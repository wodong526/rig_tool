//     AdvancedSkeleton
//     Version 6.300
//
//
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//
// INSTALLATION:
// drag`n`drop the "install.mel" file into Maya (drop in any viewport).
//
// For detailed instructions read the "install.txt" file
//
// Copyright (C)2024 Animation Studios
//
// email: support@animationstudios.com.au
// Last Modified 26/05/2024

global proc AdvancedSkeleton ()
{
global int $asBuilding;
global int $asRebuilding;
global int $asFaceIsResetting;
global string $gMainProgressBar;
global int $asFitModeScriptJobNr4;
global int $asSkipConfirm;
string $evalManagerStats[];
string $m;
string $currentUnitLinear=`currentUnit -q -f`;
$m="Units currently set to: \""+$currentUnitLinear+"\"\nAdvancedSkeleton requires \"cm\".\nClick OK to switch";
if ($currentUnitLinear!="centimeter")
	if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`=="Ok")
		currentUnit -l cm;
int $animBlendingOpt=`optionVar -q animBlendingOpt`;
if ($animBlendingOpt!=1)
	{
	optionVar -iv animBlendingOpt 1;
	print "// \"Animation Blending Option\" now switched to On.\n";
	}
if (`asMayaVersionAsFloat`>=2012)
	if (`manipMoveContext -q -ex Move`)
		if (!catchQuiet (`manipMoveContext -q -orientJointEnabled Move`))
			if (`manipMoveContext -q -orientJointEnabled Move`)
				manipMoveContext -e -orientJointEnabled 0 Move;
int $haveRanThisVersion=`optionVar -q asHaveRanThisVersion`;
int $asDock=`optionVar -q asDock`;
if (`exists dockControl`)
	if (!`optionVar -ex asDock`)
		$asDock=1;
int $asWorkspace;
int $modifier=`getModifiers`;
catchQuiet (`editDisplayLayerGlobals -useCurrent 0`);
$asBuilding=0;
$asRebuilding=0;
$asFitModeSkip=0;
$asSkipConfirm=0;
string $boldFont="smallBoldLabelFont";
if (`asMayaVersionAsFloat`<2012)
	$boldFont="plainLabelFont";
string $asScriptLocation=`asGetScriptLocation`;
string $xyz[]={"x","y","z"};
string $labels[]={"Root","Chest","Mid","Hip","Foot","Heel","Toes","ToesEnd","BigToe","PinkyToe","LegAim","QToes","Shoulder","Hand","0","1","2","3"};
string $attributes[]={"twist/bendy","inbetween","global","aim","wheel","rollingBall","freeOrient","worldOrient","flipOrient","noMirror","noFlip","noControl","noSkin",
	"ikLocal","centerBtwFeet","hipSwinger","follow","ikFollow","geoAttach","aimAt","curveGuide","rootOptions","segScaleComp","childOfPart","control","hipSwinger"};

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
if ($asFitModeScriptJobNr4!=0)
	if (!`scriptJob -ex $asFitModeScriptJobNr4`)
		$asFitModeScriptJobNr4=0;
if ($asFitModeScriptJobNr4==0)
	$asFitModeScriptJobNr4=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;

if (`exists workspaceControl`)
	if (`workspaceControl -q -ex asWorkspaceControl`)
		{
		if (`formLayout -q -ex asFormLayout`)
			deleteUI -control asFormLayout;
		setParent asWorkspaceControl;
		$asWorkspace=1;
		}
if (`exists dockControl`)
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;

if (!$asWorkspace)
	window -t AdvancedSkeleton AdvancedSkeletonWindow;

formLayout asFormLayout;
scrollLayout asScrollLayout;
columnLayout -adj 1 asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Preparation" asPreparationFrameLayout;
	columnLayout -adj 1;
		frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l "Model" asModelFrameLayout;
			columnLayout;
				text -fn $boldFont -l "This \"Preparation\" section is optional,";
				text -fn $boldFont -l "but recommended for clean file and workflow";
				separator -h 10;
				text -l "Clean :";
				text -l "Group your model, so that you have 1 top node.";
				text -l "And name this group \"geo\"";
				text -l "Then use the model-cleaner tool:";
				rowLayout -nc 4 -cw4 60 114 51 15;
					separator;
					button -w 72 -l "Model Clean" -c asModelCleaner;
					separator;
					button -w 11 -l "?" -c "asHelpImage asPreModelCleaner";
					setParent..;
				separator -h 10;
				text -l "Then save your cleaned model.";
				separator -h 5;
				text -l "Also, you can check the symmetry:";
				rowLayout -nc 4 -cw4 60 114 51 15;
					separator;
					button -w 72 -l "Model Check" -c asModelCheckerUI;
					separator;
					button -w 11 -l "?" -c "asHelpImage asPreModelChecker";
					setParent..;
				setParent..;
			setParent..;
		frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l "Rig" asRigFrameLayout;
			columnLayout -adj 1;
				if (`asIsMayaLT`)
					{
					separator -w 262 -h 10	;
					text -fn $boldFont -l "Next is to reference model-file into rig-file.";
					text -fn $boldFont -l "But MayaLT does not have referencing.";
					text -fn $boldFont -l "So, just rig the model-file instead.";
					}
				else
					{
					text -l "Create the rig file:";
					rowLayout -nc 4 -cw4 60 114 51 15;
						separator;
						button -w 72 -l "New Scene" -c NewScene;
						separator;
						button -w 11 -l "?" -c "asHelpImage asPreNewScene";
						setParent..;
					text -l "Reference-in the model:";
					rowLayout -nc 4 -cw4 60 114 51 15;
						separator;
						button -w 72 -l "Reference" -c "asReferenceBrowser 1";
						separator;
						button -w 11 -l "?" -c "asHelpImage asPreReference";
						setParent..;
					}
				columnLayout -adj 1 asBodyPreObjectsColumnLayout;
					separator -h 30 -w 262;
					text -l "Define the Objects:";
					separator -h 2 -st none;
					string $bodyInputs[]={"Skin","All","Right Eye","Left Eye"};
					for($i=0;$i<size($bodyInputs);$i++)
						{
						string $name=`substitute " " $bodyInputs[$i] ""`;
						if ($bodyInputs[$i]=="Skin") 					{}

						rowLayout -nc 3 -cw3 120 106 15;
							button -w 120 -l $bodyInputs[$i] -c ("asChooseBodyInput asBody"+$name+"TextField");
							popupMenu;
								menuItem -l "re-select" -c ("asSelectFromTextField asBody"+$name+"TextField");
							textField -w 100 -ed 0 ("asBody"+$name+"TextField");
							button -w 11 -l "?" -c ("asHelpImage BodyPre"+$name);
							setParent..;
						}
					separator -h 10 -st none;
					rowLayout -nc 4 -cw4 60 114 51 15;
						separator;
						button -l "One joint prop" -c asOneJointProp;
						separator;
						button -w 11 -l "?" -c "asHelpImage asOneJointProp";
						setParent..;
					setParent..;
				separator -h 20 -w 262;
				text -l "Options:";
				rowLayout -nc 2 -cw2 229 15;
					checkBox -l "game engine" -cc asTglBodyGameEngine asBodyGameEngineCheckBox;
					button -w 11 -l "?" -c "asHelpImage facePreGameEngine";
					setParent..;
				rowLayout -nc 2 -cw2 229 15;
					checkBox -l "Z up Axis" -cc asTglZUpAxisEngine asBodyZUpAxisCheckBox;
					button -w 11 -l "?" -c "asHelpImage asPreZUpAxis";
					setParent..;
				rowLayout -nc 2 -cw2 229 15;// -m $modifier
					checkBox -l "Offset Parent Matrix" -v 0 -cc asTglOPM asBodyOffsetParentMatrixCheckBox;
					button -w 11 -l "?" -c "asHelpImage asOffsetParentMatrix";
					setParent..;
				setParent..;
			setParent..;

		frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l "Settings" asSettingsFrameLayout;
			columnLayout;
				text -l "GUI Colors:";
				rowLayout -nc 2;
					separator -w 50 -st none;
					columnLayout asSettingsColorsColumnLayout;
						rowLayout -nc 2 -cw2 145 10;
							checkBox -l "Custom Colors" -v `optionVar -q asSettingsUseCustomColors` 
								-cc "optionVar -iv asSettingsUseCustomColors #1;asSettingsColorsRefresh;" asSettingsUseCustomColorsCheckBox;
							button -h 18 -l "reset" -c asSettingsColorsReset;
						setParent..;
						string $types[]={"Background","Level1","Level2","Buttons","DropDowns","CheckBoxes"};
						int $canFade[]={0,1,1,0};
						float $cc[];
						for($i=0;$i<size($types);$i++)
							{
							rowLayout -nc 4 -cw4 70 45 25 20 ("asSettingsColors"+$types[$i]+"RowLayout");
								{
								if ($types[$i]=="Background") $cc={0.3, 0.3, 0.4};
								if ($types[$i]=="Level1") $cc={0.4, 0.2, 0.2};
								if ($types[$i]=="Level2") $cc={0.3, 0.4, 0.3};
								if ($types[$i]=="Buttons") $cc={0.35, 0.45, 0.45};
								if ($types[$i]=="DropDowns") $cc={0.12, 0.30, 0.32};
								if ($types[$i]=="CheckBoxes") $cc={0.2, 0.3, 0.3};
								if (`optionVar -ex ("asSettingsUseCustomColors"+$types[$i])`)
									$cc=`optionVar -q ("asSettingsUseCustomColors"+$types[$i])`;
								text -l $types[$i];
								button -w 35 -l "" -bgc $cc[0] $cc[1] $cc[2] -c ("asSettingsColorsChoose "+$types[$i]) ("asSettingsColors"+$types[$i]+"Button");
								//fade
								text -l "fade" -m $canFade[$i];
								if (`optionVar -ex ("asSettingsUseCustomColors"+$types[$i]+"Fade")`)
									$cc=`optionVar -q ("asSettingsUseCustomColors"+$types[$i]+"Fade")`;
								button -w 35 -l "" -m $canFade[$i] -bgc $cc[0] $cc[1] $cc[2] -c ("asSettingsColorsChoose "+$types[$i]+"Fade") ("asSettingsColors"+$types[$i]+"FadeButton");
								setParent..;
								}
							}

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Body" asBodyFrameLayout;
columnLayout -adj 1;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asBodyFitFrameLayout;
		columnLayout -adj 0;
			text -h 10 -l "FitSkeletons:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout;
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asFitFiles;
						button -l "Import" -c asFitSkeletonImport;
						button -w 11 -l "?" -c "asHelpImage asFitSkeletons";
						setParent..;
					text -l " extra limbs:";
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asLimbFiles;
						button -l "Import" -c asFitSkeletonLimbsImport;
						button -w 11 -l "?" -c "asHelpImage asFitLimbs";
						setParent..;
					separator -h 5;
					rowLayout -nc 3 -cw3 114 49 15;
						separator -st none;
						button -h 15 -l "Export" -c asFitSkeletonExport;
						button -h 15 -w 11 -l "?" -c "asHelpImage asFitExport";
						setParent..;
					setParent..;
				setParent..;
			text -m 0 -h 10 -l "AutoPlace:" asFitAutoPlaceText;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout;
					rowLayout -m 0 -nc 3 -cw3 50 113 15 asFitAutoPlaceRowLayout;
						button -l scale -c asFitAutoScale asFitAutoScaleButton;
						button -l autoPlace -c asFitAutoPlace asFitAutoPlaceButton;
						button -h 15 -w 11 -l "?" -c "asHelpImage asFitAutoPlace";
						setParent..;
					columnLayout -m 0 asFitAutoPlaceTweaksColumnLayout;
						separator -h 5;
						rowLayout -nc 2 -cw2 165 15;
							checkBox -l "display pole-vector" -onc "asFitDisplayPoleVector 1" -ofc "asFitDisplayPoleVector 0";
							button -h 15 -w 11 -l "?" -c "asHelpImage asFitDisplayPoleVector";
							setParent..;
						rowLayout -nc 5 -cw5 73 1 80 5 15;
							button -l "straight Leg" -c "asFitStraightPoleVector Leg";
							separator -st none;
							button -l "straight Arm" -c "asFitStraightPoleVector Arm";
							separator -st none;
							button -h 15 -w 11 -l "?" -c "asHelpImage asFitStraightLimb";
							setParent..;
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Edit" asBodyEditFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 1;
				text -h 10 -l "IK-Label:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				optionMenu -cc asUpdateLabelHelp asLabelType;
				for ($label in $labels)
					menuItem -l $label;
				separator;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asLabelHelp;
				button -w 11 -l "?" -c "asHelpImage asFitLabels";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointLabel;
				button -w 72 -l "Remove" -c asRemoveFitJointLabel;
				setParent..;
			separator -h 10;
			rowLayout -nc 1;
				text -h 10 -l "Attribute:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
				optionMenu -cc asUpdateAttributeHelp asAttributeType;
				for ($attribute in $attributes)
					menuItem -l $attribute;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asAttributeHelp;
				button -w 11 -l "?" -c "asHelpImage asFitAttributes";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointAttribute;
				button -w 72 -l "Remove" -c asRemoveFitJointAttribute;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Display:";
				setParent..;
			floatSliderGrp -cw3 85 35 20 -l "joint" -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			rowLayout -h 18 -nc 4 -cw4 62 78 85 15;
				separator;
				checkBox -l "geometry" -cc "setAttr FitSkeleton.visGeo #1;asFitGeometry" asVisGeo;
				optionMenu -en 0 -cc asChangeVisGeoType asVisGeoType;
					menuItem -l "cylinders" -data 0;
					menuItem -l "boxes" -data 1;
					menuItem -l "spheres" -data 2;
					menuItem -l "bones" -data 3;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayGeometry";
				setParent..;
			floatSliderGrp -h 18 -cw3 85 35 20 -l "gap" -field 1 -min 0.01 -max 1 -pre 2 -v 0.75 -cc "setAttr FitSkeleton.visGap #1" asVisGap;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "pole-vector" -onc "asFitDisplayPoleVector 1" -ofc "asFitDisplayPoleVector 0" asVisPoleVector;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayPoleVector";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "joint-orient" -onc "asFitDisplayJointOrient 1" -ofc "asFitDisplayJointOrient 0" asVisJointOrient;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayJointOrient";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "joint-axis" -onc "asFitDisplayJointAxis 1" -ofc "asFitDisplayJointAxis 0" asVisJointAxis;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayJointAxis";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Placement:";
				setParent..;
			rowLayout -nc 6 -cw6 62 29 10 30 92 15;
				separator -st none;
				button -l "Snap" -ann "Snap joint to center of selected components" -c asPlacementSnap;
				if (`asHaveMeshCenterSnap`)
					{
					separator -st none;
					iconTextCheckBox -w 26 -h 26 -ann "Snap to Projected Center" -i "snapMeshCenter.png" -cc "snapMode -meshCenter #1" asMeshCenterSnapButton;
					}
				else
					{
					separator -st none;
					separator -st none;
					}
				checkBox -l "Lock middle" -ann "Locks the Center Joints to stay in Center" -cc asFitModeLockCenterJoints asLockCenterJoints;
				button -w 11 -l "?" -c "asHelpImage asFitPlacement";
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator -st none;
				button -l "create non-symmetry joints" -c asCreateNonSymmetryJoints;
				button -w 11 -l "?" -c "asHelpImage asFitNonSymmetryJoints";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Add Joints:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
 				$gBuffStr = `toolButton -style iconOnly -doubleClickCommand "toolPropertyWindow" -cl toolCluster `;
    		$gBuffStr1 = `jointCtx -image1 "kinJoint.png" -image2 "vacantCell.png" -image3 "vacantCell.png" -scaleCompensateJ 1
        -degreeOfFreedomJ "xyz" -jointOrientationJ 0 0 0 -scaleOrientationJ 0 0 0 -scaleJ 1 1 1 -autoJointOrient "none" 
        -secondaryAxisOrient "yup" -jointAutoLimits 0-createIKHandle 0-solverTypeH "ikSCsolver" -autoPriorityH 0
        -snapHandleH 1 -forceSolverH 1 -stickyH "off" -priorityH 1 -weightH 1 -poWeightH 1`;
				if (`asMayaVersionAsFloat`>=2012)
			    toolButton -edit -tool $gBuffStr1 -toolImage1 $gBuffStr1 "kinJoint.png" $gBuffStr;
		    toolButton -edit -tool $gBuffStr1 $gBuffStr;
		    button -w 72 -l "ReSample" -c asFitResample;
				button -w 11 -l "?" -c "asHelpImage asFitCreate";
				setParent..;
			separator;
			columnLayout asAutoOrientColumnLayout;
				rowLayout -nc 1;
					text -h 10 -l "Auto-Orient:";
					setParent..;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator -st none;
				button -w 156 -l FitMode -c asFitMode;
				button -w 11 -l "?" -c "asHelpImage asFitMode";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 82 62 81 15;
				separator -st none;
				text -l "Or, manual:";
				button -w 72 -l "Update Now" -c asFitModeManualUpdate;
				button -w 11 -l "?" -c "asHelpImage asFitUpdateNow";
				setParent..;
			separator;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asBodyBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4;
				separator -w 28 -st none;
				button -m 0 -w 60 -l "Delete Adv" -c asDeleteAdvanced asDelteAdvButton;
				separator -w 15 -st none;
				checkBox -l "Keep All" -v 1
					-onc "columnLayout -e -m 0 asBodyKeepColumnLayout"
					-ofc "columnLayout -e -m 1 asBodyKeepColumnLayout"
					asKeepAllCheckBox;
				setParent..;
			columnLayout -m 0 asBodyKeepColumnLayout;
				rowLayout -nc 2 -cw2 5 100;
					separator -st none;
					columnLayout;
						checkBox -v 1 -l "keep custom control shape and color" asKeepCurveShapesCheckBox;
						checkBox -v 1 -l "keep custom control orient" asKeepControlOrientCheckBox;
						checkBox -v 1 -l "keep custom stored buildPose" asKeepBuildPoseCheckBox;
						checkBox -v 1 -l "keep custom parenting" asKeepParentingCheckBox;
						checkBox -v 1 -l "keep custom parentConstraints" asKeepParentConstraintsCheckBox;
						checkBox -v 1 -l "keep custom lock/hide of attributes" asKeepLockHideCheckBox;
						checkBox -v 1 -l "keep custom added attributes" asKeepUserAttrsCheckBox;
						checkBox -v 1 -l "keep custom set transformLimits" asKeepLimitsCheckBox;
						checkBox -v 1 -l "keep deformations (connections)" asKeepSkinningCheckBox;
						checkBox -v 1 -l "remove unused attributes" asRemoveUnusedAttributesCheckBox;
						setParent..;
					setParent..;
				setParent..;
			rowLayout -nc 4 -cw4 5 85 5 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitAdvancedSkeleton asToggleFitSkeletonButton;
				separator -w 5 -st none;
				button -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton asBuildAdvancedSkeletonButton;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option1)" asBodyDeform1FrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 3 -cw3 100 126 15;
				separator;
				text -l "Skinning:";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinning";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				columnLayout;
					text -l "Select objects to deform, then:";  
					separator -h 5 -st none;
					button -w 140 -l "+ Select DeformJoints" -c asSelectDeformJoints;
					separator -h 5 -st none;
					button -w 140 -l "Set Smooth Bind Options" -c asSetSmoothBindOptions;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option2)" asBodyDeform2FrameLayout;
		columnLayout -adj 1;
			text -l "SkinCage:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinCage;
				button -w 60 -l "Delete" -c asDeleteSkinCage;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCage";
				setParent..;
			separator -st "none";
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 SkinCageCurvesSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 SkinCageCurvesSet";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageMirror";
				setParent..;
			separator -h 5 -st "none";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select objects to deform, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Copy weights" -c asCopySkin;
					button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCopyWeights";
					setParent..;
				setParent..;
			separator -h 10 -st none;
				rowLayout -nc 4 -cw4 60 165 64 15;
				text -l "Adjust:";
				button -w 162 -l "\"DeformationWidth\"" -c asSkinCurvesToWidth;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDWidth";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Create Groin Locators" -c asCreateGroinLocators;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCreateGroinLocators";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Adjust Groin area" -c asAdjustGroinArea;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageAdjustGroinArea";
				setParent..;
			separator -h 10 -st none;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Sliders:";
				checkBox -l "include controller" asBodySlidersIncCtrlCheckBox;
				setParent..;	
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateSliders;
				button -w 60 -l "Delete" -c asDeleteSliders;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageSliders";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Delete SkinCurves" -c asDeleteSkinCurves;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDeleteCurves";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option3)" asBodyDeform3FrameLayout;
		columnLayout -adj 1;
			text -l "SubWrap:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinSub;
				button -w 60 -l "Delete" -c asDeleteSkinSub;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapCage";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				text -l "Select objects to deform, then:";  
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Wrap selected mesh" -c asWrapSkin;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapWrap";
				setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Detach" -c asSkinSubDetach;
				button -w 60 -l "Attach" -c asSkinSubAttach;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapAttach";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Exclude selected vertices" -c asWrapExlude;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapExlude";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option4)" asBodyDeform4FrameLayout;
		columnLayout -adj 1;
			text -l "SkinLoops:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select EdgeLoop + FK control, then";
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				separator;
				checkBox -v 1 -l "mirror" asCreateSkinLoopCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Create New SkinLoop" -c "asCreateSkinLoop 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCreate";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Select All SkinLoops" -c asSelectAllSkinLoops;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsSelectAll";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to deform, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Bind" -c "asBindSkinLoops 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsBind";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "For cloth over skin, copy weighs.\nSelect cloth, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Copy" -c "asCopySkinLoopWeights";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCopy";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to CutUp, then:"; 
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "CutUp:";
				button -w 60 -l "Create" -c "asBindSkinLoops 1";
				button -w 60 -l "Delete" -c asDeleteCutUp;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCutUp";
				setParent..;
			separator -w 242 -h 5;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (DeltaMush)" asBodyDeformDeltaMushFrameLayout;
		columnLayout -adj 1;
			text -l "Delta-Mush:";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select skinned objects, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Harden weights" -c asHardenWeights;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushHarden";
					setParent..;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Apply Delta Mush" -c asApplyDeltaMush;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushApply";
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Skeleton)" asBodyGeometrySkeletonFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateSkeleton;
				button -w 60 -l "Delete" -c asDeleteSkeleton;
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Skeleton 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Skeleton 0";
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonMirror";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Muscular)" asBodyGeometryMuscularFrameLayout;
		columnLayout -adj 1;
			text -l "Make sure to create Skeleton first.";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Muscular:";
				button -w 60 -l "Create" -c asCreateMuscular;
				button -w 60 -l "Delete" -c asDeleteMuscular;
				button -w 11 -l "?" -c "asHelpImage asGeometryMuscularCreate";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (PolyBoxes)" asBodyGeometryPolyBoxesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePolyBoxes;
				button -w 60 -l "Delete" -c asDeletePolyBoxes;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Boxes 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Boxes 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Boolean:";
				button -w 60 -l "Create" -c asCreateBoolean;
				button -w 60 -l "Delete" -c asDeleteBoolean;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesBoolean";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Warp:";
				button -w 60 -l "Create" -c asCreateWarp;
				button -w 60 -l "Delete" -c asDeleteWarp;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesWarp";
				setParent..;
			setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "BoxSkin:";
				button -w 60 -l "Create" -c asCreateBoxSkin;
				button -w 60 -l "Delete" -c asDeleteBoxSkin;
				button -w 11 -l "?" -c "asHelpImage asGeometryBoxSkinCreate";
				setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Mannequin)" asBodyGeometryMannequinFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateMannequin;
				button -w 60 -l "Delete" -c asDeleteMannequin;
				button -w 11 -l "?" -c "asHelpImage asGeometryMannequinCreate";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -m 1 -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Retopology)" asBodyGeometryRetopologyFrameLayout;
		columnLayout -adj 1;
			text -l "Make sure to create SkinCage or SkinSub first.";
			separator -st none -h 5;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select Hi-res model, then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Retopo:";
				button -w 60 -l "Create" -c asCreateRetopo;
				button -w 60 -l "Delete" -c asDeleteRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoCreate";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Make any tweaks needed, then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Update selected" -c asUpdateRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoUpdate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorRetopo 1";
				button -w 60 -l "Right>Left" -c "asMirrorRetopo 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoMirror";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Normal Map" -c asNormalMapRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoNormalMap";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Bind:";
				button -w 60 -l "Bind" -c asBindRetopo;
				button -w 60 -l "UnBind" -c asUnBindRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoBind";
				setParent..;

			separator -h 15;
			rowLayout -nc 2 -cw2 130 100;
				separator -st none;
				text -h 20 -l "Face:";
				setParent..;
			rowLayout -nc 2 -cw2 90 100;
				separator -st none;
				optionMenu asCreateFaceRetopoOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
//				text -l "Guides:";
				separator -st none;
				button -w 60 -l "Create" -c asCreateFaceRetopo;
				button -w 60 -l "Delete" -c "asDeleteFaceRetopo 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoCreate";
				setParent..;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Make any tweaks needed, then:";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Match guides" -c asMatchGuidesFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoMatch";
				setParent..;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Tweak further if needed.";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Connect Body" -c asConnectBodyFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoConnect";
				setParent..;
			separator -h 10 -st none;
			rowLayout -nc 2 -cw2 90 100;
				text -l "Eyes:";
				optionMenu asCreateFaceRetopoEyeBallOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Create" -c asCreateEyesFaceRetopo;
				button -w 60 -l "Delete" -c "delete headTopologyEyes";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoEyesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "bind eyes" -c asBindEyesFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoEyesBind";
				setParent..;
			separator -h 10 -st none;
			rowLayout -nc 2 -cw2 90 100;
				text -l "Teeth:";
				optionMenu asCreateFaceRetopoTeethOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Create" -c asCreateTeethFaceRetopo;
				button -w 60 -l "Delete" -c "delete headTopologyTeeth";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoTeethCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "bind teeth" -c asBindTeethFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoTeethBind";
				setParent..;

			separator -h 10 -st none;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Face rig prep" -c asFaceRigPrepRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoPrep";
				setParent..;
			separator -h 5 -st none;
			text -l "You can now now Build Face Setup";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Skin Cut-Up)" asBodyGeometrySkinCutUpFrameLayout;
		columnLayout -adj 1;
			text -l "CutUp selected objects based on SkinWeight";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateCutUp;
				button -w 60 -l "Delete" -c asDeleteCutUp;
				button -w 11 -l "?" -c "asHelpImage asGeometrySkinCutUp";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Custom Controllers" asBodyCustomControlsFrameLayout;
	// Runs the CustomControllers Twice, once for Body, and once for Face
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Squash Controller" asBodySquashControlFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					text -l "Select vertices to be affected, then:";
					separator -h 5 -st none;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create Squash Controller" -c asCreateSquashController;
						button -w 11 -l "?" -c "asHelpImage asSquashControlCreate";
						setParent..;
					separator -h 15 -st none;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Delete Squash Controller" -c asDeleteSquashController;
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Motion System" asBodyMotionSystemFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create HumanIK" -c asCreateHumanIK;
						button -w 11 -l "?" -c "asHelpImage asCreateHuamIK";
						setParent..;
					separator -h 15 -st none;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Delete HumanIK" -c asDeleteHumanIK;
						setParent..;
/*
					separator -h 5 -st none;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Delete MotionSystem" -c asDeleteMotionSystem;
						button -w 11 -l "?" -c "asHelpImage asDeleteMotionSystem";
						setParent..;
*/
					separator -h 15 -st none;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Bake HumanIK" -c asBakeHumanIK;
						button -w 11 -l "?" -c "asHelpImage asBakeHuamIK";
						setParent..;


					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Curves" asBodyControlCurvesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 ControlSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 ControlSet";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Scale:";
				floatField -v 1 -ann "set scale-factor" ScaleCCFloatField;
				button -w 60 -l "Scale" -c "asScaleControlCurves";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesScale";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Swap:";
					button -l "import controller gallery" -c asControllerGalleryImport;
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				columnLayout;
					text -al left -l "First select Control(s) to replace,\nThen select (add) any custom curve,\nThen:";
					setParent..;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Swap Curve" -c asSwapCurve;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesSwap";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Rotate:";
				rowLayout -nc 4 -cw4 100 20 20 20;
					text -l "Snap 90 degrees:";
					button -l "x" -c "asSnapRotateCurve {1,0,0}";
					button -l "y" -c "asSnapRotateCurve {0,1,0}";
					button -l "z" -c "asSnapRotateCurve {0,0,1}";
					setParent..;
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Color:";
				int $cellHeight = 17, $cellWidth = 10;
				int $rows = 2, $columns = 16;
				palettePort -w ($columns * $cellWidth) -h ($rows * $cellHeight) -dim $columns $rows -ced 0 -td 1 asCurveColorPalettePort;
				float $colorComponentArray[];
				palettePort -edit -rgbValue 0 0 0 0 asCurveColorPalettePort;
				for ($index = 1; $index <= 31; $index++) {
					$colorComponentArray = `colorIndex -query $index`;
					palettePort -edit -rgbValue $index
						$colorComponentArray[0]
						$colorComponentArray[1]
						$colorComponentArray[2]
						asCurveColorPalettePort;
						}
				if (`asMayaVersionAsFloat`>=2014)
					palettePort -e -ced 1 asCurveColorPalettePort;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Set Color" -c asSetCurveColor;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesColor";
				setParent..;

			if (`asMayaVersionAsFloat`>=2017)
				{
				separator -h 10;
				rowLayout -nc 3 -cw3 60 50 100;
					text -l "Width:";
					intField -w 40 -v 5 -min -1 -max 100 asCurveWidthIntField;
					button -l "Set Width" -c asSetCurveWidth;
					setParent..;
				}

			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Select:";
				text -l "For selecting many controllers";
				setParent..;
			rowLayout -nc 3 -cw3 60 90 50;
				separator;
				optionMenu asControllerTypeOptionMenu;
					menuItem -l "FK";
					menuItem -l "IK";
					menuItem -l "FKIK";
					menuItem -l "Fingers";
					menuItem -l "Bend";
//					menuItem -l "Selected";
					menuItem -l "*All";
					menuItem -l "Face:A";
					menuItem -l "Face:B";
					menuItem -l "Face:C";
					menuItem -l "Face:Aim";
					menuItem -l "Face:Teeth";
					menuItem -l "Face:Tongue";
					menuItem -l "Face:Region";
					menuItem -l "Face:Squash";
					menuItem -l "Face:Custom";
				optionMenu asControllerSideOptionMenu;
					menuItem -l "Right";
					menuItem -l "Left";
					menuItem -l "Middle";
					menuItem -l "*All";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Select" -c asSelectCurve;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesColor";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Re-use:";
				text -l "This will print in the ScriptEditor:";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				columnLayout;
					text -l "commands to set control curves to";
					text -l "current shapes and colors.";
					button -w 162 -l "Script Editor" -c "ScriptEditor;";
					button -w 162 -l "Clear History" -c "scriptEditorInfo -clearHistory";
					rowLayout -nc 3;
						checkBox -l "shape" -v 1 asControlCurvesReUseShapeCheckBox;
						checkBox -l "color" -v 1 asControlCurvesReUseColorCheckBox;
						checkBox -l "`catch`" asControlCurvesReUseCatchCheckBox;
						setParent..;
					checkBox -l "ReBuild Curves" asControlCurvesReUseReBuildCurvesCheckBox;
					checkBox -l "SkinCurves" asControlCurvesReUseSkinCurvesCheckBox;
					checkBox -l "Face" asControlCurvesReUseFaceCheckBox;
					button -w 162 -l "Print Commands" -c asControlCurvesPrintInfo;
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Orient" asBodyControlOrientFrameLayout;
		columnLayout -adj 1;
			text -l "Select Controller, then:\n";

			rowLayout -nc 2 -cw2 80 120;
				separator -st none;
				button -w 80 -l "Show Axis" -c ToggleLocalRotationAxes;
				setParent..;
			separator -h 10 -st none;

			rowLayout -nc 3 -cw3 106 120 15 asControlOrientAxesRowLayout;
				optionMenu -l "Primary Axis:" -cc asControlAxisChanged asPrimaryAxisOptionMenu;
					menuItem -l "X";
					menuItem -l "Y";
					menuItem -l "Z";
					menuItem -l "-X";
					menuItem -l "-Y";
					menuItem -l "-Z";
				optionMenu -l "Secondary Axis:" -cc asControlAxisChanged asSecondaryAxisOptionMenu;
					menuItem -l "X";
					menuItem -l "Y";
					menuItem -l "Z";
					menuItem -l "-X";
					menuItem -l "-Y";
					menuItem -l "-Z";
				optionMenu -e -sl 2 asSecondaryAxisOptionMenu;
				button -w 11 -l "?" -c "asHelpImage asControlOrientAxis";
				setParent..;

			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "world-orient" -cc "rowLayout -e -en (!#1) asControlOrientAxesRowLayout;checkBox -e -en (!#1) asControlOrientWorldMatchCheckBox" asControlOrientWorldOrientCheckBox;
				button -w 11 -l "?" -c "asHelpImage asControlOrientWorldOrient";
				setParent..;

			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "world-match" -cc "rowLayout -e -en (!#1) asControlOrientAxesRowLayout;checkBox -e -en (!#1) asControlOrientWorldOrientCheckBox" asControlOrientWorldMatchCheckBox;
				button -w 11 -l "?" -c "asHelpImage asControlOrientWorldMatch";
				setParent..;

			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "mirror" -v 1 asControlOrientMirrorCheckBox;
				button -w 11 -l "?" -c "asHelpImage asControlOrientMirror";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "mirrored behaviour" -v 1 asControlOrientMirroredBehaviourCheckBox;
				button -w 11 -l "?" -c "asHelpImage asControlOrientMirroredBehaviour";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "mirrored translate" -v 0 asControlOrientMirroredTranslateCheckBox;
				button -w 11 -l "?" -c "asHelpImage asMirTrans";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "keep curve unaffected" -v 1 asControlOrientCurveUnafecctedCheckBox;
				button -w 11 -l "?" -c "asHelpImage asControlOrientCurveUnafeccted";
				setParent..;
			rowLayout -nc 2 -cw2 80 120;
				separator -st none;
				button -w 80 -l "Set Axis" -c asSetControlOrient;
				setParent..;
			separator -h 20;

			text -l "Or, for custom oriented controllers:";
			rowLayout -nc 2 -cw2 65 120;
				separator -st none;
				button -w 120 -l "Detach all controllers" -c asControlOrientDetach;
				setParent..;
			text -l "Oriented controllers, then";
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "mirror" -v 1 asControlOrientAttachMirrorCheckBox;
				button -w 11 -l "?" -c "asHelpImage ControlOrientCustom";
				setParent..;

			rowLayout -nc 2 -cw2 65 120;
				separator -st none;
				button -w 120 -l "Attach all controllers" -c asControlOrientAttach;
				setParent..;

			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Mesh" asBodyControlMeshFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2 -cw2 60 100;
				columnLayout -adj 0;
					text -l "Create:";
					setParent..;	
				columnLayout -adj 0;
					text -l "First select the poly-faces to use";
					text -l "Then select (add) the control,";
					text -l "Then:";
					checkBox -v 1 -l "mirror" asCreateControlMeshMirrorCheckBox;
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create ControlMesh" -c asCreateControlMesh;
						button -w 11 -l "?" -c "asHelpImage asControlMeshCreate";
						setParent..;
					separator -h 5;
					text -l "Or, select mesh and auto-create";
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create ControlMeshes" -c asCreateControlMeshes;
						button -w 11 -l "?" -c "asHelpImage asControlMeshesCreate";
						setParent..;
					separator -h 5;
					text -l "For colorized ControlMeshes";
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Colorize Meshes" -c asColorizeControlMeshes;
						button -w 11 -l "?" -c "asHelpImage asControlMeshesColorize";
						setParent..;
					separator -h 5;
					text -l "IK controls & driving-systems";
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create IK ControlMeshes" -c asCreateIKControlMeshes;
						button -w 11 -l "?" -c "asHelpImage asControlMeshesCreateIK";
						setParent..;
					setParent..;	
				setParent..;	
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				columnLayout -adj 0;
					text -l "Delete:";
					setParent..;	
				columnLayout -adj 0;
					button -w 162 -l "Delete Selected" -c asDeleteControlMesh;
					separator -h 5;
					button -w 162 -l "Delete All" -c asDeleteAllControlMesh;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Game Engine" asBodyGameEngineFrameLayout;
		columnLayout -adj 0;
			text -l "Root Motion Joint:";
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateGameEngineRootMotion;
				button -w 60 -l "Delete" -c asDeleteGameEngineRootMotion;
				button -w 11 -l "?" -c "asHelpImage asGameEngineRootMotion";
				setParent..;
			separator -h 15 -st none;
			text -l "Scale Behaviour:";
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Enable" -c "asGameEngineScaling 1";
				button -w 60 -l "Disable" -c "asGameEngineScaling 0";
				button -w 11 -l "?" -c "asHelpImage asGameEngineScaleBehaviour";
				setParent..;
			separator -h 25 -st none;
			text -l "Custom oriented GameSkeleton:";
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				columnLayout;
					optionMenu -l "Space:" asCustomOrientJointsSpaceOptionMenu;
						menuItem -l "Local";
						menuItem -l "World";
					optionMenu -l "FrontAxis:" asCustomOrientJointsFrontOptionMenu;
					for ($z=0;$z<size($xyz);$z++)
						menuItem -l $xyz[$z];
					setParent..;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCustomOrientJointsCreate;
				button -w 60 -l "Delete" -c asCustomOrientJointsDelete;
				button -w 11 -l "?" -c "asHelpImage asCustomOrientCreateJoints";
				setParent..;
			rowLayout -nc 2;
				separator -w 110 -st none;
				button -l "Show Axis" -c asCustomOrientJointsShowAxis;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Connect" -c asCustomOrientJointsConnect;
				button -w 60 -l "Disconnect" -c asCustomOrientJointsDisconnect;
				button -w 11 -l "?" -c "asHelpImage asCustomOrientConnect";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Transfer Skinning" -c asCustomOrientTransferSkin;
				button -w 11 -l "?" -c "asHelpImage asCustomOrientTransferSkin";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Unreal Joints" asBodyUnrealJointsFrameLayout;
		columnLayout -adj 0;
			text -l "Unreal Mannequin Skeleton:";
			rowLayout -nc 2 -cw2 100 100;
				separator -st none;
				button -l "Read This first" -c asCreateUnrealMannequinReadThis;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateUnrealMannequinJoints;
				button -w 60 -l "Delete" -c asDeleteUnrealMannequinJoints;
				button -w 11 -l "?" -c "asHelpImage asUnrealCreateMannequinJoints";
				setParent..;
			separator -h 5;
			rowLayout -nc 3 -cw3 60 166 15;
				separator ;
				button -w 162 -l "Transfer Skinning" -c asUnrealMannequinTransferSkin;
				button -w 11 -l "?" -c "asHelpImage asUnrealMannequinTransferSkin";
				setParent..;
			rowLayout -nc 2 -cw2 120 300;
				separator -h 30;
				text -l "OR:";
				setParent..;
			text -l "Rename joints to Mannequin names:";
			rowLayout -nc 3 -cw3 60 168 15;
				separator -st none;
				button -w 140 -l "Rename to Unreal" -c asExportRenameToUnreal;
				button -w 11 -l "?" -c "asHelpImage asRenameToUnreal";
				setParent..;
			rowLayout -nc 3 -cw3 60 168 15;
				separator -st none;
				button -w 140 -l "Restore" -c asExportRenameRestore;
				button -w 11 -l "?" -c "asHelpImage asRenameToUnrealRestore";
				setParent..;

			checkBox -l "more" -cc "frameLayout -e -m #1 asUnrealMoreFrameLayout";
			frameLayout -m 0 -l "more options:" asUnrealMoreFrameLayout;

				text -l "Unreal Root & IK joints:";
				rowLayout -nc 4 -cw4 60 100 64 15;
					separator;
					button -w 60 -l "Create" -c asCreateUnrealJoints;
					button -w 60 -l "Delete" -c asDeleteUnrealJoints;
					button -w 11 -l "?" -c "asHelpImage asUnrealCreateJoints";
					setParent..;
				text -al left -l "Unreal TwistJoints hierarchy:";
				rowLayout -nc 4 -cw4 60 100 64 15;
					separator;
					button -w 60 -l "Create" -c "asUnrealTwistJointsBehaviour 1";
					button -w 60 -l "Delete" -c "asUnrealTwistJointsBehaviour 0";
					button -w 11 -l "?" -c "asHelpImage asUnrealTwistJointsHierarchy";
					setParent..;
				setParent..;	

			setParent..;	
		setParent..;	

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Partial Joints" asBodyPartialJointsFrameLayout;
		columnLayout -adj 1;
			text -l "Partial Joints:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				checkBox -l "include controller" asBodyPartialJointsIncCtrlCheckBox;
				setParent..;	
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePartialJoints;
				button -w 60 -l "Delete" -c asDeletePartialJoints;
				button -w 11 -l "?" -c "asHelpImage asPartialJoints";
				setParent..;

			separator -h 10 -st none;
			text -l "Multi Partial Joints:";
			intFieldGrp -v1 12 -cw2 100 40 -l "joints:" multiPartialJointsIntFieldGrp;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				checkBox -l "auto-bind" asBodyMultiPartialJointsBindCheckBox;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateMultiPartialJoints;
				button -w 60 -l "Delete" -c asDeletePartialJoints;
				button -w 11 -l "?" -c "asHelpImage asMultiPartialJoints";
				setParent..;

			setParent..;	
		setParent..;	

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Face" asFaceFrameLayout;
columnLayout -adj 1 asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Pre" asFacePrepFrameLayout;
		columnLayout -adj 1 asFacePreColumnLayout;
			separator -h 7 -st none;
			string $faceInputs[]={"Mask","Face","All Head","Right Eye","Left Eye","Upper Teeth","Lower Teeth","Tongue","Eyebrow","Eyelash","Extras"};
			for($i=0;$i<size($faceInputs);$i++)
				{
				string $name=`substitute " " $faceInputs[$i] ""`;
				if ($faceInputs[$i]=="Mask") 					{text -l "Polygons:";}
				if ($faceInputs[$i]=="Face") 					{separator -h 7 -st none;text -l "Objects:";}
				if ($faceInputs[$i]=="Upper Teeth") 	{separator -h 7 -st none;text -l "Optional:";}

				rowLayout -nc 3 -cw3 120 100 15;
					button -w 120 -l $faceInputs[$i] -c ("asChooseInput asFace"+$name+"TextField");
					popupMenu;
						menuItem -l "re-select" -c ("asSelectFromTextField asFace"+$name+"TextField");
					textField -w 100 -ed 0 ("asFace"+$name+"TextField");
					button -w 15 -l "?" -c ("asHelpImage facePre"+$name);
					setParent..;
				}
			separator -h 10;
			rowLayout -nc 2 -h 20;
				separator -w 80 -st none;
				button -l "Model Check" -c asFaceModelCheck;
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 222 15;
				optionMenu -l "rig-type:" -w 180 -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceRigTypeOptionMenu;
					menuItem -l "Joints";
					menuItem -l "BlendShapes" asFaceRigTypeBlendShapesMenuItem;
					menuItem -l "Mixed" asFaceRigTypeMixedMenuItem;
					optionMenu -e -v "Joints" asFaceRigTypeOptionMenu;
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreRigType";
				setParent..;

			rowLayout -nc 2 -cw2 222 15;
				optionMenu -l "include :" -w 180 -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceIncludeOptionMenu;
					menuItem -l "Complete";
					menuItem -l "Skip Above Eyes";
					menuItem -l "Skip Below Eyes";
					menuItem -l "Skip Above+Below Eyes";
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreInclude";
				setParent..;

			rowLayout -nc 2 -cw2 222 15;
				optionMenu -l "lip-ctrls :" -w 180 -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceLipCtrlsOptionMenu;
					menuItem -l "12";
					menuItem -l "16";
					menuItem -l "20";
					menuItem -l "24";
					optionMenu -e -v "12" asFaceLipCtrlsOptionMenu;
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreLipCtrls";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "non symmetrical" -onc "asFaceSwitchSide 1;" -ofc "asFaceSwitchSide 2;" asFaceNonSymCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreNonSym";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "simpler eyeLid" -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceSimplerEyeLidCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage asSimplerEyeLid";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "game engine" -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceGameEngineCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreGameEngine";
				setParent..;

			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "multi skinclusters" -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceMultiSkinClustersCheckBox;
				if (`asMayaVersionAsFloat`<2024)
					checkBox -e -en 0 -v 0 asFaceMultiSkinClustersCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage faceMultiSkinClusters";
				setParent..;

			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "phonemes" -v 1 -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFacePhonemesCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage asPhonemes";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "emotions" -v 1 -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceEmotionsCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage asEmotions";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "apple arkit" -cc "checkBox -e -v 0 asFaceSnapChatCheckBox;asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceARKitCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreARKit";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "snap chat" -cc "checkBox -e -v 0 asFaceARKitCheckBox;asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceSnapChatCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreSnapChat";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l "roblox head" -cc "asFaceUpdateInfo 0;asUpdateButtonEnables;" asFaceRobloxHeadCheckBox;
				button -w 15 -h 15 -l "?" -c "asHelpImage faceRobloxHead";
				setParent..;
			rowLayout -nc 2 -cw2 222 15;
				checkBox -l advanced -onc "columnLayout -e -m 1 asFaceAdvancedinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceAdvancedinputColumnLayout";
				button -w 15 -h 15 -l "?" -c "asHelpImage facePreAdvanced";
				setParent..;
			textField -m 0 asFaceNonSymSideTextField;
			separator -w 70 -h 10;
			columnLayout -m 0 asFaceAdvancedinputColumnLayout;
				columnLayout -m 0 asFaceAdvancedinputGameEngineColumnLayout;
					checkBox -l "use max influences:" -cc "asFaceUpdateInfo 0;" asFaceUseMaxInfCheckBox;
					optionMenu  -l "max influences:" -cc "asFaceUpdateInfo 0;" asFaceMaxInfOptionMenu;
						menuItem -l "4";
						menuItem -l "8";
					setParent..;
				separator -h 15;
				text -l "For creating FaceSetup,";
				text -l "without AdvancedSkeleton body rig:";
				separator -h 5;
				rowLayout -nc 2 -cw 1 120;
					button -w 120 -l "Choose Head Joint" -c "asChooseInput asFaceHeadJointTextField";
				textField -w 100 -ed 0 -tx "Head_M" asFaceHeadJointTextField;
					setParent..;
				text -l "SkinCluster found on Face Geo:";
				textField -w 150 -m 1 asFaceSkinClusterTextField;
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asFaceFitFrameLayout;
		columnLayout -adj 0 asFaceFitColumnLayout;
			columnLayout -m 0 asFaceNonSymColumnLayout;
				rowLayout -nc 2;
					button -w 120 -l "Right" -c "asFaceSwitchSide 1";
					button -w 120 -l "Left" -c "asFaceSwitchSide 0";
					setParent..;
				rowLayout -nc 2;
					separator -w 70 -st none;
					button -h 18 -l " show both sides " -c asFaceShowBothSides;
					setParent..;
				separator -h 15 -st none;
				setParent..;
		string $parts[]={"Outer","Main","Inner"};
		int $upAndLo[],$mainAndOuter[],$isSphere[],$mid[];
		string $shadingGroup[];
		$c=-1;
		$c++;$sections[$c]="EyeBall";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="";$mid[$c]=0;
		$c++;$sections[$c]="EyeLid";$upAndLo[$c]=1;$mainAndOuter[$c]=1;$isSphere[$c]=0;$shadingGroup[$c]="";$mid[$c]=0;
		$c++;$sections[$c]="Lip";$upAndLo[$c]=1;$mainAndOuter[$c]=1;$isSphere[$c]=0;$shadingGroup[$c]="";$mid[$c]=1;
		$c++;$sections[$c]="EyeBrowInner";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asGreenSG";$mid[$c]=0;
		$c++;$sections[$c]="EyeBrowOuter";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="EyeBrowCenter";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=1;
		$c++;$sections[$c]="EyeBrowMid1";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="EyeBrowMid2";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="EyeBrowMid3";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="ForeHead";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="";$mid[$c]=0;
		$c++;$sections[$c]="JawPivot";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$mid[$c]=0;
		$c++;$sections[$c]="JawCorner";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$mid[$c]=0;
		$c++;$sections[$c]="JawLine";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$mid[$c]=0;
		$c++;$sections[$c]="Jaw";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$mid[$c]=1;
		$c++;$sections[$c]="ChinCrease";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=1;
		$c++;$sections[$c]="Throat";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$mid[$c]=1;
		$c++;$sections[$c]="Cheek";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asGreenSG";$mid[$c]=0;
		$c++;$sections[$c]="CheekBone";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$mid[$c]=0;
//		$c++;$sections[$c]="CheekRaiser";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="SmileBulge";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=0;
		$c++;$sections[$c]="FrownBulge";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=0;
		$c++;$sections[$c]="Nose";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asGreenSG";$mid[$c]=1;
		$c++;$sections[$c]="NoseUnder";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=1;
		$c++;$sections[$c]="NoseCorner";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="NoseSide";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=0;
		$c++;$sections[$c]="NoseBridge";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=1;
		$c++;$sections[$c]="Nostril";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$mid[$c]=0;
		$c++;$sections[$c]="Tongue";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="asBlueSG";$mid[$c]=1;
		$c++;$sections[$c]="Pupil";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="Iris";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="asGreenSG";$mid[$c]=0;
		$c++;$sections[$c]="UpMidLo";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="asGreenSG";$mid[$c]=1;
//		$c++;$sections[$c]="SmileLine";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="asRedSG";$mid[$c]=0;
		$c++;$sections[$c]="EyeLidMain2";$upAndLo[$c]=1;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="asGreenSG";$mid[$c]=0;
		int $hideable;
		for ($c=0;$c<size($sections);$c++)
			{
			$hideable=0;
			if ($sections[$c]=="EyeBall")
				{text -l "no selection needed:";$hideable=1;}
			if ($sections[$c]=="EyeLid")
				{
				separator -st none -h 10;
				text -l "select EdgeLoops:";
				}
			if ($sections[$c]=="ForeHead")
				{
				setParent asFaceFitAboveEyeColumnLayout;
				separator -st none -h 10;
				}
			if ($sections[$c]=="Lip" || $sections[$c]=="JawPivot" || $sections[$c]=="Tongue" || $sections[$c]=="JawPivot")
				{
				setParent asFaceFitColumnLayout;
				separator -st none -h 10;
				}
			if ($sections[$c]=="Lip")
				columnLayout -p asFaceFitColumnLayout asFaceFitBelowEyeColumnLayout1;
			if ($sections[$c]=="EyeBrowInner")
				columnLayout -p asFaceFitColumnLayout asFaceFitAboveEyeColumnLayout;
			if ($sections[$c]=="JawPivot")
				columnLayout -p asFaceFitColumnLayout asFaceFitBelowEyeColumnLayout2;
			if ($sections[$c]=="EyeBrowInner" || $sections[$c]=="JawPivot")
				text -l "select 1 vertex:";
			if ($sections[$c]=="EyeBrowMid1")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra EyeBrow controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraEyeBrowFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="SmileLine")
				{
				setParent asFaceFitColumnLayout;
				separator -st none -h 10;
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional SmileLine:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraSmileLineFrameLayout;
					columnLayout;
					text -l "select Edges:";
				}
			if ($sections[$c]=="EyeLidMain2")
				{
				setParent asFaceFitColumnLayout;
				separator -st none -h 10;
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra EyeLidMain:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitEyeLidMain2FrameLayout;
					columnLayout;
					text -l "For high polycount models:";
				}
			if ($sections[$c]=="Nose")
				separator -h 10 -st none;
			if ($sections[$c]=="ForeHead")
				{
				text -l "select 3 vertices:";
				$hideable=1;
				}
			if ($sections[$c]=="Tongue")
				{
				frameLayout -mw 16 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional tongue:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitTongueTeethFrameLayout;
					columnLayout;
					text -l "(No selection needed)";
				}
			if ($sections[$c]=="Pupil")
				{
				setParent asFaceFitColumnLayout;
				separator -st none -h 10;
				frameLayout -mw 16 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional pupil:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitPupilFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="UpMidLo")
				{
				setParent asFaceFitColumnLayout;
				separator -st none -h 10;
				frameLayout -mw 16 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional UpMidLo:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitUpMidLoFrameLayout;
					columnLayout;
					text -l "(No selection needed)";
				}
			for ($a=0;$a<size($parts);$a++)
				{
				if ($mainAndOuter[$c]==0) $parts[$a]="";
				else $parts={"Outer","Main","Inner"};
				if ($sections[$c]=="EyeBrow" && $parts[$a]=="Inner")
					continue;
				if ($mainAndOuter[$c]==0 && $a>0)
					continue;
				$checkValue=`objExists ("FaceFit"+$sections[$c]+$parts[$a])`;
				rowLayout -nc 7;
					button -w 100 -l ($sections[$c]+$parts[$a]) -c ("asCreateFaceFit "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]+" "+$mainAndOuter[$c]+" "+$isSphere[$c]+" \""+$shadingGroup[$c]+"\"");
					popupMenu;
						menuItem -l "re-select" -c ("asFaceFitReSelect "+$sections[$c]+" \""+$parts[$a]+"\"");//since $parts can be blank
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]+$parts[$a]) ("asFaceFit"+$sections[$c]+$parts[$a]);
					button -w 15 -l "?" -c ("asHelpImage fitFace"+$sections[$c]+$parts[$a]);
					if ($parts[$a]=="Inner")
						button -w  35 -l "assist" -c ("asFaceAssist "+$sections[$c]);
					else
						separator -w 35 -st none;
					if ($hideable || (($sections[$c]=="EyeLid" || $sections[$c]=="Lip") && $parts[$a]=="Inner"))
						button -l "hide" -c ("asFaceFitHide \""+$sections[$c]+"\" \""+$parts[$a]+"\"");
					text -m 0 -l $mid[$c] ("asFaceFitText"+$sections[$c]+$parts[$a]);
					setParent..;
				}
			}
		setParent..;
		setParent..;
		separator -h 7 -st none;
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asFaceBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4;
				separator -w 28 -st none;
				button -m 0 -w 60 -l "Delete Adv" -c asDeleteAdvancedFace asDelteAdvFaceButton;
				separator -w 15 -st none;
				checkBox -m 0 -l "Keep All" -v 1
					-onc "columnLayout -e -m 0 asFaceKeepColumnLayout"
					-ofc "columnLayout -e -m 1 asFaceKeepColumnLayout"
					asFaceKeepAllCheckBox;
				setParent..;
			columnLayout -m 0 asFaceKeepColumnLayout;
				rowLayout -nc 2 -cw2 5 100;
					separator -st none;
					columnLayout;
						checkBox -v 1 -l "keep Skin weights" asFaceKeepSkinWeightsCheckBox;
						checkBox -v 1 -l "keep HeadSquash" asFaceKeepHeadSquashCheckBox;
						checkBox -v 1 -l "keep DrivingSystems" asFaceKeepDrivingSystemsCheckBox;
						checkBox -v 0 -en 0 -l "keep BlendShapes" asFaceKeepBlendShapesCheckBox;//not yet available
						checkBox -v 1 -l "keep CorrectiveShapes" asFaceKeepCorrectiveShapesCheckBox;//not yet available
						checkBox -v 1 -l "keep shape and color of controls" asFaceKeepCurveShapesCheckBox;
						checkBox -v 1 -l "keep CustomControls" asFaceKeepCustomControlsCheckBox;
						checkBox -v 0 -l "manually run Restore Step" asFaceManuallyRunRestoreStepCheckBox;
						setParent..;
					setParent..;
				setParent..;
			rowLayout -nc 4 -cw4 5 85 20 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitFace asToggleFitFaceButton;
				separator -w 20 -st none;
				button -l "Build AdvancedFace" -c asBuildAdvancedFace asBuildAdvancedFaceButton;
				setParent..;
			setParent..;
		setParent..;
	string $stepBuildText[];
	$stepBuildText[size($stepBuildText)]="";
	$stepBuildText[size($stepBuildText)]="Prep";
	$stepBuildText[size($stepBuildText)]="CtrlBox";
	$stepBuildText[size($stepBuildText)]="EyeBall";
	$stepBuildText[size($stepBuildText)]="EyeLid";
	$stepBuildText[size($stepBuildText)]="EyeBlink";
	$stepBuildText[size($stepBuildText)]="Lip";
	$stepBuildText[size($stepBuildText)]="LipFalloff";
//	$stepBuildText[size($stepBuildText)]="LipCorner";
	$stepBuildText[size($stepBuildText)]="FaceCage";
	$stepBuildText[size($stepBuildText)]="CageToSkin";
	$stepBuildText[size($stepBuildText)]="EyeBrow";
	$stepBuildText[size($stepBuildText)]="Squint";
	$stepBuildText[size($stepBuildText)]="SmilePull";
	$stepBuildText[size($stepBuildText)]="FrownPull";
//	$stepBuildText[size($stepBuildText)]="NarrowPull";
	$stepBuildText[size($stepBuildText)]="Cheek";
	$stepBuildText[size($stepBuildText)]="CheekRaiser";
	$stepBuildText[size($stepBuildText)]="JawWeighing";
	$stepBuildText[size($stepBuildText)]="JawOpen";
	$stepBuildText[size($stepBuildText)]="LipUp";
	$stepBuildText[size($stepBuildText)]="LipDown";
	$stepBuildText[size($stepBuildText)]="LipSide";
//	$stepBuildText[size($stepBuildText)]="Nose";
	$stepBuildText[size($stepBuildText)]="Snarl";
	$stepBuildText[size($stepBuildText)]="Tongue";
	$stepBuildText[size($stepBuildText)]="Regions";
	$stepBuildText[size($stepBuildText)]="EyeAim";
	$stepBuildText[size($stepBuildText)]="UpMidLo";
	$stepBuildText[size($stepBuildText)]="Phonemes";
	$stepBuildText[size($stepBuildText)]="Emotions";
	$stepBuildText[size($stepBuildText)]="Finish";
	$stepBuildText[size($stepBuildText)]="RebuildRestore";
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build ..." asFaceStepBuildFrameLayout;
		columnLayout -adj 0 asStepBuildColumnLayout;
			separator -h 5;
			columnLayout ("asStepBuildColumnLayout0");
				text -l "Step Builder:";
				text -fn $boldFont -l "Use this section if normal Build had errors,";
				text -fn $boldFont -l "or to modify the build result.";
				separator -h 5;
				rowLayout -nc 2 -cw2 159 80 ("asStepBuildRowLayout0");
					setParent..;
				setParent..;
			for ($i=1;$i<size($stepBuildText);$i++)
				{
				$sbt=$stepBuildText[$i];
				setParent asStepBuildColumnLayout;
				columnLayout;
				rowLayout -nc 2 -cw2 159 80 ("asStepBuildRowLayout"+$i);
					text -l ($i+" : "+$stepBuildText[$i]) ("stepBuild"+$i+"Text");
					button -w 80 -h 15 -l "Build" -c (";asStepBuildPrep "+$i+";asFace"+$stepBuildText[$i]+";asStepBuildComplete "+$i+";");
					setParent..;
					columnLayout -adj 1 ("asStepBuildColumnLayout"+$i);

				if ($stepBuildText[$i]=="LipFalloff")
					{
					text -l "   You can now test the controller.";
					text -l "   If the area is to small or too big,";
					rowLayout -nc 7 -cw 1 10 ;
						separator -st none;
						text -l "Outside:";
						intField -w 22 -v 3 -min 0 -cc ("setAttr FaceFitSkeleton.vtxsFromLipToNose `intField -q -v lipFalloffOuterIntField`") lipFalloffOuterIntField;
						text -l "Inside:";
						intField -w 22 -v 2 -min 0 lipFalloffInnerIntField;
						text -l "Iterations:";
						intField -w 22 -v 5 -min 0 lipFalloffIterationsIntField;
						setParent..;
					separator -st none -h 5;
					rowLayout -nc 5 -cw 1 20 -cw 3 10;
						separator -st none;
						button -w 40 -l "test" -c "createNode -n asFaceLipFalloffTest transform;asFaceLipFalloff;";
						separator -st none;
						button -w 40 -l "update" -c "createNode -n asFaceLipFalloffUpdate transform;asFaceLipFalloff;print \"// Updated\\n\"";
						setParent..;
					separator -st none -h 10;
					}
/*
				if ($stepBuildText[$i]=="LipCorner")
					{
					text -l "   Smoothing Lip Corner.";
					rowLayout -nc 5 -cw 1 10 ;
						separator -st none;
						text -l "Numer of Vertices to smooth:";
						intField -w 22 -v 3 -min 0 lipCornerIntField;
						button -w 40 -l "update" -c "asFaceLipCornerUpdate;print \"// Updated\\n\"";
						setParent..;
					separator -st none -h 10;
					}
*/
				if ($stepBuildText[$i]=="CageToSkin")
					{
					text -l "   Smoothing.";
					rowLayout -nc 5 -cw 1 10 ;
						separator -st none;
						text -l "Number of Vertices to smooth:";
						intField -w 22 -v 1 -min 0 faceCageIntField;
						button -w 40 -l "update" -c "asFaceCheekCageSmoothUpdate;print \"// Updated\\n\"";
						setParent..;
					separator -st none -h 10;
					}
				if ($stepBuildText[$i]=="JawWeighing")
					{
					rowLayout -nc 2 -cw2 200 80;
						text -al left -l "   3:Edit curves to define weighting.\n       (do this at frame 0)";
						button -w 15 -h 12 -l "?" -c "asHelpImage fitFaceJawCurvesTweak";
						setParent..;
					rowLayout -nc 2 -cw2 190 80;
						text -l "   4:Set number of weight-smooths";
						intField -w 35 -v 50 asFaceNumJawSmooths;
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "       After any adjustments, then:";
						button -w 40 -h 12 -l "update" -c "asFaceWeightLips;asFaceUpdateJawCurvesWeights;print \"// Updated\\n\"";
						setParent..;
					rowLayout -nc 2 -cw2 190 80;
						text -l "   5:You can also paint Jaw-weights:";
						shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" -dcc "ArtPaintSkinWeightsTool;toolPropertyWindow;"
			        -image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c "select JawOpenLayer;ArtPaintSkinWeightsTool;";
						setParent..;
					}
				if ($stepBuildText[$i]=="SmileBulge")
					text -l "   Adjust controller, to shape the SmileBulge.";
				if ($stepBuildText[$i]=="Frown")
					text -l "   Adjust controller, to shape the Frown.";
				if ($stepBuildText[$i]=="EyeBall")
					text -h 12 -l "   You can now test eye rotation.";
				else if ($stepBuildText[$i]=="EyeLid")
					text -l "   You can now test fleshy-eye.";
				else if ($sbt=="EyeBlink" || $sbt=="CheekRaiser" || $sbt=="Squint" || $sbt=="SmilePull" || $sbt=="FrownPull"  || $sbt=="NarrowPull" 
					 || $sbt=="Cheek" || $sbt=="JawWeighing" || $sbt=="JawOpen" || $sbt=="LipUp" || $sbt=="LipDown" || $sbt=="LipSide" || $sbt== "Snarl")
					 	{
					 	rowLayout -h 12 -nc 2 -adj 1;
							text -l "   Scrub time-slider to check" ("asStepBuildScrubText"+$i);
							popupMenu;
								menuItem -l "Ok, finish step" -c ("asFace"+$stepBuildText[$i]+"Finish;");
							button -h 12 -w 15 -l "?" -c ("asHelpImage asScrub");
							setParent..;
						}
				else
					separator -h 12 -st none;

				separator -w 240;
				}
			setParent..;
		rowLayout -nc 2;
			separator -w 80 -st none;
			button -h 15 -l "reset steps" -c asFaceResetBuildStep;
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Layers" asFaceSkinLayersFrameLayout;
		rowLayout -nc 2 -cw2 15 500;
			separator;
		columnLayout;
			rowLayout -nc 2 -cw2 209 18;
				text -l "  Show SkinLayer:";
				button -w 11 -l "?" -c "asHelpImage asShowLayer";
				setParent..;
			button -w 100 -l "Normal" -c "asShowLayer Normal";
			separator -h 5;
			columnLayout asFaceSkinLayersColumnLayout;
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Tweaks" asFaceTweaksFrameLayout;
		columnLayout;
		separator -h 5 -w 240 -st none;
		text -al left -l "Swap controllers to Spheres:";
		checkBox -l "keep offset" asFaceSwapControlsKeepOffsetCheckBox;
		button -w 80 -l "Swap" -c asFaceSwapControlsToSpheres;
		separator -h 15 -w 240;
		rowLayout -nc 2 -cw2 130 80;
			text -l "Paint skin-weights:";
			shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" -dcc "ArtPaintSkinWeightsTool;toolPropertyWindow;"
				-image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c asFacePaintSkinWeights;
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "asJointsVisibility 0";
			button -w 60 -l "Show" -c "asJointsVisibility 1";
			setParent..;
		separator -h 15 -w 240;
		text -al left -l "For custom oriented controllers:";
		rowLayout -nc 2 -cw2 228 15;
			button -w 150 -l "Detach controllers" -c asFaceDetachControllers;
			button -w 11 -l "?" -c "asHelpImage asFaceDetachControllers";
			setParent..;
		text -al left -l "Orient controllers, then";
		button -w 150 -l "Attach controllers" -c asFaceAttachControllers;
		separator -h 15 -w 240;
		text -al left -l "For custom weight tweaks:";
		rowLayout -nc 3;
			button -l "select eyeBrowArea" -c "select eyeBrowArea";
			separator -st none -w 13;
			button -l "select -d eyeBrowLine" -c "select -d eyeBrowLineArea";
			setParent..;
		rowLayout -nc 3;
			button -w 110 -l "select eyeLidArea" -c "select eyeLidArea";
			separator -st none -w 13;
			button -l "select -d eyeLidMain" -c "select -d eyeLidMainArea";
			setParent..;
		rowLayout -nc 3;
			button -w 110 -l "select eyeLidOuter" -c "select eyeLidOuterArea";
			setParent..;
		rowLayout -nc 3;
			button -w 110 -l "select lipArea" -c "select lipArea";
			separator -st none -w 13;
			button -l "select -d lipMain" -c "select -d lipMainArea";
			setParent..;
		button -w 110 -l "select lipFalloffArea" -c "select lipFalloffArea";
		separator -h 5 -st none;
		rowLayout -nc 4;
			separator -w 20 -st none;
			text -l "Iterations:";
			intField -w 30 -v 5 asWeightHammerVertsIterationsIntField;
			button -w 110 -l "WeightHammerVerts" -c asTweakWeightHammerVerts;
			setParent..;
		separator -h 15 -w 240;
		button -l "Add MetaHuman Control Panel" -c "asFaceAddMetaHumanControlPanel";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " DeltaMush" asFaceDeltaMushFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Create DeltaMush" -c asFaceDeltaMush;
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Delete DeltaMush" -c "if (`objExists asFaceDeltaMush`)delete asFaceDeltaMush;";
				setParent..;
			separator -st "none" -h 15;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Select eyeLidArea" -c "select eyeLidArea";
				setParent..;
			separator -st "none" -h 5;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Select lipArea" -c "select lipArea";
				setParent..;
			separator -st "none" -h 15;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "zero weight selected" -c asFaceDeltaMushZeroWeight;
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 2 100 80;
				separator -st "none";
				text -l "Paint DeltaMush:";
				shelfButton -w 34 -h 34 -ann "Paint DeltaMush weights" -l "Paint DeltaMush" -dcc "toolPropertyWindow;"
	        -image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c "asFacePaintDeltaMush";
				setParent..;
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " HeadSquash" asFaceSquashFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 2 -cw2 15 211;
				separator -st none -w 15;
				columnLayout -adj 0;
					separator -st "none" -h 10;
					button -w 150 -l "Create HeadSquash" -c "asAdvancedSquash";
					separator -st "none" -h 10;
					button -w 150 -l "Delete HeadSquash" -c "asDeleteHeadSquash";
					separator -st "none" -h 10;
					text -fn $boldFont -l "To make sure only head";
					text -fn $boldFont -l "and no other parts of body gets squashed";
					button -w 150 -l "Optimize HeadSquash" -c "asOptimizeSquash";
					separator -st "none" -h 10;
					text -fn $boldFont -l "To make other object also be affecter e.g. hair";
					text -fn $boldFont -l "Select the object, then use this:";
					button -w 150 -l "Include selected object" -c "asAddToHeadSquash";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " WrinkleMap" asFaceWrinkleMapFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2;
				separator -w 50 -st none;
				columnLayout -adj 1;
					button -w 150 -l "Wrinkle Curves" -c "asWrinkleCurves";
					setParent..;
				setParent..;
			rowLayout -nc 2;
				separator -w 50 -st none;
				columnLayout -adj 1;
					button -w 150 -l "Wrinkle Map" -c "asWrinkleMap";
					setParent..;
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2;
				separator -w 5 -st none;
				columnLayout -adj 1;
					string $wrinkles[]={"ForeHead","Frown","CrowsFeet","BunnyLines","SmileLine","All"};
					for ($i=0;$i<size($wrinkles);$i++)
						{
						if ($wrinkles[$i]=="All")
							separator -h 5 -st none;
						rowLayout -nc 5;
							text -w 70 -l $wrinkles[$i];
							button -l "curves" -c ("asWmEdit "+$wrinkles[$i]+" Curves");
							button -l "mask" -c ("asWmEdit "+$wrinkles[$i]+" Mask");
							separator -st none -w 10;
							button -l "test" -c ("asWmEdit "+$wrinkles[$i]+" Test");
							setParent..;
						}
					separator -h 15 -st none;
					text -l "After editing, then:";
					rowLayout -en 0 -nc 5 -cw5 60 55 15 55 52 asWmEditApplyCancelRowLayout;
						separator -st none;
						button -w 50 -l "Apply" -c asWmEditApply asWmEditApplyButton;
						text -l "or";
						button -w 50 -l "Cancel" -c asWmEditCancel;
						setParent..;
					setParent..;
				setParent..;
			text -l "Maps:";
			rowLayout -nc 2;
				separator -w 50 -st none;
				columnLayout;
					rowLayout -nc 3;
						button -l "Set Folder" -c asWmSetFolder;
						separator -w 5 -st none;
						button -l "Open Folder" -c asWmOpenFolder;
						setParent..;
					separator -h 5 -st none;
					rowLayout -nc 3;
						separator -w 35 -st none;
						button -l "settings" -c asWmSettings;
						setParent..;
					setParent..;
				setParent..;
			text -l "View:";
			rowLayout -nc 2;
				separator -w 50 -st none;
				columnLayout;
					rowLayout -nc 4;
						button -l "Normal" -c "asWmView Normal";
						button -l "Bump" -c "asWmView Bump";
						button -l "BumpFile" -c "asWmView BumpFile";
						button -l "Masks" -c "asWmView Masks";
						setParent..;
					setParent..;
				setParent..;
			text -l "UV:";
			rowLayout -nc 2;
				separator -w 70 -st none;
				columnLayout;
					rowLayout -nc 1;
						button -l "Update UV Pose" -c "asWmUVUpdate";
						setParent..;

//	if ($modifier==4)
//		frameLayout -e -m 1 asFaceWrinkleMapFrameLayout;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " BlendShapes" asFaceBlendShapesFrameLayout;
		columnLayout -adj 1;
			text -l "Convert DrivingSystems to BlendShapes:";
			separator -st "none" -h 5;
			rowLayout -nc 4 -cw4 15 200 9 18;
				separator -st none;
				checkBox -v 0 -l "keep joints" asKeepJointsCheckBox;
				separator -st none;
				button -w 11 -l "?" -c "asHelpImage asConvertKeepJoints";
				setParent..;
			rowLayout -nc 4 -cw4 15 200 9 18;
				separator -st none;
				checkBox -v 0 -l "keep blendShape target objects" asKeepBSTargetsCheckBox;
				separator -st none;
				button -w 11 -l "?" -c "asHelpImage asConvertKeepBSTargets";
				setParent..;
			separator -st "none" -h 2;
			rowLayout -nc 4 -cw4 75 140 9 18;
				separator -st none;
				button -l "Convert" -c asBSConvertDStoBS;
				separator -st none;
				button -w 11 -l "?" -c ("asHelpImage asConvertToBlendShapes");
				setParent..;
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EditBlendShapes" asFaceEditBlendShapesFrameLayout;
		columnLayout -adj 1;
			text -l "Set controls to the shape for adjustment, then:";
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "extract blendShape target" -c "asBSAdjustTarget";
				popupMenu -pmc "asBsPopulatePopupMenu Extract" asBsExtractPopupMenu;
				separator -st none;
				button -h 18 -w 40 -l "reset" -c "asBSResetTarget";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesCreate";
				setParent..;
			rowLayout -nc 2;
				separator -w 15 -st none;
				floatSlider -en 0 -w 130 -min 0 -max 1 -value 0 -step 0.1 asFaceBSFloatSlider;
				setParent..;
			rowLayout -nc 3 -cw3 15 162 18;
				separator -st none;
				text -l "Delete the targets when finished:";
				button -h 18 -w 40 -l delete -c "delete deleteThis";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				columnLayout -adj 0;
					text -l "Or step through ALL the BlendShape targets,";
					text -l "with the blendShapes wizard:";
					setParent..;
				setParent..;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "start blendShapes wizard" -c "asBSWizard" asBSWizardButton;
				separator -st none;
				button -en 0 -w 40 -l "next.." -c "asBSWizardNext" asBSWizardNextButton;
				button -w 11 -en 0 -l "?" -c "asHelpImage asBSWizardStep0" asBSWizardHelpButton;
				setParent..;
			rowLayout -nc 4 -cw4 15 30 140 50;
				separator -st none;
				text -en 0 -w 30 -l "0/19" asBSWizardStepText;
				text -en 0 -w 140 -l "..." asBSWizardObjAttrText;
				text -en 0 -w 50 -l "..." asBSWizardValueText;
				setParent..;
			rowLayout -nc 2 -cw2 15 200;
				separator -st none;
				button -w 150 -l "stop blendShapes wizard" -c "asBSWizardStop";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				text -l "Or extract All targets:";
				setParent..;
			rowLayout -nc 3 -cw3 15 211 15;
				separator;
				button -w 150 -l "extract All targets" -c "asBSExtractAll";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesExtractAll";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				text -l "Or smooth all targets using DeltaMush:";
				setParent..;
			floatFieldGrp -v1 1.3 -cw2 65 50 -l "multiplier" asDeltaMushShapeMultiplier;
			rowLayout -nc 3 -cw3 15 211 15;
				separator;
				button -w 150 -l "DeltaMush All targets" -c "asBSDeltaMushAll";
				button -w 11 -l "?" -c "asHelpImage asDeltaMushAll";
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " NewBlendShapes" asFaceNewBlendShapesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 15 150 57 18;
				separator -st none;
				button -w 150 -l "Create New BlendShape" -c "asBSNewTarget";
				separator -st none;
				button -w 11 -l "?" -c "asHelpImage asCreateNewBlendShape";
				setParent..;
			rowLayout -nc 3 -cw3 15 182 18;
				separator -st none;
				text -l "Delete the targets when finished:";
				button -h 18 -w 40 -l delete -c "delete deleteThis";
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Custom Controllers" asFaceCustomControlsFrameLayout;
	string $faceBody;
	for ($a=0;$a<2;$a++)
		{
		// Runs the CustomControllers Twice, once for Body, and once for Face
		if ($a==0) {setParent asBodyCustomControlsFrameLayout;$faceBody="Body";}
		if ($a==1) {setParent asFaceCustomControlsFrameLayout;$faceBody="Face";}
		columnLayout -adj 0;
			text -l "Create:";
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					text -l "First create a SoftMod:";
					iconTextButton -w 35 -h 35 -i "softMod.png" -c SoftModTool;
					text -l "Then:";
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create Skin Control" -c ("asConvertSoftModToCustomControl Skin "+$a);
						button -w 11 -l "?" -c "asHelpImage asSkinControlCreate";
						setParent..;
					text -l "Or:";
					columnLayout ("as"+$faceBody+"CustomControlsNonGameEngineCompatiblesColumnLayout");
						rowLayout -nc 2 -cw2 198 15;
							button -w 190 -l "Create Cluster Control" -c ("asConvertSoftModToCustomControl Cluster "+$a);
							button -w 11 -l "?" -c "asHelpImage asClusterControlCreate";
							setParent..;
						text -l "Or:";
						rowLayout -nc 2 -cw2 198 15;
							button -w 190 -l "Create SoftMod Control" -c ("asConvertSoftModToCustomControl SoftMod "+$a);
							button -w 11 -l "?" -c "asHelpImage asSoftModControlCreate";
							setParent..;
						setParent..;
					setParent..;
				setParent..;
			separator -st none -h 10;
			text -l "Edit Cluster Control:";
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					button -w 190 -l "Paint weights for selected Control" -c asPaintClusterControlWeights;
					setParent..;
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					button -w 190 -l "Mirror weights for selected Control" -c asMirrorClusterControlWeights;
					setParent..;
				setParent..;
			separator -st none -h 10;
			text -l "Edit:";
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Add influenced object" -c asAddSoftModInfluencedObject;
						button -w 11 -l "?" -c "asHelpImage asSoftModControlAddInfluencedObject";
						setParent..;
					setParent..;
				setParent..;
			text -l "Delete:";
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Delete selected control" -c asDeleteCustomControl;
						setParent..;
					setParent..;
				setParent..;
		}
setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pose" asPoseFrameLayout;
columnLayout -adj 1 asPoseColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Driving Systems" asBodyDrivingSystemsFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			columnLayout asDrivingSystemsCreateColumnLayout;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout -adj 0;
					text -l "First make the pose to be driven";
					text -l "(e.g. folded wings, hand guesture..)";
					text -l "Then:";
					setParent..;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st none;
				button -w 162 -l"Create Driving System" -c asDsCreate;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsCreate";
				setParent..;
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
				columnLayout -en 1 asDrivingSystemsEditColumnLayout;
				rowLayout -nc 2 -cw2 60 100;
					separator;
					text -l "Right Click on any of these buttons,\nto access existing Driving Systems.";
					setParent..;
				rowLayout -nc 5 -cw5 60 55 55 52 15;
					separator -st none;
					button -w 50 -l "Edit" -c asDsAutoFindAndEdit asDsEditButton;
					popupMenu -pmc "asDsPopulatePopupMenu Edit" asDsEditPopupMenu;
					button -w 50 -l "Delete" asDsDeleteButton;
					popupMenu -pmc "asDsPopulatePopupMenu Delete" asDsDeletePopupMenu;
					button -w 50 -l "Graph" asDsGraphButton;
					popupMenu -pmc "asDsPopulatePopupMenu Graph" asDsGraphPopupMenu;
					button -w 11 -l "?" -c "asHelpImage asDrivingSystemsEdit";
					setParent..;
				separator -st none -h 10;
				rowLayout -nc 2 -cw2 80 100;
					separator -st none;
					columnLayout -adj 0;
						checkBox -v 1 -l "Test Animation" asDsTestAnimCheckBox;
						checkBox -v 1 -l "Test Symmetry" asDsTestSymCheckBox;
						checkBox -v 1 -l "Show only affected" asDsShowOnlyAffectedCheckBox;
						setParent..;
					setParent..;
				separator -st none -h 10;
				setParent..;
			columnLayout -en 0 asDrivingSystemsApplyColumnLayout;
				rowLayout -nc 2 -cw2 60 100;
					separator -st none;
					text -l "After editing pose, then:";
					setParent..;
				rowLayout -nc 5 -cw5 60 55 15 55 52;
					separator -st none;
					button -w 50 -l "Apply" -c asDsEditApply asDsEditApplyButton;
					text -l "or";
					button -w 50 -l "Cancel" -c asDsEditCancel;
					setParent..;
				setParent..;
	columnLayout asBodyDrivingSystemsAdvancedColumnLayout;
		separator -w 242 -h 10;
		rowLayout -nc 2;
			separator -w 5 -st none;
			frameLayout -w 232 -cll 1 -cl 1 -cc asFL -ec asFL -l " Driving Systems - Advanced" asBodyDrivingSystemsAdvancedFrameLayout;
				columnLayout -adj 0;
					text -l "Preview effect of Automatic DrivingSystems:";
					rowLayout -nc 2 -cw2 50 100;
						separator -st none;
						columnLayout -adj 0;
							button -l "Create Blendable Preview Nodes" -c asPADSCreateBlendablePreviewNodes;
							floatSliderGrp -en 0 -cw2 35 130 -field 1 -min 0 -max 1 -pre 2 -v 1 -dc "setAttr DrivingSystemBlendablePreview.blend #1" asPADSFloatSliderGrp;
							button -l "Delete Blendable Preview Nodes" -c asPADSDeleteBlendablePreviewNodes;
							setParent..;
						setParent..;

					separator -w 242 -h 5;
						text -l "Re-use:";
						setParent..;
					rowLayout -nc 2 -cw2 60 100;
						separator;
						columnLayout;
							text -l "This will print in the ScriptEditor:";
							text -l "DrivingSystems Commands";
							button -w 162 -l "Script Editor" -c "ScriptEditor;";
							button -w 162 -l "Clear History" -c "scriptEditorInfo -clearHistory";
							button -w 162 -l "Print Commands" -c asDrivingSystemsPrintInfo;

	setParent asPoseColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes" asBodyCorrectiveShapesFrameLayout;
		columnLayout -adj 0 asBodyCorrectiveShapesColumnLayout;
			text -l "Create:";
			columnLayout -en 1 asCorrectiveShapesCreateColumnLayout;
				rowLayout -nc 2 -cw2 60 100;
					separator -st none;
					columnLayout -adj 0;
						text -l "Go to pose to correct, then:";
						text -l "Select mesh to correct, then:";
						setParent..;
					setParent..;
				rowLayout -nc 3 -cw3 80 120 30;
					separator -st none;
					checkBox -v 1 -l "Angle Rotations" asCorrectiveShapesAngleCheckBox;
					setParent..;
				rowLayout -nc 3 -cw3 80 120 30;
					separator -st none;
					checkBox -v 0 -l "Use SoftMods" -cc "columnLayout -e -m #1 asCorrectiveShapesThenSoftModColumnLayout" asCorrectiveShapesUseSoftModsCheckBox;
					setParent..;
				rowLayout -nc 3 -cw3 60 166 15;
					separator -st none;
					button -w 162 -l "Create Corrective Shape" -c asCreateCorrectiveShapes asCreateCorrectiveShapesButton;
					button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCreate";
					setParent..;
				setParent..;

				separator -h 5 -st none;
				columnLayout -m 0 asCorrectiveShapesThenSoftModColumnLayout;
					rowLayout -nc 3 -cw3 60 120 35;
						separator -st none;
						text -l "Then apply SoftMods:";
						iconTextButton -w 35 -h 35 -i "softMod.png" -c "optionVar -intValue softModPreserveHistory true;SoftModTool;";
						setParent..;
					setParent..;

			separator -w 242 -h 5;
			text -l "Edit:";
			columnLayout -en 0 asCorrectiveShapesEditColumnLayout;
					separator -st none;
					text -l "Right Click on any of these buttons,\nto access existing Corrective Shapes.";
					setParent..;
				rowLayout -nc 5 -cw5 60 55 55 52 15;
					separator -st none;
					button -w 50 -l "Edit" asEditCorrectiveShapesButton;
					popupMenu -pmc "asPopulateCorrectivePopupMenu Edit" asEditCorrectiveShapesPopupMenu;
					button -w 50 -l "Delete" asDeleteCorrectiveShapesButton;
					popupMenu -pmc "asPopulateCorrectivePopupMenu Delete" asDeleteCorrectiveShapesPopupMenu;
					button -w 50 -l "Graph" asGraphCorrectiveShapesButton;
					popupMenu -pmc "asPopulateCorrectivePopupMenu Graph" asGraphCorrectiveShapesPopupMenu;
					button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesEdit";
					setParent..;
				separator -st none -h 20;
				rowLayout -nc 2 -cw2 60 100;
					separator -st none;
					text -l "After sculpted shape, then:";
					setParent..;
				setParent..;
			columnLayout -en 0 asCorrectiveShapesApplyCancelColumnLayout;
				rowLayout -nc 5 -cw5 60 55 55 52 15 ;
					separator -st none;
					button -l "Apply" -c asConnectCorrective;
					checkBox -v 1 -l "mirror" asCorrectiveShapesMirrorCheckBox;
					button -l "Cancel" -c asCancelCorrective;
				setParent..;
			setParent..;


	separator -w 242 -h 10;
	rowLayout -nc 2;
		separator -w 5 -st none;
		columnLayout -adj 0;
			frameLayout -w 232 -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes - Advanced" asBodyCorrectiveAdvancedFrameLayout;
				rowLayout -nc 2;
					separator -w 5 -st none;
					columnLayout -adj 0;
						frameLayout -cll 1 -cl 1 -w 225 -cc asFL -ec asFL -l " Bake" asBodyCorrectiveBakeFrameLayout;
							columnLayout -m 0 asCorrectiveAdvancedColumnLayout;
								rowLayout -nc 2 -cw2 209 100;
									text -l "Bake Deformations to Corrective Shapes:";
									button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesBake";
									setParent..;
								rowLayout -nc 2;
									button -w 120 -l "Source" -c "textField -e -tx `ls -sl` asBakeToCorrective1TextField";
									textField -w 100 -ed 0 asBakeToCorrective1TextField;
									setParent..;
								rowLayout -nc 2;
									button -w 120 -l "Destination" -c "textField -e -tx `ls -sl` asBakeToCorrective2TextField";
									textField -w 100 -ed 0 asBakeToCorrective2TextField;
									setParent..;
								text -l "rotations:";
								rowLayout -nc 6 asBakeAxisRowLayout;
									checkBox -l "+x" -v 1 asBakeX1CheckBox;
									checkBox -l "+y" -v 1 asBakeY1CheckBox;
									checkBox -l "+z" -v 1 asBakeZ1CheckBox;
									checkBox -l "-x" -v 1 asBakeX2CheckBox;
									checkBox -l "-y" -v 1 asBakeY2CheckBox;
									checkBox -l "-z" -v 1 asBakeZ2CheckBox;
									setParent..;
								text -l "Select FK controller, then:";
								rowLayout -nc 3 -cw3 80 50 100;
									button -w 50 -l "Bake" -c asBakeIntoCorrectiveShapes;
										setParent..;
									setParent..;
								setParent..;

							frameLayout -cll 1 -cl 1 -w 225 -cc asFL -ec asFL -l " Batch" asBodyCorrectiveBatchFrameLayout;
								columnLayout;
									text -al left -l ("If the model has changed topology,\nand Correctives are done with SoftMods,\n"
										+"Then \"Batch Edit\" to re-apply the SoftMods.");
									rowLayout -nc 2 -cw2 30 100;
										separator -st none;
										button -l "Batch Edit All Correctives" -c asCorrectiveShapesBatchEdit;
										setParent..;
									setParent..;
								setParent..;

							frameLayout -cll 1 -cl 1 -w 225 -cc asFL -ec asFL -l " CurveBased deformations" asBodyCorrectiveCBDFrameLayout;
							columnLayout;
							rowLayout -nc 2 -cw2 209 100;
								text -l "Create Curve Based Deformation objects,\nto use as Corrective Shape targets";
								button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCurveBased";
								setParent..;
							rowLayout -nc 2;
								button -w 120 -l "Mesh" -c "textField -e -tx `ls -sl` asBodyCorrectiveCBDMeshTextField";
								textField -w 100 -ed 0 asBodyCorrectiveCBDMeshTextField;
								setParent..;
							rowLayout -nc 2;
								button -w 120 -l "FK control" -c "textField -e -tx `ls -sl` asBodyCorrectiveCBDFKControlTextField";
								textField -w 100 -ed 0 asBodyCorrectiveCBDFKControlTextField;
								setParent..;
							button -l "Create Curves" -c asCBDCreateCurves;
							text -l "If you wish to Tweak curves,\n\tUn-Bind, then Tweak, then Re-Bind.";
							rowLayout -nc 3;
								button -l "Un-Bind" -c asCBDUnBindCurves;
								separator -st none -w 10;
								button -l "Re-Bind" -c asCBDReBindCurves;
								setParent..;
							separator -st none -h 5;
							button -l "Create test animation" -c asCBDCreateTestAnim;
							button -l "Hide original mesh" -c asCBDHideMesh;
							button -l "Create new deformation mesh" -c asCBDCreateDeformMesh;
							rowLayout -nc 4;
								separator -w 30 -st none;
								button -l "Show original" -c asCBDShowOriginal;
								separator -w 10 -st none;
								button -l "Show new" -c asCBDShowNew;
								setParent..;
							text -l "\"Slide\" attributecan be adjusted, if needed.";
							separator -h 5;
							text -l "When finished:";
							rowLayout -nc 4;
								separator -w 10 -st none;
								button -l "Bake as Corrective" -c asCBBakeDeformMesh;
								text -w 30  -l "or";
								button -l "Cancel" -c asCBCleanup;

/*
	separator -w 242 -h 5;
	columnLayout -en 0 asCorrectiveSoftModsPreviewColumnLayout;
		text -l "Preview:";
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			columnLayout;
				$cmd="if (`objExists CorrectiveSoftMods`){setAttr -l 0 CorrectiveSoftMods.v;setAttr CorrectiveSoftMods.v #1;setAttr -l 1 CorrectiveSoftMods.v;}";
				checkBox -l "show softMods" -cc $cmd;
				floatSliderGrp -cw2 45 130 -l "amount:" -min 0 -max 1 -v 1 asCorrectiveSoftModsPreviewFloatSlider;
				setParent..;
			setParent..;
		setParent..;
*/

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Tools" asToolsFrameLayout;
columnLayout -adj 1;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "SelectorDesigner" -c asSelectorDesigner;
		button -w 11 -l "?" -c "asHelpImage asSelectorDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "PoserDesigner" -c asPoserDesigner;
		button -w 11 -l "?" -c "asHelpImage asPoserDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "WalkDesigner" -c asWalkDesigner;
		button -w 11 -l "?" -c "asHelpImage asWalkDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "AnimationTester" -c asAnimationTesterUI;
		button -w 11 -l "?" -c "asHelpImage asAnimationTester";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "NameMatcher" -c asNameMatcherUI;
		button -w 11 -l "?" -c "asHelpImage asNameMatcher";
		setParent..;
setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Display" asDisplayFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "MotionSystem:";
			button -w 60 -l "Hide" -c "setAttr MotionSystem.v 0";
			button -w 60 -l "Show" -c "setAttr MotionSystem.v 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "asJointsVisibility 0";
			button -w 60 -l "Show" -c "asJointsVisibility 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joint axis:";
			button -w 60 -l "Hide" -c "asDisplayRigRLA 0";
			button -w 60 -l "Show" -c "asDisplayRigRLA 1";
			setParent..;
		rowLayout -nc 2 -cw2 73 100;
			text "Joint Size:";
			floatSliderGrp -cw2 35 130 -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			setParent..;
setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Optimize" asOptimizeFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused Nodes" -c "hyperShadePanelMenuCommand(\"\", \"deleteUnusedNodes\");print \"// Unused nodes deleted.\\n\"";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Remove Unused Influences" -c asRemoveAllUnusedInfluences;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Prune Small Weights" -c asPruneSmallWeights;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete saved UIs" -c asSaveUIs;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused joints" -c asDeleteUnusedJoints;
			setParent..;
		separator -st none -h 15;
		text -l "Tag Controller:";
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Tag All Controllers" -c "asTagAllControllers";
			setParent..;
		separator -st none -h 15;
		text -l "Face-joints reduction for GameEngine:";
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			columnLayout;
				button -w 140 -l "Reduce EyeLid joints to 4" -c "asReduceEyeLidJoints 4";
				button -w 140 -l "Reduce EyeLid joints to 8" -c "asReduceEyeLidJoints 8";
				separator -h 10 -st none;
				button -w 140 -l "Reduce Lip joints to 14" -c "asReduceLipJoints 14";
//				button -w 140 -l "Reduce Lip joints to 16" -c "asReduceLipJoints 16";
				separator -h 10 -st none;
				button -w 140 -l "Custom Reduce" -c asCustomReduceUI;
				setParent..;
			setParent..;

setParent asColumnLayout;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Updates" asUpdatesFrameLayout;
	columnLayout -adj 1;
		separator -h 5;
		text -l "Model update functions:";
		separator -st none -h 5;
		rowLayout -nc 4 -cw4 60 114 51 15;
			separator;
			button -w 72 -l "Green-fix" -c asReferenceGreenShaderFix;
			separator;
			button -w 11 -l "?" -c "asHelpImage asUpdatesGreenFix";
			setParent..;
setParent asColumnLayout;

frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Publish" asPublishFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Set DisplayLayers to \"R\"" -c asSetDisplayLayersToR;
			setParent..;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Set Joints to hidden" -c "asJointsVisibility 0";
			setParent..;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Go to Build Pose" -c "asGoToBuildPose bodySetup;if (`objExists FaceControlSet`)asGoToBuildPose faceSetup;";
			setParent..;
		separator -st none -h 10;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Publish" -c asPublish;
			button -w 11 -l "?" -c "asHelpImage asPublish";
setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Export" asExportFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			text -l "For Game-Engine Export:";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Delete Unused Endjoints" -c asDeleteUnusedJoints;
			button -w 11 -l "?" -c "asHelpImage asDelteEndJoints";
			setParent..;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Delete Static channels" -c "evalEcho \"delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1\";";
			button -w 11 -l "?" -c "asHelpImage asDeleteStaticChannels";
			setParent..;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Rebuild dagPose nodes" -c asReBuildDagPose;
			button -w 11 -l "?" -c "asHelpImage asRebuildDagPoseNodes";
			setParent..;
		separator -st none -h 10;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Roblox Dynamic Head" -c asRobloxDynamicHead;
			button -w 11 -l "?" -c "asHelpImage faceRobloxHead";
			setParent..;
		separator -st none -h 10;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "FBX export" -c "asExportFbxBrowser \"\"";
			button -w 11 -l "?" -c "asHelpImage asExportFBX";
			setParent..;
		separator -st none -h 10;
		text -l "Unreal:";
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Mannequin export" -c "asExportMannequin";
			button -w 11 -l "?" -c "asHelpImage asExportMannequin";
			setParent..;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "ControlRig export" -c asExportControlRig;
			button -w 11 -l "?" -c "asHelpImage asExportControlRig";
			setParent..;
		separator -st none -h 10;
		text -l "Wonder Studio:";
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Wonder Studio export" -c "asExportWonderStudio";
			button -w 11 -l "?" -c "asHelpImage asExportWonderStudio";
			setParent..;
		columnLayout -m 0 -adj 1 asSubmitToSupportColumnLayout;
			separator -st none -h 10;
			text -al center -l "For Submitting files to Support:";
			rowLayout -nc 3 -cw3 60 168 15;
				separator -st none -h 10;
				button -w 140 -l "zip export" -c "asZipExport";
				button -w 11 -l "?" -c "asHelpImage asExportZip";
				setParent..;
		if ($modifier==4)
			columnLayout -e -m 1 asSubmitToSupportColumnLayout;
setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Demo" asDemoFrameLayout;
	columnLayout -adj 1;
		separator -h 10 -st none;
		rowLayout -nc 3 -cw3 50 178 15;
			separator -st none;
			button -l "Check online for Demo updates" -c asCheckForDemoUpdates;
			button -w 11 -l "?" -c "asHelpImage asDemoCheckOnline";
			setParent..;
		separator -h 10 -st none;
		rowLayout -nc 4;
			separator -w 50 -st none;
			optionMenu asDemoOptionMenu;
			separator -w 25 -st none;
			button -l "Open" -c asOpenDemoFile;
			setParent..;
setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "About" asAboutFrameLayout;
columnLayout -adj 1;
	image -h 83 -i ($asScriptLocation+"/AdvancedSkeletonFiles/icons/asLogo.png") asHelpImage;
	if (`asIsMayaLT`)
		text -l "\nNote:\nRunning Maya LT,\n so not all AdvancedSkeleton features enabled.\n";
	button -l "visit AdvancedSkeleton website" -c "showHelp -a \"https://www.animationstudios.com.au/advancedskeleton\"";
	separator -h 15;
	if (`asMayaVersionAsFloat`>=2012)
		{
		rowLayout -nc 4 -cw4 60 50 70 100;
			text -l " Window:";
			button -c "asDockWindow 1" -l " Dock ";
			button -c "asDockWindow 0" -l " UnDock ";
			button -c asCreateWorkspaceControl -l "Workspace" asWorkspaceButton;
			if (`asMayaVersionAsFloat`<2017)
				button -e -en 0 -ann "Workspace-controller requires Maya2017 or higher" asWorkspaceButton;
			setParent..;
		}
	separator -h 15;
	rowLayout -nc 5 -cw5 110 40 30 54 15;
		button -l "Check For Updates" -c asCheckForUpdates;
		text -l "found:";
		text -m 1 -l "x.xxx" asUpdateFoundVersion;
		button -en 0 -l "Update" -c asUpdateVersion asUpdateVersionButton;
		button -w 11 -l "?" -c "asHelpImage asAboutUpdate";
		setParent..;
	checkBox -m 0 -v 0 asBetaCheckBox;	
	separator -h 15;
	rowLayout -nc 3 -cw3 80 158 15;
		text -l "current version:";
		button -l `asGetScriptVersionAsString` -c "print \"// right click on button to change version.\\n\"";
			popupMenu asVersionsPopupMenu;
		button -w 11 -l "?" -c "asHelpImage asAboutCurrentVersion";
		setParent..;
	separator -h 5;
	rowLayout -nc 3 -cw3 80 158 15;
		text -l "version history:";
		button -l "download version history info" -c asVersionHistory;
		setParent..;
	separator -h 5;
	columnLayout -adj 0;
		text -l "For support, go to:\nwww.facebook.com/AdvancedSkeleton\nOr email: support@animationstudios.com.au\n\nFor license information, read the eula.txt file.";
setParent asFormLayout;
rowLayout -nc 2 -cw2 120 100 asRowLayout;
columnLayout;
	rowLayout -nc 5 -cw5 30 90 10 30 90;
		text -l "body:" asBodyText;
		button -c "asGoToBuildPose bodySetup" -l "Go to Build Pose";
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose bodySetup";
		separator -w 10 -st none;
		text -l "face:" asFaceText;
		button -c "asGoToBuildPose faceSetup" -l "Go to Build Pose" asGoToBuildPoseFaceButton;
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose faceSetup";
		setParent..;
	setParent..;
formLayout -e
	-af asScrollLayout "right" 0
	-af asScrollLayout "left" 0
	-af asScrollLayout "top" 0
	-ac asScrollLayout "bottom" 0 asRowLayout
	-af asRowLayout "bottom" 0
	asFormLayout;
if (!`control -q -ex asWorkspaceControl`)
	{
	if($asDock)
		{
		if (`asMayaVersionAsFloat`>=2012)
			dockControl -l AdvancedSkeleton -w 288 -fl 0 -floatChangeCommand asDockWindowChangeFloatingState -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
		else
			dockControl -l AdvancedSkeleton -w 288 -fl 0 -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
		if (`asMayaVersionAsFloat`>=2016)
			{
			//force left docking area to be matching size, as it might be bigger, if a crash-report has auto-docked
			dockControl -e -fixedWidth 1 AdvancedSkeletonDockControl;
			refresh;
			dockControl -e -fixedWidth 0 AdvancedSkeletonDockControl;
			}
		evalDeferred "dockControl -e -r AdvancedSkeletonDockControl;";
		}
	else
		showWindow;
	}
asUpdateLabelHelp;
asUpdateAttributeHelp;
asEnsureFitSkeletonAttributes;
asUpdateButtonEnables;
if (`window -q -ex AdvancedSkeletonWindow`)
	{
	window -e -w 296 AdvancedSkeletonWindow;
	if (`asMayaVersionAsFloat`<2012)
		window -e -w 309 AdvancedSkeletonWindow;
	if (!`windowPref -q -ex AdvancedSkeletonWindow`)
		window -e -h 500 AdvancedSkeletonWindow;
	}
if ($asFaceIsResetting)
	$asFaceIsResetting=0;
else
	asFaceUpdateInfo 1;
//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		if (`optionVar -ex $framLayouts[$i]`)
			frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];
//populate fitSkeletonFiles optionMenu
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeletonFiles/fitSkeletons/";
string $fitSkeletonFiles[]=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asFitFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}
//populate Retopology optionMenus
string $headTopologyDir=$asScriptLocation+"/AdvancedSkeletonFiles/div/headTopology/";
string $headTopoFiles[]=`getFileList -fld $headTopologyDir`;
setParent -menu asCreateFaceRetopoOptionMenu;
for ($i=0;$i<size($headTopoFiles);$i++)
	{
	if (`gmatch $headTopoFiles[$i] "[.]*"` || $headTopoFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoFiles[$i];
	}
string $headTopologyEyeBallDir=$asScriptLocation+"/AdvancedSkeletonFiles/div/headTopologyEyeBall/";
string $headTopoEyeBallFiles[]=`getFileList -fld $headTopologyEyeBallDir`;
setParent -menu asCreateFaceRetopoEyeBallOptionMenu;
for ($i=0;$i<size($headTopoEyeBallFiles);$i++)
	{
	if (`gmatch $headTopoEyeBallFiles[$i] "[.]*"` || $headTopoEyeBallFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoEyeBallFiles[$i];
	}
string $headTopologyTeethDir=$asScriptLocation+"/AdvancedSkeletonFiles/div/headTopologyTeeth/";
string $headTopoTeethFiles[]=`getFileList -fld $headTopologyTeethDir`;
setParent -menu asCreateFaceRetopoTeethOptionMenu;
for ($i=0;$i<size($headTopoTeethFiles);$i++)
	{
	if (`gmatch $headTopoTeethFiles[$i] "[.]*"` || $headTopoTeethFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoTeethFiles[$i];
	}
//populate Demo optionMenu
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeletonFiles/exampleFiles/downloads/";
string $exampleFolders[]=`getFileList -fld $exampleFoldersDir`;
setParent -menu asDemoOptionMenu;
for ($i=0;$i<size($exampleFolders);$i++)
	{
	string $exampleFile=$exampleFoldersDir+$exampleFolders[$i]+"/"+$exampleFolders[$i]+".mb";
	if (`file -q -ex $exampleFile`)
		menuItem -l $exampleFolders[$i];
	}
$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeletonFiles/fitSkeletonsLimbs/";
$fitSkeletonFiles=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asLimbFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}
//Exist EditDrivingSystemMode (if stuck)
//if (`headsUpDisplay -q -ex HUDEDSMode`)
//	headsUpDisplay -e -rem HUDEDSMode;
asUpdateHud;
//Set 0.2 jointDisplayScale if first run of AdvancedSkeleton
if (!`optionVar -ex asBodyFrameLayout`)
	jointDisplayScale 0.2;
//populate asVersionsPopupMenu
string $oldVersionsDir=$asScriptLocation+"/AdvancedSkeletonFiles/oldVersions/";
int $latestLocal;
setParent -menu asVersionsPopupMenu;
string $oldVersions[];
if (`file -q -ex $oldVersionsDir`)
	$oldVersions=`getFileList -fld $oldVersionsDir`;
$oldVersions=`sort $oldVersions`;
for ($i=size($oldVersions);$i>-1;$i--)
	{
	if ($i==size($oldVersions))
		{
		$label=`asGetLatestLocalVersionAsString`;
		$latestLocal=1;
		}
	else
		{
		$label=$oldVersions[$i];
		$latestLocal=0;
		}
	$label=`substitute "AdvancedSkeleton_v" $label ""`;
	menuItem -l $label -c ("asSourceVersion \""+$label+"\" "+$latestLocal);
	}
//customColors
if (`optionVar -q asSettingsUseCustomColors`)
	asSettingsColorsRefresh;
//Maya less than2012 limitations
if (`asMayaVersionAsFloat`<2012)
	{
	string $childArray[]=`columnLayout -q -ca asFaceColumnLayout`;
	for ($i=0;$i<size($childArray);$i++)
		layout -e -m 0 $childArray[$i];
	setParent asFaceColumnLayout;
	text -l "FaceSetup requires Maya2012 or higher";
	}
//Maya LT limitations
if (`asIsMayaLT`)
	{
	frameLayout -e -en 0 asBodyDeform2FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDeform3FrameLayout;//no wire deformer
//	frameLayout -e -en 0 asBodyDrivingSystemsFrameLayout;//no sdk
	frameLayout -e -en 0 asFaceFrameLayout;//no wireDef, no wrapDef, no Python, Working on making this work, just missing lips
	}
if (!$haveRanThisVersion) asFirstRunOfNewVersion;//First time running this version
progressBar -e -ep $gMainProgressBar;
}

global proc asScriptLocatorProc (){}

global proc string asGetScriptLocation ()
{
string $whatIs=`whatIs asScriptLocatorProc`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder-1)`;
return $scriptLocation;
}

global proc float asGetScriptVersion ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton.mel";
float $version=`asGetScriptVersionFromFile $file`;
return $version;
}

global proc string asGetScriptVersionAsString ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton.mel";
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
return $versionAsString;
}

global proc float asGetScriptVersionFromFile (string $file)
{
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
float $version=$versionAsString;
return $version;
}

global proc string asGetScriptVersionFromFileAsString (string $file)
{
string $versionString;
string $tempString[];
int $lineNr;
if (`file -q -ex $file`)
	{
	int $fileId=`fopen $file "r"`;
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$lineNr++;
		$nextLine = `fgetline $fileId`;
		if (`gmatch $nextLine "*Version*"`)
			{
			tokenize $nextLine $tempString;
			tokenize $tempString[2] "[.]" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				$versionString+=$tempString[$i];
				if ($i==0)
					$versionString+=".";
				}
//			$version=$versionString;
			}
		if($lineNr>10)
			break;
		}
	fclose $fileId;
	}
else
	warning "Unable to determine AdvancedSkeleton version number";
return $versionString;
}

global proc asSourceVersion (string $versionAsString, int $latestLocal)
{
global string $gShelfTopLevel;
int $sucess;
string $buttons[];

string $asFile,$iol,$image;
string $latestLocalScriptLocation=`asGetLatestLocalScriptLocation`;
if ($latestLocal)
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton.mel";
else
	{
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeletonFiles/oldVersions/AdvancedSkeleton_v"+$versionAsString+"/AdvancedSkeleton.mel";
	$iol=$versionAsString;
	if (!`file -q -ex $asFile`)
		{
		warning ("attempted to source version: "+$versionAsString+", but could not find file:\""+$asFile+"\", so using latest installed version instead");
		optionVar -iv asUseVersionLatestLocal 1;
		return;
		}
	}

string $cmd="source \""+$asFile+"\";AdvancedSkeleton;";
string $shelves[]=`tabLayout -q -ca $gShelfTopLevel`;
for ($i=0;$i<size($shelves);$i++)
	{
	$buttons=`layout -q -ca $shelves[$i]`;
	for ($y=0;$y<size($buttons);$y++)
		{
		if (!`shelfButton -q -ex $buttons[$y]`)
			continue;
		string $ann=`shelfButton -q -ann $buttons[$y]`;
		if ($ann=="AdvancedSkeleton")
			{
			$image=`shelfButton -q -i $buttons[$y]`;
			if ($iol=="")
				$image=`substitute "AS4version" $image "AS4"`;
			else
				$image=`substitute "AS4" $image "AS4version"`;
			shelfButton -e -c $cmd -iol $iol -i $image -i1 $image $buttons[$y];
			$sucess=1;
			}
		}
	}
if ($sucess)
	{
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		evalDeferred -lp ("deleteUI -control AdvancedSkeletonDockControl");
	else if (`window -q -ex AdvancedSkeletonWindow`)
	    evalDeferred -lp ("deleteUI AdvancedSkeletonWindow");
	if (`exists workspaceControl`)
		if (`workspaceControl -q -ex asWorkspaceControl`)
			deleteUI asWorkspaceControl;
	print ("// Shelf button updated, Click on the button to launch choosen version of AdvancedSkeleton\n");
	}
}

global proc int asHaveMeshCenterSnap ()
{
int $haveSnap;
string $helpString=`help snapMode`;
string $tempString[];
tokenize $helpString $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]=="-meshCenter")
		$haveSnap=1;
return $haveSnap;
}

global proc asFirstRunOfNewVersion ()
{
global string $gShelfTopLevel;
int $hasAS,$hasPicker;
string $currentShelf = `tabLayout -query -selectTab $gShelfTopLevel`;
string $asScriptLocation=`asGetScriptLocation`;
string $shelfButtons[]=`shelfLayout -q -ca $currentShelf`;
for ($i=0;$i<size($shelfButtons);$i++)
	{
	if (!`shelfButton -q -ex $shelfButtons[$i]`)
		continue;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="AdvancedSkeleton") $hasAS=1;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="picker") $hasPicker=1;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="Selector:picker") $hasPicker=1;
	}
if ($hasAS && !$hasPicker)
	if (`confirmDialog -title "Add tool ?" -message 
	("This version have a new tool for your shelf (Picker)\n"
	+"Add this to your shelf now ?")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`=="Yes")
    {
		evalEcho ("source \""+$asScriptLocation+"/AdvancedSkeletonFiles/picker/install.mel\"");
		SavePreferences;
		}
optionVar -iv asHaveRanThisVersion 1;
}

global proc asUpdateLabelHelp ()
{
string $type=`optionMenu -q -v asLabelType`;
string $help="";
if ($type=="Hand" || $type=="Shoulder")
	$help="Hand + Shoulder = Arm IK";
if ($type=="Hip" || $type=="Foot")
	$help="Hip + Foot = Leg IK";
if ($type=="LegAim")
	$help="LegAim + Hip + Foot = 3 bone Leg IK";
if ($type=="Heel" || $type=="Toes" || $type=="ToesEnd")
	$help="Heel + Toes + ToesEnd = FootRoll";
if ($type=="BigToe" || $type=="PinkyToe")
	$help="BigToe + PinkyToe = FootRock";
if ($type=="QToes")
	$help="Quadped toes";
if ($type=="Root" || $type=="Chest" || $type=="Mid")
	$help="Root + Chest (+ Mid) = Spine IK";
if ($type=="0" || $type=="1" || $type=="2" || $type=="3")
	$help="0,1,2, etc.. = Spline IK (tail)";


text -e -l $help asLabelHelp;
}

global proc asUpdateAttributeHelp ()
{
string $type=`optionMenu -q -v asAttributeType`;
string $help="";
if ($type=="twist/bendy")
	$help="TwistJoints & Bendy-limbs";
if ($type=="inbetween")
	$help="Creates extra inbetween joints";
if ($type=="global")
	$help="Keeps limbs orientation fixed";
if ($type=="aim")
	$help="LookAt (AimConstraint)";
if ($type=="wheel")
	$help="Wheel Roller";
if ($type=="rollingBall")
	$help="Auto Rool for Ball";
if ($type=="freeOrient")
	$help="Free limb orientation";
if ($type=="worldOrient")
	$help="Orient limb to world-space";
if ($type=="flipOrient")
	$help="Reverse up-vector";
if ($type=="noMirror")
	$help="For non-symmetrical limbs";
if ($type=="noFlip")
	$help="Ignore Mirror behaviour";
if ($type=="noControl")
	$help="Skips creating FK-control";
if ($type=="noSkin")
	$help="Skips adding joint to DeformSet";
if ($type=="ikLocal")
	$help="Local oriented IK-control";
if ($type=="centerBtwFeet")
	$help="Makes Root follow IK legs";
if ($type=="hipSwinger")
	$help="Reverse FK Hip Controller";
if ($type=="follow")
	$help="Follows another joint";
if ($type=="ikFollow")
	$help="IK Follows another joint";
if ($type=="geoAttach")
	$help="Controller sticks to geometry";
if ($type=="aimAt")
	$help="Aim at another control";
if ($type=="curveGuide")
	$help="For feather setup";
if ($type=="rootOptions")
	$help="Options only for Root joint";
if ($type=="segScaleComp")
	$help="sets the segmentScaleCompensate";
if ($type=="childOfPart")
	$help="Make child of TwistJoint";
if ($type=="control")
	$help="creates control for end-joint";
if ($type=="hipSwinger")
	$help="For custom HipSwinger";

text -e -l $help asAttributeHelp;
}

global proc asFitResample ()
{
if (`window -q -ex asFitResample`)
	deleteUI asFitResample;
window -t Resample asFitResample;

int $numJoints=2;
string $allDescendents[],$tempString[];
string $selJoints[]=`ls -sl -type joint`;
string $startJoint=$endJoint="none";
if (size($selJoints)==1)
	{
	string $asFitJointIKInfo[]=`asFitJointIKInfo $selJoints[0]`;
	if ($asFitJointIKInfo[1]!="")
		$startJoint=$asFitJointIKInfo[1];
	if ($asFitJointIKInfo[3]!="")
		$endJoint=$asFitJointIKInfo[3];
	}
if (size($selJoints)==2)
	{
	$allDescendents=`listRelatives -ad $selJoints[0]`;
	if (`stringArrayCount $selJoints[1] $allDescendents`)
		{
		$startJoint=$selJoints[0];
		$endJoint=$selJoints[1];
		}
	$allDescendents=`listRelatives -ad $selJoints[1]`;
	if (`stringArrayCount $selJoints[0] $allDescendents`)
		{
		$startJoint=$selJoints[1];
		$endJoint=$selJoints[0];
		}
	}
//Find current $numJoints
if (`objExists $startJoint` && `objExists $endJoint` )
	{
	string $countJoint=$endJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`listRelatives -p $countJoint`;
		$countJoint=$tempString[0];
		if ($countJoint=="" || $countJoint==$startJoint)
			break;
		$numJoints++;
		}
	}

columnLayout -adj 1;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "StartJoint:" -ed 0 -tx $startJoint asFitResampleStartJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleStartJointtextFieldGrp";
	setParent..;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "EndJoint" -ed 0 -tx $endJoint asFitResampleEndJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleEndJointtextFieldGrp";
	setParent..;
intFieldGrp -v1 $numJoints -cw2 60 50 -l "joints" asFitResampleNumJoints;
button -l "ReSample" -c asFitResampleJoints;
showWindow asFitResample;
}

global proc asFitResampleJoints ()
{
global string $gSelect;
setToolTo $gSelect;
int $reachedStart,$labelNum;
int $startJointLocks[],$endJointLocks[];
float $radius;
float $startJointFat=1;
float $startJointFatFront=1;
float $startJointFatWidth=1;
float $endJointFat=1;
float $endJointFatFront=1;
float $endJointFatWidth=1;
string $sel[]=`ls -sl`;
string $tempString[],$joints[],$parentJoints[],$labels[];
string $newJoint,$nearestJoint,$startJointParent,$checkJointName,$parent,$newJointName,$newJointBaseName;
string $startJoint=`textFieldGrp -q -tx asFitResampleStartJointtextFieldGrp`;
string $endJoint=`textFieldGrp -q -tx asFitResampleEndJointtextFieldGrp`;
int $numJoints=`intFieldGrp -q -v1 asFitResampleNumJoints`;
float $dist,$minDist;
float $pos[],$posA[],$posB[],$labelPosX[],$labelPosY[],$labelPosZ[];

$tempString=`ls -l $endJoint`;
tokenize $tempString[0] "|" $parentJoints;
for ($i=0;$i<size($parentJoints);$i++)
	{
	if ($parentJoints[$i]==$startJoint)
		$reachedStart=1;
	if ($reachedStart)
		$joints[size($joints)]=$parentJoints[$i];	
	if ($reachedStart && $parentJoints[$i]!=$startJoint && $parentJoints[$i]!=$endJoint)
		{
		$tempString[0]=`asLabel $parentJoints[$i]`;
		if ($tempString[0]!="")
			{
			$labels[$labelNum]=$tempString[0];
			$pos=`xform -q -ws -t $parentJoints[$i]`;
			$labelPosX[$labelNum]=$pos[0];
			$labelPosY[$labelNum]=$pos[1];
			$labelPosZ[$labelNum]=$pos[2];
			$labelNum++;
			}
		}
	}
if (!`objExists $startJoint`)
	error ("startJoint :\""+$startJoint+"\" does not exists");
if (!`objExists $endJoint`)
	error ("endJoint :\""+$endJoint+"\" does not exists");
if ($numJoints<2)
	error "Can not ReSample to less than 2";
if (!`stringArrayCount $startJoint $joints`)
	error ("endJoint:\""+$endJoint+"\" is not a child of startJoint:\""+$startJoint+"\"");
if ($startJoint==$endJoint)
	error "StartJoint and EndJoint can not be the same";

select $startJoint $endJoint;
$tempString=`ikHandle -sol ikSplineSolver -scv false -pcv false`;
duplicate -n tempIKCurve $tempString[2];
delete $tempString[0] $tempString[2];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempIKCurveShape.worldSpace[0] tempPointOnCurveInfo.inputCurve;
select tempIKCurve;refresh;

$startJointLocks=`asUnLockAttrs $startJoint`;
$endJointLocks=`asUnLockAttrs $endJoint`;

if (`attributeExists fat $startJoint`) $startJointFat=`getAttr ($startJoint+".fat")`;
if (`attributeExists fatFront $startJoint`) $startJointFatFront=`getAttr ($startJoint+".fatFront")`;
if (`attributeExists fatWidth $startJoint`) $startJointFatWidth=`getAttr ($startJoint+".fatWidth")`;
if (`attributeExists fat $endJoint`) $endJointFat=`getAttr ($endJoint+".fat")`;
if (`attributeExists fatFront $endJoint`) $endJointFatFront=`getAttr ($endJoint+".fatFront")`;
if (`attributeExists fatWidth $endJoint`) $endJointFatWidth=`getAttr ($endJoint+".fatWidth")`;

$tempString=`listRelatives -p $startJoint`;
$startJointParent=$tempString[0];
if ($startJointParent!="")
	parent -w $startJoint;
parent -w $endJoint;
$radius=`getAttr ($startJoint+".radius")`;
rename $endJoint tempRename;
if (`objExists $joints[1]`) delete $joints[1];
$parent=$startJoint;
$newJointBaseName=$joints[0];
if ($joints[0]=="Root")
	$newJointBaseName="Spine";
for ($i=1;$i<$numJoints-1;$i++)
	{
	select -cl;
	$checkJointName=$newJointBaseName;
	for ($y=0;$y<99;$y++)
		{
		//special case, when resampling Spine, make sure 1st Spine joint is called Spine1, for correct HipSwinger
		if ($checkJointName=="Spine")
			$y++;
		if ($y>0)
			$checkJointName=$newJointBaseName+$y;
		if (!`objExists $checkJointName`)
			if ($checkJointName!=$endJoint)
				break;
		}
	$newJointName=$checkJointName;
	$newJoint=`joint -n $newJointName -rad $radius`;
	setAttr tempPointOnCurveInfo.parameter ((1.0/($numJoints-1))*$i);
	$pos=`getAttr tempPointOnCurveInfo.position`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $newJoint;
	parent $newJoint $parent;
	$parent=$newJoint;
	asEnsureFitJointAttrs $newJoint;
	setAttr ($newJoint+".fat") ($startJointFat+(($i/($numJoints-1.0))*($endJointFat-$startJointFat)));
	setAttr ($newJoint+".fatFront") ($startJointFatFront+(($i/($numJoints-1.0))*($endJointFatFront-$startJointFatFront)));
	setAttr ($newJoint+".fatWidth") ($startJointFatWidth+(($i/($numJoints-1.0))*($endJointFatWidth-$startJointFatWidth)));
	asFitModeUpdateJoints $newJoint 0;
	refresh;
	}
rename tempRename $endJoint;
parent $endJoint $parent;
if ($startJointParent!="")
	parent $startJoint $startJointParent;

//labels
for ($i=0;$i<size($labels);$i++)
	{
	$posA[0]=$labelPosX[$i];
	$posA[1]=$labelPosY[$i];
	$posA[2]=$labelPosZ[$i];
	$tempString=`listRelatives -f -ad -type joint $startJoint`;
	$minDist=999;
	for ($y=0;$y<size($tempString);$y++)
		{
		$posB=`xform -q -ws -t $tempString[$y]`;
		$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($dist<$minDist)
			{
			$nearestJoint=$tempString[$y];
			$minDist=$dist;
			}
		}
	setAttr ($nearestJoint+".drawLabel") 1;
	setAttr ($nearestJoint+".type") 18;
	setAttr -type "string" ($nearestJoint+".otherType") $labels[$i];
	}

asReLockAttrs $startJoint $startJointLocks;
asReLockAttrs $endJoint $endJointLocks;

asFitModeUpdateJoints $endJoint 0;
delete tempIKCurve;
if (`checkBox -q -ex asLockCenterJoints`)
	if (`checkBox -q -v asLockCenterJoints`)
		asFitModeLockCenterJoints;

print ("// Joints Resampled\n");
catchQuiet (`select $sel`);
}

global proc int asRoundFloatToInt (float $float)
{
float $n = $float % 1;
if ($n >= 0.5)
	$float = `ceil $float`;
else
	$float = `floor $float`;
return $float;
}

global proc int[] asUnLockAttrs (string $obj)
{
int $lockedAttrs[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		$lockedAttrs[size($lockedAttrs)]=`getAttr -l ($obj+"."+$trs[$y]+$xyz[$z])`;
		setAttr -l 0 ($obj+"."+$trs[$y]+$xyz[$z]);
		}
return $lockedAttrs;
}

global proc asReLockAttrs (string $obj, int $lockedAttrs[])
{
int $attrNr=0;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		setAttr -l $lockedAttrs[$attrNr] ($obj+"."+$trs[$y]+$xyz[$z]);
		$attrNr++;
		}
}

global proc asFitResamplePick (string $textFieldGrp)
{
string $selJoints[]=`ls -sl -type joint`;
if (!size($selJoints))
	error "No joint selected";
textFieldGrp -e -tx $selJoints[0] $textFieldGrp;
}

global proc asAddFitJointLabel ()
{
string $labelType=`optionMenu -q -v asLabelType`;
string $sel[]=`ls -sl -type joint`;
int $labelCode;
for ($i=0;$i<size($sel);$i++)
	{
	setAttr ($sel[$i]+".drawLabel") 1;
	$labelCode=`asLabelCodeLookup $labelType 1`;
	setAttr ($sel[$i]+".type") $labelCode;
	if ($labelCode==18)
		setAttr -type "string" ($sel[$i]+".otherType") $labelType;
	}
}

global proc asRemoveFitJointLabel ()
{
string $sel[]=`ls -sl -type joint`;
for ($i=0;$i<size($sel);$i++)
	setAttr ($sel[$i]+".drawLabel") 0;
}

global proc string asLabelCodeLookup (string $labelCode, int $labelToCode)
{
int $codes[]={0,1,2,4,18,10,12,15,16,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18};
string $labels[]={"None","Root","Hip","Foot","ToesEnd","Shoulder","Hand","PropA","PropB","PropC","Other","Chest","Mid","Toes","Heel","BigToe","PinkyToe","LegAim","QToes","Eye","Wheel","0","1","2","3"};

for ($i=0;$i<size($labels);$i++)
	{
	if ($labelToCode)
		if ($labels[$i]==$labelCode)
			return $codes[$i];
	if (!$labelToCode)
		if ($codes[$i]==$labelCode)
			return $labels[$i];
	}
return "";
}

global proc string asLabel (string $obj)
{
string $label;
if (size(`ls -ap $obj`)>1)
	error ("More than one object matches name: "+$obj+"\n");
if (!`objExists $obj`)
	return "AA";
if (!`attributeExists "type" $obj`)
	return "BB";
int $labelNum=`getAttr ($obj+".type")`;
if (!`getAttr ($obj+".drawLabel")`)
	return "";

$label=`asLabelCodeLookup $labelNum 0`;
if ($labelNum==18)
	{
	$label=`getAttr ($obj+".otherType")`;
	}

return $label;
}

global proc int asComponentToNr (string $component)
{
int $nr;
string $tempString[];
tokenize $component "[" $tempString;
tokenize $tempString[1] "]" $tempString;
$nr=$tempString[0];
return $nr;
}

global proc asAddFitJointAttribute ()
{
string $attr=`optionMenu -q -v asAttributeType`;
string $sel[]=`ls -sl`;
float $dv=1;
string $meshObject,$curveObject;
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]` || `objectType $sel[$i]`!="joint")
		continue;
	if (`attributeExists $attr $sel[$i]` && `objectType $sel[$i]`=="joint")
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}
	if ($attr=="twist/bendy" && `attributeExists twistJoints $sel[$i]`)
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}

	if ($attr=="twist/bendy")
		{
		if (`attributeExists inbetweenJoints $sel[$i]`) error "\"inbetweenJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "twistJoints" -at long -min 0 -max 10 -dv 2 $sel[$i];
		addAttr -k 1 -ln "bendyJoints" -at bool -dv 0 $sel[$i];
//		addAttr -k 1 -ln "partControllers" -at bool -dv 0 $sel[$i];
		//Update geo, if in FitMode
		global int $asFitModeScriptJobNr1;
		if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
//			if (`checkBox -q -ex asVisGeo`)
//				if (`checkBox -q -v asVisGeo`)
				if (`getAttr FitSkeleton.visGeo`)
					asFitModeUpdateAllGeometry;
		}
	else if ($attr=="inbetween")
		{
		if (`attributeExists twistJoints $sel[$i]`) error "\"twistJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		if (`attributeExists bendyJoints $sel[$i]`) error "\"bendyJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "inbetweenJoints" -at long -min 0 -dv 2 $sel[$i]; 
		addAttr -k 1 -ln "unTwister" -at bool -dv 0 $sel[$i];
//		addAttr -k 1 -ln "partControllers" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="global")
		{
		addAttr -k 1 -ln $attr -at double -min 0 -max 10 -dv 0 $sel[$i];
		addAttr -k 1 -ln "globalTranslate" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="noMirror")
		{
		addAttr -k 1 -ln $attr -at bool -dv $dv $sel[$i];
		addAttr -k 1 -ln "noMirrorLeft" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="worldOrient")
		{
		addAttr -k 1 -ln "worldOrientUp" -at "enum" -en "xUp:yUp:zUp:xDown:yDown:zDown:" -dv 0 $sel[$i];
		addAttr -k 1 -ln "worldOrientForward" -at "enum" -en "xForward:yForward:zForward:xBackward:yBackward:zBackward:free:" -dv 6 $sel[$i];
		}
	else if ($attr=="ikLocal")
		addAttr -k 1 -ln $attr -at "enum" -en "addCtrl:nonZero:localOrient:" -dv 0 $sel[$i];
	else if ($attr=="geoAttach")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			$tempString=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="mesh")
					$meshObject=$sel[$y];
			}
		if (size($sel)<2 || $meshObject=="")
			error "Select both FitJoint AND Geometry to attach to";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $meshObject ":" "__"` $sel[$i];
		addAttr -k 1 -ln ($attr+"Mode") -at "enum" -en "point:orient:parent" -dv 2 $sel[$i];
		select $sel[$i];
		}
	else if ($attr=="aimAt" || $attr=="follow" || $attr=="ikFollow")
		{
		for ($y=0;$y<size($sel);$y++)
			if (`objectType $sel[$y]`!="joint")
				error "Only joints must be selected.";
		if (size($sel)<2)
			error "Select both FitJoint AND secondary joint";
		if ($i==0)
			continue;//do not add attributes to `target`
		if ($i==1)
			{
			addAttr -k 1 -ln $attr -at "enum" -en $sel[0] $sel[1];
			if ($attr=="aimAt")
				{
				addAttr -k 1 -ln "aimAxis" -at "enum" -en "x:y:z:" -dv 0 $sel[1];
				addAttr -k 1 -ln "aimUpAxis" -at "enum" -en "x:y:z:" -dv 1 $sel[1];
				}
			}
		if ($attr=="follow")
			addAttr -k 1 -ln "followPivot" -at bool -dv 0 $sel[$i];
		select $sel[$i];
		}
	else if ($attr=="curveGuide")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			string $tempString[]=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="nurbsCurve")
					$curveObject=$sel[$y];
			}
		if (size($sel)<2 || $curveObject=="")
			error "Select both FitJoint AND Curve";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $curveObject ":" "__"` $sel[$i];
		addAttr -k 1 -ln ($attr+"Mode") -at "enum" -en "point:aim" -dv 1 $sel[$i];
		select $sel[$i];
		}
	else if ($attr=="rootOptions")
		{
		if ($sel[0]!="Root")
			error "Can only be added to Root joint";
		if (!`attributeExists "centerBtwFeet" $sel[0]`)
			addAttr -k 1 -ln "centerBtwFeet" -at bool -dv 1 $sel[0];
		if (!`attributeExists "numMainExtras" $sel[0]`)
			addAttr -k 1 -ln "numMainExtras" -at long -min 0 -dv 0 $sel[0];
		}
	else if ($attr=="childOfPart")
		addAttr -k 1 -ln "childOfPart" -at long -min 1 -max 10 -dv 2 $sel[$i];
	else
		addAttr -k 1 -ln $attr -at bool -dv $dv $sel[$i];
	}
}

global proc asRemoveFitJointAttribute ()
{
string $sel[]=`ls -sl -type joint`;
string $attr=`optionMenu -q -v asAttributeType`;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]`)
		deleteAttr ($sel[$i]+"."+$attr);
	if ($attr=="twist/bendy" && `attributeExists "twistJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".twistJoints");
	if ($attr=="twist/bendy" && `attributeExists "bendyJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".bendyJoints");
	if ($attr=="twist/bendy" && `attributeExists "partControllers" $sel[$i]`)
		deleteAttr ($sel[$i]+".partControllers");
	if ($attr=="inbetween" && `attributeExists "inbetweenJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".inbetweenJoints");
	if ($attr=="inbetween" && `attributeExists "unTwister" $sel[$i]`)
		deleteAttr ($sel[$i]+".unTwister");
	if ($attr=="inbetween" && `attributeExists "partControllers" $sel[$i]`)
		deleteAttr ($sel[$i]+".partControllers");
	if ($attr=="geoAttach" && `attributeExists "geoAttachMode" $sel[$i]`)
		deleteAttr ($sel[$i]+".geoAttachMode");
	if ($attr=="global" && `attributeExists "globalTranslate" $sel[$i]`)
		deleteAttr ($sel[$i]+".globalTranslate");
	if ($attr=="noMirror" && `attributeExists "noMirrorLeft" $sel[$i]`)
		deleteAttr ($sel[$i]+".noMirrorLeft");
	if ($attr=="worldOrient" && `attributeExists "worldOrientUp" $sel[$i]`)
		deleteAttr ($sel[$i]+".worldOrientUp");
	if ($attr=="worldOrient" && `attributeExists "worldOrientForward" $sel[$i]`)
		deleteAttr ($sel[$i]+".worldOrientForward");
	if ($attr=="curveGuide" && `attributeExists "curveGuideMode" $sel[$i]`)
		deleteAttr ($sel[$i]+".curveGuideMode");
	if ($attr=="rootOptions" && `attributeExists "centerBtwFeet" $sel[$i]`)
		deleteAttr ($sel[$i]+".centerBtwFeet");
	if ($attr=="rootOptions" && `attributeExists "numMainExtras" $sel[$i]`)
		deleteAttr ($sel[$i]+".numMainExtras");
	if ($attr=="aimAt" && `attributeExists "aimAxis" $sel[$i]`)
		deleteAttr ($sel[$i]+".aimAxis");
	if ($attr=="aimAt" && `attributeExists "aimUpAxis" $sel[$i]`)
		deleteAttr ($sel[$i]+".aimUpAxis");
	if ($attr=="follow" && `attributeExists "followTranslate" $sel[$i]`)
		deleteAttr ($sel[$i]+".followTranslate");
	if ($attr=="follow" && `attributeExists "followPivot" $sel[$i]`)
		deleteAttr ($sel[$i]+".followPivot");
	if ($attr=="follow" && `attributeExists "followScale" $sel[$i]`)
		deleteAttr ($sel[$i]+".followScale");
	}
}

global proc asFitDisplayJointAxis  (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $fitJoints[$i]`;
	string $child=$tempString[0];
	if ($child=="" && $onOff)
		continue;
	setAttr ($fitJoints[$i]+".displayLocalAxis") $onOff;
	}
if (`attributeExists visJointAxis FitSkeleton`)
	setAttr FitSkeleton.visJointAxis $onOff;
}

global proc asToggleFitDisplayPoleVector ()
{
int $onOff=1;
if (`attributeExists visPoleVector FitSkeleton`)
	if (`getAttr FitSkeleton.visPoleVector`)
		$onOff=0;
print ($onOff+"\n");
asFitDisplayPoleVector $onOff;
}

global proc asFitDisplayPoleVector (int $onOff)
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
float $ikLenght;
float $pos1[],$pos2[],$pos3[];
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKNumCtrls,$exp;
string $tempString[],$asFitJointIKInfo[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
if ($onOff==0)
	{
	if (`objExists FitSkeletonPoleVectors`) delete FitSkeletonPoleVectors;
	if (`objExists FitSkeletonVisualizers`)
		{
		$tempString=`listRelatives -c FitSkeletonVisualizers`;
		if ($tempString[0]=="")
			delete FitSkeletonVisualizers;
		if (`attributeExists visPoleVector FitSkeleton`)
			setAttr FitSkeleton.visPoleVector 0;
		}
	return;
	}
if ($onOff && `objExists FitSkeletonPoleVectors`)
	return;

for ($i=0;$i<size($fitJoints);$i++)
	{
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	if (!size($asFitJointIKInfo))
		continue;

	$ik=$asFitJointIKInfo[0];
	$IKParentJoint=$asFitJointIKInfo[1];
	$IKMiddleJoint=$asFitJointIKInfo[2];
	$IKChildJoint=$asFitJointIKInfo[3];
	$IKSolver=$asFitJointIKInfo[4];
	$IKNumCtrls=$asFitJointIKInfo[5];

	if ($fitJoints[$i]!=$IKParentJoint)
		continue;
	if ($IKSolver!="ikRPsolver")
		continue;

	if (!`objExists FitSkeletonVisualizers`)
		createNode -n FitSkeletonVisualizers transform;
	if (!`objExists FitSkeletonPoleVectors`)
		{
		createNode -n FitSkeletonPoleVectors -p FitSkeletonVisualizers transform;
		setAttr FitSkeletonPoleVectors.inheritsTransform 0;
		}
	asFitModeEnsureShaders;
	asEnsureFitSkeletonAttributes;
	setAttr FitSkeleton.visPoleVector 1;

	polyCreateFacet -n ("VisualizePoleVector_"+$ik) -ch 0 -tx 1 -s 1 -p 0 0 0 -p 0 0 0 -p 0 0 0 -p 0 0 0;
	if ($ik=="Leg")
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ("VisualizePoleVector_"+$ik);
	parent ("VisualizePoleVector_"+$ik) FitSkeletonPoleVectors;
	sets -e -forceElement asRedSG ("VisualizePoleVector_"+$ik);
	setAttr ("VisualizePoleVector_"+$ik+".overrideEnabled") 1;
	setAttr ("VisualizePoleVector_"+$ik+".overrideDisplayType") 2;
	
	$tempString=`spaceLocator`;
	rename $tempString[0] ("VisualizePoleVector_"+$ik+"IKParent");
	parent ("VisualizePoleVector_"+$ik+"IKParent") ("VisualizePoleVector_"+$ik);
	setAttr ("VisualizePoleVector_"+$ik+"IKParent.v") 0;
	duplicate -n ("VisualizePoleVector_"+$ik+"IKChild") ("VisualizePoleVector_"+$ik+"IKParent");
	duplicate -n ("VisualizePoleVector_"+$ik+"IKMid") ("VisualizePoleVector_"+$ik+"IKParent");
	duplicate -n ("VisualizePoleVector_"+$ik+"IKMidFloat") ("VisualizePoleVector_"+$ik+"IKParent");
	duplicate -n ("VisualizePoleVector_"+$ik+"IKPoleVec") ("VisualizePoleVector_"+$ik+"IKParent");
	parent ("VisualizePoleVector_"+$ik+"IKPoleVec") ("VisualizePoleVector_"+$ik+"IKMidFloat");

	createNode -n ("VisualizePoleVector_"+$ik+"IKDist") distanceBetween;
	createNode -n ("VisualizePoleVector_"+$ik+"IKDistA") distanceBetween;
	createNode -n ("VisualizePoleVector_"+$ik+"IKDistB") distanceBetween;
	createNode -n ("VisualizePoleVector_"+$ik+"IKDistC") distanceBetween;
	connectAttr ("VisualizePoleVector_"+$ik+"IKParent.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDist.inMatrix1");
	connectAttr ("VisualizePoleVector_"+$ik+"IKChild.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDist.inMatrix2");
	connectAttr ("VisualizePoleVector_"+$ik+"IKParent.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDistA.inMatrix1");
	connectAttr ("VisualizePoleVector_"+$ik+"IKChild.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDistB.inMatrix1");
	connectAttr ("VisualizePoleVector_"+$ik+"IKMid.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDistC.inMatrix1");
	connectAttr ("VisualizePoleVector_"+$ik+"IKMid.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDistA.inMatrix2");
	connectAttr ("VisualizePoleVector_"+$ik+"IKMid.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDistB.inMatrix2");
	connectAttr ("VisualizePoleVector_"+$ik+"IKMidFloat.worldMatrix[0]") ("VisualizePoleVector_"+$ik+"IKDistC.inMatrix2");

	createNode -n ("VisualizePoleVector_"+$ik+"PMA") plusMinusAverage;
	connectAttr -f ("VisualizePoleVector_"+$ik+"IKDist.distance") ("VisualizePoleVector_"+$ik+"PMA.input1D[0]");
	connectAttr -f ("VisualizePoleVector_"+$ik+"IKDistC.distance") ("VisualizePoleVector_"+$ik+"PMA.input1D[1]");
	connectAttr ("VisualizePoleVector_"+$ik+"PMA.output1D") ("VisualizePoleVector_"+$ik+"IKPoleVec.tx");

	pointConstraint $IKParentJoint ("VisualizePoleVector_"+$ik+"IKParent");
	pointConstraint $IKChildJoint ("VisualizePoleVector_"+$ik+"IKChild");
	pointConstraint $IKMiddleJoint ("VisualizePoleVector_"+$ik+"IKMid");
	pointConstraint $IKParentJoint $IKChildJoint ("VisualizePoleVector_"+$ik+"IKMidFloat");

	connectAttr ("VisualizePoleVector_"+$ik+"IKDistB.distance") ("VisualizePoleVector_"+$ik+"IKMidFloat_pointConstraint1."+$IKParentJoint+"W0");
	connectAttr ("VisualizePoleVector_"+$ik+"IKDistA.distance") ("VisualizePoleVector_"+$ik+"IKMidFloat_pointConstraint1."+$IKChildJoint+"W1");

	aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation"
		-worldUpObject $IKParentJoint -worldUpVector 0 0 1 $IKMiddleJoint ("VisualizePoleVector_"+$ik+"IKMidFloat");

	connectAttr ("VisualizePoleVector_"+$ik+"IKParent.worldPosition[0]") ("VisualizePoleVector_"+$ik+"Shape.controlPoints[0]");
	connectAttr ("VisualizePoleVector_"+$ik+"IKPoleVec.worldPosition[0]") ("VisualizePoleVector_"+$ik+"Shape.controlPoints[1]");
	connectAttr ("VisualizePoleVector_"+$ik+"IKChild.worldPosition[0]") ("VisualizePoleVector_"+$ik+"Shape.controlPoints[2]");
	connectAttr ("VisualizePoleVector_"+$ik+"IKMid.worldPosition[0]") ("VisualizePoleVector_"+$ik+"Shape.controlPoints[3]");

//	setAttr ("VisualizePoleVector_"+$ik+"IKMidFloat.v") 1;

	}

catchQuiet (`select $sel`);
}

global proc asFitDisplayJointOrient (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientX");
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientY");
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientZ");
	}
if (`attributeExists visJointOrient FitSkeleton`)
	setAttr FitSkeleton.visJointOrient $onOff;
}

global proc asPADSCreateBlendablePreviewNodes ()
{
int $numCreated;
string $objectType,$blendTwoAttr;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$sdkXforms[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $sel[]=`ls -sl`;

if (!`objExists DrivingSystemBlendablePreview`)
	{
	$firstRun=1;
	createNode -n DrivingSystemBlendablePreview transform;
	asLockAttr DrivingSystemBlendablePreview 1 1 1 1;
	addAttr -k 1 -ln blend -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 DrivingSystemBlendablePreview;

	$tempString=`ls -type blendWeighted "bw*"`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists FaceAllSet`)
			if (`sets -im FaceAllSet $tempString[$i]`) //Skip FaceSetup
				continue;
		$tempString2=`listConnections -scn 1 ($tempString[$i]+".output")`;
		$objectType=`objectType $tempString2[0]`;
		if ($tempString2[0]=="" || `gmatch $objectType "animCurve*"`) //Skip outputBWs
			continue;
		if ($objectType=="pairBlend")//already pairBlended
			continue;		
		$tempString3=`listConnections -scn 1 -type animCurve ($tempString[$i]+".input")`;
		if ($tempString3[0]=="")
			continue;
		$tempString3=`listConnections -scn 1 -type blendWeighted ($tempString3[0]+".input")`;
		if ($tempString2[0]=="")
			continue;
		$tempString3=`listConnections -scn 1 -type transform ($tempString3[0]+".input")`;
		if ($tempString2[0]=="")
			continue;
		$tempString4=`listRelatives -p $tempString3[0]`;
		if ($tempString4[0]=="DrivingSystem") // Skip ordinary DrivingSystem
			continue;
		if (!`stringArrayCount $tempString2[0] $sdkXforms`)
			$sdkXforms[size($sdkXforms)]=$tempString2[0];
		}

	for ($i=0;$i<size($sdkXforms);$i++)
		for ($y=0;$y<size($trs);$y++)
			{
			for ($z=0;$z<size($xyz);$z++)
				{
				$blendTwoAttr=$sdkXforms[$i]+"BlendTwo"+$trs[$y]+$xyz[$z];
				$tempString2=`listConnections -s 1 -d 0 -scn 1 -p 1 ($sdkXforms[$i]+"."+$trs[$y]+$xyz[$z])`;
				for ($a=0;$a<size($tempString2);$a++)
					{
					if (!`objExists $blendTwoAttr`)
						{
						createNode -n $blendTwoAttr blendTwoAttr;
						addAttr -k 0 -ln PADSBTA -at bool -dv true $blendTwoAttr;//PADSBTA=PreviewAutomaticDrivingSystemBlendTwoAttr
						}
					setAttr ($blendTwoAttr+".input[0]") 0;
					if ($trs[$y]=="s")
						setAttr ($blendTwoAttr+".input[0]") 1;
					connectAttr $tempString2[$a] ($blendTwoAttr+".input[1]");
					connectAttr DrivingSystemBlendablePreview.blend ($blendTwoAttr+".attributesBlender");
					connectAttr -f ($blendTwoAttr+".output") ($sdkXforms[$i]+"."+$trs[$y]+$xyz[$z]);
					$numCreated++;
					}
				}
			}
	print ("// Created: "+$numCreated+" temporary Blendable Preview Nodes\n");
	select $sel;
	}
floatSliderGrp -e -en 1 asPADSFloatSliderGrp;
}

global proc asPADSDeleteBlendablePreviewNodes ()
{
string $tempString[],$tempString2[],$tempString3[];

print "// Deleting temporary Blendable Preview Nodes\n";
if (`objExists DrivingSystemBlendablePreview`)
	delete DrivingSystemBlendablePreview;

$tempString=`ls -type blendTwoAttr`;
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists PADSBTA $tempString[$i]`)
		{
		$tempString2=`listConnections -s 1 -d 0 -scn 1 -p 1 ($tempString[$i]+".input[1]")`;
		$tempString3=`listConnections -s 0 -d 1 -scn 1 -p 1 ($tempString[$i]+".output")`;
		if ($tempString2[0]=="")
			continue;
		connectAttr -f $tempString2[0] $tempString3[0];
		delete $tempString[$i];
		}
floatSliderGrp -e -v 1 -en 0 asPADSFloatSliderGrp;
}

global proc asDrivingSystemsPrintInfo ()
{
global string $gChannelBoxName;
float $softMinValue,$softMaxValue;
int $usingSelectedDrivingSystems;
int $testAnim=`checkBox -q -v asDsTestAnimCheckBox`;
string $ds;
string $sel[]=`ls -sl`;
string $drivingSystems[]=`asDsGetDrivingSystems`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $tempString[],$selectedDrivingSystems[],$attrs[];

checkBox -e -v 0 asDsTestAnimCheckBox;
print "//MEL script for re-use of DrivingSystems\n";
print ("//generated using AdvancedSkeleton v:"+`asGetScriptVersionAsString`+"\n");
print "global string $asDSObjName;\n";
print "global string $asDSAttrName;\n";

print "global int $asDSMirror;\n";
print "global int $asDSDisableMirror;\n";
print "global int $asDSAngle;\n";

print "global int $asDSAttrHasMin;\n";
print "global int $asDSAttrHasMax;\n";
print "global int $asDSAttrSoftLimits;\n";
print "global float $asDSAttrMin;\n";
print "global float $asDSAttrMax;\n";

print "global int $asBuilding;\n";
print "$asBuilding=1;\n";
print "$asDSMirror=1;\n";
print "$asDSDisableMirror=0;\n";
print "$asDSAngle=0;\n";
print "evalDeferred (\"$asBuilding=0\");\n";
print "\n";

//check if running Selected Only
for ($i=0;$i<size($sel);$i++)
	if (`stringArrayCount $sel[$i] $drivingSystems`)
		$selectedDrivingSystems[size($selectedDrivingSystems)]=$sel[$i];

if (size($selectedDrivingSystems))
	{
	$usingSelectedDrivingSystems=1;
	$drivingSystems=$selectedDrivingSystems;
	}

for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"` && !$usingSelectedDrivingSystems)
		continue;
	if (!`sets -im ControlSet $drivingSystems[$i]` && !$usingSelectedDrivingSystems)
		continue;//probably FaceSetup DS
	$attrs=`asDsGetAttrs $drivingSystems[$i]`;
	if ($usingSelectedDrivingSystems && size($selectedMainAttrs))
		{
		clear $attrs;
		for ($y=0;$y<size($selectedMainAttrs);$y++)
			{
			$tempString=`listAttr ($drivingSystems[$i]+"."+$selectedMainAttrs[$y])`;//short to long name for non-ud
			$attrs[$y]=$tempString[0];
			}
		}

	for ($y=0;$y<size($attrs);$y++)
//	for ($y=0;$y<1;$y++)
		{
		tokenize $drivingSystems[$i] "_" $tempString;
		$ds=$tempString[0];
		print ("// "+$ds+" : "+$attrs[$y]+"\n");
		print ("if (`attributeExists "+$attrs[$y]+" "+$drivingSystems[$i]+"`)\n");
		print ("\twarning (\"DrivingSystem alread exists:"+$drivingSystems[$i]+" : "+$attrs[$y]+"\");\n");
		print ("else\n");
		print ("\t{\n");
		print ("\t$asDSObjName=\""+$ds+"\";\n");
		print ("\t$asDSAttrName=\""+$attrs[$y]+"\";\n");

		if (`attributeQuery -softMaxExists -node $drivingSystems[$i] $attrs[$y]`)
			{
			$softMinValue=`addAttr -q -softMinValue ($drivingSystems[$i]+"."+$attrs[$y])`;
			$softMaxValue=`addAttr -q -softMaxValue ($drivingSystems[$i]+"."+$attrs[$y])`;
			print ("\t$asDSAttrHasMin="+`addAttr -q -hasSoftMinValue ($drivingSystems[$i]+"."+$attrs[$y])`+";\n");
			print ("\t$asDSAttrHasMax="+`addAttr -q -hasSoftMaxValue ($drivingSystems[$i]+"."+$attrs[$y])`+";\n");
			print ("\t$asDSAttrSoftLimits="+`addAttr -q -hasSoftMaxValue ($drivingSystems[$i]+"."+$attrs[$y])`+";\n");
			print ("\t$asDSAttrMin="+$softMinValue+";\n");
			print ("\t$asDSAttrMax="+$softMaxValue+";\n");
			}

		asDsEdit Edit $drivingSystems[$i] $attrs[$y] 10;
		print ("\tasDsCreate;//driverValue=10\n");
		asDsEditCancel;

		if ($softMinValue<0)//has Neg
			{
			print ("\tsetAttr "+$drivingSystems[$i]+"."+$attrs[$y]+" "+$softMinValue+";\n");
			print ("\tasDsAutoFindAndEdit;\n");
			asDsEdit Edit $drivingSystems[$i] $attrs[$y] $softMinValue;
			print ("\tasDsEditApply;\n");
			asDsEditCancel;		
			print ("\tsetAttr "+$drivingSystems[$i]+"."+$attrs[$y]+" 0;\n");
			}

		print ("\t}\n");
		print ("\n");
		}
	}
checkBox -e -v $testAnim asDsTestAnimCheckBox;
}

global proc asCreateNonSymmetryJoints ()
{
int $isCenterJoint,$parentIsCenterJoint;
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
string $tempString[],$tempString2[],$tempString3[];

if (!`objExists Root`)
	error "Root joint not found";

$tempString=`ls -type joint "*_NonSymmetry"`;
if (size($tempString))
	{
	print ("Existing NonSymmetry joints found, Now deleting these.\n");
	delete $tempString;
	return;
	}

asFitModeManualUpdate;
$tempString=`listRelatives -ad -type joint Root`;
for ($i=0;$i<size($tempString);$i++)
	{
	$isCenterJoint=$parentIsCenterJoint=1;
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[0]<-$centerTolerance || $pos[0]>$centerTolerance)
		$isCenterJoint=0;
	$tempString2=`listRelatives -p -type joint $tempString[$i]`;
	$pos=`xform -q -ws -t $tempString2[0]`;
	if ($pos[0]<-$centerTolerance || $pos[0]>$centerTolerance)
		$parentIsCenterJoint=0;
	if (!$isCenterJoint && $parentIsCenterJoint)
		{
		$tempString3=`mirrorJoint -mirrorYZ -mirrorBehavior $tempString[$i]`;
		$tempString4=`listRelatives -ad -type joint $tempString[$i]`;$tempString4[size($tempString4)]=$tempString[$i];
		$tempString5=`listRelatives -ad -type joint $tempString3[0]`;$tempString5[size($tempString5)]=$tempString3[0];
		for ($y=0;$y<size($tempString5);$y++)
			{
			rename $tempString5[$y] ($tempString4[$y]+"_NonSymmetry");
			setAttr ($tempString4[$y]+"_NonSymmetry.drawLabel") 0;
			}
		}
	}
asFitModeManualUpdate;
select -cl;
print "// Non-Symmetry-Joints created.\n";
}

global proc asFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr3;
string $sel[]=`ls -sl`;
int $onOff=1;
if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
	$onOff=0;
//asByPassSDK $onOff;
select -cl;
if ($onOff)
	{
	asFitModeManualUpdate;
	$asFitModeScriptJobNr1=`scriptJob -cu 1 -killWithScene -e SelectionChanged asFitModeSelectionChanged`;
	if (`objExists FitSkeleton`)
		$asFitModeScriptJobNr3=`scriptJob -cu 1 -killWithScene -ac FitSkeleton.s asFitModeUpdateScale`;
	headsUpDisplay -s 2 -b 0 -bs "medium" -l "FitMode" -lfs "large" HUDFitMode;
	print "// Entered FitMode\n";
	}
else
	{
	if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr1;
		$asFitModeScriptJobNr1=0;
		}
	if (`scriptJob -ex $asFitModeScriptJobNr3`  && $asFitModeScriptJobNr3!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr3;
		$asFitModeScriptJobNr3=0;
		}
	asFitModeSelectionChanged;
	if (`headsUpDisplay -ex HUDFitMode`)
		headsUpDisplay -rem HUDFitMode;
	print "// Exited FitMode\n";
	}
select $sel;
}

global proc asToggleFitAdvancedSkeleton ()
{
int $fitSkeletonVis=`getAttr FitSkeleton.v`;
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v (!$fitSkeletonVis);
setAttr MotionSystem.v $fitSkeletonVis;
setAttr DeformationSystem.v $fitSkeletonVis;
if (!$fitSkeletonVis)
	asDsToFitSkeleton;
asUpdateButtonEnables;
}

global proc asDsToFitSkeleton ()
{
int $attrNr;
string $tempString[],$drivingSystems[],$userAttrs[],$attrs[],$sdks[],$sortedSdks[],$udAttrs[];
string $addAttrCmd;

if (!`objExists DrivingSystem`)
	return;
if (!`objExists ControlSet`)
	return;

if (`attributeExists drivingSystem FitSkeleton`)
	deleteAttr FitSkeleton.drivingSystem;
addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;

$userAttrs=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	if (`gmatch $userAttrs[$i] "drivingSystem_*"`)
		deleteAttr ("FitSkeleton."+$userAttrs[$i]);

//$drivingSystems=`listRelatives -c DrivingSystem`;
$drivingSystems=`asDsGetDrivingSystems`;

for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (!`sets -im ControlSet $drivingSystems[$i]`)
		continue;//probably FaceSetup DS
	addAttr -k 0 -ln ("drivingSystem_"+$drivingSystems[$i]) -at bool -dv true -multi FitSkeleton;
	$attrNr=0; 
//	$userAttrs=`listAttr -ud -s -k $drivingSystems[$i]`;
	$attrs=`asDsGetAttrs $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		$sdks=`listConnections -s 0 -d 1 -scn 1 ($drivingSystems[$i]+"."+$attrs[$y])`;
		$tempString=`listConnections -s 0 -d 1 -scn 1 -type blendWeighted ($drivingSystems[$i]+"."+$attrs[$y])`;
		if (size($tempString))//v>5.732
			$sdks=`listConnections -s 0 -d 1 -scn 1 -type animCurve ($tempString[0]+".output")`;

		//sort translate before rotate
		clear $sortedSdks;
		for ($z=0;$z<size($sdks);$z++)
			if (`gmatch $sdks[$z] "*_translate*"`)
				$sortedSdks[size($sortedSdks)]=$sdks[$z];
		for ($z=0;$z<size($sdks);$z++)
			if (`gmatch $sdks[$z] "*_rotate*"`)
				$sortedSdks[size($sortedSdks)]=$sdks[$z];
		for ($z=0;$z<size($sdks);$z++)
			if (!`stringArrayCount $sdks[$z] $sortedSdks`)
				$sortedSdks[size($sortedSdks)]=$sdks[$z];
		for ($z=0;$z<size($sortedSdks);$z++)
			{
			if (!`attributeExists drivingSystemOut $sortedSdks[$z]`) addAttr -k 0 -ln drivingSystemOut -at message $sortedSdks[$z];
			if (`attributeExists $attrs[$y] $sortedSdks[$z]`)
				deleteAttr ($sortedSdks[$z]+"."+$attrs[$y]);
			$udAttrs=`listAttr -ud $drivingSystems[$i]`;
			$addAttrCmd="addAttr -k 0 -ln "+$attrs[$y]+" -at \"float\" ";
			if (`stringArrayCount $attrs[$y] $udAttrs`)//ud attrs only
				{
				if (`addAttr -q -hasMinValue ($drivingSystems[$i]+"."+$attrs[$y])`)
					$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($drivingSystems[$i]+"."+$attrs[$y])`+" ";
				if (`addAttr -q -hasMaxValue ($drivingSystems[$i]+"."+$attrs[$y])`)
					$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($drivingSystems[$i]+"."+$attrs[$y])`+" ";
				if (`addAttr -q -hasSoftMinValue ($drivingSystems[$i]+"."+$attrs[$y])`)
					$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($drivingSystems[$i]+"."+$attrs[$y])`+" ";
				if (`addAttr -q -hasSoftMaxValue ($drivingSystems[$i]+"."+$attrs[$y])`)
					$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($drivingSystems[$i]+"."+$attrs[$y])`+" ";
				}
			$addAttrCmd+=$sortedSdks[$z];
			eval ($addAttrCmd);

			connectAttr -f ("FitSkeleton.drivingSystem_"+$drivingSystems[$i]+"["+$attrNr+"]") ($sortedSdks[$z]+"."+$attrs[$y]);
			$tempString=`listConnections ($sortedSdks[$z]+".drivingSystemOut")`;
			if ($tempString[0]!="FitSkeleton")
				connectAttr -na ($sortedSdks[$z]+".drivingSystemOut") FitSkeleton.drivingSystem;
			$attrNr++;
			}
		}
	}
}

global proc asTglBodyGameEngine ()
{
int $gameEngine=`checkBox -q -v asBodyGameEngineCheckBox`;
if (`attributeExists gameEngine FitSkeleton`)
	setAttr FitSkeleton.gameEngine $gameEngine;
asSavePrepInput;
asUpdateButtonEnables;
}

global proc asTglZUpAxisEngine ()
{
int $zUpAxis=`checkBox -q -v asBodyZUpAxisCheckBox`;
string $upAxisDirection=`upAxis -q -ax`;
string $switchToAxis;

if ($zUpAxis)
	if (`confirmDialog -t "Confirm"
		-m ("It is Highly recommended to Stay with Maya Y-Up axis\n\n"
			+"Switching Maya to Z-up has many undesired side effects.\n\n"
			+"( any Unreal export will automatically Convert to Z-up )")
		-b "Proceed Anyway" -b "Cancel" -db "Cancel"
		-ds "Cancel"`!="Proceed Anyway")
		{
		checkBox -e -v 0 asBodyZUpAxisCheckBox;
		return;
		}

if (`attributeExists zUpAxis FitSkeleton`)
	setAttr FitSkeleton.zUpAxis $zUpAxis;
asSavePrepInput;
asUpdateButtonEnables;

//switching UpAxis
if ($upAxisDirection=="y" && $zUpAxis)
	$switchToAxis="z";
if ($upAxisDirection=="z" && !$zUpAxis)
	$switchToAxis="y";

if ($switchToAxis!="")
	{
	if (`objExists Group`)
		asSceneUpAxisFlip Group $switchToAxis;
	else if (`objExists FitSkeleton`)
		asSceneUpAxisFlip FitSkeleton $switchToAxis;
	else
		setUpAxis $switchToAxis;
	optionVar -sv "upAxisDirection" $switchToAxis;
	print ("// Switched to \""+$switchToAxis+"\" up axis.\n");
	refresh;
	}
}

global proc asTglOPM ()
{
$opm=`checkBox -q -v asBodyOffsetParentMatrixCheckBox`;

//$opm non-compatibles
if ($opm && `asMayaVersionAsFloat`<2020)
	{
	confirmDialog -t "Error" -m "Offset Parent Matrix requires Maya2020 (or higher)" -b "OK" -db "OK";
	checkBox -e -v 0 asBodyOffsetParentMatrixCheckBox;
	}

asSavePrepInput;
asUpdateButtonEnables;
}

global proc asChooseBodyInput (string $textField)
{
string $txt;
string $sel[]=`ls -sl`;
string $tempString[],$selGeos[];

for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*|*"`)
		{
		tokenize $sel[$i] "|" $tempString;
		select `ls $tempString[size($tempString)-1]`;
		error ("Object: \""+$sel[$i]+"\" does not have a unique name."
			+"All objects with this name is now selected. Rename objects to have unique names");
		}

	$tempString=`listRelatives -s $sel[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="mesh")
			$selGeos[size($selGeos)]=$sel[$i];
	}


$txt=$selGeos[0];
for ($i=1;$i<size($selGeos);$i++)
	$txt+=" "+$selGeos[$i];

textField -e -tx $txt $textField;
asSavePrepInput;
asUpdateButtonEnables;
}

global proc asSavePrepInput ()
{
//global int $asBodyPreGameEngine;
//global int $asBodyPreZUpAxis;
//global int $asBodyPreOPM;
global string $asBodyPreSkin;
global string $asBodyPreAll;
global string $asBodyPreRightEye;
global string $asBodyPreLeftEye;
string $skin=`textField -q -tx asBodySkinTextField`;
string $all=`textField -q -tx asBodyAllTextField`;
string $rightEye=`textField -q -tx asBodyRightEyeTextField`;
string $leftEye=`textField -q -tx asBodyLeftEyeTextField`;
int $gameEngine=`checkBox -q -v asBodyGameEngineCheckBox`;
int $zUpAxis=`checkBox -q -v asBodyZUpAxisCheckBox`;
int $opm=`checkBox -q -v asBodyOffsetParentMatrixCheckBox`;

//save as optionVars
optionVar -iv asBodyPreGameEngine $gameEngine;
optionVar -iv asBodyPreZUpAxis $zUpAxis;
optionVar -iv asBodyPreOPM $opm;

if (!`objExists FitSkeleton`)
	{
	$asBodyPreSkin=$skin;
	$asBodyPreAll=$all;
	$asBodyPreRightEye=$rightEye;
	$asBodyPreLeftEye=$leftEye;
	}

if (`objExists FitSkeleton`)//save as FitSkeleton attrs
	{
	setAttr -type "string" FitSkeleton.objectsSkin $skin;
	setAttr -type "string" FitSkeleton.objectsAll  $all;
	setAttr -type "string" FitSkeleton.objectsRightEye  $rightEye;
	setAttr -type "string" FitSkeleton.objectsLeftEye   $leftEye;
	setAttr FitSkeleton.gameEngine $gameEngine;
	setAttr FitSkeleton.zUpAxis $zUpAxis;
	setAttr FitSkeleton.useOffsetParentMatrix $opm;
	}
}

global proc asUniqueNameAll ()
{
int $handDuplicated;
string $fingers[]={"Thumb","Pinky","Ring","Middle","Cup","Index"};
string $fitJoints[],$sdks[];

//backwards compatibility, for DrivingSystems from versions prior to 5.593 (remove SDK[0-9] number)
$sdks=`listConnections -s 1 -d 0 -type animCurve FitSkeleton`;
for ($y=0;$y<size($sdks);$y++)
	if (`gmatch $sdks[$y] "SDK[0-9]*"`)
		rename $sdks[$y] ("SDK"+`substring $sdks[$y] 5 99`);

$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	if (`gmatch $fitJoints[$i] "*IndexFinger*"`)
		if (size(`ls $fitJoints[$i]`)>1)
			{
			$handDuplicated=1;
			break;
			}

//sort for preffered order of appearance of Finger DS attributes
if ($handDuplicated)
	for ($y=0;$y<size($fingers);$y++)
		for ($i=0;$i<size($fitJoints);$i++)
			if (`gmatch $fitJoints[$i] ("*"+$fingers[$y]+"*")`)
				{
				stringArrayInsertAtIndex(0, $fitJoints, $fitJoints[$i]);
				stringArrayRemoveAtIndex(($i+1), $fitJoints);
				}

for ($i=0;$i<size($fitJoints);$i++)
	$fitJoints[$i]=`asUniqueName $fitJoints[$i]`;
}

global proc string asUniqueName (string $obj)
{
int $numConnections;
string $newName=$obj;
string $newSDKname,$renameSuffix;
string $tempString[]=`ls $obj`;
string $tempString2[],$tempString3[],$tempString4[],$tempString5[],$tempString6[];

if (size($tempString)>1)
	for ($i=1;$i<99;$i++)
		if (!`objExists ($obj+$i)`)
			{
			$renameSuffix=$i;
			$newName=$obj+$renameSuffix;
			rename $tempString[0] $newName;
			//also duplicate associated DrivingSystems
			if (!`objExists FitSkeleton`)
				continue;
			$tempString2=`listConnections -s 1 -d 0 -type animCurve FitSkeleton`;
			for ($y=0;$y<size($tempString2);$y++)
				{
				if (!`gmatch $tempString2[$y] ("*"+$obj+"*")`)
					continue;
				$newSDKname=`substitute $obj $tempString2[$y] $newName`;
				if (`objExists $newSDKname`)
					error ("Tried to duplicate DrivingSystem \""+$tempString2[$y]+"\", and name it \""+$newSDKname+"\", but the name is taken");
				duplicate -n $newSDKname $tempString2[$y];
// duplication includes this connection
//				connectAttr -na ($newSDKname+".") FitSkeleton.drivingSystem;
				$tempString3=`listConnections -s 1 -d 0 -p 1 $tempString2[$y]`;
				tokenize $tempString3[0] "." $tempString4;
				tokenize $tempString4[1] "[" $tempString4;
				tokenize $tempString4[0] "_" $tempString4;
				$newFitSkeletonAttr=$tempString4[0]+"_"+$tempString4[1]+$renameSuffix+"_"+$tempString4[2];
//$tempString7=`listAttr -ud $newSDKname`;
//print ("duplicate -n "+$newSDKname+" "+$tempString2[$y]+" : "+$tempString7[1]+"\n");
				if (!`attributeExists $newFitSkeletonAttr FitSkeleton`)
					addAttr -k 0 -ln $newFitSkeletonAttr -at bool -dv true -multi FitSkeleton;
				$tempString5=`listConnections -s 1 -d 0 -p 1 -c 1 $tempString2[$y]`;
				tokenize $tempString5[0] "." $tempString6;
				$numConnections=`getAttr -s ("FitSkeleton."+$newFitSkeletonAttr)`;
				connectAttr ("FitSkeleton."+$newFitSkeletonAttr+"["+$numConnections+"]") ($newSDKname+"."+$tempString6[1]);
				select $newSDKname $tempString2[$y];
				}
			break;
			}
return $newName;
}

global proc asSetControlOrient ()
{
int $numCtrls,$numChar,$worldorient,$worldmatch,$curveUnafeccted,$mirror,$mirroredBehaviour,$mirroredTranslate,$spans,$degree,$numCVs,$hadXparentConstraint;
int $isCustomCtrl,$isClusterControl,$isSoftModControl,$isSquashControl,$customControlLocalOrient,$hasExtra,$inMirrorRun,$startWasLeft,$customAxis;
int $batchMode=`objExists asSetControlOrientBatchMode`;
int $opm=`asGetOpm`;
float $version;
float $aimV[],$upV[],$pos[];
float $wupV[]={0,0,1};
string $priAxis="X";
string $secAxis="Y";
string $ctrl,$offSet,$extra,$deformJoint,$fkIkCtrl,$type,$name,$side,$cmd,$oppositeCtrl,$pluralSuffix,$modifiedCtrlsString,$parent;
string $alignTo,$alignToOffset,$endJoint;
string $sel[]=`ls -sl`;
string $originalSel[]=`ls -sl`;
string $children[],$tempString[],$tempString2[],$shapes[],$controlSetMembers[];
string $checkAttr[]={"twistJoints","inbetweenJoints"};

if (!$batchMode)
	if (!`asConfirmIfNotInBuildPose`)
		return;

if (`objExists asControlOrientDetachParentHolder`)
	error "Can not \"Set Axis\", when controllers are Detached.";
if (!size($sel))
	error "Nothing Selected, Make sure to select controller first.";
if (`objExists asSetControlOrientParentHolder`)
	error "Found object \"asSetControlOrientParentHolder\", indicating a previous failed attempt, please undo until this object no longer exists.";

asVersionRequirementCheck body 6.210;

if (`attributeExists version Main`)
	$version=`getAttr Main.version`;

if ($batchMode)
	{
	//make all ctrls that have had Customized Orient added, the selection
	select -cl;
	$controlSetMembers=`sets -q ControlSet`;
	for ($i=0;$i<size($controlSetMembers);$i++)
		if (`attributeExists primaryAxis $controlSetMembers[$i]` || `attributeExists customAxis $controlSetMembers[$i]`)
			if ($controlSetMembers[$i]!="Main")
				select -add $controlSetMembers[$i];
	$sel=$originalSel=`ls -sl`;
	if (!size($sel))
		return;
	}
if (!$batchMode)
	{
	$priAxis=`optionMenu -q -v asPrimaryAxisOptionMenu`;
	$secAxis=`optionMenu -q -v asSecondaryAxisOptionMenu`;
	$worldorient=`checkBox -q -v asControlOrientWorldOrientCheckBox`;
	$worldmatch=`checkBox -q -v asControlOrientWorldMatchCheckBox`;
	$curveUnafeccted=`checkBox -q -v asControlOrientCurveUnafecctedCheckBox`;
	$mirror=`checkBox -q -v asControlOrientMirrorCheckBox`;
	$mirroredBehaviour=`checkBox -q -v asControlOrientMirroredBehaviourCheckBox`;
	$mirroredTranslate=`checkBox -q -v asControlOrientMirroredTranslateCheckBox`;
	}

for ($i=0;$i<size($sel);$i++)
	{
	if ($i>=size($originalSel))
		$inMirrorRun=1;
	$type=`asInfoFromCtrl $sel[$i] type`;
	$name=`asInfoFromCtrl $sel[$i] name`;
	$side=`asInfoFromCtrl $sel[$i] side`;
	$deformJoint=$name+$side;

	$ctrl=$type+$name+$side;
	$offSet=$type+"Offset"+$name+$side;
	$extra=$type+"Extra"+$name+$side;

	//warn about worldorient usage
	if ($worldorient && !$batchMode && !$inMirrorRun)
		for ($y=0;$y<size($checkAttr);$y++)
			if (`attributeExists $checkAttr[$y] $name`)
				if (`confirmDialog -title "Confirm"
					-m ("World-Orient on a joints with \""+$checkAttr[$y]+"\"\nwill most likely cause issues.\nUse World-match instead")
	    		-b "Proceed Anyway" -button "Cancel"`!="Proceed Anyway")
						return;

	$hasExtra=1;
	if (`attributeExists skinControl $ctrl`) {$isCustomCtrl=1;$hasExtra=0;}
	if (`attributeExists clusterControl $ctrl`) {$isCustomCtrl=1;$isClusterControl=1;}
	if (`attributeExists softModControl $ctrl`) {$isCustomCtrl=1;$isSoftModControl=1;}
	if (`attributeExists SquashControl $ctrl`) {$isCustomCtrl=1;$isSquashControl=1;}
	if ($isCustomCtrl)
		{
		$extra=$type+$name+"Subtract"+$side;
		$pos=`xform -q -ws -t $ctrl`;
		$deformJoint=`getAttr ($ctrl+".parent")`;
		$customControlLocalOrient=0;
		if (`attributeExists localOrient $ctrl`)
			if (`getAttr ($ctrl+".localOrient")`)
				$customControlLocalOrient=1;
		}

	if ($isClusterControl)
		$extra="Subtract"+$name+$side;
	if ($isSoftModControl)
		$extra=$name+"Base"+$side;
	if ($isSquashControl)
		{
		$extra=$name+"Base"+$side;
		$offSet=$type+$name+"Offset"+$side;
		warning ("Unable to CustomOrient SquashController: \""+$sel[$i]+"\", skipping this.\n");
		continue;
		}

	if ($isSoftModControl)
		$offSet=$name+"Base"+$side;

	if ($type=="Bend" && `gmatch $name "*[0-9]"`)
		{
		$numChar=size($name);
		$deformJoint=`substring $name 1 ($numChar-1)`+$side;
		}

	$customAxis=0;
	if (`attributeExists customAxis $sel[$i]`)
		$customAxis=`getAttr ($sel[$i]+".customAxis")`;

	if ($sel[$i]!=$ctrl) {warning ("Unable to determine controller for: \""+$sel[$i]+"\", skipping this.\n");continue;}
//	if ($isCustomCtrl && !$customControlLocalOrient) {warning ("CustomControl: \""+$sel[$i]+"\" was not Created with \"localOrient\", skipping this.\n");continue;}
	if ($isCustomCtrl && $version<6.2355) {warning ("old version CustomControl : \""+$sel[$i]+"\" ReBuild, before this can work, skipping this.\n");continue;}
	if ($type=="" && !$isCustomCtrl) {warning ("Unable to determine controller-type for: \""+$sel[$i]+"\", skipping this.\n");continue;}
	if ($deformJoint=="") {warning ("Unable to determine deformJoint for: \""+$sel[$i]+"\", skipping this.\n");continue;}
	if ($type=="Root") {warning ("Root Controller must keep World-orientation, skipping this.\n");continue;}
	if ($type=="HipSwinger") {warning ("HipSwinger Controller must keep World-orientation, skipping this.\n");continue;}
	if ($type=="Extra") {warning ("Extra controller was choosen: \""+$sel[$i]+"\", skipping this.\n");continue;}
	if ($type=="Micro") {warning ("Extra controller was choosen: \""+$sel[$i]+"\", skipping this.\n");continue;}
	if (!`objExists $extra` && $hasExtra) {warning ("Unable to find Extra controller: \""+$type+"Extra"+$name+$side+"\".\n");continue;}

	if (!$inMirrorRun)
		{
		$startWasLeft=0;
		if ($side=="_L")
			$startWasLeft=1;
		}

	if ($mirror && !$inMirrorRun)
		{
		$numChar=size($sel[$i]);
		
		if ($side=="_R") $oppositeCtrl=`substring $sel[$i] 1 ($numChar-2)`+"_L";
		if ($side=="_L") $oppositeCtrl=`substring $sel[$i] 1 ($numChar-2)`+"_R";
		if (`objExists $oppositeCtrl` && !`stringArrayCount $oppositeCtrl $sel`)
			$sel[size($sel)]=$oppositeCtrl;
		}

	if ($type=="IK" || $type=="Pole" || $type=="IKhybrid")
		{
		$fkIkCtrl=`asFindFKIKCtrl $sel[$i]`;
		if ($fkIkCtrl=="")
			{
			warning ("Unable to determine FKIK-controller for:\""+$sel[$i]+"\", skipping this.\n");
			continue;
			}
		$deformJoint=`getAttr ($fkIkCtrl+".endJoint")`+$side;//this assumes `standard` ctrl (e.g IKLeg_R)
		if (`objExists ("AlignIKTo"+$name+$side)` && `objExists ($name+$side)`)//in cause of `non-standard` ctrl (e.g IKToes_R)
			$deformJoint=$name+$side;
		if ($type=="Pole") $deformJoint=`getAttr ($fkIkCtrl+".middleJoint")`+$side;
		}

	if ($hasExtra)
		$tempString=`listRelatives -p $extra`;
	else
		$tempString=`listRelatives -p $ctrl`;
	$parent=$tempString[0];
	$children=`listRelatives -c -type transform $sel[$i]`;
	$rlaChild=`asRlaChild $deformJoint`;
	$shapes=`listRelatives -s -type nurbsCurve $sel[$i]`;
	if (!`objExists $offSet`)
		{
		warning ("Unable to find:\""+$offSet+"\", skipping this.\n");
		continue;
		}
//	$offsetChildren=`listRelatives -c -type transform $offSet`;
	if (!`objExists $rlaChild` && !$worldorient && !$worldmatch)
		{
		warning ("Unable to RLA-Child for :\""+$sel[$i]+"\" to aim-at, skipping this.\n");
		continue;
		}

	if ($batchMode && !$customAxis)
		{
		if (`attributeExists primaryAxis       $sel[$i]`) $priAxis=`getAttr -asString ($sel[$i]+".primaryAxis")`;
		if (`attributeExists secondaryAxis     $sel[$i]`) $secAxis=`getAttr -asString ($sel[$i]+".secondaryAxis")`;
		if (`attributeExists worldorient       $sel[$i]`) $worldorient=`getAttr ($sel[$i]+".worldorient")`;
		if (`attributeExists worldmatch        $sel[$i]`) $worldmatch=`getAttr ($sel[$i]+".worldmatch")`;
		if (`attributeExists curveUnafeccted   $sel[$i]`) $curveUnafeccted=`getAttr ($sel[$i]+".curveUnafeccted")`;
		if (`attributeExists mirror            $sel[$i]`) $mirror=`getAttr ($sel[$i]+".mirror")`;
		if (`attributeExists mirroredBehaviour $sel[$i]`) $mirroredBehaviour=`getAttr ($sel[$i]+".mirroredBehaviour")`;
		if (`attributeExists mirroredTranslate $sel[$i]`) $mirroredTranslate=`getAttr ($sel[$i]+".mirroredTranslate")`;
		}
	if (!$batchMode)
		{
		if (!`attributeExists primaryAxis       $sel[$i]`) addAttr -ln primaryAxis   -at "enum" -en "X:Y:Z:-X:-Y:-Z:"$sel[$i];
		if (!`attributeExists secondaryAxis     $sel[$i]`) addAttr -ln secondaryAxis -at "enum" -en "X:Y:Z:-X:-Y:-Z:" $sel[$i];
		if (!`attributeExists worldorient       $sel[$i]`) addAttr -ln worldorient -at bool $sel[$i];
		if (!`attributeExists worldmatch        $sel[$i]`) addAttr -ln worldmatch -at bool $sel[$i];
		if (!`attributeExists curveUnafeccted   $sel[$i]`) addAttr -ln curveUnafeccted -at bool $sel[$i];
		if (!`attributeExists mirror            $sel[$i]`) addAttr -ln mirror -at bool $sel[$i];
		if (!`attributeExists mirroredBehaviour $sel[$i]`) addAttr -ln mirroredBehaviour -at bool $sel[$i];
		if (!`attributeExists mirroredTranslate $sel[$i]`) addAttr -ln mirroredTranslate -at bool $sel[$i];
		
		setAttr ($sel[$i]+".worldorient") $worldorient;
		setAttr ($sel[$i]+".worldmatch") $worldmatch;
		setAttr ($sel[$i]+".curveUnafeccted") $curveUnafeccted;
		setAttr ($sel[$i]+".mirror") $mirror;
		setAttr ($sel[$i]+".mirroredBehaviour") $mirroredBehaviour;
		setAttr ($sel[$i]+".mirroredTranslate") $mirroredTranslate;

		setAttr ($sel[$i]+".primaryAxis")   `asAxisToAxisEnumValue $priAxis`;
		setAttr ($sel[$i]+".secondaryAxis") `asAxisToAxisEnumValue $secAxis`;
		}

	if ($customAxis && !$batchMode)
		{//remove CustomOrient & Reverse nodes
		$tempString=`listRelatives -p ("CustomOrient"+$type+$name+$side)`;
		if ($hasExtra)
			parent -r $extra $tempString;
		else
			parent -r $ctrl $tempString;
		$children=`listRelatives -c -type transform ("CustomOrientReverse"+$type+$name+$side)`;
		if (size($children))
			parent -r $children ($type+$name+$side);
		delete ("CustomOrient"+$type+$name+$side) ("CustomOrientReverse"+$type+$name+$side);
		if (`attributeExists customAxis ($type+$name+$side)`)
			setAttr ($type+$name+$side+".customAxis") 0;
		}

	if ($worldorient || $worldmatch)
		{
		$priAxis="X";
		$secAxis="Z";
		}

	$aimV=`asAxisToVector $priAxis`;
	$upV=`asAxisToVector $secAxis`;



	if ($curveUnafeccted)
		for ($y=0;$y<size($shapes);$y++)
			{
			$spans=`getAttr ($shapes[$y]+".spans")`;
			$degree=`getAttr ($shapes[$y]+".degree")`;
			$numCVs=$spans+$degree;
			for ($z=0;$z<$numCVs;$z++)
				{
				$pos=`xform -q -ws -t ($shapes[$y]+".cv["+$z+"]")`;
				$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$shapes[$y]+".cv["+$z+"];";
				}
			}

	createNode -n asSetControlOrientParentHolder transform;
	if (!`objExists ("CustomOrientReverse"+$type+$name+$side)`)
		{
		createNode -n ("CustomOrientReverse"+$type+$name+$side) -p $sel[$i] transform;
		if (!$isCustomCtrl)
			sets -add AllSet ("CustomOrientReverse"+$type+$name+$side);//to prevent it attmpting to preserve this upon reBuild
		if (size($children))
			parent $children ("CustomOrientReverse"+$type+$name+$side);
		}
	parent ("CustomOrientReverse"+$type+$name+$side) asSetControlOrientParentHolder;

	if (!`objExists ("CustomOrient"+$type+$name+$side)`)
		{
		createNode -n ("CustomOrient"+$type+$name+$side) -p $parent transform;
		if (!$isCustomCtrl)
			sets -add AllSet ("CustomOrient"+$type+$name+$side);//to prevent it attmpting to preserve this upon reBuild
		if ($hasExtra)
			parent $extra ("CustomOrient"+$type+$name+$side);
		else
			parent $ctrl ("CustomOrient"+$type+$name+$side);		
		}

	//special case "X" parentConstraint
	$hadXparentConstraint=0;
	if (`objExists ($type+$name+"X"+$side+"_parentConstraint1")`)
		{
		delete ($type+$name+"X"+$side+"_parentConstraint1");
		$hadXparentConstraint=1;
		}

	//$mirroredTranslate
	setAttr ("CustomOrient"+$type+$name+$side+".s") -type float3 1 1 1;
	if ($side=="_L" && $mirroredTranslate)
		setAttr ("CustomOrient"+$type+$name+$side+".s") -type float3 -1 -1 -1;

	createNode -n tempAimAtTarget transform;
	asAlign tempAimAtTarget $rlaChild 1 1 0 0;
	if ($worldorient || $worldmatch)
		{
		asAlign tempAimAtTarget $sel[$i] 1 1 0 0;
		move -ws -r 1 0 0 tempAimAtTarget;
		}

	if ($worldmatch)
		{
		createNode -n tempWSsampler1 transform;
		asAlign tempWSsampler1 $deformJoint 1 0 0 0;
		createNode -n tempWSsampler2 -p tempWSsampler1 transform;
		parent tempWSsampler2 $deformJoint;
		setAttr tempWSsampler2.tx 1;
		asAlign tempAimAtTarget tempWSsampler2 1 0 0 0;
		parent tempWSsampler2 tempWSsampler1;
		$pos=`getAttr tempWSsampler2.t`;

		if (abs($pos[0])>abs($pos[1]) && abs($pos[0])>abs($pos[2]))
			{$aimV={1,0,0};if ($pos[0]<0) $aimV={-1,0,0};}//X
		if (abs($pos[1])>abs($pos[0]) && abs($pos[1])>abs($pos[2]))
			{$aimV={0,1,0};if ($pos[1]<0) $aimV={0,-1,0};}//Y
		if (abs($pos[2])>abs($pos[0]) && abs($pos[2])>abs($pos[1]))
			{$aimV={0,0,1};if ($pos[2]<0) $aimV={0,0,-1};}//Z

		if ($aimV[0]!=0) $upV=$wupV={0,1,0};
		if ($aimV[1]!=0) $upV=$wupV={0,0,1};
		if ($aimV[2]!=0) $upV=$wupV={0,1,0};

		delete tempWSsampler1;
		}


	if ($startWasLeft && $mirroredBehaviour)//Left was selected //
		{
		if (!$worldorient && !$worldmatch)
			$aimV[0]=$aimV[0]*-1;$aimV[1]=$aimV[1]*-1;$aimV[2]=$aimV[2]*-1;
		$upV[0]=$upV[0]*-1;$upV[1]=$upV[1]*-1;$upV[2]=$upV[2]*-1;
		}

	//mirror
	if ($inMirrorRun && $mirroredBehaviour)
		{
		if (!$worldorient && !$worldmatch)
			$aimV[0]=$aimV[0]*-1;$aimV[1]=$aimV[1]*-1;$aimV[2]=$aimV[2]*-1;
		$upV[0]=$upV[0]*-1;$upV[1]=$upV[1]*-1;$upV[2]=$upV[2]*-1;
		}


	if ($isCustomCtrl && !$worldorient	&& !$worldmatch)//compansate for the Offset position of CustomControllers (on skin instead of at joint)
		{
		$pos=`xform -q -ws -t ("CustomOrient"+$type+$name+$side)`;
		$tempString=`listRelatives -p $rlaChild`;
		asAlign ("CustomOrient"+$type+$name+$side) $tempString[0] 1 0 0 0;
		}

	if ($worldorient || $worldmatch)
		aimConstraint -offset 0 0 0 -weight 1
			-aimVector $aimV[0] $aimV[1] $aimV[2]
			-upVector $upV[0] $upV[1] $upV[2]
			-worldUpType "vector"
			-worldUpVector $wupV[0] $wupV[1] $wupV[2]
			tempAimAtTarget ("CustomOrient"+$type+$name+$side);
	else
		{
		createNode -n tempAimUpVec -p $deformJoint transform;
		parent -w tempAimUpVec;
		aimConstraint -offset 0 0 0 -weight 1
			-aimVector $aimV[0] $aimV[1] $aimV[2]
			-upVector $upV[0] $upV[1] $upV[2]
			-worldUpType "objectrotation"
			-worldUpVector $upV[0] $upV[1] $upV[2]
			-worldUpObject tempAimUpVec
			tempAimAtTarget ("CustomOrient"+$type+$name+$side);
		}
	delete ("CustomOrient"+$type+$name+$side+"_aimConstraint1");
	if ($isCustomCtrl)
		xform -ws -t $pos[0] $pos[1] $pos[2] ("CustomOrient"+$type+$name+$side);

	delete tempAimAtTarget;
	if (`objExists tempAimUpVec`)
		delete tempAimUpVec;

	if ($isClusterControl)
		{
		createNode -n tempMatrixXform transform;
		asAlign tempMatrixXform ($name+$side) 0 1 0 0;
		$m=`xform -q -os -m tempMatrixXform`;
		setAttr ("MMT"+$name+$side+".matrixIn[1]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		setAttr ("MMR"+$name+$side+".matrixIn[2]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		$m=`getAttr tempMatrixXform.inverseMatrix`;
		setAttr ("MMR"+$name+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		delete tempMatrixXform;
		}

	if ($customAxis && $batchMode)
		{//customAxis in BatchMode are first "Set", then aplly the custom orientation
		delete `parentConstraint ("prefix_CustomOrient"+$type+$name+$side) ("CustomOrient"+$type+$name+$side)`;
		}

	parent ("CustomOrientReverse"+$type+$name+$side) $sel[$i];

	if ($cmd!="")
		eval ($cmd);

	delete asSetControlOrientParentHolder;

	//update FKIK-AlignTo-targets
	$fkIkCtrl=`asFindFKIKCtrl $sel[$i]`;
	if ($type=="IK")
			{
			if (`attributeExists endJoint $fkIkCtrl`)
				$endJoint=`getAttr ($fkIkCtrl+".endJoint")`;
			$alignTo="AlignIKTo"+$endJoint+$side;//this assumes `standard` ctrl (e.g IKLeg_R)
			if (`objExists ("AlignIKTo"+$name+$side)`)//in cause of `non-standard` ctrl (e.g IKToes_R)
				$alignTo="AlignIKTo"+$name+$side;
			if (`objExists $alignTo`)
				{
				delete `orientConstraint $sel[$i] $alignTo`;
				if (!`attributeExists CustomOrient $alignTo`)
					addAttr -k 0 -ln CustomOrient -at bool -dv 1 $alignTo;
				}
			}
	if ($type=="FK")
		{//actually IKFKAligned not currently used, as it only has xform for `wrist`, not `shoulder/elbow`
/*
		$alignTo="IKFKAligned"+`substitute "FKIK" $fkIkCtrl ""`;
		$alignToOffset="IKFKAlignedOffset"+`substitute "FKIK" $fkIkCtrl ""`;
		if (`objExists $alignTo`)
			{
			if (!$opm) delete ("IKX"+$name+$side+"_orientConstraint1");
			delete `orientConstraint $sel[$i] $alignToOffset`;
			if (!$opm) orientConstraint -mo $alignTo ("IKX"+$name+$side);
			}
*/
		}

	if ($hadXparentConstraint)
		parentConstraint -mo ($type+$name+$side) ($type+$name+"X"+$side);

	$modifiedCtrlsString+=$type+$name+$side+" ";
	$numCtrls++;
	}

select $originalSel;
if ($numCtrls>1)
	$pluralSuffix="s";
if ($modifiedCtrlsString!="")
	$modifiedCtrlsString=" ( "+$modifiedCtrlsString+")";
if (!$batchMode)
	print ("// Set orientation for "+$numCtrls+" controller"+$pluralSuffix+$modifiedCtrlsString+".\n");
}

global proc asControlAxisChanged ()
{
int $primaryAxis=`optionMenu -q -sl asPrimaryAxisOptionMenu`-1;
int $secondaryAxis=`optionMenu -q -sl asSecondaryAxisOptionMenu`-1;

if ($secondaryAxis==$primaryAxis || $secondaryAxis==$primaryAxis+3 || $secondaryAxis==$primaryAxis-3)
	{
	print "// Primary and Secondary can not be the same, changing this now.\n";
	if ($secondaryAxis==5) $secondaryAxis=0;
	else $secondaryAxis++;
	optionMenu -e -sl ($secondaryAxis+1) asSecondaryAxisOptionMenu;
	}
}

global proc asControlOrientDetach ()
{
int $hasCustomOrient;
string $ctrl,$previousParent;
string $sel[]=`ls -sl`;
string $controlSetMembers[]=`sets -q ControlSet`;
string $children[],$tempString[];

asVersionRequirementCheck body 6.210;

if (`objExists asControlOrientDetachParentHolder`)
	error "Objct \"asControlOrientDetachParentHolder\" already exists.";

createNode -n asControlOrientDetachParentHolder transform;

for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`gmatch $controlSetMembers[$i] "*Extra*"`)
		continue;
	$ctrl=`substitute "Extra" $controlSetMembers[$i] ""`;
	$type=`asInfoFromCtrl $ctrl type`;
	$name=`asInfoFromCtrl $ctrl name`;
	$side=`asInfoFromCtrl $ctrl side`;
	$customOrient="CustomOrient"+$type+$name+$side;

	if (!`objExists $ctrl`)
		continue;

	//Already a CustomOrientCtrl
	$hasCustomOrient=0;
	if (`objExists $customOrient`)
		$hasCustomOrient=1;

	if ($hasCustomOrient)
		{
//		parent $controlSetMembers[$i] ("CustomOrientReverse"+$type+$name+$side) asControlOrientDetachParentHolder;
		//re-apply the CustomOrient to Ctrl
		parent $ctrl $customOrient;
		$tempString=`listRelatives -p $customOrient`;
		$previousParent=$tempString[0];
		parent -r $controlSetMembers[$i] $previousParent;
		parent $controlSetMembers[$i] ("CustomOrientReverse"+$type+$name+$side) asControlOrientDetachParentHolder;
		parent $ctrl $controlSetMembers[$i];
		delete $customOrient;
		}
	else
		{
		//store name of previous parent
		$tempString=`listRelatives -p $controlSetMembers[$i]`;
		$previousParent=$tempString[0];
		parent $controlSetMembers[$i] asControlOrientDetachParentHolder;
		$children=`listRelatives -c -type transform $ctrl`;
		if (size($children))
			{
			createNode -n ("CustomOrientReverse"+$type+$name+$side) -p $ctrl transform;
			parent ("CustomOrientReverse"+$type+$name+$side) asControlOrientDetachParentHolder;
			parent $children ("CustomOrientReverse"+$type+$name+$side);
			}
		}

	addAttr -ln ("previousParent"+$controlSetMembers[$i]) -dt "string" asControlOrientDetachParentHolder;
	setAttr -type "string" ("asControlOrientDetachParentHolder.previousParent"+$controlSetMembers[$i]) $previousParent;

	//special case "X" parentConstraint
	if (`objExists ($type+$name+"X"+$side+"_parentConstraint1")`)
			{
			addAttr -ln hadXparentConstraint -at bool -dv 1 ("CustomOrientReverse"+$type+$name+$side);
			delete ($type+$name+"X"+$side+"_parentConstraint1");
			}
	}

select $sel;
print ("// Controllers detached.\n");
}

global proc asControlOrientAttach ()
{
int $mirror=`checkBox -q -v asControlOrientAttachMirrorCheckBox`;
int $modifiedCtrl,$numModifiedControls;
float $value;
float $checkValues[]={0,0,0,0,0,0,1,1,1};
string $ctrl,$pluralSuffix,$previousParent,$reverseParent,$name,$side,$modifiedCtrlsString,$fkIkCtrl,$endJoint,$alignTo;
string $sel[]=`ls -sl`;
string $tempString[],$detachedXforms[],$modifiedCtrls[];
string $checkAttr[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};

if (!`objExists asControlOrientDetachParentHolder`)
	error "Object \"asControlOrientDetachParentHolder\" not found, Run \"Detach\" before \"Attach\".";

if ($mirror)
	{
	//use asMirror
	if (`window -q -ex tempWindow`)
		deleteUI tempWindow;
	window tempWindow;
	columnLayout;
	optionMenu tempWindowOptionMenu;
		menuItem -l ":";
	text -l "ControlSet " tempWindowControlSetsText;
	optionVar -sv asMOSide "asMOSideR2L";
	optionVar -sv asMOSpace "asMOSpaceMain";
	optionVar -sv asMOAxis "asMOAxisX";
	optionVar -sv asMOSelOnly "asMOSelOnlyAll";
	text -e -l "ControlSet " tempWindowControlSetsText;
	asMirror tempWindow;
	deleteUI tempWindow;
	}

$detachedXforms=`listRelatives -c -type transform asControlOrientDetachParentHolder`;
for ($i=0;$i<size($detachedXforms);$i++)
	{
	if (!`gmatch $detachedXforms[$i] "*Extra*"`)
		continue;
	$ctrl=`substitute "Extra" $detachedXforms[$i] ""`;
	$type=`asInfoFromCtrl $ctrl type`;
	$name=`asInfoFromCtrl $ctrl name`;
	$side=`asInfoFromCtrl $ctrl side`;
	$detachedXforms2=`listRelatives -c -type transform $detachedXforms[$i]`;
	$ctrl=$detachedXforms2[0];
	$previousParent=`getAttr ("asControlOrientDetachParentHolder.previousParent"+$detachedXforms[$i])`;

	$modifiedCtrl=0;
	for ($y=0;$y<size($checkAttr);$y++)
		{
		if (!`getAttr -settable ($ctrl+"."+$checkAttr[$y])`)
			continue;
		$value=`getAttr ($ctrl+"."+$checkAttr[$y])`;
		if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
			{
			$modifiedCtrl=1;
			$numModifiedControls++;
			break;
			}
		}

	if ($modifiedCtrl)
		{
		if (`objExists ("CustomOrient"+$type+$name+$side)`)
			delete ("CustomOrient"+$type+$name+$side);

		createNode -n ("CustomOrient"+$type+$name+$side) -p $ctrl transform;
		sets -add AllSet ("CustomOrient"+$type+$name+$side);//to prevent it attmpting to preserve this upon reBuild
		parent ("CustomOrient"+$type+$name+$side) $previousParent;
		parent $detachedXforms[$i] ("CustomOrient"+$type+$name+$side);
		if (!`attributeExists customAxis $ctrl`)
			addAttr -ln customAxis -at bool $ctrl;
		setAttr ($ctrl+".customAxis") 1;

		//update FKIK-AlignTo-targets
		$fkIkCtrl=`asFindFKIKCtrl $ctrl`;
		if ($type=="IK" && $fkIkCtrl!="")
				{
				if (`attributeExists endJoint $fkIkCtrl`)
					$endJoint=`getAttr ($fkIkCtrl+".endJoint")`;
				$alignTo="AlignIKTo"+$endJoint+$side;//this assumes `standard` ctrl (e.g IKLeg_R)
				if (`objExists ("AlignIKTo"+$name+$side)`)//in cause of `non-standard` ctrl (e.g IKToes_R)
					$alignTo="AlignIKTo"+$name+$side;
				if (`objExists $alignTo`)
					{
					delete `orientConstraint $ctrl $alignTo`;
					if (!`attributeExists CustomOrient $alignTo`)
						addAttr -k 0 -ln CustomOrient -at bool -dv 1 $alignTo;
					}
				}
		}
	else
		parent $detachedXforms[$i] $previousParent;
	}

asGoToBuildPose bodySetup;

$detachedXforms=`listRelatives -c -type transform asControlOrientDetachParentHolder`;
for ($i=0;$i<size($detachedXforms);$i++)
	{
	if (!`gmatch $detachedXforms[$i] "CustomOrientReverse*"`)
		continue;
	$tempString[0]=`substitute "CustomOrientReverse" $detachedXforms[$i] ""`;
	$type=`asInfoFromCtrl $tempString[0] type`;
	$name=`asInfoFromCtrl $tempString[0] name`;
	$side=`asInfoFromCtrl $tempString[0] side`;
	if (`objExists ("CustomOrient"+$type+$name+$side)`)//a modified ctrl
		{
		parent $detachedXforms[$i] ($type+$name+$side);
		$modifiedCtrls[size($modifiedCtrls)]=$type+$name+$side;
		}
	else
		{
		$reverseParent=`substitute "CustomOrientReverse" $detachedXforms[$i] ""`;
		parent `listRelatives -c $detachedXforms[$i]` $reverseParent;
		}
	//special case "X" parentConstraint
	if (`attributeExists hadXparentConstraint $detachedXforms[$i]`)
		parentConstraint -mo ($type+$name+$side) ($type+$name+"X"+$side);
	}

delete asControlOrientDetachParentHolder;
catchQuiet (`select $sel`);

if ($numModifiedControls>1)
	$pluralSuffix="s";
$modifiedCtrls=`sort $modifiedCtrls`;
for ($i=0;$i<size($modifiedCtrls);$i++)
	$modifiedCtrlsString+=$modifiedCtrls[$i]+" ";
if ($modifiedCtrlsString!="")
	$modifiedCtrlsString=" ( "+$modifiedCtrlsString+")";
print ("// Controllers attached, "+$numModifiedControls+" modified control"+$pluralSuffix+$modifiedCtrlsString+".\n");
}

global proc asFitModeManualUpdate ()
{
int $labelClash,$hadLockedCenterJoints;
string $label,$newLabel;
string $labelArray[];
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`)
	return;

asUniqueNameAll;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;

//Also ensure uniqueLabel
for ($i=0;$i<size($fitJoints);$i++)
	{
	$label=`asLabel $fitJoints[$i]`;
	if ($label=="")
		continue;
	$labelArray[size($labelArray)]=$label;
	}

for ($i=0;$i<size($fitJoints);$i++)
	{
	$label=`asLabel $fitJoints[$i]`;

	if (!`gmatch $label "*Shoulder*"` && !`gmatch $label "*Hip*"` && !`gmatch $label "*Root*"` && !`gmatch $label "0*"`)
		continue;
	$labelClash=0;

	if (`stringArrayCount $label $labelArray`>1)
		{
		$labelClash=1;
		for ($a=1;$a<99;$a++)
			{
			if (`gmatch $label "0*"`)
				$newLabel=$label+`asNrToLetter $a`;
			else
				$newLabel=$label+$a;
			if (!`stringArrayCount $newLabel $labelArray`)
				break;
			}
		}

	if ($labelClash)
		{
		setAttr ($fitJoints[$i]+".type") 18;
		setAttr -type "string" ($fitJoints[$i]+".otherType") $newLabel;
		$labelArray[size($labelArray)]=$newLabel;
		}
	}

if (`attributeExists lockCenterJoints FitSkeleton`)
	if (`getAttr FitSkeleton.lockCenterJoints`)
		{
		$hadLockedCenterJoints=1;
		asFitModeLockCenterJoints;
		}

asFitModeUpdateScale;
//if (`objExists Root`)
//	asFitModeUpdateJoints Root 1;
$tempString=`listRelatives -c -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	asFitModeUpdateJoints $tempString[$i] 1;
if ($hadLockedCenterJoints)
	asFitModeLockCenterJoints;
catchQuiet (`select $sel`);
//asByPassSDK 0;
print "// Updated Orientations\n";
}

global proc asFitModeSelectionChanged ()
{
global int $asFitModeScriptJobNr2[];
global string $asFitModeOffRLA[];
for ($i=0;$i<size($asFitModeOffRLA);$i++)
	if (`objExists $asFitModeOffRLA[$i]`)
		setAttr ($asFitModeOffRLA[$i]+".displayLocalAxis") 0;

clear $asFitModeOffRLA;
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
string $sel[]=`ls -sl -type joint`;
string $tempString[];
string $rlaParent,$rlaChild;
float $pos[];
string $aimParents;
for ($i=0;$i<size($sel);$i++)
	{
	//Parent
//	if (size(`ls -ap $sel[$i]`)>1)
//		continue;
	$rlaParent=`asRlaParent $sel[$i]`;
	if (!`objExists $rlaParent`)
		continue;
//	string $parentOtherChildren[]=`listRelatives -c -type joint $rlaParent`;
//	$parentOtherChildren=`stringArrayRemove {$sel[$i]} $parentOtherChildren`;
//	if (size($parentOtherChildren) && $sel[$i]!="BackA")
//		continue;

	if (!`getAttr ($rlaParent+".displayLocalAxis")`)
		$asFitModeOffRLA[$i]=$rlaParent;
	setAttr ($rlaParent+".displayLocalAxis") 1;
	if ($aimParents!="")
		$aimParents+="@";
	$aimParents+=$sel[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	//Child
	$rlaChild=`asRlaChild $sel[$i]`;
//	if (size(`ls -ap $rlaChild`)!=1)
//		continue;
	$aimParents+="@"+$rlaChild;

	if (`attributeExists twistJoints $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".twistJoints") ("asFitModeUpdateAllGeometry")`;

	}
if ($aimParents!="")
	{
	$asFitModeScriptJobNr2[0]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".translate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	$asFitModeScriptJobNr2[1]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".rotate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	}
}

global proc asFitModeLockCenterJoints ()
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`)
	return;
int $oldLockValue=`getAttr FitSkeleton.lockCenterJoints`;
int $lock=!$oldLockValue;
//int $primaryAxis=`optionMenu -q -sl asPrimaryAxisOptionMenu`;
//int $secondaryAxis=`optionMenu -q -sl asSecondaryAxisOptionMenu`;
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
float $pos[],$pos2[];
string $priAxis="X";
string $secAxis="Y";
string $fitSkeletonJoints[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $lockAttrs[]={"tx","ty"};

if (`attributeExists primaryAxis FitSkeleton`)
	$priAxis=`getAttr -asString FitSkeleton.primaryAxis`;
if (`attributeExists secondaryAxis FitSkeleton`)
	$secAxis=`getAttr -asString FitSkeleton.secondaryAxis`;

setAttr FitSkeleton.lockCenterJoints $lock;

$fitSkeletonJoints=`listRelatives -f -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitSkeletonJoints);$i++)
	{
	//first unlock all
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			setAttr -l 0 ($fitSkeletonJoints[$i]+"."+$trs[$y]+$xyz[$z]);
	if (!$lock)
		continue;

	$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
	if ($pos[0]<-$centerTolerance || $pos[0]>$centerTolerance)
		continue;

	$tempString=`listRelatives -p -f $fitSkeletonJoints[$i]`;
	$parent=$tempString[0];
	createNode -n transformSampler -p $parent transform;

	setAttr -type float3 transformSampler.t 1 0 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l 1 ($fitSkeletonJoints[$i]+".tx");

	setAttr -type float3 transformSampler.t 0 1 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l 1 ($fitSkeletonJoints[$i]+".ty");

	setAttr -type float3 transformSampler.t 0 0 1;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l 1 ($fitSkeletonJoints[$i]+".tz");

	delete transformSampler;
	if ((`gmatch $priAxis "*X"` && `gmatch $secAxis "*Y"`) || (`gmatch $priAxis "*Y"` && `gmatch $secAxis "*X"`))
		{
		setAttr -l 1 ($fitSkeletonJoints[$i]+".rx");
		setAttr -l 1 ($fitSkeletonJoints[$i]+".ry");
		}
	if ((`gmatch $priAxis "*X"` && `gmatch $secAxis "*Z"`) || (`gmatch $priAxis "*Z"` && `gmatch $secAxis "*X"`))
		{
		setAttr -l 1 ($fitSkeletonJoints[$i]+".rx");
		setAttr -l 1 ($fitSkeletonJoints[$i]+".rz");
		}
	if ((`gmatch $priAxis "*Y"` && `gmatch $secAxis "*Z"`) || (`gmatch $priAxis "*Z"` && `gmatch $secAxis "*Y"`))
		{
		setAttr -l 1 ($fitSkeletonJoints[$i]+".ry");
		setAttr -l 1 ($fitSkeletonJoints[$i]+".rz");
		}

	}
select -ne $sel;
}

global proc asPlacementSnap ()
{
global string $gMove;
setToolTo $gMove;
float $pos[];
string $joint;
string $sel[]=`ls -sl`;

$joint=$sel[size($sel)-1];

select -d $joint;
$pos=`manipMoveContext -q -position "Move"`;
xform -ws -t $pos[0] $pos[1] $pos[2] $joint;
print "// Joint snapped to center of components.\n";
}

global proc asPlacementCopy ()
{
global string $gMove;
setToolTo $gMove;
float $pos[]=`manipMoveContext -q -position "Move"`;
button -e -en 1 -ann ($pos[0]+" "+$pos[1]+" "+$pos[2]) asPlacementPasteButton;
}

global proc asPlacementPaste ()
{
int $editPivotMode=`manipMoveContext -q -editPivotMode Move`;
string $sel[]=`ls -sl`;
string $ann=`button -q -ann asPlacementPasteButton`;
string $buffer[];
tokenize $ann $buffer;

for ($i=0;$i<size($sel);$i++)
	if ($editPivotMode)
		move -a $buffer[0] $buffer[1] $buffer[2] ($sel[$i]+".scalePivot") ($sel[$i]+".rotatePivot");
	else
		move -a $buffer[0] $buffer[1] $buffer[2] $sel[$i];
}

global proc asFitModeUpdateAllGeometry ()
{
checkBox -e -v 0 asVisGeo;
asFitGeometry;
checkBox -e -v 1 asVisGeo;
asFitGeometry;
}

global proc asFitModeUpdateScale ()
{
int $asFitModeManualUpdateFromBuild;
if (`objExists asFitModeManualUpdateFromBuild`)
	{
	$asFitModeManualUpdateFromBuild=1;
	delete asFitModeManualUpdateFromBuild;
	}
if (!`objExists FitSkeleton`)
	return;
int $foundGeneratedTransforms;
//int $displayPoleVector=`checkBox -q -v asVisPoleVector`;
int $lockTxs[],$lockTys[],$lockTzs[];
float $fitSkeletonScale[3]=`getAttr FitSkeleton.s`;
float $pos[];
string $sel[]=`ls -sl`;
string $fitJointsParent[],$tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
string $fitSkeletonChildren[]=`listRelatives -ad -type transform FitSkeleton`;
string $generatedTransform;

for ($i=0;$i<size($fitSkeletonChildren);$i++)
	if (`objectType $fitSkeletonChildren[$i]`=="transform" && `gmatch $fitSkeletonChildren[$i] "transform*"`)
		{
		$foundGeneratedTransforms=1;
		break;
		}


if (($fitSkeletonScale[0]==1 && $fitSkeletonScale[1]==1 && $fitSkeletonScale[2]==1) && !$foundGeneratedTransforms && !$asFitModeManualUpdateFromBuild)
	return;
//removed, as we also want to find any non-1 scaled joints
//restored, as the remove cause self-call loop


setAttr -type float3 FitSkeleton.s 1 1 1;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$lockTxs[$i]=`getAttr -l ($fitJoints[$i]+".tx")`;$lockTys[$i]=`getAttr -l ($fitJoints[$i]+".ty")`;$lockTzs[$i]=`getAttr -l ($fitJoints[$i]+".tz")`;
	setAttr -l 0 ($fitJoints[$i]+".tx");setAttr -l 0 ($fitJoints[$i]+".ty");setAttr -l 0 ($fitJoints[$i]+".tz");
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$generatedTransform="";
	if ($tempString[0]!="" && `objectType $tempString[0]`=="transform" && $tempString[0]!="FitSkeleton")
		{
		$generatedTransform=$tempString[0];
		$tempString=`listRelatives -p $generatedTransform`;
		}
	$fitJointsParent[$i]=$tempString[0];
	parent -w $fitJoints[$i];
	if ($generatedTransform!="")
		delete $generatedTransform;
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$generatedTransform=$tempString[0];
	if ($generatedTransform!="")//generated Xform
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		setAttr -type float3 ($generatedTransform+".s") 1 1 1;
		parent -w $fitJoints[$i];
		xform -ws -t $pos[0] $pos[1] $pos[2] $fitJoints[$i];
		delete $generatedTransform;
		}
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	xform -ws -t ($pos[0]*$fitSkeletonScale[0]) ($pos[1]*$fitSkeletonScale[1]) ($pos[2]*$fitSkeletonScale[2]) $fitJoints[$i];
	setAttr ($fitJoints[$i]+".s") -type float3 1 1 1;
	setAttr ($fitJoints[$i]+".inverseScale") -type float3 1 1 1;
	if (`attributeExists fat $fitJoints[$i]`) setAttr ($fitJoints[$i]+".fat") (`getAttr ($fitJoints[$i]+".fat")`*$fitSkeletonScale[1]);
//	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv1")`)
//		setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y") (`getAttr ($fitJoints[$i]+"ScaleYMultiDiv1.dummyInput1Y")`);
	}
for ($i=0;$i<size($fitJoints);$i++)
	if (`objExists $fitJointsParent[$i]`)
		parent $fitJoints[$i] $fitJointsParent[$i];
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -l $lockTxs[$i] ($fitJoints[$i]+".tx");setAttr -l $lockTys[$i] ($fitJoints[$i]+".ty");setAttr -l $lockTzs[$i] ($fitJoints[$i]+".tz");
	}

if ($fitSkeletonScale[0]==1 && $fitSkeletonScale[1]==1 && $fitSkeletonScale[2]==1)
	{
	select $sel;
	return;
	}

scale -r -p 0 0 0 $fitSkeletonScale[1] $fitSkeletonScale[1] $fitSkeletonScale[1] FitSkeletonShape.cv[0:7] ;

select $sel;
}

global proc asFitModeUpdateJoints (string $jointsString, int $recursive)
{
int $childNr,$newChildNr,$reachedKneeJoint,$flipOrient,$aimAxis,$aimUpAxis,$x,$y,$z,$xUp,$yUp,$zUp,$ikPlaneVectored;
int $useWorldOrient,$freeOrient,$worldOrientUp,$worldOrientForward,$center,$iKStartJointCenter,$worldmatch,$hipFlip,$symmetryJoint,$noFlip;
int $selfUpMult=1;
int $terAxisNr=2;
int $editPivotMode=`manipMoveContext -q -editPivotMode Move`;
float $scale=1;
float $maxT;
float $aimV[3],$upV[3],$upV2[3];
float $pos[],$pos2[],$rot[],$aimVector[];
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[],$joints[],$jointAllDescendents[],$jointChildren[];
string $connectCmds[],$rlaParentChildren[],$rlaParentParentChildren[],$newRlaParentChildren[],$iKInfo[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $generatedTransform1,$generatedTransform2,$IKParentJoint,$IKChildJoint,$upVecObj,$worldOrientUpAttrName;
string $rlaParent,$rlaParentLabel,$rlaChild,$rlaParentRlaChild,$label,$tempLabel,$joint,$aimAt,$worldUpType;
string $iK,$iKStartJoint,$iKMiddleJoint,$iKEndJoint,$iKSolver,$iKNumCtrls,$roo,$selfUpAxis;
string $priAxis="X";
string $secAxis="Y";
string $terAxis="Z";

if (`attributeExists primaryAxis FitSkeleton`)
	$priAxis=`getAttr -asString FitSkeleton.primaryAxis`;
if (`attributeExists secondaryAxis FitSkeleton`)
	$secAxis=`getAttr -asString FitSkeleton.secondaryAxis`;
if (`attributeExists worldmatch FitSkeleton`)
	$worldmatch=`getAttr FitSkeleton.worldmatch`;

if ($worldmatch && !$recursive)
	{//arrived here by FitMode, but apply recursive, since any children can get new orientation
	tokenize $jointsString "@" $joints;
	asFitModeUpdateJoints $joints[0] 1;
	return;
	}

if ($recursive)
	{
	$tempString=`listRelatives -ad -type joint $jointsString`;
	for ($i=size($tempString)-1;$i>-1;$i--)
		$jointsString+="@"+$tempString[$i];
	}
tokenize $jointsString "@" $joints;
for ($joint in $joints)
	{
	if (size(`ls -ap $joint`)!=1)
		continue;
	$symmetryJoint=0;
	if (`gmatch $joint "*_NonSymmetry"`)
		$symmetryJoint=1;
	$label=`asLabel $joint`;
	$rlaParent=`asRlaParent $joint`;
	$rlaParent=`asUniqueName $rlaParent`;
	$rlaParentLabel=`asLabel $rlaParent`;
	string $rlaChild=`asRlaChild $joint`;
	$rlaChild=`asUniqueName $rlaChild`;
	$jointChildren=`listRelatives -c -type joint $joint`;

	int $childNr=0;
	clear $rlaParentChildren;
	if ($rlaParent!="")
		{
		$rlaParentRlaChild=`asRlaChild $rlaParent`;
		$rlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		if (size($rlaParentChildren)>1)
			for ($i=0;$i<size($rlaParentChildren);$i++)
				{
				if ($joint==$rlaParentChildren[$i])
					$childNr=$i;
				}
		}
	if (!`objExists $rlaParent`)
		continue;
	$freeOrient=0;
	if (`attributeExists freeOrient $rlaParent`)
		$freeOrient=`getAttr ($rlaParent+".freeOrient")`;
	if (`asRlaChild $rlaParent`!=$joint)//removed: && $rlaParent!="Cup" seems obsolete
		continue;
	if (`gmatch $rlaParent "Cup[0-9]*"` || $rlaParent=="Cup_NonSymmetry")//`other` cups (hand has been duplicated)
		continue;

	$worldOrientUp=$worldOrientForward=-1;
	$worldOrientUpAttrName="worldOrientUp";
	if (`attributeExists worldOrientForward $rlaParent`)
		$worldOrientForward=`getAttr ($rlaParent+".worldOrientForward")`;
	//the old worldOrient-way < 5.792
	if (`attributeExists worldOrient $rlaParent`)
		{
		$worldOrientUp=`getAttr ($rlaParent+".worldOrient")`;
		$worldOrientUpAttrName="worldOrient";
		}
	//the new worldOrient-way > 5.792
	if (`attributeExists worldOrientUp $rlaParent`)
		$worldOrientUp=`getAttr ($rlaParent+".worldOrientUp")`;
	$useWorldOrient=0;
	if ($worldOrientUp!=-1)
		$useWorldOrient=1;

	//update worldOrients if World-match
	if ($worldmatch && $useWorldOrient)
		$worldOrientUp=1;

	//update worldOrients if SwappingAxis, guestimate what will match with the new axis options
	if (`objExists SwappingAxisInfo` && $useWorldOrient)
		{
		if (($worldOrientUp==`getAttr SwappingAxisInfo.previousPrimaryAxis`) || (($worldOrientUp-3)==`getAttr SwappingAxisInfo.previousPrimaryAxis`))
			{
			$worldOrientUp=`getAttr SwappingAxisInfo.primaryAxis`;
			if ($worldOrientUp<3)
				setAttr ($rlaParent+"."+$worldOrientUpAttrName) ($worldOrientUp+3);//always setting to `down`
			else
				setAttr ($rlaParent+"."+$worldOrientUpAttrName) $worldOrientUp;
			}
		//and guestimate `free-forward`
		$tempString=`listRelatives -c -type joint $rlaParent`;
		if (($worldOrientForward==-1 || $worldOrientForward==6) && size($tempString))
			{//assuming correct `forward` of Parent, so aligning with that
			parent -w $tempString;
			setAttr ($rlaParent+".r") -type float3 0 0 0;
			setAttr ($rlaParent+".jointOrient") -type float3 0 0 0;
			parent $tempString $rlaParent;
			}
		}

	if (`attributeExists worldOrientForward $rlaParent` && $worldOrientForward!=6)
		if ($worldOrientForward==$worldOrientUp || $worldOrientForward==($worldOrientUp+3) || $worldOrientForward==($worldOrientUp-3))
			{
			print ("// detected invalid WorldOrient options on object:\""+$rlaParent+"\", same axis defined as \"Forward\" and \"Up\", changing the value now.\n");
			if ($worldOrientUp==5)
				setAttr ($rlaParent+".worldOrientForward") 0;
			else
				setAttr ($rlaParent+".worldOrientForward") ($worldOrientUp+1);
			}

	$flipOrient=0;
	$tempString=`ls -l $rlaParent`;
	tokenize $tempString[0] "|" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (`attributeExists flipOrient $tempString[$i]`)
			if (`getAttr ($tempString[$i]+".flipOrient")`)
				$flipOrient=!$flipOrient;

	if (`attributeExists noFlip $rlaParent`)
		$noFlip=`getAttr ($rlaParent+".noFlip")`;

	string $rlaParentParent=`asRlaParent $rlaParent`;
//	clear $otherJointsInIK;
	$jointAllDescendents=`listRelatives -allDescendents -type joint $joint`;
	$jointAllDescendents[size($jointAllDescendents)]=$joint;
	string $parentOtherChildren[]=`listRelatives -c $rlaParent`;
	$parentOtherChildren=`stringArrayRemove {$joint} $parentOtherChildren`;

	$iKInfo=`asFitJointIKInfo $rlaParent`;
	$iK=$iKInfo[0];
	$iKStartJoint=$iKInfo[1];
	$iKMiddleJoint=$iKInfo[2];
	$iKEndJoint=$iKInfo[3];
	$iKSolver=$iKInfo[4];
	$iKNumCtrls=$iKInfo[5];

	// $iKEndJoint should be first joint found in a IK, so Orient $iKStartJoint first, as it sets the upVector
	if ($iKStartJoint!="" && $iKEndJoint!="" && $joint==$iKEndJoint && !$recursive)
		{
		$tempString[0]=`asRlaChild $iKStartJoint`;
		if ($tempString[0]!="" && $tempString[0]!=$joint)//avoids stuck loop if SplineIk is only 1 bone
			asFitModeUpdateJoints $tempString[0] 0;
		}

	int $lockTX=`getAttr -l ($joint+".tx")`;int $lockTY=`getAttr -l ($joint+".ty")`;int $lockTZ=`getAttr -l ($joint+".tz")`;
	int $lockRX=`getAttr -l ($joint+".rx")`;int $lockRY=`getAttr -l ($joint+".ry")`;int $lockRZ=`getAttr -l ($joint+".rz")`;
	int $lockPTX=`getAttr -l ($rlaParent+".tx")`;int $lockPTY=`getAttr -l ($rlaParent+".ty")`;int $lockPTZ=`getAttr -l ($rlaParent+".tz")`;
	int $lockPRX=`getAttr -l ($rlaParent+".rx")`;int $lockPRY=`getAttr -l ($rlaParent+".ry")`;int $lockPRZ=`getAttr -l ($rlaParent+".rz")`;
	setAttr -l 0 ($joint+".tx");setAttr -l 0 ($joint+".ty");setAttr -l 0 ($joint+".tz");
	setAttr -l 0 ($joint+".rx");setAttr -l 0 ($joint+".ry");setAttr -l 0 ($joint+".rz");
	setAttr -l 0 ($rlaParent+".tx");setAttr -l 0 ($rlaParent+".ty");setAttr -l 0 ($rlaParent+".tz");
	setAttr -l 0 ($rlaParent+".rx");setAttr -l 0 ($rlaParent+".ry");setAttr -l 0 ($rlaParent+".rz");

	if (size($parentOtherChildren))
		{
		createNode -n otherChildrenPlaceHolder -p $rlaParent transform;
		parent -w otherChildrenPlaceHolder;
		}
	for ($i=0;$i<size($parentOtherChildren);$i++)
		{
		$tempString=`parent $parentOtherChildren[$i] otherChildrenPlaceHolder`;
		$parentOtherChildren[$i]=$tempString[0];
		}
		
	$tempString=`parent -w $joint`;
	$joint=$tempString[0];
	$tempString=`listRelatives -p $joint`;
	if (size($tempString))
		$generatedTransform1=$tempString[0];

	//remove any `rotateAxis`
	setAttr ($rlaParent+".rotateAxis") -type float3 0 0 0;

	//disconnect connections
	clear $connectCmds;
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 ($rlaParent+"."+$trs[$y]+$xyz[$z])`;
			if ($tempString[0]!="")
				{
				$connectCmds[size($connectCmds)]="connectAttr -f "+$tempString[0]+" "+$rlaParent+"."+$trs[$y]+$xyz[$z]+";";
				disconnectAttr $tempString[0] ($rlaParent+"."+$trs[$y]+$xyz[$z]);
				}
			}

	$center=0;
	$pos=`xform -q -ws -t $rlaParent`;
	if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;

	//Snap Center-joints to scene-center
	$iKStartJointCenter=0;
	if (`objExists $iKStartJoint`)
		{
		$pos2=`xform -q -ws -t $iKStartJoint`;
		if ($pos2[0]>-$centerTolerance && $pos2[0]<$centerTolerance) $iKStartJointCenter=1;
		if ($iKStartJointCenter && !$center)
			{
			$pos[0]=0;
			xform -ws -t $pos[0] $pos[1] $pos[2] $rlaParent;
			$center=1;
			}
		}

	if ($worldmatch)
		{
		createNode -n tempTransform1 -p $rlaParent transform;
		parent -w tempTransform1;
		setAttr tempTransform1.r -type float3 0 0 0;
		createNode -n tempTransform2 -p $joint transform;
		parent tempTransform2 tempTransform1;
		$pos2=`getAttr tempTransform2.t`;
		$maxT=0;
		if (abs($pos2[0])>$maxT) {$priAxis="X";$maxT=abs($pos2[0]);}
		if (abs($pos2[1])>$maxT) {$priAxis="Y";$maxT=abs($pos2[1]);}
		if (abs($pos2[2])>$maxT) {$priAxis="Z";$maxT=abs($pos2[2]);}
		if (`getAttr ("tempTransform2.translate"+$priAxis)`<0)
			$priAxis="-"+$priAxis;
		if ($useWorldOrient)//worldOrient with worldmatch, override, (assuming Ankle situation)
			$priAxis="-Y";
		delete tempTransform1;
		$secAxis="Z";
		if ($priAxis=="Z") $secAxis="-Y";
		if ($priAxis=="-Z") $secAxis="Y";
		if (!`attributeExists primaryAxis $rlaParent`)   addAttr -ln primaryAxis -at "enum" -en "X:Y:Z:-X:-Y:-Z:" $rlaParent;
		if (!`attributeExists secondaryAxis $rlaParent`) addAttr -ln secondaryAxis -at "enum" -en "X:Y:Z:-X:-Y:-Z:" $rlaParent;
		setAttr ($rlaParent+".primaryAxis") `asAxisToAxisEnumValue $priAxis`;
		setAttr ($rlaParent+".secondaryAxis") `asAxisToAxisEnumValue $secAxis`;
		if (!size($jointChildren))
			{
			if (!`attributeExists primaryAxis $joint`)   addAttr -ln primaryAxis   -at "enum" -en "X:Y:Z:-X:-Y:-Z:" $joint;
			if (!`attributeExists secondaryAxis $joint`) addAttr -ln secondaryAxis -at "enum" -en "X:Y:Z:-X:-Y:-Z:" $joint;
			setAttr ($joint+".primaryAxis") `asAxisToAxisEnumValue $priAxis`;
			setAttr ($joint+".secondaryAxis") `asAxisToAxisEnumValue $secAxis`;
			}
		}

	$terAxis=`asGetTerAxis $priAxis $secAxis`;
	$selfUpAxis=$secAxis;
	$selfUpMult=1;
	if (`objExists SwappingAxisInfo`)
		$selfUpAxis=`getAttr -asString SwappingAxisInfo.previousSecondaryAxis`;
	if (`gmatch $terAxis "*X"`) $terAxisNr=0;
	if (`gmatch $terAxis "*Y"`) $terAxisNr=1;
	if (`gmatch $terAxis "*Z"`) $terAxisNr=2;
	if (`gmatch $selfUpAxis "-*"`) {$selfUpAxis=`asAbsAxis $selfUpAxis`;$selfUpMult=-1;}

	$aimV=`asAxisToVector $priAxis`;
	$upV=`asAxisToVector $secAxis`;
	$upV2=`asAxisToVector $terAxis`;

	if ($flipOrient)
		{
		$upV[0]=$upV[0]*-1;$upV[1]=$upV[1]*-1;$upV[2]=$upV[2]*-1;
		$upV2[0]=$upV2[0]*-1;$upV2[1]=$upV2[1]*-1;$upV2[2]=$upV2[2]*-1;
		}

	if ($symmetryJoint && !$noFlip)
		{
		$aimV[0]=$aimV[0]*-1;$aimV[1]=$aimV[1]*-1;$aimV[2]=$aimV[2]*-1;
		}

	$ikPlaneVectored=0;
	$hipFlip=1;
	if (!$useWorldOrient && !$freeOrient)
		{
		if ($iKStartJoint!="" && $iKEndJoint!="" && $iKSolver=="ikRPsolver" && $rlaParent!=$iKEndJoint && !`gmatch $label "*Toes*"`) // IK
			{//`Ik-plane-vectored`
			$ikPlaneVectored=1;
			//in some cases aimConstraint computes flipped (if parent-joint.jo==90,0,90), so unparent before aim
			$tempString=`listRelatives -p $rlaParent`;
			$rlaParentParent=$tempString[0];
			$rlaParentParentChildren=`listRelatives -c -type transform $rlaParentParent`;
			parent -w $rlaParent;
			if ($rlaParent==$iKStartJoint)
				{
				$upVecObj=$iKEndJoint;//IKStartJoint upVectors to IK-plane
				$tempLabel=`asLabel $iKStartJoint`;
				if (`gmatch $tempLabel "*Hip*"`) {$upV[0]=$upV[0]*-1;$upV[1]=$upV[1]*-1;$upV[2]=$upV[2]*-1;$hipFlip=-1;}

	//			$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
				//Arms/Legs with excatly 0 rotation, will get PreferredAngles set to rotZ
				if (`objExists tempTransform`) delete tempTransform;
				createNode -n tempTransform -p $joint transform;
				parent tempTransform $rlaParent;
				$rot=`getAttr tempTransform.r`;
				delete tempTransform;
				
				if ($rot[$terAxisNr]<0.001 && $rot[$terAxisNr]>-0.001 && `objExists $iKMiddleJoint` && !`objExists SwappingAxisInfo`)
					{
					print ("// Detected zero rotation of :"+$joint+".rotation"+$terAxis+", moving middle-ik-joint slightly, to to have default rotation in \""+$terAxis+"\" axis\n");
					move -ws -r 0 0 ($pos[1]/-100.0) ($iKMiddleJoint+".rotatePivot");
					}
				}
			else
				{
				$upVecObj=$iKStartJoint;
	//			$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "objectrotation" -worldUpObject $upVecObj -worldUpVector $upV[0] $upV[1] $upV[2] $joint $rlaParent`;
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV2[0] $upV2[1] $upV2[2] -worldUpType "objectrotation" -worldUpObject $upVecObj -worldUpVector $upV2[0] $upV2[1] $upV2[2] $joint $rlaParent`;
				}

			delete $tempString[0];
			parent $rlaParent $rlaParentParent;
			//and preserve childOrder
			if (size($rlaParentParentChildren)>1)
				{
				if ($rlaParent==$rlaParentParentChildren[0]) reorder -front $rlaParent;
				else reorder -back $rlaParent;
				}
			if (`objExists tempTransform`) delete tempTransform;
			}
		else
			{//`Self-up-vectored`
			//setting to just local forward is not reliable if switching axis, changing away from `Self-up-vectored`
			//actually maybe changing back is possible...
			if ($center)
				{
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV2[0] $upV2[1] $upV2[2] -worldUpType "vector" -worldUpVector 1 0 0 $joint $rlaParent`;
				delete $tempString[0];
				}
			else
				{

	//print ("Orienting:"+$rlaParent+"\n"); 
				$upVecObj=`createNode -p $rlaParent transform`;
				if ($flipOrient) setAttr ($upVecObj+".translate"+$selfUpAxis) (-3*$selfUpMult);
				else setAttr ($upVecObj+".translate"+$selfUpAxis) (3*$selfUpMult);
				parent -w $upVecObj;
				$tempString=`listRelatives -p $upVecObj`;
				if (size($tempString)) $generatedTransform2=$tempString[0];
//				if ($worldmatch)
//					$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector 0 1 0 -worldUpType "scene" -worldUpVector 0 1 0 $joint $rlaParent`;
//				else
					$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
				delete $upVecObj $tempString[0];
				}
			}

		//Special case, LegAim
		if (`gmatch $rlaParentLabel "LegAim*"`)
			{
			$upVecObj=$joint;
			$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV2[0] $upV2[1] $upV2[2]
				-worldUpType "objectrotation" -worldUpVector $upV2[0] $upV2[1] $upV2[2] -worldUpObject $upVecObj $joint $rlaParent`;
			delete $tempString[0];
			}
		//Special case, Cup
		if ($rlaParent=="Cup" && `objExists RingFinger1` && `objExists MiddleFinger1`)
			{
			$upVecObj=`asRlaParent $rlaParent`;
			$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj RingFinger1 MiddleFinger1 $rlaParent`;
			delete $tempString[0];
			}
		//Special case, Eyes
		if (`gmatch $rlaParent "Eye*"`)
			{
				$tempString=`aimConstraint -aimVector $aimV[0] $aimV[1] $aimV[2] -upVector ($upV[0]*-1) ($upV[1]*-1) ($upV[2]*-1) -worldUpVector 0 1 0 $joint $rlaParent`;
			delete $tempString[0];
			}
		//Special case, Root with no centered child
		if ($rlaParent=="Root" && !$center)
			{
			setAttr -type float3 ($rlaParent+".rotate") 0 0 0;
			setAttr -type float3 ($rlaParent+".jointOrient") 90 0 90;
			}
		//Special case, AimAt
		if (`attributeExists aimAt $rlaParent`)
			{
			$aimAt=`getAttr -asString($rlaParent+".aimAt")`;
			$aimAxis=`getAttr ($rlaParent+".aimAxis")`;
			$aimUpAxis=`getAttr ($rlaParent+".aimUpAxis")`;

			if ($aimAxis==0) {$x=1;$y=0;$z=0;}
			if ($aimAxis==1) {$x=0;$y=1;$z=0;}
			if ($aimAxis==2) {$x=0;$y=0;$z=1;}
			if ($aimUpAxis==0) {$xUp=1;$yUp=0;$zUp=0;}
			if ($aimUpAxis==1) {$xUp=0;$yUp=1;$zUp=0;}
			if ($aimUpAxis==2) {$xUp=0;$yUp=0;$zUp=1;}
			if (`gmatch $priAxis "-*"`) {$x*=-1;$y*=-1;$z*=-1;}

			$tempString=`listRelatives -c $joint`;
			if (!size($tempString))
				parent $joint $rlaParent;
			if (`objExists $aimAt`)
				delete `aimConstraint -offset 0 0 0 -aimVector $x $y $z -upVector $xUp $yUp $zUp -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $aimAt $aimAt $rlaParent`;
			if (!size($tempString))
				parent -w $joint;
			}
		}

	if ($useWorldOrient)
		{
		$upVecObj=`createNode -n tempUpVector -p $joint transform`;
		parent -w $upVecObj;
		move -r -ws 0 1 0 $upVecObj;

		if ($worldOrientUp==0) $aimVector={-1,0,0};
		if ($worldOrientUp==1) $aimVector={0,-1,0};
		if ($worldOrientUp==2) $aimVector={0,0,-1};
		if ($worldOrientUp==3) $aimVector={1,0,0};
		if ($worldOrientUp==4) $aimVector={0,1,0};
		if ($worldOrientUp==5) $aimVector={0,0,1};

		if ($worldOrientForward==0) $aimUpV={1,0,0};
		if ($worldOrientForward==1) $aimUpV={0,1,0};
		if ($worldOrientForward==2) $aimUpV={0,0,1};
		if ($worldOrientForward==3) $aimUpV={-1,0,0};
		if ($worldOrientForward==4) $aimUpV={0,-1,0};
		if ($worldOrientForward==4) $aimUpV={0,0,-1};

		createNode -n tempAimAt -p $rlaParent transform;
		parent -w tempAimAt;
		move -r -ws 0 -1 0 tempAimAt;

		if ($worldOrientForward==-1 || $worldOrientForward==6)//forward==free
			$tempString=`aimConstraint -aimVector $aimVector[0] $aimVector[1] $aimVector[2] -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		else //new way > v5.792
			$tempString=`aimConstraint -aimVector $aimVector[0] $aimVector[1] $aimVector[2] -upVector $aimUpV[0] $aimUpV[1] $aimUpV[2] -worldUpType "vector" -worldUpVector 0 0 1 tempAimAt $rlaParent`;
		delete $tempString[0] $upVecObj tempAimAt;
		}

	//FitGeometry aim
	$upVecObj=$rlaParent;
	if (`objExists ($rlaParent+"Aim_aimConstraint1")`)
		delete ($rlaParent+"Aim_aimConstraint1");
	if (`objExists ($rlaParent+"Aim")`)
		{
		if ($ikPlaneVectored)
			{
			if ($rlaParent==$iKStartJoint)
				aimConstraint -aimVector 1 0 0 -upVector 0 (1*$hipFlip) 0 -worldUpType "object" -worldUpObject $iKEndJoint $joint ($rlaParent+"Aim");
			else
				aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($iKStartJoint+"Aim")
				-worldUpVector 0 1 0 $joint ($rlaParent+"Aim");
			}
		else
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $upVecObj
				-worldUpVector $upV[0] $upV[1] $upV[2] $joint ($rlaParent+"Aim");
		}

	makeIdentity -a 1 -t 0 -r 1 -s 0 $rlaParent;

	if (size($parentOtherChildren))
		{
		parent $parentOtherChildren $rlaParent;
		delete otherChildrenPlaceHolder;
		}

	parent $joint $rlaParent;
	//restore sibiling order
	if (size($rlaParentChildren)>1)
		{
		$newRlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		for ($i=0;$i<size($newRlaParentChildren);$i++)
			{
			if ($joint==$newRlaParentChildren[$i])
				$newChildNr=$i;
			}
		if ($newChildNr!=$childNr)
			reorder -relative ($childNr-$newChildNr) $joint;
		}
	if (`objExists $generatedTransform1`) delete $generatedTransform1;
	if (`objExists $generatedTransform2`) delete $generatedTransform2;

	//restore connections
	for ($i=0;$i<size($connectCmds);$i++)
		if (catchQuiet (`eval ($connectCmds[$i])`)) 
			warning ("Failed: "+$connectCmds[$i]+"\n");

	//zero out endJoints
	if (!size($jointChildren) && !`attributeExists control $joint`)
		{
		setAttr ($joint+".jo") -type float3 0 0 0;
		setAttr ($joint+".r") -type float3 0 0 0;
		}

	//update skeleton scale
	if (`objExists ($rlaParent+"Bone")` && `objExists ($rlaParent+"Distance")`)
		{
		float $lenght=`getAttr ($rlaParent+"Distance.distance")`*(1.0/$scale);
		setAttr ($rlaParent+"Bone.sx") $lenght;
		}

	setAttr -l $lockTX ($joint+".tx");setAttr -l $lockTY ($joint+".ty");setAttr -l $lockTZ ($joint+".tz");
	setAttr -l $lockRX ($joint+".rx");setAttr -l $lockRY ($joint+".ry");setAttr -l $lockRZ ($joint+".rz");
	setAttr -l $lockPTX ($rlaParent+".tx");setAttr -l $lockPTY ($rlaParent+".ty");setAttr -l $lockPTZ ($rlaParent+".tz");
	setAttr -l $lockPRX ($rlaParent+".rx");setAttr -l $lockPRY ($rlaParent+".ry");setAttr -l $lockPRZ ($rlaParent+".rz");
	}

if (`objExists SwappingAxisInfo`)
	delete SwappingAxisInfo;

catchQuiet (`select $sel`);
//Restore `insert-mode`, as newer version of Maya will drop this when:createNode
if ($editPivotMode)
	if (!`manipMoveContext -q -editPivotMode Move`)
		EnterEditMode;
}

global proc string[] asFitJointIKInfo (string $joint)
{
int $IKNumCtrls=2;
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKParentJointLabel;
string $asFitJointIKInfo[],$tempString[];
$tempString=`ls -l $joint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$label=`asLabel $tempString[$i]`;
	if ($i<size($tempString)-1)
		if (`gmatch $label "*Hand*"` || `gmatch $label "*Chest*"`)// || `gmatch $label "*Foot*"` //removed, allowing for Qtoes joints `under` foot
			break;
	if (`gmatch $label "*Shoulder*"` || `gmatch $label "*Hip*"` || `gmatch $label "*Root*"` || `gmatch $label "0*"`)
		{
		$IKParentJoint=$tempString[$i];
		$IKParentJointLabel=$label;
		break;
		}
	}

string $jointAllDescendents[]=`listRelatives -allDescendents -type joint $joint`;
string $anotherSpineIkJoints[];
$jointAllDescendents[size($jointAllDescendents)]=$joint;
for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
	{
	$label=`asLabel $jointAllDescendents[$i]`;
	int $validLabelHit=0;
	if (`gmatch $label "*Hand*"` && `gmatch $IKParentJointLabel "*Shoulder*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Foot*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Toes*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Chest*"` && `gmatch $IKParentJointLabel "*Root*"`)
		$validLabelHit=1;
	if ($validLabelHit)
		{
		$IKChildJoint=$jointAllDescendents[$i];
		break;
		}
	if (`gmatch $label "0*"` && $jointAllDescendents[$i]!=$joint)//track $anotherSpineIkJoints, so $IKChildJoint is not from another SplineIK
		{
		$tempString=`listRelatives -allDescendents -type joint $jointAllDescendents[$i]`;
		$anotherSpineIkJoints=`stringArrayCatenate $anotherSpineIkJoints $tempString`;
		}
	if (`gmatch $label "*[1-9]*"` && `gmatch $IKParentJointLabel "*0*"` && !`stringArrayCount $jointAllDescendents[$i] $anotherSpineIkJoints`)
		$IKChildJoint=$jointAllDescendents[$i];
	}

if ($IKParentJoint!= "" && $IKChildJoint!="")
	{
	//Find $IKMiddleJoint
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	int $numIkJoints=0;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		$numIkJoints++;
		if ($tempString[$i]==$IKParentJoint)
		break;
		}
	int $middleNr=$numIkJoints/2;
	$IKMiddleJoint=$tempString[size($tempString)-1-$middleNr];
	//Find $IKNumCtrls
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	for ($i=size($tempString)-2;$i>-1;$i--)
		{
		if ($tempString[$i]==$IKParentJoint)
		break;
		$label=`asLabel $tempString[$i]`;
		if (`gmatch $label "*Mid*"` || `gmatch $label "[0-9]*"`)
			$IKNumCtrls++;
		}

	$IKSolver="ikRPsolver";
	$label=`asLabel $IKParentJoint`;
	if (`gmatch $label "*Shoulder*"`)
		$ik="Arm"+`substitute "Shoulder" $label ""`;
	if (`gmatch $label "*Hip*"`)
		$ik="Leg"+`substitute "Hip" $label ""`;
	if (`gmatch $label "*Root*"`)
		{
		$ik="Spine"+`substitute "Root" $label ""`;
		$IKSolver="ikSplineSolver";
		}
	if (`gmatch $label "*0*"` && !`gmatch $label "*[0-9]0*"`)
		{
		$ik="Spline"+`substitute "[0-9]*" $label ""`;
		$IKSolver="ikSplineSolver";
		}

	$asFitJointIKInfo[0]=$ik;
	$asFitJointIKInfo[1]=$IKParentJoint;
	$asFitJointIKInfo[2]=$IKMiddleJoint;	
	$asFitJointIKInfo[3]=$IKChildJoint;	
	$asFitJointIKInfo[4]=$IKSolver;
	$asFitJointIKInfo[5]=$IKNumCtrls;
	}

return $asFitJointIKInfo;
}

global proc string[] asGetIKJoints (string $IKStartJoint, string $IKEndJoint)
{
string $IKJoints[];
string $tempString[]=`ls -l $IKEndJoint`;
tokenize $tempString[0] "|" $tempString;
int $foundStartJoint=0;
for ($i=0;$i<size($tempString);$i++)
	{
    if ($tempString[$i]==$IKStartJoint)
        $foundStartJoint=1;
    if ($foundStartJoint)
    	$IKJoints[size($IKJoints)]=$tempString[$i];
	}
return $IKJoints;
}

global proc asFitSDKCreateAttribute ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$drivenObjs[],$drivenAttrs[];
float $drivenDefaultValue[],$drivenValue[];
if (!size($sel))
	warning "Nothing selected, you should select a SDK Object first\n";
else
	$tempString=`listRelatives -c $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not a nurbsCurve\n";
if (`objectType $tempString[0]`!="nurbsCurve")
	error "Selected Object is not a nurbsCurve\n";
$existingDefaultPoseCmdString=`getAttr ($sel[0]+".defaultPose")`;
$existingDefaultPoseCmds=`stringToStringArray $existingDefaultPoseCmdString ";"`;

string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $cmd;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
		{
		$objAttr=$fitJoints[$i]+"."+$trs[$y]+$xyz[$z];
		float $value=`getAttr $objAttr`;
		for ($a=0;$a<size($existingDefaultPoseCmds);$a++)
			if (`gmatch $existingDefaultPoseCmds[$a] ("setAttr "+$objAttr+" *")`)
				{
				tokenize $existingDefaultPoseCmds[$a] $tempString;
				float $defaultValue=$tempString[2];
				if ($value>$defaultValue+0.001 || $value<$defaultValue-0.001)
					{
					tokenize $tempString[1] "." $tempString2;
					$drivenObjs[size($drivenObjs)]=$tempString2[0];
					$drivenAttrs[size($drivenAttrs)]=$tempString2[1];
					$drivenDefaultValue[size($drivenDefaultValue)]=$defaultValue;
					$drivenValue[size($drivenValue)]=$value;
					}
				}
		}
if (!size($drivenObjs))
	error "Found No attributes changed from Default Pose";

string $suggestAttrName;
if (`gmatch $drivenObjs[0] "*Finger*"` || `gmatch $drivenObjs[0] "*Toe*"`)
	{
	$suggestAttrName=`substitute "[0-9]" $drivenObjs[0] ""`;
	$suggestAttrName=`substitute "Finger" $suggestAttrName ""`;
	$suggestAttrName=`substitute "Toe" $suggestAttrName ""`;
	$suggestAttrNameFirstLetter=`substring $suggestAttrName 1 1`;
	$suggestAttrName=`tolower $suggestAttrNameFirstLetter`+`substring $suggestAttrName 2 99`+"Curl";
	}

$asFitSDKMessage="Create Set-Driven-Key for these ?\n\n";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $value=`getAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i])`;
	float $roundFactor=0.5;
	if ($value<0) $roundFactor=-0.5;
	$value=(trunc($value*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
	$asFitSDKMessage+=$drivenObjs[$i]+"."+$drivenAttrs[$i]+" = "+$value+"\n";
	}
$asFitSDKAttrName=$suggestAttrName;
$asFitSDKObjName=$sel[0];
$asFitSDKDriverValue=10;

string $dialogResult=`layoutDialog -t "Confirm" -ui asFitSDKCreateAttributeLayout`;
if ($dialogResult!="OK")
	return;

string $attrName=$asFitSDKAttrName;
if ($attrName=="" || `gmatch $attrName "* *"`)
	error "Not a valid attribute name";	
if (`attributeExists $attrName $sel[0]`)
	deleteAttr ($sel[0]+"."+$attrName);
addAttr -k 1 -ln $attrName -at double $sel[0];
if ($asFitSDKDriverHasMin) addAttr -e -softMinValue $asFitSDKDriverMin ($sel[0]+"."+$attrName);
if ($asFitSDKDriverHasMax) addAttr -e -softMaxValue $asFitSDKDriverMax ($sel[0]+"."+$attrName);

for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $driverValue=10;
	$objAttr=$drivenObjs[$i]+"."+$drivenAttrs[$i];
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenDefaultValue[$i] -dv 0 -cd ($sel[0]+"."+$attrName) $objAttr;
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValue[$i] -dv $asFitSDKDriverValue -cd ($sel[0]+"."+$attrName) $objAttr;
//	setAttr ($sel[0]+"."+$attrName) $driverValue;
	}
select $drivenObjs;
setInfinity -pri cycleRelative -poi cycleRelative;

select $sel;
}

global proc asFitSDKCreateAttributeLayout ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $tempString[];
tokenize $asFitSDKMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asFitSDKMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asFitSDKMessage+=$tempString[$i]+"\n";
	$asFitSDKMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout;
	text -l $asFitSDKMessage;
	separator -h 10 -st none;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 -tx $asFitSDKAttrName asFitSDKAttrNameTextField;
		setParent..;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Value:";
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverValueFloatField;
		setParent..;
	separator -st none -h 3;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		checkBox -l "Min" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMinFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMinFloatField" asFitSDKDriverHasMinCheckBox;
		checkBox -l "Max" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMaxFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMaxFloatField" asFitSDKDriverHasMaxCheckBox;
		setParent..;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		floatField -w 50 -v 0 -pre 1 asFitSDKDriverMinFloatField;
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverMaxFloatField;
		setParent..;
	separator -h 10 -st none;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asFitSDKCreateAttributeGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
}

global proc asFitSDKCreateAttributeGetName ()
{
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
$asFitSDKAttrName=`textField -q -tx asFitSDKAttrNameTextField`;
$asFitSDKDriverValue=`textField -q -tx asFitSDKDriverValueFloatField`;
$asFitSDKDriverHasMin=`checkBox -q -v asFitSDKDriverHasMinCheckBox`;
$asFitSDKDriverHasMax=`checkBox -q -v asFitSDKDriverHasMaxCheckBox`;
$asFitSDKDriverMin=`floatField -q -v asFitSDKDriverMinFloatField`;
$asFitSDKDriverMax=`floatField -q -v asFitSDKDriverMaxFloatField`;
}

global proc int asGetPartJoints (string $fitJoint)
{
int $partJoints;

if (`attributeExists inbetweenJoints $fitJoint`)
	$partJoints=`getAttr ($fitJoint+".inbetweenJoints")`;
if (`attributeExists twistJoints $fitJoint`)
	$partJoints=`getAttr ($fitJoint+".twistJoints")`;

return $partJoints;
}

global proc int asPartNrFromPartName (string $name)
{
int $partNr,$digits;
string $char;
string $tempString[];

if (!`gmatch $name "*Part[0-9]*"`)
	return $partNr;
tokenize $name "_" $tempString;
$numChar=size($tempString[0]);
for ($i=$numChar;$i>-1;$i--) 
	{
	$char=`substring $tempString[0] $i $i`;
	if (!`gmatch $char "[0-9]"`)
		break;
	$digits++;
	}
$partNr=`substring $tempString[0] ($numChar-$digits+1) $numChar`;

return $partNr;
}

global proc string asCreateWrap (string $name,float $threshold, float $maxDistance, int $exclusiveBind, int $autoWeightThreshold, int $falloffMode)
{//asCreateWrap (0,0,0,1,0);
string $sel[]=`ls -sl`;
string $tempString[];
string $wrapNode;
string $surfaceShape=$sel[1];
string $driverTrans=$sel[0];
select $driverTrans;

$tempString=`deformer -n $name -type wrap`;
$wrapNode=$tempString[0];

setAttr ($wrapNode + ".weightThreshold") $threshold;
setAttr ($wrapNode + ".maxDistance") $maxDistance;
setAttr ($wrapNode + ".exclusiveBind") $exclusiveBind;
setAttr ($wrapNode + ".autoWeightThreshold") $autoWeightThreshold;
setAttr ($wrapNode + ".falloffMode") $falloffMode;

//connectAttr ($surfaceShape+".worldMatrix[0]") ($wrapNode+".geomMatrix");
//addInfluence ({$wrapNode}, $driverTrans, $inflType, $renderInfl);
select $sel;
AddWrapInfluence;

return $wrapNode;
}

global proc asFitGeometry ()
{
global int $asFitModeScriptJobNr1;
int $wasInFitMode;
if (!`objExists FitSkeleton`)
	{
	print ("// No FitSkeleton found\n");
	return;
	}
if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
	{
	$wasInFitMode=1;
	asOffFitMode;//as any import seem to create a endless selectionChanged trigger loop
	}
asEnsureFitSkeletonAttributes;
string $sel[]=`ls -sl`;
//int $displayGeometry=`checkBox -q -v asVisGeo`;
int $displayGeometry=`getAttr FitSkeleton.visGeo`;
//int $displayPoleVector=`checkBox -q -v asVisPoleVector`;
int $displayPoleVector=`getAttr FitSkeleton.visPoleVector`;
if (`objExists FitSkeletonVisualizers`) delete FitSkeletonVisualizers;
if (`objExists Mannequin_Geometry`) delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`) delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`) delete SkinCage_Geometry;
if ($displayGeometry==0)
	{
	if ($displayPoleVector)
		asFitDisplayPoleVector 1;
	asUpdateButtonEnables;
	return;
	}
asFitModeEnsureShaders;
int $twistJoints,$inbetweenJoints;
float $aimV[3]={1,0,0};
float $upV[3]={0,1,0};
string $part;

createNode -n FitSkeletonVisualizers transform;
connectAttr FitSkeleton.s FitSkeletonVisualizers.s;
createNode -n Aims -p FitSkeletonVisualizers transform;
string $tempString[],$geoObjs[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asGeometry.ma";
file -i $asGeometryFile;
string $templateBones[]=`listRelatives -c Skeleton_Geometry`;
for ($i=0;$i<size($templateBones);$i++)
	rename $templateBones[$i] ($templateBones[$i]+"_template");

asEnsureAllFitJointAttrs;

for ($i=0;$i<size($fitJoints);$i++)
	{
	clear $geoObjs;
	string $rlaChild=`asRlaChild $fitJoints[$i]`;
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($rlaChild=="" && $fitJoints[$i]=="Root" && $tempString[0]!="") // Root to use sideChild, if no middleChild
		$rlaChild=$tempString[0];
	if ($rlaChild=="")
		continue;
//	if (`attributeExists worldOrient $fitJoints[$i]`)
//		continue;
	if (!`objExists asCreatePolyBoxes`)
		if (`gmatch $fitJoints[$i] "*Ankle*"` || `gmatch $fitJoints[$i] "*Wrist*"` || `gmatch $fitJoints[$i] "*Cup*"`)
			continue;
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	if ($fitJoints[$i]=="*Jaw*" || `gmatch $fitJoints[$i] "*Eye*"`)
		continue;	

	createNode -n ($fitJoints[$i]+"Aim") -p Aims transform;
	$twistJoints=0;
	if (`attributeExists twistJoints  $fitJoints[$i]`)
		$twistJoints=`getAttr ($fitJoints[$i]+".twistJoints")`;
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints  $fitJoints[$i]`)
		$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+$part+"Geo") -p ($fitJoints[$i]+"Aim") transform;
	
		//box
		$tempString=`polyCube -n ($fitJoints[$i]+$part+"Box") -w 1.75 -h 1 -d 1.75 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
		$box=$tempString[0];
		$geoObjs[size($geoObjs)]=$box;
		move -r 0 0.5 0 ($box+".vtx[0:7] ");
		sets -e -forceElement asRedSG ($box+".f[1]");
		sets -e -forceElement asRed2SG ($box+".f[3]");
		sets -e -forceElement asGreenSG ($box+".f[0]");
		sets -e -forceElement asGreen2SG ($box+".f[2]");
		sets -e -forceElement asBlueSG ($box+".f[4]");
		sets -e -forceElement asBlue2SG ($box+".f[5]");
		connectAttr FitSkeleton.visBoxes ($box+".v");
		setAttr ($box+"Shape.overrideEnabled") 1;
		setAttr ($box+"Shape.overrideDisplayType") 2;
		parent $box ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($box+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($box+".vtx[0:7]");
	
		
		//cylinder
		$tempString=`cylinder -n ($fitJoints[$i]+$part+"Cyl") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -hr 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0`;
		$cyl=$tempString[0];
		$geoObjs[size($geoObjs)]=$cyl;
		move -r 0 0.5 0 ($cyl+".cv[0:3][0:7]");
		sets -e -forceElement asBlueSG ($cyl+".sf[0][7]") ($cyl+".sf[0][0]");//sf[0][1:2]
		sets -e -forceElement asGreenSG ($cyl+".sf[0][1:2]");//sf[0][3:4]
		sets -e -forceElement asBlue2SG ($cyl+".sf[0][3:4]");//sf[0][5:6]
		sets -e -forceElement asGreen2SG ($cyl+".sf[0][5:6]");//sf[0][7]
		connectAttr FitSkeleton.visCylinders ($cyl+".v");
		setAttr ($cyl+"Shape.overrideEnabled") 1;
		setAttr ($cyl+"Shape.overrideDisplayType") 2;
		parent $cyl ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($cyl+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($cyl+".cv[0:3][0:7]");	
		}

	//sphere
	$tempString=`polyCube -n ($fitJoints[$i]+"Sphere") -w 2.5 -h 2.5 -d 2.5 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
	$sphere=$tempString[0];
	sets -e -forceElement asRedSG ($sphere+".f[1]");
	sets -e -forceElement asRed2SG ($sphere+".f[3]");
	sets -e -forceElement asGreenSG ($sphere+".f[0]");
	sets -e -forceElement asGreen2SG ($sphere+".f[2]");
	sets -e -forceElement asBlueSG ($sphere+".f[4]");
	sets -e -forceElement asBlue2SG ($sphere+".f[5]");
	polySmooth  -mth 0 -dv 2 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 0 $sphere;
	connectAttr FitSkeleton.visSpheres ($sphere+".v");
	setAttr ($sphere+"Shape.overrideEnabled") 1;
	setAttr ($sphere+"Shape.overrideDisplayType") 2;
	parent $sphere ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($sphere+".s") 1 1 1;
	rotate -r -p 0 0 0 -os 0 -90 -90 ($sphere+".vtx[0:999]");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sz");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sx");

	//bones
	$bone=$fitJoints[$i]+"Bone";
	if ($fitJoints[$i]!="Scapula")
		{
		if (`objExists ($fitJoints[$i]+"Bone_template")`){
		duplicate -n $bone ($fitJoints[$i]+"Bone_template");}
		else if ($fitJoints[$i]=="Root" || $fitJoints[$i]=="Chest" || `gmatch $fitJoints[$i] "Neck*"` || `gmatch $fitJoints[$i] "Spine*"`)
			duplicate -n $bone SpineBone_template;
		else if (`gmatch $fitJoints[$i] "*Finger*"`)
			duplicate -n $bone DigitBone_template;
		else
			duplicate -n $bone GenericBone_template;
		sets -e -forceElement asBonesSG $bone;
		parent $bone ($fitJoints[$i]+"Aim");
		connectAttr FitSkeleton.visBones ($bone+".v");
		connectAttr ($fitJoints[$i]+".fat") ($bone+".sy");
		connectAttr ($fitJoints[$i]+".fat") ($bone+".sz");
		}

	//Flare
	select $geoObjs;
	$tempString=`nonLinear -type flare  -lowBound 0 -highBound 1 -startFlareX 1 -startFlareZ 1 -endFlareX 1 -endFlareZ 1 -curve 0`;
	string $flare=`rename $tempString[0] ($fitJoints[$i]+"Flare")`;
	string $flareHandle=`rename $tempString[1]  ($fitJoints[$i]+"FlareHandle")`;
	parent $flareHandle ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($flareHandle+".s") 1 1 1;
	setAttr -type float3 ($flareHandle+".t") 0 0 0;
	setAttr -type float3 ($flareHandle+".r") 0 0 -90;
	setAttr -l 1 ($flareHandle+".v") 0;
	
	//maya2020.4 seems to have a `bug`, where flare connects from deformFlare->nonLinear, (other versions are reverse)
	if (`isConnected ($flareHandle+".startFlareX") ($flare+".startFlareX")`)
		{
		connectAttr ($fitJoints[$i]+".fatFrontAbs") ($flareHandle+".startFlareX");
		connectAttr ($fitJoints[$i]+".fatWidthAbs") ($flareHandle+".startFlareZ");
		connectAttr ($rlaChild+".fatFrontAbs") ($flareHandle+".endFlareX");
		connectAttr ($rlaChild+".fatWidthAbs") ($flareHandle+".endFlareZ");
		}
	else
		{//this is for the non maya2020.4 versions
		connectAttr ($fitJoints[$i]+".fatFrontAbs") ($flare+".startFlareX");
		connectAttr ($fitJoints[$i]+".fatWidthAbs") ($flare+".startFlareZ");
		connectAttr ($rlaChild+".fatFrontAbs") ($flare+".endFlareX");
		connectAttr ($rlaChild+".fatWidthAbs") ($flare+".endFlareZ");
		}

	//Distance
	if (`objExists ($fitJoints[$i]+"Distance")`) delete ($fitJoints[$i]+"Distance");
	createNode -n ($fitJoints[$i]+"Distance") distanceBetween;
	connectAttr ($fitJoints[$i]+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix1");
	connectAttr ($rlaChild+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix2");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv1")`) delete ($fitJoints[$i]+"ScaleYMultiDiv1");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv1") multiplyDivide;
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.operation") 2;
//	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y");

//	addAttr -ln dummyInput1Y -at double ($fitJoints[$i]+"ScaleYMultiDiv1");
//	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.dummyInput1Y");
//	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y") `getAttr ($fitJoints[$i]+"Distance.distance")`;
	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y");

	connectAttr FitSkeleton.sy ($fitJoints[$i]+"ScaleYMultiDiv1.input2Y");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv2")`) delete ($fitJoints[$i]+"ScaleYMultiDiv2");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv2") multiplyDivide;
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv2.input1Y");
	connectAttr FitSkeleton.visGap ($fitJoints[$i]+"ScaleYMultiDiv2.input2Y");
	
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($flareHandle+".sy");

//	parentConstraint $fitJoints[$i] ($fitJoints[$i]+"Aim");
	pointConstraint $fitJoints[$i] ($fitJoints[$i]+"Aim");

	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y) multiplyDivide;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input2Y") ($y*(1.0/($twistJoints+$inbetweenJoints+1)));
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo.tx");

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y) multiplyDivide;
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".operation") 2;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv2.outputY") ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input2Y") ($twistJoints+$inbetweenJoints+1);
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo"+".sx");
		}
	}

if (`objExists PelvisBone`)
	{
	parent PelvisBone FitSkeletonVisualizers;
	setAttr PelvisBone.tx 0;
	setAttr -type float3 PelvisBone.r 0 0 0;
	pointConstraint -skip x Hip PelvisBone;
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;
asFitModeManualUpdate;
asUpdateButtonEnables;
asChangeVisGeoType;
if ($displayPoleVector)
	asFitDisplayPoleVector 1;
if ($wasInFitMode)
	asFitMode;
catchQuiet (`select $sel`);
}

global proc asChangeVisGeoType ()
{
string $geoType=`optionMenu -q -v asVisGeoType`;
setAttr FitSkeleton.visCylinders 0;
setAttr FitSkeleton.visBoxes 0;
setAttr FitSkeleton.visSpheres 0;
setAttr FitSkeleton.visBones 0;
if ($geoType=="cylinders")
	setAttr FitSkeleton.visCylinders 1;
if ($geoType=="boxes")
	setAttr FitSkeleton.visBoxes 1;
if ($geoType=="spheres")
	setAttr FitSkeleton.visSpheres 1;
if ($geoType=="bones")
	setAttr FitSkeleton.visBones 1;
}


global proc asEnsureAllFitJointAttrs ()
{
string $sel[]=`ls -sl`;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
string $deformJoints[];

for ($i=size($fitJoints)-1;$i>-1;$i--) // Reverse order, so endJoints can copy `fat` value from parent
	asEnsureFitJointAttrs $fitJoints[$i];

//also update AdvJointAttrs, as we might be applying a `new` proc on a `old` character. e.g. CreateSkinCage on a rig from v<5.813
if (`objExists DeformationSystem`)
	{
	$deformJoints=`listRelatives -ad -type joint DeformationSystem`;
	for ($i=0;$i<size($deformJoints);$i++)
		{
		if (!`attributeExists fatFront $deformJoints[$i]`)
			addAttr -k 1 -min 0 -dv 1 -ln fatFront -at double $deformJoints[$i];
		if (!`attributeExists fatWidth $deformJoints[$i]`)
			addAttr -k 1 -min 0 -dv 1 -ln fatWidth -at double $deformJoints[$i];

		//v 5.813 upgrade
		if (`attributeExists fatY $deformJoints[$i]`)
			{
			setAttr ($deformJoints[$i]+".fatFront") `getAttr ($deformJoints[$i]+".fatY")`;
			deleteAttr ($deformJoints[$i]+".fatY");
			}
		if (`attributeExists fatZ $deformJoints[$i]`)
			{
			setAttr ($deformJoints[$i]+".fatWidth") `getAttr ($deformJoints[$i]+".fatZ")`;
			deleteAttr ($deformJoints[$i]+".fatZ");
			}
		}
	}

catchQuiet (`select $sel`);
}

global proc asEnsureFitJointAttrs (string $fitJoint)
{
float $fat;
string $priAxis="X";
string $secAxis="Y";
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
float $pos[];

if (`attributeExists primaryAxis FitSkeleton`)
	$priAxis=`getAttr -asString FitSkeleton.primaryAxis`;
if (`attributeExists secondaryAxis FitSkeleton`)
	$secAxis=`getAttr -asString FitSkeleton.secondaryAxis`;

if (!`attributeExists fat $fitJoint`)
	{
	float $dv=1;
	string $rlaChild=`asRlaChild $fitJoint`;
	if ($rlaChild!="")
		{
		$dv=`getAttr ($rlaChild+".translate"+$priAxis)`;
		$dv=`abs($dv)`/4.0;
		$pos=`xform -q -ws -t $fitJoint`;
		if ($pos[0]<$centerTolerance && $pos[0]>($centerTolerance*-1))
			$dv*=2;//larger in center
		}
	else
		{
		string $tempString[]=`listRelatives -p -type joint $fitJoint`;
		if ($tempString[0]!="" && `attributeExists fat $tempString[0]`)
			$dv=`getAttr ($tempString[0]+".fat")`;
		}
	addAttr -k 1 -min 0 -dv $dv -ln fat -at double $fitJoint;
	}
if (!`attributeExists fatFront $fitJoint`)
	{
	if (`attributeExists fat $fitJoint`)//delete and reMake fat as well, to keep all fat attrs next to eachother
		{
		$fat=`getAttr ($fitJoint+".fat")`;
		deleteAttr ($fitJoint+".fat");
		addAttr -k 1 -min 0 -dv $fat -ln fat -at double $fitJoint;
		}

	addAttr -k 1 -min 0 -dv 1 -ln fatFront -at double $fitJoint;
	}
if (!`attributeExists fatWidth $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatWidth -at double $fitJoint;
if (!`attributeExists fatFrontAbs $fitJoint`)
	addAttr -k 0 -ln fatFrontAbs -at double $fitJoint;
if (!`attributeExists fatWidthAbs $fitJoint`)
	addAttr -k 0 -ln fatWidthAbs -at double $fitJoint;

//v 5.813 upgrade
if (`attributeExists fatY $fitJoint`)
	{
	setAttr ($fitJoint+".fatFront") `getAttr ($fitJoint+".fatY")`;
	deleteAttr ($fitJoint+".fatY");
	}
if (`attributeExists fatZ $fitJoint`)
	{
	setAttr ($fitJoint+".fatWidth") `getAttr ($fitJoint+".fatZ")`;
	deleteAttr ($fitJoint+".fatZ");
	}
if (`attributeExists fatYAbs $fitJoint`) deleteAttr ($fitJoint+".fatFrontAbs");
if (`attributeExists fatZabs $fitJoint`) deleteAttr ($fitJoint+".fatZabs");

if (`objExists ($fitJoint+"Fat")`) delete ($fitJoint+"Fat");
createNode -n ($fitJoint+"Fat") multiplyDivide;
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Y");
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Z");
connectAttr -f ($fitJoint+".fatFront") ($fitJoint+"Fat.input2Y");
connectAttr -f ($fitJoint+".fatWidth") ($fitJoint+"Fat.input2Z");
connectAttr -f ($fitJoint+"Fat.outputY") ($fitJoint+".fatFrontAbs");
connectAttr -f ($fitJoint+"Fat.outputZ") ($fitJoint+".fatWidthAbs");
}

global proc asRemoveUnusedfromBuildPose (string $uiName)
{
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	$buildPose="faceBuildPose";
string $buildPoseCmds[],$newBuildPoseCmds[];
string $cmds[],$tempString[];

$buildPoseCmds[0]=`getAttr ($buildPose+".udAttr")`;
if (`attributeExists udExtraAttr $buildPose`)
	$buildPoseCmds[1]=`getAttr ($buildPose+".udExtraAttr")`;

for ($a=0;$a<size($buildPoseCmds);$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $cmds;
	for ($i=0;$i<size( $cmds);$i++)
		{
		tokenize $cmds[$i] $tempString;
		string $ctrl=$tempString[size($tempString)-1];
		if (`gmatch $cmds[$i] "*[.]*"`)
			$ctrl=$tempString[size($tempString)-2];
		if (`objExists $ctrl`)
			$newBuildPoseCmds[$a]=$newBuildPoseCmds[$a]+$cmds[$i]+";";
		}
	if ($a==0) setAttr -type "string" ($buildPose+".udAttr") $newBuildPoseCmds[$a];
	if ($a==1) setAttr -type "string" ($buildPose+".udExtraAttr") $newBuildPoseCmds[$a];
	}
}

global proc asUpdateASToolsProcsInSelectors ()
{
string $AdvancedSkeletonFile=`asGetScriptLocation`+"/AdvancedSkeleton.mel";
string $fDet,$fDet2;
string $files[];
int $fileId=`fopen $AdvancedSkeletonFile "r"`;
string $nextLine = `fgetline $fileId`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	if (`gmatch $nextLine "*[*][*][*][*][*][*]*"`)// ******ext files only
		continue;
	if ($nextLine=="string $asToolsProceduresVersion=\"x.xxx\";\n")
		$nextLine="string $asToolsProceduresVersion="+`asGetScriptVersionAsString`+";\n";
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId;

string $selectorsDir=`asGetScriptLocation`+"/AdvancedSkeletonFiles/Selector/";
string $selectorFiles[]=`getFileList -fs "*.mel" -fld $selectorsDir`;
for ($i=0;$i<size($selectorFiles);$i++)
	$files[size($files)]=$selectorsDir+$selectorFiles[$i];
$files[size($files)]=`asGetScriptLocation`+"/AdvancedSkeletonFiles/picker/picker.mel";

for ($i=0;$i<size($files);$i++)
	{
	int $fileId=`fopen $files[$i] "r"`;
	string $nextLine = `fgetline $fileId`;
	int $copyLines=0;
	$fDet2="";
	while (size($nextLine)>0)
		{
		$fDet2+=$nextLine;
		$nextLine=`fgetline $fileId`;
		if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
			break;
		}
	fclose $fileId;

	int $fileId2=`fopen $files[$i] "w"`;
	fprint $fileId2 ($fDet2+$fDet);
	fclose $fileId2;
	print ("// Updated:"+$files[$i]+"\n");
	}
}

global proc asUpdateEmbeddedPicker ()
{
int $fileId;
string $file;

//Picker-updater (system for animators to manually update Embedded Pickers)
sysFile -cp (`asGetScriptLocation`+"/distributes/ftp/download/picker/picker.mel") (`asGetScriptLocation`+"/AdvancedSkeletonFiles/picker/picker.mel");
$file=`asGetScriptLocation`+"/distributes/ftp/download/picker/pickerVersion.txt";
$fileId=`fopen $file "w"`;
fprint $fileId `asGetScriptVersionAsString`;
fclose $fileId;
print ("// Updated: /distributes/ftp/download/picker/picker.mel & pickerVersion.txt\n");
}

global proc asSetFixedWrapOptions ()
{
optionVar -intValue autoWeightThreshold 1;
optionVar -intValue exclusiveBind 0;
optionVar -intValue renderInfl 1;
optionVar -stringValue falloffMode "volume";
}

global proc string asGetSkinCluster (string $object)
{
string $historyNodes[]=`listHistory -pdo 1 -il 2 $object`;
string $skinCluster;
for ($i=0;$i<size($historyNodes);$i++)
	if (`nodeType $historyNodes[$i]`=="skinCluster")
		$skinCluster=$historyNodes[$i];
return $skinCluster;
}

global proc asSetRGBOverrideColor (string $obj, float $rgbValues[])
{
string $RGB[]={"R","G","B"};

setAttr ($obj+".overrideRGBColors") 1;
for ($z=0;$z<size($RGB);$z++)
	setAttr ($obj+".overrideColor"+$RGB[$z]) $rgbValues[$z];
}

global proc asSnapRotateCurve (int $axis[])
{
string $sel[]=`ls -sl`;
string $tempString[];

for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		rotate -r -ocp -os (90*$axis[0]) (90*$axis[1]) (90*$axis[2]) ($tempString[$y]+".cv[0:999]");
	}

print ("// Snap-rotated "+size($sel)+" controllers.\n");
}

global proc asSwapCurve ()
{
string $side,$oppositeSide,$allSet,$cmd;
string $tempString[],$tempString2[],$tempString3[],$ctrls[];
string $sel[]=`ls -sl`;
int $ctrlFromEdges,$shapeWasInAllset,$shapeWasInFaceAllset;
int $last=`size($sel)`-1;
float $pos[];
string $selShapes[];

if (size($sel)<2)
	error "Selected both controls to replace, and the new curve to use";
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	$selShapes[$i]=$tempString[0];
	if (`gmatch $sel[$i] "*Extra*"`)
		continue;
	if (`gmatch $sel[$i] "*[.]e*"`)
		{
		$ctrlFromEdges=1;
		break;
		}
	if (!`objExists $selShapes[$i]`)
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objectType $selShapes[$i]`!="nurbsCurve" && `objectType $selShapes[$i]`!="nurbsSurface")
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	}

if ($ctrlFromEdges)
	{
	print "// Edges detected, Creating curve controller from edges.\n";
	if (`objExists combinedEdgesAsCurve`)
		delete combinedEdgesAsCurve;
	select -cl;
	for ($i=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] "*[.]e*"`)
			select -add $sel[$i];
		else if (`objectType $sel[$i]`=="transform")
			$ctrls[size($ctrls)]=$sel[$i];
		}
	if ($ctrls[0]=="")
		error "No Controller found in the selection";
	DuplicateCurve -ch 0;
	DeleteHistory;
	$tempString=`ls -sl`;
	if (size($tempString)==1)
		duplicate -n combinedEdgesAsCurve $tempString[0];
	else
		attachCurve -n combinedEdgesAsCurve -ch 0 -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1;
	delete $tempString;
	createNode -n tempXform -p $ctrls[0] transform;
	parent -w tempXform;
	parent combinedEdgesAsCurve tempXform;
	xform -os -t 0 0 0 -ro 0 0 0 tempXform;
	parent -w combinedEdgesAsCurve;
	makeIdentity -a 1 -t 1 -r 1 -s 1 combinedEdgesAsCurve;
	xform -ws -piv 0 0 0 combinedEdgesAsCurve;
	scale -r -p 0 0 0 1.3 1.3 1.3 combinedEdgesAsCurve.cv[0:999];
	setAttr combinedEdgesAsCurveShape.overrideEnabled 1;
	$tempString=`listRelatives -s $ctrls[0]`;
	setAttr combinedEdgesAsCurveShape.overrideColor `getAttr ($tempString[0]+".overrideColor")`;
	delete tempXform;
	select $ctrls;
	select -add combinedEdgesAsCurve;
	asSwapCurve;
	delete combinedEdgesAsCurve;
	select $ctrls;
	return;
	}

select $sel[$last];
DeleteHistory;
		
for ($i=0;$i<size($sel)-1;$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if ($tempString[0]!="")
		{
		if (`objExists AllSet`)
			$shapeWasInAllset=`sets -im AllSet $tempString[0]`;
		if (`objExists FaceAllSet`)
			$shapeWasInFaceAllset=`sets -im FaceAllSet $tempString[0]`;
		}
	clear $tempString3;
	if (size($tempString))
		{
//		$tempString3=`listConnections -s 1 -d 0 -p 1 ($tempString[0]+".v")`;
		//faces uses .drawOverride.overrideVisibility so re-connect all connections
		$tempString3=`listConnections -s 1 -d 0 -p 1 ($tempString[0])`;
		delete $tempString;
		}
	duplicate -n tempXform $sel[$last];
	$tempString=`listRelatives -f -s tempXform`;
	for ($y=0;$y<size($tempString);$y++)
		rename $tempString[$y] ($sel[$i]+"Shape");
	$allSet="AllSet";
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $sel[$i]`)
			$allSet="FaceAllSet";
	$tempString=`listRelatives -s tempXform`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`parent -add -s $tempString[$y] $sel[$i]`;
		$tempString[$y]=$tempString2[0];
		float $rot[]=`xform -q -ws -ro $sel[$i]`;
		if (!($rot[0]==0 && $rot[1]==0 && $rot[2]==0))
			if (!`objExists combinedEdgesAsCurve`)
				rotate -r -os -90 -90 0 ($tempString[$y]+".cv[0:9999]");
		if ($shapeWasInAllset)//previous shape might not be, e.g could be a ClusterControl
			sets -add $allSet $tempString[$y];
		if ($shapeWasInFaceAllset)//previous shape might not be, e.g could be a ClusterControl
			sets -add $allSet $tempString[$y];
		if ($tempString3[0]!="")
			catchQuiet (`eval ("connectAttr "+$tempString3[0]+" "+$tempString[$y]+".v")`);
		}
	delete tempXform;
	}
	dgdirty -a;
}

//TODO: Preserve Connections to CurveShapes, E.g. ctrlBox.ACtrlVis Cheek_RShape.drawOverride.overrideVisibility;

global proc asSelectCurve ()
{
string $controlSetMembers[],$controllers[],$tempString[];
string $controllerType=`optionMenu -q -v asControllerTypeOptionMenu`;
string $controllerSide=`optionMenu -q -v asControllerSideOptionMenu`;
string $side;

if ($controllerSide=="Right") $side="_R";
if ($controllerSide=="Left") $side="_L";
if ($controllerSide=="Middle") $side="_M";

if ($controllerType=="Fingers") $controllerType="FK*Finger*";

if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;

for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (`gmatch $controlSetMembers[$i] "*Extra*"`)
		continue;
	if ($controllerType!="*All")
		{
		if (!`gmatch $controlSetMembers[$i] ($controllerType+"*")`)
			continue;
		if ($controllerType=="FK" && `gmatch $controlSetMembers[$i] "FKIK*"`)//FKIK != FK
			continue;
		}
	if ($controllerSide!="*All")
		if (!`gmatch $controlSetMembers[$i] ("*"+$side)`)
			continue;
	$controllers[size($controllers)]=$controlSetMembers[$i];
	}

//different way to find the controllers for Face:
if (`gmatch $controllerType "Face:*"` && `objExists ctrlBox`)
	{
	$type=`substitute "Face:" $controllerType ""`;
	$tempString=`listConnections -s 0 -d 1 ("ctrlBox."+$type+"CtrlVis")`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($controllerSide!="*All")
			if (!`gmatch $tempString[$i] ("*"+$side)`)
				continue;
		$controllers[size($controllers)]=$tempString[$i];
		}
	}
select -cl;
select $controllers;
print ("// Selected "+size($controllers)+" controllers.\n");
}

global proc asSetCurveWidth ()
{
int $numCtrls;
int $lineWidth=`intField -q -v asCurveWidthIntField`;
string $sel[]=`ls -sl`;
string $tempString[];

for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
//print ($y+" : "+$tempString[$y]+" "+`attributeExists lineWidth $tempString[$y]`+"\n");
		if (!`attributeExists lineWidth $tempString[$y]`)
			continue;
print ("setAttr "+$tempString[$y]+".lineWidth "+$lineWidth+";\n");
		setAttr ($tempString[$y]+".lineWidth") $lineWidth;
		if ($y==0)
			$numCtrls++;
		}
	}
print ("// Set Width for "+$numCtrls+" controllers.\n");
}

global proc asSetCurveColor ()
{
int $curveColor=`palettePort -q -setCurCell asCurveColorPalettePort`;
int $useOverrideRGBColors=0;
float $rgb[];
string $type;
string $sel[]=`ls -sl`;
string $tempString[];

if (`asMayaVersionAsFloat`>=2014 && $curveColor>0)
	{
	//Maya2015 onwards have "overrideRGBColors"
	$rgb=`palettePort -q -rgb asCurveColorPalettePort`;
	$storedRgb=`colorIndex -query $curveColor`;
	if ($storedRgb[0]==$rgb[0] && $storedRgb[1]==$rgb[1] && $storedRgb[2]==$rgb[2])
		{
		print "// Default index color, using \"overrideIndexColors\".\n";
		$useOverrideRGBColors=0;
		}
	else
		{
		print "// Non default index color, using \"overrideRGBColors\".\n";
		$useOverrideRGBColors=1;
		}
	}


for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		setAttr ($tempString[$y]+".overrideEnabled") 1;
		setAttr ($tempString[$y]+".overrideColor") $curveColor;
		if ($useOverrideRGBColors)
			{
			setAttr ($tempString[$y]+".overrideRGBColors") 1;
			setAttr -type float3 ($tempString[$y]+".overrideColorRGB") $rgb[0] $rgb[1] $rgb[2];
			}
		else
			setAttr ($tempString[$y]+".overrideRGBColors") 0;
		}
	}
print ("// Colored "+size($sel)+" controllers.\n");
}

global proc asControlCurvesPrintInfo ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
string $sel[]=`ls -sl`;
string $curveShape;
string $tempString[],$cmds[],$skinCurves1[],$skinCurves2[];
int $spans,$degree,$numCVs,$selOnly;
float $cvPos[3],$pos[],$rot[],$sca[];
int $reuseShape=`checkBox -q -v asControlCurvesReUseShapeCheckBox`;
int $reuseColor=`checkBox -q -v asControlCurvesReUseColorCheckBox`;
int $reuseCatch=`checkBox -q -v asControlCurvesReUseCatchCheckBox`;
int $reuseReBuild=`checkBox -q -v asControlCurvesReUseReBuildCurvesCheckBox`;
int $reuseSkinCurves=`checkBox -q -v asControlCurvesReUseSkinCurvesCheckBox`;
int $reuseFace=`checkBox -q -v asControlCurvesReUseFaceCheckBox`;

if ($reuseSkinCurves)
	{
	$skinCurves1=`listConnections SkinCurves1.drawInfo`;
	$skinCurves2=`listConnections SkinCurves2.drawInfo`;
	$controlSetMembers=`stringArrayCatenate $skinCurves1 $skinCurves2`;
	}
if ($reuseFace)
	$controlSetMembers=`sets -q FaceControlSet`;

//$selOnly
for ($i=0;$i<size($sel);$i++)
	if (`stringArrayCount $sel[$i] $controlSetMembers`)
		$selOnly=1;
if ($selOnly)
	{
	$tempString=$controlSetMembers;
	clear $controlSetMembers;
	for ($i=0;$i<size($sel);$i++)
		if (`stringArrayCount $sel[$i] $tempString`)
			$controlSetMembers[size($controlSetMembers)]=$sel[$i];
	}

for ($i=0;$i<size($controlSetMembers);$i++)
	{
	//SkinCurves also use xform
	if ($reuseSkinCurves)
		{
		$pos=`getAttr ($controlSetMembers[$i]+".t")`;
		$rot=`getAttr ($controlSetMembers[$i]+".r")`;
		$sca=`getAttr ($controlSetMembers[$i]+".s")`;
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".t "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".r "+$rot[0]+" "+$rot[1]+" "+$rot[2];
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".s "+$sca[0]+" "+$sca[1]+" "+$sca[2];
		}

	$tempString=`listRelatives -s $controlSetMembers[$i]`;
	for ($z=0;$z<size($tempString);$z++)
		{
		$curveShape=$tempString[$z];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		if ($reuseReBuild)
			$cmds[size($cmds)]="rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s "+$spans+" -d "+$degree+" -tol 0.01 "+$curveShape;
		if ($reuseShape)
			for ($y=0;$y<$numCVs;$y++)
				{
				$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
				$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2];
				}
		//color
		if ($reuseColor)
			$cmds[size($cmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($curveShape+".overrideColor")`;
		}
	}
for ($i=0;$i<size($cmds);$i++)
	if ($reuseCatch)
		$cmds[$i]="catch (`"+$cmds[$i]+"`)";

for ($i=0;$i<size($cmds);$i++)
	print ($cmds[$i]+";\n");
}

global proc asCreateControlMesh ()
{
string $sel[]=`ls -sl`;
string $faces[]=`ls -sl`;
float $pos[];
string $tempString[],$tempString2[],$shadingEngines[];
int $mirror=`checkBox -q -v asCreateControlMeshMirrorCheckBox`;
string $meshControl,$generatedXform,$sourceMesh,$sourceXform,$transformGeometry,$deleteComponent,$polyNormal;
if (size($sel)<2)
	error "Select polyFaces And Control";
string $control=$sel[size($sel)-1];
if (`gmatch $control "*.*"`)
	error "Control must be selected last";
if (!`gmatch $sel[0] "*.f*"`)
	error "Poly-faces must be selected";
string $sourceMeshes[]=`ls -sl -o -type mesh`;
if (size($sourceMeshes)>1)
	error "select faces from only 1 object at the time";
int $numLetters=size($control);
string $mirrorControl=`substring $control 1 ($numLetters-2)`+"_L";
if (`gmatch $control "*_L"`)
	$mirrorControl=`substring $control 1 ($numLetters-2)`+"_R";

select -d $control;
asEnsureMainCtrlVisAttrs;
for ($y=0;$y<99;$y++)
	{
	if ($y==0) $meshControl=$control+"MeshCtrl";
	else $meshControl=$control+"MeshCtrl"+$y;
	if (!`objExists $meshControl`)
		break;
	}
createNode -n $meshControl mesh;
setAttr ($meshControl+".isHistoricallyInteresting") 0;
//$tempString=`polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0`;
$tempString=`listRelatives -p $meshControl`;
$generatedXform=$tempString[0];
parent -add -s $meshControl $control;
delete $generatedXform;

$tempString=`listRelatives -p $faces[0]`;
$sourceMesh=$tempString[0];
$tempString=`listRelatives -p $sourceMesh`;
$sourceXform=$tempString[0];

$transformGeometry=`createNode -n ($control+"MCTransformGeometry") transformGeometry`;
setAttr ($transformGeometry+".isHistoricallyInteresting") 0;
setAttr ($transformGeometry+".freezeNormals") 1;//make correct normals for right side faceCtrls
connectAttr ($control+".worldInverseMatrix[0]") ($transformGeometry+".transform");
connectAttr -f ($sourceMesh+".outMesh") ($transformGeometry+".inputGeometry");
connectAttr -f ($transformGeometry+".outputGeometry") ($meshControl+".inMesh");

//Shading
$tempString=`listConnections ($sourceMesh+".instObjGroups[0]")`;
if (`objExists $tempString[0]` && $tempString[0]!="")
//	sets -e -forceElement $tempString[0] $meshControl;
	catch (`eval ("sets -e -forceElement "+$tempString[0]+" "+$meshControl)`);

//ReAssign component Shading
$shadingEngines=`ls -type shadingEngine`;
for ($i=0;$i<size($shadingEngines);$i++)
	{
	hyperShade -o $shadingEngines[$i];
	$tempString=`ls -sl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString[$y] ($sourceXform+"[.]*")`)
			{
			select `substitute $sourceXform $tempString[$y] $meshControl`;
			sets -e -forceElement $shadingEngines[$i];
			}
		}
	}

select -cl;
for ($i=0;$i<size($faces);$i++)
	{
	tokenize $faces[$i] "." $tempString;
	select -add ($meshControl+"."+$tempString[1]);
	}
asInvertSelection;
int $allFacesSelected=0;
$tempString=`ls -sl`;
if ($tempString[0]=="")
	$allFacesSelected=1;
if ($allFacesSelected) select ($meshControl+".f[0]");
delete;
$tempString=`listConnections -s 1 -d 0 ($meshControl+".inMesh")`;
$deleteComponent=`rename $tempString[0] ($control+"MCDeleteComponent")`;
setAttr ($deleteComponent+".isHistoricallyInteresting") 0;
if ($allFacesSelected)
	setAttr ($deleteComponent+".nodeState") 1;

//Right side FaceMeshCtrls to be ReversedNormals
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $control`)
		if (`gmatch $control "*_R"`)
			{
			$tempString=`polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $meshControl`;
			$polyNormal=`rename $tempString[0] ($control+"MCDeleteComponent")`;
			setAttr ($polyNormal+".isHistoricallyInteresting") 0;
			}

if ($mirror && !`objExists controlMeshMirroring` && !`objExists controlMeshBatch` && `objExists $mirrorControl`)
	{
	createNode -n controlMeshMirroring transform;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($sourceMesh+".outMesh") closestSampler.inMesh;

	select $faces;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	select -cl;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr -type float3 closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		select -add ($sourceMesh+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");	
		}
	ConvertSelectionToContainedFaces;
	select -add $mirrorControl;
	asCreateControlMesh;
	delete controlMeshMirroring;
	}

//setAttr ($meshControl+".overrideEnabled") 1;
//setAttr ($meshControl+".overrideShading") 0;
setAttr ($meshControl+".castsShadows") 0;
setAttr ($meshControl+".receiveShadows") 0;
setAttr ($meshControl+".motionBlur") 0;
setAttr ($meshControl+".primaryVisibility") 0;
setAttr ($meshControl+".smoothShading") 0;
setAttr ($meshControl+".visibleInReflections") 0;
setAttr ($meshControl+".visibleInRefractions") 0;

connectAttr -f Main.ctrlMeshVis ($meshControl+".v");
$tempString=`listRelatives -s -type nurbsCurve $control`;
if ($tempString[0]!="")
	{
	$tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
	if ($tempString2[0]=="")
		if (!`getAttr -l ($tempString[0]+".v")`)
			connectAttr -f Main.ctrlCurveVis ($tempString[0]+".v");
	}

select -cl;
print ("// "+$meshControl+" created.\n");
}

global proc asCreateControlMeshes ()
{
global string $gSelect;
global string $gMainProgressBar;
int $numFaces,$isFaceCtrl;
int $runningSkinCutUp=`objExists CutUp` && `objExists CutUpGeometry`;
int $tempInts[];
string $joint,$skinCluster,$faceCtrlName;
string $tempString[],$infs[],$weightJoints[],$faceVtxs[],$historyNodes[],$infJoints[],$infJointCtrls[];
string $sel[]=`ls -sl`;
float $jointWeights[];
float $biggestJointWeight;
if ($sel[0]=="")
	error "Nothing selected";
if (`gmatch $sel[0] "*.*"`)
	error "Found components selected, Makes sure to select a object";

if (!`asConfirmIfNotInBuildPose`)
	return;

setToolTo $gSelect;
for ($a=0;$a<size($sel);$a++)
	{
	$historyNodes=`listHistory -pdo 1 -il 2 $sel[$a]`;
	for ($i=0;$i<size($historyNodes);$i++)
		if (`nodeType $historyNodes[$i]`=="skinCluster")
			$skinCluster=$historyNodes[$i];
	if ($skinCluster=="")
		error ("No SkinCluster found on object: \""+$sel[$a]+"\"");
	$infJoints=`listConnections ($skinCluster+".matrix")`;

	$tempInts=`polyEvaluate -f $sel[$a]`;
	$numFaces=$tempInts[0];
	clear $infs;
	if (`objExists controlMeshBatch`) delete controlMeshBatch;
	createNode -n controlMeshBatch transform;
	evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
	progressBar -e -st "working" -bp -ii 1 -min 0 -max $numFaces $gMainProgressBar;
	for ($y=0;$y<$numFaces;$y++)
		{
		progressBar -e -s 1 $gMainProgressBar;
		select -r ($sel[$a]+".f["+$y+"]");
		ConvertSelectionToVertices;
		$weightJoints=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster`;
		$faceVtxs=`ls -sl -fl`;
		for ($b=0;$b<size($faceVtxs);$b++)
			{
			select $faceVtxs[$b];
			for ($z=0;$z<size($weightJoints);$z++)
				{
				if ($z==0) clear $jointWeights;
				$jointWeights[$z]+=`skinPercent -ignoreBelow 0.001 -t $weightJoints[$z] -q -v $skinCluster`;
				}
			}

		$biggestJointWeight=0;
		for ($z=0;$z<size($weightJoints);$z++)
			{
			if ($jointWeights[$z]>$biggestJointWeight)
				{
				$biggestJointWeight=$jointWeights[$z];
				$infs[$y]=$weightJoints[$z];
				}
			}
		}
	select -cl;

	for ($i=0;$i<size($infJoints);$i++)
		{
		$faceCtrlName=`substitute "Joint" $infJoints[$i] ""`;
		if (`gmatch $infJoints[$i] "*LipJoint[0-9]*"` || `gmatch $infJoints[$i] "*Lid*[0-9]*"`)//Lip/Lid special case
			$faceCtrlName=`asLipLidJointNameToCtrlName $infJoints[$i]`;
		$isFaceCtrl=0;
		if (`objExists $faceCtrlName`)
			if (`objExists FaceControlSet`)
				if (`sets -im FaceControlSet $faceCtrlName`)
					$isFaceCtrl=1;
		if (`objExists ("FK"+$infJoints[$i])` && (!`gmatch $infJoints[$i] "*Part[0-9]*"` || $runningSkinCutUp )) 
			$infJointCtrls[$i]="FK"+$infJoints[$i];
		else if (`gmatch $infJoints[$i] "EyeJoint_*"` || `gmatch $infJoints[$i] "IrisJoint_*"` || `gmatch $infJoints[$i] "PupilJoint_*"`)
			$infJointCtrls[$i]=`substitute "Joint" $infJoints[$i] ""`;
		else if ($isFaceCtrl)
			{
			$infJointCtrls[$i]=$faceCtrlName;
			if ($runningSkinCutUp)
				$infJointCtrls[$i]="FKHead_M";
			}
		else
			{
			$joint=$infJoints[$i];
			for ($y=0;$y<99;$y++)
				{
				if (!`objExists $joint`)
					{
					print ("// Found no ctrl for:"+$infJoints[$i]+"\n");
					stringArrayRemove {$infJoints[$i]} $infJoints;
					break;
					}
				$tempString=`listRelatives -p $joint`;
				$joint=$tempString[0];
				if (`objExists ("FK"+$joint)` && !`gmatch $joint "*Part[0-9]*"`)
					{
					$infJointCtrls[$i]="FK"+$joint;
					$y=99;
					}
			if ($runningSkinCutUp && `gmatch $joint "*Part[0-9]*"`)
					{
					$infJointCtrls[$i]=$joint;
					$y=99;
					}
				}
			}
		//overrides
		if ($infJoints[$i]=="upperFaceJoint_M" || $infJoints[$i]=="middleFaceJoint_M" || $infJoints[$i]=="lowerFaceJoint_M")
			$infJointCtrls[$i]="FKHead_M";
		}
	string $infJointCtrls2[]=`stringArrayRemoveDuplicates $infJointCtrls`;
	for ($i=0;$i<size($infJointCtrls2);$i++)
		{
		select -cl;
		for ($q=0;$q<size($infJoints);$q++)
			{
			if ($infJointCtrls[$q]!=$infJointCtrls2[$i])
				continue;
			for ($y=0;$y<$numFaces;$y++)
				{
				if ($infs[$y]==$infJoints[$q])
					select -add ($sel[$a]+".f["+$y+"]");
				}
			}
		$tempString=`ls -sl`;
		if ($tempString[0]=="")
			continue;
		select -add $infJointCtrls2[$i];
		refresh;
		asCreateControlMesh;
		}
	}

if (`objExists controlMeshBatch`) delete controlMeshBatch;
}

global proc asColorizeControlMeshes ()
{
global string $gSelect;
global string $gMainProgressBar;
int $numParents,$numMeshes,$numVtx;
int $tempInts[];
float $charHeight=`asgetCharHeight`;
string $mesh,$multiMesh,$sg;
string $deformJoints[]=`listRelatives -type joint -ad DeformationSystem`;
string $deformJointsLong[]=`listRelatives -f -type joint -ad DeformationSystem`;
string $tempString[];

setToolTo $gSelect;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Colorizing" -bp -ii 1 -min 0 -max (size($deformJointsLong)) $gMainProgressBar;
asFitModeEnsureShaders;
for ($i=0;$i<size($deformJointsLong);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$mesh="FK"+$deformJoints[$i]+"MeshCtrl";
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$i]`)//faceJoint
			{
			$mesh=`substitute "Joint" $deformJoints[$i] ""`+"MeshCtrl";
			if (`gmatch $deformJoints[$i] "*LipJoint[0-9]*"` || `gmatch $deformJoints[$i] "*Lid*[0-9]*"`)//Lip/Lid special case
				$mesh=`asLipLidJointNameToCtrlName $deformJoints[$i]`+"MeshCtrl";
			}
	if (!`objExists $mesh`)
		continue;
	tokenize $deformJointsLong[$i] "|" $tempString;
	$numParents=0;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString[$y] "*Part[0-9]*"`)
			continue;
		if (`gmatch $tempString[$y] "Cup_*"`)
			continue;
		$numParents++;
		}

	if (!($numParents%3)) $sg="asRedSG";
	if (!(($numParents+1)%3)) $sg="asGreenSG";
	if (!(($numParents+2)%3)) $sg="asBlueSG";

	if (`gmatch $deformJoints[$i] "Head_*"`) $sg="asBlueSG";
	if (`gmatch $deformJoints[$i] "JawJoint_*"`) $sg="asGreenSG";
	if (`gmatch $deformJoints[$i] "FrownBulgeJoint_*"`) $sg="asBlue2SG";
	if (`gmatch $deformJoints[$i] "SmileBulgeJoint_*"`) $sg="asGreen2SG";
	if (`gmatch $deformJoints[$i] "CheekRaiserJoint_*"`) $sg="asRed2SG";
	if (`gmatch $deformJoints[$i] "EyeBrowCenterJoint_*"`) $sg="asBlue2SG";
	if (`gmatch $deformJoints[$i] "EyeBrowInnerJoint_*"`) $sg="asGreenSG";
	if (`gmatch $deformJoints[$i] "EyeBrowMid1Joint_*"`) $sg="asGreen2SG";
	if (`gmatch $deformJoints[$i] "EyeBrowMid2Joint_*"`) $sg="asRed2SG";
	if (`gmatch $deformJoints[$i] "EyeBrowMid3Joint_*"`) $sg="asBlue2SG";
	if (`gmatch $deformJoints[$i] "EyeBrowOuterJoint_*"`) $sg="asGreen2SG";
	if (`gmatch $deformJoints[$i] "NoseCornerJoint_*"`) $sg="asGreenSG";
	if (`gmatch $deformJoints[$i] "NostrilJoint_*"`) $sg="asRed2SG";
	if (`gmatch $deformJoints[$i] "NoseSideJoint_*"`) $sg="asBlue2SG";
	if (`gmatch $deformJoints[$i] "NoseBridgeJoint_*"`) $sg="asGreen2SG";
	if (`gmatch $deformJoints[$i] "NoseJoint_*"`) $sg="asRedSG";
	if (`gmatch $deformJoints[$i] "upperLidBaseJoint_*"`) $sg="asRed2SG";
	if (`gmatch $mesh "*LipA_*MeshCtrl*"`) $sg="asRedSG";
	if (`gmatch $mesh "*LipB_*MeshCtrl*"`) $sg="asRed2SG";
	if (`gmatch $mesh "*Lip_*MeshCtrl*"`) $sg="asRedSG";
	if (`gmatch $mesh "*Lip_MMeshCtrl*"`) $sg="asGreen2SG";

	if (`gmatch $mesh "*upperLid_*MeshCtrl*"` || `gmatch $mesh "*lowerLid_*MeshCtrl*"`) $sg="asGreen2SG";
	if (`gmatch $mesh "*OuterLid_*MeshCtrl*"` || `gmatch $mesh "*InnerLid_*MeshCtrl*"`) $sg="asRedSG";
	if (`gmatch $mesh "outerLid_*MeshCtrl*"` || `gmatch $mesh "innerLid_*MeshCtrl*"`) $sg="asRed2SG";

	if (`gmatch $mesh "*upperLidOuter_*MeshCtrl*"` || `gmatch $mesh "*lowerLidOuter_*MeshCtrl*"`) $sg="asGreenSG";
	if (`gmatch $mesh "*OuterLidOuter_*MeshCtrl*"` || `gmatch $mesh "*InnerLidOuter_*MeshCtrl*"`) $sg="asBlue2SG";
	if (`gmatch $mesh "outerLidOuter_*MeshCtrl*"` || `gmatch $mesh "innerLidOuter_*MeshCtrl*"`) $sg="asGreenSG";


	for ($y=0;$y<10;$y++)
		{
		$multiMesh=$mesh;
		if ($y>0)
			$multiMesh=$mesh+$y;
		if (!`objExists $multiMesh`)
			continue;
		sets -e -forceElement $sg $multiMesh;
		refresh;
		//`expand` mesh to avoid overlap-flickering
		if (!`attributeExists ControlMeshesExpanded $multiMesh`)
			{
			$tempInts=`polyEvaluate -v $multiMesh`;
			$numVtx=$tempInts[0];
			for ($z=0;$z<$numVtx;$z++)
				{
				select ($multiMesh+".vtx["+$z+"]");
				moveVertexAlongDirection -n ($charHeight/1000.0);
				}
			addAttr -k 0 -ln ControlMeshesExpanded -at bool -dv 1 $multiMesh;
			select -cl;
			refresh;
			}
		$numMeshes++;
		}
	}

print ("// "+$numMeshes+" Control Meshes Colorized and expanded.\n");
}

global proc asCreateIKControlMeshes ()
{
if (!`objExists ControlSet`)
	error "ControlSet not found";
int $form,$spans,$degrees,$numCv;
float $dist;
float $scale=`asGetScale`;
float $pos1[],$pos2[];
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[],$curveShapes[];
string $controlSetMembers[]=`sets -q ControlSet`;
string $meshCtrl;
asFitModeEnsureShaders;
if (`objExists tempTG`) delete tempTG;
createNode -n tempTG transformGeometry;
setAttr tempTG.invertTransform 1;
asEnsureMainCtrlVisAttrs;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (`gmatch $controlSetMembers[$i] "FK*"` && !`gmatch $controlSetMembers[$i] "FKIK*"`)
		continue;
	$curveShapes=`listRelatives -s -type nurbsCurve $controlSetMembers[$i]`;
	for ($y=0;$y<size($curveShapes);$y++)
		{
		$form=`getAttr ($curveShapes[$y]+".form")`;
		$spans=`getAttr ($curveShapes[$y]+".spans")`;
		$degrees=`getAttr ($curveShapes[$y]+".degree")`;
		if ($form==2)
			$numCv=$spans;
		else
			$numCv=$spans+$degrees;

		for ($z=0;$z<$numCv+1;$z++)
			{
			if ($form!=2 && $z==$numCv)
				continue;
			polyCube -n ("asTempPolyCube"+$z) -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
			move -r -os -wd 0.5 0 0 ("asTempPolyCube"+$z+".vtx[0:7]");
			$pos1=`xform -q -ws -t ($curveShapes[$y]+".cv["+$z+"]")`;
			$pos2=`xform -q -ws -t ($curveShapes[$y]+".cv["+($z+1)+"]")`;
			if ($z==$numCv)
				$pos2=`xform -q -ws -t ($curveShapes[$y]+".cv[0]")`;
			$dist=`mag<<$pos1[0]-$pos2[0],$pos1[1]-$pos2[1],$pos1[2]-$pos2[2]>>`;
			move -r $pos1[0] $pos1[1] $pos1[2] ("asTempPolyCube"+$z+".vtx[0:7]");
			createNode -n tempTransform transform;
			xform -ws -piv $pos1[0] $pos1[1] $pos1[2] ("asTempPolyCube"+$z);
			xform -ws -t $pos2[0] $pos2[1] $pos2[2] tempTransform;
			delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempTransform ("asTempPolyCube"+$z)`;
			delete tempTransform;
			scale -r -p $pos1[0] $pos1[1] $pos1[2] $dist ($scale/20.0) ($scale/20.0) ("asTempPolyCube"+$z+".vtx[0:7]");
			makeIdentity -a 1 -t 0 -r 1 -s 0 ("asTempPolyCube"+$z);
			}
		select -cl;
		for ($z=0;$z<$numCv+1;$z++)
			if (`objExists ("asTempPolyCube"+$z)`)
				select -add ("asTempPolyCube"+$z);
		polyUnite -ch 0 -mergeUVSets 1 -centerPivot -name asTempPolyCube;
		$tempString2[0]="asTempPolyCube";

		$tempString3=`listRelatives -s $tempString2[0]`;
		$tempString4[0]=`createNode mesh`;
		$tempString5=`listRelatives -p $tempString4[0]`;
		connectAttr -f ($tempString3[0]+".outMesh") tempTG.inputGeometry;
		if (!`isConnected ($controlSetMembers[$i]+".worldMatrix[0]") tempTG.transform`)
			connectAttr -f ($controlSetMembers[$i]+".worldMatrix[0]") tempTG.transform;
		connectAttr -f tempTG.outputGeometry ($tempString4[0]+".inMesh");
		for ($z=0;$z<99;$z++)
			{
			if ($z==0) $meshCtrl=$controlSetMembers[$i]+"MeshCtrl";
			else $meshCtrl=$controlSetMembers[$i]+"MeshCtrl"+$z;
			if (!`objExists $meshCtrl`)
				break;
			}
		rename $tempString4[0] $meshCtrl;
		parent -add -s $meshCtrl $controlSetMembers[$i];
		delete $tempString5[0];
		delete $tempString2[0];
		sets -e -forceElement initialShadingGroup $meshCtrl;

		setAttr ($meshCtrl+".castsShadows") 0;
		setAttr ($meshCtrl+".receiveShadows") 0;
		setAttr ($meshCtrl+".motionBlur") 0;
		setAttr ($meshCtrl+".primaryVisibility") 0;
		setAttr ($meshCtrl+".smoothShading") 0;
		setAttr ($meshCtrl+".visibleInReflections") 0;
		setAttr ($meshCtrl+".visibleInRefractions") 0;

		$overrideColor=`getAttr ($curveShapes[$y]+".overrideColor")`;
		if ($overrideColor==13) sets -e -forceElement asRedSG $meshCtrl;
		if ($overrideColor==15 || $overrideColor==6) sets -e -forceElement asBlueSG $meshCtrl;
		if ($overrideColor==14) sets -e -forceElement asGreenSG $meshCtrl;
		if ($overrideColor==17 || $overrideColor==22) sets -e -forceElement asGreen2SG $meshCtrl;

		//visibility
		$tempString=`listConnections -s 1 -d 0 -p 1 ($curveShapes[$y]+".v")`;

		connectAttr -f Main.ctrlCurveVis ($curveShapes[$y]+".v");
		connectAttr -f Main.ctrlMeshVis ($meshCtrl+".v");

		if ($tempString[0]!="")//Advanced vis for spine
			{
			if (`objExists ($meshCtrl+"CurveMPD")`) delete ($meshCtrl+"CurveMPD");
			if (`objExists ($meshCtrl+"MeshMPD")`)  delete ($meshCtrl+"MeshMPD");
			createNode -n ($meshCtrl+"CurveMPD") multiplyDivide;
			createNode -n ($meshCtrl+"MeshMPD")  multiplyDivide;
			connectAttr $tempString[0] ($meshCtrl+"CurveMPD.input1X");
			connectAttr $tempString[0] ($meshCtrl+"MeshMPD.input1X");
			connectAttr Main.ctrlCurveVis ($meshCtrl+"CurveMPD.input2X");
			connectAttr Main.ctrlMeshVis  ($meshCtrl+"MeshMPD.input2X");
			connectAttr -f ($meshCtrl+"CurveMPD.outputX") ($curveShapes[$y]+".v");
			connectAttr -f ($meshCtrl+"MeshMPD.outputX")  ($meshCtrl+".v");
			}
		}
	}
if (`objExists tempTG`) delete tempTG;
print ("// IK ControlMeshes created.\n");
}

global proc asEnsureMainCtrlVisAttrs ()
{
if (!`attributeExists ctrlCurveVis Main`)
	{
	addAttr -k 1 -ln ctrlCurveVis -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.ctrlCurveVis;
	}
if (!`attributeExists ctrlMeshVis Main`)
	{
	addAttr -k 1 -ln ctrlMeshVis -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.ctrlMeshVis;
	}
}

global proc asDeleteControlMesh ()
{
string $sel[]=`ls -sl`;
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -type mesh -s $sel[$i]`;
	if (size($tempString))
		delete $tempString;
	}
}

global proc asDeleteAllControlMesh ()
{
string $tempString[]=`ls "*MeshCtrl*" "FK*_*MCTransformGeometry*" "FK*_*MCDeleteComponent*"`;
if (size($tempString))
	delete $tempString;
}

global proc string asLipLidJointNameToCtrlName (string $infJoint)
{
int $numLetters=size($infJoint);
int $jointNr,$numLidLipJoints;
string $ctrlName,$lipLid,$letter,$InnerOuter;
string $upperLower=`substring $infJoint 1 5`;
//string $lipLid=`substring $infJoint 6 8`;
string $side=`substring $infJoint ($numLetters-1) $numLetters`;
float $fraction;
string $tempString[];

if (`gmatch $infJoint "*LipJoint*"`)
	{
	$lipLid="Lip";
	$jointNr=`substring $infJoint 14 ($numLetters-2)`;
	$tempString=`ls -type joint ($upperLower+"LipJoint*"+$side)`;
	}
if (`gmatch $infJoint "*LidMain*"`)
	{
	$lipLid="Lid";
	$jointNr=`substring $infJoint 13 ($numLetters-2)`;
	$tempString=`ls -type joint ($upperLower+"LidMain*"+$side)`;
	}
if (`gmatch $infJoint "*LidOuter*"`)
	{
	$lipLid="LidOuter";
	$jointNr=`substring $infJoint 14 ($numLetters-2)`;
	$tempString=`ls -type joint ($upperLower+"LidMain*"+$side)`;
	}
$numLidLipJoints=size($tempString);
$fraction=$jointNr/($numLidLipJoints+0.0);

if ($lipLid=="Lip")
	{
	if ($fraction<0.26)
		{
		$letter="";
		$side="_M";
		}
	if ($fraction>=0.26)
		$letter="A";
	if ($fraction>=0.75)
		$letter="B";
	if ($fraction>=1.0)
		$letter="";
//	print ($jointNr+" : "+$numLidLipJoints+" : "+$fraction+" : "+$letter+"\n");
	$ctrlName=$upperLower+$lipLid+$letter+$side;
	}
if ($lipLid=="Lid" || $lipLid=="LidOuter")
	{
	if ($fraction<0.2)
		{
		$InnerOuter="Inner";
		$upperLower="";
		}
	if ($fraction>=0.2 && $fraction<0.4)
		$InnerOuter="Inner";
	if ($fraction>=0.4 && $fraction<0.6)
		$InnerOuter="";
	if ($fraction>=0.6 && $fraction<0.8)
		$InnerOuter="Outer";
	if ($fraction>0.8)
		{
		$InnerOuter="Outer";
		$upperLower="";
		}
	if ($upperLower=="")
		$InnerOuter=`tolower $InnerOuter`;
//	print ($jointNr+" : "+$numLidLipJoints+" : "+$fraction+" : "+$InnerOuter+"\n");
	$ctrlName=$upperLower+$InnerOuter+$lipLid+$side;
	}

return $ctrlName;
}

global proc asSetBuildPose (string $uiName)
{
string $controlsSet="ControlSet";
string $fitSkeleton="FitSkeleton";
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	{
	$controlsSet="FaceControlSet";
	$fitSkeleton="FaceFitSkeleton";
	$buildPose="faceBuildPose";
	}
string $controlSetMembers[]=`sets -q $controlsSet`;
string $objAttr,$runCmd,$buildPoseCmd,$newRunCmds;
int $foundRunValue,$modifiedOldRunCmd,$udAttrInNewRunCmds;
float $poseValue,$currentValue,$runValue,$poseRunValue;
float $runValues[];
string $runCmds[],$tempString[],$tempString2[],$runObjAttrs[],$checkObjAttr[],$allCheckObjAttrs[];
if (`objExists $fitSkeleton`)
	if (`attributeExists run $fitSkeleton`)
		{
		$runCmd=`getAttr ($fitSkeleton+".run")`;
		$runCmd=`substituteAllString $runCmd "\"" ""`;
		}
if ($runCmd!="")
	tokenize $runCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	$runCmds[size($runCmds)]=$tempString[$i];
	$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
	$runValues[size($runValues)]=$tempString2[2];
	$allCheckObjAttrs[size($allCheckObjAttrs)]=$tempString2[1];
	}

$buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
if (`attributeExists udExtraAttr $buildPose`)
	$buildPoseCmd+=`getAttr ($buildPose+".udExtraAttr")`;

tokenize $buildPoseCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	int $loopTimes=0;
	if ($tempString2[0]=="setAttr")
		{
		$objAttr=$tempString2[1];
		$poseValue=$tempString2[2];
		$loopTimes=1;
		$checkObjAttr[0]=$objAttr;
		}
	else if ($tempString2[0]=="xform")
		{
		$loopTimes=9;//default 15=trs
		if (size($tempString2)==11) $loopTimes=6;//11=tr
		if (size($tempString2)==7) $loopTimes=3;//7=t
		$obj=$tempString2[size($tempString2)-1];
		$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
		$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
		$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
		$poseValue=0;
		}
	for ($z=0;$z<$loopTimes;$z++)
		{
		$allCheckObjAttrs[size($allCheckObjAttrs)]=$checkObjAttr[$z];
		$currentValue=`getAttr $checkObjAttr[$z]`;
		if($z>5) $poseValue=1;//scale
		//actual poseValue might come from the run attribute//
		$foundRunValue=0;
		for ($y=0;$y<size($runObjAttrs);$y++)
			if ($checkObjAttr[$z]==$runObjAttrs[$y])
				{
				$runValue=$runValues[$y];
				$foundRunValue=1;
				}
		if ($foundRunValue)
			$poseRunValue=$runValue;
		else
			$poseRunValue=$poseValue;

		if ($poseRunValue>($currentValue+0.001) || $poseRunValue<($currentValue-0.001))
			{
			if ($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$newRunCmds+="setAttr "+$checkObjAttr[$z]+" "+$currentValue+";";
			else
				;//Arrived here, if there was a previous value set, but now replaced by 0, thereby removing entry
			//Also remove this from old run cmd, to avoid double up
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					{
					$runCmd=`substitute ($runCmds[$y]+";") $runCmd ""`;
					$modifiedOldRunCmd=1;
					}
			}
		}
	}

//user custom added attributes
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -ud -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$udAttrInNewRunCmds=0;
		for ($z=0;$z<size($allCheckObjAttrs);$z++)
			if ($allCheckObjAttrs[$z]==$controlSetMembers[$i]+"."+$tempString[$y])
				{
				$udAttrInNewRunCmds=1;
				break;
				}
		if (!$udAttrInNewRunCmds)
			for ($z=0;$z<size($runObjAttrs);$z++)
				if (`gmatch ("*"+$controlSetMembers[$i]+"."+$tempString[$y]+"*") $runObjAttrs[$z]`)
					{
					$udAttrInNewRunCmds=1;
					break;
					}
		if (!$udAttrInNewRunCmds)
			$newRunCmds+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
		}
	}

if ($newRunCmds=="" && !$modifiedOldRunCmd)
	{
	print "// No changes to the build pose detected\n";
	return;
	}

string $m="Set the following as default values ?\n\n"+`substituteAllString $newRunCmds ";" "\n"`;
string $confirmResult=`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Ok")
	return;
if (!`attributeExists run $fitSkeleton`)
	addAttr -ln run -dt "string" $fitSkeleton;

setAttr -type "string" ($fitSkeleton+".run") ($runCmd+$newRunCmds);
}

global proc asfileBrowse (string $tool, string $action)
{
string $fc,$ft;
int $mode=0;
if ($action=="Open")
	{
	$fc="asOpen "+$tool;
	$ft="mel";
	}
if ($action=="SaveAs")
	{
	$fc="asSaveAs "+$tool;
	$ft="mel";
	$mode=1;
	}
if ($action=="Import")
	{
	$fc="as"+$tool+"BackgroundImport";
	$ft="*";
	}
if (`asMayaVersionAsFloat`>=2011)
	eval ($fc+" \""+`fileDialog -dm ("*."+$ft) -m $mode`+"\" "+"fileType");
else
	{
	if (`about -win`)
		fileBrowserDialog -m $mode -fc $fc -ft $ft -an $action;
	else
		fileBrowser $fc $action $ft $mode;
	}
}

global proc astoShelf (string $tool)
{
global string $gShelfTopLevel;
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
if ($projectName=="untitled")
	error "Can not put \"untitled\" on shelf, save your project first\n";

string $cmd="source \""+$projectPath+$projectName+".mel\";";
string $ext=".png";
$icon=$projectPath+$projectName+"/"+$projectName+"_background32"+$ext;
if (!`file -q -ex $icon`)
	$icon="absolute.png";
string $setParent=`setParent -q`;
if (`tabLayout -exists $gShelfTopLevel`)
	{
	string $currentShelf=`tabLayout -query -selectTab $gShelfTopLevel`;
	setParent $currentShelf;
	shelfButton -c $cmd -ann ($tool+":"+$projectName) -label ($tool+":"+$projectName) -i1 $icon
		-st`shelfLayout -query -style $currentShelf`
		-width `shelfLayout -query -cellWidth $currentShelf`
		-height `shelfLayout -query -cellHeight $currentShelf`;
	}
setParent $setParent;
}

global proc asSelectFromTextField (string $textField)
{
if (`textField -q -ex $textField`)
	evalEcho ("select "+`textField -q -tx $textField`);
}

global proc string asUniqueFile (string $file)
{
// Copies given file to a random named file, to avoid fileNode cache
string $buffer[];
int $numTok=`tokenize $file "/" $buffer`;
string $path="";
if (`gmatch $file "/*"`)
	$path="/";
for ($i=0;$i<($numTok-1);$i++)
	$path+=$buffer[$i]+"/";
$numTok=`tokenize $file "." $buffer`;
string $ext=$buffer[$numTok-1];
string $randNumber=`rand 42`;
string $uniqueFile=$path+"unique"+`substituteAllString $randNumber "." ""`+"."+$ext;
sysFile -cp $uniqueFile $file;
return $uniqueFile;
}

global proc string[] asGetControlSets ()
{
string $controlSets[];
string $sets[]=`ls -type objectSet`;
for ($i=0;$i<size($sets);$i++)
	{
	if (!`sets -q -r $sets[$i]` && !`sets -q -v $sets[$i]` && !`sets -q -eg $sets[$i]` && !`sets -q -fc $sets[$i]` && !`sets -q -ep $sets[$i]`)
		if (`gmatch $sets[$i] "*[c-C]ontrol[s-S]et*"`)
			$controlSets[size($controlSets)]=$sets[$i];
	}
return $controlSets;
}


//-- AS IO Procedures (for tools) Starts Here --//
global proc int asOpen (string $tool, string $fileName, string $fileType)
{
global int $asfileLoading;
string $sel[]=`ls -sl`;
select -cl;
string $projectName=`basename $fileName ".mel"`;
string $projectPath=`dirname $fileName`+"/";
string $asIconLocation=$projectPath+$projectName+"/";
int $anim;
string $bgExt=".tga";
if (`about -mac`)
	$bgExt=".iff";

//if ($tool=="Poser")
//	asPoserDesigner;

evalEcho ("source \""+$fileName+"\";\n"
	+"as"+$tool+$projectName);
window -e -i 1 ("as"+$tool+$projectName);

if ($tool=="Poser")
	{
	$asfileLoading=1;
	string $gridOrder[]=`gridLayout -q -go ("asPoser"+$projectName+"GridLayout")`;
	int $nc=`gridLayout -q -nc ("asPoser"+$projectName+"GridLayout")`;
	int $nr=`gridLayout -q -nr ("asPoser"+$projectName+"GridLayout")`;
	intField -e -v $nc asPoserNc;
	intField -e -v $nr asPoserNr;
	asPoserUpdateGrid;
	int $childNum,$lenght;
	string $uiName="asPoserDefault";
	string $loadData[];
	$loadData[0]=$uiName;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] ("asPoser"+$projectName+"ColumnLayout*")`)
			{
			$image=`iconTextButton -q -i ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$loadData[1]=$image;
//			$label=`iconTextButton -q -l ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$label=`text -q -l ("asPoser"+$projectName+"Text"+$childNum)`;
			$loadData[2]=$label;
			$cmd=`iconTextButton -q -c ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$cmd=`substitute ("asPoser"+$projectName)  ("\""+$cmd+"\"") $uiName`;
			$lenght=size($cmd);
			$loadData[3]=`substring $cmd 2 ($lenght-1)`;
			$loadData[4]=$childNum;
			$anim=0;
			if (!`gmatch $cmd "*asSetAttrs *"`)
				$anim=1;
			$loadData[5]=$anim;
			asNewPose $loadData $anim;
			}
		}
	evalDeferred ("deleteUI as"+$tool+$projectName);
	}
if ($tool=="Selector")
	{
	asSelectorDesigner;
	$asfileLoading=1;
	
	window -e -w `window -q -w ("asSelector"+$projectName)` -h `window -q -h ("asSelector"+$projectName)` asSelectorDefault;
	asSelectorBackgroundImport ($asIconLocation+$projectName+"_background"+$bgExt) "image";
	
	int $width,$height,$msg0AsInt,$msg1AsInt;
	string $iol;
	string $buffer[],$msgs[];
	//restore controlSets
	string $controlSetsText,$controlSets[];
	if (`text -q -ex ("asSelector"+$projectName+"ControlSetsText")`)
		{
		$controlSetsText=`text -q -l ("asSelector"+$projectName+"ControlSetsText")`;
		$controlSets=`stringToStringArray $controlSetsText " "`;
		if (`menuItem -q -ex ControlSet`)
			menuItem -e -cb 0 ControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if (`menuItem -q -ex $controlSets[$i]`)
				menuItem -e -cb 1 $controlSets[$i];
		}

	string $ctls[]=`formLayout -q -ca ("asSelector"+$projectName+"FormLayout")`;
	int $mirrorButtons=`optionVar -q asSelectorMirrorButtons`;
	optionVar -iv asSelectorMirrorButtons 0;
	for ($ctl in $ctls)
		if (`iconTextButton -q -ex $ctl` && !`gmatch $ctl "*BGPicture"`)
			{
			tokenize $ctl ":" $buffer;
			$msg0AsInt=$msgs[0]=$buffer[size($buffer)-2];
			$msg1AsInt=$msgs[1]=$buffer[size($buffer)-1];
			$width=`iconTextButton -q -w $ctl`;
			$height=`iconTextButton -q -h $ctl`;
			$iol=`iconTextButton -q -iol $ctl`;
			$cmd=`iconTextButton -q -c $ctl`;
			$cmd=`substitute ("\""+$projectName+"\"") (""+$cmd) "\"Default\""`;
			$buttonName=`substitute $projectName $ctl ""`;
			$ann=`iconTextButton -q -ann $ctl`;
			$msgs[2]=$iol;
			$msgs[3]=$cmd;
			$msgs[4]=$buttonName;
			$msgs[6]=$ann;
			renameUI $ctl ("deleteMeUI"+$ctl);
			asSelectorDpc "asSelectorBGImage"  "asSelectorBGImage" $msgs ($msg0AsInt+$width-4) ($msg1AsInt+$height-5) 2;
			}
	optionVar -iv asSelectorMirrorButtons $mirrorButtons;
	evalDeferred -lp asSelectorRefresh;
	}

//evalDeferred ("deleteUI as"+$tool+$projectName);
text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
$asfileLoading=0;
select $sel;

return 1;
}

global proc int asSaveAs (string $tool, string $fileName, string $fileType)
{
if ($fileName=="")
	return 0;
string $sel[]=`ls -sl`;
string $projectName;
string $buffer[];
int $numFileNameChar=size ($fileName);
tokenize $fileName "/" $buffer;
string $file=$buffer[size($buffer)-1];
int $numFileChar=size ($file);
tokenize $file "." $buffer;
$projectName=$buffer[0];
string $tempTrn=`createNode transform`;
$projectName=`createNode -p $tempTrn -n $projectName transform`;
delete $tempTrn;
tokenize $projectName "|" $buffer;
$projectName=$buffer[size($buffer)-1];
string $projectPath=`substring $fileName 1 ($numFileNameChar-$numFileChar)`;

string $previousProjectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $previousProjectName=`text -q -l ("as"+$tool+"ProjectName")`;

text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
asSave $tool;

select $sel;
return 1;
}

global proc asSave (string $tool)
{
if (`text -q -l ("as"+$tool+"ProjectName")`=="untitled")
	{
	asfileBrowse $tool "SaveAs";
	return;
	}
int $haveBG=1;
float $existingBgc[];
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
string $projectFile=$projectPath+$projectName+".mel";
string $installFile=$projectPath+$projectName+"/install.mel";
string $asIconLocation=$projectPath+$projectName+"/";
string $ext=".png";
string $bgExt=".png";
string $tmpDir=`asGetTempDirectory`;
string $tmpIconDir=$tmpDir+"AdvancedSkeleton/"+$tool+"/untitled/";
string $uiName="as"+$tool+$projectName;
string $bgc;
string $buffer[];
string $fDet="";
$fDet+="//This file has been generated by AdvancedSkeleton"+$tool+"//\n";
$fDet+="//Using AdvancedSkeleton Version: "+`asGetScriptVersion`+"//\n";
$fDet+="\n";
$fDet+="global proc "+$uiName+" ()\n";
$fDet+="{\n";
$fDet+="if (`window -q -ex "+$uiName+"`)\n";
//$fDet+="\tdeleteUI "+$uiName+";\n";
$fDet+="\t{\n";
$fDet+="\tasPopulateNameSpaceMenu "+$uiName+";\n";
$fDet+="\tasShowSelJob;\n";
$fDet+="\tasSelChange;\n";
$fDet+="\tshowWindow "+$uiName+";\n";
$fDet+="\treturn;\n";
$fDet+="\t}\n";
$fDet+="\n";
$fDet+="string $asSelectorScriptLocation=`asSelectorScriptLocation`;\n";
$fDet+="string $asIconLocation=$asSelectorScriptLocation+\""+$projectName+"/\";\n";
$fDet+="window -rtf 1 -mb 1 -t "+$projectName+" "+$uiName+";\n";
$fDet+="menu -l File;\n";
$fDet+="\tmenuItem -l \"Create Reference..\" -c \"asReferenceBrowser 0\";\n";
$fDet+="\tmenuItem -l \"Reference Editor\" -c \"asReferenceEditor\";\n";
$fDet+="\tmenuItem -d 1;\n";
$fDet+="\tmenuItem -l \"Export Fbx..\" -c \"asExportFbxBrowser "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";
$fDet+="menu -l Edit;\n";
$fDet+="\tmenuItem -l Refresh -c \"asPopulateNameSpaceMenu "+$uiName+"\";\n";
$fDet+="\tmenuItem -l Filter -c \"asFilterNameSpaceMenuUI "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";

if ($tool=="Selector")
	{
	if (!`file -q -ex ($asIconLocation+"/"+$projectName+"_background"+$bgExt)`)
		$haveBG=0;//No Backround

	$fDet+="menu -l Display;\n";
	$fDet+="\tmenuItem -l Controls -c asControlsVisibilityToggle;\n";
//	$fDet+="\tmenuItem -l \"Set HotKey\" -c asSetupControlVisibilityHotKeyDialog;\n";
//	$fDet+="\tmenuItem -l Joints -c \"asJointsVisibilityToggle "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l GimbalLock -c \"asVisualizeGimbalLock "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"FaceCtrls detach\" -c \"asFaceCtrlsDetach "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Pose -aob 1;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l Paste -c \"asPasteFromClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Reset -c \"asGoToBuildPose "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Mirror -c \"asMirror "+$uiName+"\";\n";
	$fDet+="\tmenuItem -optionBox 1 -c \"asMirrorOptions "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Anim;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -l Paste -c \"asPasteFromClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Clean -c \"asDeleteStaticChannels "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asAnimBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l SwitchFKIK -c asAutoSwitchFKIK;\n";
	$fDet+="\tmenuItem -l SwitchPivot -c asAutoSwitchPivot;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l QuickIK -c asQuickIK;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l TwistFlip -c \"asTwistFlipUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l MoCapMatcher -c \"asMoCapMatcherUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l MoCapLibrary -c \"asMoCapLibraryUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Connect ARKit\" -c \"asConnectARKitUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Connect MocapX\" -c \"asConnectMocapX "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"MetaHumanAnimator\" -c \"asMetaHumanAnimatorUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Auto lipsync\" -c \"asAutoLipSyncUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Audio2Face\" -c \"asAudio2FaceUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Deformable\" -c \"asDeformableUI "+$uiName+"\";\n";
//	$fDet+="\tmenuItem -l \"Squash\" -c \"asSquashUI "+$uiName+"\";\n";
	$fDet+="menu -l Dynamics;\n";
	$fDet+="\tmenuItem -l \"Add to selected (Standard)\" -c \"asDynAdd "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Add to selected (HairSystem)\" -c \"asDynAddHairSystem "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Remove from selected\" -c \"asDynRemove "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Set Initial State\" -c \"asDynSetInitialState "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Interactive Playback\" -c \"asDynSetInteractivePlayback "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asDynBake "+$uiName+"\";\n";
	$fDet+="menu -l Parent;\n";
	$fDet+="\tmenuItem -l \"Add parent constraint\" -c \"asParentAdd "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l \"Add parent constraint (Extra)\" -c \"asParentAdd "+$uiName+" 1\";\n";
	}
$fDet+="\n";

//controlsets
string $controlSetsText;
string $menuItems[];
if (`menu -q -ex ("as"+$tool+"ControlSetsMenu")`)
	{
	$menuItems=`menu -q -ia ("as"+$tool+"ControlSetsMenu")`;
	for ($i=0;$i<size($menuItems);$i++)
		if (`menuItem -q -cb $menuItems[$i]`)
			$controlSetsText+=`menuItem -q -l $menuItems[$i]`+" ";
	}

//remove old files & copy files from `untitled`
string $fileList[];
if (`file -q -ex ($projectPath+$projectName)`)
	{
	$fileList=`getFileList -fld ($projectPath+$projectName+"/")`;
	for ($file in $fileList)
		sysFile -del ($projectPath+$projectName+"/"+$file);
	}
else
	sysFile -md ($projectPath+$projectName);
$fileList=`getFileList -fld $tmpIconDir`;
for ($file in $fileList)
	if (!`gmatch $file "*.tif"`)
		sysFile -cp ($projectPath+$projectName+"/"+`substitute ("untitled_") $file ($projectName+"_")`) ($tmpIconDir+$file);

window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");

if ($tool=="Poser")
	{
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="optionMenu -cc \"asCharChange "+$uiName+"\" "+$uiName+"OptionMenu;\n";
	$fDet+="scrollLayout "+$uiName+"ScrollLayout;\n";
	int $cw=`gridLayout -q -cw asPoserDefaultGridLayout`;
	int $ch=`gridLayout -q -ch asPoserDefaultGridLayout`;
	int $nc=`intField -q -v asPoserNc`;
	int $nr=`intField -q -v asPoserNr`;
	$fDet+="gridLayout -cw "+$cw+" -ch "+$ch+" -nc "+$nc+" -nr "+$nr+" "+$uiName+"GridLayout;\n";


	$fDet+="formLayout -e\n";
	$fDet+="	-af "+$uiName+"OptionMenu \"top\" 0\n";
	$fDet+="	-ac "+$uiName+"ScrollLayout \"top\" 0 "+$uiName+"OptionMenu\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"bottom\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"left\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"right\" 0\n";
	$fDet+="	"+$uiName+"FormLayout;\n";
	$fDet+="\n";
	$fDet+="\n";

	string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
	int $childNum,$doConnectControl;
	string $cmd,$label,$ann,$animAnn;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] "asPoser*"`)
			{
			$iconTextButton=("asPoserDefaultIconTextButton"+$childNum);
			$floatSlider=("asPoserDefaultFloatSlider"+$childNum);
			$text=("asPoserDefaultText"+$childNum);
			$label=`text -q -l $text`;
			$doConnectControl=`floatSlider -q -m $floatSlider`;
			$ann=`floatSlider -q -ann $floatSlider`;
			$cmd=`iconTextButton -q -c $iconTextButton`;
			$cmd=`substitute  "asPoserDefault" $cmd $uiName`;
			$cmd=`substitute  "untitled_" $cmd ($projectName+"_")`;
			$cmd=`encodeString $cmd`;
			$existingBgc=`text -q -bgc $text`;
			$bgc="";
			if ($existingBgc[0]==1)
				$bgc=" -bgc 1 0 0";
			$fDet+="$cmd=\""+$cmd+"\";\n";
			$image=`iconTextButton -q -i $iconTextButton`;
			tokenize ("\""+$image+"\"") "/" $buffer;
			tokenize $buffer[size($buffer)-1] "." $buffer;
			$imageNr=`match "[0-9]+$" $buffer[0]`;
			$animAnn=`rowColumnLayout -q -ann ("asPoserDefaultRowColumnLayout"+$childNum)`;

			$fDet+="setParent "+$uiName+"GridLayout;\n";
			$fDet+="columnLayout "+$uiName+"ColumnLayout"+$childNum+";\n";
			$fDet+="rowColumnLayout -ann "+$animAnn+" -nc 2 -cw 1 100 -cw 2 15 "+$uiName+"RowColumnLayout"+$childNum+";\n";
			$fDet+="iconTextButton -w 100 -h 75 -i ($asIconLocation+\""+$projectName+"_"+$imageNr+$ext+"\") -c $cmd "+$uiName+"IconTextButton"+$childNum+";\n";
			float $min=`floatSlider -q -min $floatSlider`;
			float $max=`floatSlider -q -max $floatSlider`;
			$fDet+="floatSlider -ann \""+$ann+"\" -m "+$doConnectControl+" -min "+$min+" -max "+$max+" -w 10 -h 75 -hr 0 "+$uiName+"FloatSlider"+$childNum+";\n";
			$fDet+="text -h 15 -al \"center\" -fn \"smallBoldLabelFont\" -l \""+$label+"\""+$bgc+" "+$uiName+"Text"+$childNum+";\n";

			//place it
			$fDet+="gridLayout -e -pos "+$uiName+"ColumnLayout"+$childNum+" "+$childNum+" "+$uiName+"GridLayout;\n";

			//popups
			$fDet+="asPoserupdateGridBlock "+$uiName+" "+$childNum+";\n";

			$fDet+="\n";
			}
		}

	$fDet+="\n";
	$fDet+="asPopulateNameSpaceMenu as"+$tool+$projectName+";\n";
	$fDet+="asCharChange "+$uiName+";\n";
	$fDet+="evalDeferred \"showWindow;\";\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}
if ($tool=="Selector")
	{
	int $pictureWidth=`text -q -l asSelectorBackgroundWidth`;
	int $pictureHeight=`text -q -l asSelectorBackgroundHeight`;
	
	string $allCtls[]=`formLayout -q -ca asSelectorDefaultFormLayout`;
	string $ctlName[],$ctlType[],$ctlWidth[],$ctlHeight[],$ctlLeft[],$ctlTop[],$ctlImage[],$ctlCmd[],$ctlIol[],$ctlBGC[],$ctlAnn[];
	string $ctlKeyCmd[],$ctlLinearKeyCmd[];
	string $ctlAlignFK2IKCmd[],$ctlAlignIK2FKCmd[],$ctlSwitchFK2IKCmd[],$ctlSwitchIK2FKCmd[];
	string $buffer[],$tempString[],$menuItems[];
	int $numTok;
	string $shortImageFileName,$oldProjectName;
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$ctlName[$i]=`substitute "asSelector" $allCtls[$i] $uiName`;
		if (`image -q -ex $allCtls[$i]`)
			$ctlType[$i]="image";
		if (`iconTextButton -q -ex $allCtls[$i]`)
			$ctlType[$i]="iconTextButton";
		$ctlWidth[$i]=`control -q -w $allCtls[$i]`;
		$ctlHeight[$i]=`control -q -h $allCtls[$i]`;
		$numTok=`tokenize $allCtls[$i] ":" $buffer`;
		$ctlLeft[$i]=$buffer[$numTok-2];
		$ctlTop[$i]=$buffer[$numTok-1];
		if ($ctlType[$i]=="iconTextButton")
			{
			$ctlImage[$i]=`eval ($ctlType[$i]+" -q -i \""+$allCtls[$i]+"\"")`;
			tokenize $ctlImage[$i] "/" $buffer;
			$shortImageFileName=$buffer[size($buffer)-1];
			tokenize $shortImageFileName "_" $buffer;
			$oldProjectName=$buffer[0];
			for ($b=1;$b<size($buffer)-3;$b++)
				$oldProjectName+="_"+$buffer[$b];
			$ctlImage[$i]=`substitute ($oldProjectName+"_") $shortImageFileName ($projectName+"_")`;
			$ctlCmd[$i]=`eval ($ctlType[$i]+" -q -c \""+$allCtls[$i]+"\"")`;
			$ctlCmd[$i]=`substitute "\"Default\"" $ctlCmd[$i] ("\""+$projectName+"\"")`;
			$ctlCmd[$i]="\""+`encodeString $ctlCmd[$i]`+"\"";
			$existingBgc=`eval ($ctlType[$i]+" -q -bgc \""+$allCtls[$i]+"\"")`;
			$existingBgc[0]=`asRoundOff $existingBgc[0] 3`;
			$existingBgc[1]=`asRoundOff $existingBgc[1] 3`;
			$existingBgc[2]=`asRoundOff $existingBgc[2] 3`;
			if (($existingBgc[0]+$existingBgc[1]+$existingBgc[2])>0.0)
				$ctlBGC[$i]=$existingBgc[0]+" "+$existingBgc[1]+" "+$existingBgc[2];
			$ctlAnn[$i]=`eval ($ctlType[$i]+" -q -ann \""+$allCtls[$i]+"\"")`;
			$ctlIol[$i]=`eval ($ctlType[$i]+" -q -iol \""+$allCtls[$i]+"\"")`;
			$tempString=`eval ($ctlType[$i]+" -q -pma \""+$allCtls[$i]+"\"")`;
			$menuItems=`popupMenu -q -ia $tempString[0]`;
			$ctlKeyCmd[$i]=`menuItem -q -c $menuItems[0]`;
			$ctlKeyCmd[$i]=`substitute "\"Default\"" $ctlKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlKeyCmd[$i]="\""+`encodeString $ctlKeyCmd[$i]`+"\"";
			$ctlLinearKeyCmd[$i]=`menuItem -q -c $menuItems[1]`;
			$ctlLinearKeyCmd[$i]=`substitute "\"Default\"" $ctlLinearKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlLinearKeyCmd[$i]="\""+`encodeString $ctlLinearKeyCmd[$i]`+"\"";
			if (size($menuItems)>6)
				{
				$subMenuItems=`menu -q -ia $menuItems[5]`;
				$ctlAlignFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlAlignFK2IKCmd[$i]=`substitute "\"Default\"" $ctlAlignFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignFK2IKCmd[$i]="\""+`encodeString $ctlAlignFK2IKCmd[$i]`+"\"";
				$ctlAlignIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlAlignIK2FKCmd[$i]=`substitute "\"Default\"" $ctlAlignIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignIK2FKCmd[$i]="\""+`encodeString $ctlAlignIK2FKCmd[$i]`+"\"";
				$subMenuItems=`menu -q -ia $menuItems[6]`;
				$ctlSwitchFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlSwitchFK2IKCmd[$i]=`substitute "\"Default\"" $ctlSwitchFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchFK2IKCmd[$i]="\""+`encodeString $ctlSwitchFK2IKCmd[$i]`+"\"";
				$ctlSwitchIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlSwitchIK2FKCmd[$i]=`substitute "\"Default\"" $ctlSwitchIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchIK2FKCmd[$i]="\""+`encodeString $ctlSwitchIK2FKCmd[$i]`+"\"";
				}
			}
		}

	$fDet+="columnLayout -adj 1;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="rowLayout -nc 5 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 65 -cw 4 50 -cw 5 60;\n";
	$fDet+="optionMenu -cc asSelChange "+$uiName+"OptionMenu;\n";
	$fDet+="button -l set -c \"asSetNameSpaceFromSelection "+$uiName+"\";\n";
	$fDet+="checkBox -v `optionVar -q asShowSelection` -cc \"optionVar -iv asShowSelection #1;asSelChangeToggle;\" -l Selection "+$uiName+"SelectionCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowKeyed` -cc \"optionVar -iv asShowKeyed #1;asSelChangeToggle;\" -l Keyed "+$uiName+"KeyedCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowExtra` -cc \"optionVar -iv asShowExtra #1;asSelChangeToggle;\" -l Extra "+$uiName+"ExtraCheckBox;\n";
	$fDet+="setParent..;\n";
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="\n";

	$fDet+="//Controls Begin//\n";
	if (!$haveBG)
		$fDet+="//";//No Backround
	if (`about -mac` || `about -linux`)
		$fDet+="iconTextButton -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	else
		$fDet+="image -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+=$ctlType[$i]+" -w "+$ctlWidth[$i]+" -h "+$ctlHeight[$i];
		if (!$haveBG && $ctlIol[$i]!="")// !$haveBG spesific flagging
			$fDet+=" -style textOnly -l "+$ctlIol[$i];//textOnly style for text to show on button with no icon
		if (!$haveBG)// !$haveBG spesific flagging
			$fDet+=" -olc "+$ctlBGC[$i];//-overlayLabelColor stores another `copy` of color, for `selection-coloring` revert
		if ($ctlImage[$i]!="")
			$fDet+=" -i ($asIconLocation+\""+$ctlImage[$i]+"\")";
		if ($ctlImage[$i]!="")
			$fDet+=" -iol \""+$ctlIol[$i]+"\"";
		if ($ctlCmd[$i]!="")
			$fDet+=" -c "+$ctlCmd[$i];
		if ($ctlBGC[$i]!="")
			$fDet+=" -bgc "+$ctlBGC[$i];
		if ($ctlAnn[$i]!="")
			$fDet+=" -ann \""+$ctlAnn[$i]+"\"";
		$fDet+=" \""+$ctlName[$i]+"\";\n";
		$fDet+="popupMenu;\n";
		$fDet+="\tmenuItem -l Key -c "+$ctlKeyCmd[$i]+";\n";
		$fDet+="\tmenuItem -l LinearKey -c "+$ctlLinearKeyCmd[$i]+";\n";
		if ($ctlAlignFK2IKCmd[$i]!="")
			{
			$fDet+="\tmenuItem -d 1;\n";
			$fDet+="\tmenuItem -l Align -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlAlignFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlAlignIK2FKCmd[$i]+";\n";
			$fDet+="\t\tsetParent -menu ..;\n";
			$fDet+="\tmenuItem -l Switch -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlSwitchFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlSwitchIK2FKCmd[$i]+";\n";
			}
		}
	$fDet+="//Controls End//\n";
	$fDet+="\n";
	$fDet+="formLayout -e\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+="\t-af \""+$ctlName[$i]+"\" left "+$ctlLeft[$i]+"\n";
		$fDet+="\t-af \""+$ctlName[$i]+"\" top "+$ctlTop[$i]+"\n";
		}
	$fDet+="\t"+$uiName+"FormLayout;\n";
	
	$fDet+="\n\n\n\n";
	
	$fDet+="asPopulateNameSpaceMenu \"asSelector"+$projectName+"\";\n";
	$fDet+="asShowSelJob;\n";
	$fDet+="asSelChange;\n";
	$fDet+="showWindow;\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}

string $AdvancedSkeletonFile=`asGetScriptLocation`+"/AdvancedSkeleton.mel";
int $fileId2=`fopen $AdvancedSkeletonFile "r"`;
string $nextLine = `fgetline $fileId2`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	if (`gmatch $nextLine "*[*][*][*][*][*][*]*"`)// ******ext files only
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId2;

int $fileId=`fopen $projectFile "w"`;
fprint $fileId $fDet;
fclose $fileId;

//$installFile
$fDet="";
string $AdvancedSkeletonInstallFile=`asGetScriptLocation`+"/install.mel";
if (!`file -q -ex $AdvancedSkeletonInstallFile`)
	return;
$fileId=`fopen $AdvancedSkeletonInstallFile "r"`;
$nextLine = `fgetline $fileId`;
int $installTemplatePause;
while ( size( $nextLine ) > 0 )
	{
	$nextLine = `fgetline $fileId`;
	if ($nextLine=="//--installTemplate pause--//\n")
		$installTemplatePause=1;
	if ($nextLine=="//--installTemplate resume--//\n")
		{
		$installTemplatePause=0;
		continue;
		}
	if ($installTemplatePause)
		continue;
	if (`gmatch $nextLine "string $scriptName=*"`)
		{
		$fDet+=("string $scriptName=\""+$projectName+"\";\n");
		}
	else if (`gmatch $nextLine "string $sourceFile=*"`)
		{
		$fDet+=("string $sourceFile=$asInstallScriptLocation+\"../\"+$scriptName+\".mel\";\n");
		}
	else if (`gmatch $nextLine "string $icon=*"`)
		{
		$fDet+=("string $icon=$asInstallScriptLocation+\""+$projectName+"_background32.png\";\n");
		}
	else if (`gmatch $nextLine "string $command=*"`)
		{
		$fDet+=("string $command=\"source \\\"\"+$sourceFile+\"\\\"\";\n");
		}
	else
		$fDet+=$nextLine;
	}
fclose $fileId;

$fileId=`fopen $installFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
}
//-- AS IO Procedures (for tools) Ends Here --//


//-- ASTools Procedures Starts Here --//
global proc string asGetASToolsProceduresVersionAsString ()
{
string $asToolsProceduresVersion="x.xxx";
return $asToolsProceduresVersion;
}

global proc asSelChange ()
{
global int $asfileLoading;
global int $asSelChangeSwitching;
if ($asfileLoading)
	return;
if (!`optionVar -q asShowSelection` && !`optionVar -q asShowKeyed` && !$asSelChangeSwitching)
	return;
int $undoState=`undoInfo -q -state`;
float $bgc[];
float $selectedBGC[]={0.263,1.0,0.639};
string $sel[]=`ls -sl`;
string $name,$obj,$nodeType,$projectName,$ann;
string $ctls[],$buffer[],$connections[];
int $numLetters,$numTok,$keyed;
string $ext=".png";
string $currImage,$buttonImageFile,$buttonImageFileOnK0,$buttonImageFileOnK1,$buttonImageFileOffK0,$buttonImageFileOffK1;
string $windows[]=`lsUI -windows`;
string $layout;

for ($window in $windows)
	{
	$layout="";
	if (size($window)>11)
		$layout="asSelector"+`substring $window 11 999`+"FormLayout";
	if (!`formLayout -q -ex $layout`)
		continue;
	$numLetters=size($layout);
	$name=`substring $layout 11 ($numLetters-10)`;
	$ctls=`formLayout -q -ca $layout`;
	for ($ctl in $ctls)
		{
		if (!`iconTextButton -q -ex $ctl`)
			continue;
		if (`optionVar -q asShowSelection` && !$asSelChangeSwitching)
			$selState="On";
		else
			$selState="Off";
		$keyed=0;
		$ann=`iconTextButton -q -ann $ctl`;
		$numTok=`tokenize $ann ";" $buffer`;
		for ($i=0;$i<$numTok;$i++)
			{
			$obj=`asSelectorResolveNameSpace $name $buffer[$i]`;
			if (!`stringArrayCount $obj $sel`)
				$selState="Off";
			if (`optionVar -q asShowKeyed` && `objExists $obj`)// && !$asSelChangeSwitching
				{
				$connections=`listConnections -s 1 -d 0 $obj`;
				for ($node in $connections)
					{
					$nodeType=`objectType $node`;
					if (`gmatch $nodeType "animCurve*"`)
						$keyed=1;
					}
				}
			}
		if (`gmatch $ann "*AllSet"`)
			{$selState="Off";$keyed=0;}

		$currImage=`iconTextButton -q -i1 $ctl`;
		if ($currImage=="") //!$haveBG
			{
			if ($selState=="On")
				$bgc=$selectedBGC;
			else
				$bgc=`iconTextButton -q -olc $ctl`;//-overlayLabelColor
			if ($keyed)
				$bgc={1,0,0};
			if ($keyed && $selState=="On")
				$bgc={1.0,0.5,0.5};
			iconTextButton -e -bgc $bgc[0] $bgc[1] $bgc[2] $ctl;
			continue;
			}

		$numTok=`tokenize $currImage "_" $buffer`;
		if ($numTok<3)
			continue;
		$projectName=$buffer[0];
		for ($b=1;$b<size($buffer)-3;$b++)
			$projectName+="_"+$buffer[$b];
		$buttonImageFile=$projectName+"_"+$buffer[$numTok-3]+"_"+$buffer[$numTok-2]+"_"+$selState+"K"+$keyed+$ext;

		if ($buttonImageFile!=$currImage)
			iconTextButton -e -i $buttonImageFile $ctl;
		}
	}

//PickerSelChange
if (!`optionMenu -q -ex asPickerOptionMenu`)
	return;
int $selectedTabIndex,$overrideColor;
string $picCtrls[],$selPicCtrls[],$selChrCtrls[],$tabLabels[];
string $picNs,$chrNs,$picCtrl,$chrCtrl;

if (`optionMenu -q -ex asPickerOptionMenu`)
	$chrNs=`optionMenu -q -v asPickerOptionMenu`;
if ($chrNs==":")
	$chrNs="";
if (`tabLayout -q -ex asPickerTabLayout`)
	{
	$tabLabels=`tabLayout -q -tl asPickerTabLayout`;
	$selectedTabIndex=`tabLayout -q -selectTabIndex asPickerTabLayout`;
	$picNs="picker_"+$tabLabels[$selectedTabIndex-1]+":";
	if (`text -q -ex ("asPickerEmbeddedPickerNameSpace"+$selectedTabIndex)`)
		if (`text -q -l ("asPickerEmbeddedPickerNameSpace"+$selectedTabIndex)`!="")
			$picNs=`text -q -l ("asPickerEmbeddedPickerNameSpace"+$selectedTabIndex)`+":";
	}
$picCtrls=`ls -type transform ($picNs+"*")`;
$selPicCtrls=`ls -sl -type transform ($picNs+"*")`;
$selChrCtrls=`ls -sl -type transform ($chrNs+"*")`;

//All .overrideColor==0 off first
if ($undoState) undoInfo -stateWithoutFlush 0;

//set keyed color
for ($i=0;$i<size($picCtrls);$i++)
	{
	$overrideColor=0;
	$chrCtrl=`substitute $picNs $picCtrls[$i] $chrNs`;
	if (`optionVar -q asShowExtra`) $chrCtrl=`substitute "FK" $chrCtrl "FKExtra"`;
	if (`objExists $chrCtrl`)
		if (`optionVar -q asShowKeyed` && `asHaveAnimation $chrCtrl`)
			$overrideColor=13;
	setAttr ($picCtrls[$i]+".overrideColor") $overrideColor;
	}

if (!size($selPicCtrls) && !size($selChrCtrls))
	{
	if ($undoState) undoInfo -stateWithoutFlush 1;
	return;
	}

//set selected color
for ($i=0;$i<size($sel);$i++)
	{
	if (`optionVar -q asShowSelection`)
		$overrideColor=14;
	if (`gmatch $sel[$i] ($picNs+"*")`) // $picNs > $chrNs
		{
		$chrCtrl=`substitute $picNs $sel[$i] $chrNs`;
		if (`optionVar -q asShowExtra`) $chrCtrl=`substitute "FK" $chrCtrl "FKExtra"`;
		if (`objExists $chrCtrl` && `optionVar -q asShowSelection`)
			{
			select -d $sel[$i];
			select -tgl $chrCtrl;
			if (`stringArrayCount $chrCtrl $sel`)//deselected
				{
				$overrideColor=0;
				if (`optionVar -q asShowKeyed` && `asHaveAnimation $chrCtrl`)
					$overrideColor=13;
				}
			setAttr ($sel[$i]+".overrideColor") $overrideColor;
			}
		else
			print ("// "+$chrCtrl+" not found.\n");
		}
	if (`gmatch $sel[$i] ($chrNs+"*")`) // $chrNs > $picNs
		{
		if ($chrNs=="")
			$picCtrl=$picNs+$sel[$i];
		else
			$picCtrl=`substitute $chrNs $sel[$i] $picNs`;
		if (`optionVar -q asShowExtra`)
			{
			if (!`gmatch $picCtrl "*Extra*"`) continue;
			$picCtrl=`substitute "FKExtra" $picCtrl "FK"`;
			}
		if (`objExists $picCtrl`)
			setAttr ($picCtrl+".overrideColor") $overrideColor;
		}
	}
if ($undoState) undoInfo -stateWithoutFlush 1;
}

global proc float asGetScale ()
{
float $scale=1;
if (!`objExists FitSkeleton`)
	return $scale;
float $maxY;
float $pos[];
$tempString=`listRelatives -f -ad -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[1]>$maxY)
		$maxY=$pos[1];
	}
if ($maxY>0)
	$scale=$maxY/17.176163;
if ($scale<0.01)
	$scale=0.01;
return $scale;
}

global proc asAlign (string $object, string $alignToObject, int $translate, int $rotate, int $jointOrient, int $rotateOrder)
{
string $parents[]=`listRelatives -p $object`;
string $orientConstraint[];
float $rotation[];

parent $object $alignToObject;
//Might have generated a Xform
string $generatedXform;
string $tempString[]=`listRelatives -p $object`;
if ($tempString[0]!=$alignToObject)
	$generatedXform=$tempString[0];
if ($translate)
	{
	xform -os -t 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -t 0 0 0 $generatedXform;
	}
if ($rotateOrder)
	setAttr ($object+".rotateOrder") `getAttr ($alignToObject+".rotateOrder")`;
if ($rotate)
	{
	xform -os -ro 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -ro 0 0 0 $generatedXform;
	}
if ($jointOrient && $rotate)
	setAttr -type float3 ($object+".jointOrient") 0 0 0;
	
if (`objExists $parents[0]`)
	parent $object $parents[0];
else
	parent -w $object;

if ($jointOrient && !$rotate)
	{
	if (`getAttr ($alignToObject+".rotateOrder")`!=0)
		warning "Aligning jointOrient for objects without aligning rotation, and non-default rotationOrder, may cause problems.";
	$orientConstraint=`orientConstraint $alignToObject $object`;
	$rotation=`xform -q -os -ro $object`;
	delete $orientConstraint[0];
	setAttr -type float3 ($object+".jointOrient") $rotation[0] $rotation[1] $rotation[2];
	setAttr -type float3 ($object+".rotate") 0 0 0;
	}
}

global proc float asRoundOff (float $value, int $decimals)
{
float $rounded;
if ($value>=0) $rounded=(trunc($value*`pow 10 $decimals`+0.5)/`pow 10 $decimals`);
else $rounded=(trunc(abs($value)*`pow 10 $decimals`+0.5)/`pow 10 $decimals`)*-1;
return $rounded;
}

global proc asFL ()
{
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		optionVar -iv $framLayouts[$i] `frameLayout -q -cl $framLayouts[$i]`;
}

global proc asLockAttr (string $object, int $trans, int $rot, int $scale, int $vis)
{
string $XYZ[]={"X","Y","Z"};

for ($z=0;$z<size($XYZ);$z++)
	{
	setAttr -l $trans -k (!$trans) ($object+".translate"+$XYZ[$z]);
	setAttr -l $rot -k (!$rot) ($object+".rotate"+$XYZ[$z]);
	setAttr -l $scale -k (!$scale) ($object+".scale"+$XYZ[$z]);
	}
setAttr -l $vis -k (!$vis) ($object+".v");

//in case of UnLock, also unlock the double3 type attrs, as these can have been locked by user
if (!$trans) setAttr -l $trans -k 0 ($object+".translate");
if (!$rot)   setAttr -l $rot   -k 0 ($object+".rotate");
if (!$scale) setAttr -l $scale -k 0 ($object+".scale");
}

global proc float asMayaVersionAsFloat ()
{
float $version=2012;
if (`about -v`=="2016 Extension 2")
	return 2016.5;
if (`exists getApplicationVersionAsFloat`)
	return `getApplicationVersionAsFloat`;
string $versionString=`about -v`;
string $tempString[];
string $char;
tokenize $versionString $tempString;
//default to 2012, if versionString is not all numbers
for ($i=0;$i<size($tempString[0]);$i++)
	{
	$char=`substring $tempString[0] ($i+1) ($i+1)`;
	if (!`gmatch $char "[0-9]"`)
		return 2012;
	}
$version=$tempString[0];
return $version;
}

global proc asSelChangeToggle ()
{
global int $asSelChangeSwitching;
$asSelChangeSwitching=1;
string $sel[]=`ls -sl`;
select -cl;
asSelChange;
$asSelChangeSwitching=0;
select $sel;
}

global proc asCharChange (string $uiName)
{
string $gridOrder[];
if (`gridLayout -q -ex ($uiName+"GridLayout")`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`floatSlider -q -ex ($uiName+"FloatSlider"+$i)`)
			{
			$ann=`floatSlider -q -ann ($uiName+"FloatSlider"+$i)`;
			$resolvedName=`asPoserResolveNameSpace $uiName $ann`;
			if (`objExists $resolvedName`)
				connectControl ($uiName+"FloatSlider"+$i) $resolvedName;
			}
	}
asSelChange;
}

global proc asShowSelJob ()
{
global int $asSelChangeScripJobNr;
if ($asSelChangeScripJobNr)
	return;
$asSelChangeScripJobNr=`scriptJob -e "SelectionChanged" "asSelChange"`;
}

global proc string asSelectorResolveNameSpace (string $name, string $obj)
{
string $nameSpace;
string $tempString[];
if (`optionMenu -q -ex ("asSelector"+$name+"OptionMenu")`)
	$nameSpace=`optionMenu -q -v ("asSelector"+$name+"OptionMenu")`;
else if (`optionMenu -q -ex ("asPickerOptionMenu")`)
	$nameSpace=`optionMenu -q -v ("asPickerOptionMenu")`;
else if (`gmatch $name "*:*"`)
	{
	tokenize $name ":" $tempString;
	for ($i=0;$i<size($tempString)-1;$i++)
		$nameSpace+=$tempString[$i]+":";
	}
if ($nameSpace==":")
	$nameSpace="";
string $extraObj;
//Extra control
if (`checkBox -q -ex ("asSelector"+$name+"ExtraCheckBox")`)
	if (`checkBox -q -v ("asSelector"+$name+"ExtraCheckBox")`)
		if (size($obj)>2)
			{
			$extraObj=`substring $obj 1 2`+"Extra"+`substring $obj 3 99`;
			if (`gmatch $obj "*RootX*"`)
				$extraObj=`substring $obj 1 4`+"Extra"+`substring $obj 5 99`;
			if (`objExists ($nameSpace+$extraObj)`)
				return ($nameSpace+$extraObj);
			}
return ($nameSpace+$obj);
}

global proc asSelect (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

int $modifier=`getModifiers`;
if (($modifier %  2)==0)
	select -cl;
if ($objs[0]=="")
	{
	select -cl;
	return;
	}
for ($obj in $objs)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
for ($obj in $objs)
	select -tgl $obj;
//enable hotKeys
string $formLayout="asSelector"+$name+"FormLayout";
if (`formLayout -q -ex $formLayout`)
	setFocus $formLayout;
}

global proc asKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe $obj;
select `ls -sl`;
asSelChange;
}

global proc asLinearKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe -itt linear -ott linear $obj;
select `ls -sl`;
asSelChange;
}

global proc asAlignIK2FK (string $nameSpace, string $objs[])
{
//asAssembleAlignSwitchCmd $nameSpace $objs "asAlignFKIK" "IK2FK";
asAssembleAlignSwitchCmd $nameSpace $objs "asAlignFKIK" "FK2IK";
}

global proc asAlignFK2IK (string $nameSpace, string $objs[])
{
//asAssembleAlignSwitchCmd $nameSpace $objs "asAlignFKIK" "FK2IK";
asAssembleAlignSwitchCmd $nameSpace $objs "asAlignFKIK" "IK2FK";
}

global proc asSwitchIK2FK (string $nameSpace, string $objs[])
{
asAssembleAlignSwitchCmd $nameSpace $objs "asSwitchFKIK" "IK2FK";
}

global proc asSwitchFK2IK (string $nameSpace, string $objs[])
{
asAssembleAlignSwitchCmd $nameSpace $objs "asSwitchFKIK" "FK2IK";
}

global proc asAssembleAlignSwitchCmd (string $nameSpace, string $objs[], string $alignSwitchCmd, string $W2K)
{
global int $asBakeFKIK;
$asBakeFKIK=0;
int $numLetters=size($objs[0]);
string $IK=`substring $objs[0] 5 ($numLetters-2)`;
string $side=`substring $objs[0] ($numLetters-1) $numLetters`;
eval ($alignSwitchCmd+" \""+$nameSpace+"\" "+$IK+" "+$side+" "+$W2K);
}

global proc asAlignFKIK (string $name, string $IK, string $side, string $W2K)
{
global int $asBakeFKIK;
int $isSplineIK,$numIkCtrls,$cvNr,$ikNr,$bakingMoCap,$opm,$c,$ikCtrlNr,$y;
float $IKCurveLenght,$stiff,$middleJointLenght,$endJointLenght,$joFac,$maxJo,$shiftDist,$samplerDist,$value,$version,$u;
float $shiftPolarity=1;
float $b=1;
if ($side=="_L") $b=-1;
float $pos[],$rot[],$posA[],$posB[],$tempFloat[],$alignIkToFloat[],$jo[],$w[],$aimVector[],$upVector[];
string $sel[]=`ls -sl`;
string $nameSpace=`asNameSpaceFromShortUIName $name`;
if (!`objExists ($nameSpace+"Pole"+$IK+$side)`)
	$isSplineIK=1;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $startMiddleEnd[]={$startJoint,$middleJoint,$endJoint};
string $toesJoint=`asGetToesJoint $nameSpace $endJoint $side`;
string $qToesJoints[]=`asGetQToesJoints $nameSpace $endJoint $side`;
string $curveCmd,$roo,$childLabel,$target,$sideLess,$partJoint,$rollCtrlToAim,$ikHandleWithLocalOrient,$aimAtTarget;
string $priAxis="X";
string $secAxis="Y";
string $terAxis="Z";
string $shiftAxis="Y";
string $tempLoc1[],$tempLoc2[],$tempConstraint[],$tempConstraintAttrs[],$chainJoints[],$tempString[],$tempLocShift1[],$tempLocShift2[];
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};

//compatability pre check
if (`attributeExists version ($nameSpace+"Main")`)
	{
	$version=`getAttr ($nameSpace+"Main.version")`;
	if ($version>6.240 && $version<6.261)
		error ("Detected Rig version:\""+$version+"\" which has issues with Switch FK2Ik, Update to the latest version, and run \"ReBuild AdvancedSkeleton\" to fix this.");
	}

if ($isSplineIK)
	{
	$chainJoints=`asgetChainJoints ($nameSpace+$startJoint+$side) ($nameSpace+$endJoint+$side)`;
	for ($i=0;$i<size($chainJoints);$i++)
		$chainJoints[$i]=`substitute $nameSpace $chainJoints[$i] ""`;
	for ($i=1;$i<99;$i++)
		{
		if (!`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
			break;
		$numIkCtrls=$i;
		}
	}
else
	$requiredObj=`stringArrayCatenate $requiredObj {($nameSpace+"Pole"+$IK+$side),($nameSpace+"FKX"+$endJoint+$side)}`;
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
float $charsize=`getAttr ($nameSpace+"Main.height")`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;
if ($asBakeFKIK)
	autoKeyframe -st 1;

if (`attributeExists useOffsetParentMatrix ($nameSpace+"FitSkeleton")`)
	$opm=`getAttr ($nameSpace+"FitSkeleton.useOffsetParentMatrix")`;

//Not using `optionVar -q asBakingMoCap` as it could get stuck at wrong state
if (`checkBox -q -ex asAnimBakingMoCapCheckBox`)
	$bakingMoCap=`checkBox -q -v asAnimBakingMoCapCheckBox`;

string $deleteObjs[]={"IK2FKTempCurve","IK2FKTempXform1","IK2FKTempXform2","IK2FKTempCurveInfo"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

if ($W2K=="FK2IK" && !$isSplineIK)
	{
	//Default values for RollHeel, RollToes, RollToesEnd, and UD attrs such as roll,etc
	asSetCustomAttrToDefault ($nameSpace+"IK"+$IK+$side);
	$tempString=`listRelatives -ad -type transform ($nameSpace+"IK"+$IK+$side)`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im ($nameSpace+"ControlSet") $tempString[$i]`)
			{
			if (!`getAttr -l ($tempString[$i]+".tx")`)
				setAttr ($tempString[$i]+".t") -type float3 0 0 0;
			if (!`getAttr -l ($tempString[$i]+".rx")`)
				setAttr ($tempString[$i]+".r") -type float3 0 0 0;
			}
	//zero out leg-aim for easier alignment
	if (`attributeExists legAim ($nameSpace+"IK"+$IK+$side)`)
		setAttr ($nameSpace+"IK"+$IK+$side+".legAim") 0;

	//Ik Handle
	$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$endJoint+$side)`;
	if (size($qToesJoints))
		$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$qToesJoints[0]+$side)`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);

	$roo=`xform -q -roo ($nameSpace+"IK"+$IK+$side)`;
	xform -p 1 -roo $roo ($nameSpace+"AlignIKTo"+$endJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$endJoint+$side)`;
	if (size($qToesJoints))
		$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$qToesJoints[0]+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	if (`attributeExists mirroredTranslate ($nameSpace+"IK"+$IK+$side)` && `getAttr ($nameSpace+"IK"+$IK+$side+".mirroredTranslate")` && $side=="_L")
		rotate -r -eu 0 0 -180 ($nameSpace+"IK"+$IK+$side);

	//Pole
	//Default values for Pole attrs as well e.g. follow & lock
	asSetCustomAttrToDefault ($nameSpace+"Pole"+$IK+$side);

	$tempLoc1=`spaceLocator`;
	$tempConstraint=`pointConstraint ($nameSpace+"FKX"+$startJoint+$side) ($nameSpace+"FKX"+$endJoint+$side) $tempLoc1[0]`;
	$tempConstraintAttrs=`listAttr -ud $tempConstraint`;

	$middleJointLenght=`getAttr ($nameSpace+"FKOffset"+$middleJoint+$side+".tx")`;
	$endJointLenght=`getAttr ($nameSpace+"FKOffset"+$endJoint+$side+".tx")`;
	if ($opm && `objExists ($nameSpace+$middleJoint)` && `objExists ($nameSpace+$endJoint)`)
		{//opm uses FitSkeleton for now
		$middleJointLenght=`getAttr ($nameSpace+$middleJoint+".tx")`;
		$endJointLenght=`getAttr ($nameSpace+$endJoint+".tx")`;
		}
	setAttr ($tempLoc1[0]+"_pointConstraint1."+$tempConstraintAttrs[0]) `abs($endJointLenght)`;
	setAttr ($tempLoc1[0]+"_pointConstraint1."+$tempConstraintAttrs[1]) `abs($middleJointLenght)`;
	delete $tempConstraint[0];
	if ($bakingMoCap)
		{
		//ShiftAxis
		$tempLocShift1=`spaceLocator`;
		parent -r $tempLocShift1[0] ($nameSpace+"FKX"+$middleJoint+$side);
		$tempLocShift2=`spaceLocator`;
		parent -r $tempLocShift2[0] ($nameSpace+"FKX"+$endJoint+$side);
		parent $tempLocShift2[0] $tempLocShift1[0];
		$pos=`getAttr ($tempLocShift2[0]+".t")`;
		$posA={abs($pos[0]),abs($pos[1]),abs($pos[2])};
		if ($posA[1]>$posA[0] && $posA[1]>$posA[2]) $priAxis="Y";
		if ($posA[2]>$posA[0] && $posA[2]>$posA[1]) $priAxis="Z";
		$jo=`getAttr ($nameSpace+$middleJoint+$side+".jo")`;
		if ($opm)
			$jo=`asTransformValuesFromMatrixPlug ($nameSpace+$middleJoint+$side) offsetParentMatrix rotate`;
		if (abs($jo[0])>abs($jo[1]) && abs($jo[0])>abs($jo[2])) $maxJo=$jo[0];
		if (abs($jo[1])>abs($jo[0]) && abs($jo[1])>abs($jo[2])) $maxJo=$jo[1];
		if (abs($jo[2])>abs($jo[0]) && abs($jo[2])>abs($jo[1])) $maxJo=$jo[2];
		$joFac=15.0/abs($maxJo);//15 degree bend check
		setAttr ($tempLocShift1[0]+".r") -type float3 ($jo[0]*$joFac) ($jo[1]*$joFac) ($jo[2]*$joFac);
		parent -w $tempLocShift2[0];
		setAttr ($tempLocShift1[0]+".r") -type float3 0 0 0;
		parent $tempLocShift2[0] $tempLocShift1[0];
		setAttr ($tempLocShift2[0]+".translate"+$priAxis) 0;
		$pos=`getAttr ($tempLocShift2[0]+".t")`;
		$posA={abs($pos[0]),abs($pos[1]),abs($pos[2])};
		if ($posA[0]>$posA[1] && $posA[0]>$posA[2]) $shiftAxis="X";
		if ($posA[2]>$posA[0] && $posA[2]>$posA[1]) $shiftAxis="Z";
		if (`getAttr ($tempLocShift2[0]+".translate"+$shiftAxis)`<0) $shiftPolarity=-1;
		$shiftDist=($charsize/10)*$shiftPolarity;
		delete $tempLocShift1[0];
		//Move locator1 backwards relative to $startJoint, allowing for rotation of $middleJoint past zero, w/o poleVec flip
		parent $tempLoc1[0] ($nameSpace+"FKX"+$middleJoint+$side);
		setAttr ($tempLoc1[0]+".t") -type float3 0 0 0;
		setAttr ($tempLoc1[0]+".translate"+$shiftAxis) (`getAttr ($tempLoc1[0]+".translate"+$shiftAxis)`+$shiftDist);
		parent -w $tempLoc1[0];
		}
	$tempConstraint=`aimConstraint -aimVector 1 0 0 ($nameSpace+"FKX"+$middleJoint+$side) $tempLoc1[0]`;
	$tempLoc2=`spaceLocator`;
	parent $tempLoc2[0] $tempLoc1[0];
	setAttr ($tempLoc2[0]+".t") -type float3 0 0 0;
	$posA=`xform -q -ws -t $tempLoc2[0]`;
	$posB=`xform -q -ws -t ($nameSpace+$middleJoint+$side)`;
	$samplerDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	setAttr -type float3 ($tempLoc2[0]+".translate") (($charsize/3.333)+$samplerDist) 0 0;
	$tempFloat=`xform -q -ws -t $tempLoc2[0]`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"Pole"+$IK+$side);
	delete $tempLoc1;


	if (`objExists ($nameSpace+$toesJoint)` && `objExists ($nameSpace+"AlignIKToToes"+$side)`)
		{
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setAttr ($nameSpace+"IK"+$IK+$side+".roll") 0;
		$rot=`xform -q -ws -ro ($nameSpace+"AlignIKToToes"+$side)`;
		xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"IKToes"+$side);
		if (`objExists ($nameSpace+"IK"+$toesJoint+$side)`)
			if (`attributeExists mirroredTranslate ($nameSpace+"IK"+$toesJoint+$side)` && `getAttr ($nameSpace+"IK"+$toesJoint+$side+".mirroredTranslate")` && $side=="_L")
				rotate -r -eu 0 0 -180 ($nameSpace+"IK"+$toesJoint+$side);
		}
	$tempFloat=`getAttr ($nameSpace+$endJoint+$side+".s")`;
	setAttr ($nameSpace+"IK"+$IK+$side+".s") -type float3 $tempFloat[0] $tempFloat[1] $tempFloat[2];


	setAttr ($nameSpace+"IK"+$IK+$side+".stretchy") 10;
	setAttr ($nameSpace+"IK"+$IK+$side+".volume") 10;
	//position
	$tempFloat=`xform -q -ws -t ($nameSpace+"FKX"+$endJoint+$side)`;
	if (size($qToesJoints))
		$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$qToesJoints[0]+$side)`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);

	if (`objExists ($nameSpace+"IKX"+$middleJoint+$side+"_IKLenght"+$side)` && `objExists ("IKX"+$middleJoint+$side+"_IKmessureDiv"+$side)`)
		{//Lenght1 & Lenght2
		$pos=`xform -q -ws -t ($nameSpace+"FK"+$startJoint+$side)`;
		$posA=`xform -q -ws -t ($nameSpace+"FK"+$middleJoint+$side)`;
		$posB=`xform -q -ws -t ($nameSpace+"FK"+$endJoint+$side)`;
		$tempFloat[0]=`mag<<$pos[0]-$posA[0],$pos[1]-$posA[1],$pos[2]-$posA[2]>>`;
		$tempFloat[1]=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;		
		setAttr ($nameSpace+"IK"+$IK+$side+".Lenght1") (($tempFloat[0]/(`getAttr ($nameSpace+"IKX"+$middleJoint+$side+"_IKLenght"+$side+".input2X")`*$b))/`getAttr ("IKX"+$middleJoint+$side+"_IKmessureDiv"+$side+".input1X")`);
		setAttr ($nameSpace+"IK"+$IK+$side+".Lenght2") (($tempFloat[1]/(`getAttr ($nameSpace+"IKX"+$endJoint+$side+"_IKLenght"+$side+".input2X")`*$b))/`getAttr ("IKX"+$middleJoint+$side+"_IKmessureDiv"+$side+".input1X")`);
		//allow for scaled character
		if (`objExists ($nameSpace+"MainScaleMultiplyDivide")`)
			{
			setAttr ($nameSpace+"IK"+$IK+$side+".Lenght1") (`getAttr ($nameSpace+"IK"+$IK+$side+".Lenght1")`/`getAttr ($nameSpace+"MainScaleMultiplyDivide.outputX")`);
			setAttr ($nameSpace+"IK"+$IK+$side+".Lenght2") (`getAttr ($nameSpace+"IK"+$IK+$side+".Lenght2")`/`getAttr ($nameSpace+"MainScaleMultiplyDivide.outputX")`);
			}
		}

	//Qtoes (roll toes) to reverse-aim, use toesAim attr to find ctrl that needs aiming
	if (`attributeExists toesAim ($nameSpace+"IK"+$IK+$side)`)
		{
		for ($i=0;$i<size($qToesJoints);$i++)
			{
			$rollCtrlToAim=$nameSpace+"Roll"+$qToesJoints[$i]+$side;
			$tempString=`listRelatives -c -type ikHandle $rollCtrlToAim`;
			$ikHandleWithLocalOrient=$tempString[0];
			if ($i==size($qToesJoints)-1)
				$aimAtTarget=$nameSpace+"FK"+$endJoint+$side;
			else
				$aimAtTarget=$nameSpace+"FK"+$qToesJoints[$i+1]+$side;
			createNode -n tempXform1 -p $ikHandleWithLocalOrient transform;
			createNode -n tempXform2 -p $rollCtrlToAim transform;
			parent tempXform2 tempXform1;
			$tempString=`listRelatives -p $rollCtrlToAim`;
			parent tempXform1 $tempString[0];
			aimConstraint -offset 0 0 0 -weight 1 -aimVector ($b*-1) 0 0 -upVector 0 $b 0 -worldUpType "objectrotation" -worldUpObject ($nameSpace+"IK"+$IK+$side) $aimAtTarget tempXform1;
			$tempFloat=`xform -q -ws -ro tempXform2`;
			xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] $rollCtrlToAim;
			delete tempXform1;
			}
		}
	}
if ($W2K=="FK2IK" && $isSplineIK)
	{
	$curveCmd="curve -n FK2IKCurve -d 1";
	for ($i=0;$i<size($chainJoints);$i++)
		{
		$pos=`xform -q -ws-t ($nameSpace+$chainJoints[$i])`;
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		}
	eval ($curveCmd);
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 FK2IKCurve;
	if (`objExists tempPointOnCurveInfo`) delete tempPointOnCurveInfo;
	createNode -n tempPointOnCurveInfo pointOnCurveInfo;
	setAttr tempPointOnCurveInfo.turnOnPercentage 1;
	connectAttr -f FK2IKCurve.worldSpace[0] tempPointOnCurveInfo.inputCurve;

	//First IKHybrid
	for ($i=0;$i<$numIkCtrls;$i++)
		{
		//`shuffle` so the Last is the second (1st last before the rest, since they affect pos of inbetweens)
		$y=$i;
		if ($i==0) $y=1;
		if ($i==1) $y=$numIkCtrls;

		$u=($y-1.0)/($numIkCtrls-1.0);
		setAttr tempPointOnCurveInfo.parameter $u;
		$pos=`getAttr tempPointOnCurveInfo.position`;
		$tempString=`asGetDeformJointsByDistance $pos`;
		$tempFloat=$pos;
		$rot=`xform -q -ws -ro $tempString[0]`;
		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"IKhybrid"+$IK+$y+$side);
		if ($i==1)//last IKhybrid is `limb-oriented`, but last fk is `child-oriented`, orient IK instead of IKhybrid
			xform -os -t 0 0 0 -ro 0 0 0 ($nameSpace+"IKhybrid"+$IK+$y+$side);
		}

	//then IK
	for ($i=0;$i<$numIkCtrls;$i++)
		{
		//`shuffle` again
		$y=$i;
		if ($i==0) {$y=1;$c=0;}
		if ($i==1) {$y=$numIkCtrls;$c=size($chainJoints)-1;}

		$u=($y-1.0)/($numIkCtrls-1.0);
		setAttr tempPointOnCurveInfo.parameter $u;
		$pos=`getAttr tempPointOnCurveInfo.position`;
		$tempString=`asGetDeformJointsByDistance $pos`;
		$tempFloat=$pos;

		xform -ws -t $pos[0] $pos[1] $pos[2] ($nameSpace+"IK"+$IK+$y+$side);
		xform -os -ro 0 0 0 ($nameSpace+"IK"+$IK+$y+$side);
		//last IKhybrid is `limb-oriented`, but last fk is `child-oriented`, orient IK instead of IKhybrid
		if ($i==1 || ($i==0 && $chainJoints[0]=="Root_M"))// also IKSpine1_M to be oriented, since it affect legs(in fk) but hybrid does not
			{
			$roo=`xform -q -roo ($nameSpace+"IK"+$IK+$y+$side)`;
			xform -p 1 -roo $roo ($nameSpace+"AlignIKTo"+$chainJoints[$c]);
			$rot=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$chainJoints[$c])`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"IK"+$IK+$y+$side);
			}
		}

	delete FK2IKCurve;
/*
	//removed, since FK ctrls can be moved (stretched) causing very non-unifor distribution of FK-joints,
	//and trasnferring this non-unifor distribution to the IK is probably not what the user wants
	//then do  IKcvCtrls
	for ($i=1;$i<size($chainJoints)-1;$i++)
		{
		$pos=`xform -q -ws -t ($nameSpace+"FKX"+$chainJoints[$i])`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($nameSpace+"IKcv"+$IK+$i+$side);
		}
*/
	print "// Switching from FK to Curve-Based-IK, Target might not fully Align.\n";
	}
if ($W2K=="IK2FK" && !$isSplineIK)
	{
	for ($x=0;$x<size($startMiddleEnd);$x++)
		{
		xform -os -t 0 0 0 ($nameSpace+"FK"+$startMiddleEnd[$x]+$side);
//		asFKIKOrientAlign $nameSpace ("IKX"+$startMiddleEnd[$x]+$side) ("FK"+$startMiddleEnd[$x]+$side);
		$rot=`xform -q -ws -ro ($nameSpace+"IKX"+$startMiddleEnd[$x]+$side)`;
		xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FK"+$startMiddleEnd[$x]+$side);
		asCustomOrientedAlignUpdate $nameSpace ("FK"+$startMiddleEnd[$x]+$side);
		}
	if (`objExists ($nameSpace+$toesJoint)` && `objExists ($nameSpace+"IKXToes"+$side)`)
		{
		xform -os -t 0 0 0 ($nameSpace+"FKToes"+$side);
//		asFKIKOrientAlign $nameSpace ("IKXToes"+$side) ("FKToes"+$side);
		$rot=`xform -q -ws -ro ($nameSpace+"IKXToes"+$side)`;
		xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FKToes"+$side);
		asCustomOrientedAlignUpdate $nameSpace ($nameSpace+"FKToes"+$side);
		}
	$tempFloat=`getAttr ($nameSpace+$endJoint+$side+".s")`;
	setAttr ($nameSpace+"FK"+$endJoint+$side+".s") -type float3 $tempFloat[0] $tempFloat[1] $tempFloat[2];
	//stretchy IK
//	if (`getAttr ($nameSpace+"IK"+$IK+$side+".stretchy")`>0.01)
		{
		//volume
		$tempFloat=`getAttr ($nameSpace+$startJoint+$side+".s")`;
		setAttr ($nameSpace+"FK"+$startJoint+$side+".s") -type float3 $tempFloat[0] $tempFloat[1] $tempFloat[2];
		$tempFloat=`getAttr ($nameSpace+$middleJoint+$side+".s")`;
		setAttr ($nameSpace+"FK"+$middleJoint+$side+".s") -type float3 $tempFloat[0] $tempFloat[1] $tempFloat[2];
		//position
		$tempFloat=`xform -q -ws -t ($nameSpace+"IKX"+$middleJoint+$side)`;
		xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$middleJoint+$side);
		$tempFloat=`xform -q -ws -t ($nameSpace+"IKX"+$endJoint+$side)`;
		xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$endJoint+$side);
		}
	//toesAim
	if (`attributeExists toesAim ($nameSpace+"IK"+$IK+$side)`)
		{
		if (`getAttr ($nameSpace+"IK"+$IK+$side+".toesAim")`>0)
			{
			$rot=`xform -q -ws -ro ($nameSpace+"IKX"+$qToesJoints[0]+$side)`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FK"+$qToesJoints[0]+$side);
			asCustomOrientedAlignUpdate $nameSpace ($nameSpace+"FK"+$qToesJoints[0]+$side);
			}
		}
	//qToes
	for ($i=size($qToesJoints)-1;$i>-1;$i--)
		{
		$tempFloat=`xform -q -ws -t ($nameSpace+"IKX"+$qToesJoints[$i]+$side)`;
		xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$qToesJoints[$i]+$side);
		$rot=`xform -q -ws -ro ($nameSpace+"IKX"+$qToesJoints[$i]+$side)`;
		xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FK"+$qToesJoints[$i]+$side);
		asCustomOrientedAlignUpdate $nameSpace ($nameSpace+"FK"+$qToesJoints[$i]+$side);
		}
	}
if ($W2K=="IK2FK" && $isSplineIK)
	{
	for ($i=0;$i<size($chainJoints);$i++)
		{
		if (!`objExists ($nameSpace+"IKX"+$chainJoints[$i])` || !`objExists ($nameSpace+"FK"+$chainJoints[$i])`)
			continue;
		if (!`sets -im ($nameSpace+"ControlSet") ($nameSpace+"FK"+$chainJoints[$i])`)
			continue;
		// RootX_M.legLock warning
		if ($chainJoints[$i]=="Root")
			if (`attributeExists legLock RootX_M`)
				if (`getAttr RootX_M.legLock`!=10)
					print ("// Switching from IK to FK for the Spine, Set RootX_M.legLock to 10, for more accurate switching.\n");
		$pos=`xform -q -ws -t ($nameSpace+"IKX"+$chainJoints[$i])`;
		$rot=`xform -q -ws -ro ($nameSpace+"IKX"+$chainJoints[$i])`;
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FK"+$chainJoints[$i]);

		clear $w;
		for ($y=0;$y<99;$y++)
			if (`attributeExists ("w"+$y) ($nameSpace+"FK"+$chainJoints[$i])`)
				$w[$y]=`getAttr ($nameSpace+"FK"+$chainJoints[$i]+".w"+$y)`;
			else
				break;

		if (!size($w))
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FK"+$chainJoints[$i]);

		if ($i==size($chainJoints)-1)
			asCustomOrientedAlignUpdate $nameSpace ($nameSpace+"FK"+$chainJoints[$i]);

		//inbetween, to compute controller rot needed to best align childFK
		if (size($w))
			{
			createNode -n InbetweenIK2FKTarget transform;
			asAlign InbetweenIK2FKTarget ($nameSpace+"FKOffset"+$chainJoints[$i]) 1 1 0 0;
			createNode -n InbetweenIK2FKAimer -p InbetweenIK2FKTarget transform;
			$numChar=size($chainJoints[$i]);
			$sideLess=`substring $chainJoints[$i] 1 ($numChar-2)`;
			$target=`asRlaChild ($nameSpace+$sideLess)`+$side;
			for ($y=0;$y<size($w)+1;$y++)
				{
				createNode -n ("InbetweenIK2FKTarget"+$y) -p InbetweenIK2FKTarget transform;
				if ($y==0)
					orientConstraint InbetweenIK2FKAimer InbetweenIK2FKTarget0;
				else
					{
					parent ("InbetweenIK2FKTarget"+$y) ("InbetweenIK2FKTarget"+($y-1));
					$tempString[0]=`asRlaChild ($nameSpace+$chainJoints[$i])`;
					$partJoint=$nameSpace+$sideLess+"Part1"+$side;
					$pos=`getAttr ($partJoint+".t")`;
					setAttr ("InbetweenIK2FKTarget"+$y+".t") -type float3 $pos[0] $pos[1] $pos[2];

					createNode -n ("InbetweenIK2FKTargetMPD"+$y) multiplyDivide;
					connectAttr InbetweenIK2FKAimer.r ("InbetweenIK2FKTargetMPD"+$y+".input1");
					$value=0.333;
					setAttr ("InbetweenIK2FKTargetMPD"+$y+".input2") -type float3 $value $value $value;
					setAttr ("InbetweenIK2FKTarget"+$y+".displayLocalAxis") 1;
					connectAttr ("InbetweenIK2FKTargetMPD"+$y+".output") ("InbetweenIK2FKTarget"+$y+".r");
					}
				}

			//Analyze $axis 
			$priAxis=`asGetAxis primary ($nameSpace+"FK"+$chainJoints[$i]) ($nameSpace+"Main") 0`;
			$secAxis=`asGetAxis secondary ($nameSpace+"FK"+$chainJoints[$i]) ($nameSpace+"Main") 0`;
			$terAxis=`asGetAxis tertiary ($nameSpace+"FK"+$chainJoints[$i]) ($nameSpace+"Main") 0`;
			$aimVector=`asAxisToVector $priAxis`;
			$upVector=`asAxisToVector $priAxis`;

			delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector $aimVector[0] $aimVector[1] $aimVector[2] -upVector $upVector[0] $upVector[1] $upVector[2] -worldUpType "objectrotation" -worldUpObject $target $target InbetweenIK2FKAimer`;
			parent ("InbetweenIK2FKTarget"+size($w)) InbetweenIK2FKTarget;
			delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector $aimVector[0] $aimVector[1] $aimVector[2] -upVector $upVector[0] $upVector[1] $upVector[2] -worldUpType "objectrotation" -worldUpObject $target ("InbetweenIK2FKTarget"+size($w)) InbetweenIK2FKAimer`;
			$rot=`getAttr InbetweenIK2FKAimer.r`;
			setAttr ($nameSpace+"FK"+$chainJoints[$i]+".r") -type float3 $rot[0] $rot[1] $rot[2];
			delete InbetweenIK2FKTarget;

			//then also match position:
			$pos=`xform -q -ws -t ($nameSpace+"IKX"+$chainJoints[$i])`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($nameSpace+"FK"+$chainJoints[$i]);
			}
		}
	}

if ($autoKey)
	autoKeyframe -st 1;
if (!$autoKey && $asBakeFKIK)
	autoKeyframe -st 0;
select $sel;
}

global proc asSwitchFKIK (string $name, string $IK, string $side, string $W2K)
{
global string $gPlayBackSlider;
global int $asBakeFKIK;
int $bakeRange=0;
float $timeRangeArray[]=`timeControl -q -rangeArray $gPlayBackSlider`;
if (($timeRangeArray[1]-$timeRangeArray[0])>1)
	{
	$bakeRange=1;
	currentTime $timeRangeArray[0];
	}
float $currentTime=`currentTime -q`;
string $sel[]=`ls -sl`;
//string $nameSpace=`asSelectorResolveNameSpace $name ""`;
//backwards compatibility, 1st arg used to be $name (e.g  \"biped\")
string $nameSpace=`asNameSpaceFromShortUIName $name`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
string $poleCurve=$nameSpace+"Pole"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $chainJoints[],$tempString[],$tempString2[];
string $toesJoint=`asGetToesJoint $nameSpace $endJoint $side`;
//string $qToesJoints[]=`asGetQToesJoints $nameSpace $endJoint $side`;
string $childLabel,$fkLegAim,$legAimRotCmd;
float $legAimRot[];
int $isSplineIK,$numIkCtrls;
if (!`objExists ($nameSpace+"Pole"+$IK+$side)`)
	$isSplineIK=1;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
if ($isSplineIK)
	{
	$chainJoints=`asgetChainJoints ($nameSpace+$startJoint) ($nameSpace+$endJoint)`;
	for ($i=0;$i<size($chainJoints);$i++)
		$chainJoints[$i]=`substitute $nameSpace $chainJoints[$i] ""`;
	for ($i=1;$i<99;$i++)
		{
		if (!`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
			break;
		$numIkCtrls=$i;
		}
	}
else
	$requiredObj=`stringArrayCatenate $requiredObj {($nameSpace+"Pole"+$IK+$side),($nameSpace+"FKX"+$endJoint+$side)}`;
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
int $Blend;
int $BlendInverse=10;
int $onOff;
if ($W2K=="FK2IK")
	{
	$Blend=10;
	$BlendInverse=0;
	$onOff=1;
	}

if ($W2K=="FK2IK" && `getAttr ($controlCurve+".FKIKBlend")`>0)
	{
	warning ("Could not switch FK2IK, because \"FKIKBlend\" is not \"0\"\n");
	return;
	}
if ($W2K=="IK2FK" && `getAttr ($controlCurve+".FKIKBlend")`<10)
	{
	warning ("Could not switch IK2FK, because \"FKIKBlend\" is not \"10\"\n");
	return;
	}

//LegAim
if (`attributeExists legAim ($nameSpace+"IK"+$IK+$side)`)
	{
	if (`objExists ($nameSpace+"IK"+$IK+"LegAimReverse"+$side)`)//non OPM
		{
		$tempString=`listConnections -s 0 -d 1 ($nameSpace+"IK"+$IK+"LegAimReverse"+$side)`;
		$fkLegAim=`substitute ($nameSpace+"LegAim") $tempString[0] ""`;
		$fkLegAim="FK"+`substitute ($side+"_orientConstraint1") $fkLegAim ""`;
		}
	else	//OPM
		{
		$tempString=`listConnections -s 0 -d 1 -scn 1 ($nameSpace+"IK"+$IK+$side+".legAim")`;
		$fkLegAim=`substitute ("Aim") $tempString[0] "FK"`;
		$fkLegAim=`substitute ("BM"+$side) $fkLegAim ""`;
		}
	$legAimRot=`xform -q -ws -ro ($nameSpace+$fkLegAim+$side)`;
	$legAimRotCmd="xform -ws -ro "+$legAimRot[0]+" "+$legAimRot[1]+" "+$legAimRot[2]+" "+$nameSpace+$fkLegAim+$side;
	}

int $autoKey=`autoKeyframe -q -st`;
if ($bakeRange && !$autoKey)
	{
	autoKeyframe -e -st 1;
	$autoKey=1;
	}

currentTime (`currentTime -q` -1);
setAttr ($controlCurve+".FKIKBlend") $BlendInverse;


for ($a=0;$a<2;$a++)
	{
	if (!$autoKey && $a==0)
		continue;
	if ($autoKey)
		{
		if (!$isSplineIK)
			{
			setKeyframe ($controlCurve+".FKIKBlend");
	//		setKeyframe ($poleCurve+".follow");	

			setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
			setKeyframe ($nameSpace+"FK"+$startJoint+$side+".scale");
			setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".translate");
			setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
			setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".scale");
			setKeyframe ($nameSpace+"FK"+$endJoint+$side+".translate");
			setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
			setKeyframe ($nameSpace+"FK"+$endJoint+$side+".scale");
			if (`objExists ($nameSpace+$toesJoint)` && `objExists ($nameSpace+"FKToes"+$side)`)
				setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
			setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
			setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
			setKeyframe ($nameSpace+"IK"+$IK+$side+".scale");
			setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");
			$tempString=`listAttr -ud ($nameSpace+"IK"+$IK+$side)`;
			for ($i=0;$i<size($tempString);$i++)
				setKeyframe ($nameSpace+"IK"+$IK+$side+"."+$tempString[$i]);
			$tempString=`listAttr -ud ($nameSpace+"Pole"+$IK+$side)`;
			for ($i=0;$i<size($tempString);$i++)
				setKeyframe ($nameSpace+"Pole"+$IK+$side+"."+$tempString[$i]);
//			if (`objExists ($nameSpace+$toesJoint)` && `objExists ($nameSpace+"IKToes"+$side)`)
//				setKeyframe ($nameSpace+"IKToes"+$side+".rotate");
			//also key all child-controls (ik heel/toes/toesEnd/qtoes
			$tempString=`listRelatives -ad -type transform ($nameSpace+"IK"+$IK+$side)`;
			for ($i=0;$i<size($tempString);$i++)
				if (`sets -im ($nameSpace+"ControlSet") $tempString[$i]`)
					{
					setKeyframe ($tempString[$i]+".t");
					setKeyframe ($tempString[$i]+".r");
					//and it`s equivalent FK (qToes)
					$tempString2[0]=`substitute "Roll" $tempString[$i] "FK"`;
					if (`objExists $tempString2[0]`)
						{
						setKeyframe ($tempString2[0]+".t");
						setKeyframe ($tempString2[0]+".r");
						}
					}
			}
		if ($isSplineIK)
			{
			setKeyframe ($controlCurve+".FKIKBlend");
			for ($i=0;$i<size($chainJoints);$i++)
				if (`objExists ($nameSpace+"FK"+$chainJoints[$i]+$side)`)
					{
					setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".t");
					setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".r");
					}
			for ($i=1;$i<$numIkCtrls+1;$i++)
				{
				if (`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
					{
					setKeyframe ($nameSpace+"IK"+$IK+$i+$side+".t");
					setKeyframe ($nameSpace+"IK"+$IK+$i+$side+".r");
					}
				if (`objExists ($nameSpace+"IKhybrid"+$IK+$i+$side)`)
					{
					setKeyframe ($nameSpace+"IKhybrid"+$IK+$i+$side+".t");
					setKeyframe ($nameSpace+"IKhybrid"+$IK+$i+$side+".r");
					}
				}
			}
		if ($legAimRotCmd!="")
			setKeyframe ($nameSpace+$fkLegAim+$side+".r");			
		}

	currentTime (`currentTime -q` +1);
	asAlignFKIK $name $IK $side $W2K;
	setAttr ($controlCurve+".FKIKBlend") $Blend;
	if ($legAimRotCmd!="") eval ($legAimRotCmd);
	}

if ($bakeRange)
	{
	$asBakeFKIK=1;
	for ($i=$timeRangeArray[0]+1;$i<$timeRangeArray[1];$i++)
		{
		currentTime $i;
		asAlignFKIK $name $IK $side $W2K;
		}
	$asBakeFKIK=0;
	setKeyframe -t ($timeRangeArray[1]-1) -v $Blend ($controlCurve+".FKIKBlend");
	setKeyframe -t ($timeRangeArray[1]+0) -v $BlendInverse ($controlCurve+".FKIKBlend");
	//only Maya2024 seems to be able to set range, and we loose renage upon setKeyframe cmd, so only Maya2024 will be able to do multi-obj-sel
	catchQuiet (`playbackOptions -sst $timeRangeArray[0] -set ($timeRangeArray[1]-1) -sv true`);
	}

currentTime $currentTime;

if ($bakeRange && !$autoKey)
	autoKeyframe -e -st 0;
//select ($nameSpace+"ControlSet");
//delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1;
//removed, since this sometimes deletes non-static channels e..g IKLeg_L animation
select $sel;
}

global proc asCustomOrientedAlignUpdate (string $nameSpace, string $ctrl)
{
float $rot[];
string $customOrient=$nameSpace+"CustomOrient"+$ctrl;
string $tempString[];

if (!`objExists $customOrient`)
	return;

$tempString=`listRelatives -p $customOrient`;
createNode -n asCustomOrientWithRotateOrder -p $tempString[0] transform;
setAttr asCustomOrientWithRotateOrder.rotateOrder `getAttr ($nameSpace+$ctrl+".rotateOrder")`;
orientConstraint $customOrient asCustomOrientWithRotateOrder;

$rot=`xform -q -os -ro asCustomOrientWithRotateOrder`;
delete asCustomOrientWithRotateOrder;
xform -r -os -ro $rot[0] $rot[1] $rot[2] ($nameSpace+$ctrl);
}

global proc asSetCustomAttrToDefault (string $ctrl)
{
string $attrs[]=`listAttr -ud ($ctrl)`;

for ($i=0;$i<size($attrs);$i++)
	{
	if (`getAttr -type ($ctrl+"."+$attrs[$i])`=="string")
		continue;//skip any custom added string attributes
	if (!`getAttr -settable ($ctrl+"."+$attrs[$i])`)
		continue;//skip any non settable attributes
	if (!`getAttr -keyable ($ctrl+"."+$attrs[$i])`)
		continue;//skip any non keyable attributes		
	$tempFloat=`attributeQuery -listDefault -n ($ctrl) $attrs[$i]`;
	//special case, prior to v 6.261, PoleLeg_R.follow did not have it`s -DV set to 10
	if (`gmatch $ctrl "*PoleLeg*"` && $attrs[$i]=="follow")
		$tempFloat[0]=10;
	setAttr ($ctrl+"."+$attrs[$i]) $tempFloat[0];
	}
}

global proc string asGetToesJoint (string $nameSpace,string $endJoint,string $side)
{
string $toesJoint,$childLabel;
string $tempString[],$tempString2[],$tempStringShort[];

if (!`objExists ($nameSpace+$endJoint)`)
	return $toesJoint;
	
//-f added in 5.911, which caused fail,new fix in 5.9413
$tempString     =`listRelatives -f -type joint -ad ($nameSpace+$endJoint)`;
$tempStringShort=`listRelatives    -type joint -ad ($nameSpace+$endJoint)`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`getAttr ($tempString[$i]+".drawLabel")`)
		{
		$childLabel=`getAttr ($tempString[$i]+".otherType")`;
		if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*QToes*"` && !`gmatch $childLabel "*ToesEnd*"`)
			{
			$tempString3[0]=`substitute $nameSpace $tempStringShort[$i] ""`;
			if (`objExists ($nameSpace+"FK"+$tempString3[0]+$side)`)
				$toesJoint=$tempString3[0];
			}
		}
	}

return $toesJoint;
}

global proc string[] asGetQToesJoints (string $nameSpace,string $endJoint,string $side)
{
string $childLabel;
string $qToesJoints[],$tempString[],$tempString2[],$tempString3[],$tempString4[],$tempStringShort[];

if (!`objExists ($nameSpace+$endJoint)`)
	return $qToesJoints;

//-f added in 5.911, which caused fail,new fix in 5.9413
$tempString     =`listRelatives -f -type joint -ad ($nameSpace+$endJoint)`;
$tempStringShort=`listRelatives    -type joint -ad ($nameSpace+$endJoint)`;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`getAttr ($tempString[$y]+".drawLabel")`)
		{
		$childLabel=`getAttr ($tempString[$y]+".otherType")`;
		if (`gmatch $childLabel "*QToes*"`)
			{
			$tempString2[0]=`substitute $nameSpace $tempStringShort[$y] ""`;
			if (`objExists ($nameSpace+"FK"+$tempString2[0]+$side)`)
				{
				$tempString3=`ls -l ($nameSpace+$tempString2[0])`;
				tokenize $tempString3[0] "|" $tempString4;
				for ($z=size($tempString4)-1;$z>-1;$z--)
					{
					if ($tempString4[$z]==($nameSpace+$endJoint))
						break;
					$qToesJoints[size($qToesJoints)]=`substitute $nameSpace $tempString4[$z] ""`;
					}
				}
			}
		}
	}

return $qToesJoints;
}

global proc string[] asgetChainJoints (string $startJoint, string $endJoint)
{
int $startJointIsParentNr;
string $chainJoints[];
string $tempString[]=`ls -l $endJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$startJointIsParentNr=$i;
	if ($tempString[$i]==$startJoint)
		{
		break;
		}
	}
for ($i=$startJointIsParentNr;$i<size($tempString);$i++)
	$chainJoints[size($chainJoints)]=$tempString[$i];
return $chainJoints;
}

global proc asPopulateNameSpaceMenu (string $name)
{
string $optionMenu=$name+"OptionMenu";
string $nameSpacesList[]=`namespaceInfo -r -lon`;
$nameSpacesList=`stringArrayRemove {"UI"} $nameSpacesList`;
$nameSpacesList[size($nameSpacesList)]="";
string $itemList[]=`optionMenu -q -ils $optionMenu`;
$nameSpacesList=`sort $nameSpacesList`;

if (`asHotKeyCheck "asPopulateNameSpaceMenu \"\""`) return;

for ($item in $itemList)
	deleteUI $item;

for ($nameSpace in $nameSpacesList)
	if (`attributeExists "version" ($nameSpace+":Main")` || `attributeExists "version" ($nameSpace+":FaceGroup")`)
		if (`asFilterCheck $name $nameSpace`)
			menuItem -p $optionMenu -l ($nameSpace+":");

if (!`optionMenu -q -ni ($name+"OptionMenu")`)
	{
	if ($name=="bodySetup" || `gmatch $name "asPoser*"`)
		menuItem -p $optionMenu -l "None";
	else
		menuItem -p $optionMenu -l ":";
	}
}

global proc int asFilterCheck (string $name, string $nameSpace)
{
int $return=0;
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="" || $filterString=="0")
	return 1;
string $references[]=`file -q -r`;
for ($i=0;$i<size($references);$i++)
	{
	$refNameSpace=`file -q -ns $references[$i]`;
	if ($refNameSpace==$nameSpace)
		if (`gmatch $references[$i] $filterString`)
			$return=1;
	}
return $return;
}

global proc asFilterNameSpaceMenuUI (string $name)
{
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;

if (`asHotKeyCheck "asFilterNameSpaceMenuUI \"\""`) return;

if ($filterString=="0")
	$filterString="";
if (`window -q -ex ("SelectorFilter_"+$name)`)
	deleteUI ("SelectorFilter_"+$name);
window ("SelectorFilter_"+$name);
columnLayout;
textFieldGrp -tx $filterString -cc ("asSetFilterNameSpaceMenu "+$name) -l "Reference File Filter. (e.g. *characters*)" -cw 1 200 ("asSelectorFilterTextFieldGrp_"+$name);
showWindow;
}

global proc asSetFilterNameSpaceMenu (string $name)
{
string $filterString=`textFieldGrp -q -tx ("asSelectorFilterTextFieldGrp_"+$name)`;
optionVar -sv ("asSelectorFilter_"+$name) $filterString;
asPopulateNameSpaceMenu $name;
}

global proc asSetNameSpaceFromSelection (string $uiName)
{
asPopulateNameSpaceMenu $uiName;
string $sel[]=`ls -sl`;
string $tempString[],$ils[];
if (size($sel))
	{
	tokenize $sel[0] ":" $tempString;
	$ils=`optionMenu -q -ils ($uiName+"OptionMenu")`;
	for ($i=0;$i<size($ils);$i++)
		if (`menuItem -q -l $ils[$i]`==($tempString[0]+":"))
			{
			optionMenu -e -sl ($i+1) ($uiName+"OptionMenu");
			asSelChange;
			}
	}
print "// Setting nameSpace from selected object\n";
}

global proc string asPoserGetCmd (string $uiName, int $anim)
{
global string $gChannelBoxName;
global string $gMainProgressBar;
string $cmd,$nameSpace;
int $weightedTangents[];
int $onlyOneObj,$onlyOneAttr;
string $connectObj;
string $controls[],$buffer[],$controlSets[];
string $sel[]=`ls -sl`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $selectedShapeAttrs[]=`channelBox -q -ssa $gChannelBoxName`;
string $selectedHistoryAttrs[]=`channelBox -q -sha $gChannelBoxName`;
string $selectedOutputAttrs[]=`channelBox -q -soa $gChannelBoxName`;
string $selectedAttrs[],$animCurves[];
$selectedAttrs=`stringArrayCatenate $selectedMainAttrs $selectedShapeAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedHistoryAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedOutputAttrs`;
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
int $onlySel=`checkBox -q -v asPoserOnlySel`;

$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;

if (!$onlySel && !size($controlSets))
	error "No ControlSets";

//determine the name for poserAnimFile
string $animationFile,$animationFilePath;
string $gridOrder[];
int $childNum;
$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
for ($i=1;$i<size($gridOrder)+1;$i++)
	if (`gmatch $gridOrder[$i-1] "asPoser*"`)
		$childNum=$i;
$childNum++;
$animationFile="untitled_"+$childNum;
$animationFilePath=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";

if ($onlySel)
	{
	for ($i=$y=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] ($nameSpace+"*")`)
			{
			tokenize $sel[$i] ":" $buffer;
			$controls[$y]=$buffer[size($buffer)-1];
			$y++;
			}
		}
	}
else
	{
	if (!`objExists $controlSets[0]`)
		error ("Object :\""+$controlSets[0]+"\" does not exists !\n");
	$controls=`sets -q $controlSets`;
	for ($i=0;$i<size($controls);$i++)
		$controls[$i]=`substitute $nameSpace $controls[$i] ""`;
	}
string $attrs[];
if (size($controls)<1)
	error "No Controls Available!";
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Storing Data" -bp -ii 1 -min 0 -max (size($controls)) $gMainProgressBar;
select -cl;

if ($anim)
	{
	createNode -n poserAnimationInfo transform;
	addAttr -ln "cmd" -dt "string" poserAnimationInfo;
	select poserAnimationInfo;
	}

for ($obj in $controls)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$allKeyableAttrs=`listAttr -k -m -sn ($nameSpace+$obj)`;
	if ($onlySel && (size($selectedAttrs)>0))
		$attrs=$selectedAttrs;
	else
		$attrs=$allKeyableAttrs;
	for ($attr in $attrs)
		for ($allKeyableAttr in $allKeyableAttrs)
			{
			if (`getAttr -l ($nameSpace+$obj+"."+$attr)`)
				continue;
			if ($attr==$allKeyableAttr)
				{
				if (!$anim)
					$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+";";
				else
					{
					//Animation
					$animCurves=`listConnections -type animCurve -s 1 -d 0 ($nameSpace+$obj+"."+$attr)`;
					for ($y=0;$y<size($animCurves);$y++)
						{
						select -add $animCurves[$y];
						$cmd+="connectAttr "+$animCurves[$y]+".output "+$obj+"."+$attr+";";
						}
					}
				}
			}
	}

if ($anim)
	{
	setAttr -type "string" poserAnimationInfo.cmd $cmd;
	if (!`file -q -ex $animationFilePath`)
		sysFile -md $animationFilePath;
	file -f -op "v=0" -typ "mayaAscii" -es ($animationFilePath+$animationFile+".ma");
	delete poserAnimationInfo;
	}

if ($cmd!="")
	{
	if (!$anim)
		$cmd="asSetAttrs "+$uiName+" \""+$cmd+"\"";
	else
		$cmd="asLoadAttrs "+$uiName;
	}

select $sel;
return $cmd;
}

global proc asCopyToClipBoard (string $uiName, int $anim)
{
global string $gChannelBoxName;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $selectedShapeAttrs[]=`channelBox -q -ssa $gChannelBoxName`;
string $selectedHistoryAttrs[]=`channelBox -q -sha $gChannelBoxName`;
string $selectedOutputAttrs[]=`channelBox -q -soa $gChannelBoxName`;
string $selectedAttrs[],$animCurves[];
$selectedAttrs=`stringArrayCatenate $selectedMainAttrs $selectedShapeAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedHistoryAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedOutputAttrs`;
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
int $onlySel;

if (`asHotKeyCheck ("asCopyToClipBoard \"\" "+$anim)`) return;

if ($altButton || $ctrlButton)
	$onlySel=1;
string $nameSpace,$cmd;
string $controls[],$buffer[];
int $weightedTangents[];
int $onlyOneObj,$onlyOneAttr;
string $connectObj;
string $controlSets[];

$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

$controls=`sets -q $controlSets`;
if (!$onlySel && !size($controlSets))
	error "No ControlSets";

//determine the name for animFile
string $animationFile,$animationFilePath;
$animationFile="ClipBoard"+$anim;
$animationFilePath=`asGetTempDirectory`+"AdvancedSkeleton/Selector/";

if ($onlySel)
	{
	for ($i=$y=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] ($nameSpace+"*")`)
			{
			tokenize $sel[$i] ":" $buffer;
			$controls[$y]=$buffer[size($buffer)-1];
			$y++;
			}
		}
	}
else
	{
	if (!`objExists $controlSets[0]`)
		error ("Object :\""+$controlSets[0]+"\" does not exists !\n");
	$controls=`sets -q $controlSets`;
	for ($i=0;$i<size($controls);$i++)
		$controls[$i]=`substitute  $nameSpace $controls[$i] ""`;
	}
string $attrs[];
if (size($controls)<1)
	error "No Controls Available!";
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Storing Data" -bp -ii 1 -min 0 -max (size($controls)) $gMainProgressBar;

createNode -n poserAnimationInfo transform;
addAttr -ln "cmd" -dt "string" poserAnimationInfo;
select poserAnimationInfo;

for ($obj in $controls)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$allKeyableAttrs=`listAttr -k -m -sn ($nameSpace+$obj)`;
	if ($onlySel && (size($selectedAttrs)>0))
		$attrs=$selectedAttrs;
	else
		$attrs=$allKeyableAttrs;
	for ($attr in $attrs)
		for ($allKeyableAttr in $allKeyableAttrs)
			{
			if (`getAttr -l ($nameSpace+$obj+"."+$attr)`)
				continue;
			if ($attr==$allKeyableAttr)
				{
				if (!$anim)
					$cmd+="setAttr "+$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+";";
				if ($anim)
					{
					//Animation
					$animCurves=`listConnections -type animCurve -s 1 -d 0 ($nameSpace+$obj+"."+$attr)`;
					for ($y=0;$y<size($animCurves);$y++)
						{
						select -add $animCurves[$y];
						$cmd+="connectAttr "+$animCurves[$y]+".output "+$obj+"."+$attr+";";
						}
					}
				}
			}
	}

setAttr -type "string" poserAnimationInfo.cmd $cmd;
if (!`file -q -ex $animationFilePath`)
	sysFile -md $animationFilePath;
file -f -op "v=0" -typ "mayaAscii" -es ($animationFilePath+$animationFile+".ma");
delete poserAnimationInfo;

select $sel;
}

global proc asDeleteStaticChannels (string $uiName)
{
string $nameSpace;
string $sel[]=`ls -sl`;
string $controlSets[];

if (`asHotKeyCheck ("asDeleteStaticChannels \"\"")`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

if (`confirmDialog -title "Confirm" -message 
	("Clean animation ?\n"
	+"This will delete static channels,\n"
	+"which means remove all animation where the value is not changing")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;

select $controlSets;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
print ("// Static channels cleaned\n");
select $sel;
}

global proc asSetAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[];
string $objAttr;
float $value;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";

for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asLoadAttrs (string $uiName, int $childNum)
{
global int $asPoserChildNum;
$asPoserChildNum=$childNum;
evalDeferred -lp ("$asPoserChildNum=0;");
asPasteFromClipBoard $uiName 1;
}

global proc asPasteFromClipBoard (string $uiName, int $anim)
{
global int $asPoserChildNum;
$childNum=$asPoserChildNum;
$asPoserChildNum=0;
int $autoKey=`autoKeyframe -q -st`;
int $shiftButton,$ctrlButton,$altButton;
float $value;
if (`getModifiers` %  2)
	$shiftButton=1;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
float $timeOffset=0;
if ($shiftButton)
	$timeOffset=`currentTime -q`;
string $nameSpace,$cmd,$obj,$attr,$objAttr,$connectSourceObjAttr,$newAnimCurve,$clipBoardFile,$projectName;
string $buffer[],$buffer2[],$buffer3[],$tempString[],$controlSets[];
string $sel[]=`ls -sl`;

if (`asHotKeyCheck ("asPasteFromClipBoard \"\" "+$anim)`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

if ($autoKey)
	autoKeyframe -e -st 0;

if ($childNum==0)
	{
	$projectName="Selector";
	$clipBoardFile=`asGetTempDirectory`+"AdvancedSkeleton/Selector/ClipBoard"+$anim+".ma";
	}
else
	{
	string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
	string $tempString[];
	tokenize $icon "/" $tempString;
	$projectName=$tempString[size($tempString)-2];
	$clipBoardFile=`substitute "[.][a-z][a-z][a-z]" $icon ".ma"`;
	}
if (!`file -q -ex $clipBoardFile`)
	error ("CLipboard file:\""+$clipBoardFile+"\" not found");

file -r -type "mayaAscii" -namespace $projectName -options "v=0;p=17" $clipBoardFile;

string $cmds=`getAttr ($projectName+":poserAnimationInfo.cmd")`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";
createNode -n tempXform transform;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$cmd=$buffer2[0];
	if ($cmd=="setAttr")
		{
		$objAttr=$buffer2[1];
		$value=$buffer2[2];
		}
	if ($cmd=="connectAttr")
		{
		$objAttr=$buffer2[2];
		$connectSourceObjAttr=$buffer2[1];
		}
	tokenize $objAttr "." $buffer3;
	$obj=$buffer3[0];
	$attr=$buffer3[1];
	if (($ctrlButton||$altButton) && `gmatch ($nameSpace+$objAttr) "*Main.*"`)
		continue;
	if (`objExists ($nameSpace+$objAttr)`)
		{
		if ($cmd=="setAttr")
			catch (`eval ("setAttr "+$nameSpace+$objAttr+" "+$value)`);
		if ($cmd=="connectAttr")
			{
			if (!`attributeExists $attr tempXform`)
				addAttr -k 1 -ln $attr -at double tempXform;
			connectAttr -f ($projectName+":"+$connectSourceObjAttr) ("tempXform."+$attr);
			copyKey -time ":" -hierarchy none -at $attr tempXform;
			pasteKey -option merge -copies 1 -connect 0 -timeOffset $timeOffset -floatOffset 0 -valueOffset 0 {($nameSpace+$objAttr)};
			}
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$nameSpace+$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;

if (`objExists tempXform`)
	delete tempXform;
file -rr $clipBoardFile;
select $sel;
if ($autoKey)
	autoKeyframe -e -st 1;
}

global proc asKeyAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[],$spaceBuffer[];
string $objAttr,$previousObjAttr,$restOfBuffers;
float $time,$value,$currentValue;
float $currentTime=`currentTime -q`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning,$firstValueSet;
string $warningMsg="The following attributes can not be keyed:";
float $firstValue;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	$restOfBuffers="";
	if ($objAttr!=$previousObjAttr)
		$firstValueSet=0;
	$previousObjAttr=$objAttr;
	for ($y=1;$y<size($buffer2);$y++)
		$restOfBuffers+=$buffer2[$y]+" ";
	if (`objExists $objAttr`)
		{
		tokenize $restOfBuffers $spaceBuffer;
		for ($y=0;$y<size($spaceBuffer);$y++)
			{
			//TimeOffset
			if ($spaceBuffer[$y]=="-t" && ($ctrlButton||$altButton))
				{
				$time=$spaceBuffer[$y+1];
				$spaceBuffer[$y+1]=$time+$currentTime;
				}
			//ValueOffset
			if ($spaceBuffer[$y]=="-v" && $ctrlButton)
				{
				$value=$spaceBuffer[$y+1];
				$currentValue=`getAttr $objAttr`;
				if (!$firstValueSet)
				$firstValue=$value;
				$firstValueSet=1;
				$spaceBuffer[$y+1]=$value+$currentValue-$firstValue;
				}
			}
		$restOfBuffers="";
		for ($y=0;$y<size($spaceBuffer);$y++)
			$restOfBuffers+=$spaceBuffer[$y]+" ";
		eval ($restOfBuffers+$objAttr);
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asPoseView (string $uiName, int $childNum)
{
string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $tempString[];
tokenize $icon "/" $tempString;
string $projectName=$tempString[size($tempString)-2];

string $mediaFile;
if ($anim)
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".avi"`;
else
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".png"`;
print ("// "+$mediaFile+"\n");
system ("load "+$mediaFile);
}

global proc asPoseObjects (string $uiName, string $button,string $action)
{
string $cmd=`iconTextButton -q -c $button`;
string $buffer[],$buffer2[];
string $objAttr,$value;
tokenize $cmd "\"" $buffer;
$cmd=$buffer[1];
int $numTok=`tokenize $cmd ";" $buffer`;
int $showWarning;
string $warningMsg="The following objects can not be found:";
if ($action==" select -add")
select -cl;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	tokenize $objAttr "." $buffer2;
	$obj=$buffer2[0];
	if ($action!=" select -add")
		$obj=$objAttr;
	$obj=`asPoserResolveNameSpace $uiName $obj`;
	if (`objExists $obj`)
		eval ($action+" "+$obj);
	else
		{
		$showWarning=1;
		$warningMsg+=$obj+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asMirrorOptions (string $uiName)
{
if (`asHotKeyCheck ("asMirrorOptions \"\"")`) return;

if (`window -q -ex asMirrorOptions`)
	deleteUI asMirrorOptions;
window -t "Mirror Options" asMirrorOptions;
columnLayout -adj 1;
	separator -h 25 -st "none";
	rowLayout -nc 4 -cw 1 40;
		text -l "side:";
		radioCollection asMOSideRadioCollection;
		radioButton -label "Swap" asMOSideFlip;
		radioButton -label "Right To Left" asMOSideR2L;
		radioButton -label "Left To Right" asMOSideL2R;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "axis:";
		radioCollection asMOAxisRadioCollection;
		radioButton -label "X" asMOAxisX;
		radioButton -label "Y" asMOAxisY;
		radioButton -label "Z" asMOAxisZ;
		radioCollection -e -sl "asMOAxisX" asMOAxisRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "space:";
		radioCollection asMOSpaceRadioCollection;
		radioButton -label "World" asMOSpaceWorld;
		radioButton -label "Main" asMOSpaceMain;
		radioButton -label "RootX_M" asMOSpaceCenter;
		radioCollection -e -sl "asMOSpaceWorld" asMOSpaceRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "control:";
		radioCollection asMOSelOnlyRadioCollection;
		radioButton -label "All" asMOSelOnlyAll;
		radioButton -label "Selected" asMOSelOnlySel;
		radioCollection -e -sl "asMOSelOnlyAll" asMOSelOnlyRadioCollection;
		setParent..;

separator -st "none" -h 25;
button -w 100 -l "Mirror" -c ("asMirror \""+$uiName+"\"");
showWindow;

string $optionVars[]={"asMOSide","asMOSpace","asMOAxis","asMOSelOnly"};
string $cia[];
string $radioCollection,$selected,$optionVarString;
for ($i=0;$i<size($optionVars);$i++)
	{
	$radioCollection=$optionVars[$i]+"RadioCollection";
	$cia=`radioCollection -q -cia $radioCollection`;
	$selected=$cia[0];
	if (`optionVar -ex $optionVars[$i]`)
		{
		$optionVarString=`optionVar -q $optionVars[$i]`;
		for ($y=0;$y<size($cia);$y++)
			if (`gmatch $cia[$y] ("*"+$optionVarString)`)
				$selected=`optionVar -q $optionVars[$i]`;
		}
	radioCollection -e -sl $selected $radioCollection;
	}
}

global proc asMirror (string $uiName)
{
string $side="asMOSideR2L";
string $space="asMOSpaceMain";
string $axis="asMOAxisX";
string $selOnly="asMOSelOnlyAll";
string $sel[]=`ls -sl`;
string $nameSpace;

string $controlSets[],$sortedControls[];

if (`asHotKeyCheck ("asMirror \"\"")`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

if (!size($controlSets))
	error "No controlSets detected. select a controller";

string $controls[]=`sets -q $controlSets`;
$controls=`sort $controls`;//first alphanum sort, so e.g.IKhybridSpline1 comes before 2

if (`window -q -ex asMirrorOptions`)
	{
	$side=`radioCollection -q -sl asMOSideRadioCollection`;
	$space=`radioCollection -q -sl asMOSpaceRadioCollection`;
	$axis=`radioCollection -q -sl asMOAxisRadioCollection`;
	$selOnly=`radioCollection -q -sl asMOSelOnlyRadioCollection`;
	optionVar -sv asMOSide $side;
	optionVar -sv asMOSpace $space;
	optionVar -sv asMOAxis $axis;
	optionVar -sv asMOSelOnly $selOnly;
	}
if (`optionVar -ex asMOSide`)
	$side=`optionVar -q asMOSide`;
if (`optionVar -ex asMOSpace`)
	$space=`optionVar -q asMOSpace`;
if (`optionVar -ex asMOAxis`)
	$axis=`optionVar -q asMOAxis`;
if (`optionVar -ex asMOSelOnly`)
	$selOnly=`optionVar -q asMOSelOnly`;

for ($i=0;$i<size($controls);$i++)
	if ($controls[$i]==($nameSpace+"Main"))
		$sortedControls={($nameSpace+"Main"),($nameSpace+"RootX_M"),($nameSpace+"RootExtraX_M")};

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IKhybrid*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Spine*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IKSpline*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Leg*")` || `gmatch $controls[$i] ($nameSpace+"IK*Arm*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Pole*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Roll*Heel*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Roll*ToesEnd*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Roll*Toes*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($x=10;$x>0;$x--)
	for ($i=0;$i<size($controls);$i++)
		if (`gmatch $controls[$i] ($nameSpace+"Roll*"+$x+"*")`)
			$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Toes_*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (!`stringArrayCount $controls[$i] $sortedControls`)
		$sortedControls[size($sortedControls)]=$controls[$i];

$controls=$sortedControls;
if ($selOnly=="asMOSelOnlySel")
	$controls=$sel;
string $allKeyableAttrs[],$tempString[];
string $source,$dest,$destAttr,$cmd,$loc1,$loc2;
float $pos[3],$rot[3],$pos2[3],$rot2[3],$wsScales[3];
int $wsXform[];
int $flip,$isFaceControl,$isClusterControl,$isClusterLocalOrientControl,$wsXformAttr;
string $flipAxis,$t0;
if ($axis=="asMOAxisX")
	{$flipAxis="X";$t0="tx";}
if ($axis=="asMOAxisY")
	{$flipAxis="Y";$t0="ty";}
if ($axis=="asMOAxisZ")
	{$flipAxis="Z";$t0="tz";}

createNode -n flipGroup transform;
if ($space=="asMOSpaceCenter")
	parent flipGroup ($nameSpace+"RootX_M");
if ($space=="asMOSpaceMain")
	if (`objExists ($nameSpace+"Main")`)
		parent flipGroup ($nameSpace+"Main");
xform -os -t 0 0 0 -ro 0 0 0 flipGroup;
if ($space=="asMOSpaceCenter" || $space=="asMOSpaceMain")
	if (`objExists ($nameSpace+"Main")`)
		parent -w flipGroup;
for ($i=0;$i<size($controls);$i++)
	{
	if ($side!="asMOSideFlip")
		if (`gmatch $controls[$i] "*_M"` || `gmatch $controls[$i] "*Main"`)
			continue;
	if ($side=="asMOSideR2L")
		{
		if (`gmatch $controls[$i] "*_L"`)
			continue;
		$dest=`substitute "_R" $controls[$i] "_L"`;
		}
	else if ($side=="asMOSideL2R")
		{
		if (`gmatch $controls[$i] "*_R"`)
			continue;
		$dest=`substitute "_L" $controls[$i] "_R"`;
		}
	else if ($side=="asMOSideFlip")
		{
		if (!`gmatch $controls[$i] "*_L"` && !`gmatch $controls[$i] "*_R"` && !`gmatch $controls[$i] "*_M"`)
			continue;
		if (`gmatch $controls[$i] "*FKExtraSpine1_M"`)
			continue;
		if (`gmatch $controls[$i] "*_L"`)
			$dest=`substitute "_L" $controls[$i] "_R"`;
		if (`gmatch $controls[$i] "*_R"`)
			$dest=`substitute "_R" $controls[$i] "_L"`;
		if (`gmatch $controls[$i] "*_M"`)
			$dest=$controls[$i];
		}
	if (!`objExists $dest`)
		continue;
	$isFaceControl=0;
	if (`objExists ($nameSpace+"FaceControlSet")`)
		if (`sets -im ($nameSpace+"FaceControlSet") $controls[$i]`)
			$isFaceControl=1;
	$isClusterControl=$isClusterLocalOrientControl=0;
	$tempString=`ls -l $controls[$i]`;
	if (`gmatch $tempString[0] "*CustomSystem|*"`)
		$isClusterControl=1;
	if ($isClusterControl)
		if (`attributeExists localOrient $controls[$i]`)
			$isClusterLocalOrientControl=`getAttr ($controls[$i]+".localOrient")`;
	$source=$controls[$i];
	$allKeyableAttrs=`listAttr -k -m -sn $controls[$i]`;
	for ($y=0;$y<size($allKeyableAttrs);$y++)
		{
		$destAttr=$allKeyableAttrs[$y];
		if ($destAttr=="v") continue;
		if (!`attributeExists $allKeyableAttrs[$y] $dest`) continue;//no matching attr on other side
		if			(`gmatch $destAttr "*_R*"`) $destAttr=`substitute "_R" $destAttr "_L"`;
		else if (`gmatch $destAttr "*_L*"`) $destAttr=`substitute "_L" $destAttr "_R"`;		
		$flip=1;

		// due to new //Mirrored translation, this now only applies to old rigs, detected by non-ws -1 scale
		$wsScales=`xform -q -ws -s $dest`;
		if ($wsScales[2]>0)
			{
			if (`gmatch $controls[$i] ($nameSpace+"FK*_L")` || `gmatch $controls[$i] ($nameSpace+"FK*_R")`
			 || `gmatch $controls[$i] ($nameSpace+"Bend*_L")` || `gmatch $controls[$i] ($nameSpace+"Bend*_R")`
			 || `attributeExists ikLocal $controls[$i]`
			 || $isClusterLocalOrientControl)
			 	{
			 	if ($destAttr=="tx" || $destAttr=="ty" || $destAttr=="tz")
			 		$flip=-1;
			 	}
			else
				if ($destAttr=="tz" || $destAttr=="rx" || $destAttr=="ry")
					$flip=-1;
			}

		if ($isFaceControl)
			$flip=1;
/*
		if (($controls[$i]==$nameSpace+"Eye_R" || $controls[$i]==$nameSpace+"Eye_L") && $destAttr== "ry")
			$flip=-1;//special case for eyes, as we dont need `crosseyed`
*/
		$wsXformAttr=0;
		if ($wsScales[2]>0)
			if (`gmatch $controls[$i] ($nameSpace+"IK*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")`
			|| `gmatch $controls[$i] ($nameSpace+"Roll*")`
			|| `gmatch $controls[$i] ($nameSpace+"RootX_M*")` || ($isClusterControl && !$isClusterLocalOrientControl))
				if ((!`gmatch $controls[$i] ($nameSpace+"IKLocal*")`) && !`attributeExists ikLocal $controls[$i]`)
					if (!`gmatch $controls[$i] ($nameSpace+"IKhybrid*")`)
//						if (!`gmatch $controls[$i] ($nameSpace+"IK*Toes*")`)
//							if (`getAttr ($controls[$i]+".rotateOrder")`==0)//other IK ctrls oriented as FK e.g. IKFingers1 on quadrupeds
								//changed to utilize the IKLocal attribute
								$wsXform[$i]=1;

		if (`gmatch $controls[$i] ($nameSpace+"Aim*")`)
			continue;
		if ($destAttr=="tx" || $destAttr=="ty" || $destAttr=="tz"
			||$destAttr=="rx" || $destAttr=="ry" || $destAttr=="rz")
			if ($wsXform[$i])
				$wsXformAttr=1;
		if (!$wsXformAttr)
			if (`getAttr -se ($dest+"."+$destAttr)`)
				$cmd+="setAttr "+$dest+"."+$destAttr+" "+(`getAttr ($source+"."+$allKeyableAttrs[$y])`*$flip)+";";
		}

	if ($wsXform[$i])
		{
		$tempString=`spaceLocator`;
		$loc1=$tempString[0];
		$tempString=`spaceLocator`;
		$loc2=$tempString[0];
		parent $loc2 $loc1;
		parent $loc1 $source;
		xform -os -t 0 0 0 -ro 0 0 0 $loc1;
		setAttr ($loc1+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ($loc2+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ("flipGroup.scale"+$flipAxis) 1;
		parent $loc1 flipGroup;
		setAttr ("flipGroup.scale"+$flipAxis) -1;
		setAttr ($loc1+".scaleX") -1;
		$pos=`xform -q -ws -t $loc2`;
		$rot=`xform -q -ws -ro $loc2`;
		$pos2=`getAttr ($source+".t")`;
		$rot2=`getAttr ($source+".r")`;
		$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" "+$dest+";";
		}

	if (`attributeExists "mirror" $controls[$i]`)
		setAttr ($controls[$i]+".mirror") 0;
	}
delete flipGroup;
if ($cmd!="")
	eval ($cmd);
select $sel;
}

global proc asGoToBuildPoseOptions (string $nameSpace, string $controlSet)
{
if (`objExists asGoToBuildPoseOptions`)
	delete asGoToBuildPoseOptions;
createNode -n asGoToBuildPoseOptions transform;
addAttr -ln nameSpace -dt "string" asGoToBuildPoseOptions;
setAttr -type "string" asGoToBuildPoseOptions.nameSpace $nameSpace;
addAttr -ln controlSet -dt "string" asGoToBuildPoseOptions;
setAttr -type "string" asGoToBuildPoseOptions.controlSet $controlSet;
asGoToBuildPose bodySetup;
}

global proc asGoToBuildPose (string $uiName)
{
int $ctrlButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
float $dv;
string $nameSpace,$m,$expString;
string $controlSets[],$failedCmds[];
string $sel[]=`ls -sl`;

if (`asHotKeyCheck "asGoToBuildPose \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

if (`objExists asGoToBuildPoseOptions`)
	{
	$nameSpace=`getAttr asGoToBuildPoseOptions.nameSpace`;
	$controlSets[0]=`getAttr asGoToBuildPoseOptions.controlSet`;
	delete asGoToBuildPoseOptions;
	}

string $buildPose="buildPose";
if (`gmatch $controlSets[0] "*FaceControlSet"`)
    $buildPose="faceBuildPose";

string $tempString[],$tempString2[],$buffer[];
string $setAttrCmd,$cmd;


$setAttrCmd=`getAttr ($nameSpace+$buildPose+".udAttr")`;
if (`attributeExists udExtraAttr ($nameSpace+$buildPose)`)
	$setAttrCmd+=`getAttr ($nameSpace+$buildPose+".udExtraAttr")`;
tokenize $setAttrCmd ";" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	$cmd=$tempString[$y];
	if ($cmd=="")
		continue;
	if ($nameSpace!="")
		{
		tokenize $cmd $buffer;
		if (`gmatch $cmd "xform*"`)
			$substituteWordNr=size($buffer)-1;
		else
			$substituteWordNr=1;
		$cmd="";
		for ($z=0;$z<size($buffer);$z++)
			{
			if ($z==$substituteWordNr)
				$cmd+=$nameSpace;
			$cmd+=$buffer[$z]+" ";
			}
		}
	if ($ctrlButton)
		if (`gmatch $cmd "*Main.*"`)
			continue;
	if (catchQuiet (`eval ($cmd)`))
		{
		warning ("Failed: "+$cmd+"\n");
		$failedCmds[size($failedCmds)]=$cmd;
		}
	}

//mh
if (`objExists ($nameSpace+"GRP_faceGUI")`)
	{
	$tempString=`listRelatives -ad -type transform ($nameSpace+"GRP_faceGUI")`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`gmatch $tempString[$i] "*CTRL_faceGUI*"`)//main top node comes with default offsets that should not reset
			continue;
		if (`gmatch $tempString[$i] "*CTRL_*"`)
			{
			$tempString2=`listAttr -k $tempString[$i]`;
			for ($y=0;$y<size($tempString2);$y++)
				{
				if (!`getAttr -se ($tempString[$i]+"."+$tempString2[$y])`)
					continue;
				$dv=0;
				if (`gmatch $tempString2[$y] "scale*"` || $tempString2[$y]=="visibility")
					$dv=1;
				setAttr ($tempString[$i]+"."+$tempString2[$y]) $dv;
				}
			}
		}
	}

//run
string $run,$fitTopNode,$objAttr;
for ($i=0;$i<size($controlSets);$i++)
	{
	if (`gmatch $controlSets[$i] "*ControlSet"`)
		if (`objExists ($nameSpace+"FitSkeleton")`)
			$fitTopNode=$nameSpace+"FitSkeleton";
	if (`gmatch $controlSets[$i] "*FaceControlSet"`)
		$fitTopNode=($nameSpace+"FaceFitSkeleton");
	}

//expressions (wheel & rollingBall)
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] "*WheelExpression_*"`)
		continue;
	$tempString2=`listConnections -s 0 -d 1 -type transform $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		if (!`attributeExists reset $tempString2[$y]`)
			continue;
		setAttr ($tempString2[$y]+".reset") 1;
		currentTime `currentTime -q`;
		setAttr ($tempString2[$y]+".reset") 0;
		}
	}

if (`objExists $fitTopNode`)
	if (`attributeExists "run" $fitTopNode`)
		{
		$run=`getAttr ($fitTopNode+".run")`;
		if ($run!="")
			{
			if ($nameSpace=="")
				catch (`eval ($run)`);
			else
				{
				tokenize $run ";" $tempString;
				for ($i=0;$i<size($tempString);$i++)
					{
					tokenize $tempString[$i] $tempString2;
					$objAttr=`substitute "\"" $tempString2[1] ""`;
					$objAttr=`substitute "\"" $objAttr ""`;
					$cmd=$tempString2[0]+" "+$nameSpace+$objAttr+" "+$tempString2[2]+";";
					catch (`eval ($cmd)`);
					}
				}
			}
		}

if (size($failedCmds) && ($uiName=="bodySetup" || $uiName=="faceSetup")) // not avaible from Selector/Picker as file is likly referenced-in
	{
	$m="The following commands failed,\n( Possibly these are controllers that have been removed)\nRemove these commands from the Pose-command ?\n\n";
	for ($i=0;$i<size($failedCmds);$i++)
		{
		$m+=$failedCmds[$i]+"\n";
		if ($i==25)
			{
			$m+="\n...And "+`size($failedCmds)`+" more..";
			break;
			}
		}
	if (`confirmDialog -t Confirm -m $m -b "Ok, Remove" -b "Cancel" -db "Ok"`=="Ok, Remove")
		asUpdatePoseAttributes;
	}
}

global proc asPoserupdateGridBlock (string $uiName, int $childNum)
{
string $existingPopUpMenus[]=`control -q -pma ($uiName+"IconTextButton"+$childNum)`;
for ($pop in $existingPopUpMenus)
	deleteUI $pop;

int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $button=$uiName+"IconTextButton"+$childNum;
string $viewCmd="asPoseView "+$uiName+" "+$childNum;
string $selectCmd="asPoseObjects "+$uiName+" "+$button+"\" select -add\"";
string $keyCmd="asPoseObjects "+$uiName+" "+$button+" setKeyframe";
string $linearKeyCmd="asPoseObjects "+$uiName+" "+$button+" \"setKeyframe -itt linear -ott linear\"";

popupMenu -p ($uiName+"IconTextButton"+$childNum);
	menuItem -l "View" -c $viewCmd;
	if (!$anim)
		{
		menuItem -d 1;
		menuItem -l "Select" -c $selectCmd;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		}
	if ($uiName=="asPoserDefault")
		{
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asPoserRename "+$childNum);
		menuItem -l "Remove Button" -c ("asPoserDeletePose "+$uiName+" "+$childNum);
		menuItem -l "Update icon" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 1 0");
		if ($anim)
			menuItem -l "Update movie" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 0 1");
		}
}

global proc string asPoserResolveNameSpace (string $uiName, string $obj)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asDynRemove (string $uiName)
{
string $sel[]=`ls -sl`;
string $dynAttrs[]={"blend","baseGoal","tipGoal","conserve"};
string $tempString[];
string $nameSpace,$dynObj,$restoreCmd;

if (`asHotKeyCheck "asDynRemove \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;

if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
for ($i=0;$i<size($sel);$i++)
	{
	$dynObj="dynamics"+`substitute ($nameSpace) $sel[$i] ""`;
	if(`objExists $dynObj`)
		{
		if (`attributeExists restoreCmd $dynObj`)
			$restoreCmd+=`getAttr ($dynObj+".restoreCmd")`;
		delete $dynObj;
		for ($y=0;$y<size($dynAttrs);$y++)
			if (`attributeExists $dynAttrs[$y] $sel[$i]`)
				deleteAttr ($sel[$i]+"."+$dynAttrs[$y]);
		$tempString=`listRelatives -c Dynamics`;
		if (!size($tempString))
			delete Dynamics;
		print ("// Dynamics for "+$sel[$i]+" removed\n");
		}
	else
		print ("// No dynamics for "+$sel[$i]+" found\n");
	}

if ($restoreCmd!="")
	{
	print "// restoring OPM (offsetParentMatrix) rig connections:\n";
	evalEcho ($restoreCmd);
	}
}

global proc asDynAddHairSystem (string $uiName)
{
float $pos[];
string $nameSpace,$offsetNode,$dynTopJoint;
string $sel[]=`ls -sl`;
string $tempString[],$allBefore[],$allAfter[];

if (`asHotKeyCheck "asDynAddHairSystem \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;

asDynAdd $uiName;
$tempString=`ls -sl`;
$ctrlWithDynAttrs=$tempString[0];
$name=`substitute $nameSpace $ctrlWithDynAttrs ""`;
$dynTopNode="dynamics"+$name;

$tempString=`listRelatives -c -type transform $dynTopNode`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Offset"`)
		$offsetNode=$tempString[$i];

$tempString=`listRelatives -c -type joint$offsetNode`;
$dynTopJoint=$tempString[0];

delete ("DynCurveSoft"+$name);
select ("DynCurve"+$name);
$allBefore=`ls -as`;
makeCurvesDynamic 2 { "1", "0", "1", "1", "0"};
$allAfter=`ls -as`;
select $allAfter;
select -d $allBefore;
$tempString=`ls -sl`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "hairSystem[0-9]"`) rename $tempString[$i] ("hairSystem"+$name);
	if (`gmatch $tempString[$i] "nucleus*"`) rename $tempString[$i] ("nucleus"+$name);
	if (`gmatch $tempString[$i] "hairSystem[0-9]OutputCurves"`) rename $tempString[$i] ("hairSystemOutputCurves"+$name);
	}
$tempString=`listRelatives -c -type transform ("hairSystemOutputCurves"+$name)`;
rename $tempString[0] ("hair"+$name);
$tempString=`listRelatives -c -type transform $dynTopNode`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "follicle*"`) rename $tempString[$i] ("follicle"+$name);

parent ("hairSystem"+$name) ("nucleus"+$name) ("hair"+$name) $dynTopNode;
parent $dynTopJoint $dynTopNode;
parent ("follicle"+$name) $dynTopJoint $offsetNode;
delete ("hairSystemOutputCurves"+$name);

setAttr ("hairSystem"+$name+".overrideEnabled") 1;
setAttr ("hairSystem"+$name+".overrideColor") 17;

//access to various dynamics nodes,
//pointConstraint $ctrlWithDynAttrs ("nucleus"+$name);
parent ("DynCurve"+$name) $offsetNode;
setAttr ("follicle"+$name+".t") -type float3 0 0 0;
setAttr ("follicle"+$name+".r") -type float3 0 0 0;
delete `pointConstraint $ctrlWithDynAttrs ("follicle"+$name)`;
$pos=`getAttr ("follicle"+$name+".t")`;
move -r -os -wd 0 (`mag<<$pos[0],$pos[1],$pos[2]>>`*-0.5) 0 ("follicle"+$name);
//hairSystem Shape node under follicle transform, for easier access
select ("hairSystem"+$name);
pickWalk -d down;
select -add ("follicle"+$name);
parent -s;
delete ("hairSystem"+$name);

//deleting Dynamics-Controllers
delete ("DynLocs"+$name);
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists baseGoal $sel[$i]`) deleteAttr ($sel[$i]+".baseGoal");
	if (`attributeExists tipGoal $sel[$i]`) deleteAttr ($sel[$i]+".tipGoal");
	if (`attributeExists conserve $sel[$i]`) deleteAttr ($sel[$i]+".conserve");
	}



setAttr ("follicle"+$name+".pointLock") 1;
connectAttr -f ("hair"+$name+".worldSpace[0]") ("DynIKCurve"+$name+".create");
currentTime 0;
select $ctrlWithDynAttrs;
}

global proc asDynAdd (string $uiName) 
{
int $numCv,$form,$spans,$degrees,$numChar,$opm;
int $jointDepth[];
float $pos[],$posA[],$posB[],$bbMin[],$bbMax[],$locScale[],$m[];
$m[0]=$m[5]=$m[10]=$m[15]=1;//idMatrix
string $sel[]=`ls -sl`;
string $selLong[]=`ls -sl -l`;
string $tempString[],$dynJoints[],$sorted[],$defJoints[],$dynJoints[],$deleteObjs[],$locs[],$defJointsCtrl[];
string $defJoint,$fitJoint,$side,$sideLess,$curveCmd,$name,$nameSpace,$dynTopNode,$parent,$restoreCmd;

if (`asHotKeyCheck "asDynAdd \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;

if (`attributeExists useOffsetParentMatrix ($nameSpace+"FitSkeleton")`)
	$opm=`getAttr ($nameSpace+"FitSkeleton.useOffsetParentMatrix")`;

//sort
if ($opm)
	{
	//opm hierarchy is flat, so use FitSkeleton for sorting
	for ($i=0;$i<size($sel);$i++)
		{
		$defJoint=`substitute ($nameSpace+"FK") $sel[$i] ($nameSpace)`;
		tokenize $defJoint "_" $tempString;
		$fitJoint=$tempString[0];
		for ($y=1;$y<size($tempString)-1;$y++)
			$fitJoint+="_"+$tempString[$y];
		if (!`objExists $fitJoint`)
			error ("Unable to find FitJoint for:\""+$sel[$i]+"\".\n");
		$tempString=`ls -l $fitJoint`;
		$jointDepth[$i]=`tokenize $tempString[0] "|" $tempString`;
		}
	for ($y=0;$y<9999;$y++)
		{
		for ($i=0;$i<size($sel);$i++)
			if ($jointDepth[$i]==$y)
				$sorted[size($sorted)]=$sel[$i];
		if (size($sorted)==size($sel))
			break;
		}
	}
else
	//sort by lenght of `long` name, to sort by parents befor children
	for ($y=0;$y<9999;$y++)
		{
		for ($i=0;$i<size($sel);$i++)
			if (size($selLong[$i])==$y)
				$sorted[size($sorted)]=$sel[$i];
		if (size($sorted)==size($sel))
			break;
		}

for ($i=0;$i<size($sorted);$i++)
	{
	$defJoint="";
	if (`gmatch $sorted[$i] ($nameSpace+"FK*")`)
		$defJoint=`substitute ($nameSpace+"FK") $sorted[$i] ($nameSpace)`;
	if (!`objExists $defJoint`)
		error ("Unable to find DeformJoint for:\""+$sorted[$i]+"\".\n");
	$defJoints[size($defJoints)]=$defJoint;
	$defJointsCtrl[size($defJointsCtrl)]=$sorted[$i];

	//include part joints
	$numChar=size($defJoint);
	$side=`substring $defJoint ($numChar-1) $numChar`;
	$sideLess=`substring $defJoint 1 ($numChar-2)`;
		for ($y=1;$y<99;$y++)
		{
		if (`objExists ($sideLess+"Part"+$y+$side)`)
			{
			$defJoints[size($defJoints)]=($sideLess+"Part"+$y+$side);
			//inbetween has "FK-Part-Ctrls" e.g. FKTail1Part2_M, but twist/bendy does not
			if (`objExists ("FK"+$sideLess+"Part"+$y+$side)`)
				$defJointsCtrl[size($defJointsCtrl)]=("FK"+$sideLess+"Part"+$y+$side);
			else
				$defJointsCtrl[size($defJointsCtrl)]=$sorted[$i];
			}
		else
			break;
		}
	}
//include `end joint`
$tempString=`listRelatives -c -type joint $defJoints[size($defJoints)-1]`;
if ($tempString[0]!="")
	{
	$defJoints[size($defJoints)]=$tempString[0];
	$defJointsCtrl[size($defJointsCtrl)]=$defJointsCtrl[size($defJointsCtrl)-1];
	}

$name=`substitute $nameSpace $defJointsCtrl[0] ""`;
$dynTopNode="dynamics"+$name;

if (!size($sel))
	error ("nothing selected");
if (`objExists $dynTopNode`)
	error ("Object \""+$dynTopNode+"\" already exists. Delete this first, if you wish to make a new one.");

$deleteObjs={("DynParticleArrayMapper"+$name),("DynParticleRamp"+$name),("DynIKEffector"+$name)};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists ($nameSpace+$deleteObjs[$i])`)
		delete ($nameSpace+$deleteObjs[$i]);

if (!`objExists "Dynamics"`)
	createNode -n Dynamics transform;
createNode -n $dynTopNode -p Dynamics transform;

$curveCmd="curve -d 1 ";
for ($i=0;$i<size($defJoints);$i++)
	{
	$pos=`xform -q -ws -t $defJoints[$i]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
	}
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] ("DynCurve"+$name);
parent ("DynCurve"+$name) $dynTopNode;

//soft
$tempString=`soft -d -g 1 -c ("DynCurve"+$name)`;
rename $tempString[0] ("DynParticle"+$name);
$tempString=`listRelatives -p ("DynParticle"+$name)`;
rename $tempString[0] ("DynCurveSoft"+$name);
rename ("copyOfDynCurve"+$name)  ("DynCurve"+$name);
parent ("DynCurveSoft"+$name) $dynTopNode;
setAttr ("DynCurve"+$name+".v") 0;
setAttr ("DynCurveSoft"+$name+".dispCV") 1;

//locs
createNode -n ("DynLocs"+$name) -p $dynTopNode transform;
for ($i=0;$i<size($defJoints);$i++)
	{
	$pos=`xform -q -ws -t $defJoints[$i]`;
	$locs[$i]=$defJoints[$i]+"Loc";
	spaceLocator -n $locs[$i];
	createNode -n ($locs[$i]+"Offset") -p ("DynLocs"+$name) transform;
	parent $locs[$i] ($locs[$i]+"Offset");
	xform -ws -t $pos[0] $pos[1] $pos[2] ($locs[$i]+"Offset");
	parentConstraint -mo $defJointsCtrl[$i] ($locs[$i]+"Offset");
	scaleConstraint -mo $defJointsCtrl[$i] ($locs[$i]+"Offset");
	$tempString=`listRelatives -s $defJointsCtrl[$i]`;
	$bbMin=`getAttr ($tempString[0]+".boundingBoxMin")`;
	$bbMax=`getAttr ($tempString[0]+".boundingBoxMax")`;
	$locScale[0]=$bbMax[0]-$bbMin[0];
	$locScale[1]=$bbMax[1]-$bbMin[1];
	$locScale[2]=$bbMax[2]-$bbMin[2];
	setAttr ($locs[$i]+"Shape.localScale") -type float3 ($locScale[0]/2.0) ($locScale[1]/2.0) ($locScale[2]/2.0);
	setAttr ($locs[$i]+"Shape.overrideEnabled") 1;
	setAttr ($locs[$i]+"Shape.overrideColor") 17;
	connectAttr ($locs[$i]+"Shape.worldPosition[0]") ("DynCurve"+$name+"Shape.controlPoints["+$i+"]");
	}

//$numCv
$form=`getAttr ("DynCurve"+$name+".form")`;
$spans=`getAttr ("DynCurve"+$name+".spans")`;
$degrees=`getAttr ("DynCurve"+$name+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

//mass
for ($i=0;$i<$numCv;$i++)
	{
	$massPP = (1-((1.0/$numCv)*$i));
	particle -e -or $i -at mass -fv $massPP ("DynParticle"+$name);
	}

//arrayMapper
$tempString=`arrayMapper -target ("DynParticle"+$name) -destAttr goalPP -inputV mass -type ramp`;
rename $tempString[0] ("DynParticleArrayMapper"+$name);

$tempString=`listConnections -s 1 -d 0 ("DynParticleArrayMapper"+$name+".computeNodeColor")`;
rename $tempString[0] ("DynParticleRamp"+$name);
removeMultiInstance -break true ("DynParticleRamp"+$name+".colorEntryList[1]");
setAttr ("DynParticleRamp"+$name+".colorEntryList[0].position") 0;
setAttr ("DynParticleRamp"+$name+".colorEntryList[1].position") 1;
setAttr ("DynParticleRamp"+$name+".colorEntryList[0].color") -type double3 0 0 0;
setAttr ("DynParticleRamp"+$name+".colorEntryList[1].color") -type double3 1 1 1;

if (!`attributeExists blend $sorted[0]`) addAttr -k 1 -ln blend -at double -min 0 -max 1 -dv 1 $sorted[0];
if (!`attributeExists baseGoal $sorted[0]`) addAttr -k 1 -ln baseGoal -at double -min 0 -max 1 -dv 1 $sorted[0];
if (!`attributeExists tipGoal $sorted[0]`) addAttr -k 1 -ln tipGoal -at double -min 0 -max 1 -dv 0.6 $sorted[0];
if (!`attributeExists conserve $sorted[0]`) addAttr -k 1 -ln conserve -at double -min 0 -max 1 -dv 0.75 $sorted[0];
connectAttr ($sorted[0]+".baseGoal") ("DynParticleArrayMapper"+$name+".maxValue");
connectAttr ($sorted[0]+".tipGoal") ("DynParticleArrayMapper"+$name+".minValue");
connectAttr ($sorted[0]+".conserve") ("DynParticle"+$name+".conserve");

//splineIK
createNode -n ($defJoints[0]+"Offset") -p $dynTopNode transform;
$tempString=`listRelatives -p $defJoints[0]`;
parentConstraint $tempString[0] ($defJoints[0]+"Offset");
scaleConstraint $tempString[0] ($defJoints[0]+"Offset");
//select $defJoints[0];
for ($i=0;$i<$numCv;$i++)
	{
	select $defJoints[$i];
	$dynJoints[$i]="dyn"+`substitute $nameSpace $defJoints[0] ""`+$i;
	joint -n $dynJoints[$i];
//	$pos=`xform -q -ws -t ("DynCurveSoft"+$name+".cv["+$i+"]")`;
//	xform -ws -t $pos[0] $pos[1] $pos[2] $dynJoints[$i];
	}
for ($i=0;$i<$numCv-1;$i++)
	parent $dynJoints[$i+1] $dynJoints[$i];
parent $dynJoints[0] ($defJoints[0]+"Offset");
$tempString=`ikHandle -n ("DynIKHandle"+$name) -ns 2 -sol ikSplineSolver -sj $dynJoints[0] -ee $dynJoints[size($dynJoints)-1]`;
rename $tempString[1] ("DynIKEffector"+$name);
string $ikCurve=`rename $tempString[2] ("DynIKCurve"+$name)`;
parent ("DynIKHandle"+$name) ("DynIKCurve"+$name) $dynTopNode;
connectAttr -f ("DynCurveSoft"+$name+".worldSpace[0]") ("DynIKCurve"+$name+".create");

//pairBlend
$parent=$defJoints[0]+"Offset";
for ($i=0;$i<size($defJoints);$i++)
	{
//	if ($opm && $i==size($defJoints)-1)
//		break;

	$tempString[0]=`pairBlend -nd $defJoints[$i] -at tx -at ty -at tz`;
	rename $tempString[0] ("parBlendT"+$dynJoints[$i]);
	if ($opm)
		;//skipping Translate for OPM for now
	else
		connectAttr -f ($dynJoints[$i]+".translate") ("parBlendT"+$dynJoints[$i]+".inTranslate2");
	connectAttr ($sorted[0]+".blend") ("parBlendT"+$dynJoints[$i]+".weight");

	$tempString[0]=`pairBlend -nd $defJoints[$i] -at rx -at ry -at rz`;
	rename $tempString[0] ("parBlendR"+$dynJoints[$i]);
	if ($opm)
		{
		parentConstraint $dynJoints[$i] $defJoints[$i];
		//delete the extra generated pairBlend
		$tempString=`listConnections -s 1 -d 0 ($defJoints[$i]+".tx")`;
		delete $tempString[0];
//		if ($i>0)
			connectAttr ($defJoints[$i]+"_parentConstraint1.constraintTranslate") ("parBlendT"+$dynJoints[$i]+".inTranslate2");
		connectAttr ($defJoints[$i]+"_parentConstraint1.constraintRotate") ("parBlendR"+$dynJoints[$i]+".inRotate2");
		}
	else
		connectAttr -f ($dynJoints[$i]+".rotate") ("parBlendR"+$dynJoints[$i]+".inRotate2");
	connectAttr ($sorted[0]+".blend") ("parBlendR"+$dynJoints[$i]+".weight");

	}

if ($restoreCmd!="")
	{
	addAttr -ln restoreCmd -dt "string" $dynTopNode;
	setAttr -type "string" ($dynTopNode+".restoreCmd") $restoreCmd;
	}

setAttr -l 1 ("DynIKHandle"+$name+".v") 0;

print "// Dynamics added.\n";
select $sorted[0];
}

global proc asDynSetInitialState (string $uiName)
{
if (`asHotKeyCheck "asDynSetInitialState \"\""`) return;
evalEcho saveInitialState -all;
}

global proc asDynSetInteractivePlayback (string $uiName)
{
if (`asHotKeyCheck "asDynSetInteractivePlayback \"\""`) return;
evalEcho InteractivePlayback;
}

global proc asParentAdd (string $uiName, int $extra)
{
string $sel[]=`ls -sl`;
string $child;
string $tempString[];

if (`asHotKeyCheck ("asParentAdd \"\" "+$extra)`) return;

if (size($sel)<2) error "Select at least 2 objects";

string $parent=$sel[size($sel)-1];
for ($i=0;$i<size($sel)-1;$i++)
	{
	$child=$sel[$i];
	if ($extra)
		{
		$tempString=`listRelatives -p $child`;
		if (`gmatch $tempString[0] "*Extra*"`)
			$child=$tempString[0];
		else
			print ("// No Extra control found for \""+$child+"\".\n");
		}
	$tempString=`parentConstraint -mo $parent $child`;
	parent -w $tempString[0];
	}
}

global proc string asFindFKIKCtrl (string $obj)
{
int $foundIK;
string $fkIkCtrl,$conditionNode;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];

if (`gmatch $obj "*FKIK*"`)
	return $obj;

$tempString[0]=$obj;
for ($y=0;$y<99;$y++)
	{
	$tempString=`listRelatives -p $tempString[0]`;
	if ($tempString[0]=="") 
		break;
	$tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
	if ($tempString2[0]=="")
		continue;
	if (`objectType $tempString2[0]`!="condition")
		continue;
	$tempString2=`listConnections -s 1 -d 0 ($tempString2[0]+".firstTerm")`;
	if ($tempString2[0]=="")
		continue;
	return $tempString2[0];
	}

//if not found above, check for shape connection
$tempString=`listRelatives -s $obj`;
if ($tempString[0]!="")
	{
	$tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
	if ($tempString2[0]!="")
		{
		if (`objectType $tempString2[0]`=="condition")//IKhybrid ctrl 
			$conditionNode=$tempString2[0];
		else if (`objectType $tempString2[0]`=="plusMinusAverage")//IKhybrid ctrl
			{
			$tempString3=`listConnections -s 1 -d 0 -scn 1 ($tempString2[0]+".input1D[0]")`;
			if (`objectType $tempString3[0]`=="condition")
				$conditionNode=$tempString3[0];
			}
		}

	if ($conditionNode!="")
		{
		$tempString4=`listConnections -s 1 -d 0 ($conditionNode+".firstTerm")`;
		if ($tempString4[0]!="")
			return $tempString4[0];
		}
	}

return $fkIkCtrl;
}

global proc asAutoSwitchFKIK ()
{
string $sel[]=`ls -sl`;
string $name,$nameSpace,$fkIkCtrl,$side,$ik2fk;
float $curFKIKBlend;
string $tempString[],$tempString2[],$fkIkCtrls[];

if (`asHotKeyCheck "asAutoSwitchFKIK"`) return;

for ($i=0;$i<size($sel);$i++)
	$fkIkCtrls[$i]=`asFindFKIKCtrl $sel[$i]`;

$fkIkCtrls=`stringArrayRemoveDuplicates $fkIkCtrls`;

if (size($fkIkCtrls)==0 || `stringArrayCount "" $fkIkCtrls`)
	error "First select a control that is part of FK/IK setup";

for ($i=0;$i<size($fkIkCtrls);$i++)
	{
	$nameSpace="";
	$fkIkCtrl="";
	$side="";
	$name=$fkIkCtrls[$i];
	tokenize $fkIkCtrls[$i] ":" $tempString;
	if (size($tempString)>1)
		{
		for ($y=0;$y<size($tempString)-1;$y++)
			$nameSpace+=$tempString[$y]+":";
		$name=$tempString[size($tempString)-1];
		}
	tokenize $name "_" $tempString;
	$fkIkCtrl=$tempString[0];
	$side="_"+$tempString[1];
	$curFKIKBlend=`getAttr ($fkIkCtrls[$i]+".FKIKBlend")`;
	if ($curFKIKBlend>0 && $curFKIKBlend<5) setAttr ($fkIkCtrls[$i]+".FKIKBlend") 0;
	if ($curFKIKBlend>5 && $curFKIKBlend<10) setAttr ($fkIkCtrls[$i]+".FKIKBlend") 10;
	if ($curFKIKBlend>5) $ik2fk="IK2FK";
	else $ik2fk="FK2IK";
	//    asSwitchFKIK $fkIkCtrls[$i] `substitute "FKIK" $fkIkCtrl ""` $side $ik2fk;
	asSwitchFKIK $nameSpace `substitute "FKIK" $fkIkCtrl ""` $side $ik2fk;
	//global proc asSwitchFKIK (string $nameSpace, string $IK, string $side, string $W2K)
	}
}

global proc asAutoSwitchPivot ()
{
string $target,$control,$extraControl;
string $sel[]=`ls -sl`;
string $tempString[];

if (`asHotKeyCheck "asAutoSwitchPivot"`) return;

if (size($sel)!=2)
	error "Select 1 target object + 1 control";
$target=$sel[0];
$control=$sel[1];

if (!`gmatch $control "*_*"` && `gmatch $target "*_*"`)//selection order was reversed
	{
	$target=$sel[1];
	$control=$sel[0];
	}
if (`gmatch $control "*Extra*"`)//extraControl was selected
	{
	$tempString=`listRelatives -c -type transform $control`;
	$control=$tempString[0];
	}
$tempString=`listRelatives -p $control`;
$extraControl=$tempString[0];
if (!`objExists $extraControl`)
	error ("parent of \""+$control+"\" is not a valid ExtraControl");
float $pos[]=`xform -q -ws -t $control`;
float $rot[]=`xform -q -ws -ro $control`;
float $extraPos[]=`xform -q -ws -t $extraControl`;
float $extraRot[]=`xform -q -ws -ro $extraControl`;
float $targetPos[]=`xform -q -ws -t $target`;
float $targetRot[]=`xform -q -ws -ro $target`;

//print "asAutoSwitchPivot;\n";

int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;
currentTime (`currentTime -q` -1);
setKeyframe ($extraControl+".t") ($extraControl+".r") ($control+".t") ($control+".r");

currentTime (`currentTime -q` +1);
xform -ws -t $targetPos[0] $targetPos[1] $targetPos[2] -ro $targetRot[0] $targetRot[1] $targetRot[2] $extraControl;
xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] $control;
setKeyframe ($extraControl+".t") ($extraControl+".r") ($control+".t") ($control+".r");

if ($autoKey)
	autoKeyframe -st 1;

select $extraControl;
print ("// \""+$extraControl+"\" aligned to \""+$target+"\".\n");
}

global proc asQuickIK ()
{
int $otherEndJointAssumed;
float $dist;
float $posA[],$posB[];
string $startJoint,$endJoint,$ctrlPrefix,$startJointParent,$rotateAxis,$name,$ctrl;
string $sel[]=`ls -sl`;
string $joints[],$tempString[],$chainJointsReverse[],$chainJoints[],$chainJointNames[];

if (`asHotKeyCheck "asQuickIK"`) return;

if (size($sel)!=2)
	error "Select Start control + End control";

for ($i=0;$i<2;$i++)
	{
	$joints[$i]=$sel[$i];
	$tempString[0]=`substitute "FK" $joints[$i] ""`;//Fk control
	if (`objExists $tempString[0]`)
		{
		$joints[$i]=$tempString[0];
		$ctrlPrefix="FK";
		}
	$tempString[0]=`substitute "_" $joints[$i] "Joint_"`;// Face control e.g tongue
	if (`objExists $tempString[0]`)
		{
		$joints[$i]=$tempString[0];
		$ctrlPrefix="";
		}
	}

$tempString=`listRelatives -ad -type joint $joints[0]`;
if (`stringArrayCount $joints[1] $tempString`)
	{
	$startJoint=$joints[0];
	$endJoint=$joints[1];
	}

$tempString=`listRelatives -ad -type joint $joints[1]`;
if (`stringArrayCount $joints[0] $tempString`)
	{
	$startJoint=$joints[1];
	$endJoint=$joints[0];
	}
if ($startJoint=="" || $endJoint=="")
	error "Unable to find Start & End joint for the IK, make sure to select 2 control that are in the same hierarchy.\n";

$name=`substituteAllString $startJoint ":" "_"`;
$tempString=`listRelatives -p $startJoint`;
$startJointParent=$tempString[0];

//if childJoint of $endJoint is a `actual` endJoint, then assume this was meant to be used.
$tempString=`listRelatives -ad -type joint $endJoint`;
if (size ($tempString)==1)
	{
	$endJoint=$tempString[0];
	$otherEndJointAssumed=1;
	}

//determine $chainJoints
$tempString=`ls -l $endJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$chainJointsReverse[size($chainJointsReverse)]=$tempString[$i];
	if ($tempString[$i]==$startJoint)
		break;
	}
for ($i=size($chainJointsReverse)-1;$i>-1;$i--)
	$chainJoints[size($chainJoints)]=$chainJointsReverse[$i];

for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ("QuickIKjoint_"+$chainJoints[$i])`)
		error ("Another QuickIK already using the Joint:\"QuickIKjoint_"+$chainJoints[$i]+"\"\n");

$rotateAxis="z";
if (`gmatch $startJoint "*Finger*"`)
	$rotateAxis="y";

print ("StartJoint: "+$startJoint+", EndJoint: "+$endJoint+"\n");
if (!`objExists QuickIK`)
	createNode -n QuickIK transform;
if (`objExists ("QuickIK_"+$name+"Group")`)
	delete ("QuickIK_"+$name+"Group");
createNode -n ("QuickIK_"+$name+"Group") -p $startJoint transform;
parent ("QuickIK_"+$name+"Group") QuickIK;

for ($i=0;$i<size($chainJoints);$i++)
	$chainJointNames[$i]=`substituteAllString $chainJoints[$i] ":" "_"`;

for ($i=0;$i<size($chainJoints);$i++)
	{
	select $chainJoints[$i];
	joint -n ("QuickIKjoint_"+$chainJointNames[$i]);
	setAttr ("QuickIKjoint_"+$chainJointNames[$i]+".rotateOrder") `getAttr ($chainJoints[$i]+".rotateOrder")`;
	if ($rotateAxis=="y")
		setAttr ("QuickIKjoint_"+$chainJointNames[$i]+".preferredAngle") -type float3 0 10 0;
	if ($i>0)
		parent ("QuickIKjoint_"+$chainJointNames[$i]) ("QuickIKjoint_"+$chainJointNames[$i-1]);
	}

parent ("QuickIKjoint_"+$name) ("QuickIK_"+$name+"Group");
parentConstraint -mo $startJointParent ("QuickIKjoint_"+$name);

$posA=`xform -q -ws -t $startJoint`;
$posB=`xform -q -ws -t $endJoint`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

spaceLocator -n ("QuickIK_"+$name);
parent ("QuickIK_"+$name) ("QuickIK_"+$name+"Group");
setAttr ("QuickIK_"+$name+"Shape.overrideEnabled") 1;
setAttr ("QuickIK_"+$name+"Shape.overrideColor") 13;
setAttr ("QuickIK_"+$name+"Shape.localScale") -type float3 ($dist/2.0) ($dist/2.0) ($dist/2.0);
duplicate -n ("QuickPoleVector_"+$name) ("QuickIK_"+$name);
setAttr ("QuickPoleVector_"+$name+"Shape.localScale") -type float3 ($dist/4.0) ($dist/4.0) ($dist/4.0);
xform -ws -t $posB[0] $posB[1] $posB[2] ("QuickIK_"+$name);

ikHandle -n ("QuickIK_"+$name+"Handle") -ns 2 -sol "ikRPsolver" -sj ("QuickIKjoint_"+$chainJointNames[0]) -ee ("QuickIKjoint_"+$chainJointNames[size($chainJointNames)-1]);
parent ("QuickIK_"+$name+"Handle") ("QuickIK_"+$name);
setAttr ("QuickIK_"+$name+"Handle.v") 0;

parent ("QuickPoleVector_"+$name) $startJoint;
xform -os -t 0 0 0 -ro 0 0 0 ("QuickPoleVector_"+$name);
if ($rotateAxis=="y")
	setAttr ("QuickPoleVector_"+$name+".tz") $dist;
if ($rotateAxis=="z")
	setAttr ("QuickPoleVector_"+$name+".ty") $dist;

//poleVector
poleVectorConstraint ("QuickPoleVector_"+$name) ("QuickIK_"+$name+"Handle");
$tempString[0]=`createNode annotationShape`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] ("QuickPoleAnnotation_"+$name);
setAttr ("QuickPoleAnnotation_"+$name+"Shape.overrideEnabled") 1;
setAttr ("QuickPoleAnnotation_"+$name+"Shape.overrideDisplayType") 2;
parent ("QuickPoleAnnotation_"+$name) ("QuickIK_"+$name);
xform -os -t 0 0 0 -ro 0 0 0  ("QuickPoleAnnotation_"+$name);
connectAttr ("QuickPoleVector_"+$name+"Shape.worldMatrix[0]") ("QuickPoleAnnotation_"+$name+"Shape.dagObjectMatrix[0]");
//move forward to match IkHandle pos
setAttr ("QuickPoleVector_"+$name+".tx") `getAttr ("QuickIK_"+$name+".tx")`;

//Offsets
createNode -n ("QuickIKOffset_"+$name) -p ("QuickIK_"+$name) transform;
parent ("QuickIKOffset_"+$name) ("QuickIK_"+$name+"Group");
parent ("QuickIK_"+$name) ("QuickIKOffset_"+$name);
createNode -n ("QuickPoleVectorOffset_"+$name) -p ("QuickPoleVector_"+$name) transform;
parent ("QuickPoleVectorOffset_"+$name) ("QuickIK_"+$name);
parent ("QuickPoleVector_"+$name) ("QuickPoleVectorOffset_"+$name);


//connect
for ($i=0;$i<size($chainJoints);$i++)
	{
	if ($i==(size($chainJoints)-1) && $otherEndJointAssumed)
		continue;
	if (`gmatch $chainJoints[$i] "*:*"`)//have nameSpace
		{
		tokenize $chainJoints[$i] ":" $tempString;
		$ctrl=$tempString[0]+":"+$ctrlPrefix+$tempString[1];
		}
	else
		$ctrl=$ctrlPrefix+$chainJoints[$i];
	if ($ctrlPrefix=="")
		$ctrl=`substitute "Joint" $chainJoints[$i] ""`;
	if (!`objExists $ctrl`)
		{
		warning ("Could not find controller:\""+$ctrl+"\"\n");
		continue;
		}
	orientConstraint ("QuickIKjoint_"+$chainJointNames[$i]) $ctrl;
	}

select ("QuickIK_"+$name);
}

global proc asSegmentScaleCompensate (string $uiName)
{
int $onOff;
string $onOffString;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $fkXJoints[];

$fkXJoints=`ls -type joint ($nameSpace+"FKX*")`;
for ($i=0;$i<size($fkXJoints);$i++)
	{
	if ($i==0)
		{
		$onOff=!`getAttr ($fkXJoints[$i]+".segmentScaleCompensate")`;
		if ($onOff==0) $onOffString="OFF";
		if ($onOff==1) $onOffString="ON";
		print ("// switching "+$onOffString+" segmentScaleCompensate.\n");
		}
	setAttr ($fkXJoints[$i]+".segmentScaleCompensate") $onOff;
	}
}


global proc asTwistFlipUI (string $uiName)
{
if (`asHotKeyCheck "asTwistFlipUI \"\""`) return;

if (`window -q -ex asTwistFlip`)
    deleteUI asTwistFlip;
window -t TwistFlip asTwistFlip;
columnLayout;
separator -h 5 -st none;
text -l "Sets the amount of X-rotation, before `flipping` occours";
text -l "(e.g. twisting of the wrist)\n";
text -l "Note for 360, Constraint-Caching is needed for reliable results";
separator -h 20 -st none;
rowLayout -nc 4;
	text -w 80 -l "X-rotation:";
	optionMenu asTwistFlipOptionMenu;
		menuItem -l "180";
		menuItem -l "360";
	separator -w 10;
	button -w 100 -l "Ok, Set" -c ("asTwistFlipSet \""+$uiName+"\" set");
	setParent..;
separator -h 10 -st none;
rowLayout -en 0 -nc 4 asTwistFlipCacheRowLayout;
	text -w 80 -l "Cache:";
	button -w 80 -l "Create" -c ("asTwistFlipSet \""+$uiName+"\" cacheCreate");
	separator -w 10 -st none;
	button -w 80 -l "Delete" -c ("asTwistFlipSet \""+$uiName+"\" cacheDelete");
showWindow;

//detect current option, and set OptionMenu accordingly
//removed since this can now be launched from shelf, and we do not choose $nameSpace until we execute
/*
string $twistConstraints[]=`ls -type parentConstraint ($nameSpace+"TwistBalancer*")`;
if (size($twistConstraints))
	if (`getAttr ($twistConstraints[0]+".interpType")`!=1)
		{
		optionMenu -e -v "360" asTwistFlipOptionMenu;
		rowLayout -e -en 1 asTwistFlipCacheRowLayout;
		}
*/
}

global proc asTwistFlipSet (string $uiName, string $action)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $asTwistFlipOption=`optionMenu -q -v asTwistFlipOptionMenu`;
int $interpType=1;
if ($asTwistFlipOption=="360")
	$interpType=0;
string $twistConstraints[]=`ls -type parentConstraint ($nameSpace+"TwistBalancer*")`;
for ($i=0;$i<size($twistConstraints);$i++)
	{
	if ($action=="set")
		{
		setAttr ($twistConstraints[$i]+".interpType") $interpType;
		setAttr ($nameSpace+"MainTwistFlipSetRange.value") -type float3 (!$interpType) (!$interpType) (!$interpType);
		if (`rowLayout -q -ex asTwistFlipCacheRowLayout`)
			rowLayout -e -en (!$interpType) asTwistFlipCacheRowLayout;
		}
	if (`getAttr -s ($twistConstraints[$i]+".target")`<2)// otherwice Error:No cache is needed when there is only a single target. 
		continue;
	if ($action=="cacheCreate")
		evalEcho ("parentConstraint -e -cc "+`playbackOptions -q -min`+" "+`playbackOptions -q -max`+" "+$twistConstraints[$i]);
	if ($action=="cacheDelete")
		evalEcho ("parentConstraint -e -dc "+$twistConstraints[$i]);
	}
dgdirty -a;
refresh;
if ($nameSpace=="")
	print ("// Ok TwistFlip has been \""+$action+"\".\n");
else
	print ("// Ok TwistFlip ( for nameSpace:\""+$nameSpace+"\" ) has been \""+$action+"\".\n");
}

global proc asAnimBake (string $uiName)
{
string $nameSpace;
string $controlSets[],$tempString[],$FkIks[];

if (`asHotKeyCheck "asAnimBake \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

$tempString=`ls -type transform ($nameSpace+"FKIK*")`;
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists FKIKBlend $tempString[$i]`)
		$FkIks[size($FkIks)]=`substitute ($nameSpace+"FKIK") $tempString[$i] ""`;

if (`window -q -ex asAnimBake`)
    deleteUI asAnimBake;
window -t Bake -resizeToFitChildren 1 asAnimBake;
columnLayout;
	text -l "Bake:";
	optionMenu -cc asAnimBakeOptionChange asAnimBakeOptionMenu;
	//	menuItem -l "AnimationControls to BakeSkeleton";
	//	menuItem -l "MotionCapture to FKControls";
		menuItem -l "ExtraControls to Controls";
		menuItem -l "QuickIK to FKControls";
		for ($i=0;$i<size($FkIks);$i++)
			menuItem -l ("FK to IK : "+$FkIks[$i]);
		for ($i=0;$i<size($FkIks);$i++)
			menuItem -l ("IK to FK : "+$FkIks[$i]);
	separator -h 10;
	checkBox -en 0 -l "baking MotionCapture" -v `optionVar -q asBakingMoCap` -cc "optionVar -iv asBakingMoCap #1" asAnimBakingMoCapCheckBox;
	text -en 0 -l "(match Elbow/Knee rotation instead of position)" asAnimBakingMoCapText;
	separator -st none -h 10 -w 200;
	rowLayout -nc 2;
		separator -w 50 -st none;
		button -w 100 -l "Ok, Bake" -c ("asAnimBakeGo \""+$uiName+"\"");

showWindow;
}

global proc asAnimBakeOptionChange ()
{
int $enable;
string $bake=`optionMenu -q -v asAnimBakeOptionMenu`;
if (`gmatch $bake "FK to IK*"`)
	$enable=1;
checkBox -e -en $enable asAnimBakingMoCapCheckBox;
text -e -en $enable asAnimBakingMoCapText;
}

global proc asAnimBakeGo (string $uiName)
{
string $nameSpace,$limb;
string $bake=`optionMenu -q -v asAnimBakeOptionMenu`;
string $controlSets[];

$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

//if ($bake=="AnimationControls to BakeSkeleton")
//	asAnimBakeSkeleton $uiName;
if ($bake=="ExtraControls to Controls")
	asAnimBakeExtra $uiName;
if ($bake=="QuickIK to FKControls")
	asAnimBakeQuickIK $uiName;
if (`gmatch $bake "FK to IK : *"`)
	{
	$limb=`substitute "FK to IK : " $bake ""`;
	asAnimBakeFKIK $limb 1 $uiName;
	}
if (`gmatch $bake "IK to FK : *"`)
	{
	$limb=`substitute "IK to FK : " $bake ""`;
	asAnimBakeFKIK $limb 0 $uiName;
	}
}

global proc asAnimBakeExtra (string $uiName)
{
float $curTime=`currentTime -q`;
string $nameSpace;
string $tempString[],$tempString2[],$tempString3[],$controls[],$extraControls[],$bakeControls[],$animCurves[];

$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

$controls=`sets -q $controlSets`;
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"FKExtra*")` || `gmatch $controls[$i] ($nameSpace+"RootExtraX*")`)
		$extraControls[size($extraControls)]=$controls[$i];

for ($i=0;$i<size($extraControls);$i++)
	{
	$controls[$i]=`substitute "Extra" $extraControls[$i] ""`;
	$bakeControls[$i]=$extraControls[$i]+"BAKER";
	$tempString=`listRelatives -p $extraControls[$i]`;
	createNode -n $bakeControls[$i] -p $tempString[0] transform;
	setAttr ($bakeControls[$i]+".rotateOrder") `getAttr ($controls[$i]+".rotateOrder")`;
	$tempString=`listRelatives -c -type transform $extraControls[$i]`;
	parentConstraint $tempString[0] $bakeControls[$i];
	scaleConstraint $tempString[0] $bakeControls[$i];
	}

//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
currentTime $curTime;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";

//remove existing animation
for ($i=0;$i<size($extraControls);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $extraControls[$i]`;
	if (size($animCurves)) delete $animCurves;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $extraControls[$i];
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $controls[$i]`;
	if (size($animCurves)) delete $animCurves;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $controls[$i];
	}
//asGoToBuildPose bodySetup;

//Use baked animCurves
for ($i=0;$i<size($extraControls);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $bakeControls[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		{
		$tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $animCurves[$y]`;
		tokenize $tempString[1] "[.]" $tempString2;
		connectAttr $tempString[0] ($controls[$i]+"."+$tempString2[1]);
		tokenize $tempString[0] "[.]" $tempString3;
		rename $tempString3[0] ($controls[$i]+"_"+$tempString2[1]);
		}
	}
delete $bakeControls;
}

global proc asAnimBakeQuickIK (string $uiName)
{
string $nameSpace;
string $controls[],$bakeControls[],$tempString[];

$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

$controls=`sets -q $controlSets`;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listConnections -type constraint $controls[$i]`;
	if (size($tempString))
		$bakeControls[size($bakeControls)]=$controls[$i];
	}

//Bake
select $bakeControls;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys true -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";

if (`objExists QuickIK`)
	delete QuickIK;
select -cl;
}

global proc asAnimBakeFKIK (string $limb, int $Fk2Ik, string $uiName)
{
global int $asBakeFKIK;
global string $gMainProgressBar;
int $autoKeyState=`autoKeyframe -q -state`;
int $numChar;
float $curTime=`currentTime -q`;
float $start=`playbackOptions -q -min`;
float $end=`playbackOptions -q -max`;
int $startInt=$start;
int $endInt=$end;
string $nameSpace,$side,$sideLessLimb;
string $controlSets[],$tempString[];
string $limbs[]={$limb};

//print command, for the user to easily turn this into a custom Mel command
print ("asAnimBakeFKIK \""+$limb+"\" "+$Fk2Ik+" \""+$uiName+"\";\n");

if (`gmatch $limb "*|*"`)
	tokenize $limb "|" $limbs;

$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

if (!$autoKeyState)
	autoKeyframe -state 1;

currentTime $start;
for ($y=0;$y<size($limbs);$y++)
	{
	if ($Fk2Ik)
		{
		setAttr ($nameSpace+"FKIK"+$limbs[$y]+".FKIKBlend") 0;
		asSwitchFK2IK $nameSpace {("FKIK"+$limbs[$y])}; 
		}
	else
		{
		setAttr ($nameSpace+"FKIK"+$limbs[$y]+".FKIKBlend") 10;
		asSwitchIK2FK $nameSpace {("FKIK"+$limbs[$y])};
		}
	}
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Baking" -bp -ii 1 -min $startInt -max ($endInt+1) $gMainProgressBar;
$asBakeFKIK=1;
for ($i=$start;$i<$end+1;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		$asBakeFKIK=1;
		error "Interrupted";
		}
	currentTime $i;
	for ($y=0;$y<size($limbs);$y++)
		{
		$numChar=size($limbs[$y]);
		$side=`substring $limbs[$y] ($numChar-1) $numChar`;
		$sideLessLimb=`substring $limbs[$y] 1 ($numChar-2)`;
		if ($Fk2Ik)
			asAlignFKIK $nameSpace $sideLessLimb $side FK2IK;
		else
			asAlignFKIK $nameSpace $sideLessLimb $side IK2FK;
		}
	}
currentTime $curTime;
$asBakeFKIK=0;
if (!$autoKeyState)
	autoKeyframe -state 0;
}

global proc asCreateMoCap (string $uiName)
{
string $sel[]=`ls -sl`;
string $deformJoints[],$keyDeformJoints[],$tempString[],$tempString2[],$parent[],$names[],$extra[];
string $extr;
string $nameSpace;
if (`optionMenu -q -ex ($uiName+"OptionMenu")`)
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
float $charHeight=`getAttr ($nameSpace+"Main.height")`;
if (`objExists ($nameSpace+"MoCap")`)
	error "MoCap skeleton already exists !";
if (!`objExists ($nameSpace+"Main")`)
	error "No AdvancedSKeleton In Scene!";
if (!`objExists ($nameSpace+"HipSwingerStabilizerTarget2")`)
	{
	string $dialog=`confirmDialog -t "Confirm"
	-m "HipSwinger controllers needs \"stabilize\" attribute for Mocap.\nAdd this now ?"
	-b "OK" -b "Skip" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
	if ($dialog=="Cancel")
		return;
	if ($dialog=="OK")
		{
		//Added for MoCap to rotate Root joint
		duplicate -n ($nameSpace+"HipSwingerStabilizerTarget2") ($nameSpace+"HipSwingerStabilizerTarget");
		parent ($nameSpace+"HipSwingerStabilizerTarget2") ($nameSpace+"FKExtraRoot_M");
		orientConstraint ($nameSpace+"HipSwingerStabilizerTarget2") ($nameSpace+"HipSwingerStabilizer");
		if (!`attributeExists stabilize ($nameSpace+"HipSwinger_M")`)
			addAttr -k 1 -ln stabilize -at double -min 0 -max 10 -dv 10 ($nameSpace+"HipSwinger_M");
		if (`objExists ($nameSpace+"HipSwingerStabilizerUnitConversion")`) delete ($nameSpace+"HipSwingerStabilizerUnitConversion");
		createNode -n ($nameSpace+"HipSwingerStabilizerUnitConversion") unitConversion;
		setAttr ($nameSpace+"HipSwingerStabilizerUnitConversion.conversionFactor") 0.1;
		connectAttr ($nameSpace+"HipSwinger_M.stabilize") ($nameSpace+"HipSwingerStabilizerUnitConversion.input");
		connectAttr ($nameSpace+"HipSwingerStabilizerUnitConversion.output") ($nameSpace+"HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTargetW0");
		createNode -n ($nameSpace+"HipSwingerStabilizerReverse") reverse;
		connectAttr ($nameSpace+"HipSwingerStabilizerUnitConversion.output") ($nameSpace+"HipSwingerStabilizerReverse.inputX");
		connectAttr ($nameSpace+"HipSwingerStabilizerReverse.outputX") ($nameSpace+"HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTarget2W1");
		}
	}

$deformJoints=`listRelatives -type joint -ad ($nameSpace+"DeformationSystem")`;
for ($a=$i=0;$a<size($deformJoints);$a++)
	{
	if (`gmatch $deformJoints[$a] "*Partial_*"`)
		continue;
	if (`gmatch $deformJoints[$a] "*_50"`)//same as *Partial_*, in rigs from v<5.9416
		continue;
	if (`gmatch $deformJoints[$a] "*Slider[0-9]*"`)
		continue;
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$a]`)
			continue;
	tokenize $deformJoints[$a] "_" $tempString;
	$extr=`substitute $nameSpace ("FKExtra"+$tempString[0]+"_"+$tempString[1]) ""`;
	if (`gmatch $deformJoints[$a] "*Part[0-9]*"`)
		continue;
	$keyDeformJoints[$i]=$deformJoints[$a];
	$extra[$i]=$extr;
	$tempString[0]=$keyDeformJoints[$i];
	for ($y=0;$y<99;$y++)
		{
		$tempString=`listRelatives -p $tempString[0]`;
		if (!`gmatch $tempString[0] "*Part[0-9]*"`)
			{
			tokenize $tempString[0] "_" $tempString;
			$parent[$i]=`substitute $nameSpace ($tempString[0]+"_MoCap_"+$tempString[1]) ""`;
			break;
			}
		}
	tokenize $keyDeformJoints[$i] "_" $tempString;
	string $name=$tempString[0]+"_MoCap_"+$tempString[1];
	if (!`stringArrayCount $name $names`)
		{
		$names[$i]=`substitute $nameSpace $name ""`;
		$i++;
		}
	}

string $topJoint;
for ($i=0;$i<size($names);$i++)
	{
	select -cl;
	joint -n $names[$i];
	if ($i==size($names)-1)
		{
		createNode -n "MoCap" transform;
		createNode -n "CenterOffset" transform;
		asAlign "CenterOffset" ($nameSpace+"RootExtraX_M") 1 0 0 0;
//		parent "MoCap" "Group";
		parent "CenterOffset" "MoCap";
		parent $names[$i] "CenterOffset";
		connectAttr ($names[$i]+".translate") ($nameSpace+"RootExtraX_M.translate");
		$topJoint=$names[$i];
		}
	asAlign $names[$i] $keyDeformJoints[$i] 1 1 1 0;
	setAttr ($names[$i]+".rotateOrder") 1;
	if (`objExists $extra[$i]`)
		setAttr ($extra[$i]+".rotateOrder") 1;
	}

for ($i=0;$i<size($names);$i++)
	{
	if (`objExists $parent[$i]`)
		parent $names[$i] $parent[$i];
	}
for ($i=0;$i<size($names);$i++)
	{
	if (`objExists ($names[$i]+"_blendColor")`)
		delete ($names[$i]+"_blendColor");
	createNode -n ($names[$i]+"_blendColor") blendColors;
	connectAttr ($names[$i]+".rotate") ($names[$i]+"_blendColor.color1");
	addAttr -k 1 -ln "blend" -at double -min 0 -max 1 -dv 1 $names[$i];
	connectAttr ($names[$i]+".blend") ($names[$i]+"_blendColor.blender");
	if (`objExists ($nameSpace+$extra[$i])`)
		connectAttr ($names[$i]+"_blendColor.output") ($nameSpace+$extra[$i]+".rotate");
	}
setAttr "MoCap.translateZ" ($charHeight/-3);
//orientConstraint -mo $topJoint "RootExtraX_M";
select $sel;
}

global proc asDeleteMocap (string $uiName)
{
if (`objExists MoCap`)
	delete MoCap;
delete `ls -type blendColors "*_MoCap_*_blendColor"`;
}

global proc asSetAllFK (string $nameSpace)
{
string $controlSetMembers[]=`sets -q ($nameSpace+"ControlSet")`;
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".FKIKBlend") 0;

if (`attributeExists stabilize ($nameSpace+"HipSwinger_M")`)
	setAttr ($nameSpace+"HipSwinger_M.stabilize") 0;
}

global proc asARKitAliasAttr ()
{
int $isArShapes;
string $newAttrName;
string $targets[];

if (!`objExists asFaceBS`)
	return;
$targets=`asBSGetTargets`;
for ($i=0;$i<size($targets);$i++)
	{
	if (`gmatch $targets[$i] "eyeBlinkLeft*"`)
		$isArShapes=1;
	if (`gmatch $targets[$i] "tongueOut*"`)
		$isArShapes=0;

	if (`gmatch $targets[$i] "*_M"`)
		$newAttrName=`substitute "_M" $targets[$i] ""`;
	else
		$newAttrName= $targets[$i]+"_M";
	aliasAttr $newAttrName ("asFaceBS."+$targets[$i]);
	}
}

global proc asConnectARKitUI (string $uiName)
{
string $blendShapes[]=`ls -type blendShape`;

if (`asHotKeyCheck "asConnectARKitUI \"\""`) return;
string $nameSpace=`asNameSpaceFromUIName $uiName`;

if (`window -q -ex asConnectARKitUI`)
	deleteUI asConnectARKitUI;
window -t "Connect ARKit" asConnectARKitUI;
columnLayout -adj 1;
text -l "Connect to FaceCap, Aquifer, iFacialMocap\nand other sofware that use Apple-ArKit";

separator -st none -h 10;
rowLayout -nc 3;
	button -c asARKChooseHeadRotNode "Choose Head Rotation Node";
	separator -st none -w 10;
	textField -ed 0 -tx "none" asConnectARKitHRTextField;
	setParent..;
separator -st none -h 5;
button -l "Connect Head Rotation" -c ("asARKConnectHeadRotation \""+$uiName+"\"");
separator -st none -h 5;
button -l "Disconnect Head Rotation" -c ("asARKDisconnectHeadRotation \""+$uiName+"\"");
separator -st none -h 40;

optionMenu -l "BlendShape Node" asConnectARKitBSOptionMenu;
for ($i=0;$i<size($blendShapes);$i++)
	{
	if (`gmatch $blendShapes[$i] ($nameSpace+"*asFace*")`
	 || `gmatch $blendShapes[$i] ($nameSpace+"*Close*BS*")`
	 || `gmatch $blendShapes[$i] ($nameSpace+"*SquintRightToLeft*")`)
		continue;
	menuItem -l $blendShapes[$i];
	}

separator -st none -h 20;
button -l "Connect" -c ("asConnectARKit \""+$uiName+"\"");
button -l "Disconnect" -c ("asDisconnectARKit \""+$uiName+"\"");
separator -st none -h 10;
button -l "bake" -c ("asBakeARKit \""+$uiName+"\"");
showWindow;
}

global proc asARKChooseHeadRotNode ()
{
string $sel[]=`ls -sl`;
textField -e -tx $sel[0] asConnectARKitHRTextField;
}

global proc asARKConnectHeadRotation (string $uiName)
{
int $autoKeyState=`autoKeyframe -q -state`;
string $arHeadRotObject=`textField -q -tx asConnectARKitHRTextField`;
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $tempString[];

if (!`objExists ($nameSpace+"FaceControlSet")`)
	error "No controlSets detected. select a controller";
if (!`objExists ($nameSpace+"FKHead_M")`)
	error ("Object \""+$nameSpace+"FKHead_M\" not found, you might not be using a AdvancedSkeleton body rig.\nManually constraint head rotation.");
if (!`objExists $arHeadRotObject`)
	error ("Object:\""+$arHeadRotObject+"\" not found, Choose the object that has the head rotation animation.");

if ($autoKeyState) autoKeyframe -state 0;
if (`objExists asARKHeadOrientation`) delete asARKHeadOrientation;
if (`objExists asARKHeadOrientation_orientConstraint`) delete asARKHeadOrientation_orientConstraint;
createNode -n asARKHeadOrientation -p ($nameSpace+"FKHead_M") transform;
setAttr ($arHeadRotObject+".r") -type float3 0 0 0;
parent asARKHeadOrientation $arHeadRotObject;
$tempString=`orientConstraint asARKHeadOrientation ($nameSpace+"FKHead_M")`;
rename asARKHeadOrientation_orientConstraint;
if ($autoKeyState) autoKeyframe -state 1;
dgdirty -a;
print ("// Head rotation connected.\n");
select -cl;
}

global proc asARKDisconnectHeadRotation (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;

if (!`objExists ($nameSpace+"FaceControlSet")`)
	error "No controlSets detected. select a controller";
if (`objExists asARKHeadOrientation_orientConstraint`)
	delete asARKHeadOrientation_orientConstraint;
setAttr ($nameSpace+"FKHead_M.r") -type float3 0 0 0;
}

global proc asConnectARKit (string $uiName)
{
asEnsureAsGetScriptLocation;//needs asDsSdk
int $createCtrlMode,$connectToCtrlMode,$snapChat;
int $autoKeyState=`autoKeyframe -q -state`;
float $v=1;
float $posA[],$posB[];
string $ctrl="ctrlARKit_M";
string $name,$altName,$side,$leftRight,$oppositeSide,$bs;
string $nameSpace=`asNameSpaceFromUIName $uiName`;

if (!`objExists ($nameSpace+"FaceControlSet")`)
	error "No controlSets detected. select a controller";

if (`attributeExists SnapChat FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.SnapChat`)
		{
		$snapChat=1;
		$ctrl="ctrlSnapChat_M";
		}

if (`objExists ($nameSpace+$ctrl)` && !`attributeExists eyeBlinkLeft ($nameSpace+$ctrl)`)
	$createCtrlMode=1;
if (`objExists ($nameSpace+$ctrl)` && `attributeExists eyeBlinkLeft ($nameSpace+$ctrl)`)
	$connectToCtrlMode=1;

if ($snapChat)
	$createCtrlMode=1;

if ($createCtrlMode)
	{
	$bs=$nameSpace+$ctrl;
	addAttr -k 0 -ln createCtrlMode -at bool ($nameSpace+$ctrl);
	}
else
	{
	$bs=`optionMenu -q -v asConnectARKitBSOptionMenu`;
	if (!$connectToCtrlMode)
		if (`attributeExists RigType ($nameSpace+"FaceFitSkeleton")`)
			if (`getAttr ($nameSpace+"FaceFitSkeleton.RigType")`==1)
				error "Face Rig Type \"BlendShapes\" detected. To use Connect ARKit, you must build Face Rig Type \"Joints\".";
	if (!`objExists $bs`)
		error "Not a valid blendShape node";
	}

//ARKit shapes from https://developer.apple.com/documentation/arkit/arfaceanchor/blendshapelocation
string $arShapes[]={"eyeBlinkLeft","eyeLookDownLeft","eyeLookInLeft","eyeLookOutLeft","eyeLookUpLeft","eyeSquintLeft","eyeWideLeft",
									"eyeBlinkRight","eyeLookDownRight","eyeLookInRight","eyeLookOutRight","eyeLookUpRight","eyeSquintRight","eyeWideRight",
									"jawForward","jawLeft","jawRight","jawOpen","mouthClose","mouthFunnel","mouthPucker","mouthLeft","mouthRight",
									"mouthSmileLeft","mouthSmileRight","mouthFrownLeft","mouthFrownRight","mouthDimpleLeft","mouthDimpleRight",
									"mouthStretchLeft","mouthStretchRight","mouthRollLower","mouthRollUpper","mouthShrugLower","mouthShrugUpper",
									"mouthPressLeft","mouthPressRight","mouthLowerDownLeft","mouthLowerDownRight","mouthUpperUpLeft","mouthUpperUpRight",
									"browDownLeft","browDownRight","browInnerUp","browOuterUpLeft","browOuterUpRight","cheekPuff","cheekSquintLeft",
									"cheekSquintRight","noseSneerLeft","noseSneerRight","tongueOut"};

//SnapChat shapes from https://docs.snap.com/api/lens-studio/Classes/OtherClasses/#Expressions
string $scShapes[]={"EyeBlinkLeft","EyeDownLeft","EyeInLeft","EyeOutLeft","EyeUpLeft","EyeSquintLeft","EyeOpenLeft",
									"EyeBlinkRight","EyeDownRight","EyeInRight","EyeOutRight","EyeUpRight","EyeSquintRight","EyeOpenRight",
									"JawForward","JawLeft","JawRight","JawOpen","MouthClose","LipsFunnel","LipsPucker","MouthLeft","MouthRight",
									"MouthSmileLeft","MouthSmileRight","MouthFrownLeft","MouthFrownRight","MouthDimpleLeft","MouthDimpleRight",
									"MouthStretchLeft","MouthStretchRight","LowerLipClose","UpperLipClose","LowerLipRaise","UpperLipRaise",
									//"mouthPressLeft","mouthPressRight" Would go here
																													"LowerLipDownLeft","LowerLipDownRight","UpperLipUpLeft","UpperLipUpRight",
									"BrowsDownLeft","BrowsDownRight","BrowsUpCenter","BrowsUpLeft","BrowsUpRight","Puff","CheekSquintLeft",
									"CheekSquintRight","SneerLeft","SneerRight",
									"MouthUpLeft","MouthUpRight"};//these last 2 does not have ARKit equivalents

//SnapChat does not have equivalents for: "mouthPressLeft","mouthPressRight","tongueOut"
// and it has shapes that are not in ARKit: "MouthUpLeft","MouthUpRight"
// special Note: "mouthRollLower"->"LowerLipClose" && "mouthRollUpper"->"UpperLipClose"
if ($snapChat)
	$arShapes=`stringArrayRemove {"mouthPressLeft","mouthPressRight","tongueOut"} $arShapes`;

if ($createCtrlMode)
	for ($i=0;$i<size($arShapes);$i++)
		{
		$name=$arShapes[$i];
		if ($snapChat)
			$name=$scShapes[$i];
		$v=10;
		addAttr -k 1 -ln $name -at double -smn 0 -hsn 1 -smx 10 -hsx 1 $bs;
		asEnsureOutputBlendWeighted ($bs+"."+$name);
		}

if (!$createCtrlMode && !$connectToCtrlMode && !`objExists ARKitQuickConnecting`)
	createNode -n ARKitQuickConnecting transform;

currentTime 0;
if ($autoKeyState) autoKeyframe -state 0;
for ($i=0;$i<size($arShapes);$i++)
	{
	$name=$arShapes[$i];
	if ($snapChat)
		$name=$scShapes[$i];
	$attr=$name;
	$altName=`substitute "Right" $name "_R"`;
	$altName=`substitute "Left" $altName "_L"`;

	//some Apps rename the "Right" suffix to "_R" for some attributes (e.g FaceCap)
	if ((catchQuiet (`getAttr ($bs+"."+$name)`)) && (!catchQuiet (`getAttr ($bs+"."+$altName)`)))
		$attr=$altName;

	if ((catchQuiet (`getAttr ($bs+"."+$name)`)) && (catchQuiet (`getAttr ($bs+"."+$altName)`)))
		{
		print ("Missing ARKit BlendShapes target: "+($bs+"."+$altName)+"\n");
		continue;
		}

	setAttr ($bs+"."+$attr) 0;

	if ($connectToCtrlMode)
		{
		catch (`setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0  -cd ($bs+"."+$attr) ($nameSpace+$ctrl+"."+$name)`);
		catch (`setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 1 -cd ($bs+"."+$attr) ($nameSpace+$ctrl+"."+$name)`);
		continue;
		}

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1)  {$side="_R";$leftRight="Right";$oppositeSide="_L";}
		if ($b==-1) {$side="_L";$leftRight="Left";$oppositeSide="_R";}

		if ($arShapes[$i]=="eyeBlink"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".blink") $v 10;
		if ($arShapes[$i]=="eyeLookDown"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".ty") $v -1;
		if ($arShapes[$i]=="eyeLookIn"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".tx") $v (1*$b);
		if ($arShapes[$i]=="eyeLookOut"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".tx") $v (-1*$b);
		if ($arShapes[$i]=="eyeLookUp"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".ty") $v 1;
		if ($arShapes[$i]=="eyeSquint"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".squint") $v 10;
		if ($arShapes[$i]=="eyeWide"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".blink") $v -2;
		if ($arShapes[$i]=="mouthDimple"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".tx") $v 0.3;
		if ($arShapes[$i]=="browOuterUp"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlBrow"+$side+".outerUpDown") $v 7.5;
		if ($arShapes[$i]=="noseSneer"+$leftRight) asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlNose"+$side+".ty") $v 0.5;

		//AdvSkel has Center ctrl for these side attrs
		if ($arShapes[$i]=="mouth"+$leftRight)
			{
			if ($arShapes[$i]=="mouthRight") asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.tx") $v -1;
			if ($arShapes[$i]=="mouthLeft")  asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.tx") $v  1;
			}

		//Drive multiple attr
		if ($arShapes[$i]=="mouthSmile"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".tx") $v 0.75;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".ty") $v 0.75;
			}
		if ($arShapes[$i]=="mouthFrown"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".tx") $v  0.25;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".ty") $v -0.25;
			}
		if ($arShapes[$i]=="mouthStretch"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".tx") $v  0.5;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".ty") $v -0.5;
			}
//// Removed, since any ARKit attrs that are L or R and Drive Center ctrl, fails to detect and remove zero-set SDK`
		if ($arShapes[$i]=="mouthPressRight" || $arShapes[$i]=="mouthPressLeft")//common for l/r first, then one by one
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.upperSqueeze") $v 1.5;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.lowerSqueeze") $v  1.5;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKLipRegion_M.ty") $v 0.1;
			}

		if ($arShapes[$i]=="mouthPress"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouthCorner"+$side+".ty") $v 0.25;
//			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKupperLipA"+$side+".ty") $v 0.5;
//			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKlowerLipA"+$side+".ty") $v 0.5;
//			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKLip"+$side+".sy") $v 0.5;
			}
		if ($arShapes[$i]=="mouthLowerDown"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKlowerLipA"+$side+".ty") $v -0.4;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKlowerLip_M.ty") 10 -0.3;
			}
		if ($arShapes[$i]=="mouthUpperUp"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKupperLipA"+$side+".ty") 10 0.4;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKupperLip_M.ty") $v 0.3;
			}
		if ($arShapes[$i]=="browDown"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlBrow"+$side+".ty") $v -0.75;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlBrow"+$side+".squeeze") $v 7.5;
			}
		if ($arShapes[$i]=="cheekSquint"+$leftRight)
			{
			asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlEye"+$side+".squint") $v 3;
			asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKCheek"+$side+".ty") $v 0.1;
			}
		}

	//Middle shapes
	if (`attributeExists jawForward ctrlMouth_M`)//backwards compataqbility for rigs<v5.750
		{
		if ($arShapes[$i]=="jawForward") asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouth_M.jawForward") $v 5;
		if ($arShapes[$i]=="jawRight") asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouth_M.jawSide") $v -5;
		if ($arShapes[$i]=="jawLeft")  asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouth_M.jawSide") $v 5;
		}
	if ($arShapes[$i]=="jawOpen") asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouth_M.ty") $v -1;
	if ($arShapes[$i]=="mouthClose")//mixed with the opposite amount of JawOpen gives stickylips 
		{
		setAttr ($nameSpace+"ctrlMouth_M.ty") 0;
		$posA=`xform -q -ws -t ($nameSpace+"lowerLip_M")`;
		setAttr ($nameSpace+"ctrlMouth_M.ty") -1;
		$posB=`xform -q -ws -t ($nameSpace+"lowerLip_M")`;
		xform -ws -t $posB[0] ($posB[1]+($posA[1]-$posB[1])) $posB[2] ($nameSpace+"lowerLip_M");
		$posA=`getAttr ($nameSpace+"lowerLip_M.t")`;
		setAttr ($nameSpace+"ctrlMouth_M.ty") 0;
		setAttr ($nameSpace+"lowerLip_M.t") -type float3 0 0 0;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKlowerLip_M.ty") $v ($posA[1]/2.0);
		asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKupperLip_M.ty") $v ($posA[1]/-2.0);
		}
	if ($arShapes[$i]=="mouthPucker")
		{
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.upperPucker") $v 10;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.lowerPucker") $v 10;
		}
	if ($arShapes[$i]=="mouthFunnel")
		{
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.upperPucker") $v 10;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.lowerPucker") $v 10;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKupperLip_M.ty") $v 0.3;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKlowerLip_M.ty") $v -0.3;
		}
	if ($arShapes[$i]=="mouthRollUpper") asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.upperRoll") $v -5;
	if ($arShapes[$i]=="mouthRollLower") asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlLips_M.lowerRoll") $v -5;
	if ($arShapes[$i]=="mouthShrugUpper") asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKupperLip_M.ty") $v 0.3;
	if ($arShapes[$i]=="mouthShrugLower") asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKlowerLip_M.ty") $v 0.3;
	if ($arShapes[$i]=="browInnerUp")
		{
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlBrow_R.tx") $v 1;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlBrow_L.tx") $v 1;
		}
	if ($arShapes[$i]=="cheekPuff")
		{
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlCheek_R.tx") $v 0.4;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlCheek_L.tx") $v 0.4;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"ctrlMouth_M.tx") $v -0.2;
		}
	if ($arShapes[$i]=="tongueOut")
		{
		asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKTongue0_M.tx") $v 1.5;
		asDsSdk ($bs+"."+$attr) ($nameSpace+"SDKTongue0_M.rz") $v 15;
		}
	}
if ($autoKeyState) autoKeyframe -state 1;
dgdirty -a;
if (`objExists ARKitQuickConnecting`) delete ARKitQuickConnecting;
print ("// ARKit connected.\n");
select -cl;
}

global proc asDisconnectARKit (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $tempString[],$controls[];

if (!`objExists ($nameSpace+"FaceControlSet")`)
	error "No controlSets detected. select a controller";

$controls=`sets -q ($nameSpace+"FaceControlSet")`;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve $controls[$i]`;
	if (size($tempString)) delete $tempString;
	$tempString=`listConnections -s 1 -d 0 -type blendWeighted $controls[$i]`;
	if (size($tempString)) delete $tempString;
	}
asGoToBuildPoseOptions $nameSpace "FaceControlSet";
}

global proc asBakeARKit (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $controls[];

if (!`objExists ($nameSpace+"FaceControlSet")`)
	error "No controlSets detected. select a controller";

$controls=`sets -q ($nameSpace+"FaceControlSet")`;
if (`objExists ($nameSpace+"FKHead_M")`)
	$controls[size($controls)]=($nameSpace+"FKHead_M");
select -cl;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 0 -sparseAnimCurveBake false -controlPoints false -shape false $controls;
select $controls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
select -cl;
print ("// ARKit bake complete.\n");
}

global proc asConnectMocapX (string $uiName)
{
string $side,$leftRight,$LeftRight;
string $requiredObj[]={"MocapX"};

if (`asHotKeyCheck "asConnectMocapX \"\""`) return;
string $nameSpace=`asNameSpaceFromUIName $uiName`;

for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Required object:\""+$obj+"\" does not exists. Make sure MocapX is loaded and the MocapX node is created.");

createNode -n AdvancedSkeletonHeadOffset transform;
//setAttr AdvancedSkeletonHeadOffset.r -type float3 90 0 90;
orientConstraint -mo AdvancedSkeletonHeadOffset ($nameSpace+"FKHead_M");

setAttr ($nameSpace+"ctrlBox.limits") 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$leftRight="right";$LeftRight="Right";}
	if ($b==-1) {$side="_L";$leftRight="left";$LeftRight="Left";}

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX."+$leftRight+"EyeTransformRotateY") ($nameSpace+"ctrlEye"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 30 -cd ("MocapX."+$leftRight+"EyeTransformRotateY") ($nameSpace+"ctrlEye"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX."+$leftRight+"EyeTransformRotateX") ($nameSpace+"ctrlEye"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv -30 -cd ("MocapX."+$leftRight+"EyeTransformRotateX") ($nameSpace+"ctrlEye"+$side+".ty");

	setAttr ("ctrlEye"+$side+"_translateX.preInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateX.postInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateY.preInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateY.postInfinity") 4;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.eyeBlink"+$side) ($nameSpace+"ctrlEye"+$side+".blink");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 1 -cd ("MocapX.eyeBlink"+$side) ($nameSpace+"ctrlEye"+$side+".blink");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.browInnerUp ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.browInnerUp ($nameSpace+"EyeBrowInner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.browOuterUp"+$side) ($nameSpace+"EyeBrowOuter"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("MocapX.browOuterUp"+$side) ($nameSpace+"EyeBrowOuter"+$side+".ty");

	if (`attributeExists EyeBrowMid2Joint ($nameSpace+"EyeBrowOuter"+$side)`)
		setAttr ($nameSpace+"EyeBrowOuter"+$side+".EyeBrowMid2Joint") .75;
	if (`attributeExists EyeBrowMid1Joint ($nameSpace+"EyeBrowInner"+$side)`)
		setAttr ($nameSpace+"EyeBrowInner"+$side+".EyeBrowMid1Joint") .75;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.eyeSquint"+$side) ($nameSpace+"lowerLid"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("MocapX.eyeSquint"+$side) ($nameSpace+"lowerLid"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.eyeWide"+$side) ($nameSpace+"ctrlEye"+$side+".blink");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd ("MocapX.eyeWide"+$side) ($nameSpace+"ctrlEye"+$side+".blink");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.cheekSquint"+$side) ($nameSpace+"ctrlEye"+$side+".squint");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 3 -dv 1 -cd ("MocapX.cheekSquint"+$side) ($nameSpace+"ctrlEye"+$side+".squint");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.2 -dv 1 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawForward ($nameSpace+"Jaw_M.tz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.jawForward ($nameSpace+"Jaw_M.tz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawLeft ($nameSpace+"Jaw_M.tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.jawLeft ($nameSpace+"Jaw_M.tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawRight ($nameSpace+"Jaw_M.tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd MocapX.jawRight ($nameSpace+"Jaw_M.tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.3 -dv 1 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	if (`attributeExists sticky ($nameSpace+"Lip"+$side)`)
		{
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthClose ($nameSpace+"Lip"+$side+".sticky");
		setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 1 -cd MocapX.mouthClose ($nameSpace+"Lip"+$side+".sticky");
		}

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthSmile"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.75 -dv 1 -cd ("MocapX.mouthSmile"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthFrown"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.75 -dv 1 -cd ("MocapX.mouthFrown"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthDimple"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.75 -dv 1 -cd ("MocapX.mouthDimple"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".tx");

	if (`objExists ($nameSpace+"upperLipA"+$side)`) //does not exist for Simplified FaceSetup
		{
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLipA"+$side+".ty");
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLip_M.ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.2 -dv 1 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLip_M.ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLip_M.ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.2 -dv 1 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLip_M.ty");

//	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthPress"+$side) ?;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthStretch"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.75 -dv 1 -cd ("MocapX.mouthStretch"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	}

//setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthFunnel ?;

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthPucker ($nameSpace+"ctrlMouth_M.tx");
setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd MocapX.mouthPucker ($nameSpace+"ctrlMouth_M.tx");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawOpen ($nameSpace+"ctrlMouth_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v -2 -dv 1 -cd MocapX.jawOpen ($nameSpace+"ctrlMouth_M.ty");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthRollUpper ($nameSpace+"ctrlLips_M.upperRoll");
setDrivenKeyframe -itt "linear" -ott "linear" -v -5 -dv 1 -cd MocapX.mouthRollUpper ($nameSpace+"ctrlLips_M.upperRoll");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthRollLower ($nameSpace+"ctrlLips_M.lowerRoll");
setDrivenKeyframe -itt "linear" -ott "linear" -v -5 -dv 1 -cd MocapX.mouthRollLower ($nameSpace+"ctrlLips_M.lowerRoll");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthShrugUpper ($nameSpace+"upperLip_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd MocapX.mouthShrugUpper ($nameSpace+"upperLip_M.ty");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthShrugLower ($nameSpace+"lowerLip_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd MocapX.mouthShrugLower ($nameSpace+"lowerLip_M.ty");

connectAttr MocapX.transformRotateX AdvancedSkeletonHeadOffset.rx;
connectAttr MocapX.transformRotateY AdvancedSkeletonHeadOffset.ry;
connectAttr MocapX.transformRotateZ AdvancedSkeletonHeadOffset.rz;

print ("// MocapX connected.\n");
}

global proc asMetaHumanAnimatorUI (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;

if (`asHotKeyCheck "asMetaHumanAnimator \"\""`) return;

if (`window -q -ex asMetaHumanAnimatorUI`)
	deleteUI asMetaHumanAnimatorUI;
window -w 300 -h 150 -t "MetaHuman Animator" asMetaHumanAnimatorUI;
columnLayout;
text -m 0 -l $nameSpace asMetaHumanAnimatorNameSpaceText;
separator -st none -h 15;
rowLayout -nc 2;
	separator -st none -w 50;
	button -l "Connect Face Animation" -c asMetaHumanAnimatorConnect;
	setParent..;
separator -st none -h 15;
rowLayout -nc 3;
	text -l "Optional:";
	button -l "Connect Head Rotation" -c "asMetaHumanAnimatorConnectHead 0";
	button -l "Connect Head Translation" -c "asMetaHumanAnimatorConnectHead 1";
	setParent..;
separator -st none -h 15;
rowLayout -nc 4;
	separator -st none -w 50;
	button -l "Delete root" -c "delete root";
	separator -st none -w 10;
	button -l "Delete animation" -c asMetaHumanAnimatorDeleteAnimation;
	setParent..;
separator -st none -h 15;
rowLayout -nc 2;
	separator -st none -w 50;
	button -l "Bake to standard Face Controls" -c asMetaHumanAnimatorBake;
	setParent..;

showWindow;
}

global proc asMetaHumanAnimatorConnectHead (int $mode) 
{
float $height=10;
string $animCurve="root_HeadYaw";
string $a,$b;
string $as[]={"root_HeadRoll","root_HeadPitch","root_HeadYaw"};
string $bs[]={"FKHead_M.rotateX","FKHead_M.rotateY","FKHead_M.rotateZ"};
string $nameSpace=`text -q -l asMetaHumanAnimatorNameSpaceText`;
if ($mode==1)
	{
	$as={"root_HeadTranslationX","root_HeadTranslationY","root_HeadTranslationZ"};
	$bs={"FKHead_M.translateX","FKHead_M.translateY","FKHead_M.translateZ"};
	}

if (`attributeExists height ($nameSpace+"Main")`)
	$height=`getAttr ($nameSpace+"Main.height")`;

for ($i=0;$i<size($as);$i++)
	{
	$a=$as[$i];
	$b=$nameSpace+$bs[$i];
	if (!`objExists $a`) warning ("Not found:\""+$a+"\".\n");
	if (!`objExists $b`) warning ("Not found:\""+$b+"\".\n");
	if (`objExists $a` && `objExists $b`)
		{
		$animCurve=`substitute "[.]" $b"_"`;
		if (`objExists $animCurve`)
			delete $animCurve;
		duplicate -n $animCurve $a;
		if ($a=="root_HeadTranslationZ")
			scaleKey -iub false -index "0:99999" -ts 1 -tp 0 -fs 1 -fp 458 -vs -1 -vp 0 $animCurve;
		if ($mode==1)
			scaleKey -iub false -index "0:99999" -ts 1 -tp 0 -fs 1 -fp 458 -vs ($height/160.0) -vp 0 $animCurve;
		connectAttr ($animCurve+".output") $b;
		}
	}
}

global proc asMetaHumanAnimatorConnect ()
{
int $numConnected;
float $keyXValues[],$keyYValues[];
string $animCurve,$side,$a,$b,$target,$nonNsName;
string $tempString[];
string $requiredObj[]={"root"};
//string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $nameSpace=`text -q -l asMetaHumanAnimatorNameSpaceText`;

if (!`objExists ($nameSpace+"FRM_faceGUI")`)
	error ($nameSpace+"FRM_faceGUI not found. The rig does not have MetaHuman ControlPanel added.");

for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Required object:\""+$obj+"\" does not exists. Make sure a MetaHuman-Animator FBX-Animation file is imported.");

if (`objExists asMetaHumanAnimatorSideWaysControls`)
	delete asMetaHumanAnimatorSideWaysControls;
createNode -n asMetaHumanAnimatorSideWaysControls transform;

//$tempString=`ls -type animCurve "*_CTRL_*"`;
// UnKnown: eyeLowerLidDownL eyeLowerLidUpL eyeWidenL
// Skip: eyeParallelLookDirection eyePupilNarrowR eyeRelaxL eyeUpperLidUpL eyelashesDownINL headTiltLeftD headTurnDownD jawChinCompressL lookAtSwitch
// Skip as no equivalent in AS yet: jawClenchL
// Skip because can not find equi:    mouthLipsPullDL mouthLipsPullUL mouthLipsTightenUL tongueRoll(tongue cups) tongueRollUp/Down/Left/Right
// Skip, ignoring (seems static): mouthLipsStickyLPh1-3 neckSwallowPh1-5 neckThroatUp-Down neckThroatInhale-Exhale neckDigastricUp-Down noseWrinkleUpperL skullUnified teeth*
// Skip, as ASMetaHuman control appears to not be matching latest MH: mouthLipsThickInwardDL tongueThick/Thin
// Not found : Opposite of mouthLipsPushUL & mouthLipsPushDL
string $as[]={"browDown", "browLateral", "browRaiseIn","browRaiseOuter","earUp","eyeBlink","eyeFaceScrunch",    "eyeCheekRaise", "eyeLidPress",
	"eyeLookUp","eyeLookDown",      "eyeLookLeft",   "eyeLookRight",					       "eyeSquintInner", "jawBack",    "jawFwd",         "jawChinRaiseD", "jawChinRaiseU",
	"jawLeft",       "jawRight",       "jawOpen","jawOpenExtreme", "mouthCheekBlow","mouthCheekSuck","mouthCornerDepress","mouthCornerPull", "mouthDimple",
	"mouthCornerUp","mouthCornerDown",     "mouthCornerWide",         "mouthCornerNarrow",
	"mouthCornerSharpenU","mouthCornerRounderU","mouthCornerSharpenD","mouthCornerRounderD",
	"mouthUp","mouthDown","mouthLeft","mouthRight",
	"mouthFunnelU","mouthFunnelD","mouthLipsBlow","mouthLipsPress","mouthLipsPurseU","mouthLipsPurseD","mouthLipsPushU","mouthLipsPushD",
	"mouthLipsThickU","mouthLipsThinU","mouthLipsThickD","mouthLipsThinD","mouthLipsTogetherU","mouthLipsTogetherD","mouthUpperLipTowardsTeeth","mouthLowerLipTowardsTeeth",
	"mouthUpperLipBite","mouthLowerLipBite","mouthLowerLipDepress","mouthUpperLipRollIn","mouthUpperLipRollOut","mouthLowerLipRollIn","mouthLowerLipRollOut",
	"mouthUpperLipShiftLeft","mouthUpperLipShiftRight","mouthLowerLipShiftLeft","mouthLowerLipShiftRight","mouthPressU","mouthPressD",
	"mouthSharpCornerPull","mouthStickyUC","mouthStickyDC","mouthStickyUIN","mouthStickyDIN","mouthStickyUOUT","mouthStickyDOUT",
	"mouthStretch","mouthStretchLipsClose","mouthUpperLipRaise","mouthLipsTowardsU","mouthLipsTowardsD",
	"neckMastoidContract","neckStretch","noseNasolabialDeepen",
	"noseWrinkle","noseNostrilDepress","noseNostrilDilate","noseNostrilCompress",//"noseNostrilDilate","noseNostrilCompress"  //depress=-y Compress=-x Dialite=X  Y?="noseWrinkleL" !Nostril
	"tongueUp","tongueDown","tongueLeft","tongueRight",//tongue ctrl
	"tongueBendUp","tongueBendDown","tongueTwistLeft","tongueTwistRight",//tongue_bendTwist ctrl
	"tongueTipUp","tongueTipDown","tongueTipLeft","tongueTipRight",//tongue_tip ctrl
	"tongueIn","tongueOut","tongueWide","tongueNarrow","tonguePress"};

string $bs[]={"brow_down","brow_lateral","brow_raiseIn","brow_raiseOut","ear_up","eye_blink","eye_faceScrunch", "eye_cheekRaise","eye_lidPress",
	"eye",      "HolderEyeLookDown","eye.translateX","HolderEyeLookRight.translateX","eye_squintInner","jaw_fwdBack","HolderJawForward","jaw_ChinRaiseD","jaw_ChinRaiseU",
	"jaw.translateX","HolderJawRight","jaw",    "jaw_openExtreme","mouth_suckBlow","HolderMouthSuck","mouth_cornerDepress","mouth_cornerPull","mouth_dimple",
	"mouth_corner","HolderMouthCornerDown","mouth_corner.translateX","HolderMouthCornerNarrow.translateX",
	"mouth_cornerSharpnessU","HolderMouthCornerSharpnessU","mouth_cornerSharpnessD","HolderMouthCornerSharpnessD",
	"mouth","HolderMouthDown","mouth.translateX","HolderMouthRight",
	"mouth_funnelU","mouth_funnelD","mouth_lipsBlow","mouth_lipsPressU","mouth_purseU","mouth_purseD","mouth_pushPullU","mouth_pushPullD",
	"mouth_thicknessU","HolderMouthLipsThickU","mouth_thicknessD","HolderMouthLipsThickD","mouth_lipsTogetherU","mouth_lipsTogetherD","mouth_lipsTowardsTeethU","mouth_lipsTowardsTeethD",
	"mouth_lipBiteU","mouth_lipBiteD","mouth_lowerLipDepress","mouth_lipsRollU","HolderMouthUpperLipRollOut","mouth_lipsRollD","HolderMouthLowerLipRollOut",
	"mouth_lipShiftU","HolderMouthUpperLipShiftRight","mouth_lipShiftD","HolderMouthLowerLipShiftRight","mouth_pressU","mouth_pressD",
	"mouth_sharpCornerPull","mouth_stickyU","mouth_stickyD","mouth_stickyInnerU","mouth_stickyInnerD","mouth_stickyOuterU","mouth_stickyOuterD",
	"mouth_stretch","mouth_stretchLipsClose","mouth_upperLipRaise","mouth_towardsU","mouth_towardsD",
	"neck_mastoidContract","neck_stretch","nose_nasolabialDeepen",
	"nose","HolderNoseNostrilDepress","nose.translateX","HolderNoseNostrilCompress",
	"tongue_move","HolderTongueDown","tongue_move.translateX","HolderTongueRight",//tongue
	"tongue_bendTwist","HolderTongueBendDown","tongue_bendTwist.translateX","HolderTongueTwistRight",//tongue_bendTwist
	"tongue_tipMove","HolderTongueTipDown","tongue_tipMove.translateX","HolderTongueTipRight",
	"tongue_inOut","HolderTongueOut","tongue_wideNarrow","HolderTongueNarrow","tongue_press"};

for ($x=1;$x>-2;$x=$x-2)
	{
	if ($x==1)  $side="R";
	if ($x==-1) $side="L";

	if ($nameSpace!="") namespace -setNamespace $nameSpace;
	createNode -n ("CTRL_"+$side+"_HolderEyeLookDown") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderEyeLookRight") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthSuck") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthCornerDown") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthCornerNarrow") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthCornerSharpnessU") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthCornerSharpnessD") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthLipsThickU") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthLipsThickD") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthUpperLipRollOut") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderMouthLowerLipRollOut") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderNoseNostrilDepress") -p asMetaHumanAnimatorSideWaysControls transform;
	createNode -n ("CTRL_"+$side+"_HolderNoseNostrilCompress") -p asMetaHumanAnimatorSideWaysControls transform;
	if ($x==1)
		{
		createNode -n ("CTRL_C_HolderMouthDown") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderJawForward") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderJawRight") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderMouthRight") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderMouthUpperLipShiftRight") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderMouthLowerLipShiftRight") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueDown") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueBendDown") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueTwistRight") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueRight") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueOut") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueNarrow") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueTipDown") -p asMetaHumanAnimatorSideWaysControls transform;
		createNode -n ("CTRL_C_HolderTongueTipRight") -p asMetaHumanAnimatorSideWaysControls transform;
		}
	if ($nameSpace!="") namespace -setNamespace ":";

	for ($i=0;$i<size($as);$i++)
		{
		$a="root_CTRL_expressions_"+$as[$i]+$side;
		$b=$nameSpace+"CTRL_"+$side+"_"+$bs[$i];

		//could be center
		if (!`objExists $a` && `objExists ("root_CTRL_expressions_"+$as[$i])`)
			{
			if ($x== 1) {$a="root_CTRL_expressions_"+$as[$i];$b=$nameSpace+"CTRL_C_"+$bs[$i];}
			if ($x==-1) continue;
			}

		if (!`objExists $a`)
			{
			warning ("AnimationCurve :\""+$a+"\" not found");
			continue;
			}

		//default attr is ty
		if (!`gmatch $b "*[.]*"`)
			$b=$b+".translateY";

		if (!`objExists $b`)
			{
			warning ("Control-Attribute :\""+$b+"\" not found");
			continue;
			}
		//animCurve without nameSpace
		tokenize $b ":" $tempString;
		if (size($tempString)<2)
			$nonNsName=$tempString[0];
		else
			$nonNsName=$tempString[1];
		$animCurve=`substitute "[.]" $nonNsName "_"`;
		if (`objExists $animCurve`)
			delete $animCurve;
		duplicate -n $animCurve $a;
		if (!`getAttr -settable $b`)
			{
			warning ("Unable to connect animation-curve to: \""+$b+"\"");
			continue;
			}
		connectAttr ($animCurve+".output") $b;

		//special case, mixing single animCurves to Plus/Minus & MultiAxis attributes
		if (`gmatch $as[$i] "eyeLook*"` || $as[$i]=="jawBack" || $as[$i]=="jawFwd" || $as[$i]=="jawLeft" || $as[$i]=="jawRight"
			|| $as[$i]=="mouthUp" || $as[$i]=="mouthDown" || $as[$i]=="mouthCheekBlow" || $as[$i]=="mouthCheekSuck" || $as[$i]=="mouthLeft" || $as[$i]=="mouthRight"
			|| `gmatch $as[$i] "mouthCorner*"` || `gmatch $as[$i] "mouthLipsThick*"` || `gmatch $as[$i] "mouthLipsThin*"`
			|| `gmatch $as[$i] "mouth*LipRoll*"` || `gmatch $as[$i] "mouth*LipShiftRight*"` || `gmatch $as[$i] "noseNostril*"`
			|| `gmatch $as[$i] "tongue*"`)
			{
			$keyXValues=`keyframe -q -tc $animCurve`;
			$keyYValues=`keyframe -q -vc $animCurve`;
			for ($z=1;$z<size($keyXValues);$z++)
				if ($keyYValues[$z]<=0 && $keyYValues[($z+1)]<=0 && $keyYValues[($z-1)]<=0)//and next/prev key is zero
					cutKey -t $keyXValues[$z] $animCurve;
			if (!`objExists $animCurve`)
				continue;//all keys were at zero
			keyTangent -itt linear -ott linear $animCurve;

			if (`gmatch $as[$i] "*Down*"` || `gmatch $as[$i] "*Right*"` || $as[$i]=="jawFwd" || $as[$i]=="jawRight"
				|| $as[$i]=="mouthCheekSuck" || `gmatch $as[$i] "mouthCornerDown*"` || `gmatch $as[$i] "mouthCornerNarrow*"` || $as[$i]=="mouthRight"
				|| `gmatch $as[$i] "mouthCornerRounder*"` || `gmatch $as[$i] "mouthLipsThin*"` || `gmatch $as[$i] "mouth*LipRollOut"`
				|| `gmatch $as[$i] "mouth*LipShiftRight"` || $as[$i]=="noseNostrilDepress" || $as[$i]=="noseNostrilCompress"
				|| $as[$i]=="tongueDown" || $as[$i]=="tongueBendDown" || $as[$i]=="tongueRight" || $as[$i]=="tongueOut" || $as[$i]=="tongueNarrow"
				|| $as[$i]=="tongueTipDown" || $as[$i]=="tongueTipRight")
				{
				scaleKey -iub false -index "0:99999" -ts 1 -tp 0 -fs 1 -fp 458 -vs -1 -vp 0 $animCurve;
				selectKey -k $animCurve;
				copyKey;
				if (`gmatch $as[$i] "eyeLookDown*"`)  $target="CTRL_"+$side+"_eye_translateY";
				if (`gmatch $as[$i] "eyeLookRight*"`) $target="CTRL_"+$side+"_eye_translateX";
				if ($as[$i]=="jawFwd") $target="CTRL_C_jaw_fwdBack_translateY";
				if ($as[$i]=="jawRight") $target="CTRL_C_jaw_translateX";
				if ($as[$i]=="mouthRight") $target="CTRL_C_mouth_translateX";
				if ($as[$i]=="mouthDown") $target="CTRL_C_mouth_translateY";
				if ($as[$i]=="mouthCheekSuck") $target="CTRL_"+$side+"_mouth_suckBlow_translateY";
				if ($as[$i]=="mouthCornerDown") $target="CTRL_"+$side+"_mouth_corner_translateY";
				if ($as[$i]=="mouthCornerNarrow") $target="CTRL_"+$side+"_mouth_corner_translateX";
				if ($as[$i]=="mouthCornerRounderU") $target="CTRL_"+$side+"_mouth_cornerSharpnessU_translateY";
				if ($as[$i]=="mouthCornerRounderD") $target="CTRL_"+$side+"_mouth_cornerSharpnessD_translateY";
				if ($as[$i]=="mouthLipsThinU") $target="CTRL_"+$side+"_mouth_thicknessU_translateY";
				if ($as[$i]=="mouthLipsThinD") $target="CTRL_"+$side+"_mouth_thicknessD_translateY";
				if ($as[$i]=="mouthUpperLipRollOut") $target="CTRL_"+$side+"_mouth_lipsRollU_translateY";
				if ($as[$i]=="mouthLowerLipRollOut") $target="CTRL_"+$side+"_mouth_lipsRollD_translateY";
				if ($as[$i]=="mouthUpperLipShiftRight") $target="CTRL_C_mouth_lipShiftU_translateY";
				if ($as[$i]=="mouthLowerLipShiftRight") $target="CTRL_C_mouth_lipShiftD_translateY";
				if ($as[$i]=="noseNostrilDepress") $target="CTRL_"+$side+"_nose_translateY";
				if ($as[$i]=="noseNostrilCompress") $target="CTRL_"+$side+"_nose_translateX";
				if ($as[$i]=="tongueDown") $target="CTRL_C_tongue_move_translateY";
				if ($as[$i]=="tongueBendDown") $target="CTRL_C_tongue_bendTwist_translateY";
				if ($as[$i]=="tongueRight") $target="CTRL_C_tongue_move_translateX";
				if ($as[$i]=="tongueOut") $target="CTRL_C_tongue_inOut_translateY";
				if ($as[$i]=="tongueNarrow") $target="CTRL_C_tongue_wideNarrow_translateY";
				if ($as[$i]=="tongueTipDown") $target="CTRL_C_tongue_tipMove_translateY";
				if ($as[$i]=="tongueTipRight") $target="CTRL_C_tongue_tipMove_translateX";
				if (`objExists $target`)
					pasteKey -option merge -copies 1 -connect 0 -timeOffset 0 -floatOffset 0 -valueOffset 0 {$target};
				else
					warning ("Target animationCurve:\""+$target+"\" not found.");
				}
			}

		$numConnected++;
		}
	}

delete asMetaHumanAnimatorSideWaysControls;
select -cl;

print ("// MetaHumanAnimator animation copied ("+$numConnected+" animationCurves).\n");
}

global proc asMetaHumanAnimatorDeleteAnimation ()
{
int $num;
string $nameSpace=`text -q -l asMetaHumanAnimatorNameSpaceText`;
string $tempString[],$tempString2[];

$tempString=`listRelatives -ad -type transform ($nameSpace+"GRP_faceGUI")`;
if (`objExists ($nameSpace+"FKHead_M")`)
	$tempString[size($tempString)]=$nameSpace+"FKHead_M";
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`sets -im ($nameSpace+"FaceControlSet") $tempString[$i]` && $tempString[$i]!=$nameSpace+"FKHead_M")
		continue;
	$tempString2=`listConnections -s 1 -d 0 -scn 1 -type animCurveTU $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		delete $tempString2[$y];
		$num++;
		}
	}
asGoToBuildPoseOptions $nameSpace "FaceControlSet";
asGoToBuildPoseOptions $nameSpace "ControlSet";
print ("// "+$num+" animationCurves deleted.\n");
}

global proc asMetaHumanAnimatorBake ()
{
int $num,$secondaryDriven,$plugNr;
float $keyYValues[];
string $nameSpace=`text -q -l asMetaHumanAnimatorNameSpaceText`;
string $sdkXform,$bwOrig,$bwNew;
string $tempString[],$tempString2[],$tempString3[],$bakers[];
string $faceControlSetMembers[]=`sets -q ($nameSpace+"FaceControlSet")`;

if (`objExists asMetaHumanAnimatorBaker`)
	delete asMetaHumanAnimatorBaker;
createNode -n asMetaHumanAnimatorBaker transform;
asLockAttr asMetaHumanAnimatorBaker 1 1 1 1;
$faceControlSetMembers=`sort $faceControlSetMembers`;
for ($i=0;$i<size($faceControlSetMembers);$i++)
	{
	//find by SDK connections
	$sdkXform="";
	if (`gmatch $faceControlSetMembers[$i] ($nameSpace+"CTRL_*_*")`)
		continue;
	$tempString=`listRelatives -p $faceControlSetMembers[$i]`;
	if (`gmatch  $tempString[0] ($nameSpace+"SDK*")`)
		$sdkXform=$tempString[0];
	else
		{
		$tempString2=`listRelatives -p $tempString[0]`;
		if (`gmatch $tempString2[0] ($nameSpace+"SDK*")`)
			$sdkXform=$tempString2[0];
		}

	if ($sdkXform!="")
		{
		$tempString=`listConnections -s 1 -d 0 -type blendWeighted $sdkXform`;
//		if (`objExists ("bw"+$faceControlSetMembers[$i]+"_lipsTogether")`)//special case, a driven ud attr on a OnFace ctrl
//			$tempString[size($tempString)]="bw"+$faceControlSetMembers[$i]+"_lipsTogether";
		}
	else
		$tempString=`listConnections -s 0 -d 1 -type blendWeighted $faceControlSetMembers[$i]`;

	if (`attributeExists lipsTogether $faceControlSetMembers[$i]`)
		{
		$tempString2=`listConnections -s 0 -d 1 -type blendWeighted $faceControlSetMembers[$i]`;
		$tempString=`stringArrayCatenate $tempString $tempString2`;
		}

	for ($y=0;$y<size($tempString);$y++)
		{
		$bwOrig=$tempString[$y];
		$bwNew=$bwOrig+"_NEW";
		createNode -n ("BAKER"+$bwOrig) -p asMetaHumanAnimatorBaker transform;
		if (!`objExists $bwNew`)
			{
			$plugNr=0;
			createNode -n $bwNew blendWeighted;
			connectAttr ($bwNew+".output") ("BAKER"+$bwOrig+".tx");
			}
		$tempString2=`listConnections -s 1 -d 0 -scn 1 -type animCurve $tempString[$y]`;//find any `secondary` driven
		for ($z=0;$z<size($tempString2);$z++)
			{
			$secondaryDriven=0;
			$tempString3=`listConnections -s 1 -d 0 -scn 1 -type blendWeighted $tempString2[$z]`;
			for ($aa=0;$aa<size($tempString3);$aa++)
				{
				if (!`gmatch $tempString3[$aa] ($nameSpace+"bwCTRL_*")` && !`gmatch $tempString3[$aa] "*Emotions*"`
				 && !`gmatch $tempString3[$aa] "*Phonemes*"` && !`gmatch $tempString3[$aa] "*bwSmilePull*"`)
					$secondaryDriven=1;
				if (!$secondaryDriven)
					{
					if (`gmatch $bwOrig "*_scale*"`)//might need to re-ensure 1st in BW is 1-based for scale
						{
						$keyYValues=`keyframe -in 0 -q -vc $tempString2[$z]`;
						if ($keyYValues[0]==0)
							{
							setAttr ($bwNew+".input["+$plugNr+"]") 1;
							$plugNr++;
							}
						}
					connectAttr ($tempString2[$z]+".output") ($bwNew+".input["+$plugNr+"]");
					$plugNr++;
					}
				}
			}
		}
	}

$bakers=`listRelatives -c asMetaHumanAnimatorBaker`;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakers;
asMetaHumanAnimatorDeleteAnimation;
setAttr ($nameSpace+"MetaHumanControlPanelToggle.MetaHumanControlPanelVis") 0;
setAttr ($nameSpace+"ctrlBox.limits") 0;
delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 0 $bakers;
for ($i=0;$i<size($bakers);$i++)
	{
	$tempString=`listConnections -s 1 -d 0 -scn 1 -type animCurve $bakers[$i]`;
	if (!size($tempString))
		continue;
	copyKey ($bakers[$i]+".tx");
	$tempString[0]=`substitute ("BAKER"+$nameSpace+"bw") $bakers[$i] ""`; //"BAKERbwctrlBrow_R_translateY
	$tempString[0]=`substitute "SDK" $tempString[0] ""`;
	tokenize $tempString[0] "_" $tempString2;
	$dest=$nameSpace+$tempString2[0]+"_"+$tempString2[1]+"."+$tempString2[2];
	if (!`getAttr -settable $dest`)
		continue;
	pasteKey $dest;
	$num++;
	}
delete asMetaHumanAnimatorBaker;
print ("// "+$num+" animationCurves baked.\n");
}

global proc asAutoLipSyncDownload (string $uiName)
{
string $zipFileUrl="https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/releases/download/v1.1.0-beta.2/montreal-forced-aligner_win64.zip";
if (`about -mac`)
	$zipFileUrl="https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/releases/download/v1.1.0-beta.2/montreal-forced-aligner_macosx.zip";
string $libriSpeechLexiconUrl="https://www.openslr.org/resources/11/librispeech-lexicon.txt";
string $sLoc=`asGetScriptLocation`;
string $curl=$sLoc+"/AdvancedSkeletonFiles/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeletonFiles/bin/7za.e";
string $binDir=$sLoc+"/AdvancedSkeletonFiles/bin";
string $downloadDir=$sLoc+"/AdvancedSkeletonFiles/bin/download";
string $tempString[];
tokenize $zipFileUrl "/" $tempString;
string $downloadedZipFile=$tempString[size($tempString)-1];
string $downloadedZipFilePath=$downloadDir+"/"+$downloadedZipFile;
string $cmd;

if (!`file -q -ex $downloadDir`) sysFile -md $downloadDir;

//download Montreal-Forced-Aligner
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -k -L -o "+$downloadDir+"/"+$downloadedZipFile+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -L -o \""+$downloadDir+"/"+$downloadedZipFile+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+"\n");
	system ($cmd);
	}

//download librispeech-lexicon
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -k -L -o "+$downloadDir+"/librispeech-lexicon.txt "+$libriSpeechLexiconUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -L -o \""+$downloadDir+"/librispeech-lexicon.txt\" "+$libriSpeechLexiconUrl;
	print ("// Starting Download:"+$cmd+";\n");
	system ($cmd);
	}

//confirm downloads
if (`file -q -ex $downloadedZipFilePath`)
	print ("// Downloaded sucessfully:"+$downloadedZipFilePath+";\n");
else
	error ("// Download failed, could not find:"+$downloadedZipFilePath+";\n");
if (`file -q -ex ($downloadDir+"/librispeech-lexicon.txt")`)
	print ("// Downloaded sucessfully:"+$downloadDir+"/librispeech-lexicon.txt;\n");
else
	error ("// Download failed, could not find:"+$downloadDir+"/librispeech-lexicon.txt;\n");

//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$downloadedZipFilePath+" -d "+$binDir;
else
	$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x \""+$downloadedZipFilePath+"\" -o\""+$binDir+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($binDir+"/montreal-forced-aligner")`)
	print ("// Unzipped sucessfully:"+$downloadedZipFile+";\n");
else
	error ("// Unzipp failed, could not find:"+$binDir+"/montreal-forced-aligner\n");

//Delete download
if (`filetest -f $downloadedZipFilePath`)
	sysFile -del $downloadedZipFilePath;
//Delete montreal-forced-aligner_win64.zip (1kb file that comes with the zip)
if (`filetest -f ($binDir+"/montreal-forced-aligner_win64.zip")`)
	sysFile -del ($binDir+"/montreal-forced-aligner_win64.zip");

//Move librispeech-lexicon.txt
sysFile -ren ($binDir+"/montreal-forced-aligner/bin/librispeech-lexicon.txt") ($downloadDir+"/librispeech-lexicon.txt");

asAutoLipSyncUI $uiName;
}

global proc asAutoLipSyncFfmpegDownload ()
{
//ffmpeg for $segmentReplacing
string $zipFileUrl="https://www.advancedskeleton.com/download/div/ffmpeg.7z";
string $ffmpegFile="ffmpeg.e";
if (`about -mac`)
	{
	$zipFileUrl="https://www.advancedskeleton.com/download/div/ffmpeg_mac.zip";
	$ffmpegFile="ffmpeg";
	}
string $sLoc=`asGetScriptLocation`;
string $curl=$sLoc+"/AdvancedSkeletonFiles/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeletonFiles/bin/7za.e";
string $forceAlignerBinDir=$sLoc+"/AdvancedSkeletonFiles/bin/montreal-forced-aligner/bin";
string $downloadDir=$sLoc+"/AdvancedSkeletonFiles/bin/download";
string $tempString[];
tokenize $zipFileUrl "/" $tempString;
string $downloadedZipFile=$tempString[size($tempString)-1];
string $downloadedZipFilePath=$downloadDir+"/"+$downloadedZipFile;
string $cmd;

if (!`file -q -ex $downloadDir`) sysFile -md $downloadDir;

//download
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -k -o "+$downloadedZipFilePath+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -o \""+$downloadedZipFilePath+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+";\n");
	system ($cmd);
	}

//confirm downloads
if (`file -q -ex $downloadedZipFilePath`)
	print ("// Downloaded sucessfully:"+$downloadedZipFilePath+";\n");
else
	error ("// Download failed, could not find:"+$downloadedZipFilePath+"\n");

//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$downloadedZipFilePath+" -d "+$forceAlignerBinDir;
else
	$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x \""+$downloadedZipFilePath+"\" -o\""+$forceAlignerBinDir+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($forceAlignerBinDir+"/"+$ffmpegFile)`)
	print ("// Unzipped sucessfully:"+$downloadedZipFile+";\n");
else
	error ("// Unzipp failed, could not find:"+$forceAlignerBinDir+"/"+$ffmpegFile+"\n");

//Delete download
if (`filetest -f $downloadedZipFilePath`)
	sysFile -del $downloadedZipFilePath;
}

global proc asDeformableUI (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;

if (`window -q -ex asDeformableUI`)
	deleteUI asDeformableUI;
window -t "Deformable Controllers" asDeformableUI;
columnLayout;
text -m 0 -l $nameSpace asDeformableNameSpaceText;
separator -h 5 -w 300 -st none;
text -l "Makes controllers able to have \"Deformers\" applied.";
separator -h 15 -st none;
text -l "Select all the controllers that will be `deformed`.";
separator -h 30 -st none;
rowLayout -nc 2;
	separator -w 20 -st none;
	columnLayout;
		optionMenu -l "planePerpendicularAxis" asDeformablePlanePerpendicularAxisOptionMenu;
			menuItem -l "X";
			menuItem -l "Y";
			menuItem -l "Z";
		checkBox -l "connect to \"Extra\" controllers" asDeformableUseExtraCheckBox;
		optionMenu -l "connection:" asDeformableConnectionOptionMenu;
			menuItem -l "Constraint";
			menuItem -l "DirectConnect";
		separator -h 10 -st none;
		button -l "Make selected controllers Deformable" -c asDeformable;
showWindow;
}

global proc asDeformable ()
{
int $hasSettable,$checkingHierarcyByJoints;
int $useExtra=`checkBox -q -v asDeformableUseExtraCheckBox`;
float $dist,$maxDist;
float $scale=`asGetScale`;
float $posA[],$posB[];
string $deformableControlsObject,$suffix,$polyPlane,$nearest,$checkObj,$constraint1,$constraint2,$loc,$offset,$previousLoc;
string $nameSpace=`text -q -l asDeformableNameSpaceText`;
string $ppAxis=`optionMenu -q -v asDeformablePlanePerpendicularAxisOptionMenu`;
string $connection=`optionMenu -q -v asDeformableConnectionOptionMenu`;
string $sel[]=`ls -sl -type transform`;
string $tempString[],$tempString2[],$newPolyPlanes[],$ctrls[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};

if (!size($sel))
	error "No valid Controllers selected";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*DeformableControls*"`)
		error "Selected object already is a DeformableControls-object, select controller(s) instead.";

for ($i=0;$i<99;$i++)
	{
	if ($i==0) $suffix="";
	else $suffix=$i;
	$deformableControlsObject="DeformableControls"+$suffix;
	if (!`objExists $deformableControlsObject`)
		break;
	}

for ($i=0;$i<size($sel);$i++)
	{
	$hasSettable=1;
	for ($y=0;$y<size($trs)-1;$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			if (!`getAttr -settable ($sel[$i]+"."+$trs[$y]+$xyz[$z])`)
				{
				$hasSettable=0;
				$y=$z=99;
				}
			$tempString=`listConnections -s 1 -d 0 ($sel[$i]+"."+$trs[$y]+$xyz[$z])`;
			if ($tempString[0]!="")
				$hasSettable=0;
			}
	if (!$hasSettable)
		{
		print ($sel[$i]+" have translate or rotate channels that are not \"settable\" , skipping this controller.\n");
		continue;
		}
	if (`gmatch $sel[$i] "*Extra*"`)
		{
		$tempString=`listRelatives -c -type transform $sel[$i]`;
		if (`stringArrayCount $tempString[0] $sel`)
			{
			print ($sel[$i]+" is a \"Extra\" controller, but \""+$tempString[0]+"\" is also selected, skipping this controller.\n");
			continue;
			}
		}
	if ($useExtra && !`gmatch $sel[$i] "*Extra*"`)
		{
		$tempString=`listRelatives -p -type transform $sel[$i]`;
		if (`gmatch $tempString[0] "*Extra*"` && !`stringArrayCount $tempString[0] $sel`)
			{
			$ctrls[size($ctrls)]=$tempString[0];
			continue;
			}
		}
	$ctrls[size($ctrls)]=$sel[$i];
	}

for ($i=0;$i<size($ctrls);$i++)
	{
	$tempString=`polyPlane -n ($ctrls[$i]+"PolyPlane") -w ($scale/3.0) -h ($scale/3.0) -sx 1 -sy 1 -ax 0 0 1 -cuv 2 -ch 0`;
	$polyPlane=$tempString[0];
	$newPolyPlanes[size($newPolyPlanes)]=$polyPlane;
	polyEditUV -u $i -v 0 ($ctrls[$i]+"PolyPlane.map[0:99]");
	if ($ppAxis=="X")
		rotate -r -os 0 90 0 ($polyPlane+".vtx[0:99]");
	else if ($ppAxis=="Y")
		rotate -r -os 90 0 0 ($polyPlane+".vtx[0:99]");

	asAlign $polyPlane $ctrls[$i] 1 1 0 0;
	//transform-connect
	
	//connectorMesh
	if (size($ctrls)>1)
		{
		$posA=`xform -q -ws -t $ctrls[$i]`;
		//First try to find `nearest` via hierarcy
		$nearest="";
		$checkObj=$ctrls[$i];
		$checkingHierarcyByJoints=0;
		if (`gmatch $ctrls[$i] "*FK*"`)
			{
			$tempString[0]=`substitute "FK" $ctrls[$i] ""`;
			if (`objExists $tempString[0]`)
				{
				$checkObj=$tempString[0];
				$checkingHierarcyByJoints=1;
				}
			}
		if ($checkingHierarcyByJoints)
			{
			$tempString=`ls -l $checkObj`;
			tokenize $tempString[0] "|" $tempString;
			for ($y=size($tempString)-2;$y>-1;$y--)
				{
				if ($nameSpace=="")
					$tempString2[0]="FK"+$tempString[$y];
				else
					$tempString2[0]=`substitute $nameSpace $tempString[$y] ($nameSpace+"FK")`;
				if (`stringArrayCount $tempString2[0] $ctrls`)
					{
					$nearest=$tempString2[0];
					break;
					}
				}
			}

		if ($nearest=="")
			{//secondly by distance
			$maxDist=999;
			for ($y=0;$y<size($ctrls);$y++)
				{
				if ($i==$y)
					continue;
				$posB=`xform -q -ws -t $ctrls[$y]`;
				$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
				if ($dist<$maxDist)
					{
					$nearest=$ctrls[$y];
					$maxDist=$dist;
					}
				}
			}

		if ($nearest!="")
			{
			$posB=`xform -q -ws -t $nearest`;
			polyCreateFacet -n ("connectorMesh"+$i) -ch 0 -tx 1 -s 1 -p $posA[0] $posA[1] $posA[2] -p $posA[0] $posA[1] $posA[2] -p $posB[0] $posB[1] $posB[2];
			$newPolyPlanes[size($newPolyPlanes)]="connectorMesh"+$i;
			}
		}
	}
if (size($ctrls)==1)
	rename $newPolyPlanes[0] $deformableControlsObject;
else
	{
	polyUnite -n $deformableControlsObject -ch 0 -mergeUVSets 1 $newPolyPlanes;
	}

for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		setAttr -l 1 ($deformableControlsObject+"."+$trs[$y]+$xyz[$z]);

//constraint
for ($i=0;$i<size($ctrls);$i++)
	{
	$tempString=`spaceLocator -n ($deformableControlsObject+"_Loc"+$i)`;
	$loc=$tempString[0];
	parent $loc $deformableControlsObject;
	setAttr ($loc+".localScale") -type float3 ($scale/20.0) ($scale/20.0) ($scale/20.0);
//	setAttr ($loc+".rotateOrder") `getAttr ($ctrls[$i]+".rotateOrder")`;
	asAlign $loc $ctrls[$i] 1 1 0 1;
	$tempString=`listRelatives -p $ctrls[$i]`;
	select $deformableControlsObject $loc;
	$tempString=`pointOnPolyConstraint -mo -weight 1`;
	$constraint1=$tempString[0];
	setAttr ($constraint1+"."+$deformableControlsObject+"U0") (0.5+$i);
	setAttr ($constraint1+"."+$deformableControlsObject+"V0") 0.5;
	setAttr ($constraint1+".offsetTranslate") -type float3 0 0 0;
	if ($connection=="Constraint")
		parentConstraint  $loc $ctrls[$i];

	$offset=`createNode -n ($deformableControlsObject+"_Offset"+$i) -p $ctrls[$i] transform`;
	setAttr ($offset+".rotateOrder") `getAttr ($ctrls[$i]+".rotateOrder")`;
	parent $offset $deformableControlsObject;
	parent $loc $offset;
	if ($i>0)
		parent $offset $previousLoc;

	if ($connection=="DirectConnect")
		{
		connectAttr ($loc+".t") ($ctrls[$i]+".t");
		connectAttr ($loc+".r") ($ctrls[$i]+".r");
		}
	$previousLoc=$loc;
	}
select $deformableControlsObject;
print ("// Deformable Controller Object created, you can now apply Deformers to this object.\n");
}

global proc asAudio2FaceUI (string $uiName)
{
string $folder="C:/Users/"+`getenv "USER"`+"/Documents/Kit/shared/capture";
//string $asset="C:/Users/"+`getenv "USER"`+"/AppData/Local/ov/pkg/audio2face-2021.3.3/exts/omni.audio2face.wizard/assets/demo.usda";
string $pkgFolder="C:/Users/"+`getenv "USER"`+"/AppData/Local/ov/pkg";
string $asset,$latestPkg;
string $tempString[];

//could be custom installation path used for audio2face
if (`optionVar -ex asAudio2FacePkgFolder`)
	$pkgFolder=`optionVar -q asAudio2FacePkgFolder`;
if (!`file -q -ex $pkgFolder`)
	{
	$tempString=`fileDialog2 -fm 3 -cap "Choose the Omniverse \"pkg\" folder" -okc Choose`;
	if (!`file -q -ex $tempString[0]` || $tempString[0]=="")
		return;
	$pkgFolder=$tempString[0];
	optionVar -sv asAudio2FacePkgFolder $pkgFolder;
	}

//assume asset from latest found version of Audio2Face
$tempString=`getFileList -fld $pkgFolder -fs "audio2face-*"`;
if (!size($tempString))
	error ("Unable to determine which version of Audio2Face to use, as no folders found matching the name \"audio2face-\" in the \""+$pkgFolder+"\" folder");
$tempString=`sort $tempString`;
$latestPkg=$tempString[size($tempString)-1];
//$asset="C:/Users/"+`getenv "USER"`+"/AppData/Local/ov/pkg/"+$latestPkg+"/exts/omni.audio2face.wizard/assets/demo_regular.usda";
$asset="C:/Users/"+`getenv "USER"`+"/AppData/Local/ov/pkg/"+$latestPkg+"/assets/male/mesh/male_fullface_model.usd";
if (!`file -q -ex $asset`)
	{
	$tempString[0]="C:/Users/"+`getenv "USER"`+"/AppData/Local/ov/pkg/"+$latestPkg+"/exts/omni.audio2face.tool/deps/audio2face-assets/mark/mesh/mark_fullface_model.usd";
	if (`file -q -ex $tempString[0]`)
	$asset=$tempString[0];
	}

string $nameSpace=`asNameSpaceFromUIName $uiName`;
if (`optionVar -ex asAudio2FaceFolderTextField`)
	$folder=`optionVar -q asAudio2FaceFolderTextField`;
if (`optionVar -ex asAudio2FaceAssetTextField`)
	$asset=`optionVar -q asAudio2FaceAssetTextField`;

if (`window -q -ex asAudio2FaceUI`)
	deleteUI asAudio2FaceUI;
window -t Audio2Face asAudio2FaceUI;
columnLayout;
	text -m 0 -l $nameSpace asAudio2FaceNameSpaceText;
	rowLayout -nc 2;
		separator -w 100 -st none;
		button -l "visit nvidia.com/audio2face" -c "showHelp -a \"https://www.nvidia.com/en-us/omniverse/apps/audio2face/\"";
		setParent..;
	separator -h 5 -st none;
	rowLayout -nc 3;
		text -w 40 -l "Folder:";
		textField -w 300 -tx $folder asAudio2FaceFolderTextField;
		iconTextButton -i "menuIconFile.png" -c "asAudio2FaceBrowse asAudio2FaceFolderTextField";
		setParent..;
	rowLayout -nc 3;
		text -w 40 -l "Asset:";
		textField -w 300 -tx $asset asAudio2FaceAssetTextField;
		iconTextButton -i "menuIconFile.png" -c "asAudio2FaceBrowse asAudio2FaceAssetTextField";
		setParent..;
	separator -h 10 -st none;
	checkBox -v 1 -l "include eyeBrow animation" asAudio2FaceIncEyeBrowCheckBox;
	checkBox -v 1 -l "include eyeLid animation" asAudio2FaceIncEyeLidCheckBox;
	separator -h 10 -st none;
	rowLayout -nc 6;
		separator -w 10 -st none;
		button -l "Apply" -c asAudio2FaceApply;
		separator -w 10 -st none;
		button -l "Bake" -c asAudio2FaceBake;
		separator -w 10 -st none;
		button -l "Remove" -c asAudio2FaceRemove;
showWindow;

if (!`file -q -ex $asset`)
	textField -e -bgc 1 0 0 asAudio2FaceAssetTextField;
}

global proc asAudio2FaceBrowse (string $textField)
{
int $fileMode=1;
if ($textField=="asAudio2FaceFolderTextField")
	$fileMode=3;
string $result[]=`fileDialog2 -fm $fileMode -cap folder -okc Choose`;
if (!`file -q -ex $result[0]` || $result[0]=="")
	return;
textField -e -tx $result[0] -bgc 0 0 0 $textField;
optionVar -sv $textField $result[0];
}

global proc asAudio2FaceApply ()
{
int $incEyeBrow=`checkBox -q -v asAudio2FaceIncEyeBrowCheckBox`;
int $incEyeLid=`checkBox -q -v asAudio2FaceIncEyeLidCheckBox`;
float $s,$scale,$onFaceCtrlScale,$eyeLidMultiplierDefaultValue;
float $posA[],$posB[],$posC[],$posD[];
string $xmlFile,$assetHead,$side,$cache;
string $nameSpace=`text -q -l asAudio2FaceNameSpaceText`;
string $folder=`textField -q -tx asAudio2FaceFolderTextField`;
string $asset=`textField -q -tx asAudio2FaceAssetTextField`;
string $tempString[],$tempString2[],$allAsAfter[],$allAsBefore[];

$scale=`getAttr ($nameSpace+"FaceFitSkeleton.faceScale")`;
$onFaceCtrlScale=`getAttr ($nameSpace+"OnFacecontrols.sx")`;

if (!`file -q -ex $folder`)
	error ("Folder: \""+$folder+"\" not found");
if (!`file -q -ex $asset`)
	error ("Asset: \""+$asset+"\" not found");

$tempString2=`getFileList -fld $folder`;
for ($i=0;$i<size($tempString2);$i++)
	{
//	if (`gmatch $tempString2[$i] "*head*[.]xml"`)
	if (`gmatch $tempString2[$i] "*[.]xml"`)
		$xmlFile=$folder+"/"+$tempString2[$i];
	}
if ($xmlFile=="" || !`file -q -ex $xmlFile`)
	error ("XML file not found in the folder");

if (`objExists a2fXfer`)
	asAudio2FaceRemove;

if (`objExists ($nameSpace+"FaceControlSet")`)
	asGoToBuildPoseOptions $nameSpace "FaceControlSet";

createNode -n a2fXfer transform;
if (`objExists a2fImported`)
	delete a2fImported;
createNode -n a2fImported transform;

$allAsBefore=`ls -as`;
evalEcho ("file -i -type \"USD Import\" \""+$asset+"\"");// -type "USD Import"
select `ls -as`;
select -d $allAsBefore;
$allAsAfter=`ls -sl`;
if (!size($allAsAfter))
	error "Import failed";
parent $allAsAfter a2fImported;

$tempString=`listRelatives -ad -type mesh a2fImported`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*head*"`)
		{
		$tempString2=`listRelatives -p $tempString[$i]`;
		$assetHead=$tempString2[0];
		}

parent $assetHead a2fXfer;
createNode -n a2fCurves -p a2fXfer transform;
createNode -n a2fLocs -p a2fXfer transform;
createNode -n a2fXforms -p a2fXfer transform;
setAttr a2fXforms.s -type float3 $onFaceCtrlScale $onFaceCtrlScale $onFaceCtrlScale;
circle -n a2fCtrl -c 0 0 0 -nr 0 0 1 -sw 360 -r ($scale/10.0) -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
setAttr a2fCtrl.overrideEnabled 1;
parent a2fCtrl a2fXfer;
setAttr a2fCtrl.overrideColor 17;
$posA=`xform -q -ws -t ($nameSpace+"ctrlBox")`;
xform -ws -t ($posA[0]*1.5) $posA[1] $posA[2] a2fCtrl;
asLockAttr a2fCtrl 1 1 1 1;
addAttr -k 1 -ln LipMultiplier -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 a2fCtrl;
addAttr -k 1 -ln JawMultiplier -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 a2fCtrl;
if ($incEyeBrow)
	addAttr -k 1 -ln EyeBrowMultiplier -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 1 a2fCtrl;
if ($incEyeLid)
	addAttr -k 1 -ln EyeLidMultiplier -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 1 a2fCtrl;
addAttr -k 1 -ln TranslateZMultiplier -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 0.5 a2fCtrl;

//Reduced LipMultiplier engages stickyLip
/* removed in v 6.045 as this does not work as well for V6 FaceSetup
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";

	if (`attributeExists zip ($nameSpace+"Lip"+$side)`)
		$stickyAttrName="zip";//v5
	else
		$stickyAttrName="sticky";//v6
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd a2fCtrl.LipMultiplier ($nameSpace+"Lip"+$side+"."+$stickyAttrName);
	setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 0 -cd a2fCtrl.LipMultiplier ($nameSpace+"Lip"+$side+"."+$stickyAttrName);
	}
*/
//Off Follow, as it interfers with multipliers
/*
setAttr ($nameSpace+"lowerLip_M.followJawFollow_M") 0;
setAttr ($nameSpace+"upperLip_M.followJawFollow_M") 0;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";

	setAttr ($nameSpace+"Cheek"+$side+".followJawFollow"+$side) 0;
	setAttr ($nameSpace+"lowerLipA"+$side+".followlowerLip_M") 0;
	setAttr ($nameSpace+"lowerLipB"+$side+".followlowerLip_M") 0;
	setAttr ($nameSpace+"Lip"+$side+".followJawFollow"+$side) 0;
	setAttr ($nameSpace+"upperLipB"+$side+".followupperLip_M") 0;
	setAttr ($nameSpace+"upperLipA"+$side+".followupperLip_M") 0;
	}
*/
$posA=`xform -q -ws -t c_headWatertight_hi.vtx[37489]`;
$posB=`xform -q -ws -t c_headWatertight_hi.vtx[48699]`;
$posC=`xform -q -ws -t ($nameSpace+"Jaw")`;
$posD=`xform -q -ws -t ($nameSpace+"innerLid_R")`;
setAttr c_headWatertight_hi.ty (($posA[1]*-1)+$posC[1]);
setAttr c_headWatertight_hi.tz ($posC[2]-$posA[2]);
$s=($posD[1]-$posC[1])/($posB[1]-$posA[1]);
scale -r -p 0 $posC[1] $posD[2] $s $s $s c_headWatertight_hi;
$posA=`xform -q -ws -t ($nameSpace+"JawPivot")`;
move -r -os -wd ($posA[0]*2.5) 0 0 c_headWatertight_hi;

if (!`exists importCacheFile`)
	evalEcho ("source doImportCacheArgList");
select c_headWatertight_hi;
importCacheFile $xmlFile "xml";
select -cl;

playbackOptions -min 0;
currentTime 0;
$tempString=`listHistory -interestLevel 1 c_headWatertight_hi`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="cacheFile")
		$cache=$tempString[$i];
playbackOptions -max `getAttr ($cache+".sourceEnd")`;

setAttr ($nameSpace+"Lip_R.followJawFollow_R") 2.5;
setAttr ($nameSpace+"Lip_L.followJawFollow_L") 2.5;
setAttr ($nameSpace+"lowerLip_M.followJawFollow_M") 5;

asAudio2FaceEdge2Curve 8512 Jaw_M;
//asAudio2FaceEdge2Curve 54824 lowerLip_M;
//asAudio2FaceEdge2Curve 55242 upperLip_M;

asAudio2FaceEdge2Curve 72676 Lip_R;
asAudio2FaceEdge2Curve 54826 upperLipA_R;
asAudio2FaceEdge2Curve 54042 upperLipB_R;
//asAudio2FaceEdge2Curve 53761 upperLipC_R;
asAudio2FaceEdge2Curve 54776 lowerLipA_R;
asAudio2FaceEdge2Curve 54178 lowerLipB_R;
//asAudio2FaceEdge2Curve 54434 lowerLipC_R;
asAudio2FaceEdge2Curve 21212 Lip_L;
asAudio2FaceEdge2Curve 2453 upperLipA_L;
asAudio2FaceEdge2Curve 1859 upperLipB_L;
//asAudio2FaceEdge2Curve 1367 upperLipC_L;
asAudio2FaceEdge2Curve 2399 lowerLipA_L;
asAudio2FaceEdge2Curve 1960 lowerLipB_L;
//asAudio2FaceEdge2Curve 2051 lowerLipC_L;

asAudio2FaceEdge2Curve 59041 Cheek_R;
asAudio2FaceEdge2Curve 76762 NoseCorner_R;
asAudio2FaceEdge2Curve 9731 Cheek_L;
asAudio2FaceEdge2Curve 23642 NoseCorner_L;

if ($incEyeLid)
	{
	asAudio2FaceEdge2Curve 91623 upperLid_R;
	asAudio2FaceEdge2Curve 91857 lowerLid_R;
//	asAudio2FaceEdge2Curve 93186 innerLid_R;
//	asAudio2FaceEdge2Curve 90572 outerLid_R;

	asAudio2FaceEdge2Curve 40425 upperLid_L;
	asAudio2FaceEdge2Curve 39777 lowerLid_L;
//	asAudio2FaceEdge2Curve 41101 innerLid_L;
//	asAudio2FaceEdge2Curve 38483 outerLid_L;
	}

if ($incEyeBrow)
	{
	asAudio2FaceEdge2Curve 87840 EyeBrowInner_R;
	asAudio2FaceEdge2Curve 82598 EyeBrowOuter_R;
	asAudio2FaceEdge2Curve 35788 EyeBrowInner_L;
	asAudio2FaceEdge2Curve 30426 EyeBrowOuter_L;
	}

if ($incEyeLid)
	{
	//EyeLid multiplyer to default to relative size-difference of eye-lid-opening
	$posA=`xform -q -ws -t A2F_upperLid_R_Loc`;
	$posB=`xform -q -ws -t A2F_lowerLid_R_Loc`;
	$posC=`xform -q -ws -t ($nameSpace+"upperLid_R")`;
	$posD=`xform -q -ws -t ($nameSpace+"lowerLid_R")`;
	$eyeLidMultiplierDefaultValue=($posC[1]-$posD[1]) / ($posA[1]-$posB[1]);
	setAttr a2fCtrl.EyeLidMultiplier `asRoundOff $eyeLidMultiplierDefaultValue 2`;
	}

select a2fCtrl;
print "// Audio2Face Applied, You can now adjust the Multipliers.\n";
}

global proc asAudio2FaceEdge2Curve (int $edgeNr, string $name)
{
float $scale;
string $side;
string $region="Lip";
string $nameSpace=`text -q -l asAudio2FaceNameSpaceText`;
string $tempString[];
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
tokenize $name "_" $tempString;
$side="_"+$tempString[1];

if ($name=="Jaw_M") $region="Jaw";
if (`gmatch $name "EyeBrow*"`) $region="EyeBrow";
if (`gmatch $name "*Lid*"`) $region="EyeLid";

$scale=`getAttr ($nameSpace+"FaceFitSkeleton.faceScale")`;
select -r ("c_headWatertight_hi.e["+$edgeNr+"]");
duplicateCurve -n ("A2F_"+$name+"Curve") -ch 1 -rn 0 -local 0;
parent ("A2F_"+$name+"Curve") a2fCurves;
spaceLocator -n ("A2F_"+$name+"_Loc");
setAttr ("A2F_"+$name+"_Loc.localScale") -type float3 ($scale/50.0) ($scale/50.0) ($scale/50.0);
setAttr ("A2F_"+$name+"_Loc.overrideEnabled") 1;
setAttr ("A2F_"+$name+"_Loc.overrideColor") 13;
//setAttr ("A2F_"+$name+"_Loc.displayLocalAxis") 1;
parent ("A2F_"+$name+"_Loc") a2fLocs;
createNode -n ("A2F_"+$name+"MotionPath") motionPath;
connectAttr ("A2F_"+$name+"Curve.worldSpace") ("A2F_"+$name+"MotionPath.geometryPath");
setAttr ("A2F_"+$name+"MotionPath.fractionMode") 1;
setAttr ("A2F_"+$name+"MotionPath.worldUpType") 0;
setAttr ("A2F_"+$name+"MotionPath.frontAxis") 2;
setAttr ("A2F_"+$name+"MotionPath.upAxis") 1;
if ($name=="upperLip_M")
	setAttr ("A2F_"+$name+"MotionPath.inverseFront") 1;
connectAttr ("A2F_"+$name+"MotionPath.allCoordinates") ("A2F_"+$name+"_Loc.t");
connectAttr ("A2F_"+$name+"MotionPath.rotate") ("A2F_"+$name+"_Loc.r");

createNode -n ("A2F_"+$name+"_XformA") -p a2fXforms transform;
asAlign ("A2F_"+$name+"_XformA") ("A2F_"+$name+"_Loc") 1 0 0 0;
asAlign ("A2F_"+$name+"_XformA") ($nameSpace+$name) 0 1 0 0;
createNode -n ("A2F_"+$name+"_XformB") -p ("A2F_"+$name+"_XformA") transform;
pointConstraint ("A2F_"+$name+"_Loc") ("A2F_"+$name+"_XformB");

createNode -n ("A2F_"+$name+"MPD") multiplyDivide;
for ($z=0;$z<size($XYZ);$z++)
	connectAttr ("a2fCtrl."+$region+"Multiplier") ("A2F_"+$name+"MPD.input1"+$XYZ[$z]);
//override, Tz of Lip as it will easily crash back into teeth
connectAttr -f ("a2fCtrl.TranslateZMultiplier") ("A2F_"+$name+"MPD.input1Z");
connectAttr ("A2F_"+$name+"_XformB.t") ("A2F_"+$name+"MPD.input2");

if (`gmatch $name "EyeBrowOuter_*"`)
	{
	createNode -n ("A2F_EyeBrowBrowMixer"+$side+"MPD") multiplyDivide;
	createNode -n ("A2F_EyeBrowBrowMixer"+$side+"PMA") plusMinusAverage;
	connectAttr ("A2F_EyeBrowOuter"+$side+"MPD.outputY") ("A2F_EyeBrowBrowMixer"+$side+"MPD.input1X");
	setAttr ("A2F_EyeBrowBrowMixer"+$side+"MPD.input2X") -1;
	connectAttr ("A2F_EyeBrowInner"+$side+"MPD.outputY") ("A2F_EyeBrowBrowMixer"+$side+"PMA.input1D[0]");
	connectAttr ("A2F_EyeBrowBrowMixer"+$side+"MPD.outputX") ("A2F_EyeBrowBrowMixer"+$side+"PMA.input1D[1]");
	connectAttr ("A2F_EyeBrowBrowMixer"+$side+"PMA.output1D") ($nameSpace+"ctrlBrow"+$side+".tx");
	connectAttr ("A2F_EyeBrowOuter"+$side+"MPD.outputY") ($nameSpace+"ctrlBrow"+$side+".ty");
	}
else if ($region=="Lip")
	{
	$tempString=`listRelatives -p ($nameSpace+$name)`;
//	$tempString[0]=`substitute $side ($nameSpace+$name) ("Offset"+$side)`;
	createNode -n ("A2F_"+$name+"_XformC") -p $tempString[0] transform;
//	pointConstraint -mo ("A2F_"+$name+"_XformB") ("A2F_"+$name+"_XformC");
	connectAttr ("A2F_"+$name+"_XformB.t") ("A2F_"+$name+"_XformC.t");
	connectAttr -f ("A2F_"+$name+"_XformC.t") ("A2F_"+$name+"MPD.input2");
	connectAttr ("A2F_"+$name+"MPD.outputX") ($nameSpace+$name+".tx");
	connectAttr ("A2F_"+$name+"MPD.outputY") ($nameSpace+$name+".ty");
	connectAttr ("A2F_"+$name+"MPD.outputZ") ($nameSpace+$name+".tz");
	//override, Tz of Lip as it will easily crash back into teeth
//	connectAttr -f ("a2fCtrl.JawMultiplier") ("A2F_"+$name+"MPD.input1Y");
	}
else
	{
	connectAttr ("A2F_"+$name+"MPD.output") ($nameSpace+$name+".t");
	}

if ($name=="lowerLip_M" || $name=="upperLip_M")
	{
	orientConstraint -mo ("A2F_"+$name+"_Loc") ("A2F_"+$name+"_XformB");
	createNode -n ("A2F_"+$name+"RotateMPD") multiplyDivide;
	for ($z=0;$z<size($XYZ);$z++)
		connectAttr ("a2fCtrl."+$region+"Multiplier") ("A2F_"+$name+"RotateMPD.input1"+$XYZ[$z]);
	connectAttr ("A2F_"+$name+"_XformB.r") ("A2F_"+$name+"RotateMPD.input2");
	connectAttr ("A2F_"+$name+"RotateMPD.output") ($nameSpace+$name+".r");
	}

//pointConstraint -mo ("A2F_"+$name+"_XformB") ($nameSpace+$name);
}

global proc asAudio2FaceBake ()
{
float $curTime=`currentTime -q`;
string $nameSpace=`text -q -l asAudio2FaceNameSpaceText`;
string $side;
string $ctrls[]={"Jaw_M","lowerLip_M","upperLip_M"};

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";

	$ctrls[size($ctrls)]="ctrlBrow"+$side;
	$ctrls[size($ctrls)]="Lip"+$side;
	$ctrls[size($ctrls)]="lowerLipA"+$side;
	$ctrls[size($ctrls)]="upperLipA"+$side;
	$ctrls[size($ctrls)]="Cheek"+$side;
	$ctrls[size($ctrls)]="NoseCorner"+$side;
	$ctrls[size($ctrls)]="upperLid"+$side;
	$ctrls[size($ctrls)]="lowerLid"+$side;
	}
for ($i=0;$i<size($ctrls);$i++)
	$ctrls[$i]=$nameSpace+$ctrls[$i];
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $ctrls;
currentTime $curTime;
select $ctrls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
asAudio2FaceRemove;
print "// Audio2Face Baked.\n";
}

global proc asAudio2FaceRemove ()
{
string $nameSpace=`text -q -l asAudio2FaceNameSpaceText`;
string $tempString[];

if (`objExists a2fXfer`)
	delete a2fXfer;
else
	error "asAudio2Face node \"a2fXfer\" not found";
if (`objExists a2fImported`)
	delete a2fImported;
$tempString=`ls "A2F_*MPD"`;
if (size($tempString))
	delete $tempString;
if (`objExists ($nameSpace+"FaceControlSet")`)
	asGoToBuildPoseOptions $nameSpace "FaceControlSet";

print "// Audio2Face Removed.\n";
}

global proc asAutoLipSyncUI (string $uiName)
{
asEnsureAsGetScriptLocation;
string $nameSpace;
string $alignerDir=`asGetScriptLocation`+"/AdvancedSkeletonFiles/bin/montreal-forced-aligner";
string $aligner=$alignerDir+"/bin/mfa_align";
if (`about -win`)
	$aligner=$alignerDir+"/bin/mfa_align.exe";
int $haveAligner=`file -q -ex $aligner`;
string $languages[]=`asAutoLipSyncLanguages`;
stringArrayInsertAtIndex 1 $languages "English";
string $language="English";
if (`optionVar -ex asAutoLipSyncLanguage`)
	$language=`optionVar -q asAutoLipSyncLanguage`;

if (`asHotKeyCheck "asAutoLipSyncUI \"\""`) return;

if (`window -q -ex asAutoLipSyncUI`)
	deleteUI asAutoLipSyncUI;
window -t AutoLipSync -w 300 -h 200 asAutoLipSyncUI;
formLayout asAutoLipSyncUIFormLayout;
columnLayout asAutoLipSyncUIColumnLayout;
if (!$haveAligner)
	{
	separator -h 5 -st none;
	text -l "To run AutoLipSync,";
	text -l "first download \"Montreal-Forced-Aligner\"";
	separator -h 5 -st none;
	button -l "Download Montreal-Forced-Aligner" -c ("asAutoLipSyncDownload "+$uiName);
	showWindow;
	print ("// Montreal-Forced-Aligner tool must be downloaded first\n");
	print ("// If the automatic download does not work, you can manually download from:\n");
	print ("// https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/releases\n");
	print ("// download and extract the files, so you get this available file-path:\n");
	print ("// "+$aligner+"\n");
	print ("\n");
	return;
	}

text -m 0 -l $aligner asAutoLipSyncAlignerText;
separator -h 10 -st none;
columnLayout;
	text -l "Add Idle motions:";
	rowLayout -nc 5;
		checkBox -l "Blink" -v 1 asAutoLipSyncBlinkCheckBox;
		checkBox -l "Glimpse" -v 1 asAutoLipSyncGlimpseCheckBox;
		checkBox -l "EyeBrows" -v 1 asAutoLipSyncEyeBrowsCheckBox;
		checkBox -l "Head" -v 1 asAutoLipSyncHeadCheckBox;
		setParent..;
	setParent..;

separator -h 20 -st none;
setParent..;
scrollField -wordWrap false -text "Dialog text here" asAutoLipSyncUIScrollField;
button -m 0 -l "Open text editor, for non-latin alphabet" -c asAutoLipOpenTextEditor asAutoLipSyncUIButton;
frameLayout -w 300 -cll 1 -cl 0 -l "advanced options" asAutoLipSyncUIFrameLayout;
	columnLayout -adj 0;
		rowLayout -nc 3;
			optionMenu -l "language:" -cc asAutoLipSyncLanguageChanged asAutoLipSyncLanguageOptionMenu;
			for ($i=0;$i<size($languages);$i++)
				menuItem $languages[$i];
			separator -st none -w 20;
			checkBox -l "non-latin alphabet" -cc asAutoLipSyncLanguageChanged asAutoLipSyncNonLatinCheckBox;
			setParent..;
		if (`stringArrayCount $language $languages`)
			{
			optionMenu -e -v $language asAutoLipSyncLanguageOptionMenu;
			asAutoLipSyncLanguageChanged;
			}
		rowLayout -nc 3;
			text -l "phoneme  fadeIn   ";
			floatField -pre 3 -v 0.05 -min 0.001 asAutoLipSyncPhonemeInFloatField;
			text -l "seconds";
			setParent..;
		rowLayout -nc 3;
			text -l "phoneme  fadeOut";
			floatField -pre 3 -v 0.05 -min 0.001 asAutoLipSyncPhonemeOutFloatField;
			text -l "seconds";
			setParent..;
		rowLayout -nc 3;
			checkBox -l "always re-code audio file" asAutoLipSyncAlwaysReCodeCheckBox;		
			setParent..;
		rowLayout -nc 6;
			separator -w 5 -st none;
			button -l "import example voice" -c asAutoLipSyncImportExampleVoice;
			separator -w 5 -st none;
			button -l "visit ibm.com/watson" -c "showHelp -a \"https://www.ibm.com/watson/services/text-to-speech/\"";
			separator -w 5 -st none;
			button -l "enable mp3" -c "asAutoLipSyncEnableMp3";
			setParent..;
		separator;
		setParent..;
	setParent..;
columnLayout asAutoLipSyncUIColumnLayout2;
separator -h 5 -st none;

rowLayout -nc 3;
	separator -w 50 -st none;
	button -w 100 -l "Run Auto LipSync" -c ("asAutoLipSyncForceAlign \""+$uiName+"\"");

formLayout -e 
	-ac asAutoLipSyncUIScrollField "top" 0 asAutoLipSyncUIColumnLayout
	-af asAutoLipSyncUIScrollField "left" 0
	-af asAutoLipSyncUIScrollField "right" 0
	-ac asAutoLipSyncUIScrollField "bottom" 0 asAutoLipSyncUIFrameLayout

	-ac asAutoLipSyncUIFrameLayout "bottom" 0 asAutoLipSyncUIColumnLayout2

	-ac asAutoLipSyncUIButton "top" 0 asAutoLipSyncUIColumnLayout
	-af asAutoLipSyncUIButton "left" 0
	-af asAutoLipSyncUIButton "right" 0
	-ac asAutoLipSyncUIButton "bottom" 0 asAutoLipSyncUIFrameLayout

	-af asAutoLipSyncUIColumnLayout2 "bottom" 5
	-af asAutoLipSyncUIFrameLayout "left" 0
	-af asAutoLipSyncUIFrameLayout "right" 0
	asAutoLipSyncUIFormLayout;

showWindow;
}

global proc asAutoLipSyncForceAlign (string $uiName)
{
global string $gPlayBackSlider;
int $segmentReplacing=0;
int $alwaysReCode=`checkBox -q -v asAutoLipSyncAlwaysReCodeCheckBox`;
float $timeRangeArray[]=`timeControl -q -rangeArray $gPlayBackSlider`;
if (($timeRangeArray[1]-$timeRangeArray[0])>1)
	$segmentReplacing=1;
float $fps=`currentTimeUnitToFPS`;
if ($fps<1) $fps=1;
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $mfaDir,$cmd,$genDictCmd,$ffMpegCmd,$pythonCmd,$uniDecoded;
string $tempString[];
string $languageMenuValue=`optionMenu -q -v asAutoLipSyncLanguageOptionMenu`;
string $language=`tolower $languageMenuValue`;
string $aligner=`text -q -l asAutoLipSyncAlignerText`;
$mfaDir=`asStripPath $aligner 2`;
string $lexicon=$mfaDir+"bin/librispeech-lexicon.txt";
string $ffmpeg=$mfaDir+"bin/ffmpeg.e";
if (`about -mac`)
	$ffmpeg=$mfaDir+"bin/ffmpeg";
string $mfaGD=$mfaDir+"bin/mfa_generate_dictionary";
string $g2pFile=$mfaDir+"pretrained_models/"+$language+"_g2p.zip";
string $languageZipFile=$mfaDir+"pretrained_models/"+$language+".zip";
string $tempDir=`asGetTempDirectory`+"AdvancedSkeleton/autoLipSync/";
string $audioNode = `timeControl -q -s $gPlayBackSlider`;
if (!`objExists $audioNode`)
	error "No sound found. Make sure to import a sound file first";
string $soundFile=`getAttr ($audioNode+".filename")`;
tokenize $soundFile "/" $tempString;
string $soundFileBaseName=$tempString[size($tempString)-1];
tokenize $soundFile "." $tempString;
string $soundFileExt=$tempString[size($tempString)-1];
string $forceSoundFile=$tempDir+"input/align."+$soundFileExt;
string $forceTextFile=$tempDir+"input/align.txt";
string $textGridFile=$tempDir+"output/align.TextGrid";
string $forceText=`scrollField -q -tx asAutoLipSyncUIScrollField`;


if (!`objExists ($nameSpace+"FaceControlSet")`)
	error "No controlSets detected. select a controller";
if (!`objExists ($nameSpace+"ctrlPhonemes_M")`)
	error ($nameSpace+"ctrlPhonemes_M not found");
if (!`file -q -ex $aligner`)
	error ("Missing file:\""+$aligner+"\"");

//non-english needs to mfa_generate_dictionary (lexicon) first
//use the g2p to make the dict, and then the zip (Pretrained acoustic models) to align
if ($language!="english")
	{
	$lexicon=$tempDir+"sessionLexicon.txt";
	if (`about -mac` || `about -linux`)
		$genDictCmd="\""+$mfaGD+"\" \""+$g2pFile+"\" \""+$tempDir+"input/\" \""+$lexicon+"\"";
	else
		$genDictCmd="start\/wait/I \"Generating Dictionary\" \""+$mfaGD+"\" \""+$g2pFile+"\" \""+$tempDir+"input/\" \""+$lexicon+"\"";
	}

if (`about -mac` || `about -linux`)
	{
	$cmd="\""+$aligner+"\" -c \""+$tempDir+"input/\" \""+$lexicon+"\" "+$language+" \""+$tempDir+"output/\"";
	$ffMpegCmd="start\/wait/I \"Coding Audio\" \""+$ffmpeg+"\" -y -i \""+$soundFile+"\"";
	}
else
	{
	$cmd="start\/wait/I \"Force Aligning\" \""+$aligner+"\" -c \""+$tempDir+"input/\" \""+$lexicon+"\" "+$language+" \""+$tempDir+"output/\"";
	$ffMpegCmd="start\/wait/I \"Coding Audio\" \""+$ffmpeg+"\" -y -i \""+$soundFile+"\"";
	}

if (!`file -q -ex $soundFile`)
	error "Not a valid sound file";

//Remove old results
$tempString=`getFileList -fld ($tempDir+"output")`;
for ($i=0;$i<size($tempString);$i++)
	sysFile -del ($tempDir+"output/"+$tempString[$i]);
if (`checkBox -q -v asAutoLipSyncNonLatinCheckBox` && !$segmentReplacing)
	{
	$tempString=`getFileList -fld ($tempDir+"render")`;
	for ($i=0;$i<size($tempString);$i++)
		sysFile -del ($tempDir+"render/"+$tempString[$i]);
	}

if (!`file -q -ex ($tempDir+"input")`) sysFile -md ($tempDir+"input");
if (!`file -q -ex ($tempDir+"output")`) sysFile -md ($tempDir+"output");
sysFile -cp $forceSoundFile $soundFile;

if ($segmentReplacing || $alwaysReCode)
	if (!`file -q -ex $ffmpeg`)
		asAutoLipSyncFfmpegDownload;
	
if ($segmentReplacing)
	{//If range in the timeLine is highlighted, then we assume to run "Correction" for this segment
	print ("// Segment selection found on Timeline-slider, trimming audio to selection.\n");
	$ffMpegCmd+=" -ss "+($timeRangeArray[0]/$fps)+" -to "+($timeRangeArray[1]/$fps)+" "+$forceSoundFile;
	print ("// Starting Trimming Audio:"+$ffMpegCmd+"\n");
	system ($ffMpegCmd);
	}
else if ($alwaysReCode)
	{
	$ffMpegCmd+=" "+$forceSoundFile;
	print ("// Starting ReCode Audio:"+$ffMpegCmd+"\n");
	system ($ffMpegCmd);	
	}

if (`latinWriting $languageMenuValue`)
	{
	//Unidecode to transliterates any unicode string into the closest possible representation in ascii text.
	//open file > strip_accents > save file, in Py, so we do not need to pass the text as variable

	$forceText=`substituteAllString $forceText "`" ""`;
	$forceText=`substituteAllString $forceText "'" " "`;
	$forceText=`substituteAllString $forceText "\n" " "`;
	$pythonCmd+="import unicodedata\n";
	$pythonCmd+="def strip_accents(s):\n";
	$pythonCmd+="	return ''.join(c for c in unicodedata.normalize('NFD', s)\n";
	$pythonCmd+="		if unicodedata.category(c) != 'Mn')\n";
	python ($pythonCmd);
	$uniDecoded=`python ("strip_accents(u'"+$forceText+"')")`;

	$fileId=`fopen $forceTextFile "w"`;
	fprint $fileId $uniDecoded;
	fclose $fileId;

	if ($uniDecoded!=$forceText)
		scrollField -e -tx $uniDecoded asAutoLipSyncUIScrollField;
	}

//non-english needs to mfa_generate_dictionary (lexicon) first
//use the g2p to make the dict, and then the zip (Pretrained acoustic models) to align
if ($language!="english")
	{
	print ("// Starting Generating Dictionary:"+$genDictCmd+"\n");
	if (`file -q -ex $lexicon`)
		sysFile -del $lexicon;
	system ($genDictCmd);
	if (!`file -q -ex $lexicon`)
		error ("Failed to create dictionary:\""+$lexicon+"\"");
	}

if ($forceText!="")
	{
	print ("// Starting Force Aligning:"+$cmd+"\n");
	system ($cmd);
	}
else
	{
	$fileId=`fopen $textGridFile "w"`;
	fprint $fileId "";
	fclose $fileId;
	}

if (`file -q -ex $textGridFile`)
	print ("// Successfully created:\""+$textGridFile+"\".\n");
else
	{
	if (`file -q -ex ($tempDir+"output/unaligned.txt")`)
		{
		$fileId=`fopen ($tempDir+"output/unaligned.txt") "r"`;
		$tempString[0]=`fread $fileId $tempString[0]`;
		print ($tempString[0]+"\n");
		fclose $fileId;
		}
	//Try with ffmpeg
	if (!$alwaysReCode)
		{
		if (`confirmDialog -title "Confirm" -message "Force Align Failed.\nThis could be a compatibility issues with the sound-file.\nTry to re-code sound-file?"
  	  -button "Yes" -button "No" -defaultButton "Yes"
    	-cancelButton "No" -dismissString "No"`=="Yes")
    		{
    		checkBox -e -v 1 asAutoLipSyncAlwaysReCodeCheckBox;
    		asAutoLipSyncForceAlign $nameSpace;
    		return;
    		}
		}
	//Try re-download language files, since at some point g2p files was moved to a "1.0" folder https://github.com/MontrealCorpusTools/mfa-models/tree/master/g2p/1.0
	if (`confirmDialog -title "Confirm" -message "Force Align Failed.\nThe language files might be incorrect,\nTry to re-download language files?"
	  -button "Yes" -button "No" -defaultButton "Yes"
  	-cancelButton "No" -dismissString "No"`=="Yes")
  		{
  		sysFile -del $languageZipFile;
  		sysFile -del $g2pFile;
  		asAutoLipSyncLanguageChanged;
  		asAutoLipSyncForceAlign $nameSpace;
  		return;
  		}

	error ("Failed to create:\""+$textGridFile+"\".\n");
	}

asAutoLipSyncImport $nameSpace;
}

global proc asAutoLipSyncImport (string $nameSpace)
{
global string $gMainProgressBar;
global string $gPlayBackSlider;
global string $gCurrentTimeCmdValueTable[];
int $segmentReplacing=0;
float $timeRangeArray[]=`timeControl -q -rangeArray $gPlayBackSlider`;
float $fps=`currentTimeUnitToFPS`;
if ($fps<1) $fps=1;
int $nonLatin=`checkBox -q -v asAutoLipSyncNonLatinCheckBox`;
int $wordsSection,$phonesSection,$fileId;
int $autoBlink=`checkBox -q -v asAutoLipSyncBlinkCheckBox`;
int $autoGlimpse=`checkBox -q -v asAutoLipSyncGlimpseCheckBox`;
int $autoEyeBrows=`checkBox -q -v asAutoLipSyncEyeBrowsCheckBox`;
int $autoHead=`checkBox -q -v asAutoLipSyncHeadCheckBox`;
int $lastKeyFrameNr,$nextBlinkTriggFrameNr,$nextGlipseTriggFrameNr,$nextHeadTriggFrameNr,$wordNr;
if (!`objExists ($nameSpace+"FKHead_M")`) $autoHead=0;
float $prePhoneTime=`floatField -q -v asAutoLipSyncPhonemeInFloatField`*$fps;
float $postPhoneTime=`floatField -q -v asAutoLipSyncPhonemeOutFloatField`*$fps;
float $sequenceStart=-1;
float $sequenceEnd=-1;
float $wordSpace=0.25;//0.25*$fps
float $scale=1.5;
float $xMin,$xMax,$segRepOffset,$keyValue,$previousKeyTime;
float $wordStarts[],$wordEnds[],$phoneStarts[],$phoneEnds[],$bb[],$keyTimes[],$pos[],$pos1[],$pos2[];
string $aligner=`text -q -l asAutoLipSyncAlignerText`;
string $tempDir=`asGetTempDirectory`+"AdvancedSkeleton/autoLipSync/";
string $textGridFile=$tempDir+"output/align.TextGrid";
string $nextLine,$para,$value,$pythonCmd,$fileRead,$font,$imConvertCmdLine;
string $imConvertCmd=`asGetImConvertCmd`;
string $tempString[],$words[],$phones[],$missingPhoneParts[],$letters[],$deleteObjs[],$texts[],$chars[];
string $currentTimeUnit=`currentUnit -q -t`;
string $audioNode = `timeControl -q -s $gPlayBackSlider`;
string $languageMenuValue=`optionMenu -q -v asAutoLipSyncLanguageOptionMenu`;
string $language=`tolower $languageMenuValue`;
float $offset=`getAttr ($audioNode+".offset")`;///$fps

if (!`objExists ($nameSpace+"ctrlPhonemes_M")`)
	error ($nameSpace+"ctrlPhonemes_M not found");

if (`objExists ($nameSpace+"FaceFitSkeletonHeightShape")`)
    {
    $pos1=`xform -q -ws -t ($nameSpace+"FaceFitSkeletonHeightShape.cv[5]")`;
    $pos2=`xform -q -ws -t ($nameSpace+"FaceFitSkeletonShape.cv[5]")`;
    $scale=$pos1[1]-$pos2[1];
   	}

if (($timeRangeArray[1]-$timeRangeArray[0])>1 && `objExists ($nameSpace+"subTitles")`)
	$segmentReplacing=1;

if ($segmentReplacing)
	{
	//Remove all subtitles in segment (and onwards
	select -cl;
	$pos=`xform -q -ws -t ($nameSpace+"subTitlesArrowShape.cv[3]")`;
	$texts=`listRelatives -c ($nameSpace+"subTitlesRoller")`;
	currentTime $timeRangeArray[0];
	$previousKeyTime=`findKeyframe -which previous ($nameSpace+"subTitlesRoller.tx")`;

	for ($i=0;$i<size($texts);$i++)
		{
		$chars=`listRelatives -c -type transform $texts[$i]`;
		if ($nonLatin) $chars[0]=$texts[$i];
		for ($y=0;$y<size($chars);$y++)
			if ((`getAttr -t $previousKeyTime ($nameSpace+"subTitlesRoller.tx")`*-1)<=`getAttr ($texts[$i]+".tx")`)
				select -add $texts[$i];
		}

	if (size(`ls -sl`))
		delete;

	//Remove subTitlesRoller keyframes as well
	if (`objExists ($nameSpace+"subTitlesRoller")`)
		cutKey -time ($timeRangeArray[0]+":99999") -attribute translateX -option keys ($nameSpace+"subTitlesRoller");
	cutKey -time ($timeRangeArray[0]+":99999") -option keys ($nameSpace+"ctrlPhonemes_M");
	}

/*
Removed as this can cause Preference window to no longer load
//Maya(above2016) seems to want to remove the "sec" timeUnit, overriding this with optionvar and re-create $gCurrentTimeCmdValueTable
if (!`stringArrayCount "sec" $gCurrentTimeCmdValueTable` && `exists workingTimeUtil`)
	{
	optionVar -iv hideNoFPSFramerate 0;
	eval ("source workingTimeUtil");
	}

currentUnit -t "sec";
evalDeferred ("catchQuiet(`currentUnit -t "+$currentTimeUnit+"`)");
*/
//Possible restore
if (`currentUnit -q -t`=="sec")
	currentUnit  -t "film";

if ($segmentReplacing)
	$segRepOffset=`currentTime -q`;

if ($segmentReplacing)
	{
	if (`objExists subTitles_parentConstraint1`)
		delete subTitles_parentConstraint1;
	if (`objExists ($nameSpace+"subTitles")`)
		xform -ws -t 0 0 0 -ro 0 0 0 -s 1 1 1 ($nameSpace+"subTitles");
	}
else
	{
	$deleteObjs={"subTitles","subTitlesExp","subTitlesBox","subTitlesArrow","subTitlesBoxMPD"};
	for ($i=0;$i<size($deleteObjs);$i++)
		if (`objExists ($nameSpace+$deleteObjs[$i])`)
			delete ($nameSpace+$deleteObjs[$i]);

	createNode -n ($nameSpace+"subTitles") transform;
	createNode -n ($nameSpace+"subTitlesRoller") -p ($nameSpace+"subTitles") transform;
	$tempString[0]=`curve -d 1 -p -4 1.25 0 -p -4 -0.5 0 -p 4 -0.5 0 -p 4 1.25 0 -p -4 1.25 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
	rename $tempString[0] ($nameSpace+"subTitlesBox");
	setAttr ($nameSpace+"subTitlesBoxShape.overrideEnabled") 1;
	setAttr ($nameSpace+"subTitlesBoxShape.overrideColor") 13;
	$tempString[0]=`curve -d 1 -p 0 0.65 0 -p 0.127 1.2 0 -p -0.127 1.2 0 -p 0 0.65 0 -k 0 -k 1 -k 2 -k 3`;
	parent ($nameSpace+"subTitlesBox") ($nameSpace+"subTitles");
	addAttr -k 1 -ln textVisCenter -at double -dv 4.5 ($nameSpace+"subTitlesBox");
	addAttr -k 1 -ln textVisLenght -at double -dv 8 ($nameSpace+"subTitlesBox");
	createNode -n ($nameSpace+"subTitlesBoxMPD") multiplyDivide;
	connectAttr ($nameSpace+"subTitlesBox.sx") ($nameSpace+"subTitlesBoxMPD.input1X");
	connectAttr ($nameSpace+"subTitlesBox.sx") ($nameSpace+"subTitlesBoxMPD.input1Y");
	setAttr ($nameSpace+"subTitlesBoxMPD.input2") -type float3 4 8 0;
	connectAttr ($nameSpace+"subTitlesBoxMPD.outputX") ($nameSpace+"subTitlesBox.textVisCenter");
	connectAttr ($nameSpace+"subTitlesBoxMPD.outputY") ($nameSpace+"subTitlesBox.textVisLenght");

	rename $tempString[0] ($nameSpace+"subTitlesArrow");
	setAttr ($nameSpace+"subTitlesArrowShape.overrideEnabled") 1;
	setAttr ($nameSpace+"subTitlesArrowShape.overrideColor") 13;
	parent -add -s ($nameSpace+"subTitlesArrowShape") ($nameSpace+"subTitlesBox");
	delete ($nameSpace+"subTitlesArrow");

	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"ctrlPhonemes_M")`;
	if (size($tempString)) delete $tempString;
	$tempString=`listAttr -ud ($nameSpace+"ctrlPhonemes_M")`;
	for ($i=0;$i<size($tempString);$i++)
		if (!`getAttr -l ($nameSpace+"ctrlPhonemes_M."+$tempString[$i])`)
			setAttr ($nameSpace+"ctrlPhonemes_M."+$tempString[$i]) 0;
	if (`attributeExists jaw ($nameSpace+"ctrlPhonemes_M")`)//could have converted to SimplifiedFaceSetup
		{
		setAttr ($nameSpace+"ctrlPhonemes_M.jaw") 0.25;
		setAttr ($nameSpace+"ctrlPhonemes_M.lip") 0.25;
		if (`objExists asFaceBS`)//FaceSetup is BlendShapes, which does not (yet) work with Mulipliers
			{
			setAttr ($nameSpace+"ctrlPhonemes_M.jaw") 1;
			setAttr ($nameSpace+"ctrlPhonemes_M.lip") 1;
			}
		}
	}

$fileId=`fopen $textGridFile "r"`;
$nextLine = `fgetline $fileId`;
while (size($nextLine)>0)
	{
	$line=`strip $nextLine`;
	tokenize $line " = " $tempString;
	$para=$tempString[0];
	$value=$tempString[1];
	if ($sequenceStart==-1 && $para=="xmin") {$sequenceStart=$value;$sequenceStart*=$fps;}
	if ($sequenceEnd==-1 && $para=="xmax") {$sequenceEnd=$value;$sequenceEnd*=$fps;}
	if ($para=="name" && $value=="\"words\"") $wordsSection=1;
	if ($para=="name" && $value=="\"phones\"") {$phonesSection=1;$wordsSection=0;}
	if ($para=="xmin") $xMin=$value;
	if ($para=="xmax") $xMax=$value;
	if ($wordsSection && $para=="text")
		{
		$tempString[0]=`substituteAllString $value "\"" ""`;
		if ($tempString[0]!="")
			{
			$words[size($words)]=$tempString[0];
			$wordStarts[size($wordStarts)]=($xMin+$segRepOffset+$offset)*$fps;
			$wordEnds[size($wordEnds)]=($xMax+$segRepOffset+$offset)*$fps;
			}
		}
	if ($phonesSection && $para=="text")
		{
		$tempString[0]=`substituteAllString $value "\"" ""`;
		if ($tempString[0]!="")
			{
			$phones[size($phones)]=$tempString[0];
			$phoneStarts[size($phoneStarts)]=($xMin+$segRepOffset+$offset)*$fps;
			$phoneEnds[size($phoneEnds)]=($xMax+$segRepOffset+$offset)*$fps;
			}
		}
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

for ($i=0;$i<size($words);$i++)
	if ($words[$i]=="<unk>")
		$words[$i]="***";

if (!$segmentReplacing)
	playbackOptions -min ($sequenceStart+$offset) -ast ($sequenceStart+$offset) -aet ($sequenceEnd+$offset) -max ($sequenceEnd+$offset);

//ensure key of value 0 at frame 0
setKeyframe -itt linear -ott linear -t 0 -v 0 ($nameSpace+"subTitlesRoller.tx");

for ($i=0;$i<9999;$i++)
	if (!`objExists ($nameSpace+"text"+$i)`)
		break;
$wordNr=$i;

//render non supported symbols, from utf-8 format text files
if ($nonLatin)
	{
	if (!`file -q -ex ($tempDir+"render")`)
		sysFile -md ($tempDir+"render");
	$pythonCmd="";
	$pythonCmd+="wordsSection = 0\n";
	$pythonCmd+="wordNr = "+$wordNr+"\n";
	$pythonCmd+="searchfile = open('"+$textGridFile+"','r')\n";
	$pythonCmd+="for line in searchfile:\n";
	$pythonCmd+="	if line.find('name = \"words\"') != -1:\n";
	$pythonCmd+="		wordsSection = 1\n";
	$pythonCmd+="	if line.find('name = \"phones\"') != -1:\n";
	$pythonCmd+="		wordsSection = 0\n";
	$pythonCmd+="	if wordsSection == 1:\n";
	$pythonCmd+="		if line.find('text = ') != -1:\n";
	$pythonCmd+="			word = line.split()[2].replace('\"','')\n";
	$pythonCmd+="			if word == '':\n";
	$pythonCmd+="				continue\n";
	$pythonCmd+="			wordFile = open ('"+$tempDir+"render/word'+str(wordNr)+'.txt','w')\n";
	$pythonCmd+="			wordFile.write (word)\n";
	$pythonCmd+="			wordFile.close ()\n";
	$pythonCmd+="			wordNr = wordNr + 1\n";
	$pythonCmd+="searchfile.close()\n";
	python ($pythonCmd);
	}

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Reading Data" -bp -ii 1 -min 0 -max (size($words)+1) $gMainProgressBar;

for ($i=0;$i<size($words);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	currentTime $wordStarts[$i];
	if ($nonLatin)
		{
		$font="arial";
		if ($language=="thai") $font="tahoma";
		if ($language=="korean") $font="Malgun-Gothic";
		$imConvertCmdLine=$imConvertCmd+" -background black -fill white -font "+$font+" -pointsize 72 label:@"+$tempDir+"render/word"+$wordNr+".txt "+$tempDir+"render/word"+$wordNr+".png";
		system ($imConvertCmdLine);
		$tempString=`ls ($nameSpace+"text*"+$wordNr)`;
		for ($y=0;$y<size($tempString);$y++)
			if (`objExists $tempString[$y]`) delete $tempString[$y];
		polyPlane -n ($nameSpace+"text"+$wordNr) -w 1 -h 1 -sx 1 -sy 1 -ax 0 0 1 -cuv 2 -ch 0;
		shadingNode -n ($nameSpace+"textShader"+$wordNr) -asShader surfaceShader;
		sets -renderable true -noSurfaceShader true -empty -name ($nameSpace+"textSG"+$wordNr);
		connectAttr -f ($nameSpace+"textShader"+$wordNr+".outColor") ($nameSpace+"textSG"+$wordNr+".surfaceShader");
		sets -e -forceElement ($nameSpace+"textSG"+$wordNr) ($nameSpace+"text"+$wordNr);
		createNode -n ($nameSpace+"textFile"+$wordNr) file;
		connectAttr -force ($nameSpace+"textFile"+$wordNr+".outColor") ($nameSpace+"textShader"+$wordNr+".outColor");
		setAttr -type "string" ($nameSpace+"textFile"+$wordNr+".fileTextureName") ($tempDir+"render/word"+$wordNr+".png");
		move -r -ws -wd 0.5 0 0 ($nameSpace+"text"+$wordNr+".vtx[0:99]");
		scale -r -p 0 0 0 ((size($words[$i])/2.25)) 1 1 ($nameSpace+"text"+$wordNr+".vtx[0:99]");

//		setAttr ($nameSpace+"text"+$wordNr+".sx") ((size($words[$i])/2.0));
		}
	else
		{
		$tempString=`textCurves -f "Times New Roman|wt:50|sz:28" -t $words[$i]`;
		delete `ls -type makeTextCurves`;
		rename $tempString[0] ($nameSpace+"text"+$wordNr);
		}

	setAttr ($nameSpace+"text"+$wordNr+".tx") $wordSpace;//word spacing
	parent ($nameSpace+"text"+$wordNr) ($nameSpace+"subTitlesRoller");
	setKeyframe -itt linear -ott linear -t $wordStarts[$i] -v (`getAttr ($nameSpace+"subTitlesRoller.tx")`-$wordSpace) ($nameSpace+"subTitlesRoller.tx");
	$bb=`xform -q -ws -bb ($nameSpace+"text"+$wordNr)`;
	$keyValue=`getAttr ($nameSpace+"subTitlesRoller.tx")`-($bb[0]+$bb[3]);
	setKeyframe -itt linear -ott linear -t $wordEnds[$i] -v $keyValue ($nameSpace+"subTitlesRoller.tx");

	$wordNr++;
	}

for ($i=0;$i<size($phones);$i++)
	{
	if ($phones[$i]=="sil" || $phones[$i]=="sp" || $phones[$i]=="spn") 
		continue;
//	if ($language=="english")
		$phoneme=`asAutoLipSyncPhonemeMapping $phones[$i]`;
//	else
//		$phoneme=`substring $language 1 3`+"_"+`asPhonemeTranslate $phones[$i] 0`;
	if ($phoneme=="" || !`attributeExists $phoneme ($nameSpace+"ctrlPhonemes_M")`)
		{
		if (!`stringArrayCount $phoneme $missingPhoneParts`)
			$missingPhoneParts[size($missingPhoneParts)]="Phoneme:\""+$phoneme+"\", from the phone:	\""+$phones[$i]+"\"";
		continue;
		}

	setKeyframe -v 0 -t ($phoneStarts[$i]-$prePhoneTime) ($nameSpace+"ctrlPhonemes_M."+$phoneme);
	setKeyframe -v 10 -t (($phoneStarts[$i]+$phoneEnds[$i])/2.0) ($nameSpace+"ctrlPhonemes_M."+$phoneme);
	setKeyframe -v 0 -t ($phoneEnds[$i]+$postPhoneTime) ($nameSpace+"ctrlPhonemes_M."+$phoneme);
	}

if (size($missingPhoneParts))
	{
	print "Found the following phonemes, that are not mapped to the current FaceSetup:\n";
	print $missingPhoneParts;
	}
progressBar -e -ep $gMainProgressBar;

currentTime 0;
//currentUnit -t $currentTimeUnit;

//Find each letter`s offset, and animate visibility to be visible only inside box
//currentUnit -t "pal";
currentTime 0 ;
$tempString=`listRelatives -ad -type transform ($nameSpace+"subTitlesRoller")`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] "Char_*"` && !$nonLatin)
		continue;
	$letters[size($letters)]=$tempString[$i];
	}
$bb=`xform -q -ws -bb ($nameSpace+"subTitlesBox")`;
$boxWidth=($bb[3]-$bb[0])/`getAttr ($nameSpace+"subTitles.sx")`;
if ($nameSpace!="" && `objExists subTitlesRoller_translateX`)
	rename subTitlesRoller_translateX ($nameSpace+"subTitlesRoller_translateX");
$keyTimes=`keyframe -q -tc ($nameSpace+"subTitlesRoller_translateX")`;
$lastKeyFrameNr=$keyTimes[size($keyTimes)-1];
progressBar -e -st "Animating text visibility" -bp -ii 1 -min 0 -max ($lastKeyFrameNr+1) $gMainProgressBar;
for ($y=0;$y<size($letters);$y++)
	{
	if (`objExists ($letters[$y]+"PMA")`)
		continue;
	createNode -n ($letters[$y]+"PMA") plusMinusAverage;
	connectAttr -f ($nameSpace+"subTitlesRoller_translateX.output") ($letters[$y]+"PMA.input1D[1]");
	connectAttr -f ($nameSpace+"subTitlesBox.textVisCenter") ($letters[$y]+"PMA.input1D[2]");
	$bb=`xform -q -ws -bb $letters[$y]`;
	setAttr ($letters[$y]+"PMA.input1D[0]") ($bb[0]+0.5);
	createNode -n ($letters[$y]+"Clamp") clamp;
	connectAttr -f ($letters[$y]+"PMA.output1D") ($letters[$y]+"Clamp.inputR");
	setAttr ($letters[$y]+"Clamp.maxR") 1000;
	createNode -n ($letters[$y]+"Condition") condition;
	setAttr ($letters[$y]+"Condition.operation") 2;
	connectAttr -f ($letters[$y]+"Clamp.outputR") ($letters[$y]+"Condition.firstTerm");
	connectAttr -f ($letters[$y]+"Clamp.outputR") ($letters[$y]+"Condition.colorIfFalseR");
	connectAttr -f ($nameSpace+"subTitlesBox.textVisLenght") ($letters[$y]+"Condition.secondTerm");
	connectAttr -f ($letters[$y]+"Condition.outColorR") ($letters[$y]+".v");
	}

//Place subTitles
$bb=`xform -q -ws -bb ($nameSpace+"subTitles")`;
setAttr ($nameSpace+"subTitles.s") -type float3 ($scale/10.0) ($scale/10.0) ($scale/10.0);
$bb=`xform -q -ws -bb ($nameSpace+"ctrlBox")`;
$bb2=`xform -q -ws -bb ($nameSpace+"ctrlPhonemes_M")`;
$bb3=`xform -q -ws -bb ($nameSpace+"subTitlesBox")`;
xform -ws -t ($bb[3]+$bb3[3]*1.2) $bb2[1] $bb[5] ($nameSpace+"subTitles");
parentConstraint -mo ($nameSpace+"ctrlBox") ($nameSpace+"subTitles");

if ($segmentReplacing)
	{
	select -r ($nameSpace+"subTitles");
	currentTime $timeRangeArray[0];
	dgdirty -a;
	return;
	}

//Remove existing animation, if Idle animations is to be added
if ($autoBlink)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"ctrlEye_R") ($nameSpace+"ctrlEye_L")`;
	if (size($tempString)) delete $tempString;
	}
if ($autoGlimpse)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"Eye_R") ($nameSpace+"Eye_L")`;
	if (size($tempString)) delete $tempString;
	}
if ($autoHead)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"FKHead_M")`;
	if (size($tempString)) delete $tempString;
	}
if ($autoBlink)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"ctrlEye_R") ($nameSpace+"ctrlEye_L")`;
	if (size($tempString)) delete $tempString;
	}

//Add Idle animations
if ($autoHead)
	setAttr ($nameSpace+"AimEye_M.follow") 0;
$nextBlinkTriggFrameNr=$keyTimes[0]+`rand 25 40`;
$nextGlipseTriggFrameNr=$keyTimes[0]+`rand 25 40`;
$nextHeadTriggFrameNr=$keyTimes[0]+`rand 80 100`;
for ($i=1;$i<`playbackOptions -q -max`;$i++)
	{
	if ($i<$keyTimes[0])
		continue;//no Idle-anim before first word
	if ($autoBlink && $i==$nextBlinkTriggFrameNr)
		{
		$nextBlinkTriggFrameNr=$i+`rand 50 250`;
		setKeyframe -t $i -v 1.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+1) -v 10 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+3) -v 10 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+6) -v 1.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");

		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*1/4)) -v 2.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*3.8/4)) -v 2.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		//squint
		$tempFloat[0]=`rand 1 5`;
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*1.5/4)) -v 0 ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*2/4)) -v $tempFloat[0] ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*3.8/4)) -v $tempFloat[0] ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*4/4)) -v 0 ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");
		}

	if ($autoGlimpse && $i==$nextGlipseTriggFrameNr)
		{
		$nextGlipseTriggFrameNr=$i+`rand 50 200`;
		setKeyframe -t $i -v 0 ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry") ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		$tempFloat[0]=`rand -1 1`;
		$tempFloat[1]=`rand -6 6`;
		setKeyframe -t ($i+10) -v $tempFloat[0] ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		setKeyframe -t ($i+10) -v $tempFloat[1] ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry");
		setKeyframe -t ($i+15) -v $tempFloat[0] ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		setKeyframe -t ($i+15) -v $tempFloat[1] ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry");
		setKeyframe -t ($i+20) -v 0 ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry") ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		setKeyframe -t ($i+25) -v 0 ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry") ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		$tempFloat[0]=`rand -1 1`;
		$tempFloat[1]=`rand -6 6`;
		setKeyframe -t ($i+30) -v $tempFloat[0] ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		setKeyframe -t ($i+30) -v $tempFloat[1] ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry");
		setKeyframe -t ($i+38) -v $tempFloat[0] ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		setKeyframe -t ($i+38) -v $tempFloat[1] ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry");
		setKeyframe -t ($i+41) -v 0 ($nameSpace+"Eye_L.ry") ($nameSpace+"Eye_R.ry") ($nameSpace+"Eye_L.rx") ($nameSpace+"Eye_R.rx");
		}

	if ($autoHead && $i==$nextHeadTriggFrameNr)
		{
		$nextHeadTriggFrameNr=$i+`rand 25 300`;
		$moveDur=`rand 5 20`;
		$tempFloat=`getAttr -t $i ($nameSpace+"FKHead_M.r")`;
		setKeyframe -t $i -v $tempFloat[0] ($nameSpace+"FKHead_M.rx");
		setKeyframe -t $i -v $tempFloat[1] ($nameSpace+"FKHead_M.ry");
		setKeyframe -t $i -v $tempFloat[2] ($nameSpace+"FKHead_M.rz");
			setKeyframe -t ($i+($moveDur/2.0)) -v ($tempFloat[2]-4) ($nameSpace+"FKHead_M.rz");
		setKeyframe -t ($i+$moveDur) -v `rand -8 8` ($nameSpace+"FKHead_M.rx");
		setKeyframe -t ($i+$moveDur) -v `rand -4 4` ($nameSpace+"FKHead_M.ry");
		setKeyframe -t ($i+$moveDur) -v `rand -2 2` ($nameSpace+"FKHead_M.rz");
		if ($autoEyeBrows)
			{
			$tempFloat=`getAttr -t $i ($nameSpace+"ctrlBrow_R.t")`;
			setKeyframe -t ($i+($moveDur/2.0)) -v $tempFloat[0] ($nameSpace+"ctrlBrow_R.tx") ($nameSpace+"ctrlBrow_L.tx");
			setKeyframe -t ($i+($moveDur/2.0)) -v $tempFloat[1] ($nameSpace+"ctrlBrow_R.ty") ($nameSpace+"ctrlBrow_L.ty");
			setKeyframe -t ($i+$moveDur) -v `rand -0.8 0.8` ($nameSpace+"ctrlBrow_R.tx") ($nameSpace+"ctrlBrow_L.tx");
			setKeyframe -t ($i+$moveDur) -v `rand -0.8 0.8` ($nameSpace+"ctrlBrow_R.ty") ($nameSpace+"ctrlBrow_L.ty");
			}
		}
	}

if ($nonLatin && !$segmentReplacing)
	setAttr ($nameSpace+"subTitlesBox.sx") 4;

select -r ($nameSpace+"subTitles");
dgdirty -a;
}

global proc string asAutoLipSyncPhonemeMapping (string $phone)
{
//We will do all upperCase, since the English "meta.yaml" is all upperCase
$phone=`toupper $phone`;

string $phoneme;
//english
if ($phone=="EY1") $phoneme="aaa";
if ($phone=="Z") $phoneme="sss";
if ($phone=="B") $phoneme="mbp";
if ($phone=="AA2") $phoneme="aaa";
if ($phone=="D") $phoneme="lntd";
if ($phone=="IY0") $phoneme="tth";//
if ($phone=="K") $phoneme="gk";
if ($phone=="AO2") $phoneme="ohh";
if ($phone=="R") $phoneme="rrr";
if ($phone=="T") $phoneme="lntd";
if ($phone=="G") $phoneme="gk";
if ($phone=="AH0") $phoneme="ahh";//
if ($phone=="OY1") $phoneme="ohh";
if ($phone=="N") $phoneme="lntd";
if ($phone=="L") $phoneme="lntd";
if ($phone=="M") $phoneme="mbp";
if ($phone=="AY1") $phoneme="ahh";//
if ($phone=="OW2") $phoneme="ohh";
if ($phone=="S") $phoneme="sss";
if ($phone=="P") $phoneme="mbp";
if ($phone=="EH2") $phoneme="eh";
if ($phone=="IY1") $phoneme="iee";
if ($phone=="AY2") $phoneme="aaa";
if ($phone=="OW1") $phoneme="ohh";
if ($phone=="ER0") $phoneme="schwa";//
if ($phone=="UW1") $phoneme="ohh";
if ($phone=="W") $phoneme="www";
if ($phone=="DH") $phoneme="lntd";
if ($phone=="JH") $phoneme="ssh";//
if ($phone=="IH1") $phoneme="iee";
if ($phone=="IH0") $phoneme="iee";
if ($phone=="NG") $phoneme="gk";
if ($phone=="IH2") $phoneme="eh";
if ($phone=="V") $phoneme="schwa";//
if ($phone=="AA1") $phoneme="ohh";
if ($phone=="TH") $phoneme="lntd";
if ($phone=="ZH") $phoneme="ssh";
if ($phone=="AE2") $phoneme="aaa";
if ($phone=="SH") $phoneme="ssh";
if ($phone=="EH1") $phoneme="eh";
if ($phone=="AA0") $phoneme="aaa";
if ($phone=="F") $phoneme="fff";
if ($phone=="AW1") $phoneme="www";
if ($phone=="AE1") $phoneme="aaa";
if ($phone=="OW0") $phoneme="ohh";
if ($phone=="AW2") $phoneme="aaa";
if ($phone=="EY2") $phoneme="eh";
if ($phone=="EY0") $phoneme="aaa";
if ($phone=="AE0") $phoneme="aaa";
if ($phone=="IY2") $phoneme="iee";
if ($phone=="CH") $phoneme="ssh";
if ($phone=="ER1") $phoneme="ahh";
if ($phone=="EH0") $phoneme="ahh";//
if ($phone=="UW2") $phoneme="ohh";
if ($phone=="AH1") $phoneme="ohh";
if ($phone=="HH") $phoneme="schwa";//
if ($phone=="AH2") $phoneme="ahh";
if ($phone=="AO0") $phoneme="ahh";
if ($phone=="OY2") $phoneme="ohh";
if ($phone=="OY0") $phoneme="ohh";
if ($phone=="UH1") $phoneme="ohh";
if ($phone=="AO1") $phoneme="ohh";
if ($phone=="UW0") $phoneme="ohh";
if ($phone=="Y") $phoneme="uuu";//
if ($phone=="AW0") $phoneme="aaa";
if ($phone=="AY0") $phoneme="ahh";
if ($phone=="ER2") $phoneme="ohh";
if ($phone=="UH0") $phoneme="uuu";
if ($phone=="UH2") $phoneme="ohh";

//bulgarian
if ($phone=="A") $phoneme="ahh";
if ($phone=="BJ") $phoneme="mbp";
if ($phone=="DZ") $phoneme="lntd";
if ($phone=="DJ") $phoneme="lntd";
if ($phone=="E") $phoneme="eh";
if ($phone=="FJ") $phoneme="fff";
if ($phone=="GJ") $phoneme="gk";
if ($phone=="I") $phoneme="iee";
if ($phone=="J") $phoneme="ssh";
if ($phone=="JA") $phoneme="tth";
if ($phone=="JU") $phoneme="tth";
if ($phone=="KJ") $phoneme="gk";
if ($phone=="LJ") $phoneme="lntd";
if ($phone=="MJ") $phoneme="mbp";
if ($phone=="NJ") $phoneme="lntd";
if ($phone=="O") $phoneme="ohh";
if ($phone=="PJ") $phoneme="mbp";
if ($phone=="RJ") $phoneme="rrr";
if ($phone=="SJ") $phoneme="ssh";
if ($phone=="TS") $phoneme="ssh";
if ($phone=="TJ") $phoneme="tth";
if ($phone=="U") $phoneme="uuu";
if ($phone=="VJ") $phoneme="schwa";
if ($phone=="X") $phoneme="ohh";
if ($phone=="ZJ") $phoneme="sss";

//Croatian
if ($phone=="DZP") $phoneme="lntd";
if ($phone=="tcp") $phoneme="sss";
if ($phone=="x") $phoneme="";//covered in bulgarian

//Czech
if ($phone=="AA") $phoneme="aaa";
if ($phone=="AW") $phoneme="ahh";
if ($phone=="C") $phoneme="ssh";
if ($phone=="EE") $phoneme="eh";
if ($phone=="EW") $phoneme="eh";
if ($phone=="H") $phoneme="schwa";
if ($phone=="II") $phoneme="iee";
if ($phone=="MG") $phoneme="mbp";
if ($phone=="OO") $phoneme="ohh";
if ($phone=="OW") $phoneme="ohh";
if ($phone=="RSH") $phoneme="rrr";
if ($phone=="RZH") $phoneme="rrr";
if ($phone=="UU") $phoneme="uuu";
 
//French
if ($phone=="AE") $phoneme="eh";
if ($phone=="AX") $phoneme="aaa";
if ($phone=="A~") $phoneme="ahh";
if ($phone=="EU") $phoneme="uuu";
if ($phone=="E~") $phoneme="eh";
if ($phone=="OE") $phoneme="ohh";
if ($phone=="OE~") $phoneme="ohh";
if ($phone=="o~") $phoneme="ohh";

//german
if ($phone=="+hGH") $phoneme="gk";
if ($phone=="C") $phoneme="ssh";
if ($phone=="AI") $phoneme="aaa";
if ($phone=="AU") $phoneme="aaa";
if ($phone=="AL") $phoneme="aaa";
if ($phone=="ATU") $phoneme="lntd";
if ($phone=="EL") $phoneme="eh";
if ($phone=="ETU") $phoneme="lntd";
if ($phone=="IL") $phoneme="lntd";
if ($phone=="OEL") $phoneme="lntd";
if ($phone=="OL") $phoneme="ohh";
if ($phone=="UE") $phoneme="uuu";
if ($phone=="UEL") $phoneme="lntd";
if ($phone=="UL") $phoneme="uuu";

//Hausa
if ($phone=="KR") $phoneme="gk";
if ($phone=="Q") $phoneme="uuu";
if ($phone=="AI") $phoneme="";//covered in german
if ($phone=="AU") $phoneme="";//covered in german
if ($phone=="A_L") $phoneme="aaa";
if ($phone=="A_S") $phoneme="aaa";
if ($phone=="A_T1") $phoneme="aaa";
if ($phone=="A_T2") $phoneme="aaa";
if ($phone=="A_T3") $phoneme="aaa";
if ($phone=="E_L") $phoneme="eh";
if ($phone=="E_S") $phoneme="eh";
if ($phone=="E_T1") $phoneme="eh";
if ($phone=="E_T2") $phoneme="eh";
if ($phone=="I_L") $phoneme="iee";
if ($phone=="I_S") $phoneme="iee";
if ($phone=="I_T1") $phoneme="iee";
if ($phone=="I_T2") $phoneme="iee";
if ($phone=="I_T3") $phoneme="iee";
if ($phone=="O_L") $phoneme="ohh";
if ($phone=="O_S") $phoneme="ohh";
if ($phone=="O_T1") $phoneme="ohh";
if ($phone=="O_T2") $phoneme="ohh";
if ($phone=="U_L") $phoneme="uuu";
if ($phone=="U_S") $phoneme="uuu";
if ($phone=="U_T1") $phoneme="uuu";
if ($phone=="U_T2") $phoneme="uuu";

//Korean
if ($phone=="BB") $phoneme="mbp";
if ($phone=="CHH") $phoneme="ssh";
if ($phone=="DD") $phoneme="lntd";
if ($phone=="EO") $phoneme="eh";
if ($phone=="GG") $phoneme="gk";
if ($phone=="JJ") $phoneme="ssh";
if ($phone=="KH") $phoneme="gk";
if ($phone=="PH") $phoneme="mbp";
if ($phone=="SS") $phoneme="sss";
if ($phone=="EUI") $phoneme="eh";
if ($phone=="IA") $phoneme="ahh";
if ($phone=="IE") $phoneme="iee";
if ($phone=="IEO") $phoneme="";
if ($phone=="IO") $phoneme="ohh";
if ($phone=="IU") $phoneme="uuu";
if ($phone=="OA") $phoneme="ohh";
if ($phone=="UEO") $phoneme="ohh";

//Mandarin (pinyin)
if ($phone=="A1") $phoneme="ahh";
if ($phone=="A2") $phoneme="ahh";
if ($phone=="A3") $phoneme="ahh";
if ($phone=="A4") $phoneme="ahh";
if ($phone=="A5") $phoneme="ahh";
if ($phone=="AI1") $phoneme="ahh";
if ($phone=="AI2") $phoneme="ahh";
if ($phone=="AI3") $phoneme="ahh";
if ($phone=="AI4") $phoneme="ahh";
if ($phone=="AI5") $phoneme="ahh";
if ($phone=="AO1") $phoneme="ohh";
if ($phone=="AO2") $phoneme="ohh";
if ($phone=="AO3") $phoneme="ohh";
if ($phone=="AO4") $phoneme="ohh";
if ($phone=="AO5") $phoneme="ohh";
if ($phone=="E1") $phoneme="eh";
if ($phone=="E2") $phoneme="eh";
if ($phone=="E3") $phoneme="eh";
if ($phone=="E4") $phoneme="eh";
if ($phone=="E5") $phoneme="eh";
if ($phone=="EI1") $phoneme="eh";
if ($phone=="EI2") $phoneme="eh";
if ($phone=="EI3") $phoneme="eh";
if ($phone=="EI4") $phoneme="eh";
if ($phone=="I1") $phoneme="iee"; 
if ($phone=="I2") $phoneme="iee";
if ($phone=="I3") $phoneme="iee";
if ($phone=="I4") $phoneme="iee";
if ($phone=="I5") $phoneme="iee";
if ($phone=="IA1") $phoneme="iee";
if ($phone=="IA2") $phoneme="iee";
if ($phone=="IA3") $phoneme="iee";
if ($phone=="IA4") $phoneme="iee";
if ($phone=="IA5") $phoneme="iee";
if ($phone=="IAO1") $phoneme="iee";
if ($phone=="IAO2") $phoneme="iee";
if ($phone=="IAO3") $phoneme="iee";
if ($phone=="IAO4") $phoneme="iee";
if ($phone=="IE1") $phoneme="iee";
if ($phone=="IE2") $phoneme="iee";
if ($phone=="IE3") $phoneme="iee";
if ($phone=="IE4") $phoneme="iee";
if ($phone=="IE5") $phoneme="iee";
if ($phone=="II1") $phoneme="iee";
if ($phone=="II2") $phoneme="iee";
if ($phone=="II3") $phoneme="iee";
if ($phone=="II4") $phoneme="iee";
if ($phone=="II5") $phoneme="iee";
if ($phone=="IO1") $phoneme="iee";
if ($phone=="IO2") $phoneme="iee";
if ($phone=="IO3") $phoneme="iee";
if ($phone=="IO4") $phoneme="iee";
if ($phone=="IOU1") $phoneme="iee";
if ($phone=="IOU2") $phoneme="iee";
if ($phone=="IOU3") $phoneme="iee";
if ($phone=="IOU4") $phoneme="iee";
if ($phone=="IU1") $phoneme="iee";
if ($phone=="IU2") $phoneme="iee";
if ($phone=="IU3") $phoneme="iee";
if ($phone=="IU4") $phoneme="iee";
if ($phone=="IU5") $phoneme="iee";
if ($phone=="O1") $phoneme="ohh";
if ($phone=="O2") $phoneme="ohh";
if ($phone=="O3") $phoneme="ohh";
if ($phone=="O4") $phoneme="ohh";
if ($phone=="O5") $phoneme="ohh";
if ($phone=="OU1") $phoneme="ohh";
if ($phone=="OU2") $phoneme="ohh";
if ($phone=="OU3") $phoneme="ohh";
if ($phone=="OU4") $phoneme="ohh";
if ($phone=="OU5") $phoneme="ohh";
if ($phone=="U1") $phoneme="uuu";
if ($phone=="U2") $phoneme="uuu";
if ($phone=="U3") $phoneme="uuu";
if ($phone=="U4") $phoneme="uuu";
if ($phone=="U5") $phoneme="uuu";
if ($phone=="UA1") $phoneme="uuu";
if ($phone=="UA2") $phoneme="uuu";
if ($phone=="UA3") $phoneme="uuu";
if ($phone=="UA4") $phoneme="uuu";
if ($phone=="UA5") $phoneme="uuu";
if ($phone=="UAI1") $phoneme="uuu";
if ($phone=="UAI2") $phoneme="uuu";
if ($phone=="UAI3") $phoneme="uuu";
if ($phone=="UAI4") $phoneme="uuu";
if ($phone=="UE1") $phoneme="uuu";
if ($phone=="UE2") $phoneme="uuu";
if ($phone=="UE3") $phoneme="uuu";
if ($phone=="UE4") $phoneme="uuu";
if ($phone=="UE5") $phoneme="uuu";
if ($phone=="UEI1") $phoneme="uuu";
if ($phone=="UEI2") $phoneme="uuu";
if ($phone=="UEI3") $phoneme="uuu";
if ($phone=="UEI4") $phoneme="uuu";
if ($phone=="UEI5") $phoneme="uuu";
if ($phone=="UO1") $phoneme="uuu";
if ($phone=="UO2") $phoneme="uuu";
if ($phone=="UO3") $phoneme="uuu";
if ($phone=="UO4") $phoneme="uuu";
if ($phone=="UO5") $phoneme="uuu";
if ($phone=="V1") $phoneme="www";
if ($phone=="V2") $phoneme="www";
if ($phone=="V3") $phoneme="www";
if ($phone=="V4") $phoneme="www";
if ($phone=="V5") $phoneme="www";
if ($phone=="VA1") $phoneme="www";
if ($phone=="VA2") $phoneme="www";
if ($phone=="VA3") $phoneme="www";
if ($phone=="VA4") $phoneme="www";
if ($phone=="VE1") $phoneme="www";
if ($phone=="VE2") $phoneme="www";
if ($phone=="VE3") $phoneme="www";
if ($phone=="VE4") $phoneme="www";

//Polish
if ($phone=="DZJ") $phoneme="sss";
if ($phone=="EO5") $phoneme="iee";
if ($phone=="N~") $phoneme="lntd";
if ($phone=="OC5") $phoneme="ohh";
if ($phone=="TSJ") $phoneme="sss";

//Portuguese
if ($phone=="A+") $phoneme="aaa";
if ($phone=="A~+") $phoneme="aaa";
if ($phone=="E+") $phoneme="eh";
if ($phone=="E~+") $phoneme="eh";
if ($phone=="I+") $phoneme="iee";
if ($phone=="IX") $phoneme="iee";
if ($phone=="I~") $phoneme="iee";
if ($phone=="I~+") $phoneme="iee";
if ($phone=="O+") $phoneme="ohh";
if ($phone=="O~+") $phoneme="ohh";
if ($phone=="RR") $phoneme="rrr";
if ($phone=="SCH") $phoneme="sss";
if ($phone=="U+") $phoneme="uuu"; 
if ($phone=="UX") $phoneme="uuu";
if ($phone=="U~") $phoneme="uuu";
if ($phone=="U~+") $phoneme="uuu";
if ($phone=="W~") $phoneme="www";

//Russian
if ($phone=="STS") $phoneme="sss";
if ($phone=="STSJ") $phoneme="sss";
if ($phone=="HRD") $phoneme="rrr";
if ($phone=="jE") $phoneme="eh";
if ($phone=="JO") $phoneme="ohh";

//Spanish
if ($phone=="EI") $phoneme="";
if ($phone=="OI") $phoneme="ohh";
if ($phone=="RF") $phoneme="rrr";

//Swahili
if ($phone=="GH") $phoneme="gk";
if ($phone=="MB") $phoneme="mbp"; 
if ($phone=="MV") $phoneme="mbp";
if ($phone=="ND") $phoneme="lntd";
if ($phone=="NG~") $phoneme="gk";
if ($phone=="NY") $phoneme="lntd";
if ($phone=="NZ") $phoneme="lntd";

//Swedish
if ($phone=="ABL") $phoneme="mbp";
if ($phone=="AEL") $phoneme="iee";
if ($phone=="ALE") $phoneme="lntd";
if ($phone=="ALEL") $phoneme="lntd";
if ($phone=="DR") $phoneme="lntd";
if ($phone=="KS") $phoneme="gk";
if ($phone=="LR") $phoneme="lntd";
if ($phone=="NR") $phoneme="lntd";
if ($phone=="OC") $phoneme="ohh";
if ($phone=="OLE") $phoneme="lntd";
if ($phone=="OLEL") $phoneme="lntd";
if ($phone=="OX") $phoneme="ohh";
if ($phone=="SR") $phoneme="sss";
if ($phone=="TR") $phoneme="rrr";
if ($phone=="UXL") $phoneme="uuu";

//Thai
if ($phone=="IIA") $phoneme="iee";
if ($phone=="KHW") $phoneme="gk";
if ($phone=="KW") $phoneme="gk";
if ($phone=="QQ") $phoneme="gk";
if ($phone=="UUA") $phoneme="uuu";
if ($phone=="VV") $phoneme="www";
if ($phone=="VVA") $phoneme="www";
if ($phone=="XX") $phoneme="ohh";
if ($phone=="YY") $phoneme="uuu";

//Turkish
if ($phone=="AB") $phoneme="mbp";
if ($phone=="SFT") $phoneme="sss";

//Ukrainian
if ($phone=="DZH") $phoneme="lntd";
if ($phone=="HJ") $phoneme="eh"; 
if ($phone=="KJ") $phoneme="gk";
if ($phone=="SHJ") $phoneme="sss"; 
if ($phone=="TSH") $phoneme="sss";
if ($phone=="TSHJ") $phoneme="sss";
if ($phone=="WJ") $phoneme="www";
if ($phone=="XJ") $phoneme="sss";
if ($phone=="ZHJ") $phoneme="ssh";

return $phoneme;
}

global proc asAutoLipSyncImportExampleVoice ()
{
string $soundFile,$text;
string $asScriptLocation=`asGetScriptLocation`;

$soundFile=$asScriptLocation+"/AdvancedSkeletonFiles/div/sound/exampleVoice.wav";
if (!`file -q -ex $soundFile`)
	error ("Unable to find the file:\""+$soundFile+"\"");
if (`objExists exampleVoice`)
	delete exampleVoice;
file -import -type "audio" -ignoreVersion -mergeNamespacesOnClash false -rpr "exampleVoice" -options "o=0" $soundFile;

$text="Conscious of its spiritual and moral heritage, the Union is founded on the indivisible, universal values of human dignity,\n";
$text+="freedom, equality and solidarity; it is based on the principles of democracy and the rule of law. It places the individual\n";
$text+="at the heart of its activities, by establishing the citizenship of the Union and by creating an area of freedom, security and justice.";
scrollField -e -tx $text asAutoLipSyncUIScrollField;
optionMenu -e -v "English" asAutoLipSyncLanguageOptionMenu;
if (`checkBox -q -v asAutoLipSyncNonLatinCheckBox`)
	{
	checkBox -e -v 0 asAutoLipSyncNonLatinCheckBox;
	asAutoLipSyncLanguageChanged;
	}

print ("// Example voice imported, you can now Run Auto LipSync.\n");
}

global proc asAutoLipSyncEnableMp3 ()
{
string $cmd;
if (`whatIs performFileDropAction`=="Unknown")
	error "\"performFileDropAction\" function not avaiable in this version of Maya. A newer version of Maya is reuired for this to work.";

$cmd+="global proc int performFileDropAction (string $theFile)\n";
$cmd+="{\n";
$cmd+="if (`gmatch $theFile \"*.mp3\"`)\n";
$cmd+="	{\n";
$cmd+="	asAutoLipSyncConvertMp3 $theFile;\n";
$cmd+="	return 0;\n";
$cmd+="	}\n";

$cmd+="return( performFileImportAction( $theFile ) );\n";
$cmd+="}\n";
evalEcho ($cmd);
print ("// mp3 files will not automatically get converted to wav, when dropped into Maya.\n");
}

global proc asAutoLipSyncConvertMp3 (string $theFile)
{
string $aligner=`text -q -l asAutoLipSyncAlignerText`;
string $ffmpeg=`substitute "mfa_align.exe" $aligner "ffmpeg.e"`;
if (`about -mac`)
	$ffmpeg=`substitute "mfa_align" $aligner "ffmpeg"`;
string $convertedFile=`substitute ".mp3" $theFile ".wav"`;
string $ffMpegCmd;
if (`about -mac` || `about -linux`)
	$ffMpegCmd="\""+$ffmpeg+"\" -y -i \""+$theFile+"\" \""+$convertedFile+"\"";
else
	$ffMpegCmd="start\/wait/I \"Converting Audio\" \""+$ffmpeg+"\" -y -i \""+$theFile+"\" \""+$convertedFile+"\"";
print ("// Starting Converting Audio:"+$ffMpegCmd+"\n");
system ($ffMpegCmd);
if (!`file -q -ex $convertedFile`)
	error ("Failed to create:\""+$convertedFile+"\"");
file -import -type "audio" -ignoreVersion -mergeNamespacesOnClash false -options "o=0" $convertedFile;
}

global proc asAutoLipSyncLanguageChanged ()
{
int $haveLanguage=1;
string $languageMenuValue=`optionMenu -q -v asAutoLipSyncLanguageOptionMenu`;
string $language=`tolower $languageMenuValue`;
string $languageZip=$language+".zip";
string $sLoc=`asGetScriptLocation`;
string $curl=$sLoc+"/AdvancedSkeletonFiles/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeletonFiles/bin/7za.e";
string $binDir=$sLoc+"/AdvancedSkeletonFiles/bin";
string $aligner=`text -q -l asAutoLipSyncAlignerText`;
string $zipFileUrl;
string $tempString[],$languageZipFiles[];
string $pretrainedModelsDir=`asStripPath $aligner 2`+"pretrained_models/";
string $phonemes[]=`asAutoLipSyncLanguagePhonemes $language`;

//latinWriting
if (`latinWriting $languageMenuValue`)
	{
	button -e -m 0 asAutoLipSyncUIButton;
	scrollField -e -m 1 asAutoLipSyncUIScrollField;
	}
else
	{
	button -e -m 1 asAutoLipSyncUIButton;
	scrollField -e -m 0 asAutoLipSyncUIScrollField;
	}

//ensure we have the Phonemes for the language
$languageZipFiles=`getFileList -fld $pretrainedModelsDir`;

if (!`stringArrayCount $languageZip $languageZipFiles`)
	{
	if (`confirmDialog -title "Confirm" -message ("Download files for \""+$language+"\ language?")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`=="Yes")
		$haveLanguage=0;
	else
		optionMenu -e -v "English" asAutoLipSyncLanguageOptionMenu;
	}

//save this as the new `default` language
optionVar -sv asAutoLipSyncLanguage $languageMenuValue;

if ($haveLanguage)
	return;

if (!`file -q -ex $pretrainedModelsDir`)
	error ("Folder not found:"+$pretrainedModelsDir);

//download language files
for ($a=0;$a<2;$a++)
	{
	if ($a==0) {$languageZip=$language+".zip";		$zipFileUrl="https://github.com/MontrealCorpusTools/mfa-models/raw/main/acoustic/"+$languageZip;}
	if ($a==1) {$languageZip=$language+"_g2p.zip";$zipFileUrl="https://github.com/MontrealCorpusTools/mfa-models/raw/main/g2p/1.0/"+$languageZip;}

	if ($language=="mandarin")
		$zipFileUrl="https://github.com/MontrealCorpusTools/mfa-models/raw/main/g2p/1.0/"+$language+"_pinyin_g2p.zip";//_pinyin variant

	if ($language=="korean")
		$zipFileUrl="https://github.com/MontrealCorpusTools/mfa-models/raw/main/g2p/1.0/"+$language+"_jamo_g2p.zip";//_jamo variant (not hangul)

	if (`about -mac` || `about -linux`)
		{
		$cmd="\"curl -k -L -o "+$pretrainedModelsDir+$languageZip+" "+$zipFileUrl+"\"";
		evalEcho ("system("+$cmd+")");
		}
	else
		{
		$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -L -o \""+$pretrainedModelsDir+$languageZip+"\" "+$zipFileUrl;
		print ("// Starting Download:"+$cmd+"\n");
		system ($cmd);
		}
	}
}

global proc string[] asAutoLipSyncLanguages ()
{
string $languages[]={"Bulgarian","Croatian","Czech","French","German","Hausa",
	"Korean","Mandarin","Polish","Portuguese","Russian","Spanish","Swahili","Swedish",
	"Thai","Turkish","Ukrainian","Vietnamese"};
//Maya appears to be the lower ASCII range, we need utf-8 for these languages
$languages=`stringArrayRemove {"Vietnamese"} $languages`;
return $languages;
}

global proc int latinWriting (string $language)
{
int $latin=1;
//Bulgarian: Cyrillic alphabet
//Korean: Hangul
//Mandarin: Hanzi 
//Russian: Cyrillic alphabet
//Thai: Thai script
//Ukrainian: Cyrillic alphabet
//Vietnamese: Vietnamese alphabet
string $latinWritingLaunguages[]={"Bulgarian","Korean","Mandarin","Russian","Thai","Ukrainian","Vietnamese"};
if (`stringArrayCount $language $latinWritingLaunguages`)
	$latin=0;

//proceed with assuming all languages should be Romanized
//$latin=1;

//checkBox can now choose this
$latin=!`checkBox -q -v asAutoLipSyncNonLatinCheckBox`;

return $latin;
}

global proc asAutoLipOpenTextEditor ()
{
string $tempDir=`asGetTempDirectory`+"AdvancedSkeleton/autoLipSync/";
string $forceTextFile=$tempDir+"input/align.txt";
string $pythonCmd;

if (!`file -q -ex ($tempDir+"input")`)
	sysFile -md ($tempDir+"input");

//utf-8 format
$pythonCmd+="txt = u'$\\u2026\\n'\n";
$pythonCmd+="with open('"+$forceTextFile+"', 'wb') as fp:\n";
$pythonCmd+="    fp.write(txt.encode('utf-8'))\n";
print $pythonCmd;
python ($pythonCmd);

system ("load \""+$forceTextFile+"\"");
}

global proc string asPhonemeTranslate (string $phonemes, int $toMaya)
{
//as some phoneme symbols are not valid in Maya-attribute-names, translate to valid symbols:
string $return;
if ($toMaya)
	{
	$return=`substitute "[~]" $phonemes "Tilde"`;
	$return=`substitute "[+]" $return "Plus"`;
	}
else
	{
	$return=`substitute "Tilde" $phonemes "~"`;
	$return=`substitute "Plus" $return "+"`;
	}
return $return;
}

global proc string[] asAutoLipSyncLanguagePhonemes (string $language)
{
string $phonemes[];

if ($language=="bulgarian")
	$phonemes={"S","Y","Z","a","b","bj","d","dZ","dj","dz","e","f","fj","g","gj","i","j","ja","ju","k","kj","l",
		"lj","m","mj","n","nj","o","p","pj","r","rj","s","sj","t","tS","tj","ts","u","v","vj","x","z","zj"};

if ($language=="croatian")
	$phonemes={"L","S","Z","a","b","d","dZ","dzp","e","f","g","i","j","k","l","m","n","nj","o","p","r","s","t",
		"tS","tcp","ts","u","v","x","z"};

if ($language=="czech")
	$phonemes={"a","aa","aw","b","c","ch","d","dj","e","ee","ew","f","g","h","i","ii","j","k","l","m","mg","n",
  "ng","nj","o","oo","ow","p","r","rsh","rzh","s","sh","t","tj","u","uu","v","x","z","zh"};
 
//if ($language=="english")
//	$phonemes={"AA0","AA1","AA2","AE0","AE1","AE2","AH0","AH1","AH2","AO0","AO1","AO2,AW0","AW1","AW2","AY0",
//	"AY1","AY2","EH0","EH1","EH2","ER0","ER1","ER2,EY0","EY1","EY2","IH0","IH1","IH2","IY0","IY1","IY2","OW0",
//	"OW1","OW2,OY0","OY1","OY2","UH0","UH1","UH2","UW0","UW1","UW2,B","CH","D","DH","F","G","HH","JH","K","L",
//	"M","N","NG","P","R,S","SH","T","TH","V","W","Y","Z","ZH"};

if ($language=="french")
	$phonemes={"AE","AX","A~","B","D","E","EU","E~","F","G","H","J","K","L","M","N","NG","NJ","O","OE","OE~",
  "P","R","S","SH","T","V","W","Z","ZH","a","e","h","i","o","o~","u","y"};

if ($language=="german")
	$phonemes={"+hGH","C","S","a","aI","aU","ae","al","atu","b","d","e","eU","el","etu","f","g","h","i","il","j",
		"k","l","m","n","ng","o","oe","oel","ol","p","r","s","t","ts","u","ue","uel","ul","v","x","z"};

if ($language=="hausa")
	$phonemes={"B","D","DZ","F","K","KR","Q","R","S","TS","a","aI","aU","a_L","a_S","a_T1","a_T2","a_T3","b","c",
		"d","e","e_L","e_S","e_T1","e_T2","g","h","i","i_L","i_S","i_T1","i_T2","i_T3","j","k","l","m","n","o","o_L",
		"o_S","o_T1","o_T2","p","r","s","t","u","u_L","u_S","u_T1","u_T2","w","z"};

if ($language=="korean")
	$phonemes={"A","AE","B","BB","CHh","D","DD","E","EO","EU","G","GG","H","I","J","JJ","Kh","L","M","N","NG","O",
		"OE","Ph","R","S","SS","Th","U","UE","euI","iA","iE","iEO","iO","iU","k","oA","p","t","uEO"};

if ($language=="mandarin")
	$phonemes={"a1","a2","a3","a4","a5","ai1","ai2","ai3","ai4","ai5","ao1","ao2","ao3","ao4","ao5","b",
  "c","ch","d","e1","e2","e3","e4","e5","ei1","ei2","ei3","ei4","f","g","h","i1","i2","i3","i4","i5","ia1",
  "ia2","ia3","ia4","ia5","iao1","iao2","iao3","iao4","ie1","ie2","ie3","ie4","ie5","ii1","ii2","ii3",
  "ii4","ii5","io1","io2","io3","io4","iou1","iou2","iou3","iou4","iu1","iu2","iu3","iu4","iu5","j",
  "k","l","m","n","ng","o1","o2","o3","o4","o5","ou1","ou2","ou3","ou4","ou5","p","q","r","s","sh","t",
  "u1","u2","u3","u4","u5","ua1","ua2","ua3","ua4","ua5","uai1","uai2","uai3","uai4","ue1","ue2","ue3",
  "ue4","ue5","uei1","uei2","uei3","uei4","uei5","uo1","uo2","uo3","uo4","uo5","v1","v2","v3","v4",
  "v5","va1","va2","va3","va4","ve1","ve2","ve3","ve4","x","z","zh"};

if ($language=="polish")
	$phonemes={"S","Z","a","b","c","d","dZ","dz","dzj","e","eo5","f","g","h","i","i2","j","k","l","m","n","n~","o",
		"oc5","p","r","s","sj","t","tS","tsj","u","v","w","z","zj"};

if ($language=="portuguese")
	$phonemes={"A","A+","AX","A~","A~+","B","D","DJ","E","E+","E~","E~+","F","G","I","I+","IX","I~","I~+","K","L",
		"LJ","M","N","NJ","O","O+","O~","O~+","P","R","RR","S","SCH","T","TJ","U","U+","UX","U~","U~+","V","W","W~","Z"};

if ($language=="russian")
	$phonemes={"S","Sj","StS","StSj","Z","Zj","a","b","bj","d","dj","e","f","g","hrd","i","i2","j","jA","jE",
  "jO","jU","k","l","lj","m","mj","n","nj","o","p","pj","r","rj","s","sj","t","tS","tSj","tj","ts","u","v",
  "vj","x","z","zj"};

if ($language=="spanish")
	$phonemes={"D","G","L","T","V","a","a+","aI","aU","b","d","e","e+","eI","eU","f","g","i","i+","j","k","l",
  "m","n","ng","n~","o","o+","oI","p","r","rf","s","t","tS","u","u+","w","x","z"};

if ($language=="swahili")
	$phonemes={"a","b","ch","d","dh","e","f","g","gh","h","i","j","k","kh","l","m","mb","mv","n","nd","ng","ng~",
		"nj","ny","nz","o","p","r","s","sh","t","th","u","v","w","y","z"};

if ($language=="swedish")
	$phonemes={"C","S","a","abl","ae","ael","al","ale","alel","b","d","dr","e","el","etu","f","g","h","i","il","j",
		"k","ks","l","lr","m","n","ng","nr","o","oc","oe","oel","ol","ole","olel","ox","p","r","s","sr","t","tr","u",
		"ue","uel","ul","uxl","v"};

if ($language=="thai")
	$phonemes={"a","aa","b","c","ch","d","e","ee","f","h","i","ii","iia","j","k","kh","khw","kw","l","m","n","ng",
		"o","oo","p","ph","q","qq","r","s","t","th","u","uu","uua","v","vv","vva","w","x","xx","y","yy","z"};

if ($language=="turkish")
	$phonemes={"S","Z","ab","b","d","dZ","e","f","g","h","i","i2","j","k","l","m","n","o","oe","p","r","s","sft",
  "t","tS","u","ue","v","z"};

if ($language=="ukrainian")
	$phonemes={"a","b","bj","d","dj","dz","dzh","dzj","e","f","fj","g","h","hj","i","j","k","kj","l","lj","m","mj",
		"n","nj","o","p","pj","r","rj","s","sh","shj","sj","t","tj","ts","tsh","tshj","tsj","u","w","wj","x","xj",
		"y","z","zh","zhj","zj"};

if ($language=="vietnamese")
	$phonemes={"WB","a1_T1","a1_T2","a1_T3","a1_T4","a1_T5","a1_T6","a2_T1","a2_T2","a2_T3","a2_T4",
  "a2_T5","a2_T6","a3_T1","a3_T2","a3_T3","a3_T4","a3_T5","a3_T6","ai_T1","ai_T2","ai_T3","ai_T4",
  "ai_T5","ai_T6","ao_T1","ao_T2","ao_T3","ao_T4","ao_T5","ao_T6","au3_T1","au3_T2","au3_T3",
  "au3_T4","au3_T5","au3_T6","au_T1","au_T2","au_T3","ay3_T1","ay3_T2","ay3_T3","ay3_T4","ay3_T5",
  "ay3_T6","ay_T1","ay_T2","ay_T3","ay_T4","ay_T5","ay_T6","b","ch","d1","d2","e1_T1","e1_T2","e1_T3",
  "e1_T4","e1_T5","e1_T6","e2_T1","e2_T2","e2_T3","e2_T4","e2_T5","e2_T6","eo_T1","eo_T2","eo_T3",
  "eo_T4","eo_T5","eo_T6","eu_T2","eu_T3","eu_T4","eu_T6","g","h","i_T1","i_T2","i_T3","i_T4","i_T5",
  "i_T6","ie2_T1","ie2_T2","ie2_T3","ie2_T4","ie2_T5","ie2_T6","ieu_T1","ieu_T2","ieu_T3","ieu_T4",
  "ieu_T6","iu_T1","iu_T2","iu_T3","iu_T4","iu_T5","iu_T6","j","k","kh","l","m","n","ng","nh","o1_T1",
  "o1_T2","o1_T3","o1_T4","o1_T5","o1_T6","o2_T1","o2_T2","o2_T3","o2_T4","o2_T5","o2_T6","o3_T1",
  "o3_T2","o3_T3","o3_T4","o3_T5","o3_T6","oa_T1","oa_T2","oa_T3","oa_T4","oa_T5","oa_T6","oe_T1",
  "oe_T2","oe_T3","oe_T4","oe_T6","oi2_T1","oi2_T2","oi2_T3","oi2_T4","oi2_T5","oi2_T6","oi3_T1",
  "oi3_T2","oi3_T3","oi3_T4","oi3_T5","oi3_T6","oi_T1","oi_T2","oi_T3","oi_T4","oi_T5","oi_T6",
  "p","ph","r","s","t","th","tr","u1_T1","u1_T2","u1_T3","u1_T4","u1_T5","u1_T6","u2_T1","u2_T2",
  "u2_T3","u2_T4","u2_T5","u2_T6","ua2_T1","ua2_T2","ua2_T3","ua2_T4","ua2_T5","ua2_T6","ua_T1",
  "ua_T2","ua_T3","ua_T4","ua_T5","ua_T6","ui2_T4","ui_T1","ui_T2","ui_T3","ui_T4","ui_T5","ui_T6",
  "uoi2_T1","uoi2_T3","uoi2_T4","uoi2_T5","uoi2_T6","uoi3_T1","uoi3_T2","uoi3_T3","uoi3_T4",
  "uoi3_T5","uou_T6","uu2_T1","uu2_T2","uu2_T3","uu2_T4","uu2_T5","uu2_T6","uy_T1","uy_T2","uy_T3",
  "uy_T4","uy_T5","uy_T6","v","x"};

return $phonemes;
}

global proc asDynBake (string $uiName)
{
float $pos[],$rot[];
string $lastToken;
string $tempString[],$tempString2[],$dynJoints[],$softDynCurves[],$fkCtrls[],$bakeXforms[];

if (`asHotKeyCheck "asDynBake \"\""`) return;

if (`confirmDialog -title "Confirm" -message "Bake all dynamics ?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;

if (!`objExists Dynamics`)
	error "Dynamics not found";

createNode -n BakeXforms transform;
$dynJoints=`listRelatives -type joint -ad Dynamics`;
for ($y=0;$y<size($dynJoints);$y++)
	{
	$tempString=`listConnections ($dynJoints[$y]+".r")`;
	if (`objectType $tempString[0]`=="pairBlend")
		$tempString=`listConnections ($tempString[0]+".outRotate.outRotateX")`;
//	$fkCtrl="FK"+$tempString[0];
	tokenize $tempString[0] ":" $tempString2;
//	if (size($tempString2)==2) $fkCtrl=$tempString2[0]+":FK"+$tempString2[1];
	//allow for nested nameSpaces
	$lastToken=$tempString2[size($tempString2)-1];
	$fkCtrl=`substitute $lastToken $tempString[0] ("FK"+$lastToken)`;
	if (!`objExists $fkCtrl`)
		continue;
	$fkCtrls[size($fkCtrls)]=$fkCtrl;
	$bakeXforms[size($bakeXforms)]="Bake"+$dynJoints[$y];
	createNode -n ("Bake"+$dynJoints[$y]) -p BakeXforms transform;
	parentConstraint $dynJoints[$y] ("Bake"+$dynJoints[$y]);
	}

if (size($bakeXforms))
	{
	bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 1 -sparseAnimCurveBake false -controlPoints false -shape false $bakeXforms;
	delete `listRelatives -ad -type parentConstraint BakeXforms`;
	}
delete Dynamics;

for ($i=0;$i<size($fkCtrls);$i++)
	parentConstraint $bakeXforms[$i] $fkCtrls[$i];

if (size($fkCtrls))
	{
	bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 1 -sparseAnimCurveBake false -controlPoints false -shape false $fkCtrls;
	delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 0 $fkCtrls;
	}
delete BakeXforms;
select -cl;
print ("// Dynamics bake complete.\n");
}

global proc asControlsVisibilityToggle ()
{
int $vis;

if (`asHotKeyCheck asControlsVisibilityToggle`) return;

string $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;
for ($i=0;$i<size($motionSystems);$i++)
    {
    if ($i==0)
        $vis=!(`getAttr ($motionSystems[$i]+".v")`);
    setAttr ($motionSystems[$i]+".v") $vis;
    }
}

global proc asSetupControlVisibilityHotKeyDialog ()
{
if (`asHotKeyCheck asSetupControlVisibilityHotKeyDialog`) return;

if (`confirmDialog -title "Confirm Control Visibility HotKey"
	-message ("Add toggle of control-visibility to the \"~\" hotkey.\n"
	+"For easy toggling visibility of controls.\n"
	+"Holding down the \"~\" key (next to the \"number 1\" on the keyboard) to see and select controls.\n"
	+"As you let go, controls will again be hidden.\n"
	+"The idea is to work without the `visual clutter` of the controls.\n"
	+"Tip: Ctrl+\"\~\" will leave the controls visible")
	-button "Confirm" -button "Cancel" -defaultButton "Confirm"
	-cancelButton "Cancel" -dismissString "Cancel"`!="Confirm")
	return;
asSetupControlVisibilityHotKey;
}

global proc asSetupControlVisibilityHotKey ()
{
if (!`runTimeCommand -q -ex advancedSkeletonVisibilitySwitch`)
	{
	nameCommand -ann "advancedSkeletonVisibilitySwitch" -c "advancedSkeletonVisibilitySwitch" advancedSkeletonVisibilitySwitchNameCommand;
	runTimeCommand -annotation "switches the visibility of controls" -category "User"
		-command ("int $vis;\nstring $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;\nfor ($i=0;$i<size($motionSystems);$i++)\n    {\n    if ($i==0)\n        $vis=!(`getAttr ($motionSystems[$i]+\".v\")`);\n    setAttr ($motionSystems[$i]+\".v\") $vis;\n    }")
		advancedSkeletonVisibilitySwitch;
	}
hotkey -keyShortcut "`"  -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "\`" -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "`"  -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "\`" -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
}

global proc advancedSkeletonVisibilitySwitch2 ()
{
global string $gMainPane;
int $isFront,$orto,$b;
float $s,$dist,$nearClipPlane,$bX,$bY;
float $autoPlacePos[],$camPos[],$bb[],$bPos[],$bbb[];
string $currentPanel,$cam,$pickerGroupParent,$itemLabel,$dagObjectHit,$ctrlHit,$buttonHit;
string $picker="picker_biped";
string $pickerGroup=$picker+":Group";
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $tempString[],$paneChildren[];
string $sel[]=`ls -sl`;

//if ($isFront)
setAttr PolyBoxes.v 1;
//refresh;
	if (`dagObjectHit`)
		{
		if (`popupMenu -exists asAutoPlaceMenu`)
			deleteUI asAutoPlaceMenu;
		popupMenu -mm 1 -p viewPanes asAutoPlaceMenu;
		dagObjectHit -mn asAutoPlaceMenu;
		$tempString=`popupMenu -q -itemArray asAutoPlaceMenu`;
		$itemLabel=`menuItem -q -l $tempString[0]`;
		tokenize $itemLabel "." $tempString;
		$dagObjectHit=$tempString[0];
//		print ("\n"+$dagObjectHit+" : ");
		}
setAttr PolyBoxes.v 0;

if (!`objExists $pickerGroup`)
	return;

if (!`attributeExists isFront $pickerGroup`)
	addAttr -k 0 -ln isFront -at bool $pickerGroup;
$isFront=!`getAttr ($pickerGroup+".isFront")`;

$currentPanel = `getPanel -withFocus`;
if (!`modelPanel -q -ex $currentPanel`)
	error (" \""+$currentPanel+"\" is not a valid modelPanel");
$cam=`modelPanel -q -camera $currentPanel`;
if (`objectType $cam`=="camera")
	{
	$tempString=`listRelatives -p $cam`;
	$cam=$tempString[0];
	}
$nearClipPlane=`getAttr ($cam+".nearClipPlane")`;
$tempString=`listRelatives -p $pickerGroup`;
if ($tempString[0]!="")
	$pickerGroupParent=$tempString[0];

if (catch (`eval "autoPlace -useMouse"`))
	error "Failed to detect cursor position, camera might be under groundPlane";
$autoPlacePos=`autoPlace -useMouse`;
$camPos=`xform -q -ws -t $cam`;
$orto=`getAttr ($cam+".orthographic")`;
if (`objExists asAutoPlaceCamSpace`)
	{
	$tempString=`listRelatives -c asAutoPlaceCamSpace`;
	for ($i=0;$i<size($tempString);$i++)
		if (!`gmatch $tempString[$i] "asAutoPlaceCamSpace_*Constraint*"`)
			parent -w $tempString[$i];
	delete asAutoPlaceCamSpace;
	}
if (`objExists asAutoPlaceCamSpace2`)
	{
	$tempString=`listRelatives -c asAutoPlaceCamSpace2`;
	for ($i=0;$i<size($tempString);$i++)
			parent -w $tempString[$i];
	delete asAutoPlaceCamSpace2;
	}
createNode -n asAutoPlaceCamSpace transform;
setAttr asAutoPlaceCamSpace.displayLocalAxis 1;
setAttr asAutoPlaceCamSpace.t -type float3 $autoPlacePos[0] $autoPlacePos[1] $autoPlacePos[2];
createNode -n asAutoPlaceCamSpace2 -p asAutoPlaceCamSpace transform;
if ($orto)
	orientConstraint  $cam asAutoPlaceCamSpace;
else
	aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $cam $cam asAutoPlaceCamSpace;
if ($orto)
	{
	parent asAutoPlaceCamSpace $cam;
	$dist=`getAttr asAutoPlaceCamSpace.tz`;
	parent -w asAutoPlaceCamSpace;
	}
else
	$dist=`mag<<$autoPlacePos[0]-$camPos[0],$autoPlacePos[1]-$camPos[1],$autoPlacePos[2]-$camPos[2]>>`;

if ($isFront)
	{
	//find $bb
	if ($pickerGroupParent!="")
		parent -w $pickerGroup;
	xform -os -t 0 0 0 -ro  0 0 0 -s 1 1 1 $pickerGroup;
	$bb=`xform -q -bb $pickerGroup`;

	if ($dagObjectHit!="")
		{
		$tempString[0]="FK"+`substitute "Box" $dagObjectHit ""`;
		if (`gmatch $tempString[0] "*Part[0-9]*"`)
			$tempString[0]=`substitute "Part[0-9]" $tempString[0] ""`;

		if (`objExists $tempString[0]`)
			{
			$ctrlHit=$tempString[0];
			$tempString[0]=$picker+":"+$ctrlHit;
			if (`objExists $tempString[0]`)
				{
				$buttonHit=$tempString[0];
				$bbb=`xform -q -bb $buttonHit`;
				$b=1;
				if (`gmatch $buttonHit "*_L"`)
					$b=-1;
				print ("HIT:\""+$tempString[0]+" : "+`objExists $tempString[0]`+" : "+($bbb[3])+"\n");
				}
			}
		else
			print ("No Ctrl:\""+$tempString[0]+"\"\n");
		}

	if ($orto)
		$s=`getAttr ($cam+".orthographicWidth")`/40.0;
	else
		$s=(`getAttr ($cam+".focalLength")`/700.0)*$nearClipPlane;

	parent -r $pickerGroup asAutoPlaceCamSpace2;
	setAttr ($pickerGroup+".r") -type float3 0 0 0;

	//defaults to centered
	setAttr asAutoPlaceCamSpace2.ty ((($bb[4]-$bb[1])/-2.0)*$s);
	
	if ($buttonHit!="")
		{
		setAttr asAutoPlaceCamSpace2.tx (($bbb[3]-(($bbb[3]-$bbb[0])/2.0))*-$s*$b);
		setAttr asAutoPlaceCamSpace2.ty (($bbb[4]-(($bbb[4]-$bbb[1])/2.0))*-$s);
		}

	setAttr ($pickerGroup+".t") -type float3 0 0 ($dist-($nearClipPlane*2.0));
	parent $pickerGroup $cam;
	setAttr ($pickerGroup+".r") -type float3 0 0 0;

	setAttr ($pickerGroup+".s") -type float3 $s $s $s;

	if ($pickerGroupParent!="")
		{
		if ($pickerGroupParent!=$cam)
			parent $pickerGroup $pickerGroupParent;
		}
	else
		parent -w $pickerGroup;
	}

if (!$isFront)
	{
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			if (!`attributeExists ("pre"+$trs[$y]+$xyz[$z]) $pickerGroup`)
				addAttr -k 0 -ln ("pre"+$trs[$y]+$xyz[$z]) -at double $pickerGroup;
			setAttr ($pickerGroup+"."+$trs[$y]+$xyz[$z]) `getAttr ($pickerGroup+".pre"+$trs[$y]+$xyz[$z]) `;
			}
	}

delete asAutoPlaceCamSpace;

setAttr ($pickerGroup+".isFront") $isFront;
select $sel;
}

global proc asVisualizeGimbalLock (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace;
int $fromSelection;
int $buildGimbal[];
float $scale;
float $bb[];
string $name,$lookForVisConnectionOnObject;
string $tempString[],$controlSets[],$controls[];

if (`asHotKeyCheck "asVisualizeGimbalLock \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`; 
if (!size($controlSets))
	error "No controlSets detected. select a controller";

if (`objExists GimbalLockVisualizers`)
	{
	delete GimbalLockVisualizers;
	return;
	}
createNode -n GimbalLockVisualizers transform;
$controls=`sets -q $controlSets`;
if ($sel[0]!="")
	if (`stringArrayCount $sel[0] $controls`)
		$fromSelection=1;
asFitModeEnsureShaders;
for ($i=0;$i<size($controls);$i++)
	{
	if ($controls[$i]==$nameSpace+"Main")
		continue;
	$tempString=`listRelatives -s $controls[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="nurbsCurve")
			{
			if ($fromSelection)
				if (`stringArrayCount $controls[$i] $sel`)
					$buildGimbal[$i]=1;
			if (!$fromSelection)
				$buildGimbal[$i]=1;
			}
	}
for ($i=0;$i<size($controls);$i++)
	{
	if (!$buildGimbal[$i])
		continue;
	$name=$controls[$i];
	createNode -n ($name+"Constraint") -p GimbalLockVisualizers transform;
	createNode -n ($name+"Offset") -p ($name+"Constraint") transform;

	polyCylinder -n ($name+"Cones") -r 0.3 -h 2.5 -sx 10 -sy 2 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	scale -r -p 0 0 0 0 0 0 ($name+"Cones.vtx[10:19]");
	parent ($name+"Cones") ($name+"Offset");
	if (`objExists asGreenSG`)
		sets -e -forceElement asGreenSG ($name+"Cones");

	polyTorus -n ($name+"Torus") -r 1 -sr 0.03 -tw 0 -sx 30 -sy 6 -ax 0 1 0 -cuv 1 -ch 0;
	parent ($name+"Torus") ($name+"Offset");
	if (`objExists asRedSG`)
		sets -e -forceElement asRedSG ($name+"Torus");

	polyCylinder -n ($name+"Arrow") -r 0.06 -h 2 -sx 10 -sy 3 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	rotate -r 0 0 90 ($name+"Arrow.vtx[0:41]");
	move -r 1 0 0 ($name+"Arrow.vtx[0:41]");
	scale -r -p 0 0 0 1 0 0 ($name+"Arrow.vtx[0:9]") ($name+"Arrow.vtx[40]");
	move -r 0.35 0 0 ($name+"Arrow.vtx[10:19]");
	scale -r -p 0 0 0 1 1.75 1.75 ($name+"Arrow.vtx[10:19]");
	move -r 1 0 0 ($name+"Arrow.vtx[20:29]");
	parent ($name+"Arrow") ($name+"Offset");
	if (`objExists asGreen2SG`)
		sets -e -forceElement asGreen2SG ($name+"Arrow");
	orientConstraint $name ($name+"Arrow");

	$tempString=`listRelatives -p $name`;
	parentConstraint $tempString[0] ($name+"Constraint");
	$tempString=`listRelatives -s $name`;
	$bb=`xform -q -bb ($tempString[0]+".cv[0:999]")`;
	$scale=(($bb[3]-$bb[0])+($bb[4]-$bb[1])+($bb[5]-$bb[2]))/5.0;
	setAttr -type float3 ($name+"Offset.s") $scale $scale $scale;
	$lookForVisConnectionOnObject=$name;
	$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
	for ($y=0;$y<20;$y++)
		{
		if ($tempString[0]!="")
			{
			connectAttr $tempString[0] ($name+"Offset.v");
			break;
			}
		$tempString=`listRelatives -p $lookForVisConnectionOnObject`;
		if ($tempString[0]=="")
			break;
		$lookForVisConnectionOnObject=$tempString[0];
		$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	}
select $sel;
}

global proc asFaceCtrlsDetach (string $uiName)
{
int $wasConnected;
string $nameSpace,$objA,$objB,$plugA,$plugB;
string $controlSets[];

if (`asHotKeyCheck "asFaceCtrlsDetach \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if (!size($controlSets))
	error "No controlSets detected. select a controller";

$objA=$nameSpace+"SkinAttachCtrlsWrap";
$objB=$nameSpace+"AttacherCurveShape";
$plugA=$objA+".outputGeometry[0]";
$plugB=$objB+".create";

if (`objExists outerLidCurveFromMeshEdge_R`)
	{
	$objA=$nameSpace+"SkinAttachMeshBS";
	$objB=$nameSpace+"SkinAttachMeshShapeDeformed";
	$plugA=$objA+".outputGeometry[0]";
	$plugB=$objB+".inMesh";
	}

if (!`objExists $objA`)
	print ("// No wrap-attached controllers found on this character, this function is for character that use the face-rig-type:\"Mixed\".\n");

if (!`objExists $objA` || !`objExists $objB`)
	return;

if (`isConnected $plugA $plugB`)
	{
	$wasConnected=1;
	disconnectAttr $plugA $plugB;
	}
else
	{
	connectAttr $plugA $plugB;
	dgdirty -a;
	}

setAttr ($nameSpace+"ctrlBox.ACtrlVis") (!$wasConnected);
setAttr ($nameSpace+"ctrlBox.BCtrlVis") (!$wasConnected);
setAttr ($nameSpace+"ctrlBox.CCtrlVis") (!$wasConnected);
setAttr ($nameSpace+"ctrlBox.RegionsCtrlVis") (!$wasConnected);
setAttr ($nameSpace+"ctrlBox.TeethCtrlVis") (!$wasConnected);
setAttr ($nameSpace+"ctrlBox.TongueCtrlVis") (!$wasConnected);

if ($wasConnected)
	print ("// Detached On-Face controllers.\n");
else
	print ("// Attached On-Face controllers.\n");
}

global proc int asHaveAnimation (string $node)
{
int $haveAnimation=0;
float $distAB,$distAC;
string $nodeType;
string $tempString[]=`listConnections -s 1 -d 0 $node`;

for ($i=0;$i<size($tempString);$i++)
	{
	$nodeType=`objectType $tempString[$i]`;
	if (`gmatch $nodeType "animCurve*"`)
		{
		$haveAnimation=1;
		break;
		}
	}
return $haveAnimation;
}

global proc asStraightenPoleVectors ()
{
float $pos[];
string $startJoint,$middleJoint,$endJoint;
string $tempString[];
string $sel[]=`ls -sl`;

if (`confirmDialog -t "Confirm"
	-m ("Knee & Elbow will be moved to make poleVector straight.")
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;

//Straighten Knee/Elbow
for ($i=0;$i<2;$i++)
	{
	if ($i==0)
		{
		$startJoint="Hip";
		$middleJoint="Knee";
		$endJoint="Ankle";
		}
	if ($i==1)
		{
		$startJoint="Shoulder";
		$middleJoint="Elbow";
		$endJoint="Wrist";
		}
	if (`objExists $startJoint` && `objExists $middleJoint` && `objExists $endJoint`)
		{
		print ("// Moving "+$middleJoint+" joint, to make a more straight IK poleVector.\n");
		if (`objExists TempLoc1`) delete TempLoc1;
		spaceLocator -n TempLoc1;
		asAlign TempLoc1 $startJoint 1 0 0 0;
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 0 1 $endJoint TempLoc1;
		spaceLocator -n TempLoc2;
		parent TempLoc2 TempLoc1;
		asAlign TempLoc2 $middleJoint 1 0 0 0;
		setAttr TempLoc2.tz 0;
		$pos=`xform -q -ws -t TempLoc2`;
		delete TempLoc1;
		$tempString=`listRelatives -c $middleJoint`;
		parent -w $tempString[0];
		xform -ws -t $pos[0] $pos[1] $pos[2] $middleJoint;
		parent $tempString[0] $middleJoint;
		}
	}
print "// Knee & Elbow joints have been moved, to make poleVector straight.\n";
select $sel;
}

global proc asNameMatcherUI ()
{
asMappingUI nameMatcher "";
}

global proc asMoCapMatcherUI (string $uiName)
{
asMappingUI moCapMatcher $uiName;
}


global proc asMappingUI (string $tool, string $uiName)
{
int $cw=150;
int $sep=10;
string $name,$nameSpace;
string $tempString[];

if (`asHotKeyCheck ("asMappingUI "+$tool+" \"\"")`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
//if (!size($controlSets))
//	error "No controlSets detected. select a controller";

if (`window -q -ex asMappingUI`)
    deleteUI asMappingUI;
window -t $tool asMappingUI;
formLayout asMappingUIFormLayout;
scrollLayout asMappingUIScrollLayout;
columnLayout asMappingUIColumnLayout1;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Templates" asMappingUITemplatesFrameLayout;
	columnLayout;
		rowLayout -nc 4 -cw4 10 25 200 100;
			separator -st none;
			text -l "files:";
			optionMenu -cc ("asMappingUIFileOptionMenuChanged "+$tool) asMappingUIFiles;
//			button -w 80 -l "New" -c asMappingUIClearAll;
			setParent..;
		rowLayout -nc 2 -cw2 40 200;
			separator -st none;
			text -en 0 -l "" -fn smallBoldLabelFont asMappingUIWWW;
			setParent..;
		separator -h 15 -st none;
		rowLayout -nc 3 -cw3 86 150 200;
			separator -st none;
			text -al right -l "save current configutation:";
			button -h 15 -w 80 -l "Export" -c ("asMappingUIExport "+$tool);
			setParent..;		

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Side" asMappingUISideFrameLayout;
	columnLayout;
		textFieldGrp -cw2 45 60 -l "Right:" -ed 1 -tx "Right" -cc asMappingUISideOptionChanged asMappingUISideRightTextFieldGrp;
		textFieldGrp -cw2 45 60 -l "Left:" -ed 1 -tx "Left" asMappingUISideLeftTextFieldGrp;
		textFieldGrp -cw2 45 60 -l "Middle:" -ed 1 -tx "" asMappingUISideMiddleTextFieldGrp;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 10 50;
			separator -st none;
			checkBox -l "%Side% before name" -v 1 -cc asMappingUISideOptionChanged asMappingUISideBeforeNameCheckBox;
			setParent..;
		rowLayout -nc 2 -cw2 10 50;
			separator -st none;
			checkBox -l "Use _ (underscore)" -cc asMappingUISideOptionChanged asMappingUISideUnderScoreCheckBox;
			setParent..;
		separator -h 10 -st none;
		rowLayout -nc 3 -cw3 10 100 100;
			separator -st none;
			text -l "Result example:";
			text -fn boldLabelFont -l "RightArm" asMappingUISideResultExampleText;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Joints" asMappingUIJointsFrameLayout;
	formLayout asMappingUIJointsFormLayout;
		columnLayout -adj 1 asMappingUIJointsColumnLayout1;
			rowLayout -nc 3 -cw3 $cw $sep $cw;
				text -l "   AdvancedSkeleton:";
				text -l "|";
				text -l "   Other:";
				setParent..;
			separator -w ($cw*2);
			columnLayout asMappingUIJointsColumnLayout;
				setParent..;
			setParent..;

		columnLayout asMappingUIJointsColumnLayout2;
			separator -w 320 -h 10;
			separator -w 320 -h 5 -st none;
			rowLayout -nc 3 -cw3 10 80 80;
				separator -st none;
				button -l "Add joint" -c asMappingUIAddJoint;
				button -l "Clear all" -c asMappingUIClearAll;
				setParent..;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "NameSpaces" asMappingUINameSpacesFrameLayout;
	formLayout asMappingUINameSpacesFormLayout;
		columnLayout -adj 1 asMappingUINameSpacesColumnLayout1;
			rowLayout -nc 3 -cw3 $cw $sep $cw;
				text -l "   AdvancedSkeleton:";
				text -l "|";
				text -l "   Other:";
				setParent..;
			separator -w ($cw*2);
			columnLayout asMappingUINameSpacesColumnLayout;
				rowLayout -nc 3 -cw3 $cw $sep $cw;
					textField -w ($cw-$sep-10) asMappingUINameSpacesTextFieldA1;
					if ($nameSpace!="")
						textField -e -tx $nameSpace asMappingUINameSpacesTextFieldA1;
					text -l "|";
					textField -w ($cw-$sep-10) asMappingUINameSpacesTextFieldB1;
				setParent..;
				rowLayout -nc 3 -cw3 $cw $sep $cw;
					separator -st none;
					separator -st none;
					button -h 15 -l "detect from selected" -c asMoCapMatcherNameSpaceDetect;

frameLayout -m 1 -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "TopNode" asMappingUITopNodeFrameLayout;
	formLayout;
		columnLayout -adj 1;
			rowLayout -nc 3 -cw3 $cw $sep $cw;
				text -l "   AdvancedSkeleton:";
				text -l "|";
				text -l "   Other:";
				setParent..;
			separator -w ($cw*2);
			columnLayout;
				rowLayout -nc 3 -cw3 $cw $sep $cw;
					textField -w ($cw-$sep-10) -tx "Group" -ed 0 asMappingUITopNodeTextFieldA1;
					text -l "|";
					textField -w ($cw-$sep-10) asMappingUITopNodeTextFieldB1;
				setParent..;

formLayout -e
	-ac asMappingUIJointsColumnLayout2 "top" 0 asMappingUIJointsColumnLayout1
	asMappingUIJointsFormLayout;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Functions" asMappingUIFunctionsFrameLayout;
	columnLayout;
		if ($tool=="nameMatcher")
			{
//			rowLayout -adj 2 -nc 2 -cw2 80 150;
//				separator -st none;
				columnLayout;
					separator -st none -h 10;
					rowLayout -nc 2;
						separator -st none -w 80;
						button -w 150 -l "Check" -c asNameMatcherCheck;
						setParent..;
					separator -st none -h 5;
					rowLayout -nc 2;
						separator -st none -w 80;
						button -w 150 -l "Create + Place FitSkeleton" -c asNameMatcherCheckAndAutoRigFit;
						setParent..;
					separator -st none -h 5;
					rowLayout -nc 4;
						separator -st none -w 50;
						button -l "Show PoleVectors" -c asToggleFitDisplayPoleVector;
						separator -st none -w 10;
						button -l "Straighten PoleVectors" -c asStraightenPoleVectors;
						setParent..;
					separator -st none -h 5;
					rowLayout -nc 2;
						separator -st none -w 80;
						button -w 150 -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton;
						setParent..;
					separator -st none -h 20;
					rowLayout -nc 2;
						separator -st none -w 80;
						columnLayout;
							button -w 150 -l "Constraint to Joints" -c "asMappingUIFunction AutoRigConstraint";
							text -l "\t\t\tOR:";
							button -w 150 -l "Transfer Skinning" -c "asMappingUIFunction AutoRigTransferSkinning";
							if (size(`ls -type blendShape`))
								{
								separator -st none -h 20;
								button -w 150 -l "Create BlendShapes Control" -c "asMappingUIFunction CreateBSControl";
								}

			}
		if ($tool=="moCapMatcher")
			{
			separator -st none -h 10;
			rowLayout -adj 2 -nc 2 -cw2 80 150;
				separator -st none;
				columnLayout;
					text -l "1: Import MoCap-skeleton.";
					separator -st none -h 10;
					text -l "2: Select MoCap-skeleton";
					button -w 150 -l "Scan MoCap-skeleton" -c asMoCapMatcherScan;
					separator -st none -h 10;
					text -al "left" -l "3: Scale the MoCap-skeleton,\n    to match your character.";
					separator -st none -h 10;
					text -al "left" -l "4: Go to start of animation,\n    and `zero-out` MoCap-joints.";
					button -w 150 -l "`zero-out` MoCap-joints" -c "asMappingUIFunction MoCapZeroOut";
					text -al "left" -l "And align skeletons (if needed)";
					separator -st none -h 10;
					rowLayout -nc 2 -cw2 100 10;
						checkBox -v 1 -l "use IK-Feet" asMappingUIIKFeetCheckBox;
						text -l "Or:";
						setParent..;
					button -w 150 -l "Set rig to all FK" -c ("asSetAllFK \""+$nameSpace+"\"");
					separator -st none -h 10;
					rowLayout -nc 2 -cw2 160 10;
						button -w 150 -l "Connect MoCap Skeleton" -c "asMappingUIFunction MoCapConnect";
						checkBox -l "Extra" asMappingUIExtraCheckBox;
						setParent..;
					button -w 150 -l "Disconnect MoCap Skeleton" -c asMoCapMatcherDisconnect;
					button -w 150 -l "Bake" -c asMoCapMatcherBake;
//					button -w 150 -l "IKBake" -c ("asMoCapMatcherIKBake "+$uiName);
			}

formLayout -e
	-af asMappingUIScrollLayout "top" 0
	-af asMappingUIScrollLayout "bottom" 0
	-af asMappingUIScrollLayout "left" 0
	-af asMappingUIScrollLayout "right" 0
asMappingUIFormLayout;

showWindow;

//populate $tool`s optionMenu
string $asScriptLocation=`asGetScriptLocationFromSelector`;
string $toolDir=$asScriptLocation+"/AdvancedSkeletonFiles/"+$tool+"s/";
string $toolFiles[]=`getFileList -fs "*.txt" -fld $toolDir`;
setParent -menu asMappingUIFiles;
for ($i=0;$i<size($toolFiles);$i++)
	{
	if (`gmatch $toolFiles[$i] "[.]*"` || $toolFiles[$i]=="incrementalSave")
		continue;
	tokenize $toolFiles[$i] "." $tempString;
	$name=$tempString[0];
	menuItem -l $name;
	}
//defaults to "MotionBuilder"
if (`stringArrayCount "MotionBuilder.txt" $toolFiles`)
	optionMenu -e -v MotionBuilder asMappingUIFiles;
menuItem -l "*New";

//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "asMappingUI*FrameLayout"`)
		if (`optionVar -ex $framLayouts[$i]`)
			frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];

//auto-guess source App from scene nodes
if (size(`ls -r 1 |master`)) catchQuiet(`optionMenu -e -v AutodeskCharacterGenerator asMappingUIFiles`);
if (size(`ls -r 1 "*BoneRoot"`)) catchQuiet(`optionMenu -e -v CharacterCreator asMappingUIFiles`);
if (size(`ls -r 1 "*BoneRoot"`) && size(`ls -r 1 "*_Thumb1"`)) catchQuiet(`optionMenu -e -v CharacterCreator3 asMappingUIFiles`);
if (size(`ls -r 1 "*BoneRoot"`) && size(`ls -r 1 "*_Thumb1"`) && size(`ls -r 1 "*_BigToe1"`)) catchQuiet(`optionMenu -e -v CharacterCreator4 asMappingUIFiles`);
if (size(`ls -r 1 ik_foot_root`)) catchQuiet(`optionMenu -e -v Unreal asMappingUIFiles`);
if (size(`ls -r 1 ik_foot_root`) && size(`ls -r 1 spine_05`)) catchQuiet(`optionMenu -e -v Unreal5 asMappingUIFiles`);
if (size(`ls -r 1 Abdomen`)) catchQuiet(`optionMenu -e -v Poser asMappingUIFiles`);
if (size(`ls -r 1 abdomenLower`)) catchQuiet(`optionMenu -e -v Daz3d asMappingUIFiles`);
if (size(`ls -r 1 RightFinger5Proximal`)) catchQuiet(`optionMenu -e -v Rokoko asMappingUIFiles`);
//if (size(`ls -r 1 wrist_inner_l`)) catchQuiet(`optionMenu -e -v MetaHumanFBX asMappingUIFiles`);//MetaHuman from Unreal>FbxExport
//Removed in v6.2616, since this means Unreal5 get wrongly detected as MetaHuman
if (size(`ls -r 1 wrist_innerOff_l_drv`)) catchQuiet(`optionMenu -e -v MetaHuman asMappingUIFiles`);
if (size(`ls -r 1 Armature`)) catchQuiet(`optionMenu -e -v ReadyPlayerMe asMappingUIFiles`);
if (size(`ls -r 1 "mixamorig:*"`))
	{
	catchQuiet(`optionMenu -e -v Mixamo asMappingUIFiles`);
	textField -e -tx "mixamorig" asMappingUINameSpacesTextFieldB1;
	}

//if "NameMatcher" nameSpace exists, it means NameMatcher has already ran, so restore this.
if (`namespace -ex NameMatcher`)
	textField -e -tx NameMatcher asMappingUINameSpacesTextFieldB1;

asMappingUIFileOptionMenuChanged $tool;
}

global proc asMappingUIFileOptionMenuChanged (string $tool)
{
string $text="";
string $file=`optionMenu -q -v asMappingUIFiles`;
if ($file=="AutodeskCharacterGenerator") $text="charactergenerator.autodesk.com";
if ($file=="CharacterCreator") $text="www.reallusion.com/character-creator";
if ($file=="Daz3d") $text="www.daz3d.com";
if ($file=="DeepMotion") $text="www.deepmotion.com";
if ($file=="iPiSoft") $text="www.ipisoft.com";
if ($file=="Mixamo") $text="www.mixamo.com";
if ($file=="MotionBuilder") $text="www.autodesk.com";
if ($file=="Plask") $text="app.plask.ai";
if ($file=="Poser") $text="smithmicro.com/poser";
if ($file=="Unreal") $text="www.unrealengine.com";
if ($file=="Rokoko") $text="www.rokoko.com";
if ($file=="ReadyPlayerMe") $text="readyplayer.me";

text -e -l $text asMappingUIWWW;

asMappingUIClearAll;
if ($file!="*New")
	asMappingUILoad $tool;
}

global proc asMappingUISideOptionChanged ()
{
string $joint="Arm";
string $side=`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`;
string $underS="";
if (`checkBox -q -v asMappingUISideUnderScoreCheckBox`)
	$underS="_";
string $text=$text=$joint+$underS+$side;
if (`checkBox -q -v asMappingUISideBeforeNameCheckBox`)
	$text=$side+$underS+$joint;
text -e -l $text asMappingUISideResultExampleText;
}

global proc asMappingUIAddJoint ()
{
int $cw=150;
int $sep=10;
string $rowLayouts[]=`columnLayout -q -ca asMappingUIJointsColumnLayout`;
int $nr=size($rowLayouts)+1;

setParent asMappingUIJointsColumnLayout;
rowLayout -nc 3 -cw3 $cw $sep $cw ("asMappingUIJointsRowLayout"+$nr);
	textField -w ($cw-$sep-10) ("asMappingUIJointsTextFieldA"+$nr);
	text -l "|";
	textField -w ($cw-$sep-10) ("asMappingUIJointsTextFieldB"+$nr);
}

global proc asMappingUIClearAll ()
{
string $rowLayouts[]=`columnLayout -q -ca asMappingUIJointsColumnLayout`;
for ($i=0;$i<size($rowLayouts);$i++)
	deleteUI $rowLayouts[$i];

textFieldGrp -e -tx "Right" asMappingUISideRightTextFieldGrp;
textFieldGrp -e -tx "Left"  asMappingUISideLeftTextFieldGrp;
textFieldGrp -e -tx "" 			asMappingUISideMiddleTextFieldGrp;
checkBox -e -v 1 asMappingUISideBeforeNameCheckBox;
checkBox -e -v 0 asMappingUISideUnderScoreCheckBox;
}

global proc asMappingUILoad (string $tool)
{
int $section=1;
int $nr=1;
string $line,$para,$value;
string $asScriptLocation=`asGetScriptLocationFromSelector`;
string $file=$asScriptLocation+"/AdvancedSkeletonFiles/"+$tool+"s/"+`optionMenu -q -v asMappingUIFiles`+".txt";
string $tempString[];

if (!`file -q -ex $file`)
	error ("Unable to find the file:\""+$file+"\".\n");

print ("// Loading:\""+$file+"\".\n");
asMappingUIClearAll;
int $fileId=`fopen $file "r"`;
string $nextLine = `fgetline $fileId`;
while (size($nextLine)>0)
	{
	$line=`strip $nextLine`;
	tokenize $line "=" $tempString;
	$para=$tempString[0];
	$value=$tempString[1];

	if ($para=="sideRight")
		textFieldGrp -e -tx $value asMappingUISideRightTextFieldGrp;
	if ($para=="sideLeft")
		textFieldGrp -e -tx $value asMappingUISideLeftTextFieldGrp;
	if ($para=="sideMiddle")
		textFieldGrp -e -tx $value asMappingUISideMiddleTextFieldGrp;
	if ($para=="sideBeforeName")
		eval ("checkBox -e -v "+$value+" asMappingUISideBeforeNameCheckBox");
	if ($para=="sideUnderScore")
		eval ("checkBox -e -v "+$value+" asMappingUISideUnderScoreCheckBox");


	if ($section==2)
		{
		if ($para=="")
			{
			$nextLine=`fgetline $fileId`;
			continue;
			}

		asMappingUIAddJoint;
		textField -e -tx $para ("asMappingUIJointsTextFieldA"+$nr);
		textField -e -tx $value ("asMappingUIJointsTextFieldB"+$nr);
		$nr++;
		}

	if ($para=="" && $value=="")
		$section++;
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;
asMappingUISideOptionChanged;
}

global proc asMappingUIExport (string $tool)
{
string $fDet,$a,$b;
string $asScriptLocation=`asGetScriptLocationFromSelector`;
string $tempString[],$existingMenuItems[],$existingFiles[];

string $return[] = `fileDialog2 -fileFilter "*.txt" -dialogStyle 2 -dir ($asScriptLocation+"/AdvancedSkeletonFiles/"+$tool+"s/")`;
string $file=$return[0];
if ($file=="")
	return;

$fDet+="sideRight="+`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`+"\n";
$fDet+="sideLeft="+`textFieldGrp -q -tx asMappingUISideLeftTextFieldGrp`+"\n";
$fDet+="sideMiddle="+`textFieldGrp -q -tx asMappingUISideMiddleTextFieldGrp`+"\n";
$fDet+="sideBeforeName="+`checkBox -q -v asMappingUISideBeforeNameCheckBox`+"\n";
$fDet+="sideUnderScore="+`checkBox -q -v asMappingUISideUnderScoreCheckBox`+"\n";
$fDet+="\n";
for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$a=`textField -q -tx ("asMappingUIJointsTextFieldA"+$nr)`;
	$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
	$fDet+=$a+"="+$b+"\n";
	}

int $fileId=`fopen $file "w"`;
fprint $fileId $fDet;
fclose $fileId;

tokenize $return[0] "/" $tempString;
tokenize $tempString[size($tempString)-1] "." $tempString;

$existingMenuItems=`optionMenu -q -ill asMappingUIFiles`;
for ($i=0;$i<size($existingMenuItems);$i++)
	$existingFiles[$i]=`menuItem -q -l $existingMenuItems[$i]`;
if (!`stringArrayCount $tempString[0] $existingFiles`)
	{
	setParent -menu asMappingUIFiles;
	menuItem -l $tempString[0];
	optionMenu -e -v $tempString[0] asMappingUIFiles;
	}
}

global proc int asNameMatcherCheck ()
{
int $sideBeforeName=`checkBox -q -v asMappingUISideBeforeNameCheckBox`;
int $sideUnderScore=`checkBox -q -v asMappingUISideUnderScoreCheckBox`;
int $defaultXform,$plugNr,$firstAlert,$isMetaHuman;
float $value,$defaultValue;
float $currentTime=`currentTime -q`;
float $posA[],$posB[],$m[], $m1[],$m2[];
string $sideMiddle=`textFieldGrp -q -tx asMappingUISideMiddleTextFieldGrp`;
string $msg,$otherTopNode,$bResolved,$underS,$b,$obj,$skinCluster,$joint,$dialog,$tg;
string $nonDefaultXformObjs[],$historyNodes[],$testAnimations[],$topLevXforms[],$topLevelMeshObjs[];
string $nameSpaceB=`textField -q -tx asMappingUINameSpacesTextFieldB1`;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$allReservedNames[],$clashingNames[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $reservedNames[]={"Root","Spine1","Spine2","Chest","Scapula","Shoulder","Elbow","Wrist","Cup",
	"ThumbFinger1","ThumbFinger2","ThumbFinger3","ThumbFinger4",
	"IndexFinger1","IndexFinger2","IndexFinger3","IndexFinger4",
	"MiddleFinger1","MiddleFinger2","MiddleFinger3","MiddleFinger4",
	"RingFinger1","RingFinger2","RingFinger3","RingFinger4",
	"PinkyFinger1","PinkyFinger2","PinkyFinger3","PinkyFinger4",
	"Neck","Head","HeadEnd","Eye","EyeEnd","Jaw","JawEnd",
	"Hip","Knee","Ankle","Toes","ToesEnd"};

for ($i=0;$i<size($reservedNames);$i++)
	for ($p=0;$p<3;$p++)
		{
		if ($p==0) $part="";
		if ($p==1) $part="Part1";
		if ($p==2) $part="Part2";
		$allReservedNames[size($allReservedNames)]=$reservedNames[$i]+$part;
		}

//find $otherTopNode
for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
	$bResolved=$b;
	if ($nameSpaceB!="")
		$bResolved=$nameSpaceB+":"+$b;
	$tempString=`ls $bResolved`;
	if (size($tempString)!=1)
		continue;
	$tempString=`ls -l $bResolved`;
	tokenize $tempString[0] "|" $tempString;
	if ($tempString[0]!="FitSkeleton")
		{
		$otherTopNode=`substitute ($nameSpaceB+":") $tempString[0] ""`;
		break;
		}
	}

//find $otherTopNode. part2, migh require sidePrefix (checking for middle only)
if ($otherTopNode=="")
	for ($nr=1;$nr<999;$nr++)
		{
		if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
			break;
		$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
		$underS="";
		if ($sideUnderScore)
			$underS="_";
		if ($sideBeforeName)
			$bResolved=$nameSpaceB+":"+$sideMiddle+$underS+$b;
		else
			$bResolved=$nameSpaceB+":"+$b+$underS+$sideMiddle;
		$tempString=`ls $bResolved`;
		if (size($tempString)!=1)
			continue;
		$tempString=`ls -l $bResolved`;
		tokenize $tempString[0] "|" $tempString;
//		$otherTopNode="|"+$tempString[0];
		$otherTopNode=$tempString[0];
		break;
		}
if (`gmatch $otherTopNode "NameMatcher:*"`)
	$otherTopNode=`substitute "NameMatcher:" $otherTopNode ""`;
textField -e -tx $otherTopNode asMappingUITopNodeTextFieldB1;

if ($otherTopNode=="")
	error ("Unable to find Top-Node of the \"Other\" Skeleton,\n"
		+"Possible reasones:\n"
		+"-No joints in the list in the \"joints\" section.\n"
		+"-None of the joints in the list have unique names, meaning they have same name as other objects in the scene.\n");

//group geo
$topLevXforms=`ls -as -l`;
for ($i=0;$i<size($topLevXforms);$i++)
	{
	$tempString=`listRelatives -ni -s -f $topLevXforms[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`objectType $tempString[0]`!="mesh")
		continue;
	$topLevelMeshObjs[size($topLevelMeshObjs)]=$topLevXforms[$i];
	}
if (size($topLevelMeshObjs) && !`objExists geo` && !`objExists Hi`)
	{
	$dialog=`confirmDialog -t "Confirm"
			-m ("Found: "+size($topLevelMeshObjs)+" TopLevel Geomtry objects,\nThese should be grouped as the model.\n")
			-b "OK" -b "Skip" -b "Cancel" -db "OK"`;
	if ($dialog=="Cancel") return 0;
	if ($dialog=="OK")
		{
		createNode -n geo transform;
		parent $topLevelMeshObjs geo;
		createDisplayLayer -name Hi;
//		setAttr Hi.displayType 1;
		editDisplayLayerMembers -noRecurse Hi geo;
		select -cl;
		}
	}

//Remove any animation that might be on joints (iclone seem to have test-animation by default)
//ensure we keep Start-Pose:
$tempString=`ls -type joint -type blendShape`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -type animCurve -s 1 -d 0 $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		$testAnimations[size($testAnimations)]=$tempString2[$y];
	}
if (size($testAnimations))
	{
	currentTime -1;
	refresh;
	$dialog=`confirmDialog -t "Confirm"
			-m ("Found: "+size($testAnimations)+" AnimationCurves,\nthat are propably test-animation from external skeleton,\nThese should be removed.\n")
			-b "OK" -b "Skip" -b "Cancel" -db "OK"`;
	if ($dialog=="Cancel") return 0;
	if ($dialog=="OK")
		{
		delete $testAnimations;
		currentTime $currentTime;
		}
	}

for ($i=0;$i<size($allReservedNames);$i++)
	{
	if (`objExists $allReservedNames[$i]`)
		{
		$tempString=`ls -l $allReservedNames[$i]`;
		if (`gmatch $tempString[0] "*FitSkeleton*"`)
			continue;
		$clashingNames[size($clashingNames)]=$allReservedNames[$i];
		}
	}
if (size($clashingNames))
	{
	$msg="Clashing Names Detected\n\n"
			+"Names that AdvancedSkeleton needs to use,\n"
			+"are detected in the external skeleton.\n\n"
			+"To proceed, a NameSpace will be added \n"
			+"to the external skeleton, to avoid the name-clashes\n\n"
			+"The clashing names are:\n";
	for ($i=0;$i<size($clashingNames);$i++)
		{
		$msg+=$clashingNames[$i]+"\n";
		if ($i>10)
			{
			$msg+="\n..and "+(size($clashingNames)-10)+" more\n";
			break;
			}
		}
	$dialog=`confirmDialog -t "Confirm"
		-m $msg
		-b "OK" -b "Skip" -b "Cancel" -db "OK"`;
	if ($dialog=="Cancel") return 0;
	if ($dialog=="OK")
		{
		//Adding NameSpace to OtherSkeleton
		if (!`namespace -ex NameMatcher`)
			namespace -addNamespace NameMatcher;
		namespace -setNamespace NameMatcher;
		$tempString=`listRelatives -f -ad -type transform $otherTopNode`;
		$tempString2=`listRelatives -ad -type transform $otherTopNode`;
		$tempString[size($tempString)]=$otherTopNode;
		$tempString2[size($tempString2)]=$otherTopNode;
		for ($i=0;$i<size($tempString);$i++)
			{
			rename $tempString[$i] ("TEMP_"+$tempString2[$i]);
			rename ("NameMatcher:TEMP_"+$tempString2[$i]) $tempString2[$i];
			}
		namespace -setNamespace ":";
		$nameSpaceB="NameMatcher";
		if (`textField -q -ex asMappingUINameSpacesTextFieldB1`)
			textField -e -tx $nameSpaceB asMappingUINameSpacesTextFieldB1;
	//	$otherTopNode="NameMatcher:"+$otherTopNode;
		}
	}

//Y-Up
if (`upAxis -q -ax`=="z")
	if (`confirmDialog -t "Confirm"
					-m "Z-Up Axis Settings detected.\nIt is Highly recommended to use Y-Up\nSwitch to Y-Up ?"
					-b "OK" -b "Skip" -db "OK"`=="OK")
						upAxis -ax y;

if (`getAttr top.rx`>-89)
	if (`confirmDialog -t "Confirm"
					-m "Z-Up Camera Values detected.\n\nSwitch to Y-Up Camera Values ?"
					-b "OK" -b "Skip" -db "OK"`=="OK")
		{
		setAttr top.r   -type float3 -90 0 0;
		setAttr front.r -type float3 0 0 0;
		setAttr side.r  -type float3 0 90 0;
		setAttr persp.r -type float3 -27 45 0;
		xform -piv 0 0 0 persp;
		setNamedPanelLayout "Four View";
		FrameAllInAllViews;
		}

if (`objExists head_drv` && `objExists root_drv`)
	{
	$isMetaHuman=1;
	$posA=`xform -q -ws -t head_drv`;
	if ($posA[2]>$posA[1])
			if (`confirmDialog -t "Confirm"
					-m "Rotate character to Y-up ?"
					-b "OK" -b "Skip" -db "OK"`=="OK")
				{
				setAttr root_drv.rx -90;
				FrameAllInAllViews;
				if (`objExists headRig_grp`)
					setAttr headRig_grp.rx -90;

				createNode -n tempTransform transform;
				setAttr tempTransform.rx -90;
				$m=`getAttr tempTransform.matrix`;
				delete tempTransform;
				$tempString=`ls -type mesh`;
				for ($i=0;$i<size($tempString);$i++)
					{
					if (!`getAttr ($tempString[$i]+".intermediateObject")`)
						continue;
					$tempString2=`listRelatives -p $tempString[$i]`;
					$obj=$tempString2[0];
					xform -piv 0 0 0 $obj;
					$skinCluster=`findRelatedSkinCluster $obj`;
					if ($skinCluster=="")
						continue; 
					$tg=`createNode -n asResetTransform transformGeometry`;
					$tempString2=`listConnections -s 1 -d 0 ($tempString[$i]+".inMesh")`;
					if ($tempString2[0]!="")
						continue;
					$tempString2=`listConnections -s 0 -d 1 -p 1 ($tempString[$i]+".worldMesh")`;
					connectAttr ($tempString[$i]+".worldMesh") ($tg+".inputGeometry");
					if ($tempString2[0]=="")
						continue;
					connectAttr -f ($tg+".outputGeometry") $tempString2[0];
					setAttr ($tg+".transform") -type "matrix"
						$m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
					freezeSkinCluster $skinCluster;
					}
				}
	}

//"Go to BindPose" (by bindPreMatrix)
$firstAlert=1;
if ($nameSpaceB!="")
	$otherTopNode=$nameSpaceB+":"+$otherTopNode;
$tempString=`listRelatives -ad -type joint $otherTopNode`;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	if ($isMetaHuman)
		continue;
	$joint=$tempString[$i];
	if (!`attributeExists bindPose $joint`)
		continue;
	$m1=`getAttr ($joint+".bindPose")`;
	if (`size($m1)`!=16)
		continue;
	$m2=`getAttr ($joint+".matrix")`;
	if ($m1[0]!=$m2[0] || $m1[1]!=$m2[1] || $m1[2]!=$m2[2] || $m1[3]!=$m2[3] || $m1[4]!=$m2[4] || $m1[5]!=$m2[5] || $m1[6]!=$m2[6] || $m1[7]!=$m2[7]
	 || $m1[8]!=$m2[8] || $m1[9]!=$m2[9] || $m1[10]!=$m2[10] || $m1[11]!=$m2[11] || $m1[12]!=$m2[12] || $m1[13]!=$m2[13] || $m1[14]!=$m2[14] || $m1[15]!=$m2[15])
			{
			if ($firstAlert)
				{
				$dialog=`confirmDialog -t "Confirm"
					-m "detected joint that are Not in Bind Pose,\n\nReset joints to Bind-Pose ?"
					-b "OK" -b "Skip" -b "Cancel" -db "OK"`;
				if ($dialog=="Cancel") return 0;
				if ($dialog=="Skip")   {$i=0;break;}
				$firstAlert=0;
				}
			xform -ws -m $m1[0] $m1[1] $m1[2] $m1[3] $m1[4] $m1[5] $m1[6] $m1[7] $m1[8] $m1[9] $m1[10] $m1[11] $m1[12] $m1[13] $m1[14] $m1[15] $joint;
			}
	}
refresh;
/*
getAttr skinCluster1.bindPreMatrix[0];
getAttr skinCluster1.matrix[0];
float $m1[]=`getAttr skinCluster1.bindPreMatrix[0]`
xform -m $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
*/

//Detect any Skinned Object with Non-Default Transform, for Freezing. e.g. imported from CC4
$tempString=`ls -ni -l -type mesh`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	$obj=$tempString2[0];
	$skinCluster=`findRelatedSkinCluster $tempString[$i]`;//must use findRelatedSkinCluster and not asGetSkinCluster
	if ($skinCluster=="")
		continue;
	$defaultXform=1;
	for ($y=0;$y<size($trs);$y++)
		{
		if ($y==2) $defaultValue=1;
		else $defaultValue=0;
		for ($z=0;$z<size($xyz);$z++)
			{
			$value=`getAttr ($obj+"."+$trs[$y]+$xyz[$z])`;
			if ($value!=$defaultValue)
				$defaultXform=0;
			}
		}
	if (!$defaultXform)
		$nonDefaultXformObjs[size($nonDefaultXformObjs)]=$obj;
	}
if (size($nonDefaultXformObjs))
	$dialog=`confirmDialog -t "Reset Transforms ?"
		-m (size($nonDefaultXformObjs)+" Skinned Objects with Non Default Transform Values detected.\nReset Transforms ?")
		-b "OK" -b "Skip" -b "Cancel" -db "OK"`;
	if ($dialog=="Cancel") return 0;
	if ($dialog=="OK")
		for ($i=0;$i<size($nonDefaultXformObjs);$i++)
			{
			$tempString=`listConnections -s 1 -d 0 -type animCurve $nonDefaultXformObjs[$i]`;
			if (size($tempString))
				delete $tempString;
			asLockAttr $nonDefaultXformObjs[$i] 0 0 0 0;
			makeIdentity -a 1 -t 1 -r 1 -s 1 $nonDefaultXformObjs[$i];
			for ($y=0;$y<size($trs);$y++)
				for ($z=0;$z<size($xyz);$z++)
					setAttr -l 1 ($nonDefaultXformObjs[$i]+"."+$trs[$y]+$xyz[$z]);
			$historyNodes=`listHistory -future 0 -leaf 1 -il 1 -pdo 1 $nonDefaultXformObjs[$i]`;
			for ($y=0;$y<size($historyNodes);$y++)
				if (`objectType $historyNodes[$y]`=="transformGeometry")
					rename $historyNodes[$y] asResetTransform;
			}

print ("// NameMatcher Check completed.\n");
return 1;
}

global proc int asNameMatcherCheckAndAutoRigFit ()
{
int $isMiddleJoint,$numChilJoInts,$maxNumChildJoints,$numMissing;
int $sideBeforeName=`checkBox -q -v asMappingUISideBeforeNameCheckBox`;
int $sideUnderScore=`checkBox -q -v asMappingUISideUnderScoreCheckBox`;
float $scale,$maxY,$maxZ;
float $pos[];
textField -e -ebg 1 asMappingUIJointsTextFieldA1;
float $bgc[]=`textField -q -bgc asMappingUIJointsTextFieldA1`;
textField -e -ebg 0 asMappingUIJointsTextFieldA1;
frameLayout -e -ebg 1 asMappingUITemplatesFrameLayout;
float $bgc2[]=`frameLayout -q -bgc asMappingUITemplatesFrameLayout`;
frameLayout -e -ebg 0 asMappingUITemplatesFrameLayout;
string $a,$b,$aLong,$bResolved,$otherTopNode,$underS,$bs,$suffix,$part,$longHipToKeep,$baseName,$finger,$nameSpaceB,$tPoseTarget,$upAxisDirection;
string $sideRight=`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`;
string $sideLeft=`textFieldGrp -q -tx asMappingUISideLeftTextFieldGrp`;
string $sideMiddle=`textFieldGrp -q -tx asMappingUISideMiddleTextFieldGrp`;
string $file=`optionMenu -q -v asMappingUIFiles`;
string $templateMaFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/nameMatchers/"+$file+".ma";
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[],$fitJoints[],$placedJoints[];
string $fingers[]={"Thumb","Index","Middle","Ring","Pinky"};


if (!`asNameMatcherCheck`)
	return 0;

$upAxisDirection=`upAxis -q -ax`;//run here as this could have changed within above `asNameMatcherCheck` proc
$nameSpaceB=`textField -q -tx asMappingUINameSpacesTextFieldB1`;
$otherTopNode=`textField -q -tx asMappingUITopNodeTextFieldB1`;
if ($nameSpaceB!="")
	$otherTopNode=$nameSpaceB+":"+$otherTopNode;

//remove existing FitSkeleton
if (`objExists |FitSkeleton`)
	delete |FitSkeleton;

//resolve Daz non-unique names
$longHipToKeep="hip";
$tempString=`ls hip`;
if (size($tempString)>1)
	{
	warning "Found multiple objects called \"hip\", this is probably a export from DAZ, now attemting to merge all the DAZ skeletons..";
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listRelatives -ad -c $tempString[$i]`;
		$numChilJoints=size($tempString2);
		if ($numChilJoints>$maxNumChildJoints)
			{
			$longHipToKeep=$tempString[$i];
			$maxNumChildJoints=$numChilJoints;
			}
		}
	}
//rename to unique names
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]==$longHipToKeep)
		continue;
	$tempString2=`listRelatives -p $tempString[$i]`;
	$baseName=$tempString2[0];
	$tempString2=`listRelatives -ad -c -f $baseName`;
	$tempString3=`listRelatives -ad -c $baseName`;
	$tempString4=`listRelatives -ad -c -f $longHipToKeep`;
	$tempString5=`listRelatives -ad -c $longHipToKeep`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		rename $tempString2[$y] ($baseName+"_"+$tempString3[$y]);
		for ($z=0;$z<size($tempString5);$z++)//constraint to `keepJoint`
			if ($tempString5[$z]==$tempString3[$y])
				{
				parentConstraint $tempString4[$z] ($baseName+"_"+$tempString3[$y]);
				scaleConstraint $tempString4[$z] ($baseName+"_"+$tempString3[$y]);
				}
		}
	}

//turning Off "segmentScaleCompensate" for all joints, for better scale behaviour
$tempString=`ls -type joint`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".segmentScaleCompensate") 0;



if (!`optionMenu -q -ex asFitFiles`)
	AdvancedSkeleton;

//if a .ma file matching the templateName exists, we assume this to be used as FitSkeleton
createNode -n FitSkeletonNameMatcherImporting transform;
if (`file -q -ex $templateMaFile`)
	{
	print ("// Detected custom FitSkeleton for NameMatcher template, using this instead of default biped. (\""+$templateMaFile+"\")\n");
	createNode -n FitSkeletonOverride transform;
	addAttr -ln fitSkeletonFile -dt "string" FitSkeletonOverride;
	setAttr -type "string" FitSkeletonOverride.fitSkeletonFile $templateMaFile;
	asFitSkeletonImport;
	delete FitSkeletonOverride;
	if (`attributeExists fitSkeletonTemplate FitSkeleton`)
		setAttr -type "string" FitSkeleton.fitSkeletonTemplate `basenameEx $templateMaFile`;
	}
else
	{
	optionMenu -e -v "biped.ma" asFitFiles;
	asFitSkeletonImport;
	}
delete FitSkeletonNameMatcherImporting;

//Overall scale
$tempString=`listRelatives -f -ad -type transform $otherTopNode`;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	if ($pos[1]>$maxY)
		$maxY=$pos[1];
	if ($pos[2]>$maxZ)
		$maxZ=$pos[2];
	}
if ($upAxisDirection=="z")
	$scale=$maxZ/17.0;
else
	$scale=$maxY/17.0;
setAttr FitSkeleton.s -type float3 $scale $scale $scale;

for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$a=`textField -q -tx ("asMappingUIJointsTextFieldA"+$nr)`;
	$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;

	if (!`objExists $a`)
		{
		if (!`gmatch $a "*Part[0-9]*"`)//Missing *Part* joints is OK for `Fitting`, still gets used in `Constraint`
			warning ("AdvancedSkeleton FitJoint \""+$a+"\" not found");
		continue;
		}

	//find $aLong
	$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
	$tempString=`listRelatives -fullPath -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($fitJoints);$i++)
		if ($fitJoints[$i]==$a)
			$aLong=$tempString[$i];

	$isMiddleJoint=1;
	$pos=`xform -q -ws -t $aLong`;
	if ($pos[0]>0.001 || $pos[0]<-0.001)
		$isMiddleJoint=0;

	//find $bResolved
	$underS="";
	if ($sideUnderScore)
		$underS="_";
	if ($isMiddleJoint && $sideMiddle=="")//special case, no middleSuffix, so no underscore
		$underS="";

	if ($sideBeforeName)
		{
		if ($isMiddleJoint) $bResolved=$sideMiddle+$underS+$b;
		else 								$bResolved=$sideRight+$underS+$b;
		}
	else
		{
		if ($isMiddleJoint) $bResolved=$b+$underS+$sideMiddle;
		else 								$bResolved=$b+$underS+$sideRight;
		}

	if ($nameSpaceB!="")
		$bResolved=$nameSpaceB+":"+$bResolved;

	if (!`objExists $bResolved`)
		{
		warning ("Other Joint \""+$bResolved+"\" not found");
		textField -e -bgc 1.0 0.5 0.5 ("asMappingUIJointsTextFieldB"+$nr);
		$numMissing++;
		continue;
		}
	else
		textField -e -bgc $bgc[0] $bgc[1] $bgc[2] ("asMappingUIJointsTextFieldB"+$nr);

	$pos=`xform -q -ws -t $bResolved`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $aLong;
	$placedJoints[size($placedJoints)]=$a;
	}

if ($numMissing)
	frameLayout -e -cl 1 -bgc 1.0 0.5 0.5 asMappingUIJointsFrameLayout;
else
	frameLayout -e -bgc $bgc2[0] $bgc2[1] $bgc2[2] asMappingUIJointsFrameLayout;

asFitModeManualUpdate;

//Finger endjoints likly not present in imported skeleton, so resetting .jo for previous joint
for ($y=0;$y<size($fingers);$y++)
	for ($i=1;$i<5;$i++)
		{
		$fingerJoint=$fingers[$y]+"Finger"+$i;
		if (!`stringArrayCount $fingerJoint $placedJoints`)
			{
			$tempString=`listRelatives -p $fingerJoint`;
			setAttr ($tempString[0]+".jointOrient") -type float3 0 0 0;
			}
		}

select FitSkeleton;
return 1;
}

global proc asMappingUIFunction (string $function)
{
int $sideBeforeName=`checkBox -q -v asMappingUISideBeforeNameCheckBox`;
int $sideUnderScore=`checkBox -q -v asMappingUISideUnderScoreCheckBox`;
int $numChar,$numChar2,$numConnectedJoints,$hitXferredJoint,$useTPoseFile,$useExtra,$useIkFeet;
int $autoKeyState=`autoKeyframe -q -state`;
float $pos[],$posA[],$posB[],$rot[];
float $height=10;
float $dist,$minDist,$currentTime,$min,$max,$animationStartTime,$animationEndTime;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $fk="FK";
if (`checkBox -q -ex asMappingUIExtraCheckBox`)
	if (`checkBox -q -v asMappingUIExtraCheckBox`)
		{
		$fk="FKExtra";
		$useExtra=1;
		}
if (`checkBox -q -ex asMappingUIIKFeetCheckBox`)
	if (`checkBox -q -v asMappingUIIKFeetCheckBox`)
		$useIkFeet=1;
string $target,$source,$dest,$previousParent,$child,$m,$side,$blendShape,$attr;
string $underS="";
string $file=`optionMenu -q -v asMappingUIFiles`;
string $asScriptLocation=`asGetScriptLocationFromSelector`;
string $customMelFile=$asScriptLocation+"/AdvancedSkeletonFiles/moCapMatchers/"+$file+".mel";
string $sideRight=`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`;
string $sideLeft=`textFieldGrp -q -tx asMappingUISideLeftTextFieldGrp`;
string $sideMiddle=`textFieldGrp -q -tx asMappingUISideMiddleTextFieldGrp`;
string $nameSpaceA=`textField -q -tx asMappingUINameSpacesTextFieldA1`;
string $nameSpaceB=`textField -q -tx asMappingUINameSpacesTextFieldB1`;
string $tempString[],$tempString2[],$tempString3[],$as[],$bs[],$scs[],$aResolveds[],$bResolveds[],$commonAttrs[],$allAttrs[],$historyNodes[];
string $topNodesBefore[],$topNodesAfter[];
string $deformJoints[]=`listRelatives -type joint -ad ($nameSpaceA+"DeformationSystem")`;
string $refFiles[]=`file -q -r`;

if ($function=="MoCapConnect" && `objExists MoCapConstraints`)
	error "MoCapConstraints object already exists, which means MoCap skeleton is already connected";

if ($autoKeyState) autoKeyframe -state 0;

for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$as[$nr-1]=`textField -q -tx ("asMappingUIJointsTextFieldA"+$nr)`;
	$bs[$nr-1]=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
	}

for ($i=0;$i<size($deformJoints);$i++)
	{
	$target="";
	if ($sideUnderScore) $underS="_";
	$numChar=size($deformJoints[$i]);
	for ($y=0;$y<size($as);$y++)
		if (`substring $deformJoints[$i] 1 ($numChar-2)`==$nameSpaceA+$as[$y])
			{
			if (`gmatch $deformJoints[$i] "*_R"`)
				{
				$side="_R";
				if ($sideBeforeName)
					$target=$sideRight+$underS+$bs[$y];
				else
					$target=$bs[$y]+$underS+$sideRight;
				}
			if (`gmatch $deformJoints[$i] "*_L"`)
				{
				$side="_L";
				if ($sideBeforeName)
					$target=$sideLeft+$underS+$bs[$y];
				else
					$target=$bs[$y]+$underS+$sideLeft;
				}
			if (`gmatch $deformJoints[$i] "*_M"`)
				{
				$side="_M";
				if ($sideMiddle=="")//special case, no middleSuffix, so no underscore
					$underS="";
				if ($sideBeforeName)
					$target=$sideMiddle+$underS+$bs[$y];
				else
					$target=$bs[$y]+$underS+$sideMiddle;
				}
			if ($nameSpaceB!="")
				$target=$nameSpaceB+":"+$target;
			}
	if ($target=="")
		continue;

	$aResolveds[size($aResolveds)]=$deformJoints[$i];
	$bResolveds[size($bResolveds)]=$target;

	//AutoRigConstraint
	if ($function=="AutoRigConstraint")
		{
		print ($deformJoints[$i]+" -> "+$target+"\n");
		if (!`objExists $target`)
			{
			warning ("Expected targetJoint:\""+$target+"\" not found, skipping this.");
			continue;
			}

		//some packages makes locked or limited atrributes, so open up these first
		transformLimits -erx 0 0 -ery 0 0 -erz 0 0 -etx 0 0 -ety 0 0 -etz 0 0 -esx 0 0 -esy 0 0 -esz 0 0 $target;
		asLockAttr $target 0 0 0 0;

		select $target;
		if (`objExists ($target+"_parentConstraint1")`) delete ($target+"_parentConstraint1");
		if (`objExists ($target+"_scaleConstraint1")`) delete ($target+"_scaleConstraint1");
		parentConstraint -mo $deformJoints[$i] $target;
		scaleConstraint -mo $deformJoints[$i] $target;//sometime mixamo character have non-1 scaled joints
		}

	//AutoRigTransferSkinning
	if ($function=="AutoRigTransferSkinning")
		{
		$tempString=`listConnections -p 1 -s 0 -d 1 -type skinCluster $target`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (!`gmatch $tempString[$y] "*[.]matrix*"`)
				continue;
			connectAttr -f ($deformJoints[$i]+".worldMatrix[0]") $tempString[$y];
			}
		}

	//MoCapConnect
	if ($function=="MoCapConnect")
		{
		if ($nameSpaceA!="")
			$dest=`substitute $nameSpaceA $deformJoints[$i] ($nameSpaceA+$fk)`;
		else
			$dest=$fk+$deformJoints[$i];
		if (`gmatch $dest "*Root_M"`)
			{//Use RootX instead of Root, as Root may have `inbetween` joint
			$dest=`substitute "FKRoot_M" $dest "RootX_M"`;
			if ($fk=="FKExtra")
				$dest=`substitute "FKExtraRoot_M" $dest "RootExtraX_M"`;
			}
		if (!`objExists $dest`)
			continue;
		if (!`objExists $target`)
			{
			if (!`objExists MoCapConstraints`)
				error ("Unable to find \""+$target+"\", Maybe the NameSpace is not defined ?\n");
			else
				{
				print ("\""+$target+"\" not found, Skipping.\n");
				continue;
				}
			}

		print ($target+" -> "+$dest+"\n");

		//if MoCap-joint-name clashes with FitSkeleton-joint-name (e.g Head, Neck)
		//we will update $target to have `fullPath`
		$tempString=`ls -l $target`;
		if (size($tempString)>1)
			{
			for ($y=0;$y<size($tempString);$y++)
				{
				if (`gmatch $tempString[$y] "*|Group|*"`)
					continue;
				$target=$tempString[$y];
				}
			print ("non-unique name update:"+$target+" -> "+$dest+"\n");
			}

		if (!`objExists MoCapConstraints`)
			{
			createNode -n MoCapConstraints transform;
			asLockAttr MoCapConstraints 1 1 1 1;
			}
		if (!`attributeExists disableConstraints MoCapConstraints`)
			addAttr -k 1 -ln "disableConstraints"  -at bool MoCapConstraints;
		if ($deformJoints[$i]==$nameSpaceA+"Root_M")
			{
			$tempString=`pointConstraint -mo $target $dest`;
//			parent $tempString[0] MoCapConstraints;
			connectAttr MoCapConstraints.disableConstraints ($tempString[0]+".nodeState");
			}
		$tempString=`orientConstraint -mo $target $dest`;
//		parent $tempString[0] MoCapConstraints;
		connectAttr MoCapConstraints.disableConstraints ($tempString[0]+".nodeState");
		$numConnectedJoints++;

		//IK-Feet
		if ($useIkFeet && `gmatch $deformJoints[$i] ($nameSpaceA+"Ankle_*")`)
			{
			print ("// connecting IK-Feet:"+$deformJoints[$i]+"\n");
			$dest=$nameSpaceA+"IKLeg"+$side;
			if ($useExtra)
				$dest=$nameSpaceA+"IKExtraLeg"+$side;
			$tempString=`parentConstraint -mo $target $dest`;
			connectAttr MoCapConstraints.disableConstraints ($tempString[0]+".nodeState");
			}
		}

	//MoCapZeroOut
	if ($function=="MoCapZeroOut")
		{
		if (!`objExists $target`)
			continue;
		catchQuiet (`setAttr ($target+".r") -type float3 0 0 0`);
		$numConnectedJoints++;
		}
	}

//possible Custom code for MoCapZeroOut
if ($function=="MoCapZeroOut" && `file -q -ex $customMelFile`)
	{
	eval ("source \""+$customMelFile+"\"");
	evalEcho ("MoCapZeroOut");
	print ("// sourced "+$customMelFile+"\n");		
	}

//AutoRigTransferSkinning
if ($function=="AutoRigTransferSkinning")
	{
	//any joints not `mapped` to be `parented over`
	for ($i=0;$i<size($bResolveds);$i++)
		{
		$tempString=`listRelatives -c -type joint $bResolveds[$i]`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`stringArrayCount $tempString[$y] $bResolveds`)
				continue;
			$tempString2=`listRelatives -p $tempString[$y]`;
			$previousParent=$tempString2[0];
			//delete `dud` joints, e.g ReadyPlayerMe 'RightHandIndex4_end'
			$tempString3=`listConnections ($tempString[$y]+".worldMatrix")`;
			if ($tempString3[0]=="")
				{
				print ("deleting un-used joint: "+$tempString[$y]+"\n");
				delete $tempString[$y];
				continue;
				}
			parent $tempString[$y] $aResolveds[$i];
			if ($m=="")
				$m="The following Joints does not have a Matching-Joint,\nso these will be parented to the DeformationSystem:\n\n";
			$m+=$tempString[$y]+"\n";
			$child=$tempString[$y];
			while ($child!="")
				{
				$tempString2=`listRelatives -c $child`;
				$child=$tempString2[0];
				if (`stringArrayCount $child $bResolveds`)
					{
					parent $child $previousParent;
					break;
					}
				}
			}
		}
	if ($m!="")
		confirmDialog -t Note -m $m -b "Ok" -db "Ok";

	//FaceSetup On External Skeleton, can happen with asNameMatcherAutoFaceFitting
	if (`objExists FaceJoint_M` && `objExists Head_M`)
		{
		$tempString=`listRelatives -p FaceJoint_M`;
		if ($tempString[0]!="Head_M")
			{
			parent FaceJoint_M Head_M;
			$tempString2={"FaceMotionSystem","FaceDeformationFollowHead","LipFollowHead"};
			for ($i=0;$i<size($tempString2);$i++)
				{
				if (!`objExists $tempString2[$i]`)
					continue;
				parentConstraint -mo Head_M $tempString2[$i];
				scaleConstraint Head_M $tempString2[$i];
				}
			}
		}

	//delete original skeleton
	$target=$bResolveds[size($bResolveds)-1];
	if (`objExists $target`)
		{
		for ($i=0;$i<5;$i++)
			{
			$tempString=`listRelatives -p $target`;
			if ($tempString[0]=="")
				break;
			$target=$tempString[0];
			}
		delete $target;
		}

	dgdirty -a;
	$scs=`ls -type skinCluster`;
	for ($i=0;$i<size($scs);$i++)
		{
		freezeSkinCluster $scs[$i];
		$historyNodes=`listHistory -f 1 -interestLevel 1 $scs[$i]`;
		for ($z=0;$z<size($historyNodes);$z++)
			if (`objectType $historyNodes[$z]`=="mesh")
				skinPercent -normalize 1 $scs[$i] $historyNodes[$z];
		}
	}

//blendShapes
if ($function=="CreateBSControl" && !`objExists FRM_faceGUI`)//skip for MH, as it has faceGUI
	{
	$tempString=`ls -type blendShape`;
	//first find $commonAttrs (matching bsTargetNames at multuiple bsNodes
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listAttr -m ($tempString[$i]+".weight")`;
		for ($y=0;$y<size($tempString2);$y++)
			{
			if (`stringArrayCount $tempString2[$y] $allAttrs`)
				$commonAttrs[size($commonAttrs)]=$tempString2[$y];
			else
				$allAttrs[size($allAttrs)]=$tempString2[$y];
			}
		}
	$commonAttrs=`stringArrayRemoveDuplicates $commonAttrs`;

	for ($i=-1;$i<size($tempString);$i++)
		{
		if ($i==-1)//common
			{
			$blendShape="CommonBlendShapes";
			if (!size($commonAttrs))
				continue;
			}
		else
			{
			$blendShape=$tempString[$i];
			}
		circle -n ($blendShape+"Ctrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
		parentConstraint Head_M ($blendShape+"Ctrl");
		setAttr ($blendShape+"Ctrl_parentConstraint1.target[0].targetOffsetTranslateX") (($height/40.0)*$i);
		setAttr ($blendShape+"Ctrl_parentConstraint1.target[0].targetOffsetTranslateZ") ($height/-10.0);
		setAttr ($blendShape+"CtrlShape.overrideEnabled") 1;
		setAttr ($blendShape+"CtrlShape.overrideColor") 17;
		asLockAttr ($blendShape+"Ctrl") 1 1 1 1;
		if ($i==-1)
			continue;
		$tempString2=`listAttr -m ($blendShape+".weight")`;
//		if (size($tempString2)==0)
//			delete ($blendShape+"Ctrl");
		for ($y=0;$y<size($tempString2);$y++)
			{
			$attr=$tempString2[$y];
			if ($attr=="V_None")
				continue;
			if (`stringArrayCount $attr $commonAttrs`)
				{
				if (!`attributeExists $attr CommonBlendShapesCtrl`)
					addAttr -k 1 -ln $attr -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 0 CommonBlendShapesCtrl;
				connectAttr -f ("CommonBlendShapesCtrl."+$attr) ($blendShape+"."+$attr);
				}
			else
				{
				addAttr -k 1 -ln $attr -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 0 ($blendShape+"Ctrl");
				connectAttr -f ($blendShape+"Ctrl."+$attr) ($blendShape+"."+$attr);
				}
			}
		//remove any that has no (nonCommon) attrs
		$tempString2=`listAttr -k ($blendShape+"Ctrl")`;
		if (!size($tempString2))
			delete ($blendShape+"Ctrl");
		}
	if (`objExists CommonBlendShapesCtrl`)
		{
		$tempString2=`listAttr -k CommonBlendShapesCtrl`;
		if (!size($tempString2))
			delete CommonBlendShapesCtrl;
		}
	refresh;
	}

if ($autoKeyState) autoKeyframe -state 1;
select -cl;

if ($function=="AutoRigConstraint")
	print "// Skeleton has been constrained to AdvancedSkeleton`s Deformation-Joints,\n";
if ($function=="AutoRigTransferSkinning")
	print "// Skinning has been transferred to AdvancedSkeleton`s Deformation-Joints,\n";
if ($function=="MoCapConnect")
	print ("// "+$numConnectedJoints+" joints connected.\n");
if ($function=="MoCapZeroOut")
	print ("// "+$numConnectedJoints+" joints `zeroed out`.\n");
}

global proc asMoCapMatcherNameSpaceDetect ()
{
string $sel[]=`ls -sl`;
string $tempString[];
string $nameSpace;
for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] ":" $tempString;
	if (size($tempString)>1)
		$nameSpace=$tempString[0];
	}
print ("// nameSpace \""+$nameSpace+"\" detected, and updated in the  \"NameSpaces\" section.\n");
textField -e -tx $nameSpace asMappingUINameSpacesTextFieldB1;
}

global proc asMoCapMatcherScan ()
{
asMoCapMatcherNameSpaceDetect;
}

global proc asMoCapMatcherDisconnect ()
{
string $tempString[];

if (`objExists MoCapConstraints`)
	{
	if (`attributeExists disableConstraints MoCapConstraints`)
		$tempString=`listConnections -s 0 -d 1 MoCapConstraints.disableConstraints`;
	for ($i=0;$i<size($tempString);$i++)
		delete $tempString[$i];
	delete MoCapConstraints;
	}
print ("// MoCap Skeleton disconnected.\n");
}

global proc asMoCapMatcherBake ()
{
string $tempString[],$bakeControls[];

if (!`objExists MoCapConstraints`) error "MoCapConstraints object not found";
if (!`attributeExists disableConstraints MoCapConstraints`) error "MoCapConstraints.disableConstraints attribute not found";

string $moCapConstraints[]=`listConnections -s 0 -d 1 MoCapConstraints.disableConstraints`;
for ($i=0;$i<size($moCapConstraints);$i++)
	{
	$tempString=`listConnections ($moCapConstraints[$i]+".constraintParentInverseMatrix")`;
	$bakeControls[size($bakeControls)]=$tempString[0];
	}
select $bakeControls;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
}
/*
global proc asMoCapMatcherIKBake (string $uiName)
{
float $start=`playbackOptions -q -min`;
float $end=`playbackOptions -q -max`;
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $limb;
string $tempString[],$tempString2[];

//bake before IKBake
if (`objExists ($nameSpace+"RootX_M")` && `objExists ($nameSpace+"RootExtraX_M")`)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"RootX_M") ($nameSpace+"RootExtraX_M")`;
	if (!size($tempString))
		error "Run Bake before running IKBake";
	}

optionVar -iv asBakingMoCap 1;
evalDeferred ("optionVar -iv asBakingMoCap 0");
$tempString=`listRelatives -c ($nameSpace+"FKIKSystem")`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -c $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		if (!`attributeExists FKIKBlend $tempString2[$y]`)
			continue;
		if ($limb!="") $limb+="|";
		$limb+=`substitute ($nameSpace+"FKIK") $tempString2[$y] ""`;
		}
	}
asAnimBakeFKIK $limb 1 $uiName;
}
*/

global proc asMoCapLibraryUI (string $uiName)
{
asEnsureAsGetScriptLocation;
string $frameLayouts[]={"asMCLBody","asMCLMoCapMaya","asMCLCNU","asMCLMoCapCustom","asMCLEdit","asMCLFace"};

if (`asHotKeyCheck "asMoCapLibraryUI \"\""`) return;

if (`upAxis -q -ax`!="y")
	error "Maya settting are not using Y-up axis, MoCapLibrary requires Y-up";

for ($i=0;$i<size($frameLayouts);$i++)
	if (!`optionVar -ex ($frameLayouts[$i]+"FrameLayout")`)
		optionVar -iv ($frameLayouts[$i]+"FrameLayout") 1;

if (`window -q -ex asMoCapLibraryUI`)
    deleteUI asMoCapLibraryUI;
window -t "MoCapLibrary" asMoCapLibraryUI;

columnLayout -adj 1;
	text -l "Motion Capture Library:";
	separator -h 10;
	frameLayout -mw 10 -cll 1 -cl `optionVar -q asMCLBodyFrameLayout` -cc asFL -ec asFL -l "Body" asMCLBodyFrameLayout;
		frameLayout -cll 1 -cl `optionVar -q asMCLMoCapMayaFrameLayout` -cc asFL -ec asFL -l " Motion Capture (Maya)" asMCLMoCapMayaFrameLayout;
			text -l "Maya Example Motion Capture files:";
			text -al "center" -fn "smallBoldLabelFont" -l "* only for Maya versions that include MoCap files";
			rowLayout -nc 2;
				optionMenu asMCLMoCapMayaOptionMenu;
				button -l "apply" -c ("asMCLMayaApply \""+$uiName+"\"");
				setParent..;
			setParent..;
		frameLayout -mw 10 -cll 1 -cl `optionVar -q asMCLMoCapCustomFrameLayout` -cc asFL -ec asFL -l " Motion Capture (Custom)" asMCLMoCapCustomFrameLayout;
			columnLayout -adj 1;
			separator -st none -h 5;
				rowLayout -nc 3;
					text -w 100 -l "MoCap library path:";
					button -l "browse" -c "asMCLMoCapCustomBrowse asMCLMoCapCustomPathTextField";
					textField -ed 0 -w 300 asMCLMoCapCustomPathTextField;
					if (`optionVar -q asMCLMoCapCustomPathTextField`!=0)
						textField -e -tx `optionVar -q asMCLMoCapCustomPathTextField` asMCLMoCapCustomPathTextField;
					setParent..;
				setParent..;
			rowLayout -nc 2;
				optionMenu asMCLMoCapCustomOptionMenu;
				button -l "apply" -c ("asMCLCustomApply \""+$uiName+"\"");
				setParent..;
			setParent..;
		frameLayout -cll 1 -cl `optionVar -q asMCLCNUFrameLayout` -cc asFL -ec asFL -l " Motion Capture (CMU Database)" asMCLCNUFrameLayout;
			text -l "Carnegie Mellon University MoCap Database files";
			text -al "center" -fn "smallBoldLabelFont" -l "http://mocap.cs.cmu.edu";
			optionMenu -cc asPopulateMCLCNU2OptionMenu asMCLCNU1OptionMenu;
			optionMenu -cc asUpdateMoCapCNUApplyButton asMCLCNU2OptionMenu;
			separator -h 5;
			rowLayout -nc 2;
				separator -w 200 -st none;
				button -w 100 -l "apply" -c ("asMCLCNUApply \""+$uiName+"\"") asMCLCNUApplyButton;
				setParent..;
			setParent..;
		frameLayout -cll 1 -cl `optionVar -q asMCLEditFrameLayout` -cc asFL -ec asFL -l " Edit" asMCLEditFrameLayout;
			rowLayout -nc 3 -cw3 50 120 150;
				text -l "Edit:";
				button -w 110 -l "Go to Frame -1" -c "currentTime -1";
				button -w 110 -l "Show MoCap joints" -c "setAttr MotionCaptureLibraryScale.v 1;select MotionCaptureLibraryScale;";
				setParent..;
			rowLayout -nc 3 -cw3 50 120 150;
				separator;
				button -w 110 -l "Disconnect" -c ("asMCLDisconnectBody \""+$uiName+"\"");
				button -w 110 -l "Reconnect" -c ("asMCLConnectBody \""+$uiName+"\"");
				setParent..;
			rowLayout -nc 3 -cw3 50 120 150;
				separator -w 50 -st none;
				button -w 110 -l "Remove animation" -c ("asMCLRemoveBody \""+$uiName+"\"");
				button -w 110 -l "Bake animation" -c ("asMCLBakeBody \""+$uiName+"\"");
				setParent..;
			setParent..;
		setParent..;
	separator -h 5;
	frameLayout -cll 1 -cl `optionVar -q asMCLFaceFrameLayout` -cc asFL -ec asFL -l "Face" asMCLFaceFrameLayout;
		columnLayout;
			rowLayout -nc 3;
				separator -h 20 -w 50 -st none;
				optionMenu asMCLFaceOptionMenu;
				button -l apply -c ("asMCLTestFace \""+$uiName+"\"");
//				button -l "import Face test-animation" -c ("asMCLTestFace \""+$uiName+"\"");
			setParent..;
		setParent..;
		rowLayout -nc 2;
			separator -h 20 -w 50 -st none;
			button -l "Remove Face animation" -c ("asMCLRemoveFace \""+$uiName+"\"");
			setParent..;

asPopulateMCLMoCapsOptionMenu;
asPopulateMCLMoCapCustomOptionMenu;
asPopulateMCLCNU1OptionMenu;
asPopulateMCLFaceOptionMenu;

showWindow asMoCapLibraryUI;
}

global proc asMCLMoCapCustomBrowse (string $textField)
{
int $fileMode=1;
if ($textField=="asMCLMoCapCustomPathTextField")
	$fileMode=3;
string $result[]=`fileDialog2 -fm $fileMode -cap folder -okc Choose`;
textField -e -tx $result[0] $textField;
optionVar -sv $textField $result[0];
asPopulateMCLMoCapCustomOptionMenu;
}

global proc asPopulateMCLMoCapsOptionMenu ()
{
string $mayaLocation=`getenv MAYA_LOCATION`;
string $mocapFbxLocation=$mayaLocation+"/Examples/Animation/Motion_Capture/FBX";
if (!`file -q -ex $mocapFbxLocation`)
	return;
string $files[]=`getFileList -fs "*.fbx" -fld $mocapFbxLocation`;
setParent -menu asMCLMoCapMayaOptionMenu;
for ($i=0;$i<size($files);$i++)
	menuItem -l $files[$i];
}

global proc asPopulateMCLMoCapCustomOptionMenu ()
{
string $path=`textField -q -tx asMCLMoCapCustomPathTextField`;
string $tempString[];

if ($path=="")
	return;

$tempString=`optionMenu -q -ill asMCLMoCapCustomOptionMenu`;
for ($y=0;$y<size($tempString);$y++)
	deleteUI $tempString[$y];

string $files[]=`getFileList -fs "*.*" -fld $path`;
setParent -menu asMCLMoCapCustomOptionMenu;
for ($i=0;$i<size($files);$i++)
	menuItem -l $files[$i];
}

global proc asPopulateMCLCNU1OptionMenu ()
{
string $line;
string $subjects[],$tempString[];
string $file=`asGetScriptLocation`+"/AdvancedSkeletonFiles/moCapCNUlib/moCapCNUlib.txt"; 

if (!`file -q -ex $file`)
	error ("Unable to find file:"+$file);

int $fileId=`fopen $file "r"`;
string $nextLine = `fgetline $fileId`;
while (size($nextLine)>0)
	{
	$line=`strip $nextLine`;
	tokenize $line $tempString;
	if (`gmatch $line "Subject #*"`)
		$subjects[size($subjects)]=$line;
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

setParent -menu asMCLCNU1OptionMenu;
for ($i=0;$i<size($subjects);$i++)
	menuItem -l $subjects[$i];
asPopulateMCLCNU2OptionMenu;
//asUpdateMoCapCNUApplyButton;
}

global proc asPopulateMCLCNU2OptionMenu ()
{
int $subjectMatch;
string $line;
string $tempString[],$clips[];
string $file=`asGetScriptLocation`+"/AdvancedSkeletonFiles/moCapCNUlib/moCapCNUlib.txt";
string $subject=`optionMenu -q -v asMCLCNU1OptionMenu`;

//remove existing items
$tempString=`optionMenu -q -ill asMCLCNU2OptionMenu`;
for ($y=0;$y<size($tempString);$y++)
	deleteUI $tempString[$y];

int $fileId=`fopen $file "r"`;
string $nextLine = `fgetline $fileId`;
while (size($nextLine)>0)
	{
	$line=`strip $nextLine`;
	tokenize $line $tempString;
	if (`gmatch $line "Subject #*"`)
		{
		if ($line==$subject)
			$subjectMatch=1;
		else
			$subjectMatch=0;
		}
	if ($subjectMatch && `gmatch $line "[0-9][0-9]*"`)
		$clips[size($clips)]=$line;

	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

setParent -menu asMCLCNU2OptionMenu;
for ($i=0;$i<size($clips);$i++)
	menuItem -l $clips[$i];

asUpdateMoCapCNUApplyButton;
}

global proc asPopulateMCLFaceOptionMenu ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $moCapFacelibDir=$asScriptLocation+"/AdvancedSkeletonFiles/faceLibrary";
string $files[]=`getFileList -fld $moCapFacelibDir`;
setParent -menu asMCLFaceOptionMenu;
for ($i=0;$i<size($files);$i++)
	{
	if ($files[$i]=="incrementalSave")
		continue;
	menuItem -l $files[$i];
	}
}

global proc asPopulateATFaceOptionMenu ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $moCapFacelibDir=$asScriptLocation+"/AdvancedSkeletonFiles/faceLibrary";
string $files[]=`getFileList -fld $moCapFacelibDir`;
setParent -menu asATFaceOptionMenu;
for ($i=0;$i<size($files);$i++)
	{
	if ($files[$i]=="incrementalSave")
		continue;
	menuItem -l $files[$i];
	}
}

global proc asUpdateMoCapCNUApplyButton ()
{
string $label="apply";
string $asScriptLocation=`asGetScriptLocation`;
string $moCapCNUlibDir=$asScriptLocation+"/AdvancedSkeletonFiles/moCapCNUlib/downloads";
string $clipLongName=`optionMenu -q -v asMCLCNU2OptionMenu`;
string $files[]=`getFileList -fld $moCapCNUlibDir`;
string $tempString[];
tokenize $clipLongName $tempString;
string $clipShortName=$tempString[0];
string $mayaFile=$moCapCNUlibDir+"/"+$clipShortName+".ma";

if (!`file -q -ex $mayaFile`)
	$label="download && apply";
button -e -l $label asMCLCNUApplyButton;
}

global proc asMCLMayaApply (string $uiName)
{
asMCLApply $uiName Maya;
}

global proc asMCLCustomApply (string $uiName)
{
asMCLApply $uiName Custom;
}

global proc asMCLCNUApply (string $uiName)
{
if (`button -q -l asMCLCNUApplyButton`=="download && apply")
	asMCLMoCapCNUDownload;
asMCLApply $uiName CNU;
}

global proc asMCLApply (string $uiName, string $type)
{
global string $unrealMannequinJoints;
int $lastKeyFrameNr,$altSkeletonType;
int $autoKeyState=`autoKeyframe -q -state`;
float $lowestFootTy,$s,$sizeAdv,$sizeMoCap;
float $posA[],$posB[],$keyTimes[],$rot[],$rotA[],$rotB[];
string $mayaLocation=`getenv MAYA_LOCATION`;
string $asScriptLocation=`asGetScriptLocation`;
string $mocapFbxLocation;
string $fileName,$file,$moCapCNUlibDir,$clipLongName,$clipShortName,$topNode,$tPoseNameSpace;
string $rightShoulder,$rightArm,$rightForeArm,$rightHand,$rightUpLeg,$rightLeg,$rightFoot;
string  $leftShoulder, $leftArm, $leftForeArm, $leftHand, $leftUpLeg, $leftLeg, $leftFoot;
string $basename=`basenameEx $file`;
string $ref="MotionCaptureLibrary:"+$basename+":Reference";
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $hipsJoint,$side,$rightLeft,$mpd,$moCapNs;
string $tempString[],$moCapJoints[],$files[];

if ($autoKeyState) autoKeyframe -state 0;

if ($type=="Maya") 
	{
	$mocapFbxLocation=$mayaLocation+"/Examples/Animation/Motion_Capture/FBX";
	$fileName=`optionMenu -q -v ("asMCLMoCap"+$type+"OptionMenu")`;
	$file=$mocapFbxLocation+"/"+$fileName;
	}
if ($type=="Custom") 
	{
	$mocapFbxLocation=`textField -q -tx asMCLMoCapCustomPathTextField`;
	$file=$mocapFbxLocation+"/"+`optionMenu -q -v asMCLMoCapCustomOptionMenu`;
	}
if ($type=="CNU") 
	{
//	$moCapShoulderName="Arm";
	$moCapCNUlibDir=$asScriptLocation+"/AdvancedSkeletonFiles/moCapCNUlib/downloads";
	$clipLongName=`optionMenu -q -v asMCLCNU2OptionMenu`;
	$files=`getFileList -fld $moCapCNUlibDir`;
	tokenize $clipLongName $tempString;
	$clipShortName=$tempString[0];
	$file=$moCapCNUlibDir+"/"+$clipShortName+".ma";
	}

if ($file=="")
	error "No MotionCapture Example choosen";
if (!`file -q -ex $file`)
	error ("File not found:\""+$file+"\"");

asMCLRemoveBody $uiName;

$topNodesBefore=`ls -as`;

if ($type=="Custom") 
	{
	file -r -namespace "MotionCaptureLibrary" $file;
	file -importReference $file;
	}
else
	file -i -namespace "MotionCaptureLibrary" $file;

$topNodesAfter=`ls -as`;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		{
		$tempString=`listRelatives -type joint -c $topNodesAfter[$i]`;
		if (size($tempString))
			{
			$topNode=$topNodesAfter[$i];
			break;
			}
		}

print ("// detected MoCap TopNode:\""+$topNode+"\".\n");

tokenize $topNode ":" $tempString;
if (size($tempString)>1)//if the file is a fbx, nameSpace does not get added upon import
	$moCapNs=$tempString[0]+":";

if ($moCapNs=="")
	{
	if (!`namespace -ex MotionCaptureLibrary`)
		namespace -addNamespace MotionCaptureLibrary;
	namespace -setNamespace MotionCaptureLibrary;
	$tempString=`listRelatives -ad -type transform $topNode`;
	$tempString[size($tempString)]=$topNode;
	for ($i=0;$i<size($tempString);$i++)
		{
		rename $tempString[$i] ("TEMP_"+$tempString[$i]);
		rename ("MotionCaptureLibrary:TEMP_"+$tempString[$i]) $tempString[$i];
		}
	namespace -setNamespace ":";
	$moCapNs="MotionCaptureLibrary:";
	$topNode=$moCapNs+$topNode;
	}

$moCapJoints=`listRelatives -type joint -ad $topNode`;

currentTime 0;
if (`nodeType $topNode`=="joint" && `getAttr ($topNode+".ty")`>0)//chek ty>0 as this could be Unreal-root, which is not $hipsJoint;
	$hipsJoint=$topNode;
else
	{
	$tempString=`listRelatives -type joint -c $topNode`;
	$hipsJoint=$tempString[0];
	}

createNode -n MotionCaptureLibraryScale transform;
parent $topNode MotionCaptureLibraryScale;

//Names (CMU & Maya have MoCap standard names e.g. RightShoulder, but Custom could have alternative names
$rightShoulder="RightShoulder";$leftShoulder="LeftShoulder";
$rightArm="RightArm";$leftArm="LeftArm";
$rightForeArm="RightForeArm";$leftForeArm="LeftForeArm";
$rightHand="RightHand";$leftHand="LeftHand";
$rightUpLeg="RightUpLeg";$leftUpLeg="LeftUpLeg";
$rightLeg="RightLeg";$leftLeg="RightLeg";
$rightFoot="RightFoot";$leftFoot="LeftFoot";
if (`objExists ($moCapNs+"upperarm_r")`)
	{
	$altSkeletonType=1;//Unreal Mannequin
	addAttr -ln altSkeletonType -at long -dv 1 MotionCaptureLibraryScale;
	$rightShoulder="clavicle_r";$leftShoulder="clavicle_l";
	$rightArm="upperarm_r";$leftArm="upperarm_l";
	$rightForeArm="lowerarm_r";$leftForeArm="lowerarm_l";
	$rightHand="hand_r";$leftHand="hand_l";
	$rightUpLeg="thigh_r";$leftUpLeg="thigh_l";
	$rightLeg="calf_r";$leftLeg="calf_l";
	$rightFoot="foot_r";$leftFoot="foot_l";
	if (!`objExists "root"`)//might already be working with a rig that has UnrealJoints added
		{
		createNode -n asMoCapMatcherCreatingUnrealMannequinJoints transform;
		$unrealMannequinJoints="Quinn (UE5)";
		asCreateUnrealMannequinJoints;

		$tPoseNameSpace="TPose";
		if (`namespace -ex TPose`)
			delete `ls "TPose:*"`;
		else
			namespace -addNamespace TPose;
		namespace -setNamespace TPose;
		$tempString=`listRelatives -ad -type transform root`;
		$tempString[size($tempString)]="root";
		for ($i=0;$i<size($tempString);$i++)
			{
			rename $tempString[$i] ("TEMP_"+$tempString[$i]);
			rename ("TPose:TEMP_"+$tempString[$i]) $tempString[$i];
			}
		setAttr TPose:root.v 0;
		namespace -setNamespace ":";
		}
	}

//Rmoved, as some MoCap animations do not start with feet on the ground. e.g. Hoverboard_Hover clip
//assume one of the feet are touching the ground, at the start of animation, Find the Lowest one
//if (`objExists ($moCapNs+$leftFoot)`)	  $posA=`xform -q -ws -t ($moCapNs+$leftFoot)`;
//if (`objExists ($moCapNs+$rightFoot)`)	$posB=`xform -q -ws -t ($moCapNs+$rightFoot)`;
//$lowestFootTy=`min $posA[1] $posB[1]`;

$keyTimes=`keyframe -q -tc ($hipsJoint+".tx")`;
$lastKeyFrameNr=$keyTimes[size($keyTimes)-1];

playbackOptions -min -1 -ast -1 -max $lastKeyFrameNr -aet $lastKeyFrameNr;
currentTime -1;
//asSetAllFK "";
if (`objExists ($nameSpace+"FKIKLeg_R")`) setAttr ($nameSpace+"FKIKLeg_R.FKIKBlend") 10;
if (`objExists ($nameSpace+"FKIKLeg_L")`) setAttr ($nameSpace+"FKIKLeg_L.FKIKBlend") 10;
if (`objExists ($nameSpace+"FKIKSpine_M")`) setAttr ($nameSpace+"FKIKSpine_M.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_R")`) setAttr ($nameSpace+"FKIKArm_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_L")`) setAttr ($nameSpace+"FKIKArm_L.FKIKBlend") 0;

//zero-out MoCap Skeleton joints
if ($altSkeletonType==0)
	{
	for ($i=0;$i<size($moCapJoints);$i++)
		setAttr ($moCapJoints[$i]+".r") -type float3 0 0 0;
	setAttr ($hipsJoint+".tx") 0;
	setAttr ($hipsJoint+".tz") 0;
	}
if ($altSkeletonType==1)
	{
	//could have a "root" joint above $hipsJoint, (aka Unreal Root Joints)  so include making sure this is also zeroed
	$tempString=`listRelatives -p -type joint $hipsJoint`;
	if (`gmatch $tempString[0] "*root"`)
		{
		xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $tempString[0];
		setKeyframe $tempString[0];
		}

//	setAttr ($hipsJoint+".tx") 0;
//	setAttr ($hipsJoint+".ty") 0;
	}

//Attempt to T-Pose MoCap Skeleton
if ($type=="CNU")
	{
	xform -ws -ro 0 0 0 ($moCapNs+$rightShoulder);xform -ws -ro 0 0 0 ($moCapNs+$leftShoulder);
	xform -ws -ro 0 0 0 ($moCapNs+$rightArm);xform -ws -ro 0 0 0 ($moCapNs+$leftArm);
	xform -ws -ro 0 0 0 ($moCapNs+$rightForeArm);xform -ws -ro 0 0 0 ($moCapNs+$leftForeArm);
	xform -ws -ro 0 0 0 ($moCapNs+$rightHand);xform -ws -ro 0 0 0 ($moCapNs+$leftHand);
	setAttr ($moCapNs+$rightUpLeg+".rz") 20;
	setAttr ($moCapNs+$leftUpLeg+".rz") -20;
	}
if ($type=="Maya")
	{
	xform -ws -ro -180 0 180 ($moCapNs+$rightShoulder);xform -ws -ro 0 0 0 ($moCapNs+$leftShoulder);
	xform -ws -ro 90 0 -180 ($moCapNs+$rightArm);xform -ws -ro 90 0 0 ($moCapNs+$leftArm);
	}

if ($altSkeletonType==1)
	{
	for ($i=0;$i<size($moCapJoints);$i++)
		{
		$tposeJoint=`substitute "MotionCaptureLibrary" $moCapJoints[$i] $tPoseNameSpace`;
		if (!`objExists $tposeJoint`)
//			error ("failed to find t-pose joint: \""+$tposeJoint+"\".\n");
			{
			warning ("failed to find t-pose joint: \""+$tposeJoint+"\".\n");
			continue;
			}
		$rot=`getAttr ($tposeJoint+".r")`;
		setAttr ($moCapJoints[$i]+".r") -type float3 $rot[0] $rot[1] $rot[2];
		}
	}

//After Straighting, legs and knee straighting probably cause the foot to be lower, so compensate
/*
if (`objExists ($moCapNs+$leftFoot)`)
	{
	$posA=`xform -q -ws -t ($moCapNs+$leftFoot)`;
	if ($posA[1]<$lowestFootTy)
		move -r -ws -wd 0 ($lowestFootTy-$posA[1]) 0 $hipsJoint;
	}
*/

$posA=`xform -q -ws -t ($nameSpace+"Root_M")`;
$posB=`xform -q -ws -t ($nameSpace+"IKLeg_R")`;
$sizeAdv=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

$posA=`xform -q -ws -t $hipsJoint`;
$posB=`xform -q -ws -t ($moCapNs+$rightFoot)`;
$sizeMoCap=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

$s=$sizeAdv/$sizeMoCap;
if ($s>1.1 || $s<0.9)
	setAttr MotionCaptureLibraryScale.s -type float3 $s $s $s;

//match Root pos
$posA=`xform -q -ws -t ($nameSpace+"Root_M")`;
xform -ws -t $posA[0] $posA[1] $posA[2] $hipsJoint;

select $moCapJoints;
setKeyframe;

//Attempt to T-Pose AdvancedSkeleton
if ($altSkeletonType!=1)// Skip as this could be Unreal Mannequin rigged with AS, so Non-T-BuildPose
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1)  {$side="_R";$rightLeft="Right";$rotA[0]=0;$rotA[1]=0;$rotA[2]=180;$rotB[0]=90;$rotB[1]=0;$rotB[2]=180;}
		if ($b==-1) {$side="_L";$rightLeft="Left";$rotA[0]=0;$rotA[1]=0;$rotA[2]=0;$rotB[0]=-90;$rotB[1]=0;$rotB[2]=180;}

		if (`objExists ($nameSpace+"FKShoulder"+$side)`) asSetMoCapWSOrient $rotB[0] $rotB[1] $rotB[2] ($nameSpace+"FKShoulder"+$side) $nameSpace;
		if (`objExists ($nameSpace+"FKElbow"+$side)`) asSetMoCapWSOrient $rotB[0] $rotB[1] $rotB[2] ($nameSpace+"FKElbow"+$side) $nameSpace;
		if (`objExists ($nameSpace+"FKWrist"+$side)`) asSetMoCapWSOrient $rotB[0] $rotB[1] $rotB[2] ($nameSpace+"FKWrist"+$side) $nameSpace;

		//Align IK as well
		if (`objExists ("IKLeg"+$side)` && `objExists ($moCapNs+$rightLeft+"Foot")`) 
			delete `pointConstraint -skip y ($moCapNs+$rightLeft+"Foot") ("IKLeg"+$side)`;
		}

asMCLConnectBody $uiName;

setAttr MotionCaptureLibraryScale.v 0;
if ($autoKeyState) autoKeyframe -state 1;
select -cl;
currentTime 0;
}

global proc asMCLMoCapCNUDownload ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $moCapCNUlibDir=$asScriptLocation+"/AdvancedSkeletonFiles/moCapCNUlib/downloads";
string $clipLongName=`optionMenu -q -v asMCLCNU2OptionMenu`;
string $tempString[];
tokenize $clipLongName $tempString;
string $clipShortName=$tempString[0];
string $zipFileUrl="https://www.advancedskeleton.com/download/moCapCNUlib/downloads/"+$clipShortName+".7z";
string $curl=$asScriptLocation+"/AdvancedSkeletonFiles/bin/curl.e";
string $zip=$asScriptLocation+"/AdvancedSkeletonFiles/bin/7za.e";
string $downloadDir=$asScriptLocation+"/AdvancedSkeletonFiles/moCapCNUlib/downloads";
tokenize $zipFileUrl "/" $tempString;
string $downloadedZipFile=$tempString[size($tempString)-1];
string $downloadedZipFilePath=$downloadDir+"/"+$downloadedZipFile;
string $downloadedMaFilePath=$downloadDir+"/"+`substitute "[.]7z" $downloadedZipFile ".ma"`;
string $cmd;

if (!`file -q -ex $downloadDir`) sysFile -md $downloadDir;

//download
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -k -L -o "+$downloadDir+"/"+$downloadedZipFile+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -L -o \""+$downloadDir+"/"+$downloadedZipFile+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+"\n");
	system ($cmd);
	}

//confirm downloads
if (`file -q -ex $downloadedZipFilePath`)
	print ("// Downloaded sucessfully:"+$downloadedZipFilePath+";\n");
else
	error ("// Download failed, could not find:"+$downloadedZipFilePath+";\n");

//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$downloadedZipFilePath+" -d "+$moCapCNUlibDir;
else
	$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x \""+$downloadedZipFilePath+"\" -o\""+$moCapCNUlibDir+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex $downloadedMaFilePath`)
	print ("// Unzipped sucessfully:"+$downloadedMaFilePath+";\n");
else
	error ("// Unzipp failed, could not find:"+$downloadedMaFilePath);

//Delete download
if (`filetest -f $downloadedZipFilePath`)
	sysFile -del $downloadedZipFilePath;

asUpdateMoCapCNUApplyButton;
}

global proc asMCLBakeBody (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $sel[]=`ls -sl`;
string $controlSetMembers[];
string $refFiles[]=`file -q -r`;

if (!`objExists ($nameSpace+"ControlSet")`)
	error "No controlSets detected";

$controlSetMembers=`sets -q ($nameSpace+"ControlSet")`;
select $controlSetMembers;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $controlSetMembers;
select $controlSetMembers;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";

//remove MotionCaptureLibrary-reference
for ($i=0;$i<size($refFiles);$i++)
	if (`file -q -ns $refFiles[$i]`=="MotionCaptureLibrary")
		file -rr $refFiles[$i];
if (`objExists MotionCaptureLibraryScale`)
	delete MotionCaptureLibraryScale;

if (`namespace -ex MotionCaptureLibrary`)
	namespace -rm MotionCaptureLibrary;

catchQuiet (`select $sel`);
print ("// Body animations baked.\n");
}

global proc asMCLDisconnectBody (string $uiName)
{
float $currentTime=`currentTime -q`;
string $tempString[];

currentTime -1;
$tempString=`ls -type constraint -type multiplyDivide`;
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists moCapLibCN $tempString[$i]`)
		delete $tempString[$i];
currentTime $currentTime;

print "// Motion Capture Diconnected.\n";
}

global proc asMCLConnectBody (string $uiName)
{
int $numConnected,$altSkeletonType;
float $currentTime=`currentTime -q`;
float $distA,$distB;
float $posA[],$posB[],$posC[];
string $side,$rightLeft,$rightLeftSuffix,$topNode,$asFKFinger,$moCapFingerJoint,$hip,$knee,$ankle;
string $moCapNs="MotionCaptureLibrary:";
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $tempString[],$constraintObjs[],$constraintToObjs[],$cn[];
string $fingers[]={"Thumb","Index","Middle","Ring","Pinky"};

if (`attributeExists altSkeletonType MotionCaptureLibraryScale`)
	$altSkeletonType=`getAttr MotionCaptureLibraryScale.altSkeletonType`;

if ($currentTime!=-1)
	if (`confirmDialog -t "Confirm"
	-m ("Connecting when Not at Frame -1, could lead to unwanted offset.\n"
		+"It is recommended to connect at Frame -1.\n")
	-b "Proceed Anyway" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="Proceed Anyway")
		return;

$constraintObjs={"RootX_M","FKRoot_M","FKSpine1_M","FKChest_M","FKNeck_M","FKHead_M"};
$constraintToObjs={"Hips","Spine","Spine1","Spine3","Neck","Head"};

if ($altSkeletonType==1)
	$constraintToObjs={"pelvis","spine_01","spine_03","spine_05","neck_01","head"};

$tempString=`listRelatives -c MotionCaptureLibraryScale`;
$topNode=$tempString[0];
tokenize $topNode ":" $tempString;
$moCapNs=$tempString[0]+":";

//create poleVec PlaceHolder
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$rightLeft="Right";$rightLeftSuffix="_r";}
	if ($b==-1) {$side="_L";$rightLeft="Left";$rightLeftSuffix="_l";}

	if ($altSkeletonType==0)
		{
		if (`objExists ($moCapNs+$rightLeft+"UpLeg")`) $hip=$moCapNs+$rightLeft+"UpLeg";
		if (`objExists ($moCapNs+$rightLeft+"Leg")`) $knee=$moCapNs+$rightLeft+"Leg";
		if (`objExists ($moCapNs+$rightLeft+"Foot")`) $ankle=$moCapNs+$rightLeft+"Foot";
		}
	if ($altSkeletonType==1)
		{
		if (`objExists ($moCapNs+"thigh"+$rightLeftSuffix)`) $hip="thigh"+$rightLeftSuffix;
		if (`objExists ($moCapNs+"calf"+$rightLeftSuffix)`) $knee="calf"+$rightLeftSuffix;
		if (`objExists ($moCapNs+"foot"+$rightLeftSuffix)`) $ankle="foot"+$rightLeftSuffix;
		}
	if (`objExists $hip` && `objExists $ankle`)
		{
		namespace -set $moCapNs;
		if (!`objExists PoleVectorLocators`)
			createNode -n PoleVectorLocators -p MotionCaptureLibraryScale transform;
		createNode -n ("PoleVectorLocatorOffset"+$side) -p ($moCapNs+"PoleVectorLocators") transform;
		createNode -n ("PoleVectorLocator"+$side) -p ($moCapNs+"PoleVectorLocatorOffset"+$side) transform;
		namespace -set ":";

		$posA=`xform -q -ws -t $hip`;
		$posB=`xform -q -ws -t $knee`;
		$posC=`xform -q -ws -t $ankle`;
		$distA=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		$distB=`mag<<$posB[0]-$posC[0],$posB[1]-$posC[1],$posB[2]-$posC[2]>>`;

		pointConstraint -w $distB $hip ($moCapNs+"PoleVectorLocatorOffset"+$side);
		pointConstraint -w $distA $ankle ($moCapNs+"PoleVectorLocatorOffset"+$side);
		//avoid flippped knee when straight leg
		setAttr ("PoleVectorLocatorOffset"+$side+"_pointConstraint1.offsetZ") -0.1;

		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $knee ($moCapNs+"PoleVectorLocatorOffset"+$side);
		select $hip $ankle;
		setAttr ($moCapNs+"PoleVectorLocator"+$side+".tx") ((($distA+$distB)/2.0)/`getAttr MotionCaptureLibraryScale.sx`);
		}
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$rightLeft="Right";$rightLeftSuffix="_r";}
	if ($b==-1) {$side="_L";$rightLeft="Left";$rightLeftSuffix="_l";}

	$tempString={("FKHip"+$side),("FKKnee"+$side),("FKAnkle"+$side),("FKToes"+$side),("IKLeg"+$side),("PoleLeg"+$side),("IKToes"+$side),("FKScapula"+$side),("FKShoulder"+$side),("FKElbow"+$side),("FKWrist"+$side)};
	$constraintObjs=`stringArrayCatenate $tempString $constraintObjs`;
	if ($altSkeletonType==0)
		$tempString={($rightLeft+"UpLeg"),($rightLeft+"Leg"),($rightLeft+"Leg"),($rightLeft+"ToeBase"),($rightLeft+"Foot"),("PoleVectorLocator"+$side),($rightLeft+"ToeBase"),($rightLeft+"Shoulder"),($rightLeft+"Arm"),($rightLeft+"ForeArm"),($rightLeft+"Hand")};
	if ($altSkeletonType==1)
		$tempString={("thigh"+$rightLeftSuffix),("calf"+$rightLeftSuffix),("foot"+$rightLeftSuffix),("ball"+$rightLeftSuffix),("foot"+$rightLeftSuffix),("PoleVectorLocator"+$side),("ball"+$rightLeftSuffix),("clavicle"+$rightLeftSuffix),("upperarm"+$rightLeftSuffix),("lowerarm"+$rightLeftSuffix),("hand"+$rightLeftSuffix)};
	$constraintToObjs=`stringArrayCatenate $tempString $constraintToObjs`;

	//fingers
	for ($y=0;$y<size($fingers);$y++)
		for ($i=1;$i<4;$i++)
			{
			$asFKFinger=$nameSpace+"FK"+$fingers[$y]+"Finger"+$i+$side;
			$moCapFingerJoint=$rightLeft+"Hand"+$fingers[$y]+$i;
			if ($altSkeletonType==1)
				$moCapFingerJoint=`tolower $fingers[$y]`+"_"+`asDoPadd $i 2`+$rightLeftSuffix;
			$constraintObjs[size($constraintObjs)]=$asFKFinger;
			$constraintToObjs[size($constraintToObjs)]=$moCapFingerJoint;
			}
	}

for ($i=0;$i<size($constraintObjs);$i++)
	{
	if (!`objExists ($moCapNs+$constraintToObjs[$i])` || !`objExists ($nameSpace+$constraintObjs[$i])`)
		continue;
	if (`gmatch $constraintObjs[$i] "FK*"` || `gmatch $constraintObjs[$i] "IKToes_*"`)
		$tempString=`orientConstraint -mo ($moCapNs+$constraintToObjs[$i]) ($nameSpace+$constraintObjs[$i])`;
	else if (`gmatch $constraintObjs[$i] "Pole*"`)
		$tempString=`pointConstraint ($moCapNs+$constraintToObjs[$i]) ($nameSpace+$constraintObjs[$i])`;
	else
		$tempString=`parentConstraint -mo ($moCapNs+$constraintToObjs[$i]) ($nameSpace+$constraintObjs[$i])`;
	$cn[size($cn)]=$tempString[0];
	$numConnected++;
	}

/*fingers used to be `directConnect` v<6.003, but now allowing or Unreal FBX so including these as constraints
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$rightLeft="Right";$rightLeftSuffix="_r";}
	if ($b==-1) {$side="_L";$rightLeft="Left";$rightLeftSuffix="_l";}

	for ($y=0;$y<size($fingers);$y++)
		for ($i=1;$i<4;$i++)
			{
			$mpd="MotionCaptureLibrary"+$fingers[$y]+"FingerMPD"+$i+$side;
			if (`objExists $mpd`)
				delete $mpd;
			$moCapFingerJoint=$moCapNs+$rightLeft+"Hand"+$fingers[$y]+$i;
			if ($altSkeletonType==1)
				$moCapFingerJoint=$moCapNs+`tolower $fingers[$y]`+"_"+`asDoPadd $i 2`+$rightLeftSuffix;

			if (!`objExists $moCapFingerJoint` || !`objExists ($nameSpace+"FK"+$fingers[$y]+"Finger"+$i+$side)`)
				continue;
			createNode -n $mpd multiplyDivide;
			$cn[size($cn)]=$mpd;
			connectAttr ($moCapFingerJoint+".ry") ($mpd+".input1Y");
			connectAttr ($moCapFingerJoint+".rz") ($mpd+".input1Z");
			setAttr ($mpd+".input2Y") -1;
			if ($side=="_L")
				setAttr ($mpd+".input2Z") -1;
			connectAttr ($mpd+".outputZ") ($nameSpace+"FK"+$fingers[$y]+"Finger"+$i+$side+".ry");
			connectAttr ($mpd+".outputY") ($nameSpace+"FK"+$fingers[$y]+"Finger"+$i+$side+".rz");
			$numConnected++;
			}
	}
*/

for ($i=0;$i<size($cn);$i++)
	if (!`attributeExists moCapLibCN $cn[$i]`)
		addAttr -k 0 -ln moCapLibCN -at bool -dv 1 $cn[$i];

print ("// Motion Capture Connected ("+$numConnected+" controllers).\n");
}

global proc asMCLRemoveBody (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $refFiles[]=`file -q -r`;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$controlSetMembers[];

if (!`objExists ($nameSpace+"ControlSet")`)
	error "No controlSets detected. select a controller";

$controlSetMembers=`sets -q ($nameSpace+"ControlSet")`;
select $controlSetMembers;
string $animCurves[]=`listConnections -type animCurve -s 1 -d 0`;
if (size($animCurves))
	delete $animCurves;

//remove constraint
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listConnections -type constraint -s 1 -d 0 ($controlSetMembers[$i]+".rx")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`objExists $tempString[$y]`)
			continue;
		$tempString2=`listConnections -s 1 -d 0 ($tempString[$y]+".target[0].targetRotate")`;
		if (`gmatch $tempString2[0] "MotionCaptureLibrary:*"`)
			delete $tempString[$y];
		}
	}

//remove MotionCaptureLibrary-reference
for ($i=0;$i<size($refFiles);$i++)
	if (`file -q -ns $refFiles[$i]`=="MotionCaptureLibrary")
		file -rr $refFiles[$i];
if (`objExists MotionCaptureLibraryScale`)
	delete MotionCaptureLibraryScale;

if (`objExists MoCapConstraints`)//in case of useMoCapMatcher
	delete MoCapConstraints;

$tempString=`ls "MotionCaptureLibrary:*"`;
if (size($tempString))
	delete $tempString;

$tempString=`ls "TPose:*"`;
if (size($tempString))
	delete $tempString;

if (`namespace -ex MotionCaptureLibrary`)
	namespace -rm MotionCaptureLibrary;
if (`namespace -ex TPose`)
	namespace -rm TPose;

if (`objExists ($nameSpace+"ControlSet")`) asGoToBuildPoseOptions $nameSpace "ControlSet";

catchQuiet (`select $sel`);
print ("// Body animations removed.\n");
}

global proc asMCLRemoveFace (string $uiName)
{
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $refFiles[]=`file -q -r`;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];

if (!`objExists ($nameSpace+"ControlSet")`)
	error "No controlSets detected. select a controller";

select -cl;
if (`objExists ($nameSpace+"FaceControlSet")`) select -add `sets -q ($nameSpace+"FaceControlSet")`;
if (`objExists ($nameSpace+"FKHead_M")`) select -add ($nameSpace+"FKHead_M");
if (`objExists ($nameSpace+"FKNeck_M")`) select -add ($nameSpace+"FKNeck_M");
	
string $animCurves[]=`listConnections -type animCurve -s 1 -d 0`;
if (size($animCurves))
	delete $animCurves;

if (`objExists ($nameSpace+"ControlSet")`) asGoToBuildPoseOptions $nameSpace "ControlSet";
if (`objExists ($nameSpace+"FaceControlSet")`) asGoToBuildPoseOptions $nameSpace "FaceControlSet";

dgdirty -a;
catchQuiet (`select $sel`);
print ("// Face Test animations removed.\n");
}

global proc asMCLTestFace (string $uiName)
{
float $keyTimes[];
string $ctrl,$attr,$clip,$asMotionFaceFile;
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $asScriptLocation=`asGetScriptLocation`;
string $moCapFacelibDir=$asScriptLocation+"/AdvancedSkeletonFiles/faceLibrary";
string $tempString[],$tempString2[],$animCurves[];

if (!`objExists ($nameSpace+"FaceControlSet")`)
	error "No controlSets detected. select a controller";

if (`optionMenu -q -ex asMCLFaceOptionMenu`)
	$clip=`optionMenu -q -v asMCLFaceOptionMenu`;
else
	$clip=`optionMenu -q -v asATFaceOptionMenu`;
$asMotionFaceFile=$moCapFacelibDir+"/"+$clip;

if (`objExists animationTestFaceFromMoCapLibrary`)
	{
	$nameSpace=`getAttr animationTestFaceFromMoCapLibrary.nameSpace`;
	delete animationTestFaceFromMoCapLibrary;
	}
asMCLRemoveFace $uiName;
file -r -ignoreVersion -gl -mergeNamespacesOnClash false -namespace "MotionCaptureLibraryFace" -options "v=0;" $asMotionFaceFile;

$animCurves=`ls -type animCurve "MotionCaptureLibraryFace:*"`;
for ($i=0;$i<size($animCurves);$i++)
	{
	//remove old copies, if exists
	$tempString[0]=`substitute "MotionCaptureLibraryFace:" $animCurves[$i] ""`;
	$tempString=`ls ($tempString[0]+"*")`;
	if (size($tempString))
		delete $tempString;

	$tempString=`duplicate $animCurves[$i]`;
	tokenize $tempString[0] "_" $tempString2;
	$ctrl=$nameSpace+$tempString2[0]+"_"+$tempString2[1];
	$attr=$tempString2[2];
	if (!`attributeExists $attr $ctrl`)
		{
		print ("//Not found:"+$ctrl+"."+$attr+"\n");
		continue;
		}
print ("connectAttr "+$tempString[0]+".output "+$ctrl+"."+$attr+";\n");
	 catchQuiet (`connectAttr ($tempString[0]+".output") ($ctrl+"."+$attr)`);
	}
file -rr $asMotionFaceFile;
/*
playbackOptions -min 0 -ast 0 -max 330 -aet 330;
currentTime 70;
*/
if (`objExists ($nameSpace+"FaceControlSet")`)
	{
	$keyTimes=`keyframe -q -tc ($nameSpace+"ctrlMouth_M.ty")`;
	$lastKeyFrameNr=$keyTimes[size($keyTimes)-1];
	playbackOptions -min -1 -ast -1 -max $lastKeyFrameNr -aet $lastKeyFrameNr;
	}

print "// Test animation applied.\n";
}

global proc int asIsMayaLT ()
{
int $isMayaLT=0;
if (!`exists CreateWrap`)
	$isMayaLT=1;
return $isMayaLT;
}

global proc asReferenceBrowser (int $model)
{
global string $selectedNamespaceRadioButton;
string $sNRB=$selectedNamespaceRadioButton;
string $referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
int $referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
int $referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
string $ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;
string $defaultFileReferenceType=`optionVar -q defaultFileReferenceType`;
string $tempString[],$topNodesBefore[],$topNodesAfter[];

string $renamePrefix="model";
string $mergeOptionValue="radioNamespaceOnString";
if (!$model)
	{
	$renamePrefix="anim";
	$mergeOptionValue="radioNamespaceOnFileName";
	}

optionVar -sv referenceOptionsRenamePrefix $renamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue $mergeOptionValue;
optionVar -sv defaultFileReferenceType "mayaBinary";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton=$mergeOptionValue;

if (`asHotKeyCheck ("asReferenceBrowser "+$model)`) return;

if ($model)
	$topNodesBefore=`ls -as`;

if (`asIsMayaLT`)
	error ("Maya LT does not have Reference, Import the model instead");
CreateReferenceOptions;

//Something in here Ran again, makes it work
global string $selectedNamespaceRadioButton;
$sNRB=$selectedNamespaceRadioButton;
$referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
$referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
$referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
$ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;
$defaultFileReferenceType=`optionVar -q defaultFileReferenceType`;

optionVar -sv referenceOptionsRenamePrefix $renamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue $mergeOptionValue;
optionVar -sv defaultFileReferenceType "mayaBinary";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton=$mergeOptionValue;
CreateReference;

optionVar -sv referenceOptionsRenamePrefix $referenceOptionsRenamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO $referenceUseNamespacesDuringFileIO;
optionVar -iv referenceOptionsUseRenamePrefix $referenceOptionsUseRenamePrefix;
optionVar -sv ReferenceMergeOptionValue $ReferenceMergeOptionValue;
optionVar -sv defaultFileReferenceType $defaultFileReferenceType;
if ($sNRB!="")
	$selectedNamespaceRadioButton=$sNRB;

if ($model)
	$topNodesAfter=`ls -as`;
select -cl;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		select -add $topNodesAfter[$i];

if ($model)
	{
	//Hi layer
	if (`objExists Hi`)
		{
		if (`objectType Hi`=="displayLayer")
			editDisplayLayerMembers -noRecurse Hi `ls -selection`;
		}
	else
		{
		createDisplayLayer -name Hi -number 1 -nr;
		setAttr Hi.displayType 1;
		}
	}

if (!$model)
	{
	//refresh character-chooser-dropdowns
	$tempString=`lsUI -type optionMenu`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "asSelector*OptionMenu"` || `gmatch $tempString[$i] "asPicker*OptionMenu"`)
			asPopulateNameSpaceMenu `substitute "OptionMenu" $tempString[$i] ""`;
	}
select -cl;
}

global proc asReferenceEditor ()
{
if (`asHotKeyCheck ReferenceEditor`) return;

ReferenceEditor;
}

global proc asFBXMissingBlendShapeTargetsFix ()
{
//seems sometimes Maya skipps writing these lines, (when bs-target has no moving points)
//setAttr ".it[0].itg[12].iti[6000].ipt" -type "pointArray" 0 ;
//setAttr ".it[0].itg[12].iti[6000].ict" -type "componentList" ;
//(This is for target number 12)
//This causes the FBX exporter to skip these targets, and also skip any folloing targets
//This workaround will re-set the attributes
string $bss[]=`ls -type blendShape`;
for ($i=0;$i<size($bss);$i++)
	{
	$numTargets=`getAttr -s ($bss[$i]+".it[0].itg")`;
	for ($y=0;$y<$numTargets;$y++)
		{
		float $ipts[]=`getAttr ($bss[$i]+".it[0].itg["+$y+"].iti[6000].ipt")`;
		if (!size($ipts))
			{
			evalEcho ("setAttr "+$bss[$i]+".it[0].itg["+$y+"].iti[6000].ipt  -type \"pointArray\" 0;");
			evalEcho ("setAttr "+$bss[$i]+".it[0].itg["+$y+"].iti[6000].ict  -type \"componentList\";");
			}
		}
	}
}

global proc asReferenceGreenShaderFix ()
{
string $obj,$dotComp,$destination;
string $shadingEngines[]=`ls -type shadingEngine`;
string $tempString[],$sel[],$historyNodes[];
string $refNodes[]=`ls -type reference`;

for ($i=0;$i<size($refNodes);$i++)
	{
	file -cleanReference $refNodes[$i];
	}

for ($i=0;$i<size($shadingEngines);$i++)
	{
	select `sets -q $shadingEngines[$i]`;
	$sel=`ls -sl`;
	if (!size($sel))
		continue;
	for ($y=0;$y<size($sel);$y++)
		{
		$dotComp="";
		tokenize $sel[$y] "." $tempString;
		$obj=$tempString[0];
		if ($tempString[1]!="")
			$dotComp="."+$tempString[1];
		if (!`getAttr ($obj+".intermediateObject")`)
			continue;
		$historyNodes=`listHistory -f 1 -interestLevel 1 $sel[$y]`;
		for ($z=0;$z<size($historyNodes);$z++)
			if (`objectType $historyNodes[$z]`=="mesh")
				if (!`getAttr ($historyNodes[$z]+".intermediateObject")`)
					{
					$destination=$historyNodes[$z]+$dotComp;
					evalEcho ("sets -e -forceElement "+$shadingEngines[$i]+" "+$destination);
					}
		}
	}
}

global proc int asHotKeyCheck (string $command)
{
if (`getModifiers`!=5)
	return 0;

global string $gShelfTopLevel;
string $currentShelf = `tabLayout -query -selectTab $gShelfTopLevel`;
string $imageOverlayLabel,$ann;
string $image="commandButton.png";
string $tempString[];
tokenize $command $tempString;
$ann=$tempString[0];

if ($command=="asReferenceBrowser 0") {$imageOverlayLabel="ref";$image="menuIconFile.png";$ann="Reference-in a new rig";}
if ($command=="ReferenceEditor") {$imageOverlayLabel="edit";$image="menuIconFile.png";$ann="Open the Reference Editor";}
if ($command=="asExportFbxBrowser \"\"") {$imageOverlayLabel="fbx";$image="menuIconFile.png";$ann="Export selected rig as FBX";}
if ($command=="asPopulateNameSpaceMenu \"\"") error "Refreshing of GUI, can not be a shelf button";
if ($command=="asFilterNameSpaceMenuUI \"\"") error "Name-filtering of GUI, can not be a shelf button";
if ($command=="asSetupControlVisibilityHotKeyDialog") error "Set Hotkey, can not be a shelf button";
if ($command=="asControlsVisibilityToggle") {$imageOverlayLabel="";$image="curveCV.png";$ann="Toggles visibility of ControlCurves";}
if ($command=="asVisualizeGimbalLock \"\"") {$imageOverlayLabel="";$image="srt.png";$ann="Visualize GimbalLock for selected ControlCurves";}
if ($command=="asFaceCtrlsDetach \"\"") {$imageOverlayLabel="";$image="BasicHead.png";$ann="Detach face-controls, for faster playback";}
if ($command=="asCopyToClipBoard \"\" 0") {$imageOverlayLabel="Copy";$image="menuIconEdit.png";$ann="Copy Pose";}
if ($command=="asPasteFromClipBoard \"\" 0") {$imageOverlayLabel="Paste";$image="menuIconEdit.png";$ann="Paste Pose";}
if ($command=="asGoToBuildPose \"\"") {$imageOverlayLabel="";$image="addSkinInfluence.png";$ann="Resets the pose for selected rig";}
if ($command=="asDeleteStaticChannels \"\"") {$imageOverlayLabel="clean";$image="menuIconEdit.png";$ann="Deletes static channels for selected rig";}
if ($command=="asMirror \"\"") {$imageOverlayLabel="";$image="doubleHorizArrow.png";$ann="Mirror pose for selected rig";}
if ($command=="asMirrorOptions \"\"") {$imageOverlayLabel="o";$image="doubleHorizArrow.png";$ann="Mirror (options) pose for selected rig";}
if ($command=="asCopyToClipBoard \"\" 1") {$imageOverlayLabel="Copy";$image="render_tripleShadingSwitch.png";$ann="Copy Animation";}
if ($command=="asPasteFromClipBoard \"\" 1") {$imageOverlayLabel="Paste";$image="render_tripleShadingSwitch.png";$ann="Paste Animation";}
//if ($command=="asLoadAttrs \"\" 0") {$imageOverlayLabel="Paste";$image="menuIconEdit.png";
//	$ann="Paste Animation ( Hold SHIFT button for pasting at Current Time, Hold CTRL button to ignore Main ctrl )";}
if ($command=="asAnimBake \"\"") {$imageOverlayLabel="Bake";$image="menuIconEdit.png";$ann="Bake Animation";}
if ($command=="asAutoSwitchFKIK") {$imageOverlayLabel="Switch";$image="kinHandle.png";$ann="Switch between FK & IK";}
if ($command=="asAutoSwitchPivot") {$imageOverlayLabel="Pivot";$image="counterclockwise.png";$ann="Switch the position of the Pivot";}
if ($command=="asQuickIK") {$imageOverlayLabel="IK";$image="smoothSkin.png";$ann="Create a Quick-IK e.g. IK for fingers.";}
if ($command=="asTwistFlipUI \"\"") {$imageOverlayLabel="Flip";$image="srt.png";$ann="Set amount of twist before flipping (constraint-casching)";}
if ($command=="asMappingUI moCapMatcher \"\"") {$imageOverlayLabel="MoCap";$image="motionPath.png";$ann="Tool for attaching rig to a MotionCapture skeleton";}
if ($command=="asMoCapLibraryUI \"\"") {$imageOverlayLabel="Lib";$image="batchRender.png";$ann="MotionCapture library";}
if ($command=="asConnectARKitUI \"\"") {$imageOverlayLabel="AR";$image="yawPitch.png";$ann="Connect Face-Motion-Capture ( ARKit )";}
if ($command=="asConnectMocapX \"\"") {$imageOverlayLabel="X";$image="yawPitch.png";$ann="Connect Face-Motion-Capture ( MocapX )";}
if ($command=="asAutoLipSyncUI \"\"") {$imageOverlayLabel="Sync";$image="123d.png";$ann="Connect Face-Motion-Capture ( MocapX )";}
if ($command=="asDynAdd \"\"") {$imageOverlayLabel="Dyn";$image="hairDynamicCurves.png";$ann="Add dynamics to selected controller";}
if ($command=="asDynAddHairSystem \"\"") {$imageOverlayLabel="Dyn";$image="hairDynamicCurves.png";$ann="Add dynamics to selected controller";}
if ($command=="asDynRemove \"\"") {$imageOverlayLabel="Rem";$image="hairDynamicCurves.png";$ann="Remove dynamics to selected controller";}
if ($command=="asDynSetInitialState \"\"") {$imageOverlayLabel="Set";$image="interactivePlayback.png";$ann="Set Initial State for all dynamics";}
if ($command=="asDynSetInteractivePlayback \"\"") {$imageOverlayLabel="Play";$image="interactivePlayback.png";$ann="Allows interaction with objects during playback";}
if ($command=="asDynBake \"\"") {$imageOverlayLabel="Bake";$image="hairDynamicCurves.png";$ann="Bake all dynamics";}
if ($command=="asParentAdd \"\" 0") {$imageOverlayLabel="Parent";$image="parentConstraint.png";$ann="Add parent constraint";}
if ($command=="asParentAdd \"\" 1") {$imageOverlayLabel="Parent";$image="parentConstraint.png";$ann="Add parent constraint (Extra)";}

setParent $currentShelf;
shelfButton
	-command $command
	-annotation $ann
	-label $tempString[0]
	-imageOverlayLabel $imageOverlayLabel
	-image $image
	-image1 $image
	-sourceType "mel";

return 1;
}

global proc string asNameSpaceFromSelection ()
{
string $nameSpace;
string $sel[]=`ls -sl`;
string $tempString[];

for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*:*"`)
		continue;
	tokenize $sel[$i] ":" $tempString;
	if (!`objExists ($tempString[0]+":Group")`)
		continue;
	$nameSpace=$tempString[0]+":";
	}
return $nameSpace;
}

global proc string asNameSpaceFromUIName (string $uiName)
{
string $nameSpace;
if ($uiName=="")
	$nameSpace=`asNameSpaceFromSelection`;
else if (`optionMenu -q -ex ($uiName+"OptionMenu")`)
	{
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
	if ($nameSpace==":")
		$nameSpace="";
	}

return $nameSpace;
}

global proc string asNameSpaceFromShortUIName (string $shortUIName)
{
//e.g asKey "biped" vs asExportFbxBrowser "asSelectorbiped", some functions do not use the "asSelector" prefix
string $nameSpace;
if (`optionMenu -q -ex ("asSelector"+$shortUIName+"OptionMenu")`)
	{
	$nameSpace=`optionMenu -q -v ("asSelector"+$shortUIName+"OptionMenu")`;
	if ($nameSpace==":")
		$nameSpace="";
	}
else
	$nameSpace=$shortUIName;//this proc could be called from the standalone asAutoSwitchFKIK function, then $name is $nameSpace

return $nameSpace;
}

global proc string[] asNameControlSetsFromUiName (string $uiName)
{
int $selectedTabIndex;
string $sel[]=`ls -sl`;
string $controlSets[];
string $nameSpace=`asNameSpaceFromUIName $uiName`;
string $tempString[],$tabLabels[];
string $controlSetsText;

if ($uiName=="" && $sel[0]!="")
	{
	if (`objExists ($nameSpace+"ControlSet")`)
		if (`sets -im ($nameSpace+"ControlSet") $sel[0]`)
			$controlSets[0]=($nameSpace+"ControlSet");
	if (`objExists ($nameSpace+"FaceControlSet")`)
		if (`sets -im ($nameSpace+"FaceControlSet") $sel[0]`)
			$controlSets[0]=($nameSpace+"FaceControlSet");
	}
else if ($uiName=="bodySetup")
	$controlSets[0]="ControlSet";
else if ($uiName=="faceSetup")
	$controlSets[0]="FaceControlSet";
else if (`text -q -ex ($uiName+"ControlSetsText")`)//Selector
	{
	$controlSetsText=`text -q -l ($uiName+"ControlSetsText")`;
	tokenize $controlSetsText $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists ($nameSpace+$tempString[$i])`)
			$controlSets[size($controlSets)]=$nameSpace+$tempString[$i];
	}
else if ($uiName=="asPicker" && `tabLayout -q -ex asPickerTabLayout`)//Picker
	{
	$tabLabels=`tabLayout -q -tl asPickerTabLayout`;
	$selectedTabIndex=`tabLayout -q -selectTabIndex asPickerTabLayout`;
	if (`gmatch $tabLabels[$selectedTabIndex-1] "*face*"`)
		$controlSets[0]=$nameSpace+"FaceControlSet";
	else
		$controlSets[0]=$nameSpace+"ControlSet";
	}
else if ($uiName=="asPoserDefault" && `menuItem -q -ex asPoserControlSetsMenu`)//PoserDesigner
	{
	$tempString=`menu -q -ia asPoserControlSetsMenu`;
	for ($i=0;$i<size($tempString);$i++)
		if (`menuItem -q -cb $tempString[$i]`)
			$controlSets[size($controlSets)]=$nameSpace+`menuItem -q -l $tempString[$i]`;
	}
else if (`objExists ($nameSpace+"ControlSet")`)
	$controlSets[0]=$nameSpace+"ControlSet";

return $controlSets;
}

global proc asExportFbxBrowser (string $uiName)
{
global string $asFbxExportedFile;
int $withGUIOptions=1;
string $nameSpace,$deformationSystem,$exportFbxPre,$exportFbxPost,$file;
string $sel[]=`ls -sl`;
string $controlSets[],$tempString[];

if (`asHotKeyCheck "asExportFbxBrowser \"\""`) return;
$nameSpace=`asNameSpaceFromUIName $uiName`;
$controlSets=`asNameControlSetsFromUiName $uiName`;
if ($uiName=="" && $controlSets[0]=="" && `objExists ControlSet`)
	$controlSets[0]="ControlSet";
if (!size($controlSets))
	error "No controlSets detected. select a controller"; 

string $plugins[]=`pluginInfo -q -ls`;
for ($plug in $plugins)
	if (!`stringArrayCount "fbxmaya" $plugins`)
	error "You Must Load the \"fbxmaya\" plugin !";

$deformationSystem=$nameSpace+":DeformationSystem";
if (`objExists ($nameSpace+"|root")`) //Unreal Skeleton
	$deformationSystem=$nameSpace+"|root";
if (`objExists ($nameSpace+"|GameSkeletonRoot_M")`) //Custom oriented GameSkeletonRoot
	$deformationSystem=$nameSpace+"|GameSkeletonRoot_M";

if (`objExists |Geometry`)
	select $deformationSystem |Geometry;
else
	{
	select $deformationSystem ($nameSpace+":Geometry");
	refresh;
	}

//custom code can be added
$asFbxExportedFile="";
if (`attributeExists exportFbxPre fbxExportOptions`) $exportFbxPre=`getAttr fbxExportOptions.exportFbxPre`;
if (`attributeExists exportFbxPost fbxExportOptions`) $exportFbxPost=`getAttr fbxExportOptions.exportFbxPost`;
if ($exportFbxPre!="") evalEcho ($exportFbxPre);

if (`objExists asMannequinExporting`) //no GUIOptions for Mannequin Export 
	$withGUIOptions=0;

if ($withGUIOptions)
	{
	optionVar -sv "defaultFileExportActiveType" "FBX export";
	ExportSelection;
	}
else
	{
	//FBXProperties;
	FBXProperty Export|IncludeGrp|Animation -v 1;
	FBXProperty Export|IncludeGrp|Animation|BakeComplexAnimation -v 1;
	if (`objExists |Geometry`)
		{
		FBXProperty Export|IncludeGrp|Animation -v 0;
		FBXProperty Export|IncludeGrp|Animation|BakeComplexAnimation -v 0;
		}
	FBXProperty Export|IncludeGrp|Audio -v 0;
	FBXProperty Export|IncludeGrp|InputConnectionsGrp|IncludeChildren -v 1;
	FBXProperty Export|IncludeGrp|InputConnectionsGrp|InputConnections -v 0;
	$tempString=`fileDialog2 -fileFilter "*.fbx" -dialogStyle 2`;
	$file=$tempString[0];
	$asFbxExportedFile=$file;
	if ($file!="")
		FBXExport -f $file -s;
	}

if ($exportFbxPost!="") evalEcho ($exportFbxPost);
print "// Fbx exported.\n";
}

global proc asDecomposeOPM ()
{
float $m[];
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[];

createNode -n tempMatrixTransform transform;
$m=`xform -q -os -m tempMatrixTransform`;
delete tempMatrixTransform;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	createNode -n ($deformJointsList[$i]+"DM") decomposeMatrix;
	setAttr ($deformJointsList[$i]+"DM.inputRotateOrder") `getAttr ($deformJointsList[$i]+".ro")`;
	connectAttr ($deformJointsList[$i]+"DM.outputTranslate") ($deformJointsList[$i]+".t");
	connectAttr ($deformJointsList[$i]+"DM.outputRotate") ($deformJointsList[$i]+".r");
	connectAttr ($deformJointsList[$i]+"DM.outputScale") ($deformJointsList[$i]+".s");
	connectAttr ($deformJointsList[$i]+"DM.outputShear") ($deformJointsList[$i]+".shear");

	$tempString=`listConnections -s 1 -d 0 -p 1 ($deformJointsList[$i]+".offsetParentMatrix")`;
	disconnectAttr $tempString[0] ($deformJointsList[$i]+".offsetParentMatrix");
	setAttr ($deformJointsList[$i]+".offsetParentMatrix") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
	connectAttr $tempString[0] ($deformJointsList[$i]+"DM.inputMatrix");
	}
}

global proc string asCRInjectLine (string $ctrl,string $parent,string $joint,string $type,string $typeEls,string $gizmo)
{
int $colorIndex,$ws;
float $diameter;
float $rbg[],$offT[],$offR[];
string $injectLine;
string $tempString[];

if ($ctrl=="Main" || $ctrl=="RootX_M" || `gmatch $ctrl "IK*"` || `gmatch $ctrl "Pole*"` || `gmatch $ctrl "ctrl*"`)//
	$ws=1;
$diameter=`asControlDiameter $ctrl`;
if ($type=="OnFace")
	$diameter*=10;
//$offT=`asControlOffT $ctrl $ws`;
$offT=`asControlOffset $ctrl`;
$tempString=`listRelatives -s $ctrl`;
$rbg={1,0,0};
$colorIndex=`getAttr ($tempString[0]+".overrideColor")`;
//if ($type=="ctrlBox")
if (`gmatch $ctrl "ctrl*"`)
	$colorIndex=17;
if ($colorIndex>0 && $colorIndex<32)
	$rbg=`colorIndex -q $colorIndex`;

if ($typeEls=="") $typeEls="{}";
$injectLine+="	asAddCtrl ('"+$ctrl+"','"+$parent+"','"+$joint+"','"+$type+"',"
						+$typeEls+",'"
						+$gizmo+"',"+$ws+","+$diameter+","+"["+$offT[0]+", "+$offT[1]+", "+$offT[2]+"],"
						+"["+$rbg[0]+", "+$rbg[1]+", "+$rbg[2]+", 1.0])\n";

return $injectLine;
}

global proc asExportControlRig ()
{
global string $ueVersion;
int $fileId,$fileId2,$copyLines,$ikNum,$skipFaceSetup,$numAttrCtrls;
int $numCtrls=2;
float $pmax,$value,$driverValue;
float $pos[],$jos[],$pa[],$sa[],$pp[],$keyXValues[];
string $fDet,$nextLine,$injectLines,$ctrl,$parent,$joint,$name,$side,$pyFile,$startJoint,$middleJoint,$endJoint,$poleVector,$parentInIk,$file;
string $parentJoint,$fitJoint,$fitJointParent,$arrayInfo,$fitJointTwistJoints,$fitJointInbetweenJoints,$restoreCmd,$type,$gizmo,$parentConstraint;
string $as2crFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/as2cr/4x.py";
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$IKJoints[],$jointsInIk[],$jointsInIk2[],$iks[],$parents[];
string $ikStartJoints[],$ikEndJoints[],$ikArrayInfo[],$deformJoints[],$userAttrs[],$attrs[],$animCurves[],$tongueCtrls[],$eyeCtrls[];
string $controlSetMembers[],$faceControlSetMembers[];
if (`objExists FaceControlSet`)
	$faceControlSetMembers=`sets -q FaceControlSet`;
else
	$skipFaceSetup=1;

if (`objExists "|root"` || `objExists "UnrealRoot"`)
	error "Unreal Joints found. Export ControlRig does not work with these joints. Only with standard AdvancedSkeleton joints.";

if (!`objExists ControlSet`)
	error "ControlSet not found, no valid AdvancedSkeleoton tig in this scene.";
$controlSetMembers=`sets -q ControlSet`;

if (!`objExists ctrlBox`)
	$skipFaceSetup=1;
if (`objExists ctrlBox` && !`objExists asFaceBS`)
	{
	if (`confirmDialog -t "Confirm"
	-m ("FaceSetup detected,\n"
		+"but it is not \"BlendShape FaceSetup\"\n\n"
		+"Only \"BlendShape FaceSetup\" can be exported.\n"
		+"To export FaceSetup for this rig,\n"
		+"you must first go to the Face>BlendShapes section, and run \"convert\".\n\n"
		+"Or, Click OK to export BodySetup only")
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	$skipFaceSetup=1;
	}
if (`objExists ctrlBox` && `objExists asFaceBS` && `objExists EyeBrowInner_R`)
	{//Mixed uses Layered-deformation, ot compatible with Unreal
	if (`confirmDialog -t "Confirm"
	-m ("\"Mixed\" type FaceSetup detected,\n\n"
		+"Only \"BlendShapes\" type FaceSetup can be exported.\n"
		+"Click OK to export BodySetup only")
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	$skipFaceSetup=1;
	}

//EarlyAccess2 : Version: 5.0.0-16682836+++UE5+Release-5.0-EarlyAccess
//Preview2 : Version: 5.0.0-19206456+++UE5+Release-5.0
if (`objExists boxManTest`)
	{
	$pyFile="C:/temp/FBX/boxMan.py";
	$ueVersion="5.1";
	}
if (!`objExists boxManTest`)
	if (`layoutDialog -t "version" -ui asECRLayout`!="OK")
		return;
$fileName=`substituteAllString $ueVersion " " ""`;
$fileName=`substituteAllString $fileName "[.]" ""`;
$file=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/as2cr/"+$fileName+".py";
if (!`file -q -ex $file`)
	error ("Template file not found:"+$file);
$as2crFile=$file;

if (!`objExists boxManTest`)
	{
	$tempString=`fileDialog2 -fileFilter "*.py" -dialogStyle 2`;
	$pyFile=$tempString[0];
	}
if ($pyFile=="")
	return;

$injectLines+=`asCRInjectLine "Main" "MainSystem" "DeformationSystem" "Main" "" "Circle_Thick"`;
$injectLines+=`asCRInjectLine "RootX_M" "Main" "Root_M" "FK" "" "Arrow4_Thin"`;

//IK
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`gmatch $controlSetMembers[$i] "FKIK*"`)
		continue;
	if (!`attributeExists FKIKBlend $controlSetMembers[$i]`)
		continue;
	if (`getAttr ($controlSetMembers[$i]+".FKIKBlend")`<10)
		continue;
	$ctrl=`substitute "FKIK" $controlSetMembers[$i] "IK"`;
	if (!`objExists $ctrl`)
		continue;
	$iks[$ikNum]=$ctrl;
	tokenize $controlSetMembers[$i] "_" $tempString;
	$side="_"+$tempString[size($tempString)-1];
	$startJoint=`getAttr ($controlSetMembers[$i]+".startJoint")`+$side;
	$middleJoint=`getAttr ($controlSetMembers[$i]+".middleJoint")`+$side;
	$endJoint=`getAttr ($controlSetMembers[$i]+".endJoint")`+$side;
	$joint=$endJoint;
	$IKJoints=`asGetIKJoints $startJoint $endJoint`;
	$ikStartJoints[$ikNum]=$startJoint;
	$ikEndJoints[$ikNum]=$endJoint;
	for ($y=0;$y<size($IKJoints);$y++)
		{
		$jointsInIk[size($jointsInIk)]=$IKJoints[$y];
		$jointsInIk2[size($jointsInIk2)]=$ctrl;
		}
	//pri axis
	$pa={1,0,0};
	$pos=`getAttr ($middleJoint+".t")`;
	$pMax=abs($pos[0]);
	if (abs($pos[1])>$pMax) {$pa={0,1,0};$pMax=abs($pos[1]);}
	if (abs($pos[2])>$pMax) {$pa={0,0,1};$pMax=abs($pos[2]);}
	if (($pos[0]+$pos[1]+$pos[2])<0) {$pa[0]*=-1;$pa[1]*=-1;$pa[2]*=-1;}
	//sec axis
	$sa={0,1,0};
	$jos=`getAttr ($middleJoint+".jo")`;
	$pMax=abs($jos[1]);
	//sec axis appear to be Not bendAxis, but other other one, so swapping these
	if (abs($jos[1])>$pMax) {$sa={0,0,1};$pMax=abs($jos[1]);}
	if (abs($jos[2])>$pMax) {$sa={0,1,0};$pMax=abs($jos[2]);}
	//flipping based on pri && sec axis
	if (($pos[0]+$pos[1]+$pos[2])<0) {$sa[0]*=-1;$sa[1]*=-1;$sa[2]*=-1;}
	if (($jos[0]+$jos[1]+$jos[2])<0) {$sa[0]*=-1;$sa[1]*=-1;$sa[2]*=-1;}
	//$pp polePos
	$poleVector=`substitute "FKIK" $controlSetMembers[$i] "Pole"`;
	$pp={0,0,0};
	if (`objExists $poleVector`) {$pos=`xform -q -ws -t $poleVector`;$pp={$pos[0],$pos[1],$pos[2]};}

	$ikArrayInfo[$ikNum]="{'startJoint':'"+$startJoint+"','middleJoint':'"+$middleJoint+"','endJoint':'"+$endJoint+"',"
		+"'paX':'"+$pa[0]+"','paY':'"+$pa[1]+"','paZ':'"+$pa[2]+"',"
		+"'saX':'"+$sa[0]+"','saY':'"+$sa[1]+"','saZ':'"+$sa[2]+"',"
		+"'ppX':'"+$pp[0]+"','ppY':'"+$pp[1]+"','ppZ':'"+$pp[2]+"'}";

	$ikNum++;
	}

//FK
//temporarily reParenting, to get complete Spine first in $deformJoints list
$tempString=`listRelatives -type joint Root_M`;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*_M"`)
		{
		parent -w $tempString[$i];
		$restoreCmd+="parent "+$tempString[$i]+" Root_M;";
		}

$tempString2=`listRelatives -type joint -ad DeformationSystem`;
if ($restoreCmd!="") eval $restoreCmd;
$restoreCmd="";
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*_M"`)
		{
		parent -w $tempString[$i];
		$restoreCmd+="parent "+$tempString[$i]+" Root_M;";
		}
$tempString3=`listRelatives -type joint -ad DeformationSystem`;
if ($restoreCmd!="") eval $restoreCmd;
$tempString3=`stringArrayRemove {"Root_M"} $tempString3`;
$deformJoints=`stringArrayCatenate $tempString3 $tempString2`;

for ($y=size($deformJoints)-1;$y>-1;$y--)
	{
	$joint=$deformJoints[$y];
	$ctrl="FK"+$joint;
	if (!`objExists $ctrl`)
		continue;
	if (!`sets -im ControlSet $ctrl`)
		continue;

	tokenize $deformJoints[$y] "_" $tempString;
	$fitJoint=$tempString[0];
	if (!`objExists $fitJoint`)
		{
		warning ("FitJoint: \""+$fitJoint+"\" is missing, unable to scan this for FitAttributes & Ik-Labels.");
		continue;
		}
	$side="_"+$tempString[1];
	$tempString=`listRelatives -p -type joint $fitJoint`;
	$fitJointParent=$tempString[0];

	for ($a=0;$a<size($ikStartJoints);$a++)
		if ($joint==$ikStartJoints[$a])
			{
			//IK
			$ikNum=$a;
			$ctrl=$iks[$ikNum];
			$injectLines+=`asCRInjectLine $ctrl "Main" $ikEndJoints[$ikNum] "IK" $ikArrayInfo[$ikNum] "Box_Thick"`;
			$numCtrls++;
			continue;
			}
	if (`stringArrayCount $joint $jointsInIk`)
		continue;

	$parentJoint="";
	$tempString2=`listRelatives -f -p $joint`;
	tokenize $tempString2[0] "|" $parents;
	for ($z=size($parents)-1;$z>-1;$z--)
		{
		if (`gmatch $parents[$z] "*Part[0-9]*"`)
			continue;
		if (`attributeExists visibility ("FK"+$parents[$z]+"Shape")`)
			if (`getAttr ("FK"+$parents[$z]+"Shape.v")`==0)//noControl
				continue;
		$parentJoint=$parents[$z];
		break;
		}
	$parent="RootX_M";
	$parentInIk="";
	for ($a=0;$a<size($ikEndJoints);$a++)
		if ($parentJoint==$ikEndJoints[$a])
			{
			$parentInIk=$iks[$a];
			$parent=$parentInIk;//IK
			break;
			}
	if ($parentInIk=="")//FK
		{
		if (`objExists ("FK"+$parentJoint)`)
			$parent="FK"+$parentJoint;
		//special case if parent is Root, and has InbetweenJoints
		if ($parent=="FKRoot_M" && `attributeExists inbetweenJoints $fitJointParent`)
			$parent="RootX_M";
		}

	//FitAttributes
	$arrayInfo="{";
	clear $userAttrs;
	if (`objExists $fitJoint`)
 		$userAttrs=`listAttr -ud -s $fitJoint`;
	for ($i=0;$i<size($userAttrs);$i++)
		{
		if (`gmatch $userAttrs[$i] "fat*"`)
			continue;
		if ($userAttrs[$i]=="twistJoints")
			if (`getAttr ($fitJoint+".twistJoints")`==0)
				continue;//LogPython: Error: ZeroDivisionError: float division by zero	
		if ($arrayInfo!="{")
			$arrayInfo+=",";
		$value=`getAttr ($fitJoint+"."+$userAttrs[$i])`;
		//if Global Attribute exist on FK-control, then use that value.
		if ($userAttrs[$i]=="global")
			if (`attributeExists "Global" ("FK"+$joint)`)
				$value=`getAttr ("FK"+$joint+".Global")`;
		$arrayInfo+="'"+$userAttrs[$i]+"':'"+$value+"'";
		}
	$arrayInfo+="}";

	$injectLines+=`asCRInjectLine $ctrl $parent $joint "FK" $arrayInfo "Circle_Thick"`;
	$numCtrls++;
	}

//DrivingSystems
for ($i=0;$i<size($controlSetMembers);$i++)
	{
//	$tempString=`listRelatives -p $controlSetMembers[$i]`;
	$tempString=`ls -l $controlSetMembers[$i]`;
	if (!`gmatch $tempString[0] "*|DrivingSystem|*"`)
		continue;
	$ctrl=$controlSetMembers[$i];
	$parentConstraint=$ctrl+"_parentConstraint1";
	if (!`objExists $parentConstraint`)
		continue;
	$tempString=`listConnections -s 1 -d 0 ($parentConstraint+".target[0].targetTranslate")`;
	$joint=$tempString[0];

	$arrayInfo=`asDSArrayInfo $ctrl`;
	$numAttrCtrls=$numAttrCtrls+size(`asDsGetAttrs $ctrl`);

	$injectLines+=`asCRInjectLine $ctrl "Main" $joint "DrivingSystem" $arrayInfo "Circle_Thick"`;
	$numCtrls++;
	}
$arrayInfo="";

//FaceSetup
if (!$skipFaceSetup)
	{
	//sort Tongue ctrls
	for ($i=0;$i<99;$i++)
		if (`objExists ("Tongue"+$i+"_M")`)
			$tongueCtrls[$i]="Tongue"+$i+"_M";
	$faceControlSetMembers=`stringArrayRemove $tongueCtrls $faceControlSetMembers`;
	$faceControlSetMembers=`stringArrayCatenate $faceControlSetMembers $tongueCtrls`;
	//sort order of Eye>Iris>Pupil
	$eyeCtrls={"Eye_R","Eye_L","Iris_R","Iris_L","Pupil_R","Pupil_L"};
	$faceControlSetMembers=`stringArrayRemove $eyeCtrls $faceControlSetMembers`;
	for ($i=0;$i<size($eyeCtrls);$i++)
		if (`objExists $eyeCtrls[$i]`)
			$faceControlSetMembers[size($faceControlSetMembers)]=$eyeCtrls[$i];


	if (`getAttr ctrlBox.EyeCtrlVis`==0)
	setAttr ctrlBox.EyeCtrlVis 1;//need eyeCtrls visible to ensure they export
	$restoreCmd="setAttr ctrlBox.EyeCtrlVis 0;";

	for ($i=0;$i<size($faceControlSetMembers);$i++)
		{
		$ctrl=$faceControlSetMembers[$i];
		tokenize $ctrl "_" $tempString;
		$name=$tempString[0];
		$side="_"+$tempString[1];
		$joint=$name+"Joint"+$side;
		$parent="FKHead_M";
		if (!`objExists $joint`)
			continue;
		$tempString=`ls -l $joint`;
		tokenize $tempString[0] "|" $tempString;
		if (!`stringArrayCount "DeformationSystem" $tempString`)
			continue;
		$tempString=`listRelatives -s $ctrl`;
		if (!`getAttr ($tempString[0]+".overrideVisibility")`)
			continue;
		$gizmo="Gizmo";
		$type="OnFace";
		if (`gmatch $ctrl "Tongue*"` || $ctrl=="Jaw_M" || `gmatch $ctrl "Eye_*"` || `gmatch $ctrl "Iris_*"` || `gmatch $ctrl "Pupil_*"`)
			{
			$gizmo="Circle_Thick";
			$type="FK";
			$tempString=`listRelatives -p $joint`;
			$parentJoint=`substitute "Joint" $tempString[0] ""`;
			if (`objExists $parentJoint`)
				$parent=$parentJoint;
			}
		$injectLines+=`asCRInjectLine $ctrl $parent $joint $type $arrayInfo $gizmo`;
		$numCtrls++;
		}
	if (`objExists ctrlBox`)
		{
//		$arrayInfo="{'ctrlBoxSize':'"+`getAttr ctrlBoxBrow_R.sx`+"'}";
		$arrayInfo="{'ctrlBoxSize':'"+(`getAttr ctrlBoxShape.boundingBoxMaxX`/3.0)+"'}";
		$injectLines+=`asCRInjectLine ctrlBox "FKHead_M" "Head_M" "ctrlBox" $arrayInfo "Square_Thick"`;
		$arrayInfo="";
		$tempString=`listRelatives -c -type transform ctrlBox`;
		for ($i=0;$i<size($tempString);$i++)
			{
			$tempString2=`listRelatives -c -type transform $tempString[$i]`;
			$ctrl=$tempString2[0];
			if ($ctrl=="")
				continue;//allowing for deleted controller
			$attrs=`asDsGetAttrs $ctrl`;
/*
			$arrayInfo="{";
			for ($y=0;$y<size($attrs);$y++)
				{
				$arrayInfo+="'"+$attrs[$y]+"':{";
				$animCurves=`listConnections -s 0 -d 1 ($ctrl+"."+$attrs[$y])`;
				for ($z=0;$z<size($animCurves);$z++)
					{
					$tempString2=`listConnections -s 0 -d 1 -scn 1 ($animCurves[$z]+".output")`;
					$tempString3=`listConnections -s 0 -d 1 -scn 1 -p 1 ($animCurves[$z]+".output")`;
					if ($tempString2[0]=="")
						continue;
					if (`objectType $tempString2[0]`!="blendShape")
						continue;
					if (!`gmatch $tempString3[0] "asFaceBS[.]*"`)
						continue;//skipping BS nodes that are not "asFaceBS", e.g. "asFaceBS_model_eyeBrowR", since Unreal have these `combined`
					$keyXValues=`keyframe -in 0 -q -fc $animCurves[$z]`;
					$driverValue=$keyXValues[0];
					if ($driverValue!=-1) $driverValue=1;
					tokenize $tempString3[0] "." $tempString4;
					$arrayInfo+="'"+$tempString4[1]+"':'"+$driverValue+"',";
					}
				$arrayInfo=`asUnCommaCloseBracket $arrayInfo`+",";
				}
			$arrayInfo=`asUnCommaCloseBracket $arrayInfo`;
*/
			$arrayInfo=`asDSArrayInfo $ctrl`;
			$numAttrCtrls=$numAttrCtrls+size(`asDsGetAttrs $ctrl`);
			$injectLines+=`asCRInjectLine $ctrl "ctrlBox" "ctrlBox" "ctrlBox" $arrayInfo "Gizmo"`; 
			$numCtrls++;
			}
		}
	if ($restoreCmd!="") eval $restoreCmd;
	}


$fileId2=`fopen $as2crFile "r"`;
$nextLine="The next line";
$copyLines=1;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	if ($nextLine=="# exported using AdvancedSkeleton version:x.xx\n")
		$nextLine="# exported using AdvancedSkeleton version:"+`asGetScriptVersion`+"\n";
	if ($nextLine=="asExportVersion = x.xx\n")
		$nextLine="asExportVersion = "+`asGetScriptVersion`+"\n";

	if ($nextLine=="asExportTemplate = '4x'\n")
		$nextLine="asExportTemplate = '"+$fileName+"'\n";

	if ($nextLine=="	#//-- ASControllers Starts Here --//\n")
		{
		$copyLines=0;
		$fDet+=$nextLine;
		$fDet+=$injectLines;
		}
	if ($nextLine=="	#//-- ASControllers Ends Here --//\n")
		$copyLines=1;
	if ($copyLines)
		$fDet+=$nextLine;
	}
fclose $fileId2;

$fileId=`fopen $pyFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
select -cl;
print ("// ControlRig python script exported ("+$numCtrls+" Controllers, and "+$numAttrCtrls+" AttributeSliders) (Unreal "+$fileName+".py template).\n");
}

global proc asECRLayout ()
{
global string $ueVersion;
$ueVersion="5.1";
string $as2crDir=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/as2cr";
string $fileList[]=`getFileList -fld ($as2crDir+"/") -fs "*.py"`;
$fileList=`sort $fileList`;

columnLayout;
	text -l "Unreal Engine version you wish to export to:";
	separator -st none -h 10;
	optionMenu -cc "$ueVersion=\"#1\"" unrealControlRigVersionOptionMenu;
	for ($i=0;$i<size($fileList);$i++)
		menuItem -l `substitute "[.]py" $fileList[$i] ""`;
	separator -st none -h 25;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
optionMenu -e -sl 3 unrealControlRigVersionOptionMenu;
}

global proc asUMJLayout ()
{
global string $unrealMannequinJoints;
$unrealMannequinJoints="Manny (UE5)";
global int $unrealMannequinScale;
$unrealMannequinScale=1;
columnLayout;
	text -l "Unreal Mannequin you wish to use:";
	separator -st none -h 10;
	optionMenu -cc "$unrealMannequinJoints=\"#1\"" unrealMannequinJointsOptionMenu;
		menuItem -l "Mannequin (UE4)";
		menuItem -l "Manny (UE5)";
		menuItem -l "Quinn (UE5)";
	separator -st none -h 10;
	checkBox -v 1 -l "scale to match mannequin" -cc "$unrealMannequinScale=\"#1\"" unrealMannequinScaleCheckBox;
	separator -st none -h 25;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
optionMenu -e -v $unrealMannequinJoints unrealMannequinJointsOptionMenu;
checkBox -e -v $unrealMannequinScale unrealMannequinScaleCheckBox;
}

global proc asExportRenameToUnreal ()
{
int $spineNr,$numChar;
string $side,$parent,$aboveTwistParent,$nextSegJoint,$lastTwoChar,$aa,$bb;
string $as[]={"Root_M","Hip_R","Knee_R","Ankle_R","Toes_R","Scapula_R","Shoulder_R","Elbow_R","Wrist_R","Neck_M","Head_M"};
string $bs[]={"pelvis","thigh_r","calf_r","foot_r","ball_r","clavicle_r","upperarm_r","lowerarm_r","hand_r","neck_01","head"};
string $aFingers[]={"Index","Middle","Ring","Pinky","Thumb"};
string $bFingers[]={"index","middle","ring","pinky","thumb"};
string $twistLimbs[]={"thigh","calf","upperarm","lowerarm"};
string $tempString[];

//error checks
if (!`objExists |Group`)
	error ("Top node \"Group\" not found, No valid AdvancedSkeleton rig in the scene");
if (`objExists |root`)
	error ("|root already exists, already using Unreal Names");
for ($i=0;$i<size($bs);$i++)
	if (`objExists $bs[$i]`)
		{
		select $bs[$i];
		error ("Selected object is named:\""+$bs[$i]+"\", which is a name required bu UnrealJoints, rename this object to use another name.");
		}

//Part joints
for ($i=1;$i<10;$i++)
	{
	$as[size($as)]="HipPart"+$i+"_R";
	$bs[size($bs)]="thigh_twist_"+`asDoPadd $i 2`+"_r";
	$as[size($as)]="KneePart"+$i+"_R";
	$bs[size($bs)]="calf_twist_"+`asDoPadd $i 2`+"_r";
	$as[size($as)]="ShoulderPart"+$i+"_R";
	$bs[size($bs)]="upperarm_twist_"+`asDoPadd $i 2`+"_r";
	$as[size($as)]="ElbowPart"+$i+"_R";
	$bs[size($bs)]="lowerarm_twist_"+`asDoPadd $i 2`+"_r";

	$as[size($as)]="NeckPart"+$i+"_M";
	$bs[size($bs)]="neck_"+`asDoPadd ($i+1) 2`;
	}

//Fingers
for ($i=1;$i<4;$i++)
	for ($y=0;$y<size($aFingers);$y++)
		{
		$as[size($as)]=$aFingers[$y]+"Finger"+$i+"_R";
		$bs[size($bs)]=$bFingers[$y]+"_"+`asDoPadd $i 2`+"_r";
		}
//MetaCarpal
for ($y=0;$y<size($aFingers);$y++)
	{
	$as[size($as)]=$aFingers[$y]+"Finger0_R";
	$bs[size($bs)]=$bFingers[$y]+"_metacarpal_r";
	}

//add Left
for ($i=0;$i<size($as);$i++)
	if (`gmatch $as[$i] "*_R"`)
		{
		$as[size($as)]=`substitute "_R" $as[$i] "_L"`;
		$bs[size($bs)]=`substitute "_r" $bs[$i] "_l"`;
		}

if (!`objExists root`)
	{
	asCreateGameEngineRootMotion;
	setAttr root.jointOrientX -90;
	addAttr -k 0 -ln noRootMotionJointBeforeRename -at bool -dv 1 root;
	}
parent -w root;

//Spine
$tempString=`ls -l Chest_M`;
tokenize $tempString[0] "|" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	if ($tempString[$y]=="Root_M")
		{
		$spineNr=1;
		continue;
		}
	if ($spineNr==0)
		continue;
	if (!`attributeExists asName $tempString[$y]`)
		addAttr -ln asName -dt "string" $tempString[$y];
	setAttr -type "string" ($tempString[$y]+".asName") $tempString[$y];
	rename $tempString[$y] ("spine_"+`asDoPadd $spineNr 2`);
	$spineNr++;
	}

//rename known (from mannequinn) named joints
for ($i=0;$i<size($as);$i++)
	{
	if (!`objExists $as[$i]`)
		continue;
	if (!`attributeExists asName $as[$i]`)
		addAttr -ln asName -dt "string" $as[$i];
	setAttr -type "string" ($as[$i]+".asName") $as[$i];
	rename $as[$i] $bs[$i];
	}

//rename un-known (Not from mannequinn) named joints (just side-suffix rename)
$tempString=`listRelatives -ad -type joint root`;
for ($i=0;$i<size($tempString);$i++)
	{
	$aa=$tempString[$i];
	$bb="";
	$numChar=size($tempString[$i]);
	$lastTwoChar=`substring $tempString[$i] ($numChar-1) $numChar`;
	if ($lastTwoChar=="_R") $bb=`substring $tempString[$i] 1 ($numChar-2)`+"_r";
	if ($lastTwoChar=="_L") $bb=`substring $tempString[$i] 1 ($numChar-2)`+"_l";
	if ($lastTwoChar=="_M") $bb=`substring $tempString[$i] 1 ($numChar-2)`+"";
	if ($bb=="")
		continue;
	if (!`attributeExists asName $aa`)
		addAttr -ln asName -dt "string" $aa;
	setAttr -type "string" ($aa+".asName") $aa;
	rename $aa $bb;
	}

//change twist-joints-hierarchy
for ($y=0;$y<size($twistLimbs);$y++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1)  $side="_r";
		if ($b==-1) $side="_l";

		for ($i=1;$i<10;$i++)
			{
			$twistJoint=$twistLimbs[$y]+"_twist_"+`asDoPadd $i 2`+$side;
			if (!`objExists $twistJoint`)
				continue;
			$tempString=`listRelatives -p $twistJoint`;
			$parent=$tempString[0];
			if ($i==1)
				$aboveTwistParent=$parent;

			if ($i>1)
				{
				if (!`attributeExists asParent $twistJoint`)
					addAttr -ln asParent -dt "string" $twistJoint;
				setAttr -type "string" ($twistJoint+".asParent") $parent;
				parent $twistJoint $aboveTwistParent;
				}

			$tempString=`listRelatives -c -type joint $twistJoint`;
			if (!`gmatch $tempString[0] "*_twist_*"`)//next segment start
				{
				$nextSegJoint=$tempString[0];
				if (!`attributeExists asParent $nextSegJoint`)
					addAttr -ln asParent -dt "string" $nextSegJoint;
				setAttr -type "string" ($nextSegJoint+".asParent") $twistJoint;
				parent $nextSegJoint $aboveTwistParent;
				}
			}
		}
	}

parent -w Geometry;
select root Geometry;
print "// Renamed to Unreal names.\n";
}

global proc asExportRenameRestore ()
{
string $asName,$asParent;
string $tempString[];

//error checks
if (!`objExists |Group`)
	error ("Top node \"Group\" not found, No valid AdvancedSkeleton rig in the scene");
if (!`objExists |root`)
	error ("|root does not exist, not currently using Unreal Names");

parent root DeformationSystem;
if (`attributeExists noRootMotionJointBeforeRename root`)
	asDeleteGameEngineRootMotion;

$tempString=`listRelatives -ad -type joint -f DeformationSystem`;
//reParent
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`attributeExists asParent $tempString[$i]`)
		continue;
	$asParent=`getAttr ($tempString[$i]+".asParent")`;
	parent $tempString[$i] $asParent;
	}
//reName
$tempString=`listRelatives -ad -type joint -f DeformationSystem`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`attributeExists asName $tempString[$i]`)
		continue;
	$asName=`getAttr ($tempString[$i]+".asName")`;
	rename $tempString[$i] $asName;
	}

parent Geometry Group;

select -cl;
print "// Renamed back to AdvancedSkeleton names.\n";
}

global proc string asDSArrayInfo (string $ctrl)
{
int $numKeys;
float $value,$arKitEyeLookPreSDKMult;
float $keyXValues[],$keyYValues[],$limits[];
string $arrayInfo,$driverValue;
string $attrs[],$animCurves[],$bsAnimCurves[],$tempString[],$tempString2[],$tempString3[],$tempString4[];

$attrs=`asDsGetAttrs $ctrl`;
$arrayInfo="{";
for ($y=0;$y<size($attrs);$y++)
	{
	if (!`getAttr -se ($ctrl+"."+$attrs[$y])`)
		continue;//skip ctrlMouthCorner_L.txPos_tyPos
	$arrayInfo+="'"+$attrs[$y]+"':{";
	$animCurves=`asDsGetAnimCurves $ctrl $attrs[$y]`;
	//special case ARKit Drive EyeJoint
	$arKitEyeLookPreSDKMult=0;
	if ($ctrl=="ctrlARKit_M" && `gmatch $attrs[$y] "eyeLook*"`)
		{
		$keyYValues=`keyframe -in 1 -q -vc $animCurves[0]`;
		if ($keyYValues[0]==-1) $arKitEyeLookPreSDKMult=-1;
		$tempString=`listConnections -s 0 -d 1 -type blendWeighted ($animCurves[0]+".output")`;
		$animCurves=`listConnections -s 0 -d 1 -type animCurve ($tempString[0]+".output")`;
		}
	$animCurves=`sort $animCurves`;
	for ($z=0;$z<size($animCurves);$z++)
		{
		$tempString2=`listConnections -s 0 -d 1 -scn 1 ($animCurves[$z]+".output")`;
		if (!`attributeExists "output" $tempString2[0]`) continue;
		$tempString3=`listConnections -s 0 -d 1 -scn 1 -p 1 ($tempString2[0]+".output")`;
		$tempString4=`listConnections -s 0 -d 1 -scn 1 -p 0 ($tempString2[0]+".output")`;
		if ($tempString3[0]=="") continue;
		if (`objectType $tempString3[0]`!="transform")
			continue;
		$tempString3[0]=`substitute "SDK" $tempString3[0] ""`;
		$arrayInfo+="'"+$tempString3[0]+"':";
		$numKeys=`keyframe -q -keyframeCount $animCurves[$z]`;
		$value=0;
		for ($x=0;$x<$numKeys;$x++)
			{
			$keyXValues=`keyframe -in $x -q -fc $animCurves[$z]`;
			$keyYValues=`keyframe -in $x -q -vc $animCurves[$z]`;
			$keyXValues[0]=`asRoundOff $keyXValues[0] 3`;
			$keyYValues[0]=`asRoundOff $keyYValues[0] 3`;
//				$arrayInfo+="'"+$keyXValues[0]+"':'"+$keyYValues[0]+"',";
			// simplifying curves to plain multipliers, as we can not script AnimEvalRichCurve keys
			//use first positive time-value key, to calculate multiplier
			if ($keyXValues[0]>0.1)
				{
//				$value=$keyYValues[0]/$keyXValues[0];
				$value=$keyYValues[0];
				break;
				}
			}
		if ($value==0)//only negative keyValues, so use first keyValue
			{
			$keyXValues=`keyframe -in 0 -q -fc $animCurves[$z]`;
			$keyYValues=`keyframe -in 0 -q -vc $animCurves[$z]`;
//			$value=$keyYValues[0]/$keyXValues[0];
			$value=$keyYValues[0];
			}
		if ($arKitEyeLookPreSDKMult==-1) $value=$value*-1;
		$arrayInfo+="'"+$value+"',";
		}	

	//Driven BS(FaceSetup) not included in asDsGetAnimCurves since it does not use the `$bw="bw"+$drivingSystem+"_"+$drivingAttr` node, so adding these
	$bsAnimCurves=`listConnections -s 0 -d 1 -type animCurve ($ctrl+"."+$attrs[$y])`;
	//ctrlMouthCorner_R.t uses BW
	if (`objExists ("bw"+$ctrl+"_"+$attrs[$y])`)
		{
		$tempString=`listConnections -s 0 -d 1 -type animCurve ("bw"+$ctrl+"_"+$attrs[$y])`;
		$bsAnimCurves=`stringArrayCatenate $bsAnimCurves $tempString`;
		}
	for ($i=0;$i<size($bsAnimCurves);$i++)
		{
		$tempString3=`listConnections -s 0 -d 1 -scn 1 -p 1 ($bsAnimCurves[$i]+".output")`;
		if (!`gmatch $tempString3[0] "asFaceBS[.]*"`)
			continue;//skipping BS nodes that are not "asFaceBS", e.g. "asFaceBS_model_eyeBrowR", since Unreal have these `combined`
		$keyXValues=`keyframe -in 0 -q -fc $bsAnimCurves[$i]`;
		$driverValue=$keyXValues[0];
		if ($driverValue==-10) $driverValue=-1;
		if ($driverValue!=-1) $driverValue=1;
		$arrayInfo+="'"+$tempString3[0]+"':'"+$driverValue+"',";
		}

	$arrayInfo=`asUnCommaCloseBracket $arrayInfo`+",";
	//min/max
	if (`attributeQuery -n $ctrl -softMaxExists $attrs[$y]`)
		{
		$limits=`attributeQuery -n $ctrl -softRange $attrs[$y]`;
		if ($limits[0]!=0)
			{
			$arrayInfo+="'"+$attrs[$y]+"-setLimits':{'"+$limits[0]/10+"':'"+$limits[1]/10+"'";
			$arrayInfo=`asUnCommaCloseBracket $arrayInfo`+",";
			}
		}
	}
$arrayInfo=`asUnCommaCloseBracket $arrayInfo`;
return $arrayInfo;
}

global proc float asControlDiameter (string $ctrl)
{
float $diameter;
float $bbMin[],$bbMax[],$bbShapeMin[],$bbShapeMax[],$bbDiffs[];
float $scale[]=`xform -q -ws -s $ctrl`;
string $shape;
string $tempString[] = `listRelatives -s $ctrl`;

for ($i=0;$i<size($tempString);$i++)
	{
	$shape=$tempString[$i];
	$bbShapeMin=`getAttr ($shape+".boundingBoxMin")`;
	$bbShapeMax=`getAttr ($shape+".boundingBoxMax")`;
	if ($i==0)
		{
		$bbMin[0]=$bbShapeMin[0];
		$bbMin[1]=$bbShapeMin[1];
		$bbMin[2]=$bbShapeMin[2];
		$bbMax[0]=$bbShapeMax[0];
		$bbMax[1]=$bbShapeMax[1];
		$bbMax[2]=$bbShapeMax[2];
		}
	if ($bbShapeMin[0]<$bbMin[0]) $bbMin[0]=$bbShapeMin[0];
	if ($bbShapeMin[1]<$bbMin[1]) $bbMin[1]=$bbShapeMin[1];
	if ($bbShapeMin[2]<$bbMin[2]) $bbMin[2]=$bbShapeMin[2];
	if ($bbShapeMax[0]>$bbMax[0]) $bbMax[0]=$bbShapeMax[0];
	if ($bbShapeMax[1]>$bbMax[1]) $bbMax[1]=$bbShapeMax[1];
	if ($bbShapeMax[2]>$bbMax[2]) $bbMax[2]=$bbShapeMax[2];
	}

$bbDiffs={($bbMax[0]-$bbMin[0])*$scale[0],($bbMax[1]-$bbMin[1])*$scale[1],($bbMax[2]-$bbMin[2])*$scale[2]};
if ($bbDiffs[0]>$diameter) $diameter=$bbDiffs[0];
if ($bbDiffs[1]>$diameter) $diameter=$bbDiffs[1];
if ($bbDiffs[2]>$diameter) $diameter=$bbDiffs[2];

return $diameter;
}

global proc float[] asControlOffset (string $ctrl)
{
float $offT[3],$pos[3];
float $bbShapeMin[],$bbShapeMax[],$bbDif[];
float $scale[]=`xform -q -ws -s $ctrl`;
string $parent;
string $tempString[] = `listRelatives -s $ctrl`;

if (!`gmatch $ctrl "ctrl*"`)//e.g. ctrlARKit_M, just use [0] shape.
	if (size($tempString)!=1)
		return $offT;

$bbShapeMin=`getAttr ($tempString[0]+".boundingBoxMin")`;
$bbShapeMax=`getAttr ($tempString[0]+".boundingBoxMax")`;
$bbDif[0]=$bbShapeMin[0]-($bbShapeMax[0]*-1);
$bbDif[1]=$bbShapeMin[1]-($bbShapeMax[1]*-1);
$bbDif[2]=$bbShapeMin[2]-($bbShapeMax[2]*-1);
if (abs($bbDif[0])>0.01) $offT[0]=($bbDif[0]/2.0)*$scale[0];
if (abs($bbDif[1])>0.01) $offT[1]=($bbDif[1]/2.0)*$scale[1];
if (abs($bbDif[2])>0.01) $offT[2]=($bbDif[2]/2.0)*$scale[2];
//if (abs($bbDif[0])>0.01 || abs($bbDif[1])>0.01 || abs($bbDif[2])>0.01)
//	print ($ctrl+" : "+$offT[0]+" : "+$offT[1]+" : "+$offT[2]+"\n");
if (`gmatch $ctrl "ctrl*"`)
	{
	$tempString=`listRelatives -p $ctrl`;
	$parent=$tempString[0];
	$pos=`getAttr ($parent+".t")`;
	$offT={$pos[0],$pos[1],$pos[2]};
	}
//DrivingSystems are WS in Maya, but OS in Unreal, so $offT would not be correct, flipping 
$tempString=`ls -l $ctrl`;
if (`gmatch $tempString[0] "*|DrivingSystem|*"`)
	if (`gmatch $ctrl "*_L"`)
		$offT={$offT[0]*-1,$offT[1]*-1,$offT[2]*-1};

return $offT;
}

global proc string asUnCommaCloseBracket (string $string)
{
int $numChar=size($string);
string $newString=$string;

if (`gmatch $string "*,"`)
	$newString=`substring $string 1 ($numChar-1)`;
$newString+="}";

return $newString;
}

global proc asExportWonderStudio ()
{
if (`window -q -ex asExportWonderStudioUI`)
    deleteUI asExportWonderStudioUI;
window -t "Wonder Studio" asExportWonderStudioUI;
columnLayout;
	separator -h 10 -st none;
	text -l "Make sure your file is saved.\nThis process will Remove current rig.";
	separator -h 10 -st none;
	button -l "Rename and ReOrder Joints and Geometry" -c "asEWSRenameReorder";
	separator -h 10 -st none;
	button -l "Export" -c asEWSExport;
showWindow;
}

global proc asEWSRenameReorder ()
{
int $createdShaders;
float $colors[];
string $side,$leftRight,$errorEvalCmd,$geometry,$noneNsName;
string $as[]={"Geometry","DeformationSystem",				 "Root_M","Spine1_M","Spine1Part2_M","Chest_M","Neck_M","Head_M"};
string $bs[]={"GEO","AdvancedSkeletonCharacter_BODY","Hips",  "Spine",   "Spine1",       "Spine2", "Neck",  "Head"};
string $aSides[]={"Scapula", "Shoulder","Elbow",       "Wrist","Hip",  "Knee","Ankle","Toes"};
string $bSides[]={"Shoulder","Arm",     "ForeArm","Hand", "UpLeg","Leg", "Foot", "ToeBase"};
string $fingers[]={"Index","Middle","Ring","Pinky","Thumb"};
string $geoParts[]={"UpperTeeth","LowerTeeth","Tongue","Eyebrow","EyeLash"};
string $handFoot[]={"Hand","Foot"};
string $fitSkeletonJoints[],$meshes[],$tempString[],$tempString2[],$tempString3[],$targets[],$cTargets[],$allGeos[],$skinClusters[];

//notes: fileName should be character.fbx

//preCheck 1/2
if (`objExists AdvancedSkeletonCharacter_BODY`)
	error "Already Renamed and Reorrdered for WonderStudio";
if (!`pluginInfo -q -l mtoa`)
	error "Arnold render plugin (mtoa) not loaded";

//FitSkeleton renaming
if (`objExists FitSkeleton`)
	$fitSkeletonJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitSkeletonJoints);$i++)
	{
	rename $fitSkeletonJoints[$i] ("prefix_"+$fitSkeletonJoints[$i]);
	$errorEvalCmd+="rename prefix_"+$fitSkeletonJoints[$i]+" "+$fitSkeletonJoints[$i]+";";
	}

//assembling arrays
for ($i=0;$i<size($aSides);$i++)
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$leftRight="Right";}
		else {$side="_L";$leftRight="Left";}

		$as[size($as)]=$aSides[$i]+$side;
		$bs[size($bs)]=$leftRight+$bSides[$i];
		}

for ($i=0;$i<size($fingers);$i++)
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$leftRight="Right";}
		else {$side="_L";$leftRight="Left";}

		for ($y=1;$y<4;$y++)
			{
			$as[size($as)]=$fingers[$i]+"Finger"+$y+$side;
			$bs[size($bs)]=$leftRight+"Hand"+$fingers[$i]+$y;
			}
		}

//preCheck 2/2
for ($i=0;$i<size($bs);$i++)
	if (`objExists $bs[$i]`)
		{
		eval ($errorEvalCmd);
		error ("Object:\""+$bs[$i]+"\" already exists, Aborting.");
		}
for ($i=0;$i<size($as);$i++)
	if (!`objExists $as[$i]`)
		{
		eval ($errorEvalCmd);
		error ("Object:\""+$as[$i]+"\" does not exists, Aborting.");
		}

setAttr Main.jointVis 1;
string $references[]=`file -q -r`;
for ($i=0;$i<size($references);$i++)
	file -importReference $references[$i];

//Shaders
$meshes=`listRelatives -ni -ad -type mesh Geometry`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listConnections -s 0 -d 1 -type shadingEngine $meshes[$i]`;
	if ($tempString[0]=="")
		continue;//Maya pre2024 seems to incorrectly return inter meses even with `listRelatives -ni`
	$tempString2=`listConnections ($tempString[0]+".surfaceShader")`;
	if ($tempString2[0]=="")
		continue;
	$tempString3[0]=`objectType $tempString2[0]`;
	if ($tempString3[0]!="aiFlat" && $tempString3[0]!="aiStandardSurface")
		{
		createNode -n ($tempString2[0]+"_AsAiStandardSurface") aiStandardSurface;
		connectAttr -f ($tempString2[0]+"_AsAiStandardSurface.outColor") ($tempString[0]+".surfaceShader");
		$createdShaders=1;
		if (`attributeExists color $tempString2[0]`)
			{
			$colors=`getAttr ($tempString2[0]+".color")`;
			setAttr ($tempString2[0]+"_AsAiStandardSurface.baseColor") -type float3 $colors[0] $colors[1] $colors[2];
			}
		}
	}
if ($createdShaders)
	print ("// Only AiStandardSurface & AiFlat shaders are currently supported in WonderStudio, now creating new shaders.\n");

//BlendShapes
$targets={"browInnerDn","browInnerUp","browOuterDn","browOuterUp","browSqueeze","cheekBlow","cheekUp","eyeBlink","eyeCompress","eyeSquint",
	"eyeWidenLower","eyeWidenUpper","lipChinRaiser","lipCornerDn","lipCornerUp","lipDimpler",
	"lipLowerDn","lipLowerUp",
	"lipUpperDn","lipUpperUp",
	"lipLowerPullDn",
	"lipNarrow","lipWiden","lipPresser","lipPull","lipSmileClosed","lipSmileOpen","lipSneer","lipSticky","lipTightner",
	"noseSneer","noseWrinkler"};
//skip: jawClench
$cTargets={"eyeDn","eyeUp","jawIn","jawOut","jawL","jawR","jawOpen","lipCloseLower","lipCloseUpper","lipFunnelerLower","lipFunnelerUpper",
	"lipPoutLower","lipPoutUpper","lipPucker","lipPushLower","lipPushUpper","lipSuckLower","lipSuckUpper","lipSwingL","lipSwingR",
	"noseCompress","noseFlare"};
$targets=`stringArrayCatenate $targets $cTargets`;
if (`objExists FaceFitSkeleton`)
	{
	createNode -n WonderStudioBlendShapeTargets transform;
	setAttr WonderStudioBlendShapeTargets.v 0;
	$geometry=`getAttr FaceFitSkeleton.Face`;
	$allGeos={$geometry};
	for ($i=0;$i<size($geoParts);$i++)
		{
		if (!`attributeExists $geoParts[$i] FaceFitSkeleton`)
			continue;
		$tempString[0]=`getAttr ("FaceFitSkeleton."+$geoParts[$i])`;
		if ($tempString[0]=="")
			continue;
		tokenize $tempString[0] $tempString;
		for ($y=0;$y<size($tempString);$y++)
			if (`objExists $tempString[$y]`)
				$allGeos[size($allGeos)]=$tempString[$y];
		}

	for ($i=0;$i<size($targets);$i++)
		{
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1)  $side="R";
			if ($b==-1) $side="L";

			if (`stringArrayCount $targets[$i] $cTargets`)
				{
				if ($b==1) $side="";
				if ($b==-1) continue;
				}

			if ($targets[$i]=="browInnerDn") setAttr ("ctrlBrow_"+$side+".tx") -1;
			if ($targets[$i]=="browInnerUp") setAttr ("ctrlBrow_"+$side+".tx") 1;
			if ($targets[$i]=="browOuterDn") setAttr ("ctrlBrow_"+$side+".outerUpDown") -5;
			if ($targets[$i]=="browOuterUp") setAttr ("ctrlBrow_"+$side+".outerUpDown") 10;
			if ($targets[$i]=="browSqueeze") setAttr ("ctrlBrow_"+$side+".squeeze") 10;
			if ($targets[$i]=="cheekBlow") setAttr ("ctrlCheek_"+$side+".tx") 1;
			if ($targets[$i]=="cheekUp") setAttr ("ctrlCheek_"+$side+".ty") 1;
			if ($targets[$i]=="eyeBlink") setAttr ("ctrlEye_"+$side+".blink") 10;
			if ($targets[$i]=="eyeCompress") {setAttr ("ctrlEye_"+$side+".squint") 10;setAttr ("ctrlEye_"+$side+".blink") -10;}
			if ($targets[$i]=="eyeSquint") setAttr ("ctrlEye_"+$side+".squint") -10;
			if ($targets[$i]=="eyeWidenLower") setAttr ("lowerLid_"+$side+".ty") -0.3;
			if ($targets[$i]=="eyeWidenUpper") setAttr ("upperLid_"+$side+".ty") 0.3;
			if ($targets[$i]=="lipChinRaiser") setAttr ctrlLips_M.ty 0.5;//not really a l/r split, but intended for combine anyway
			if ($targets[$i]=="lipCornerDn") setAttr ("ctrlMouthCorner_"+$side+".ty") -1;
			if ($targets[$i]=="lipCornerUp") setAttr ("ctrlMouthCorner_"+$side+".ty") 1;
			if ($targets[$i]=="lipDimpler") setAttr ("cornerLip_"+$side+".tz") -0.25;
			if ($targets[$i]=="lipLowerDn") setAttr ("lowerLipB_"+$side+".ty") -1;
			if ($targets[$i]=="lipLowerUp") setAttr ("lowerLipB_"+$side+".ty") 1;
			if ($targets[$i]=="lipUpperDn") setAttr ("upperLipB_"+$side+".ty") -1;
			if ($targets[$i]=="lipUpperUp") setAttr ("upperLipB_"+$side+".ty") 1;
			if ($targets[$i]=="lipLowerPullDn") setAttr ("lowerLipB_"+$side+".ty") -1;//same as lipLowerDn
			if ($targets[$i]=="lipNarrow") setAttr ("ctrlMouthCorner_"+$side+".tx") -1;
			if ($targets[$i]=="lipWiden") setAttr ("ctrlMouthCorner_"+$side+".tx") 1;
			if ($targets[$i]=="lipPresser") {setAttr ctrlLips_M.upperPress 5;setAttr ctrlLips_M.lowerPress 5;}//not really a l/r split, but intended for combine anyway
			if ($targets[$i]=="lipPull")  {setAttr ("ctrlMouthCorner_"+$side+".tx") 1;setAttr ("ctrlMouthCorner_"+$side+".ty") -1;}
			if ($targets[$i]=="lipSmileClosed") {setAttr ("ctrlMouthCorner_"+$side+".tx") 1;setAttr ("ctrlMouthCorner_"+$side+".ty") 1;}
			if ($targets[$i]=="lipSmileOpen") {setAttr ("ctrlMouthCorner_"+$side+".tx") 1;setAttr ("ctrlMouthCorner_"+$side+".ty") 1;setAttr lowerLip_M.ty -0.5;}
			if ($targets[$i]=="lipSneer") setAttr ("upperLipB_"+$side+".ty") 1;
			if ($targets[$i]=="lipSticky") {setAttr ("upperLipC_"+$side+".ty") -0.1;setAttr ("lowerLipC_"+$side+".ty") 0.1;}
			if ($targets[$i]=="lipTightner") {setAttr ctrlLips_M.upperPress 5;setAttr ctrlLips_M.lowerPress 5;}//same as lipPresser
			if ($targets[$i]=="noseSneer") setAttr ("ctrlNose_"+$side+".ty") 0.3;
			if ($targets[$i]=="noseWrinkler") setAttr ("ctrlNose_"+$side+".ty") 1;

			if ($targets[$i]=="eyeDn") {setAttr ctrlEye_R.ty -1;setAttr ctrlEye_L.ty -1;}
			if ($targets[$i]=="eyeUp") {setAttr ctrlEye_R.ty 1;setAttr ctrlEye_L.ty 1;}
			if ($targets[$i]=="jawIn") setAttr ctrlMouth_M.jawForward -5;
			if ($targets[$i]=="jawOut") setAttr ctrlMouth_M.jawForward 5;
			if ($targets[$i]=="jawL") setAttr ctrlMouth_M.jawSide 10;
			if ($targets[$i]=="jawR") setAttr ctrlMouth_M.jawSide -10;
			if ($targets[$i]=="jawOpen") setAttr ctrlMouth_M.ty -1;
			if ($targets[$i]=="lipCloseLower") setAttr lowerLip_M.ty 1.4;
			if ($targets[$i]=="lipCloseUpper") setAttr upperLip_M.ty -1.4;
			if ($targets[$i]=="lipFunnelerLower") setAttr ctrlLips_M.lowerPucker 10;
			if ($targets[$i]=="lipFunnelerUpper") setAttr ctrlLips_M.upperPucker 10;
			if ($targets[$i]=="lipPoutLower") setAttr lowerLip_M.tz 1;
			if ($targets[$i]=="lipPoutUpper") setAttr upperLip_M.tz 1;
			if ($targets[$i]=="lipPucker") {setAttr ctrlLips_M.lowerPucker 10;setAttr ctrlLips_M.upperPucker 10;}
			if ($targets[$i]=="lipPushLower") setAttr lowerLip_M.tz 1;
			if ($targets[$i]=="lipPushUpper") setAttr upperLip_M.tz 1;
			if ($targets[$i]=="lipSuckLower") setAttr ctrlLips_M.lowerRoll -10;
			if ($targets[$i]=="lipSuckUpper") setAttr ctrlLips_M.upperRoll -10;
			if ($targets[$i]=="lipSwingL") setAttr ctrlLips_M.tx 1;
			if ($targets[$i]=="lipSwingR") setAttr ctrlLips_M.tx -1;
			if ($targets[$i]=="noseCompress") {setAttr ctrlNose_R.tx -1;setAttr ctrlNose_L.tx -1;}
			if ($targets[$i]=="noseFlare") {setAttr ctrlNose_R.tx 1;setAttr ctrlNose_L.tx 1;}

			for ($a=0;$a<size($allGeos);$a++)
				{
				$noneNsName=`substituteAllString $allGeos[$a] ":" "_"`;
				duplicate -n ($targets[$i]+$side) $allGeos[$a];
				if (!`objExists ($noneNsName+"_Targets")`)
					createNode -n ($noneNsName+"_Targets") -p WonderStudioBlendShapeTargets transform;
				parent ($targets[$i]+$side) ($noneNsName+"_Targets");
				select ($targets[$i]+$side) $allGeos[$a];
				if (`objExists ("WonderStudioBS"+$a)`)
					blendShape -e -tc 0 -t $allGeos[$a] `getAttr -s ("WonderStudioBS"+$a+".w")` ($targets[$i]+$side) 1 ("WonderStudioBS"+$a);
				else
					asBlendShapeFrontOfChain ("WonderStudioBS"+$a);
				rename ($targets[$i]+$side) ($targets[$i]+"_"+$noneNsName+$side);
				}
			asGoToBuildPose faceSetup;
			}
		}
	delete WonderStudioBlendShapeTargets;
	}

//remove joints
//if (`objExists FaceJoint_M`)
//	delete FaceJoint_M;
/*
if (`objExists RootPart1_M`) {parent Spine Hips;delete RootPart1_M;}
if (`objExists Spine1Part1_M`) {parent Spine1 Spine;delete Spine1Part1_M;}
for ($b=1;$b>-2;$b=$b-2)
	{
		if ($b==1) {$side="_R";$leftRight="Right";}
		else {$side="_L";$leftRight="Left";}

	if (`objExists ("HipPart1"+$side)`) {parent ($leftRight+"Leg") ($leftRight+"UpLeg");delete ("HipPart1"+$side);}
	if (`objExists ("ShoulderPart1"+$side)`) {parent ($leftRight+"ForeArm") ($leftRight+"Arm");delete ("ShoulderPart1"+$side);}
	if (`objExists ("ElbowPart1"+$side)`) {parent ($leftRight+"Hand") ($leftRight+"ForeArm");delete ("ElbowPart1"+$side);}
	}
source doNormalizeWeightsArgList;
//select -hi GEO;
$tempString=`listRelatives -ad -c -ni GEO`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2[0]=`asGetSkinCluster $tempString[$i]`;
	if ($tempString2[0]=="")
		continue;
	select $tempString[$i];
	doNormalizeWeightsArgList 2 { "4", "1" };
	}
dgdirty -a;
*/

parent -w Geometry DeformationSystem;

select -hi DeformationSystem;
$tempString=`ls -sl`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $tempString[$i]`)
			continue;
	if ($tempString[$i]!="DeformationSystem" && `objectType $tempString[$i]`!="joint")
		{
		delete $tempString[$i];
		continue;
		}
	sets -rm AllSet $tempString[$i];
	sets -rm DeformSet $tempString[$i];
	setAttr ($tempString[$i]+".rotateOrder") 0;
	$tempString2=`listConnections -s 1 -d 0 -p 1 -c 1 $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y=$y+2)
		{
		if ($tempString2[$y+1]=="")
			continue;
		catchQuiet (`disconnectAttr $tempString2[$y+1] $tempString2[$y]`);
		}
	}

//remove rig
/*
if (`objExists FaceAllSet`) delete `sets -q -nodesOnly FaceAllSet`;
if (`objExists FaceAllSet`) delete `sets -q -nodesOnly FaceAllSet`;
if (`objExists FaceGroup`) delete FaceGroup;
*/
if (`objExists FaceGroup`) asDeleteAdvancedFace;
if (`objExists FaceGroup`) delete FaceGroup;
$tempString=`listRelatives -c -type transform Geometry`;
asDeleteAdvanced;
delete FitSkeleton;

for ($i=0;$i<size($tempString);$i++)
	parent $tempString[$i] Geometry;

//rename
for ($i=0;$i<size($as);$i++)
		rename $as[$i] $bs[$i];

//add IK joints
for ($i=0;$i<size($handFoot);$i++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$leftRight="Right";}
		else {$side="_L";$leftRight="Left";}

		select -cl;
		joint -n ($leftRight+$handFoot[$i]+"_IK");
		parent ($leftRight+$handFoot[$i]+"_IK") ($leftRight+$handFoot[$i]);
		setAttr ($leftRight+$handFoot[$i]+"_IK.t") -type float3 0 0 0;
		$tempString=`listRelatives -p ($leftRight+$handFoot[$i])`;
		parent ($leftRight+$handFoot[$i]+"_IK") $tempString[0];
		}
	}

$tempString=`ls -type displayLayer`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!="defaultLayer")
		delete $tempString[$i];
dgdirty -a;

hyperShadePanelMenuCommand("", "deleteUnusedNodes");

select -cl;
print "// Ready for WonderStudio export.\n";
}

global proc asEWSExport ()
{
int $fileId;
string $sceneName=`file -q -sn`;
string $filePath=`asStripPath $sceneName 1`;
string $fbxFile,$exportPath,$py;
string $as2wdFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/as2wd/wd_character_export.py";

if (!`objExists AdvancedSkeletonCharacter_BODY` || !`objExists GEO`)
	error "Required objects not found, run the \"Rename and ReOrder Joints and Geometry\" function first";
if (!`file -q -ex $as2wdFile`)
	error ("The file:\""+$as2wdFile+"\" no found");
if ($sceneName=="")
	error "No Scene Name, the file must be saved first.";

//read $as2wdFile
$fileId=`fopen $as2wdFile "r"`;
$nextLine=`fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	$py+=$nextLine;
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

print ("// Executing WonderStudio Python Script:\""+$as2wdFile+"\".\n");
python ($py);
print ("//Complete, files to upload can be found in this Folder:\""+$filePath+"01_character_data/\"\n");
}

global proc asRobloxDynamicHead ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $userAttrs[],$tempString[];

if (!`objExists ctrlRobloxHead_M`)
	error "ctrlRobloxHead_M controller not found, a FaceRig with the \"roblox head\" option must be created.";

currentTime 0;

//remove existing
$tempString=`listConnections -s 1 -d 0 -type animCurve ctrlRobloxHead_M`;
if (size($tempString))
	delete $tempString;
$tempString=`listAttr -ud $geometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "Frame[0-9]*"`)
		deleteAttr ($geometry+"."+$tempString[$i]);
	}

//addAttrs
if (!`attributeExists RootFaceJoint $geometry`)
	addAttr -ln RootFaceJoint -dt "string" $geometry;
setAttr -type "string"($geometry+".RootFaceJoint") "Face";
addAttr -ln Frame0 -dt "string" $geometry;
setAttr -type "string" ($geometry+".Frame0") "Neutral";

$userAttrs=`listAttr -ud -s ctrlRobloxHead_M`;
for ($i=0;$i<size($userAttrs);$i++)
	{
	setKeyframe -v 0  -t $i     ("ctrlRobloxHead_M."+$userAttrs[$i]);
	setKeyframe -v 10 -t ($i+1) ("ctrlRobloxHead_M."+$userAttrs[$i]);
	setKeyframe -v 0  -t ($i+2) ("ctrlRobloxHead_M."+$userAttrs[$i]);

	addAttr -ln ("Frame"+($i+1)) -dt "string" $geometry;
	setAttr -type "string" ($geometry+".Frame"+($i+1)) $userAttrs[$i];
	}
playbackOptions -min 0 -ast 0 -aet $i -max $i;
select ctrlRobloxHead_M;
currentTime 39 ;
print "// Roblox Dynamic Head animation created, now ready for FBX export.\n";
}
/*
global proc asMSCParentConstraint (string $parent, string $child, string $flagString, int $parentLevels) // MSC=MultiSkinCluster
{
int $plugNr;
string $name,$side,$parentAtLevel;
string $tempString[];

tokenize $child "_" $tempString;
$name=$tempString[0];
for ($y=1;$y<size($tempString)-1;$y++)
	$name+="_"+$tempString[$y];
$side="_"+$tempString[size($tempString)-1];

createNode -n ($name+"MM"+$side) multMatrix;

connectAttr ($parent+".worldMatrix") ($name+"MM"+$side+".matrixIn["+$plugNr+"]");
$plugNr++;

$tempString=`listRelatives -p $parent`;
for ($i=1;$i<$parentLevels;$i++)
	$tempString=`listRelatives -p $tempString[0]`;
$parentAtLevel=$tempString[0];
connectAttr ($parentAtLevel+".worldInverseMatrix") ($name+"MM"+$side+".matrixIn["+$plugNr+"]");
$plugNr++;


$m=`getAttr ($parentAtLevel+".matrix")`;
setAttr ($name+"MM"+$side+".matrixIn["+$plugNr+"]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];

if (`gmatch $flagString "*-incParentScaleAAAAAA*"`)
	{
	createNode -n ($name+"IncParentScaleMM"+$side) multMatrix;
	createNode -n ($name+"IncParentScalePM"+$side) pickMatrix;
	connectAttr ($parentAtLevel+".worldMatrix") ($name+"IncParentScalePM"+$side+".inputMatrix");
	setAttr ($name+"IncParentScalePM"+$side+".useScale") 0;
	setAttr ($name+"IncParentScalePM"+$side+".useShear") 0;
$m=`getAttr ($name+"IncParentScalePM"+$side+".outputMatrix")`;
	setAttr ($name+"IncParentScalePM"+$side+".useScale") 1;
	setAttr ($name+"IncParentScalePM"+$side+".useShear") 1;

	setAttr ($name+"IncParentScalePM"+$side+".useTranslate") 0;
	setAttr ($name+"IncParentScalePM"+$side+".useRotate") 0;
	setAttr ($name+"IncParentScaleMM"+$side+".matrixIn[1]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
	connectAttr ($name+"IncParentScalePM"+$side+".outputMatrix") ($name+"IncParentScaleMM"+$side+".matrixIn[0]");
	connectAttr ($name+"IncParentScaleMM"+$side+".matrixSum") ($name+"MM"+$side+".matrixIn["+$plugNr+"]");
	}
$plugNr++;

$tempString=`listRelatives -p $child`;
$m=`getAttr ($parentAtLevel+".worldInverseMatrix")`;
setAttr ($name+"MM"+$side+".matrixIn["+$plugNr+"]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
$plugNr++;

connectAttr ($name+"MM"+$side+".matrixSum") ($child+".offsetParentMatrix");

xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $child;
}
*/
global proc asParentConstraint (string $parent, string $child, string $flagString)
{
int $opm=`checkBox -q -v asBodyOffsetParentMatrixCheckBox`;
int $plugNr;
float $m[];
string $name,$side;
string $sel[]=`ls -sl`;
string $tempString[];
/*
if ($gameEngine)
	if (`sets -im DeformSet $child`)
		$opm=0;//DeformJoints not to use OffsetParentMatrix if $gameEngine
ghost matrix somehow connected Root_M.worldMatrix[0] -> IKParentConstraintHip_R.offsetParentMatrix; then Error Not Found IKParentConstraintHipMM_R
*/
if ($opm)
	{
	tokenize $child "_" $tempString;
	$name=$tempString[0];
	for ($y=1;$y<size($tempString)-1;$y++)
		$name+="_"+$tempString[$y];
	$side="_"+$tempString[size($tempString)-1];

//print ($name+"MM"+$side+" : "+`objExists ($name+"MM"+$side)`+"\n");
	if (!`objExists ($name+"MM"+$side)`)
		createNode -n ($name+"MM"+$side) multMatrix;

	if (`gmatch $flagString "*-mo*"`)
		{
		createNode -n tempMatrixTransform -p $child transform;
		parent tempMatrixTransform $parent;
		$m=`xform -q -os -m tempMatrixTransform`;
		delete tempMatrixTransform;		
		setAttr ($name+"MM"+$side+".matrixIn["+$plugNr+"]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		$plugNr++;
		}

	connectAttr ($parent+".worldMatrix") ($name+"MM"+$side+".matrixIn["+$plugNr+"]");
	$plugNr++;

	$tempString=`listRelatives -p $child`;
	if ($tempString[0]!="")
		{
		connectAttr ($tempString[0]+".worldInverseMatrix[0]") ($name+"MM"+$side+".matrixIn["+$plugNr+"]");
		$plugNr++;
		}

	if (`gmatch $flagString "*-includePickMatrix*"`)
		{
		createNode -n ($name+"PM"+$side) pickMatrix;
		connectAttr ($name+"MM"+$side+".matrixSum") ($name+"PM"+$side+".inputMatrix");
		connectAttr ($name+"PM"+$side+".outputMatrix") ($child+".offsetParentMatrix");
		}
	else
		connectAttr  ($name+"MM"+$side+".matrixSum") ($child+".offsetParentMatrix");

	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $child;
	if (`objectType $child`=="joint")
		setAttr ($child+".jo") -type float3 0 0 0;
	}
else
	{
	if (`gmatch $flagString "*-mo*"`)
		{
		parentConstraint -mo $parent $child;
		scaleConstraint -mo $parent $child;
		}
	else
		{
		parentConstraint $parent $child;
		scaleConstraint $parent $child;
		}
	}
select $sel;
}

global proc asBlendedMatrixAim (string $baseName, string $side, int $b, string $input, string $upObj, string $target, string $obj, int $secondaryMode, int $mo)
{
createNode -n ("FKAim"+$baseName+"AM"+$side) aimMatrix;
setAttr ("FKAim"+$baseName+"AM"+$side+".secondaryMode") $secondaryMode;
setAttr ("FKAim"+$baseName+"AM"+$side+".primaryInputAxis") -type float3 $b 0 0;
setAttr ("FKAim"+$baseName+"AM"+$side+".secondaryInputAxis") -type float3 0 $b 0;
setAttr ("FKAim"+$baseName+"AM"+$side+".secondaryTargetVector") -type float3 0 $b 0;
connectAttr ($input+".worldMatrix[0]") ("FKAim"+$baseName+"AM"+$side+".inputMatrix");
connectAttr ($target+".worldMatrix[0]") ("FKAim"+$baseName+"AM"+$side+".primaryTargetMatrix");
connectAttr ($upObj+".worldMatrix[0]") ("FKAim"+$baseName+"AM"+$side+".secondaryTargetMatrix");

//Skip the MM, since using AimMatrix.inputMatrix

createNode -n ("Aim"+$baseName+"MM"+$side) multMatrix;
connectAttr ("FKAim"+$baseName+"AM"+$side+".outputMatrix") ("Aim"+$baseName+"MM"+$side+".matrixIn[1]");
connectAttr ($input+".worldInverseMatrix") ("Aim"+$baseName+"MM"+$side+".matrixIn[2]");

if ($mo)
	{
	$m=`getAttr ("Aim"+$baseName+"MM"+$side+".matrixSum")`;
	$m=`asInvertMatrix $m`;
	setAttr ("Aim"+$baseName+"MM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
	}
createNode -n ("Aim"+$baseName+"BM"+$side) blendMatrix;
createNode -n ("Aim"+$baseName+"PM"+$side) pickMatrix;
setAttr ("Aim"+$baseName+"PM"+$side+".useTranslate") 0;
setAttr ("Aim"+$baseName+"PM"+$side+".useScale") 0;
setAttr ("Aim"+$baseName+"PM"+$side+".useShear") 0;
connectAttr ("Aim"+$baseName+"MM"+$side+".matrixSum") ("Aim"+$baseName+"PM"+$side+".inputMatrix");
//connectAttr ("FKAim"+$baseName+"AM"+$side+".outputMatrix") ("Aim"+$baseName+"PM"+$side+".inputMatrix");
connectAttr ("Aim"+$baseName+"PM"+$side+".outputMatrix") ("Aim"+$baseName+"BM"+$side+".target[0].targetMatrix");

//setting BlenMatrix.inputMatrix, to allow for non-zero values at `not-aim`
$m=`getAttr ("Aim"+$baseName+"PM"+$side+".outputMatrix")`;
setAttr ("Aim"+$baseName+"BM"+$side+".inputMatrix") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];

connectAttr ("Aim"+$baseName+"BM"+$side+".outputMatrix") ($obj+".offsetParentMatrix");
}

global proc string asInfoFromCtrl (string $ctrl, string $info)
{
int $numChar;
string $name,$type,$extra;
string $tempString[],$tempString2[];

if (`gmatch $ctrl "FK*"`) $type="FK";
if (`gmatch $ctrl "IK*"`) $type="IK";
if (`gmatch $ctrl "Root*"`) $type="Root";
if (`gmatch $ctrl "Pole*"`) $type="Pole";
if (`gmatch $ctrl "Bend*"`) $type="Bend";
if (`gmatch $ctrl "IKhybrid*"`) $type="IKhybrid";
if (`gmatch $ctrl "Micro*"`) $type="Micro";
if (`gmatch $ctrl "RootX*"`) $type="Root";
if (`gmatch $ctrl "HipSwinger*"`) $type="HipSwinger";
if (`gmatch $ctrl "*Extra*"`) $type+="Extra";
$numChar=size($type);
$tempString[0]=`substring $ctrl ($numChar+1) 99`;
tokenize $tempString[0] "_" $tempString2;
$name=$tempString2[0];
$side="_"+$tempString2[1];

if ($info=="type") return $type;
if ($info=="name") return $name;
if ($info=="side") return $side;
}

global proc string asRlaParent (string $joint)
{
string $tempString[]=`listRelatives -p -type joint $joint`;
string $rlaParent=$tempString[0];
return $rlaParent;
}

global proc string asRlaChild (string $joint)
{
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
string $children[]=`listRelatives -type joint -c $joint`;
string $rlaChild="";
float $pos[3]=`xform -q -ws -t $joint`;
int $center=0;
if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;
for ($y=0;$y<size($children);$y++)
	{
	float $childPos[3]=`xform -q -ws -t $children[$y]`;
	int $childCenter=0;
	if ($childPos[0]>-$centerTolerance && $childPos[0]<$centerTolerance) $childCenter=1;
	if ($center && $childCenter) $rlaChild=$children[$y];
	if (!$center && !$childCenter) $rlaChild=$children[$y];
	//Use `first` child as $rlaChild
	if ($rlaChild!="")
	 break;
	}

//if (!$center && size($children)>1)
//	$rlaChild="";

//Preferred $rlaChild
if (`gmatch $joint "*Head*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Head*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Ankle*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Toes*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Root*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Spine*"`)
			$rlaChild=$children[$y];

return $rlaChild;
}

global proc string nonPartRlaChild (string $joint)
{
string $nonPartRlaChild;
string $rlChild=`asRlaChild $joint`;
string $tempString[];

if ($rlChild=="")
	return "";
if (`gmatch $rlChild "*Part[0-9]*"`)
	{
	$tempString=`listRelatives -type joint -ad $rlChild`;
	for ($i=size($tempString)-1;$i>-1;$i--)
		if (!`gmatch $tempString[$i] "*Part[0-9]*"`)
			{
			$nonPartRlaChild=$tempString[$i];
			break;
			}
	}
else
	$nonPartRlaChild=$rlChild;
return $nonPartRlaChild;
}

global proc string nonPartRlaParent (string $joint)
{
string $nonPartRlaParent=`asRlaParent $joint`;
string $tempString[];

while (`gmatch $nonPartRlaParent "*Part[0-9]*"`)
	{
	$tempString=`listRelatives -p $nonPartRlaParent`;
	$nonPartRlaParent=$tempString[0];
	}
return $nonPartRlaParent;
}

global proc string asGetAxis (string $priSecTer, string $fitJoint, string $FitSkeletonOrMain, int $abs)
{
int $worldmatch;
string $axis;
string $priAxis="X";
string $secAxis="Y";
string $terAxis="Z";

if (!`objExists $FitSkeletonOrMain`)
	error ("Object \""+$FitSkeletonOrMain+"\" does not exist");

if (`attributeExists worldmatch FitSkeleton`)
	$worldmatch=`getAttr FitSkeleton.worldmatch`;

if (`objExists $FitSkeletonOrMain`)
	if (`attributeExists primaryAxis $FitSkeletonOrMain`)
		{
		$priAxis=`getAttr -asString ($FitSkeletonOrMain+".primaryAxis")`;
		$secAxis=`getAttr -asString ($FitSkeletonOrMain+".secondaryAxis")`;
		}

if ($worldmatch)
	if (`objExists $fitJoint`)
		if (`attributeExists primaryAxis $fitJoint`)
			{
			$priAxis=`getAttr -asString ($fitJoint+".primaryAxis")`;
			$secAxis=`getAttr -asString ($fitJoint+".secondaryAxis")`;
			}

if ($priSecTer=="primary")   $axis=$priAxis;
if ($priSecTer=="secondary") $axis=$secAxis;
if ($priSecTer=="tertiary")  $axis=`asGetTerAxis $priAxis $secAxis`;

if ($abs)
	$axis=`asAbsAxis $axis`;

return $axis;
}

global proc string asGetTerAxis (string $priAxis, string $secAxis)
{
int $flip;
string $terAxis;
string $absPriAxis=`asAbsAxis $priAxis`;
string $absSecAxis=`asAbsAxis $secAxis`;

if ($absPriAxis=="X" && $absSecAxis=="Y") {$terAxis="Z";}
if ($absPriAxis=="X" && $absSecAxis=="Z") {$terAxis="Y";$flip=!$flip;}
if ($absPriAxis=="Y" && $absSecAxis=="X") {$terAxis="Z";$flip=!$flip;}
if ($absPriAxis=="Y" && $absSecAxis=="Z") {$terAxis="X";}
if ($absPriAxis=="Z" && $absSecAxis=="X") {$terAxis="Y";}
if ($absPriAxis=="Z" && $absSecAxis=="Y") {$terAxis="X";$flip=!$flip;}

if (`gmatch $priAxis "-*"`) $flip=!$flip;
if (`gmatch $secAxis "-*"`) $flip=!$flip;
if ($flip) $terAxis="-"+$terAxis;

return $terAxis;
}

global proc string asAbsAxis (string $axis)
{
string $absAxis=$axis;
if (`gmatch $axis "-*"`)
	$absAxis=`substitute "-" $axis ""`;
return $absAxis;
}

global proc int asAxisToAxisNr (string $axis)
{
int $axisNr;

if (`asAbsAxis $axis`=="X") $axisNr=0;
if (`asAbsAxis $axis`=="Y") $axisNr=1;
if (`asAbsAxis $axis`=="Z") $axisNr=2;

return $axisNr;
}

global proc int asAxisToAxisEnumValue (string $axis)
{
int $axisEnumValue;

if ($axis== "X") $axisEnumValue=0;
if ($axis== "Y") $axisEnumValue=1;
if ($axis== "Z") $axisEnumValue=2;
if ($axis=="-X") $axisEnumValue=3;
if ($axis=="-Y") $axisEnumValue=4;
if ($axis=="-Z") $axisEnumValue=5;

return $axisEnumValue;
}

global proc float[] asAxisToVector (string $axis)
{
float $vector[3];

if ($axis=="X") $vector={1,0,0};
if ($axis=="Y") $vector={0,1,0};
if ($axis=="Z") $vector={0,0,1};
if ($axis=="-X") $vector={-1,0,0};
if ($axis=="-Y") $vector={0,-1,0};
if ($axis=="-Z") $vector={0,0,-1};

return $vector;
}

global proc int asGetOpm ()
{
int $opm;
if (`attributeExists useOffsetParentMatrix FitSkeleton`)
	$opm=`getAttr FitSkeleton.useOffsetParentMatrix`;
return $opm;
}

global proc float[] asTransformValuesFromMatrixPlug (string $obj, string $attr, string $transformAttr)
{
float $transformValues[];
string $sel[]=`ls -sl`;

if (`objExists tempDecomposeMatrix`) delete tempDecomposeMatrix;
createNode -n tempDecomposeMatrix decomposeMatrix;
setAttr tempDecomposeMatrix.inputRotateOrder `getAttr ($obj+".rotateOrder")`;
connectAttr ($obj+"."+$attr) tempDecomposeMatrix.inputMatrix;
if ($transformAttr=="rotate") $transformValues=`getAttr tempDecomposeMatrix.outputRotate`;
if ($transformAttr=="translate") $transformValues=`getAttr tempDecomposeMatrix.outputTranslate`;
if ($transformAttr=="scale") $transformValues=`getAttr tempDecomposeMatrix.outputScale`;

delete tempDecomposeMatrix;
select $sel;
return $transformValues;
}

global proc float[] asGetTransformValues (string $obj, string $transformAttr)
{//`short` cmd to get Xform, wheter OPM or not
int $opm=`asGetOpm`;
float $transformValues[];

if ($opm)
	$transformValues=`asTransformValuesFromMatrixPlug $obj "offsetParentMatrix" $transformAttr`;
else
	$transformValues=`getAttr ($obj+"."+$transformAttr)`;

return $transformValues;
}

global proc float[] asInvertMatrix (float $m[])
{
float $invM[];
string $tempXform;

$tempXform=`createNode -n tempTransform transform`;
xform -m $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15] $tempXform;
$invM=`getAttr ($tempXform+".inverseMatrix")`;
delete $tempXform;
return $invM;
}

global proc string asGetTempDirectory ()
{
string $tempDirectory=`internalVar -utd`;
string $folders[];

//resolve userNames that has beeen `truncated` with Tilde symbol
if (`gmatch $tempDirectory "*~*"`)
	{
	tokenize $tempDirectory "/" $folders;
	$tempDirectory="";
	for ($i=0;$i<size($folders);$i++)
		{
		if (`gmatch $folders[$i] "*~*"`)
			$folders[$i]=`getenv USERNAME`;
		$tempDirectory+=$folders[$i];
//		if ($i<(size($folders)-1))
		if ($i<size($folders))
			$tempDirectory+="/";
		}
	}
return $tempDirectory;
}

global proc string asStripPath (string $path, int $numStrip)
{
string $return;
string $tempString[];

//mac/linux path could start with /
if (`gmatch $path "//*"`) $return="//";
else if (`gmatch $path "/*"`) $return="/";

tokenize $path "/" $tempString;
for ($i=0;$i<size($tempString)-$numStrip;$i++)
	$return+=$tempString[$i]+"/";
return $return;
}

global proc asEnsureAsGetScriptLocation  ()
{
string $asSelectorScriptLocation,$AdvancedSkeletonMelFile;
string $folders[];
if (`exists asGetScriptLocation`)
	return;
else if (`exists asSelectorScriptLocation`)
	{
	$asSelectorScriptLocation=`asSelectorScriptLocation`;
	//Could be that we `have` AdvancedSkeleton, it was just not sourced, so we source it
	if (`gmatch $asSelectorScriptLocation "*/AdvancedSkeletonFiles/*"`) 
		{
		$AdvancedSkeletonMelFile=`asStripPath $asSelectorScriptLocation 2`+"AdvancedSkeleton.mel";
		if (`file -q -ex $AdvancedSkeletonMelFile`)
			{
			evalDeferred ("source \""+$AdvancedSkeletonMelFile+"\"");
			print ("source \""+$AdvancedSkeletonMelFile+"\";\n");
			error "AdvancedSkeleton.mel was not sourced. Sourcing this now. Try running this function again";
			}
		else
			error ("Expected file not found:\""+$AdvancedSkeletonMelFile+"\"");
		}
	else
		error "Seems AdvancedSkeleton is not installed (only running Selector or Picker). This function requires AdvancedSkeleton installed.\n";
	}
else
	error "Unable to run `asGetScriptLocation`, and unable to run `asSelectorScriptLocation`, so unable to determine directory for force-aligner.";
}

global proc string asGetScriptLocationFromSelector ()
{
//simulates `asGetScriptLocation`, but can run in `standalone` mode.
int $numChar;
string $asScriptLocation;
string $tempString[];
if (`exists asGetScriptLocation`)
	$asScriptLocation=`asGetScriptLocation`;
else//can run `standalone`
	{
	$tempString[0]=`asSelectorScriptLocation`;
	$asScriptLocation=`asStripPath $tempString[0] 2`;
	if (`gmatch $asScriptLocation "*/"`)//remove last slash
		{
		$numChar=size($asScriptLocation);
		$asScriptLocation=`substring $asScriptLocation 1 ($numChar-1)`;
		}
	}
return $asScriptLocation;
}

/******ext files only
global proc string asSelectorScriptLocation ()
{
string $whatIs=`whatIs asSelectorScriptLocation`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
if ($numTok<2)
	if (`about -win`)
		$numTok=`tokenize $fullPath "\\" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}
******/
//-- ASTools Procedures Ends Here --//

//-- ASSelector Procedures Starts Here --//
global proc asSelectorDesigner ()
{
asShowSelJob;
string $controlSets[]=`asGetControlSets`;
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Selector/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");

if (`window -q -ex asSelectorDefault`)
	deleteUI asSelectorDefault;
window -w 640 -h 480 -mb 1 -t "SelectorDesigner :untitled" asSelectorDefault;

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`asGetTempDirectory`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	intField -v 640 asSelectorWidth;
	intField -v 480 asSelectorHeight;
	setParent..;

menu "File";
	menuItem -sm 1 -l ControlSets asSelectorControlSetsMenu;
		menuItem -cb 1 -l ControlSet -c asSelectorControlSetsChanged asSelectorControlSetsMenuItemControlSet;
		menuItem -cb 0 -l FaceControlSet -c asSelectorControlSetsChanged asSelectorControlSetsMenuItemFaceControlSet;
		setParent -menu ..;
	menuItem -c "asSave Selector" "Save";
	menuItem -c "asfileBrowse Selector SaveAs" "Save As";
	menuItem -c "astoShelf Selector" "Put on shelf";
/*
menu "Edit";
	menuItem -sm 1 "Colors";
		menuItem -c "asSelectorBackgroundSetColor asSelectorSelColor" "set Selected Color";
		menuItem -c "asSelectorBackgroundSetColor asSelectorKeyColor" "set Keyed Color";
*/
menu "Layout";
	menuItem -c "asSDNewLayout 0" -l "New Empty Layout";
	menuItem -c "asSDNewLayout 1" -l "New Biped Layout";
	menuItem -c "asSDNewLayout 2" -l "New Face Layout";
	menuItem -c "asSDNewLayout 3" -l "New Horse Layout";

menu "Buttons";
	menuItem -c "asSDNewButton Object 50 50 100 100" -l "Create New Button";

menu "Render";
	menuItem -c "asSDRender 1" -l "Render Background";
	menuItem -c "asfileBrowse Selector Import" -l "Import  Background";
	menuItem -d 1;
	menuItem -c "asSDRender 0" -l "Render Buttons";

columnLayout -adj 1;
rowLayout -nc 5 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 65 -cw 4 50 -cw 5 60;
optionMenu -cc asSelChange asSelectorDefaultOptionMenu;
button -l "set" -c "asSetNameSpaceFromSelection asSelectorDefault";
checkBox -v `optionVar -q asShowSelection` -cc "optionVar -iv asShowSelection #1;asSelChangeToggle;" -l Selection asSelectorSelectionCheckBox;
checkBox -v `optionVar -q asShowKeyed` -cc "optionVar -iv asShowKeyed #1;asSelChangeToggle;" -l Keyed asSelectorKeyedCheckBox;
checkBox -v `optionVar -q asShowExtra` -cc "optionVar -iv asShowExtra #1;asSelChangeToggle;" -l Extra asSelectorbipedExtraCheckBox;
setParent..;

formLayout asSelectorDefaultFormLayout;
setParent..;
asPopulateNameSpaceMenu "asSelectorDefault";

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`asGetTempDirectory`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	text -l "640" asSelectorBackgroundWidth;
	text -l "480" asSelectorBackgroundHeight;

showWindow;
}

global proc asSelectorControlSetsChanged ()
{
if (!`objExists SelectorLayout`)
	return;
string $controlSets[]={"ControlSet","FaceControlSet"};

for ($i=0;$i<size($controlSets);$i++)
	{
	if (!`attributeExists $controlSets[$i] SelectorLayout`)
		addAttr -k 1 -ln $controlSets[$i] -at bool -dv 1 SelectorLayout;
	setAttr ("SelectorLayout."+$controlSets[$i]) `menuItem -q -cb  ("asSelectorControlSetsMenuItem"+$controlSets[$i])`;
	}
}

global proc asSDNewLayout (int $LayoutType)
{
string $asScriptLocation=`asGetScriptLocation`;

if (`objExists SelectorLayout`)
	if (`confirmDialog -t "Confirm"
	-m "SelectorLayout already exists, this will replace the current Layout"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;

float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $tempString[];

select -cl;
string $deleteObjs[]={"SelectorLayout","Template","SelectorLayoutShader","SelectorLayoutSG","SelectorIcons"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

if ($LayoutType==1)
	{
	file -i ($asScriptLocation+"/AdvancedSkeletonFiles/Selector/scenes/biped.ma");
	return;
	}
if ($LayoutType==2)
	{
	file -i ($asScriptLocation+"/AdvancedSkeletonFiles/Selector/scenes/face.ma");
	return;
	}
if ($LayoutType==3)
	{
	file -i ($asScriptLocation+"/AdvancedSkeletonFiles/Selector/scenes/horse.ma");
	return;
	}

createNode -n SelectorLayout transform;
polyCube -n Button_Template -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
addAttr -ln label -dt "string" Button_Template;
addAttr -ln multiObjs -dt "string" Button_Template;
polyProjection -ch 0 -type Planar -ibd on -md z Button_Template.f[0];
setAttr Button_Template.sz 0.001;
parent Button_Template SelectorLayout;
setAttr SelectorLayout.tz ($height/2);
setAttr -l 1 -k 0 Button_Template.tz;
setAttr -l 1 -k 0 Button_Template.rx;
setAttr -l 1 -k 0 Button_Template.ry;
setAttr -l 1 -k 0 Button_Template.rz;
setAttr -l 1 -k 0 Button_Template.sz;
setAttr Button_Template.doubleSided 0;
//setAttr -l 1 -k 0 Button_Template.v;

shadingNode -n SelectorLayoutShader -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name SelectorLayoutSG;
connectAttr -f SelectorLayoutShader.outColor SelectorLayoutSG.surfaceShader;
setAttr SelectorLayoutShader.transparency -type double3 0.8 0.8 0.8; 
sets -e -forceElement SelectorLayoutSG Button_Template;

setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.overrideColor 15;
setAttr Button_TemplateShape.primaryVisibility 0;
//setAttr Button_TemplateShape.overrideShading 0;
setAttr Button_TemplateShape.castsShadows 0;
setAttr Button_TemplateShape.receiveShadows 0;
setAttr Button_TemplateShape.visibleInReflections 0;
setAttr Button_TemplateShape.visibleInRefractions 0;
setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.motionBlur 0;
setAttr Button_TemplateShape.smoothShading 0;
//setAttr Button_TemplateShape.doubleSided 0;

//SelectorWindow
duplicate -n SelectorWindow Button_Template;
setAttr SelectorWindowShape.overrideShading 0;
setAttr SelectorWindow.sx 640;
setAttr SelectorWindow.sy 480;
move -r 0 240 0 SelectorWindow.vtx[0:7];
setAttr -type float3 SelectorLayout.s ($height*0.002083) ($height*0.002083) ($height*0.002083);

//WindowCorner
createNode -n WindowCorner -p SelectorWindow transform;
setAttr -type float3 WindowCorner.t -0.5 1 0;
setAttr -type float3 WindowCorner.s (1.0/640) (-1.0/480) 1;

//Prep Button_Template
move -r (`getAttr SelectorLayout.sx`/2.0) (`getAttr SelectorLayout.sy`/2.0) 0 Button_Template.vtx[0:7];
parent Button_Template WindowCorner;
setAttr Button_Template.tx -150;
setAttr Button_Template.ty 50;
setAttr Button_Template.sx 100;
setAttr Button_Template.sy 100;
setAttr Button_Template.v 0;

createNode -n LoadingSelectorLayout transform;
select -cl;

//SelectorIcons
asFitModeEnsureShaders;
createNode -n SelectorIcons transform;
setAttr SelectorIcons.tz ($height/2.2);
connectAttr SelectorLayout.s SelectorIcons.s;
createNode -n SelectorIconsWindow -p SelectorIcons transform;
connectAttr SelectorWindow.t SelectorIconsWindow.t;
connectAttr SelectorWindow.s SelectorIconsWindow.s;
createNode -n WindowIconsCorner -p SelectorIconsWindow transform;
connectAttr WindowCorner.t WindowIconsCorner.t;
connectAttr WindowCorner.s WindowIconsCorner.s;
createNode -n MirroredIcons -p WindowIconsCorner transform;
setAttr MirroredIcons.tx `getAttr SelectorWindow.sx`;
setAttr MirroredIcons.sx -1;

if ($LayoutType==1)
	{
	asSDNewIcon IKArm_R asRedSG sphere;
	asSDNewIcon PoleArm_R asRedSG cross;
	asSDNewIcon FKIKArm_R asBlueSG cross;
	asSDNewIcon IKLeg_R asRedSG sphere;
	asSDNewIcon PoleLeg_R asRedSG cross;
	asSDNewIcon FKIKLeg_R asBlueSG cross;
	asSDNewIcon RollHeel_R asRedSG torus;
	asSDNewIcon RollToes_R asRedSG torus;
	asSDNewIcon RollToesEnd_R asRedSG torus;
	asSDNewIcon HipSwinger_M asGreen2SG torus;
	asSDNewIcon IKSpine1_M asRedSG sphere;
	asSDNewIcon IKSpine2_M asRedSG sphere;
	asSDNewIcon IKSpine3_M asRedSG sphere;
	asSDNewIcon FKIKSpine_M asBlueSG cross;
	}

if (`objExists LoadingSelectorLayout`) delete LoadingSelectorLayout;

select SelectorLayout;
}

global proc asSDNewIcon (string $name, string $shader, string $shape)
{
string $buttonIcon="ButtonIcon_"+$name;
int $numLetters=`size($buttonIcon)`;
string $buttonIconLeft=`substring $buttonIcon 1 ($numLetters-2)`+"_L";
if ($shape=="sphere")
	polySphere -n $buttonIcon -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
if ($shape=="cross")
	{
	polyCube -n $buttonIcon -w 1 -h 1 -d 1 -sx 3 -sy 3 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	scale -r -p 0 0 0 0.333 0.333 0.333 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3]") ($buttonIcon+".vtx[12]")
		($buttonIcon+".vtx[15:16]") ($buttonIcon+".vtx[19]") ($buttonIcon+".vtx[28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 2.5 2.5 2.5 ($buttonIcon+".vtx[0:99]");
	scale -r -p 0 0 0 1 0.5 1 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3:12]") ($buttonIcon+".vtx[15:16]")
		($buttonIcon+".vtx[19:28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 0.5 1 1 ($buttonIcon+".vtx[0:3]") ($buttonIcon+".vtx[5:6]") ($buttonIcon+".vtx[9:10]")
		($buttonIcon+".vtx[12:19]") ($buttonIcon+".vtx[21:22]") ($buttonIcon+".vtx[25:26]") ($buttonIcon+".vtx[28:31]");
	}
if ($shape=="torus")
	polyTorus -n $buttonIcon -r 1 -sr 0.1 -tw 0 -sx 20 -sy 20 -ax 0 0 1 -cuv 1 -ch 0;
parent $buttonIcon WindowIconsCorner;
sets -e -forceElement $shader $buttonIcon;
move -r 1 -1 0 ($buttonIcon+".vtx[0:999]");
scale -r -p 0 0 0 0.5 0.5 0.5 ($buttonIcon+".vtx[0:999]");
scale -r -p 0.5 -0.5 0 0.75 0.75 0.75 ($buttonIcon+".vtx[0:999]");
connectAttr ("Button_"+$name+".t") ($buttonIcon+".t");
connectAttr ("Button_"+$name+".sx") ($buttonIcon+".sx");
connectAttr ("Button_"+$name+".sy") ($buttonIcon+".sy");
setAttr ($buttonIcon+".sz") 1000;
if (`gmatch $buttonIcon "*_R"`)
	{
	instance -n $buttonIconLeft $buttonIcon;
	parent $buttonIconLeft MirroredIcons;
	connectAttr ($buttonIcon+".t") ($buttonIconLeft+".t");
	connectAttr ($buttonIcon+".sy") ($buttonIconLeft+".sy");
	connectAttr ($buttonIcon+".sz") ($buttonIconLeft+".sz");
	createNode -n ($buttonIcon+"Reverse") reverse;
	connectAttr ($buttonIcon+".sx") ($buttonIcon+"Reverse.inputX");
	connectAttr ($buttonIcon+"Reverse.outputX") ($buttonIconLeft+".sx");
	}
	
}


global proc asSDNewButton (string $name,int $x, int $y, int $width, int $height)
{
if (!`objExists Button_Template`)
	error "\"Button_Template\" Not found";
int $indexColor;
float $rgb[];
string $multiObjString,$shader;
string $sel[]=`ls -sl -type transform`;
string $buttonName="Button_"+$name;
string $tempString[];

if ($sel[0]!="" && !`gmatch $sel[0] "Button*"` && $sel[0]!="SelectorWindow" && $sel[0]!="SelectorLayout")
	{
	string $nameSpace=`optionMenu -q -v asSelectorDefaultOptionMenu`;
	if ($nameSpace==":")
		$buttonName="Button_"+$sel[0];
	else
		$buttonName="Button_"+`substitute $nameSpace $sel[0] ""`;
	createNode -n SelectorSampler -p WindowCorner transform;
	pointConstraint $sel[0] SelectorSampler;
	dgdirty -a;
	$x=`getAttr SelectorSampler.tx`-($width/2);
	$y=`getAttr SelectorSampler.ty`-($height/2);
	delete SelectorSampler;
	if (size($sel)>1)
		for ($i=0;$i<size($sel);$i++)
			$multiObjString+=`substitute $nameSpace $sel[$i] ""`+" ";
	$tempString=`listRelatives -s $sel[0]`;
	if (`attributeExists overrideColor $tempString[0]`)
		$indexColor=`getAttr ($tempString[0]+".overrideColor")`;
	}
//unique buttonName
if (`objExists $buttonName`)
	for ($i=1;$i<10;$i++)
		{
		$buttonName=`substitute "Button" $buttonName ""`;
		if (`gmatch $buttonName "[1-9]*"`)
			$buttonName=`substring $buttonName 2 99`;
		$buttonName="Button"+$i+$buttonName;
		if (!`objExists $buttonName`)
			break;
		}

$tempString=`duplicate -n $buttonName Button_Template`;
$buttonName=$tempString[0];
if (!`attributeExists mirror $buttonName`)
	addAttr -k 1 -ln mirror -at bool -dv 1 $buttonName;
setAttr ($buttonName+".v") 1;
setAttr ($buttonName+".tx") $x;
setAttr ($buttonName+".ty") $y;
setAttr ($buttonName+".sx") $width;
setAttr ($buttonName+".sy") $height;
setAttr ($buttonName+".doubleSided") 0;
if ($multiObjString!="")
	setAttr -type "string" ($buttonName+".multiObjs") $multiObjString;

//Middle Constraint
if (`gmatch $buttonName "*_M"` && !`objExists LoadingSelectorLayout`)
	{
	if (`objExists ($buttonName+"MultiplyDivide")`) delete ($buttonName+"MultiplyDivide");
	if (`objExists ($buttonName+"PlusMinusAverage")`) delete ($buttonName+"PlusMinusAverage");
	createNode -n ($buttonName+"MultiplyDivide") multiplyDivide;
	createNode -n ($buttonName+"PlusMinusAverage") plusMinusAverage;
	setAttr ($buttonName+"PlusMinusAverage.operation") 2;
	connectAttr ($buttonName+".scale.scaleX") ($buttonName+"MultiplyDivide.input1Y");
	setAttr -type float3 ($buttonName+"MultiplyDivide.input2") 2 2 2;
	setAttr ($buttonName+"MultiplyDivide.operation") 2;
	connectAttr ($buttonName+"MultiplyDivide.outputY") ($buttonName+"PlusMinusAverage.input1D[1]");
//	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") (`getAttr SelectorWindow.scale.scaleX`/2.0);
	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") 320;
	connectAttr ($buttonName+"PlusMinusAverage.output1D") ($buttonName+".tx");
	}

//$indexColor
if ($indexColor!=0)
	{
	$shader="SelectorColorIndex"+$indexColor;
	$SG="SelectorColorIndex"+$indexColor+"SG";
	if (!`objExists $shader`)
		{
		shadingNode -n $shader -asShader lambert;
		sets -renderable true -noSurfaceShader true -empty -name ($shader+"SG");
		connectAttr -f ($shader+".outColor") ($shader+"SG.surfaceShader");
		$rgb=`colorIndex -query $indexColor`;
		setAttr ($shader+".color") -type double3 $rgb[0] $rgb[1] $rgb[2]; 
		}
	sets -e -forceElement ($shader+"SG") $buttonName;
	}

select $buttonName;
}

global proc int asSelectorBackgroundImport (string $fileName, string $fileType)
{
eval ("renderWindowEditor -e -loadImage \""+$fileName+"\" renderView");
asSDRender 2;
return 1;
}

global proc asSDRender (int $background)
{
global string $gMove;
setToolTo $gMove;
if (!`objExists SelectorWindow`)
	{
	if (`confirmDialog -t "Confirm"
	-m "No Layout found. Create New one ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	asSDNewLayout 0;
	}
if (`objExists SelectorCamera`)
	delete SelectorCamera;
int $renderViewIconized=1;
if (`window -q -ex renderViewWindow`)
	$renderViewIconized=`window -q -i renderViewWindow`;
else if ($background)
	RenderViewWindow;
int $x,$y,$width,$height,$numLetters,$customColor;
int $haveBG=1;
int $windowWidth=`getAttr SelectorWindow.sx`;
int $windowHeight=`getAttr SelectorWindow.sy`;
float $widthFloat,$heightFloat,$pictureWidth,$pictureHeight;
float $windowCornerWidth=`getAttr WindowCorner.sx`;
float $windowCornerHeight=`getAttr WindowCorner.sy`;
$windowCornerHeight=`abs($windowCornerHeight)`;
int $doMirrorBox[];
float $pos[],$bgc[];
string $sel[]=`ls -sl`;
string $projectName=`text -q -l asSelectorProjectName`;
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Selector/untitled/";
//string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Selector/"+$projectName+"/";
//string $iconDir=`text -q -l asSelectorProjectPath`+$projectName+"/";
string $bgImageFile=$iconDir+"untitled_background.png";
string $bgImageFile32=$iconDir+"untitled_background32.png";
string $cmd,$keyCmd,$linearKeyCmd,$labelAttr,$iol,$multiObjAttr,$ann,$fileName,$SG,$shader;
string $alignFK2IKCmd,$alignIK2FKCmd,$switchFK2IKCmd,$switchIK2FKCmd;
string $buttonImageFileOffK0=$iconDir+$projectName+"_"+$fileName+"_OffK0.png";
string $buttonImageFileOffK1,$buttonImageFileOnK0,$buttonImageFileOnK1;
string $annBuffer[],$tempString[];
string $renderBoxes[]=`listRelatives -c WindowCorner`;
string $renderBoxObjs[]=$renderBoxes;

if (`window -q -ex ("asSelector"+$projectName)`)
	{
	print "// The Selector-window from the Project was found open, preventing render of new buttons. This window will now be closed.\n";
	deleteUI ("asSelector"+$projectName);
	}

//using this time to ensure $ControlSet setting from SelectorLayout are updated to MenuItems (as maya-file may have been loaded after gui opened)
if (`attributeExists ControlSet SelectorLayout` && `menuItem -q -ex asSelectorControlSetsMenuItemControlSet`)
	{
	menuItem -e -cb `getAttr SelectorLayout.ControlSet` asSelectorControlSetsMenuItemControlSet;
	menuItem -e -cb `getAttr SelectorLayout.FaceControlSet` asSelectorControlSetsMenuItemFaceControlSet;
	}

for ($i=0;$i<size($renderBoxes);$i++)
	{
	if (`gmatch $renderBoxes[$i] "Button_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 8 999`;
	if (`gmatch $renderBoxes[$i] "Button?_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 9 999`;
//	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<$windowWidth/2)
	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<320)
		{
		$numLetters=`size($renderBoxes[$i])`;
		$mirrorBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_L";
		if (`objExists $mirrorBox`)
			continue;
		if (`attributeExists mirror $renderBoxes[$i]`)
			if (`getAttr ($renderBoxes[$i]+".mirror")`==0)
				continue;

		$doMirrorBox[$i]=1;
		$doMirrorBox[size($renderBoxes)]=1;
		$renderBoxes[size($renderBoxes)]=$mirrorBox;
		}
	}

string $deleteObjs[]={"SelectorScaleSampler","SelectorCamera","SelectorFileNode","SelectorFilePlace",
	"SelectorRampU","SelectorRampV","SelectorLayeredTexture"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

float $color[3]=`displayRGBColor -q "background"`;
if (!`optionVar -ex asSelectorBGColor`)
	{
	optionVar -fv asSelectorBGColor $color[0];
	optionVar -fva asSelectorBGColor $color[1];
	optionVar -fva asSelectorBGColor $color[2];
	}
if (!`optionVar -ex asSelectorDefaultColor`)
	{
	optionVar -fv asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	}
if (!`optionVar -ex asSelectorSelColor`)
	{
	optionVar -fv asSelectorSelColor 0.2;
	optionVar -fva asSelectorSelColor 0.8;
	optionVar -fva asSelectorSelColor 0.2;
	}
if (!`optionVar -ex asSelectorKeyColor`)
	{
	optionVar -fv asSelectorKeyColor 1;
	optionVar -fva asSelectorKeyColor 0.4;
	optionVar -fva asSelectorKeyColor 0.4;
	}
float $bgColor[3]=`optionVar -q asSelectorBGColor`;
float $selColor[3]=`optionVar -q asSelectorSelColor`;
float $keyColor[3]=`optionVar -q asSelectorKeyColor`;

$tempString=`formLayout -q -ca asSelectorDefaultFormLayout`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!$background && $tempString[$i]=="asSelectorDefaultBGPicture")
		continue;
	deleteUI $tempString[$i];
	}

if ($background)
	{
	if (`text -q -l asSelectorBackgroundWidth`) text -e -l $windowWidth asSelectorBackgroundWidth;
	if (`text -q -l asSelectorBackgroundHeight`) text -e -l $windowHeight asSelectorBackgroundHeight;

	createNode -n SelectorScaleSampler transform;
	$tempString=`camera -centerOfInterest 5 -focalLength 35 -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture 1.4173 -horizontalFilmOffset 0 -verticalFilmAperture 0.9449 -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 144 -nearClipPlane 0.1 -farClipPlane 10000 -orthographic 1 -orthographicWidth 30 -panZoomEnabled 0 -horizontalPan 0 -verticalPan 0 -zoom 1`;
	rename $tempString[0] SelectorCamera;
	float $restoreRenderWidth=`getAttr defaultResolution.width`;
	float $restoreRenderHeight=`getAttr defaultResolution.height`;
	float $restoreRenderAspectLock=`getAttr defaultResolution.aspectLock`;
	int $restoreFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
	setAttr defaultRenderGlobals.imageFormat 32;
	
	setAttr "defaultResolution.aspectLock" 0;
	setAttr defaultResolution.width $windowWidth;
	setAttr defaultResolution.height $windowHeight;
	setAttr "defaultResolution.aspectLock" 1;
	setAttr defaultResolution.deviceAspectRatio ($windowWidth/($windowHeight+0.00));
	
	select SelectorWindow.vtx[0:99];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] SelectorCamera;
	move -r 0 0 1.1 SelectorCamera;
	delete `scaleConstraint SelectorWindow SelectorScaleSampler`;
	setAttr SelectorCameraShape.orthographicWidth `getAttr SelectorScaleSampler.sx`;
	if ($background==1)
		renderWindowRenderCamera render renderView SelectorCamera;
	eval ("renderWindowEditor -e -wi \""+$bgImageFile+"\" renderView");
	setParent asSelectorDefaultFormLayout;

	image -en 0 -w $windowWidth -h $windowHeight -i $bgImageFile asSelectorDefaultBGPicture;
	reloadImage $bgImageFile asSelectorDefaultBGPicture;
	formLayout -e -af asSelectorDefaultBGPicture "left" 0 -af asSelectorDefaultBGPicture "top" 0 asSelectorDefaultFormLayout;
	//32
	string $fileNode=`createNode file`;
	setAttr -type "string" ($fileNode+".fileTextureName") $bgImageFile;
	select $fileNode;
	eval ("convertSolidTx -sp 1 -al 1 -rx 32 -ry 32 -n asTempSolidTx32 -fil \"png\" -fin \""+$bgImageFile32+"\"");
	delete $fileNode asTempSolidTx32;
	evalDeferred -lp ("window -e -w "+$windowWidth+" -h "+$windowHeight+" asSelectorDefault");
	
	setAttr defaultResolution.width $restoreRenderWidth;
	setAttr defaultResolution.height $restoreRenderHeight;
	setAttr defaultResolution.aspectLock $restoreRenderAspectLock;
	setAttr defaultRenderGlobals.imageFormat $restoreFormat;
	delete SelectorCamera SelectorScaleSampler;
	if ($renderViewIconized)
		window -e -i 1 renderViewWindow;
	}

if ($bgImageFile=="" || !`file -q -ex $bgImageFile`)
	$haveBG=0;

for ($i=0;$i<size($renderBoxes);$i++)
	{
	$guiBox=$renderBoxes[$i];
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		{
		$numLetters=`size($renderBoxes[$i])`;
		$guiBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_R";
		}
	$x=`getAttr ($guiBox+".tx")`*$windowWidth*$windowCornerWidth;
	$y=`getAttr ($guiBox+".ty")`*$windowHeight*$windowCornerHeight;
	
	$widthFloat=`getAttr ($guiBox+".sx")`*$windowWidth*$windowCornerWidth;
	$width=`asRoundOff $widthFloat 0`;
	$heightFloat=`getAttr ($guiBox+".sy")`*$windowHeight*$windowCornerHeight;
	$height=`asRoundOff $heightFloat 0`;
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		$x=$windowWidth-$x-$width;
	if ($x<0 || $x>$windowWidth || $y<0 || $y>$windowHeight)
		continue;
	if ($background)
		continue;
	$iol="";
	$labelAttr=`getAttr ($guiBox+".label")`;
	if ($labelAttr!="")
		$iol=$labelAttr;
	$ann=$renderBoxObjs[$i];
	$fileName=$ann;
	$multiObjAttr=`getAttr ($guiBox+".multiObjs")`;
	if ($multiObjAttr!="")
		{
		$ann=$multiObjAttr;
		if (`gmatch $renderBoxes[$i] "*_L"`)
			{
			tokenize $ann $tempString;
			$ann="";
			for ($z=0;$z<size($tempString);$z++)
				$ann+=`substitute "_R" $tempString[$z] "_L"`+" ";
			}
		$fileName="combo"+$x+$y;
		}
	//determine $customColor
	$customColor=0;
	$tempString=`listRelatives -s $guiBox`;
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	$SG=$tempString[0];
	if ($SG!="SelectorLayoutSG")
		{
		$tempString=`listConnections -s 1 -d 0 ($SG+".surfaceShader")`;
		$shader=$tempString[0];
		if (`attributeExists color $shader`)
			{
			$customColor=1;
			$bgc=`getAttr ($shader+".color")`;
			}
		}

	if ($haveBG)
		{
		createNode -n SelectorFileNode file;
		setAttr -type "string" SelectorFileNode.fileTextureName $bgImageFile;
		float $pictureWidth=`getAttr SelectorFileNode.outSizeX`;
		float $pictureHeight=`getAttr SelectorFileNode.outSizeY`;
		createNode -n SelectorFilePlace place2dTexture;
		connectAttr SelectorFilePlace.outUV SelectorFileNode.uvCoord; connectAttr -f SelectorFilePlace.outUvFilterSize SelectorFileNode.uvFilterSize; 
		connectAttr -f SelectorFilePlace.coverage SelectorFileNode.coverage; connectAttr -f SelectorFilePlace.translateFrame SelectorFileNode.translateFrame; 
		connectAttr -f SelectorFilePlace.rotateFrame SelectorFileNode.rotateFrame; connectAttr -f SelectorFilePlace.mirrorU SelectorFileNode.mirrorU; 
		connectAttr -f SelectorFilePlace.mirrorV SelectorFileNode.mirrorV; connectAttr -f SelectorFilePlace.stagger SelectorFileNode.stagger; 
		connectAttr -f SelectorFilePlace.wrapU SelectorFileNode.wrapU; connectAttr -f SelectorFilePlace.wrapV SelectorFileNode.wrapV; 
		connectAttr -f SelectorFilePlace.repeatUV SelectorFileNode.repeatUV; connectAttr -f SelectorFilePlace.vertexUvOne SelectorFileNode.vertexUvOne; 
		connectAttr -f SelectorFilePlace.vertexUvTwo SelectorFileNode.vertexUvTwo; connectAttr -f SelectorFilePlace.vertexUvThree SelectorFileNode.vertexUvThree; 
		connectAttr -f SelectorFilePlace.vertexCameraOne SelectorFileNode.vertexCameraOne; connectAttr -f SelectorFilePlace.noiseUV SelectorFileNode.noiseUV; 
		connectAttr -f SelectorFilePlace.offset SelectorFileNode.offset; connectAttr -f SelectorFilePlace.rotateUV SelectorFileNode.rotateUV;
		setAttr SelectorFilePlace.offsetU (($x+1)/$pictureWidth);
		setAttr SelectorFilePlace.offsetV (($pictureHeight-($y-1+$height))/$pictureHeight);
		setAttr SelectorFilePlace.repeatV (($height-2)/$pictureHeight);
		setAttr SelectorFilePlace.repeatU (($width-2)/$pictureWidth);

		createNode -n SelectorRampU ramp;
		createNode -n SelectorRampV ramp;
		setAttr SelectorRampU.type 1;
		setAttr SelectorRampU.interpolation 0;
		setAttr SelectorRampU.colorEntryList[1].color -type double3 0.75 0.75 0.75;
	//	if ($width>2)
			setAttr SelectorRampU.colorEntryList[1].position (1-(1.00000/$width));
		setAttr SelectorRampU.colorEntryList[0].color -type double3 0 0 0;
		setAttr SelectorRampV.type 0;
		setAttr SelectorRampV.interpolation 0;
		setAttr SelectorRampV.colorEntryList[0].color -type double3 0.75 0.75 0.75;
	//	if ($height>2)
			setAttr SelectorRampV.colorEntryList[1].position (1.00000/$height);
		connectAttr SelectorRampU.outColor SelectorRampV.colorEntryList[1].color;
		setAttr SelectorRampU.colorEntryList[0].position (1.00000/$width);
		setAttr SelectorRampU.colorEntryList[2].color -type double3 0.75 0.75 0.75;
		setAttr SelectorRampV.colorEntryList[0].position (1-(1.00000/$height));
		setAttr SelectorRampV.colorEntryList[2].color -type double3 0.75 0.75 0.75;


		createNode -n SelectorLayeredTexture layeredTexture;
		setAttr SelectorLayeredTexture.inputs[0].color -type double3 1 1 1 ;
		connectAttr SelectorRampV.outColorR SelectorLayeredTexture.inputs[0].alpha;
		connectAttr -f SelectorFileNode.outAlpha SelectorLayeredTexture.inputs[1].alpha;
		connectAttr -f SelectorFileNode.outColor SelectorLayeredTexture.inputs[1].color;

		$buttonImageFileOffK0=$iconDir+$projectName+"_"+$fileName+"_OffK0.png";
		$buttonImageFileOffK1=$iconDir+$projectName+"_"+$fileName+"_OffK1.png";
		$buttonImageFileOnK0=$iconDir+$projectName+"_"+$fileName+"_OnK0.png";
		$buttonImageFileOnK1=$iconDir+$projectName+"_"+$fileName+"_OnK1.png";
		
		//Off K0 version
		select SelectorLayeredTexture;
		eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK0+"\"");
		delete asTempSolidTx;

		//add tint now, so that selection/keyed buttons (with blank space background) are also visible
		setAttr SelectorLayeredTexture.inputs[2].alpha 0.3;
		
		//Off K1 version
		setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
		setAttr SelectorFileNode.colorGain -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
		setAttr SelectorLayeredTexture.inputs[2].color -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
		eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK1+"\"");
		delete asTempSolidTx;
		
		//On K0 version
		setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
		setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
		setAttr SelectorLayeredTexture.inputs[2].color -type double3 $selColor[0] $selColor[1] $selColor[2];
		eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK0+"\"");
		delete asTempSolidTx;
		
		//On K1 version
		setAttr SelectorFileNode.colorOffset -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
		setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
		setAttr SelectorLayeredTexture.inputs[2].color -type double3 ($selColor[0]+$keyColor[0]) ($selColor[1]+$keyColor[1]) ($selColor[2]+$keyColor[2]);
		eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK1+"\"");
		delete asTempSolidTx;
		for ($q=0;$q<size($deleteObjs);$q++)
			if (`objExists $deleteObjs[$q]`)
				delete $deleteObjs[$q];
		}


	if (`control -q -ex $renderBoxes[$i]`)
		deleteUI $renderBoxes[$i];
	setParent asSelectorDefaultFormLayout;

	//Update cmd, popUp
	$alignFK2IKCmd=$alignIK2FKCmd=$switchFK2IKCmd=$switchIK2FKCmd="";
	if (`gmatch $renderBoxObjs[$i] "FKIK*"`)
		{
		$alignFK2IKCmd="asAlignFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$alignIK2FKCmd="asAlignIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchFK2IKCmd="asSwitchFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchIK2FKCmd="asSwitchIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		}
	$cmd="asSelect \"Default\" {\""+$ann+"\"};";
	if (`gmatch $ann "* *"`)
		{
		tokenize $ann $annBuffer;
		$cmd="asSelect \"Default\" {";
		for ($q=0;$q<size($annBuffer);$q++)
			{
			$cmd+="\""+$annBuffer[$q]+"\"";
			if ($q<size($annBuffer)-1)
				$cmd+=",";
			}
		$cmd+="};";
		}
	$keyCmd="asKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";
	$linearKeyCmd="asLinearKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";

	$buttonName=$renderBoxObjs[$i]+":"+$x+":"+$y;
	if ($haveBG)
		{
		iconTextButton -w $width -h $height -i $buttonImageFileOffK0 -iol $iol -c $cmd -ann $ann $buttonName;
		reloadImage $buttonImageFileOffK0 $buttonName;
		}
	else
		iconTextButton -w $width -h $height -bgc 0.4 0.4 0.4 -olc 0.4 0.4 0.4 -style textOnly -l $iol -iol $iol -c $cmd -ann $ann $buttonName;//completly invisible buttons are no good, give some default bgc
	if ($customColor)
		iconTextButton -e -bgc $bgc[0] $bgc[1] $bgc[2] -olc $bgc[0] $bgc[1] $bgc[2] $buttonName;

	formLayout -e -af $buttonName "left" $x -af $buttonName "top" $y asSelectorDefaultFormLayout;

	popupMenu -p $buttonName;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asLabelButton \""+$buttonName+"\"");
//		menuItem -l "Remove Button" -c ("asDeleteButton \""+$buttonName+"\"");
		if ($alignFK2IKCmd!="")
			{
			menuItem -d 1;
			menuItem -sm 1 -l "Align";
				menuItem -l "FK2IK" -c $alignFK2IKCmd;
				menuItem -l "IK2FK" -c $alignIK2FKCmd;
				setParent -menu ..;
			menuItem -sm 1 -l "Switch";
				menuItem -l "FK2IK" -c $switchFK2IKCmd;
				menuItem -l "IK2FK" -c $switchIK2FKCmd;
			}
	}


select $sel;
}

global proc asLabelButton (string $button)
{
string $return=`promptDialog -t "Label" -b "Ok"  -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
string $text=`promptDialog -q -tx`;
string $tempString[];

if ($return!="Ok")
	return;

iconTextButton -e -iol $text -l $text  $button;

tokenize $button ":" $tempString;
if (`objExists ("Button_"+$tempString[0])`)
	{
	if (!`attributeExists label ("Button_"+$tempString[0])`)
		addAttr -ln label -dt "string" ("Button_"+$tempString[0]);
	setAttr -type "string" ("Button_"+$tempString[0]+".label") $text;
	}

if ($text=="All")
	iconTextButton -e -ann "ControlSet" $button;
}
//-- ASSelectorDesigner Procedures Ends Here --//

//-- ASPoserDesigner Procedures Starts Here --//
global proc asPoserDesigner ()
{
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");
string $buttonImageFileExt="png";
int $nc=`optionVar -q asPoserNc`;
if ($nc<1)
	$nc=4;
int $nr=`optionVar -q asPoserNr`;
if ($nr<1)
	$nr=2;
string $poserText=`optionVar -q asPoserText`;
if ($poserText=="0")
	$poserText="Pose";
int $onlySel=`optionVar -q asPoserOnlySel`;
int $anim=`optionVar -q asPoserAnim`;
int $renderView=`optionVar -q asPoserRenderView`;
string $controlSets[]=`asGetControlSets`;

if (`window -q -ex asPoserDefault`)
	deleteUI asPoserDefault;
window -mb 1 -t "PoserDesigner :untitled" asPoserDefault;
menu "File";
	menuItem -c "evalDeferred asPoserDesigner" "New";
	menuItem -c "asfileBrowse Poser Open" "Open";
	menuItem -sm 1 -l "ControlSets" asPoserControlSetsMenu;
		menuItem -cb 1 -l ControlSet asPoserControlSetsMenuItemControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if ($controlSets[$i]!="ControlSet")
				menuItem -cb 0 -l $controlSets[$i] ("asPoserControlSetsMenuItem"+$controlSets[$i]);
		setParent -menu ..;
	menuItem -d 1;
	menuItem -c "asSave Poser" "Save";
	menuItem -c "asfileBrowse Poser SaveAs" "Save As";
	menuItem -c "astoShelf Poser" "Put on shelf";
	setParent -menu ..;
	menuItem -d 1;
	menuItem -c "deleteUI asPoserDefault" "Close";
	setParent -menu ..;
formLayout asPoserDefaultFormLayout;
	text -vis 0 -l (`asGetTempDirectory`+"AdvancedSkeleton/Poser/") asPoserProjectPath;
	text -vis 0 -l ("untitled") asPoserProjectName;
	rowLayout -adj 1 -nc 8 -cw 2 90 -cw 3 80 -cw 4 90 -cw 5 50 -cw 6 20 -cw 7 25 asPoserDefaultRowLayout;
		optionMenu asPoserDefaultOptionMenu;
		button -l "    New Pose    " -c "asNewPose {} 0";
		textField -w 70 -tx $poserText -cc asPoserUpdateGrid asPoserTextField;
		checkBox -v $onlySel -l "only selected" -cc asPoserUpdateGrid asPoserOnlySel;
		checkBox -v $anim -l "anim" -cc asPoserUpdateGrid asPoserAnim;
		intField -w 20 -v $nc -cc asPoserUpdateGrid asPoserNc;
		intField -w 20 -v $nr -cc asPoserUpdateGrid asPoserNr;
		checkBox -v $renderView -l "renderView" -cc asPoserUpdateGrid asPoserRenderView;
		setParent..;
//	scrollLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
//	cannot use scrollLayout cause it returns incorrect drop coordinates when scrolled.
	columnLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
		gridLayout -h (90*$nr) -nc $nc -nr $nr -cw 110 -ch 90 asPoserDefaultGridLayout;

formLayout -e
	-af asPoserDefaultRowLayout "top" 0
	-ac asPoserDefaultScrollayout "top" 0 asPoserDefaultRowLayout
	-af asPoserDefaultScrollayout "bottom" 0
	-af asPoserDefaultScrollayout "left" 0
	-af asPoserDefaultScrollayout "right" 0
	asPoserDefaultFormLayout;

asPopulateNameSpaceMenu "asPoserDefault";

//Remove Old Icons
string $oldFilesList[]=`getFileList -fld $iconDir`;
for ($file in $oldFilesList)
	sysFile -del ($iconDir+$file);

showWindow asPoserDefault;
}

global proc asNewPose (string $loadData[], int $anim)
{
global int $asfileLoading;
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $setParent=`setParent -q`;
string $uiName,$image,$label,$cmd,$mayaFile,$loadingMayaFile;
int $nc,$nr,$numTok,$singleAttr;
float $range[2]={0,1};
string $buffer[];
if ($loadData[0]=="" || $asfileLoading)
	{
	$nc=`intField -q -v asPoserNc`;
	$nr=`intField -q -v asPoserNr`;
	$uiName="asPoserDefault";
	}
else
	$uiName=$loadData[0];
string $ext="png";
string $gridOrder[]=`gridLayout -q -go ($uiName+"GridLayout")`;
int $lastFilled,$childNum;
//Find Last filled
for ($i=1;$i<size($gridOrder)+1;$i++)
	if (`gmatch $gridOrder[$i-1] "asPoser*"`)
		$lastFilled=$i;
$childNum=$lastFilled+1;

//Total full
if ($childNum>($nc*$nr) && $loadData[0]=="")
	error "Grid is full, extend rows or columns !\n";

if ($loadData[0]=="")
	{
	if (`optionMenu -q -v asPoserDefaultOptionMenu`=="None")
		error "No Character In The Scene\n";
	$anim=`checkBox -q -v asPoserAnim`;
	$cmd=`asPoserGetCmd $uiName $anim`;
	if ($cmd=="")
		error "No valid objects !\n";
	$image=`asPoserSnapShoot $uiName $childNum $anim 1 1`;
	if ($anim && $cmd!="")
		$cmd+=" "+$childNum;
	if (`about -mac`)
		showWindow asPoserDefault;
	$label=`textField -q -tx asPoserTextField`;
	}
else
	{
	$childNum=$loadData[4];
	$numTok=`tokenize $loadData[1] "/" $buffer`;
	$image=$iconDir+"untitled_"+$childNum+"."+$ext;
	sysFile -cp $image $loadData[1];
	$mayaFile=`substitute "[.][a-z][a-z][a-z]" $image ".ma"`;
	$loadingMayaFile=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".ma"`;
	if (`file -q -ex $loadingMayaFile`)
		sysFile -cp $mayaFile $loadingMayaFile;
	$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
	$loadingJpg=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".jpg"`;
	if (`file -q -ex $loadingJpg`)
		sysFile -cp $jpg $loadingJpg;
	$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
	$loadingAvi=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".avi"`;
	if (`file -q -ex $loadingAvi`)
		sysFile -cp $avi $loadingAvi;
	$label=$loadData[2];
	$cmd=$loadData[3];
	if ($asfileLoading)
		$cmd=`substitute $loadData[0] $cmd $uiName`;
	$anim=$loadData[5];
	}
$numTok=`tokenize $cmd ";" $buffer`;
if ($numTok==2)
	$singleAttr=1;
setParent ($uiName+"GridLayout");
columnLayout ($uiName+"ColumnLayout"+$childNum);
gridLayout -e -pos ($uiName+"ColumnLayout"+$childNum) $childNum ($uiName+"GridLayout");
rowColumnLayout -ann $anim -nc 2 -cw 1 100 -cw 2 15 ($uiName+"RowColumnLayout"+$childNum);
	iconTextButton -w 100 -h 75 -i $image -c $cmd ($uiName+"IconTextButton"+$childNum);
	floatSlider -m 0 -w 10 -h 75 -hr 0 ($uiName+"FloatSlider"+$childNum);
	text -h 15 -al "center" -fn "smallBoldLabelFont" -l $label ($uiName+"Text"+$childNum);
if ($anim)
	text -e -bgc 1 0 0 ($uiName+"Text"+$childNum);
if ($loadData[0]=="" || $asfileLoading)
	{
	asPoserupdateGridBlock $uiName $childNum;
	iconTextButton -e -dgc asPoserDgc -dpc asPoserDpc ($uiName+"IconTextButton"+$childNum);
	}

//connectControl
string $connectToObj,$connectToAttr,$resolvedDestination;
string $allKeyableAttrs[];
if ($singleAttr)
	{
	tokenize $cmd "\"" $buffer;
	tokenize $buffer[1]  $buffer;
	tokenize $buffer[0] "." $buffer;
	$connectToObj=$buffer[0];
	$connectToAttr=$buffer[1];
	$resolvedObj=`asPoserResolveNameSpace $uiName $connectToObj`;
	if (`objExists $resolvedObj`)
		$allKeyableAttrs=`listAttr -k -m -sn $resolvedObj`;

	for ($allKeyableAttr in $allKeyableAttrs)
		if ($connectToAttr==$allKeyableAttr)
			if (`getAttr -se ($resolvedObj+"."+$connectToAttr)`)
					{
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						if (!`attributeQuery -n $resolvedObj -re $connectToAttr`)
							break;
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						$range=`attributeQuery -n $resolvedObj -r $connectToAttr`;
					else
						//probably a muli attr  e.g. blenShape target..using range 0->1
						$range={0,1};
					floatSlider -ann ($connectToObj+"."+$connectToAttr) -e -m 1 -min $range[0] -max $range[1] ($uiName+"FloatSlider"+$childNum);
					connectControl ($uiName+"FloatSlider"+$childNum) ($resolvedObj+"."+$connectToAttr);
					text -e -l $connectToAttr ($uiName+"Text"+$childNum);
					}
	}
setParent $setParent;
}

global proc asPoserUpdateGrid ()
{
int $nc=`intField -q -v asPoserNc`;
optionVar -iv asPoserNc $nc;
int $nr=`intField -q -v asPoserNr`;
optionVar -iv asPoserNr $nr;
string $poserText=`textField -q -tx asPoserTextField`;
optionVar -sv asPoserText $poserText;
int $onlySel=`checkBox -q -v asPoserOnlySel`;
optionVar -iv asPoserOnlySel $onlySel;
int $anim=`checkBox -q -v asPoserAnim`;
optionVar -iv asPoserAnim $anim;
int $renderView=`checkBox -q -v asPoserRenderView`;
optionVar -iv asPoserRenderView $renderView;

if ($nc<1)
	{
	intField -e -v 1 asPoserNc;
	asPoserUpdateGrid;
	return;
	}
if ($nr<1)
	{
	intField -e -v 1 asPoserNr;
	asPoserUpdateGrid;
	return;
	}
gridLayout -e -nc $nc -nr $nr -w (110*$nc) -h (90*$nr) asPoserDefaultGridLayout;
}

global proc asPoserRename (int $childNum)
{
if (!`text -q -ex ("asPoserDefaultText"+$childNum)`)
	error "Cant find `text` uiElement\n";
string $oldname=`text -q -l ("asPoserDefaultText"+$childNum)`;
string $return=`promptDialog -m "Name:" -tx $oldname -t ("AdvancedSkeleton") -b "Ok" -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($return=="Cancel")
	return;
string $newName=`promptDialog -q -tx`;
text -e -l $newName ("asPoserDefaultText"+$childNum);
}

global proc asPoserDeletePose (string $uiName, int $num)
{
string $image=`iconTextButton -q -i ($uiName+"IconTextButton"+$num)`;
$jpgImage=`substitute "[.]png" $image ".jpg"`;
sysFile -del $image;
sysFile -del $jpgImage;

evalDeferred ("deleteUI "+$uiName+"ColumnLayout"+$num);
}

global proc string asPoserSnapShoot (string $uiName, int $childNum, int $anim, int $updateIcon, int $updateMovie)
{
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
int $renderView=`checkBox -q -v asPoserRenderView`;
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;

int $curFrame=`currentTime -q`;
int $startFrame=$endFrame=$curFrame;
int $currFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
string $huds[]=`headsUpDisplay -listHeadsUpDisplays`;
int $hudStates[];
for ($i=0;$i<size($huds);$i++)
	{
	$hudStates[$i]=`headsUpDisplay -q -vis $huds[$i]`;
	headsUpDisplay -e -vis 0 $huds[$i];
	}
string $ext="png";
setAttr "defaultRenderGlobals.imageFormat" 32;
string $fileName=$iconDir+"untitled_"+$childNum;
string $iconImage=$fileName+"."+$ext;
string $blastImage=$fileName+"."+`asDoPadd $curFrame 4`;
string $blastMovie=$fileName+".avi";
string $largeImage=$fileName+".jpg";
string $bgImageFile32=$iconDir+"untitled_background32."+$ext;
int $iconExists;
if (`file -q -ex $iconImage`)
	$iconExists=1;
		
if ($renderView && $updateIcon)
	{
	if (`renderWindowEditor -q -nim renderView`<0)
		error ("No Image In RenderView\n");
	eval ("renderWindowEditor -e -wi \""+$iconImage+"\" renderView");
	asPoserResizeImage 100 75 $iconImage $iconImage;
	setAttr defaultRenderGlobals.imageFormat 8;
	evalEcho ("renderWindowEditor -e -wi \""+$largeImage+"\" renderView");
	}
if (!$renderView && $updateIcon)
	{
	playblast -w 100 -h 75 -compression "png" -p 100 -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $iconImage ($blastImage+"."+$ext);
	}

setAttr defaultRenderGlobals.imageFormat 8;

if ($anim && $updateMovie)
	playblast -p 100 -st `playbackOptions -q -min` -et `playbackOptions -q -max` -f $fileName -fmt movie -fo -clearCache 0 -viewer 0 -showOrnaments 0;
else if ($updateIcon)
	{
	playblast -p 100 -compression "png" -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $largeImage ($blastImage+".jpg");
	}
setAttr defaultRenderGlobals.imageFormat $currFormat;
for ($i=0;$i<size($huds);$i++)
	headsUpDisplay -e -vis $hudStates[$i] $huds[$i];

//32x32
if (!`file -q -ex $bgImageFile32`)
	asPoserResizeImage 32 32 $iconImage $bgImageFile32;

if ($iconExists)
	reloadImage $iconImage ($uiName+"IconTextButton"+$childNum);
return $iconImage;
}

global proc asPoserResizeImage (int $x, int $y, string $inputImage, string $outputImage)
{
string $sel[]=`ls -sl`;
string $buttonImageFileExt="png";
string $uniqueFileName=`asUniqueFile $inputImage`;
string $fileNode=`createNode file`;
setAttr -type "string" ($fileNode+".fileTextureName") $uniqueFileName;
eval ("convertSolidTx -sp 1 -al 1 -rx "+$x+" -ry "+$y+" -n asTempSolidTx32 -fil \""+$buttonImageFileExt+"\" -fin \""+$outputImage+"\"");
delete $fileNode asTempSolidTx32;
sysFile -del $uniqueFileName;
select $sel;
}

global proc string asDoPadd (int $frameNr,int $padding)
{
string $frameName;
string $padd="";
string $neg="";
string $frameNrAsString=$frameNr;
for ($i=0;$i<$padding;$i++)
	$padd=$padd+"0";
//move the negative symbol to start of string//
if ($frameNr<0)
	$neg="-";
int $nr=`size ($frameNrAsString)`;
if ($padding>$nr)
	$frameName=$neg+`substring $padd ($nr+1) 999`+abs($frameNr);
else
	$frameName=$frameNr;
return $frameName;
}

global proc string[] asPoserDgc (string $dragControl, int $x, int $y, int $mods) 
{
string $return[];
$return[0]=$x;
$return[1]=$y;
$return[2]=$mods;
return $return;
}

global proc asPoserDpc (string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) 
{
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
if (`gmatch $dropControl "*IconTextButton*"`)
	return;
int $left=$msgs[0];
int $top=$msgs[1];

int $nc=`intField -q -v asPoserNc`;
int $nr=`intField -q -v asPoserNr`;
	
string $match=`match "[0-9]+$" $dragControl`;
int $oldChildNum=$match;
int $newRowNum=ceil(($x+0.00)/110);
int $newColNum=ceil(($y+0.00)/90);
int $newChildNum=$newRowNum+(($newColNum-1)*$nc);
if ($newChildNum==$oldChildNum)
	return;
if ($newChildNum>($nc*$nr))
	error "out of grid, extend rows or columns !\n";
string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
if (`gmatch $gridOrder[$newChildNum-1] "asPoser*"`)
	error "grid position is occupied !\n";
gridLayout -e -pos ("asPoserDefaultColumnLayout"+$oldChildNum) $newChildNum asPoserDefaultGridLayout;

//rename UI elements
string $children[]=`layout -q -ca ("asPoserDefaultColumnLayout"+$oldChildNum)`;
$children[size($children)]="asPoserDefaultColumnLayout"+$oldChildNum;
string $grandChildren[]=`layout -q -ca $children[0]`;
string $allChildren[]=`stringArrayCatenate $children $grandChildren`;
string $tempString[];
string $cmd;
int $numDigitsInIldChildNum=size($match);
int $numDigitsInChild;
int $numDigitsInImage;
string $newChildName,$image,$animFile,$newAnimFile;
string $ext="png";
for ($child in $allChildren)
	{
	$numDigitsInChild=size($child);
	string $newChildName=`substring $child 1 ($numDigitsInChild-$numDigitsInIldChildNum)`+$newChildNum;
	renameUI $child $newChildName;

	//rename bitmaps
	if (!`iconTextButton -q -ex $newChildName`)
		continue;
	$image=`iconTextButton -q -i $newChildName`;
	$numDigitsInImage=size($image);
	$newImage=`substring ("\""+$image+"\"") 2 ($numDigitsInImage-3-$numDigitsInIldChildNum)`+$newChildNum+"."+$ext;
	if (`file -q -ex $image` && $newImage!=$image)
		{
		eval ("sysFile -ren \""+$newImage+"\"  \""+$image+"\"");
		iconTextButton -e -i $newImage $newChildName;
		reloadImage $newImage $newChildName;
		$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		if (`file -q -ex $jpg`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".jpg"` `substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		if (`file -q -ex $avi`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".avi"` `substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		}
	//rename anim files
	$animFile=$iconDir+"untitled_"+$oldChildNum+".ma";
	$newAnimFile=$iconDir+"untitled_"+$newChildNum+".ma";
	if (`file -q -ex $animFile` && $newAnimFile!=$animFile)
		eval ("sysFile -ren \""+$newAnimFile+"\"  \""+$animFile+"\"");
	//update animation command
	$cmd=`iconTextButton -q -c $newChildName`;
	tokenize $cmd $tempString;
	if ($tempString[0]=="asLoadAttrs")
		{
		$cmd=$tempString[0]+" "+$tempString[1]+" "+$newChildNum;
		iconTextButton -e -c $cmd $newChildName;
		}
	}
string $uiName="asPoserDefault";
asPoserupdateGridBlock $uiName $newChildNum;
}
//-- ASPoserDesigner Procedures Ends Here --//
//-- ASWalkDesigner Procedures Start Here --//
global proc asWalkDesigner ()
{
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
//create, connectControl, and delete, to disable.
int $mixerExisted=1;
if (!`objExists WalkDesignerMotionMixer`)
	{
	createNode -n WalkDesignerMotionMixer transform;
	addAttr -k 1 -dv 1 -ln "speed" -at double WalkDesignerMotionMixer;
	$mixerExisted=0;
	}
if (`window -q -ex asWalkDesigner`)
	deleteUI asWalkDesigner;
window -mb 1 -t WalkDesigner asWalkDesigner;
formLayout asWDFormLayout;
columnLayout;
optionMenu -w 200 asWalkDesignerOptionMenu;
button -l "Start" -c asWDStart;
columnLayout asWDMixerColumnLayout;
for($i=0;$i<size($motions);$i++)
	{
	if(!$mixerExisted)
		addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	rowLayout -nc 2 -cw2 240 100;
		floatSliderGrp -label $motions[$i] -field true -cw 1 80 -cw 2 50 -cw 3 100 -min 0 -max 1 ("asWDField"+$i);
		connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
		button -l "solo" -c ("asWDSolo "+$i);
		setParent..;
	}
floatSliderGrp -cc asWDSpeedChange -pre 2 -v 1 -label "speed" -field true -cw 1 40 -cw 2 40 -cw 3 180 -min 0.01 -max 2 asWDSpeedField;
connectControl asWDSpeedField WalkDesignerMotionMixer.speed;
if (`asIsMayaLT`)
	floatSliderGrp -e -en 0 asWDSpeedField;
setParent..;

frameLayout -w 279 -cll 1 -cl 1 -l "Baking";
columnLayout;
//text -l "baking:";
checkBox -cc asWDSpeedChange -l "loop animation (curves > post infinity > cycle)" -v 1 -onc "intField -e -en 0 asWDLoopsIntField" -ofc "intField -e -en 1 asWDLoopsIntField" asWDLoopCheckBox;
text -l "or";
rowLayout -nc 3;
	text -l "loop animation";
	intField -cc asWDSpeedChange -en 0 -w 30 -min 1 -v 1 asWDLoopsIntField;
	text -l "times";
	setParent..;
button -l "Ok, Bake keys onto character" -c asWDBake;
setParent..;
setParent..;
setParent..;
button -l "Cancel and Close" -c asWDFinish asWDClose;
formLayout -e 
	-attachForm asWDClose "bottom" 0
	-attachForm asWDClose "left" 0
	-attachForm asWDClose "right" 0
	asWDFormLayout;

asPopulateNameSpaceMenu "asWalkDesigner";
if(!$mixerExisted)
	delete WalkDesignerMotionMixer;
showWindow;
}

global proc asWDBake ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
select -cl;
string $allFkControls[];
for($i=0;$i<size($consts);$i++)
	{
	string $fkControl=$nameSpace+"FK"+$consts[$i];
	if ($consts[$i]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	$allFkControls[size($allFkControls)]=$fkControl;
	select -add $fkControl;
	}

if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}

bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "rx" -at "ry" -at "rz";
select ($nameSpace+"RootX_M");
bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "tx" -at "ty" -at "tz";
if (`checkBox -q -v asWDLoopCheckBox`)
	{
	select $allFkControls;
	setInfinity -poi cycle;
	}
asWDFinish;
}

global proc asWDSpeedChange ()
{
if (!`objExists WalkDesignerMotionMixer` || !`objExists walkDesignerClip`)
	return;
float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);
if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr walkDesignerClip.scale (1.0/$speed);
}

global proc asWDStart ()
{
string $upAxisDirection=`upAxis -q -ax`;
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	error ("AdvancedSkeleton not found in your scene");
float $charHeight=`getAttr ($nameSpace+"Main.height")`;

string $motionFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asMotion.ma";
if (!`file -q -ex $motionFile`)
	error ("Not found:"+$motionFile);
if (`objExists WalkDesignerMotionMixer`)
	error ("\"WalkDesignerMotionMixer\", already exists, delete this object, before starting again");
if (!`file -q -ex $motionFile`)
	error ("Required motion file not found:\""+$motionFile+"\"");
string $tempString[]=`ls "asMotion:*"`;
if (size($tempString))
	delete $tempString;
if (`namespace -ex "asMotion"`)
	if (catchQuiet (`namespace -dnc -rm "asMotion"`))
		{ 
		//Maya2012 and older dont have namespace -dnc, so we work around the problems of empty nameSpaces not agknowlowdge their empty
		for($i=0;$i<99;$i++)
			if (!`namespace -ex ("tempNameSpace"+$i)`)
				break;
		namespace -ren asMotion ("tempNameSpace"+$i);
		}
if (`namespace -ex "asMotion"`)
	error "Unable to remove namespace \"asMotion\", try restarting Maya";

file -ns "asMotion" -i $motionFile;
setAttr asMotion:Group.v 0;
setAttr -type float3 asMotion:Group.s ($charHeight/12.0) ($charHeight/12.0) ($charHeight/12.0);

if ($upAxisDirection=="z")
	setAttr asMotion:Group.rx 90;

createNode -n WalkDesignerMotionMixer transform;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.tx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ty;setAttr -l 1 -k 0 WalkDesignerMotionMixer.tz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.rx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ry;setAttr -l 1 -k 0 WalkDesignerMotionMixer.rz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.sx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sy;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.v;
addAttr -k 1 -ln "speed" -dv 1 -at double WalkDesignerMotionMixer;
addAttr -k 0 -ln defaultEndTime -at double WalkDesignerMotionMixer;
parent "asMotion:Group" WalkDesignerMotionMixer;

select -hi "asMotion:Group";
select -d "asMotion:Group";
if (!`asIsMayaLT`)
	{
	character -name walkDesignerSet -excludeVisibility -excludeScale;
	clip -name walkDesignerClip -sc 1 -allAbsolute -animCurveRange walkDesignerSet;
	setAttr walkDesignerClip.postCycle 9999;
	}

if (`objExists ($nameSpace+"FKIKLeg_R")`) setAttr ($nameSpace+"FKIKLeg_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKLeg_L")`) setAttr ($nameSpace+"FKIKLeg_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_R")`) setAttr ($nameSpace+"FKIKArm_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_L")`) setAttr ($nameSpace+"FKIKArm_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKSpine_M")`) setAttr ($nameSpace+"FKIKSpine_M.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKShoulder_R")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_R")`) setAttr ($nameSpace+"FKShoulder_R.Global") 0;
if (`objExists ($nameSpace+"FKShoulder_L")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_L")`) setAttr ($nameSpace+"FKShoulder_L.Global") 0;
if (`objExists ($nameSpace+"FKWrist_R")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_R")`) setAttr ($nameSpace+"FKWrist_R.Global") 0;
if (`objExists ($nameSpace+"FKWrist_L")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_L")`) setAttr ($nameSpace+"FKWrist_L.Global") 0;
if (`objExists ($nameSpace+"FKHead_M")`) if (`attributeExists "Global"  ($nameSpace+"FKHead_M")`) setAttr ($nameSpace+"FKHead_M.Global") 0;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
string $orientConstraint,$pointConstraint;

for($i=0;$i<size($motions);$i++)
	{
	addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	for($y=0;$y<size($consts);$y++)
		{
		$fkControl=$nameSpace+"FK"+$consts[$y];
		if ($consts[$y]=="Root_M")
			{
			$fkControl=$nameSpace+"RootX_M";
			$tempString=`pointConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
			$pointConstraint=$tempString[0];
			}
		if (!`objExists $fkControl`)
			continue;
		$tempString=`orientConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
		$orientConstraint=$tempString[0];
		setAttr ($orientConstraint+".interpType") 2;

		if ($consts[$y]=="Root_M")
			{
			setAttr RootX_M_orientConstraint1.offsetX -90;
			setAttr RootX_M_orientConstraint1.offsetY -90;
			connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($pointConstraint+"."+$consts[$y]+"W"+$i);
			}
		connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($orientConstraint+"."+$consts[$y]+"W"+$i);
		}
	connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";
	setAttr ("FKHip"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKKnee"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKAnkle"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKToes"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKShoulder"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKElbow"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKWrist"+$side+"_orientConstraint1.offsetX") -90;
	}

connectControl asWDSpeedField WalkDesignerMotionMixer.speed;

if (`attributeExists walk_male WalkDesignerMotionMixer`)
	setAttr WalkDesignerMotionMixer.walk_male 1;
currentTime 0;
if (`objExists ($nameSpace+"FKAnkle_R")` && `objExists ($nameSpace+"Ankle")`)
	{
	float $anklePos[3]=`xform -q -ws -t ($nameSpace+"FKAnkle_R")`;
	float $fitAnklePos[3]=`xform -q -ws -t ($nameSpace+"Ankle")`;
	float $offset=$anklePos[1]-$fitAnklePos[1];
	setAttr asMotion:Group.ty ($offset*-1);
	}
float $tempFloats[]=`keyframe -index 1 -q  -tc asMotion:Group.timing`;
float $endTime=$tempFloats[0];
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr WalkDesignerMotionMixer.defaultEndTime $endTime;
select -cl;
}

global proc asWDSolo (int $num)
{
if (!`objExists WalkDesignerMotionMixer`)
	error ("WalkDesignerMotionMixer not found");
float $value;
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
for($i=0;$i<size($motions);$i++)
	{
	if ($i==$num)
		$value=1;
	else
		$value=0;
	floatSliderGrp -e -v $value ("asWDField"+$i);
	setAttr ("WalkDesignerMotionMixer."+$motions[$i]) $value;
	}
}

global proc asWDFinish ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

if (`objExists walkDesignerSet`)
	delete walkDesignerSet;
if (`objExists WalkDesignerMotionMixer`)
	delete WalkDesignerMotionMixer;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Chest_M","Chest_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $tempString[];
string $attrs[]={"tx","ty","tz","rx","ry","rz"};
for($y=0;$y<size($consts);$y++)
	{
	$fkControl=$nameSpace+"FK"+$consts[$y];
	if ($consts[$y]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	for($i=0;$i<size($attrs);$i++)
		{
		$tempString=`listConnections ($fkControl+"."+$attrs[$i])`;
		if (!size($tempString))
			setAttr ($fkControl+"."+$attrs[$i]) 0;
		}
	}
deleteUI asWalkDesigner;
}
//-- ASWalkDesigner Procedures Ends Here --//
//-- ASModelCleaner Procedures Starts Here --//
global proc asModelCleaner ()
{
if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

window -s 1 -title "Model Cleaner" modelCleaner;
columnLayout;
	separator -st none -h 10;
	text -l "This will cleanup your model.\n";
	if (!`pluginInfo -q -l objExport`)
		{
		text -l "The objExport plugin must be loaded:";
		button -l "load objExport plugin" -c "loadPlugin objExport;print (\"// OK, objExport plugin loaded\\n\")";
		separator -h 10 -st none;
		}
	text -l "Create top level group, called \"geo\":";
	button -c modelCleanGreateGeo -label "Create";
	separator -st none -h 10;
	text -l "Now ready for Clean.";
	text -fn "smallBoldLabelFont" -l "(Save your scene first, for safe keeping)\n";
	button -w 230 -c modelCleanGo -ann "clean model" -label "Clean";
showWindow modelCleaner;
}

global proc modelCleanGreateGeo ()
{
if (!`objExists |geo`)
	createNode -n geo transform;
string $tempString[];
string $topLevXforms[]=`ls -as -l`;
for($i=0;$i<size($topLevXforms);$i++)
	{
	if ($topLevXforms[$i]=="|geo")
		continue;
	$tempString=`listRelatives -s $topLevXforms[$i]`;
	if (`size ($tempString)`==0 || `objectType $tempString[0]`=="mesh")
		parent $topLevXforms[$i] |geo;
	}
select |geo;
}

global proc modelCleanGo ()
{
global string $gMainProgressBar;
global string $gMainPane;
string $sceneName=`file -q -sn`;
string $references[];
string $allReferences[]=`file -q -r`;
for ($i=0;$i<size($allReferences);$i++)
	if (!`file -q -deferReference $allReferences[$i]`)
		$references[size($references)]=$allReferences[$i];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

select -cl;

string $sceneFile=`file -q -sn`;
string $tmpFile=`asGetTempDirectory`+"AdvancedSkeleton/modelCleaner/tmp.ma";
if (`asIsMayaLT`)
	$tmpFile=`asGetTempDirectory`+"AdvancedSkeleton/modelCleaner/tmp.mlt";
int $eyeCandy=0;
int $moreThanOneWithSameName;
string $plugins[]=`pluginInfo -q -ls`;
string $parent[],$tempString[],$tempString2[],$longNames[],$buffer[],$oldShapeName[],$partitionPlugs[],$creaseMembers[],$objFileName[];
float $temp[];
float $perspPos[]=`getAttr persp.translate`;
float $perspRot[]=`getAttr persp.rotate`;
int $isGroup[];
int $doubleSided[];
for ($plug in $plugins)
	if (!`stringArrayCount "objExport" $plugins`)
	error "You Must Load the \"objExport\" plugin !";

string $tempDir=`asGetTempDirectory`+"AdvancedSkeleton/modelCleaner/";
if (!`file -q -ex $tempDir`)
	sysFile -md $tempDir;

//Pre Flight Check
if (!`objExists geo`)
	error "group \"geo\" does not exists !\n";
//string $all[]=`ls -noIntermediate`;
string $all[]=`ls`;
for ($obj in $all)
	{
	if (`gmatch $obj "*|*"`)
		{
		$tempString=`listRelatives -ap $obj`;
		if (size($tempString)==1)
			{
			select -add $obj;
			$moreThanOneWithSameName=1;
			}
		}
	}
if ($moreThanOneWithSameName)
	modelCleanMakeUniqueNames;
if (`objExists "polySurface1"`)
	{
	select "polySurface1";
	error "Illegal objectName \"polySurface1\"";
	}

//delete intermidiate meshes
$tempString=`ls -l -type mesh`;
for($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		{
		print ("Found intermediateObject mesh:\""+$tempString[$i]+"\" removing this.\n");
		delete $tempString[$i];
		}

//delete animCurves
$tempString=`ls -l -type animCurve`;
for($i=0;$i<size($tempString);$i++)
	{
	print ("Found animCurve:\""+$tempString[$i]+"\" removing this.\n");
	delete $tempString[$i];
	}

//delete imagePlanes
string $imagePlanes[]=`ls -type imagePlane`;
if (size($imagePlanes))
	delete $imagePlanes;

//delete displayLayers
string $displayLayers[]=`ls -type layer1`;
if (size($displayLayers))
	delete $displayLayers;

//delete unused refNodes
deleteUnusedRefNodes;

//unParent all place3dTextures
string $place3ds[]=`ls -type place3dTexture`;
for ($i=0;$i<size($place3ds);$i++)
{
$tempString=`listRelatives -p $place3ds[$i]`;
if(size($tempString))
	parent -w $place3ds[$i];
}

//remove old files
string $fileList[]=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Remove nameSpaces
$all=`ls -type transform`;
for ($i=0;$i<size($all);$i++)
    if (`gmatch $all[$i] "*:*"`)
        {
        tokenize $all[$i] ":" $tempString;
        rename $all[$i] $tempString[size($tempString)-1];
        }

//rename Shapes to match name of their Xform
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
    	$tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"TEMPShape");
    	}
$meshes=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
	    $tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"Shape");
    	}

DeleteAllHistory;

//remove objectSets, as these cause issues since the introduction of multi-uv support
string $objectSets[]=`ls -exactType objectSet`;
for ($i=0;$i<size($objectSets);$i++)
{
if (`gmatch $objectSets[$i] "default*"`)
	continue;
catchQuiet (`delete $objectSets[$i]`);
}

//createUVAssigner
if (`objExists uvAssign`) 
	delete uvAssign;
createNode -n uvAssign transform;
$meshes=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	if (`getAttr ($meshes[$i]+".intermediateObject")`)
		continue;
	$tempString=`listRelatives -p $meshes[$i]`;
	if (`objExists ($tempString[0]+"_UV")`)
		continue;
	duplicate -n ($tempString[0]+"_UV") $tempString[0];
	//if objs or grps was parented to mesh-obj, remove these from duplicate
	$tempString2=`listRelatives -f -c -type transform ($tempString[0]+"_UV")`;
	if (size($tempString2))
		delete $tempString2;
	parent ($tempString[0]+"_UV") uvAssign;
	}

//createShaderAssigner
string $assigned[], $shadingEngines[], $namespaces[];
string $allTrns[]=`ls -type transform`;
string $place3dTextures[]=`ls -type place3dTexture`;
if (`objExists shaderAssign`) 
	delete shaderAssign;
createNode -n shaderAssign transform;
addAttr -ln notes -dt "string" shaderAssign;
$shadingEngines=`ls -type shadingEngine`;
string $connections = ("global proc cleanConnectFileNodes(string $namespace1, string $namespace2) {\n");
for ($i=0;$i<size($shadingEngines);$i++) {
	if (`gmatch $shadingEngines[$i] "initial*"`)
		continue;
	$assigned=`sets -q $shadingEngines[$i]`;
	$assigned=`stringArrayRemoveDuplicates $assigned`;
	for ($z=0;$z<size($assigned);$z++) 
		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$assigned[$z]+"\")`);\n");
}
for ($z=0;$z<size($place3dTextures);$z++) {
	$tempString=`listConnections -p 1 ($place3dTextures[$z]+".worldInverseMatrix")`;
	$connections+=("catch(`connectAttr ($namespace2 + \"" +$place3dTextures[$z]+".worldInverseMatrix\") ($namespace1 + \""+$tempString[0]+"\")`);\n");
}
$connections += ("}\n");
setAttr -type "string" shaderAssign.notes $connections;

//exportShaders
/*
string $hyperShadePanelMelFile="C:/Program Files/Autodesk/Maya2012/scripts/others/hyperShadePanel.mel";
if (`file -q -ex$hyperShadePanelMelFile `)
eval ("source \""+$hyperShadePanelMelFile+"\"");
hyperShadePanelMenuCommand("", "deleteUnusedNodes");
*/
MLdeleteUnused;//delete unused
string $unKnownNodes[]=`ls -type unknown`;
for ($i=0;$i<size($unKnownNodes);$i++)
	catchQuiet (`delete $unKnownNodes[$i]`);
string $shadingNodes[]=`lsThroughFilter -na DefaultAllShadingNodesFilter`;
string $objectType;
select -cl;
for ($i=0;$i<size($shadingNodes);$i++)
	{
	$objectType=`objectType $shadingNodes[$i]`;
	if ($objectType=="camera" || `gmatch $objectType "*Light"`)
		continue;
	select -add -ne $shadingNodes[$i];
	}
select -add uvAssign shaderAssign;
lockNode -l 0 renderPartition;
if (`file -q -ex $tmpFile`)
	sysFile -del $tmpFile;
if (`asIsMayaLT`)
	file -op "v=0;" -typ "mayaLT" -es $tmpFile;
else
	file -op "v=0;p=17" -typ "mayaAscii" -es $tmpFile;

//delete intermediateObjects meshes
$tempString=`ls -intermediateObjects -type mesh`;
if (size($tempString))
	delete $tempString;

// SelectAllPolygonGeometry;
select geo;
select -hi;
string $selAll[]=`ls -l -sl -type transform`;

// read all attribute + their values, to restore after obj import
 string $userAttrs[],$addAttrCmds[];
string $cmd,$sn,$ln,$at,$kk,$dv,$minMax;
float $range[2];
string $shapes[];
string $selAllInclShapes[]=$selAll;
for ($i=0;$i<size($selAll);$i++)
	{
	$tempString=`listRelatives -s $selAll[$i]`;
	if (`objExists $tempString[0]`)
		$shapes[`size($shapes)`]=$tempString[0];
	}
appendStringArray $selAllInclShapes $shapes `size($shapes)`;
for ($i=0;$i<size($selAllInclShapes);$i++)
	{
 	$userAttrs=`listAttr -ud -s $selAllInclShapes[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		if (`getAttr -type ($selAllInclShapes[$i]+"."+$userAttrs[$y])`=="message")
			continue;
		$tempString=`listAttr -sn ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if (`gmatch $at "*Array"` || `gmatch $at "*dataCompound"`)
			continue;
		$dv=`getAttr ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$kk=`getAttr -k ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$l=`getAttr -l ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		$minMax="";
		if (`attributeQuery -re -n $selAllInclShapes[$i] $ln`)
			{
			$range=`attributeQuery -r -n $selAllInclShapes[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		if ($at=="string")
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -dt \""+$at+"\" "+$minMax+" "+$selAllInclShapes[$i]+";"
					+"setAttr -l "+$l+" -type \"string\" "+$selAllInclShapes[$i]+"."+$sn+" \""+`encodeString $dv`+"\";";
		else
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$selAllInclShapes[$i]+";";
		}
	}

// read smooth level
$shapes=`ls -ni -type mesh`;
for ($y=0;$y<size($shapes);$y++)
	{
	if (!`attributeExists "displaySmoothMesh" $shapes[$y]`)
		continue;
	if (!`getAttr -l ($shapes[$y]+".displaySmoothMesh")`)
		continue;
	$smoothLevel=`getAttr ($shapes[$y]+".smoothLevel")`;
	$smoothLock=`getAttr -l ($shapes[$y]+".smoothLevel")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$smoothLock+" "+$shapes[$y]+".smoothLevel "+$smoothLevel+";";
	$dispResolution=`getAttr ($shapes[$y]+".dispResolution")`;
	$displaySmoothMesh=`getAttr ($shapes[$y]+".displaySmoothMesh")`;
	$displaySmoothMeshLock=`getAttr -l ($shapes[$y]+".displaySmoothMesh")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr "+$shapes[$y]+".dispResolution "+$dispResolution+";";
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$displaySmoothMeshLock+" "+$shapes[$y]+".displaySmoothMesh "+$displaySmoothMesh+";";
	}

// select non-instanced geometry
select geo;
select -hi;
string $sel[]=`ls -sl -type transform`;
string $selLong[]=`ls -l -sl -type transform`;
string $selShort[]=$sel;
string $children[];

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "ObjExporting" -bp -ii 1 -min 0 -max (size($sel)) $gMainProgressBar;
for ($i=0;$i<size($sel);$i++)
{
	if (`progressBar -q -ic $gMainProgressBar`)
	{
		break;progressBar -e -ep $gMainProgressBar;
	}
	progressBar -e -s 1 $gMainProgressBar;

	if (`gmatch $obj "*:*"`)
		continue;

	if (`gmatch $selShort[$i] "*|*"`)
		{
		tokenize $selShort[$i] "|" $tempString;
		$selShort[$i]=$tempString[size($tempString)-1];
		}
	select $sel[$i];
	$tempString=`listRelatives -s $sel[$i]`;
	$oldShapeName[$i]=$tempString[0];

	$tempString=`listRelatives -ad -type transform $sel[$i]`;
	for ($a=0;$a<size($tempString);$a++)
		for ($y=0;$y<size($trs);$y++)
			for ($z=0;$z<size($xyz);$z++)
				setAttr -l 0 ($tempString[$a]+"."+$trs[$y]+$xyz[$z]);

	makeIdentity -a 1 -t 1 -r 1 -s 1 $sel[$i];
//		polySetToFaceNormal -setUserNormal;
	DeleteAllHistory;
	if (size(`ls -type nurbsCurve`))
		delete `ls -type nurbsCurve`;
	$tempString=`listRelatives -f -s $sel[$i]`;
	if (size($tempString)==0)
		$isGroup[$i]=1;
	$doubleSided[$i]=1;
	if (`objExists $tempString[0]`)
		if (`attributeExists doubleSided $tempString[0]`)
			$doubleSided[$i]=`getAttr ($tempString[0]+".doubleSided")`;
	$tempString=`listRelatives -p $sel[$i]`;
	if ($tempString[0]!="")
		$parent[$i]=$tempString[0];

	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		sysFile -del ($tempDir+$sel[$i]+".obj");
	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		print ("// Unable to delete "+$tempDir+$sel[$i]+".obj!\n");
	clear $children;
	$children=`listRelatives -f -type transform -c $sel[$i]`;
	if (size($children))
		$children=`parent -w $children`;
	select $sel[$i];
	$objFileName[$i]=`substituteAllString $selLong[$i] "|" "!"`;
	if (`gmatch $objFileName[$i] "!*"`)
		$objFileName[$i]=`substring $objFileName[$i] 2 999`;
	print ("// Exporting: "+$tempDir+$objFileName[$i]+".obj\n");
//		if ($eyeCandy)
//			FrameSelected;
	file -op "groups=0;ptgroups=0;materials=0;smoothing=1;normals=1;" -typ "OBJexport" -pr -es ($tempDir+$objFileName[$i]+".obj");
	if (size($children))
		parent $children $sel[$i];
}
progressBar -e -ep $gMainProgressBar;

//NewScene;
// select -all;delete;
string $filename = `file -q -exn`;
$mayaFileType = `file -q -type`;
file -f -new;
file -type $mayaFileType;
file -rn $filename;
setAttr -type float3 persp.translate $perspPos[0] $perspPos[1] $perspPos[2];
setAttr -type float3 persp.rotate $perspRot[0] $perspRot[1] $perspRot[2];
if ($eyeCandy)
	{
	setNamedPanelLayout "Single Perspective View";
	string $modelPanel=`paneLayout -q -p1 $gMainPane`;
	modelEditor -e -da "smoothShaded" $modelPanel;
	}

//Create groups
for ($i=0;$i<size($sel);$i++)
	if ($isGroup[$i])
		createNode -n $sel[$i] transform;

for ($i=0;$i<size($sel);$i++)
	{
	if ($isGroup[$i])
		{
		if (`objExists $parent[$i]`)
			parent $sel[$i] $parent[$i];
		continue;
		}
	print ("// importing: "+$tempDir+$objFileName[$i]+".obj\n");
	file -i -type "OBJ" -rpr "DUP" -options "mo=0;lo=1" ($tempDir+$objFileName[$i]+".obj");
	$existing[0]="polySurfaceShape1";
	if (!`objExists $existing[0]`)
		{
		warning ("No valid object created from:\""+$selShort[$i]+"\".");
		continue;
		}
	$tempString=`listRelatives -p $existing[0]`;
	rename $tempString[0] $selShort[$i];

	if (`objExists $parent[$i]`)
		parent ("|"+$selShort[$i]) $parent[$i];
	if (!$doubleSided[$i])
		setAttr ($sel[$i]+".doubleSided") $doubleSided[$i];
	select $sel[$i];
	if ($eyeCandy)
		FrameSelected;

	// restore original shape name
	if (`objExists $sel[$i]`)
		{
		$tempString=`listRelatives -s $sel[$i]`;
		if (`objExists $tempString[0]`)
			{
			setAttr ($tempString[0]+".visibleInReflections") 1;
			setAttr ($tempString[0]+".visibleInRefractions") 1;
			if ($tempString[0]!=$oldShapeName[$i])
				{
				print ("// Renaming "+$tempString[0]+" to "+$oldShapeName[$i]+"\n");
				rename $tempString[0] $oldShapeName[$i];
				}
			}
		}
	}

// restore added attributes
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

// restore bits in sets
if (`gmatch $sceneName "*/library/set/*"`)
	file -import -type "mayaAscii" -ra false -rpr "export" -options "v=0"  -pr -loadReferenceDepth "all" ($tempDir+"setReferences.ma");

//remove files
$fileList=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size($fileList);$i++)
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);

//Import & Assign texturess
file -i $tmpFile;
eval `getAttr shaderAssign.notes`;
cleanConnectFileNodes "" "";
delete shaderAssign;

//Assign UV`s (for multi-uv`s since obj format only allow for 1 uv-map)
$tempString=`listRelatives -c -type transform uvAssign`;
for($i=0;$i<size($tempString);$i++)
	{
	$tempString2[0]=`substitute "_UV" $tempString[$i] ""`;
	if (!`objExists $tempString2[0]`)
		continue;
	select $tempString[$i] $tempString2[0];
	transferAttributes -n tempXferUV -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 0;
	select $tempString2[0];
	DeleteHistory;
	}
delete uvAssign;

//set default UI
select -cl;
setNamedPanelLayout "Four View";
FrameAllInAllViews;

if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

print ("// Cleaning finished.\n");
}


global proc deleteUnusedRefNodes ()
{
string $allReferences[]=`file -q -r`;

string $realRefNodes[];
for ($y=0;$y<size($allReferences);$y++)
    $realRefNodes[size($realRefNodes)]=`file -q -rfn $allReferences`;
string $refNodes[]=`ls -type reference`;
for ($y=0;$y<size($refNodes);$y++)
    if (!`stringArrayCount $refNodes[$y] $realRefNodes`)
        {
        lockNode -l 0 $refNodes[$y];
        delete $refNodes[$y];
        }
}

global proc modelCleanMakeUniqueNames ()
{
SelectAllGeometry;
string $alls[]=`ls -sl`;
string $alls2[],$tempString[];
string $suffix;
int $clash;
for ($i=0;$i<size($alls);$i++)
    {
    $break=0;
    SelectAllGeometry;
    select -d $alls[$i];
    $alls2=`ls -sl -sn`;
    $suffix="";
    $clash=0;
    tokenize $alls[$i] "|" $tempString;
    $newName=$tempString[size($tempString)-1]+$suffix;
    for ($z=0;$z<size($alls2);$z++)
        {
        tokenize $alls2[$z] "|" $tempString;
        if ($newName==$tempString[size($tempString)-1])
            {
            for ($aa=0;$aa<999;$aa++)
            if (!`objExists ($newName+$aa)`)
                {
                print("// rename "+$alls[$i]+" "+$alls[$i]+"1\n");                
                rename $alls[$i] ($newName+$aa);
                $break=1;
                break;         
                }
            if ($break)
                break;
            }
        if ($break)
            break;
        }
    }
}
//-- ASModelCleaner Procedures Ends Here --//
//-- ASFace Procedures Starts Here --//
global proc asCreateFaceFitSkeleton ()
{
float $bb[];
string $sel[]=`ls -sl`;
string $tempString[];

//asFitModeEnsureShaders;
//if (`objExists FaceGroup`)
//	delete FaceGroup;
createNode -n FaceGroup transform;
//setAttr -l 1 FaceGroup.inheritsTransform 0;
asLockAttr FaceGroup 1 1 1 0;
if (`objExists "|Group"`)
	parent FaceGroup "|Group";
if (`objExists FaceFitSkeleton`)
	delete FaceFitSkeleton;
createNode -n FaceFitSkeleton -p FaceGroup transform;
asLockAttr FaceFitSkeleton 1 1 1 0;

asUpdateButtonEnables;
asFaceUpdateInfo 1;
select $sel;
}

global proc asFaceUpgradeFaceFitCheck ()
{
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
float $oldVersion,$faceScale;
string $geometry,$allFaceGeoString,$rightEye,$leftEye,$upperTeeth,$lowerTeeth,$tongue,$headJoint,$skinCluster;
string $rightPupil,$rightIris,$dialog;
string $tempString[];

if (`attributeExists version FaceGroup`)
	$oldVersion=`getAttr FaceGroup.version`;
else if (`objExists FaceFitSkeleton`)
	{//could be old Face-Fit, never built, so no version info stored
	if (`getAttr FaceFitSkeleton.ty`>1)
		$oldVersion=5.0;
	else
		return;
	}
else
	return;

if ($oldVersion>5.743)
	return;

$dialog=`confirmDialog -t "Confirm"
	-m "FaceFitSkeleton is from a older version.\nCreate New FaceFitSkeleton ?"
	-b "Yes" -db "Yes"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="Yes")
	error "FaceFitSkeleton is from a older version. Delete this, and create a new FaceFitSkeleton.";

if (`objExists FaceFitCheekRaiser`) delete FaceFitCheekRaiser;
if (`objExists FaceFitSmileBulge`) delete FaceFitSmileBulge;
if (`objExists FaceFitFrownBulge`) delete FaceFitFrownBulge;

if (`objExists FaceMotionSystem`)
	{
	if (!`getAttr FaceFitSkeleton.v`)
		asToggleFitFace;
	asDeleteAdvancedFace;
	}

$geometry=`getAttr FaceFitSkeleton.Geometry`;//changed in 5.743
$allFaceGeoString=`getAttr FaceFitSkeleton.AllFaceGeo`;//changed in 5.743
$rightEye=`getAttr FaceFitSkeleton.Eye_R`;//changed in 5.743
$leftEye=`getAttr FaceFitSkeleton.Eye_L`;//changed in 5.743
$upperTeeth=`getAttr FaceFitSkeleton.UpperTeeth`;
$lowerTeeth=`getAttr FaceFitSkeleton.LowerTeeth`;
$tongue=`getAttr FaceFitSkeleton.Tongue`;
$headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
$skinCluster=`getAttr FaceFitSkeleton.SkinCluster`;
$faceScale=`getAttr FaceFitSkeleton.sy`*1.5;
if (`attributeExists Pupil_R FaceFitSkeleton`)
	$rightPupil=`getAttr FaceFitSkeleton.Pupil_R`;
if (`attributeExists Pupil_R FaceFitSkeleton`)
	$rightIris=`getAttr FaceFitSkeleton.Iris_R`;

//OldFaceFitSkeletonHolder
createNode -n OldFaceFitSkeletonHolder transform;
$tempString=`listRelatives -c -type transform FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	parent $tempString[$i] OldFaceFitSkeletonHolder;
	//turn On .inheritsTransform
	$tempString2=`listRelatives -c -type transform $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		asLockAttr $tempString2[$y] 0 0 0 0;
	parent -w $tempString2;
	for ($y=0;$y<size($tempString2);$y++)
		setAttr ($tempString2[$y]+".inheritsTransform") 1;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $tempString[$i];
	parent $tempString2 $tempString[$i];
	}

delete FaceGroup;
select $geometry;
asChooseInput asFaceFaceTextField;

setAttr -type "string" FaceFitSkeleton.Face $geometry;
setAttr -type "string" FaceFitSkeleton.AllHead $allFaceGeoString;
setAttr -type "string" FaceFitSkeleton.RightEye $rightEye;
setAttr -type "string" FaceFitSkeleton.LeftEye $leftEye;
setAttr -type "string" FaceFitSkeleton.UpperTeeth $upperTeeth;
setAttr -type "string" FaceFitSkeleton.LowerTeeth $lowerTeeth;
setAttr -type "string" FaceFitSkeleton.HeadJoint $headJoint;
setAttr -type "string" FaceFitSkeleton.SkinCluster $skinCluster;

//temporarily use old version scale
addAttr -k 0 -ln faceScale -at double -dv $faceScale FaceFitSkeleton;

if ($rightPupil!="")
	{
	if (!catchQuiet (`eval select $rightPupil`))
		asCreateFaceFit Pupil "" 0 0 0 "asRedSG";
	}
if ($rightIris!="")
	{
	if (!catchQuiet (`eval select $rightIris`))
	asCreateFaceFit Iris "" 0 0 0 "asGreenSG";
	}
deleteAttr FaceFitSkeleton.faceScale;

$tempString=`listRelatives -c -type transform OldFaceFitSkeletonHolder`;
for ($i=0;$i<size($tempString);$i++)
	parent $tempString[$i] FaceFitSkeleton;
delete OldFaceFitSkeletonHolder;

$tempString=`listRelatives -ad -type transform FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*EyeBrowMiddle*"`)
		rename $tempString[$i] `substitute "EyeBrowMiddle" $tempString[$i] "EyeBrowCenter"`;

asFaceUpdateInfo 1;
error "FaceFitSkeleton updated.\nNext complete the \"Pre\" and \"Fit\" section, before building the FaceSetup.\n";
}

global proc asCreateFaceFitMask ()
{
global string $gMainProgressBar;
string $upAxisDirection=`upAxis -q -ax`;
float $faceScale;
float $bb[];
string $sel[]=`ls -sl`;
string $tempString[];

if ($upAxisDirection=="z")
	{
	confirmDialog -t "Z up"
	-m ("Z-up axis detected.\n"
		+"To add FaceSetup,\n"
		+"First go to the Preparation>Rig section, and turn  OFF \"Z up Axis\".\n"
		+"Once the FaceSetup is complete you can turn back ON \"Z up Axis\".")
	-b "OK" -db "OK";
	return;
	}

if (!`gmatch $sel[0] "*.f*"`)
	error "No poly-faces selected, The polygons of the characters`s face must be selected.";

string $m;
string $currentUnitLinear=`currentUnit -q -f`;
$m="Units currently set to: \""+$currentUnitLinear+"\"\nAdvancedSkeleton FaceSetup requires \"cm\".\nClick OK to switch";
if ($currentUnitLinear!="centimeter")
	{
	if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`=="Ok")
		currentUnit -l cm;
	else
		error "Unable to continue, AdvancedSkeleton FaceSetup requires \"cm\" as the WorkingUnit";
	}

createNode -n asSkipModelSymmetryCheck transform;
select $sel;
select `ls -sl -o`;
select `listRelatives -p`;
asModelChecker;
select -cl;

progressBar -e -st "Storing Mask" -bp -ii 1 -min 0 -max 9 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

$tempString=`listRelatives -s FaceFitSkeleton`;
if (size($tempString))
	delete $tempString;

select -cl;
$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] TempCircle;
parent -add -s TempCircleShape FaceFitSkeleton;
delete TempCircle;
rename TempCircleShape FaceFitSkeletonShape;
setAttr FaceFitSkeletonShape.overrideEnabled 1;
setAttr FaceFitSkeletonShape.overrideColor 13;
//scale -r -p 0 0 0 0.5 0.5 0.5 FaceFitSkeleton.cv[0:99];
rotate -r -p 0 0 0 -os 0 -90 0 FaceFitSkeleton.cv[0:99];
duplicate -n FaceFitSkeletonHeight FaceFitSkeleton;
duplicate -n FaceFitSkeletonCircle FaceFitSkeleton;
duplicate -n FaceFitSkeletonHeightCircle FaceFitSkeleton;
parent -add -s FaceFitSkeletonHeightShape FaceFitSkeleton;
parent -add -s FaceFitSkeletonCircleShape FaceFitSkeleton;
parent -add -s FaceFitSkeletonHeightCircleShape FaceFitSkeleton;
delete FaceFitSkeletonHeight FaceFitSkeletonCircle FaceFitSkeletonHeightCircle;
move -r -os 0 1.0 0 FaceFitSkeletonHeightShape.cv[0:99]  FaceFitSkeletonHeightCircleShape.cv[0:99];

if ($sel[0]!="")
	{
	select $sel;
	$bb=`xform -q -ws -bb`;
	$tempString=`listRelatives -s FaceFitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		scale -r -p 0 0 0 ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) ($bb[5]-$bb[2]) ($tempString[$i]+".cv[0:99]");
		move -r -os -wd 0 $bb[1] (($bb[2]+$bb[5])/2.0) ($tempString[$i]+".cv[0:99]");
		}
	//FaceFitSkeleton.faceScale
	$faceScale=$bb[4]-$bb[1];
	if (!`attributeExists faceScale FaceFitSkeleton`)
		addAttr -k 0 -ln faceScale -at double FaceFitSkeleton;
	setAttr FaceFitSkeleton.faceScale $faceScale;
	}

print "// Mask stored.\n";
}

global proc asFaceFitJawCurves ()
{
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`+1;
float $pos[],$posA[],$posB[],$posC[];
float $scale=`getAttr FaceFitSkeleton.faceScale`;
string $curveCmd;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[];

createNode -n FaceFitJawCurves -p FaceFitSkeleton transform;

//create Jaw weight-curves : JawCurve
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t Jaw`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurve;
setAttr JawCurveShape.overrideEnabled 1;
setAttr JawCurveShape.overrideColor 14;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 3 -d 3 -tol 0.01 JawCurve;
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t JawCurve.cv[1]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[1];
$posA=`xform -q -ws -t Cheek`;
$posB=`xform -q -ws -t JawCurve.cv[3]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[3];
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawCurve.cv[4]`;
xform -ws -t $posB[0] $posB[1] $posA[2] JawCurve.cv[4];
asCurveOffsetMesh JawCurve $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurve50
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t Cheek`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveMid;
setAttr JawCurveMidShape.overrideEnabled 1;
setAttr JawCurveMidShape.overrideColor 13;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 JawCurveMid;

asCurveOffsetMesh JawCurveMid $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveTop
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t NoseCorner`;
$posC=`xform -q -ws -t Cheek`;
$posD=`xform -q -ws -t CheekBone`;
$curveCmd+=" -p "+(($posA[0]+$posC[0])/2.0)+" "+(($posA[1]+$posD[1])/2.0)+" "+(($posA[2]+$posC[2])/2.0)+" ";
//$posA=`xform -q -ws -t CheekRaiser`;
$curveCmd+=" -p "+$posD[0]+" "+$posD[1]+" "+$posD[2]+" ";
$pos=`xform -q -ws -t NoseCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t NoseUnder`;
$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveTop;
setAttr JawCurveTopShape.overrideEnabled 1;
setAttr JawCurveTopShape.overrideColor 6;
asCurveOffsetMesh JawCurveTop $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveBottom
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCurve.cv[1]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+($pos[2]-($scale/20.0))+" ";
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$posB[0]+" "+$posA[1]+" "+($pos[2]-($scale/20.0))+" ";
$pos=`xform -q -ws -t Throat`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveBottom;
setAttr JawCurveBottomShape.overrideEnabled 1;
setAttr JawCurveBottomShape.overrideColor 6;
asCurveOffsetMesh JawCurveBottom $geometry ($scale/150.0);

parent JawCurve JawCurveMid JawCurveTop JawCurveBottom FaceFitJawCurves;

if (`checkBox -q -ex asFaceFitJawCurves`)
	checkBox -e -ed 1 -v 1 asFaceFitJawCurves;
select -cl;
}

global proc asFaceDesignMouthOpen ()
{
int $lowerLipMainNumCVs=`getAttr lowerLipMainCurve.spans`+1;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $lipCnrPercentage;
float $posA[]=`xform -q -ws -t lowerLipMainCurve.cv[0]`;
float $posB[]=`xform -q -ws -t lowerLipMainCurve.cv[$lowerLipMainNumCVs]`;
float $posC[],$posD[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $topVtx,$cnrVtx;
string $tempString[];

createNode -n LipDeformations -p FaceBuildInProgressHidden transform;
duplicate -n LipDeform templateLayer;
//setAttr LipDeform.v 1;
sets -e -forceElement initialShadingGroup LipDeform;
//setAttr LipDeform.tx $posA[0];

select -r LipDeform;
$tempString=`asDeformer softMod`;
rename $tempString[0] mouthOpenSoftMod;
rename $tempString[1] mouthOpenSoftModHandle;
$tempString=`listConnections mouthOpenSoftMod.message`;
rename $tempString[0] mouthOpenSoftModSet;
setAttr -type float3 mouthOpenSoftModHandleShape.origin $posA[0] $posA[1] $posA[2];
setAttr mouthOpenSoftMod.falloffCenter $posA[0] $posA[1] $posA[2];
xform -piv $posA[0] $posA[1] $posA[2] mouthOpenSoftModHandle;
setAttr mouthOpenSoftMod.falloffMode 1;
setAttr mouthOpenSoftMod.falloffRadius ((0-$posB[0])*2);

//topVtx pos before move softMod
createNode -n closestSampler2 closestPointOnMesh;
connectAttr -f LipDeform.outMesh closestSampler2.inMesh;
$posA=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
setAttr -type float3 closestSampler2.inPosition $posA[0] $posA[1] $posA[2];
$topVtx="LipDeform.vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]";
$posA=`xform -q -ws -t $topVtx`;
setAttr -type float3 closestSampler2.inPosition $posB[0] $posB[1] $posB[2];
$cnrVtx="LipDeform.vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]";
$posC=`xform -q -ws -t $cnrVtx`;
delete closestSampler2;

setAttr mouthOpenSoftModHandle.ty ($scale/-10.0);
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 1;

//increase radius, until topVtx is included
setAttr mouthOpenSoftMod.falloffRadius 0;
$posA=`xform -q -ws -t $topVtx`;
float $radius=(0-$posB[0])*2;
setAttr mouthOpenSoftMod.falloffRadius $radius;
for ($i=0;$i<99;$i++)
	{
	$posB=`xform -q -ws -t $topVtx`;
	if ($posB[1]-$posA[1]!=0)
		break;
	$radius+=($scale/1000.0)*$i;
	setAttr mouthOpenSoftMod.falloffRadius $radius;
	}
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 0.05;
setAttr "mouthOpenSoftMod.falloffCurve[0].falloffCurve_FloatValue" 0.95;

//Determine % at which the lipCnr is at (as this might not be excatly at 50%)
$posD=`xform -q -ws -t $cnrVtx`;
$lipCnrPercentage=1.0-(($posC[1]-$posD[1])/($scale/10.0));

setAttr "mouthOpenSoftMod.falloffCurve[2].falloffCurve_Position" $lipCnrPercentage;
setAttr "mouthOpenSoftMod.falloffCurve[2].falloffCurve_FloatValue" 0.5;

//updated for rounder shape
setAttr "mouthOpenSoftMod.falloffCurve[3].falloffCurve_Position" ($lipCnrPercentage-0.15);
setAttr "mouthOpenSoftMod.falloffCurve[3].falloffCurve_FloatValue" 0.8;

setAttr "mouthOpenSoftMod.falloffCurve[4].falloffCurve_Position" ($lipCnrPercentage+0.15);
setAttr "mouthOpenSoftMod.falloffCurve[4].falloffCurve_FloatValue" 0.2;

for ($i=0;$i<5;$i++)
	setAttr ("mouthOpenSoftMod.falloffCurve["+$i+"].falloffCurve_Interp") 3;

//Delete `all-except-lips` from LipDeform
select lipArea;
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString LipDeform`;
$tempString=`ls -sl -fl`;
ConvertSelectionToContainedFaces;
//InvertSelection;
asInvertSelection;
delete;

setAttr mouthOpenSoftModHandle.ty 0;
parentConstraint -mo Jaw_M mouthOpenSoftModHandle;
scaleConstraint -mo Jaw_M mouthOpenSoftModHandle;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;

setKeyframe -v 0 -t 0 ctrlMouth_M.ty;setKeyframe -v -1 -t 30 ctrlMouth_M.ty;

setKeyframe -v 0 -t 0 Jaw_M.ty;setKeyframe -v -0.5 -t 30 Jaw_M.ty;
setKeyframe -v 0 -t 0 Jaw_M.tz;setKeyframe -v 0.5 -t 30 Jaw_M.tz;
setKeyframe -v 0 -t 0 Jaw_M.rx;setKeyframe -v 15 -t 30 Jaw_M.rx;

setKeyframe -v 1 -t 0 Jaw_M.sx;setKeyframe -v 1 -t 0 Jaw_M.sx;
setKeyframe -v 1 -t 0 Jaw_M.sy;setKeyframe -v 1 -t 0 Jaw_M.sy;
setKeyframe -v 1 -t 0 Jaw_M.sz;setKeyframe -v 1 -t 0 Jaw_M.sz;

setAttr -l 1 Jaw_M.tx;
setAttr -l 1 Jaw_M.ry;
setAttr -l 1 Jaw_M.rz;
}

global proc asFaceAssist (string $section)
{
int $spans,$degree,$numCVs;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $posA[],$posB[];
string $tempString[];
string $sel[]=`ls -sl`;
string $leftSuffix;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $part="Main";
if ($section=="Lip") $part="Outer";
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSymSide`=="Left")
		$leftSuffix="Left";

if (`objExists upperTempSoftModHandle`)
	{
	delete upperTempSoftModHandle;
	if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;
	print "// assist removed.\n";
	return;
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$spans=`getAttr ($upperLower+$section+$part+"Curve.spans")`;
	$degree=`getAttr ($upperLower+$section+$part+"Curve.degree")`;
	$numCVs=$spans+$degree;
	$middleCvNr=($numCVs-1)/2;
	$posA=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+$middleCvNr+"]")`;
	if ($section=="Lip")
		$posA=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv[0]")`;
	$posB=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+($numCVs-1)+"]")`;
	if ($leftSuffix=="Left")
		{
		$posA[0]=$posA[0]*-1;
		$posB[0]=$posB[0]*-1;
		}
	select -r $geometry;
	$tempString=`asDeformer softMod`;
	rename $tempString[0] ($upperLower+"TempSoftMod");
	rename $tempString[1] ($upperLower+"TempSoftModHandle");
	setAttr -type float3 ($upperLower+"TempSoftModHandleShape.origin") $posA[0] $posA[1] $posA[2];
	setAttr ($upperLower+"TempSoftMod.falloffCenter") $posA[0] $posA[1] $posA[2];
	xform -piv $posA[0] $posA[1] $posA[2] ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffMode") 1;
	setAttr ($upperLower+"TempSoftMod.falloffRadius") `abs($posA[0]-$posB[0])`;
	move -r 0 ($scale/30.0*$upperLowerFactor) ($scale/10.0) ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_FloatValue") 1;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Position") 0.5;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Interp") 2;
	}
select $sel;
print "// assist added.\n";
}

global proc asCreateFaceFit (string $section,string $part,int $upAndLo,int $mainAndOuter,int $isSphere,string $shadingGroup)
{
int $nr,$sideVtxNr,$topVtxNr,$noseVtxNr,$lidInnerVtxNr,$lidOuterVtxNr,$numSel,$previousNumSel,$condition,$hitRighLowerStartVtx,$numNeighOnCurve,$rigTypeInt;
int $upperRightNumLipCvs,$upperLeftNumLipCvs,$lowerRightNumLipCvs,$lowerLeftNumLipCvs,$numVtxSelected;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $selectionNeeded=1;
int $selCompNrs[];
float $dist,$dist2,$maxDist,$minPosX,$maxPosX,$maxPosY,$falloffRadius,$tol,$maxPosY,$scale,$parameter;
float $pos[],$posA[],$posB[],$selPosX[],$selPosY[],$bb[];
string $upperLower,$growStartPos,$areaMeshShader,$closestSampler,$nearestVtx,$leftSuffix,$righLowerStartVtx;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$borderVtxs[],$edgesLidInnerNose[],$edgesNoseTop[];
string $edgesTopSide[],$edgesSideLidOuter[],$lipStartVtxs[],$selVtxs[],$leftLipSelection[],$deadEndVtxs[],$vtxs[],$previousVtxs[],$prevVtxs[],$vtxs1[],$vtxs2[];
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSymSide`=="Left")
		$leftSuffix="Left";
if (`objExists asRunningFaceLipLeft`)
	$leftSuffix="Left";
if (`attributeExists RigType FaceFitSkeleton`)
	$rigTypeInt=`getAttr FaceFitSkeleton.RigType`;

if (`objExists ("FaceFit"+$section+$part+$leftSuffix)`)
	error ("FaceFit"+$section+$part+$leftSuffix+" Already Exists");

if (!`attributeExists faceScale FaceFitSkeleton`)
	error "Mask not defined. Choose \"Mask\" in the Pre section, by selecting polygons.";
$scale=`getAttr FaceFitSkeleton.faceScale`;

if ($section=="EyeBall")
	{
	asBuildFitEyeBall;
	return;
	}

if ($section=="Tongue" || $section=="UpMidLo")
	{
	$selectionNeeded=0;
	select -cl;
	}

if ($section=="UpMidLo" && $rigTypeInt==1)
	{
	confirmDialog -t "Confirm" -m ("Rig-type is set to: \""+`getAttr -asString FaceFitSkeleton.RigType`+"\" this does not work with UpMidLo") -b "OK";
	return;
	}

string $sel[]=`ls -sl -fl`;
int $numSelEdges[];
if (!`gmatch $sel[0] "*[.]*"` && $selectionNeeded)
	{
	error "No edge or vertex selected";
	$numSelEdges=`polyEvaluate -edgeComponent`;
	}

if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

int $edgeSelection,$vertexSelection,$faceSelection,$startVtxSelected,$endVtxSelected;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*[.]e*"`)
		$edgeSelection=1;
	if (`gmatch $sel[$i] "*[.]f*"`)
		$faceSelection=1;
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		{
		$vertexSelection=1;
		if ($startVtxSelected)
			$endVtxSelected=1;
		$startVtxSelected=1;
		$numVtxSelected++;
		}
	}

if (!$isSphere && !$edgeSelection && !$faceSelection && !$vertexSelection && $selectionNeeded)
		error "No edges selected";

if ($section=="Lip" && $numVtxSelected!=0 && $numVtxSelected!=3)
	error ("Lip Vertex Selection detected, but "+$numVtxSelected+" vertices was selected, it should be 3 as shown here: "
		+"https://youtu.be/kz4NaLGMtQg?t=556");


if ($section=="Jaw" && `objExists FKJaw_M`)
	if (!`asFaceRemoveBodyJaw`)
		return;

asFitModeEnsureShaders;

spaceLocator -n templateLoc;
setAttr -type float3 templateLocShape.localScale (0.035*$scale) (0.035*$scale) (0.035*$scale);
setAttr templateLocShape.overrideEnabled 1;
setAttr templateLocShape.overrideColor 17;

createNode -n ("FaceFit"+$section+$part+$leftSuffix) -p FaceFitSkeleton transform;
//setAttr ("FaceFit"+$section+$part+$leftSuffix+".inheritsTransform") 0;
//addAttr -k 1 -min 0 -dv 1 -ln radius -at double ("FaceFit"+$section+$part+$leftSuffix);
if ($section=="EyeBrow")
	setAttr ("FaceFit"+$section+$part+$leftSuffix+".radius") 2.5;
createNode -n ("FaceFit"+$section+$part+"Geo"+$leftSuffix) -p ("FaceFit"+$section+$part+$leftSuffix) transform;
//if (!$isSphere)
//	setAttr ("FaceFit"+$section+$part+"Geo"+$leftSuffix+".inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Curve"+$leftSuffix) -p ("FaceFit"+$section+$part+$leftSuffix) transform;
//setAttr ("FaceFit"+$section+$part+"Curve"+$leftSuffix+".inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Loc"+$leftSuffix) -p ("FaceFit"+$section+$part+$leftSuffix) transform;

if ($isSphere)
	{
	duplicate -n ($section+$leftSuffix) templateLoc;
	parent ($section+$leftSuffix) ("FaceFit"+$section+$part+"Loc"+$leftSuffix);

	sphere -n ($section+"Sphere"+$leftSuffix) -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (0.02*$scale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0;
	parent ($section+"Sphere"+$leftSuffix) ("FaceFit"+$section+$part+"Geo"+$leftSuffix);
	connectAttr ($section+$leftSuffix+".t") ($section+"Sphere"+$leftSuffix+".t");
	connectAttr ($section+$leftSuffix+".r") ($section+"Sphere"+$leftSuffix+".r");
	connectAttr ($section+$leftSuffix+".s") ($section+"Sphere"+$leftSuffix+".s");
	setAttr ($section+"Sphere"+$leftSuffix+"Shape.overrideEnabled") 1;
	setAttr ($section+"Sphere"+$leftSuffix+"Shape.overrideDisplayType") 2;

	addAttr -k 1 -min 0 -dv 1 -ln "falloffRadius" -at double ($section+$leftSuffix);
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($section+$leftSuffix);
	}

if (`checkBox -q -ex ("asFaceFit"+$section+$part)`)
	checkBox -e -ed 1 -v 1 ("asFaceFit"+$section+$part);

if ($section=="Tongue")
	{
	$pos=`xform -q -ws -t FaceFitSkeleton`;
	$tempString[0]=`curve -d 1 
		-p 0 ($pos[1]+$scale/10.0) 0
		-p 0 ($pos[1]+$scale/5.0) ($scale/5.0)
		-p 0 ($pos[1]+$scale/5.0) ($scale/3.0)
		-p 0 ($pos[1]+$scale/5.5) ($scale/2.5)
		-p 0 ($pos[1]+$scale/7.0) ($scale/2.2)`;
	rename $tempString[0] TongueCurve;
	parent TongueCurve FaceFitTongueCurve;
	setAttr TongueCurve.inheritsTransform 0;
//	setAttr TongueCurveShape.dispCV 1;
	setAttr TongueCurveShape.overrideEnabled 1;
	setAttr TongueCurveShape.overrideColor 13;//Yellow
	for ($i=0;$i<5;$i++)
		{
		duplicate -n ("Tongue"+$i) templateLoc;
		parent ("Tongue"+$i) FaceFitTongueLoc;
		$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i);
		connectAttr -f ("Tongue"+$i+"Shape.worldPosition[0]") ("TongueCurveShape.controlPoints["+$i+"]");
		}
	select -cl;
	for ($i=0;$i<5;$i++)
		select -add ("Tongue"+$i);
	//autoplace
	if ($tongue!="")
		{
		eval ("select "+$tongue);
		$bb=`xform -q -ws -bb`;
		for ($i=0;$i<5;$i++)
			xform -ws -t 0 (($bb[1]+$bb[4])/2.0) ($bb[2]+((($bb[2]+$bb[5])/6.0)*$i)) ("Tongue"+$i);
		}
	}
if ($section=="UpMidLo")
	{
	duplicate -n upperFace templateLoc;
	parent upperFace FaceFitUpMidLoLoc;
	setAttr upperFaceShape.localScale -type float3 ($scale/2.0) 0 0;
	$pos=`xform -q -ws -t JawPivot`;
	$bb=`xform -q -ws -bb lowerEyeLidOuterCurve`;
	xform -ws -t 0 $bb[1] $pos[2] upperFace;
	asLockAttr upperFace 1 1 1 0;
	setAttr -l 0 -k 1 upperFace.ty;
	setAttr -l 0 -k 1 upperFace.tz;
	duplicate -n middleFace upperFace;
	duplicate -n lowerFace upperFace;
	setAttr lowerFace.ty `getAttr NoseUnder.ty`;
	setAttr middleFace.ty ((`getAttr upperFace.ty`+`getAttr lowerFace.ty`)/2.0);
	select -cl;
	}

delete templateLoc;

if ($edgeSelection || $vertexSelection || $faceSelection)
	{
	addAttr -ln selection -dt "string" ("FaceFit"+$section+$part+$leftSuffix);
	$tempString[0]="";
	for ($i=0;$i<size($sel);$i++)
		$tempString[0]=$tempString[0]+$sel[$i]+" ";
	setAttr -type "string" ("FaceFit"+$section+$part+$leftSuffix+".selection") $tempString[0];
	}

//EdgeSelection based placement
if (!$edgeSelection && !$vertexSelection)
	return;

int $around;
float $minPos[3]={999,999,999};
float $maxPos[3]={-999,-999,-999};
string $minXVtx,$maxXVtx,$minYVtx,$maxYVtx,$minZVtx,$maxZVtx;

if ($isSphere)
	{
	for ($i=0;$i<size($sel);$i++)
		{
		if (!$vertexSelection && `gmatch $sel[$i] "*[.]e*"`)
			{
			select $sel[$i];ConvertSelectionToVertices;$tempString=`ls -sl`;
			$pos=`xform -q -ws -t $tempString[0]`;
			}
		if ($vertexSelection && `gmatch $sel[$i] "*[.]vtx*"`)
			$pos=`xform -q -ws -t $sel[$i]`;
		}
	if ($section=="Nose" || $section=="Jaw" || $section=="ChinCrease" || $section=="NoseUnder" || $section=="Throat")
		$pos[0]=0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part+$leftSuffix);
	sets -e -forceElement $shadingGroup ($section+"Sphere"+$leftSuffix);
	select -cl;
	return;
	}

select $sel;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;

if ($section=="Lip" && $part=="Outer")//special case, Outer Lip: deselect `lowest half` of vtx, to ensure $maxXVtx not found on lowerLip
	asFaceDeselectLowestHalfOfVtx;

if (`gmatch $section "*Line"`)
	{
	for ($y=0;$y<size($tempString);$y++)
		{
		$pos=`xform -q -ws -t $tempString[$y]`;
		if ($leftSuffix=="") if ($pos[0]>0.001) select -d $tempString[$y];
		if ($leftSuffix=="Left") if ($pos[0]<-0.001) select -d $tempString[$y];
		}
	$tempString=`ls -sl -fl`;
	}

$tol=0.001;
if ($leftSuffix=="Left")
	$tol=9999;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	if ($pos[0]<$minPos[0]) {$minPos[0]=$pos[0];$minXVtx=$tempString[$y];}
	if ($pos[1]<$minPos[1]) {$minPos[1]=$pos[1];$minYVtx=$tempString[$y];}
	if ($pos[2]<$minPos[2]) {$minPos[2]=$pos[2];$minZVtx=$tempString[$y];}
	if ($pos[0]>$maxPos[0] && $pos[0]<$tol) {$maxPos[0]=$pos[0];$maxXVtx=$tempString[$y];}
	if ($pos[1]>$maxPos[1] && $pos[0]<$tol) {$maxPos[1]=$pos[1];$maxYVtx=$tempString[$y];}
	if ($pos[2]>$maxPos[2] && $pos[0]<$tol) {$maxPos[2]=$pos[2];$maxZVtx=$tempString[$y];}
	}
for ($y=0;$y<size($tempString);$y++)
	{
	select $tempString[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $tempString[$y];
	$tempString2=`ls -sl -fl`;
	$numNeighOnCurve=0;
	for ($z=0;$z<size($tempString2);$z++)
		{
		$numNeighOnCurve+=`stringArrayCount $tempString2[$z] $tempString`;
		}
	if ($numNeighOnCurve<2)
		$deadEndVtxs[size($deadEndVtxs)]=$tempString[$y];
	}

//special case, LipMain, cleanup assist
if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

string $startVtx=$maxXVtx;
string $endVtx=$minXVtx;
if ($leftSuffix=="Left")
	{
	$startVtx=$minXVtx;
	$endVtx=$maxXVtx;
	}
if (`objExists asRunningFaceLipLeft`)
	{
	$startVtx=`getAttr asRunningFaceLipLeft.startVtx`;
	$endVtx=`getAttr asRunningFaceLipLeft.endVtx`;
	}
if (`gmatch $section "*Line"`)
	{
	$posA=`xform -q -ws -t $deadEndVtxs[0]`;
	$posB=`xform -q -ws -t $deadEndVtxs[1]`;
	if ($posA[1]>$posB[1]) {$startVtx=$deadEndVtxs[0];$endVtx=$deadEndVtxs[1];}
	if ($posA[1]<$posB[1]) {$startVtx=$deadEndVtxs[1];$endVtx=$deadEndVtxs[0];}
	}

if ($section=="Pupil" || $section=="Iris")
	$endVtx="";

//fake a `spesified vtx`, for `Main` & `Inner`
$alignWithCurve="upper"+$section+"OuterCurve";
if (($part=="Main" || $part=="Inner") && `objExists $alignWithCurve` && !$startVtxSelected)
	{
	//changed from sampling closest to OuterCurveCorner, to attempt equal upper/lower
/*
	$closestSampler=`createNode -n closestSampler closestPointOnMesh`;
	connectAttr ($geometry+".outMesh") ($closestSampler+".inMesh");
	$posA=`xform -q -ws -t ($alignWithCurve+".cv[0]")`;
	setAttr -type float3 ($closestSampler+".inPosition") $posA[0] $posA[1] $posA[2];
	string $outerStartVtx=$geometry+".vtx["+`getAttr ($closestSampler+".result.closestVertexIndex")`+"]";
	delete $closestSampler;
	float $closestDist=999;//$closestDist is numEdges to reach
	select $sel;
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl -fl`;
	for ($i=0;$i<size($loopVtxs);$i++)
		{
		select $loopVtxs[$i];
		for ($y=0;$y<10;$y++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d $loopVtxs[$i];
			$tempString=`ls -sl -fl`;
			for ($z=0;$z<size($tempString);$z++)
				{
				if ($tempString[$z]==$outerStartVtx)
					{
					if ($y<$closestDist)
						{
						$startVtx=$loopVtxs[$i];
						$closestDist=$y;
						}
					break;
					}
				}
			}
		}
	select $sel;
	select -add $startVtx;
	$startVtxSelected=1;
	$sel=`ls -sl -fl`;//Update $sel, as if the vtx was selected to start with
*/
	}

//$startVtx(& end) spesified as a vtx selected ( For EyeLid )
if ($section=="EyeLid")
	{
	for ($i=0;$i<size($sel);$i++)
		if (`gmatch $sel[$i] "*[.]vtx*"`)
			{
			if ($startVtx!="" && $endVtxSelected)
				$endVtx=$startVtx;
			if ($startVtxSelected)
				$startVtx=$sel[$i];
			}
	//Ensure start&end are not swapped
	if ($startVtx!="" && $endVtx!="")
		{
		$posA=`xform -q -ws -t $startVtx`;
		$posB=`xform -q -ws -t $endVtx`;
		$condition=0;
		if ($posA[0]<$posB[0]) $condition=1;
		if ($leftSuffix=="Left") $condition=!$condition;
		if ($condition)
			{
			$tempString[0]=$startVtx;
			$startVtx=$endVtx;
			$endVtx=$tempString[0];
			}
		}
	$around=0;
	if ($startVtx!="")
		{
		//find new $endVtx, by traversing the edge-selection
		select $startVtx;
		for ($y=0;$y<99;$y++)
			{
			ConvertSelectionToEdges;
			$tempString=`ls -sl -fl`;
			for ($z=0;$z<size($tempString);$z++)
				if (!`stringArrayCount $tempString[$z] $sel`)
					select -d $tempString[$z];
			if (size(`ls -sl -fl`)==$numSelEdges[0])
				$around=1;
			
			ConvertSelectionToVertices;
			$vtxs=`ls -sl -fl`;

			if ($around)
				{
				select $vtxs;
				select -d $previousVtxs;
				$tempString=`ls -sl -fl`;
				$endVtx=$tempString[0];
				break;
				}
			$previousVtxs=$vtxs;
			}
		}
	}

// mouth corner spesified as a vtx selected, this ( For Lip )
$minPosX=999;
$maxPosX=-999;
$maxPosY=-999;
if ($section=="Lip")
	{
	if (`objExists asRunningFaceLipLeft`)
		{
		$startVtx=`getAttr asRunningFaceLipLeft.startVtx`;
		$lipStartVtxs[0]=`getAttr asRunningFaceLipLeft.startVtx`;
		$lipStartVtxs[1]=`getAttr asRunningFaceLipLeft.righLowerStartVtx`;
		}
	else
		{
		for ($i=0;$i<size($sel);$i++)
			if (`gmatch $sel[$i] "*[.]vtx*"` && $sel[$i]!=$startVtx)
				{
				$pos=`xform -q -ws -t $sel[$i]`;
				if ($pos[0]<$minPosX)
					{
					$minPosX=$pos[0];
					$endVtx=$sel[$i];
					}
				$selVtxs[size($selVtxs)]=$sel[$i];
				}
		//Could be `startVtxs` selected, to overRide that start is at scene tx==0
		for ($i=0;$i<size($sel);$i++)
			if (`gmatch $sel[$i] "*[.]vtx*"`)
				if ($sel[$i]!=$endVtx)
					$lipStartVtxs[size($lipStartVtxs)]=$sel[$i];
		}
		//if (3 vtx selected), we assume the MaxY vtx is the $startVtx (2 vtx selected is ignored)
		if (size($lipStartVtxs)==1)
			clear $lipStartVtxs;
		if (size($lipStartVtxs)>1)
			for ($i=0;$i<size($lipStartVtxs);$i++)
				{
				$pos=`xform -q -ws -t $lipStartVtxs[$i]`;
				if ($pos[1]>$maxPosY)
					{
					$maxPosY=$pos[1];
					$startVtx=$lipStartVtxs[$i];
					}
		}
	}

select $startVtx;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
for ($y=0;$y<size($tempString);$y++)
	{
	if (!`stringArrayCount $tempString[$y] $sel`)
		select -d $tempString[$y];
	}
$tempString=`ls -sl -fl`;
string $edge1=$tempString[0];
string $edge2=$tempString[1];

//start leftwards
if ($edge2!="")
	{
	$posA=`xform -q -ws -t $edge1`;
	$posB=`xform -q -ws -t $edge2`;
	$condition=0;
	if (($posA[0]+$posA[3]) > ($posB[0]+$posB[3])) $condition=1;
	if ($leftSuffix=="Left") $condition=!$condition;
	if ($condition)
		{
		$tempString[0]=$edge1;
		$edge1=$edge2;
		$edge2=$tempString[0];
		}
	}

//get $edges1[]
$curveCmd="curve -n faceLoopCurve1 -d 1 ";
$pos=`xform -q -ws -t $startVtx`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
select $startVtx;
$prevVtxs[0]=$startVtx;
$vtxs1[size($vtxs1)]=$startVtx;
string $coveredEdges[];

$around=0;
for ($i=0;$i<199;$i++)
	{
	ConvertSelectionToEdges;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge2)
			select -d $tempString[$y];
		}
	$tempString=`ls -sl -fl`;
	$coveredEdges[size($coveredEdges)]=$tempString[0];
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	if ($endVtx=="")
		{
		if  (size($coveredEdges)==size($sel))
			$around=1;
		}
	else
		{
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVtx $tempString`)
				$around=1;
		}
	select -d $prevVtxs;
	$prevVtxs=$tempString;
	$tempString2=`ls -sl -fl`;
	if ($tempString2[0]=="")
		break;
	$vtxs1[size($vtxs1)]=$tempString2[0];
	$pos=`xform -q -ws -t $tempString2[0]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	select $tempString;
	if ($around)
		{
		if ($endVtx=="")
			$endVtx=$tempString2[0];
		break;
		}
	}

//$endVtx="" means a complete loop, so include start as the end
if ($endVtx=="")
	{
	$pos=`xform -q -ws -t $startVtx`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}

ConvertSelectionToContainedEdges;
string $edges1[]=`ls -sl -fl`;
eval $curveCmd;

if ($section=="ForeHead")
	{
	if (`objExists ForeHeadFromEdges`)
		{
		select -cl;
		for ($i=0;$i<size($sel);$i++)
			if (`gmatch $sel[$i] "*[.]vtx*"`)
				select -add $sel[$i];
		}

	if (size($sel)!=3 && !`objExists ForeHeadFromEdges`)
		{
		print "// Not 3 vertices selected, assuming creation of ForeHead from custom selection of Edges+3verts.\n";
		createNode -n ForeHeadFromEdges transform;
//		error "Exactly 3 vertices must be selected";
		}
	$closestSampler=`createNode -n closestSampler closestPointOnMesh`;
	connectAttr ($geometry+".outMesh") ($closestSampler+".inMesh");
	for ($i=0;$i<size($sel);$i++)
		{
		tokenize $sel[$i] "[" $tempString;
		tokenize $tempString[1] "]" $tempString;
		$selCompNrs[$i]=$tempString[0];
		$pos=`xform -q -ws -t $sel[$i]`;
		$selPosX[$i]=$pos[0];
		$selPosY[$i]=$pos[1];
		}

	//find $sideVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($leftSuffix=="")
			if ($selPosX[$i]<$minPosX)
				{
				$sideVtxNr=$selCompNrs[$i];
				$minPosX=$selPosX[$i];
				}
		if ($leftSuffix=="Left")
			if ($selPosX[$i]>$maxPosX)
				{
				$sideVtxNr=$selCompNrs[$i];
				$maxPosX=$selPosX[$i];
				}
		}
	//find $topVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selCompNrs[$i]==$sideVtxNr) continue;
		if ($selPosY[$i]>$maxPosY)
			{
			$topVtxNr=$selCompNrs[$i];
			$maxPosY=$selPosY[$i];
			}
		}
	//find $noseVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selCompNrs[$i]==$sideVtxNr) continue;
		if ($selCompNrs[$i]==$topVtxNr) continue;
		$noseVtxNr=$selCompNrs[$i];
		}
	//find $lidInnerVtxNr
	$pos=`xform -q -ws -t ("upperEyeLidOuterCurve"+$leftSuffix+".cv[0]")`;
	setAttr -type float3 ($closestSampler+".inPosition") $pos[0] $pos[1] $pos[2];
	$lidInnerVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	//find $lidOuterVtxNr
	int $upperEyeLidOuterSpans=`getAttr ("upperEyeLidOuterCurve"+$leftSuffix+".spans")`;
	$pos=`xform -q -ws -t ("upperEyeLidOuterCurve"+$leftSuffix+".cv["+$upperEyeLidOuterSpans+"]")`;
	setAttr -type float3 ($closestSampler+".inPosition") $pos[0] $pos[1] $pos[2];
	$lidOuterVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	if (!`objExists ForeHeadFromEdges`)
		{
		select `ls -o $sel[0]`;
//		select `polySelect -q -asSelectString -shortestEdgePath $lidInnerVtxNr $noseVtxNr`;
		asSelectLeastEdgesPath $geometry $lidInnerVtxNr $noseVtxNr;
		$edgesLidInnerNose=`ls -sl -fl`;
		if (!size(`ls -sl`))
			{
			delete FaceFitForeHead faceLoopCurve1;
			asFaceUpdateInfo 1;
			select $sel;
			error ("Unable to determine ForeHead area, try selecting the complete edgeBorder manually\n"
				+"and select the 3 vertices,\n");
//				+"and then type:asForeHeadFromEdges;");
			}
//		select `polySelect -q -asSelectString -shortestEdgePath $noseVtxNr $topVtxNr`;
		asSelectLeastEdgesPath $geometry $noseVtxNr $topVtxNr;
		$edgesNoseTop=`ls -sl -fl`;
//		select `polySelect -q -asSelectString -shortestEdgePath $topVtxNr $sideVtxNr`;
		asSelectLeastEdgesPath $geometry $topVtxNr $sideVtxNr;
		$edgesTopSide=`ls -sl -fl`;
//		select `polySelect -q -asSelectString -shortestEdgePath $sideVtxNr $lidOuterVtxNr`;
		asSelectLeastEdgesPath $geometry $sideVtxNr $lidOuterVtxNr;
		$edgesSideLidOuter=`ls -sl -fl`;

		//Edges that are in more then 1 path, are unneccecary detours
		//4 way check
		for ($i=0;$i<size($edgesLidInnerNose);$i++)
			{
			if (`stringArrayCount $edgesLidInnerNose[$i] $edgesNoseTop`)
				{
				$edgesNoseTop=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesNoseTop`;
				$edgesLidInnerNose=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesLidInnerNose`;
				}
			if (`stringArrayCount $edgesLidInnerNose[$i] $edgesTopSide`)
				{
				$edgesTopSide=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesTopSide`;
				$edgesLidInnerNose=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesLidInnerNose`;
				}
			if (`stringArrayCount $edgesLidInnerNose[$i] $edgesSideLidOuter`)
				{
				$edgesSideLidOuter=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesSideLidOuter`;
				$edgesLidInnerNose=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesLidInnerNose`;
				}
			}
		//3 way check
		for ($i=0;$i<size($edgesNoseTop);$i++)
			{
			if (`stringArrayCount $edgesNoseTop[$i] $edgesTopSide`)
				{
				$edgesTopSide=`stringArrayRemove {$edgesNoseTop[$i]} $edgesTopSide`;
				$edgesNoseTop=`stringArrayRemove {$edgesNoseTop[$i]} $edgesNoseTop`;
				}
			if (`stringArrayCount $edgesNoseTop[$i] $edgesSideLidOuter`)
				{
				$edgesSideLidOuter=`stringArrayRemove {$edgesNoseTop[$i]} $edgesSideLidOuter`;
				$edgesNoseTop=`stringArrayRemove {$edgesNoseTop[$i]} $edgesNoseTop`;
				}
			}
		//2 way check
		for ($i=0;$i<size($edgesTopSide);$i++)
			if (`stringArrayCount $edgesTopSide[$i] $edgesSideLidOuter`)
				{
				$edgesSideLidOuter=`stringArrayRemove {$edgesTopSide[$i]} $edgesSideLidOuter`;
				$edgesTopSide=`stringArrayRemove {$edgesTopSide[$i]} $edgesTopSide`;
				}

		select $edgesLidInnerNose $edgesNoseTop $edgesNoseTop $edgesTopSide $edgesSideLidOuter;
		$sel=`ls -sl -fl`;
		}
	delete $closestSampler;

	if (`objExists ForeHeadFromEdges`)
		select $sel;

	delete faceLoopCurve1;
	DuplicateCurve;
	$tempString=`ls -sl`;
	catchQuiet (`attachCurve -n faceLoopCurve1 -ch 1 -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1`);
	delete $tempString;
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 1 -kep 0 -kt 0 -s 0 -d 1 -tol 0.01 faceLoopCurve1;//for param range to start from 0

	createNode -n tempNearestPointOnCurve nearestPointOnCurve;
	connectAttr -f faceLoopCurve1.worldSpace[0] tempNearestPointOnCurve.inputCurve;

	if (`objExists ForeHeadFromEdges`)
		{
		//`manually` rebuild the curve so it starts with cv[0] at innerEyeCorner and moves CounterClockWise around
		$pos=`xform -q -ws -t ("upperEyeLidOuterCurve"+$leftSuffix+".cv[0]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		select ("faceLoopCurve1.cv["+`getAttr tempNearestPointOnCurve.result.parameter`+"]");
		$curveCmd="curve -n faceLoopCurve1 -d 1 ";
		rename faceLoopCurve1 faceLoopCurve1OLD;
		for ($i=0;$i<`getAttr faceLoopCurve1OLD.spans`+2;$i++)
			{
			$pos=`xform -q -ws -t`;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			pickWalk -d right;
			}
		eval $curveCmd;
		connectAttr -f faceLoopCurve1.worldSpace[0] tempNearestPointOnCurve.inputCurve;
		delete faceLoopCurve1OLD;
		}

	//Ensure consistent curve-direction
	if (!`objExists ForeHeadFromEdges`)
		{
		$pos=`xform -q -ws -t ("upperEyeLidOuterCurve"+$leftSuffix+".cv[0]")`;
		setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
		if (`getAttr tempNearestPointOnCurve.result.parameter`>2)//Reverse curve, to ensure start in innerEyeLidCorner
			reverseCurve -ch 0 -rpo 1 "faceLoopCurve1";
		if (!`attributeExists directionChecked ("FaceFitForeHead"+$leftSuffix)`)
			addAttr -k 0 -ln directionChecked -at bool -dv 1 ("FaceFitForeHead"+$leftSuffix);
		}

	//store info which CV aligns with original vtx selection, so we can re-find these later, even if topology changes
	//yes. crazy (int)(string); convert to string, then to int, as maya will incorrectly convert 11.0 -> 10
	//e.g. "max" character FaceFitForeHead.sideCvNr
	//But this incorrectly rounds 27.99999708 -> 27 e.g. tuna outerEyeCnrNr, change to using asRoundFloatToInt
	$pos=`xform -q -ws -t ($geometry+".vtx["+$noseVtxNr+"]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
	addAttr -ln noseCvNr -at long -dv `asRoundFloatToInt $parameter` ("FaceFitForeHead"+$leftSuffix);
	$pos=`xform -q -ws -t ($geometry+".vtx["+$topVtxNr+"]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
	addAttr -ln topCvNr -at long -dv `asRoundFloatToInt $parameter` ("FaceFitForeHead"+$leftSuffix);
	$pos=`xform -q -ws -t ($geometry+".vtx["+$sideVtxNr+"]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
	addAttr -ln sideCvNr -at long -dv `asRoundFloatToInt $parameter` ("FaceFitForeHead"+$leftSuffix);
	$pos=`xform -q -ws -t ("upperEyeLidOuterCurve"+$leftSuffix+".cv[0]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
	addAttr -ln innerEyeCnrNr -at long -dv `asRoundFloatToInt $parameter` ("FaceFitForeHead"+$leftSuffix);
	$pos=`xform -q -ws -t ("upperEyeLidOuterCurve"+$leftSuffix+".cv[99]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
	addAttr -ln outerEyeCnrNr -at long -dv `asRoundFloatToInt $parameter` ("FaceFitForeHead"+$leftSuffix);

	delete tempNearestPointOnCurve;
	if (`objExists ForeHeadFromEdges`)
		delete ForeHeadFromEdges;
	}


if ($upAndLo)
	{
	if (`objExists asRunningFaceLipLeft`)
		$posA=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
	//get $edges2[]
	$curveCmd="curve -n faceLoopCurve2 -d 1 ";
	$around=0;
	select $startVtx;
	$pos=`xform -q -ws -t $startVtx`;
	if ($section!="Lip")
		{
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$prevVtxs[0]=$startVtx;
		$vtxs2[size($vtxs2)]=$startVtx;
		}
	$hitSecondLipStartVtxs=0;
	for ($i=0;$i<199;$i++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge1)
				select -d $tempString[$y];
			}
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVtx $tempString`)
				$around=1;
		select -d $prevVtxs;
		$prevVtxs=$tempString;
		$tempString2=`ls -sl -fl`;
		if (!`size($tempString2)`)
			{
			delete ("FaceFit"+$section+$part+$leftSuffix) faceLoopCurve1;
			asFaceUpdateInfo 1;
			select $sel;
			error "Not a complete edgeloop";
			}
		$pos=`xform -q -ws -t $tempString2[0]`;

		if ($i>0 && size($lipStartVtxs) && `stringArrayCount $tempString2[0] $lipStartVtxs`)
			$hitSecondLipStartVtxs=1;
		if (`objExists asRunningFaceLipLeft`)
			if (`getAttr asRunningFaceLipLeft.righLowerStartVtx`==$tempString2[0])
				$hitRighLowerStartVtx=1;
		if (size($lipStartVtxs) && $hitSecondLipStartVtxs==0)
			;
		else if ($section=="Lip" && $pos[0]>0.001 && size($lipStartVtxs)==0 && !`objExists asRunningFaceLipLeft`) //only rightSide for Lip-curve
			;
		else if ($section=="Lip" && $pos[0]<($posA[0]-0.001) && size($lipStartVtxs)==0 && `objExists asRunningFaceLipLeft`) //only rightSide for Lip-curve
			;
		else
			{
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			$vtxs2[size($vtxs2)]=$tempString2[0];
			}

		select $tempString;
		if ($around)
			break;
		}

	ConvertSelectionToContainedEdges;
	eval $curveCmd;

	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	$tempString=`listRelatives -s faceLoopCurve2`;
	rename $tempString[0] faceLoopCurve2Shape;

	int $OneIsUpper;
	select $edges1;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $maxYVtx $tempString`)
			$OneIsUpper=1;

	//Special case detection of $OneIsUpper, on LipOuter
	if ($section=="Lip" && $part=="Outer")
		{
		$posA=`xform -q -ws -t $vtxs1[0]`;
		$posB=`xform -q -ws -t $vtxs2[0]`;
		if ($posA[1]>$posB[1])
			$OneIsUpper=1;
		else
			$OneIsUpper=0;
		}

	//Special case detection of $OneIsUpper, on LipMain, as LowerVtx can be higher than UpperVtx
	if ($section=="Lip" && $part=="Main" && `objExists ("upperLipOuterCurve"+$leftSuffix)`)
		{
		$tempString[0]=`asGetFaceFitSelection ("upperLipOuterCurve"+$leftSuffix)`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		string $upperOuterLipVtxZero=$tempString[0];
		select $upperOuterLipVtxZero;
		for ($y=0;$y<18;$y++)//inc. from 10 to 18 upon metahuman test
			{
			polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
			$tempString=`ls -sl -fl`;
			if (`stringArrayCount $vtxs1[0] $tempString`)
				{
				$OneIsUpper=1;
				break;
				}
			if (`stringArrayCount $vtxs2[0] $tempString`)
				{
				$OneIsUpper=0;
				break;
				}
			}
		}

	//Same Special case detection for LipInner, but refering looking for LipMain
	if ($section=="Lip" && $part=="Inner" && `objExists ("upperLipMainCurve"+$leftSuffix)`)
		{
		$tempString[0]=`asGetFaceFitSelection ("upperLipMainCurve"+$leftSuffix)`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		string $upperOuterLipVtxZero=$tempString[0];
		select $upperOuterLipVtxZero;
		for ($y=0;$y<10;$y++)
			{
			polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
			$tempString=`ls -sl -fl`;
			if (`stringArrayCount $vtxs1[0] $tempString`)
				{
				$OneIsUpper=1;
				break;
				}
			if (`stringArrayCount $vtxs2[0] $tempString`)
				{
				$OneIsUpper=0;
				break;
				}
			}
		}

//	string $upperVtxs[],$lowerVtxs[];
	if ($OneIsUpper)
		{
//		$upperVtxs=$vtxs1;
//		$lowerVtxs=$vtxs2;
		rename faceLoopCurve1 ("upper"+$section+$part+"Curve"+$leftSuffix);
		rename faceLoopCurve2 ("lower"+$section+$part+"Curve"+$leftSuffix);
		}
	else
		{
//		$upperVtxs=$vtxs2;
//		$lowerVtxs=$vtxs1;
		rename faceLoopCurve1 ("lower"+$section+$part+"Curve"+$leftSuffix);
		rename faceLoopCurve2 ("upper"+$section+$part+"Curve"+$leftSuffix);
		}
	}
if (!$upAndLo)
	{
	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	rename faceLoopCurve1 ($section+$part+"Curve"+$leftSuffix);
	}


for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if (!$upAndLo) $upperLower="";
	if (!$upAndLo && $upperLowerFactor==-1) continue;

	parent ($upperLower+$section+$part+"Curve"+$leftSuffix) ("FaceFit"+$section+$part+"Curve"+$leftSuffix);
	makeIdentity -a 1 -t 1 -r 1 -s 1 ("FaceFit"+$section+$part+$leftSuffix);
//	setAttr ($upperLower+$section+$part+"CurveShape.dispCV") 1;
	setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideEnabled") 1;
	setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 17;//Yellow

	//Colors
	if ($part=="Inner")
		setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 15;//Blue
	if ($part=="Main")
		setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 13;//Red
	if ($part=="Outer")
		setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 14;//Green
	}


if ($mainAndOuter==0) $part="";
else $parts={"Main","Outer"};
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;
	if ($isSphere)
		continue;

	$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r ($scale/400.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
	rename $tempString[0] ($section+"Profile"+$part+$leftSuffix);
	parent ($section+"Profile"+$part+$leftSuffix) ("FaceFit"+$section+$part+"Curve"+$leftSuffix);

	extrude -n ($upperLower+$section+"Cylinder"+$part+$leftSuffix) -ch 0 -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 0 ($section+"Profile"+$part+$leftSuffix) ($upperLower+$section+$part+"Curve"+$leftSuffix);
	delete ($section+"Profile"+$part+$leftSuffix);
	setAttr ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".overrideEnabled") 1;
	setAttr ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".overrideDisplayType") 2;

	setAttr ($upperLower+$section+"Cylinder"+$part+$leftSuffix+"Shape.curvePrecisionShaded") 4;
	parent ($upperLower+$section+"Cylinder"+$part+$leftSuffix) ("FaceFit"+$section+$part+"Geo"+$leftSuffix);

	//ensure outwards normals
	$posA=`xform -q -ws -t ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".cv[6][0]")`;
	$posB=`xform -q -ws -t ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".cv[6][1]")`;
	if ($posA[1]>$posB[1])
		reverseSurface -d 0 -ch 0 -rpo 1 ($upperLower+$section+"Cylinder"+$part+$leftSuffix);

	//Colors
	if ($part=="Inner" || $part=="Main" || $part=="Outer")
		{
		sets -e -forceElement "asGreenSG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		if ($upperLower=="lower")
			sets -e -forceElement "asGreen2SG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		}

	if ($section=="EyeLidMain2")
		{
		sets -e -forceElement "asGreenSG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		if ($upperLower=="lower")
			sets -e -forceElement "asGreen2SG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		}

	if ($section=="Tongue")
		sets -e -forceElement "asRedSG" ($section+"Cylinder"+$part+$leftSuffix);
	}

if (`gmatch $section "*Line"` || $section=="Pupil" || $section=="Iris")
	{
	sets -e -forceElement $shadingGroup ($section+"Cylinder"+$leftSuffix);
	}

if ($section=="ForeHead" || ($section=="EyeLid" && $part=="Inner") || ($section=="Lip" && $part=="Inner"))
	{
	select $sel;
	$tempString=`ls -sl -fl`;
	if ($section=="ForeHead")
		{
		$areaMeshShader="asGreenSG";
		sets -e -forceElement "asGreenSG" ($section+"Cylinder"+$part+$leftSuffix);
		asFaceFitReSelect EyeLid Outer;
		$growStartPos="EyeBrowInner"+$leftSuffix;
		}
	if (($section=="EyeLid" && $part=="Inner") || ($section=="Lip" && $part=="Inner"))
		{
		$areaMeshShader="asRedSG";
		loft -n tempLoft -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true ("upper"+$section+"OuterCurve"+$leftSuffix) ("upper"+$section+"MainCurve"+$leftSuffix) ("upper"+$section+"InnerCurve"+$leftSuffix);
		$growStartPos="upper"+$section+"MainCurve"+$leftSuffix+".cv["+(`getAttr ("upper"+$section+"MainCurve"+$leftSuffix+".spans")`/2)+"]";
		asFaceFitReSelect $section Outer;
		}
	select -add $tempString;
	ConvertSelectionToVertices;
	$borderVtxs=`ls -sl -fl`;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($geometry+".outMesh") closestSampler.inMesh;
	$pos=`xform -q -ws -t $growStartPos`;

	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	if (`objExists tempLoft`) delete tempLoft;
	select ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
	for ($i=0;$i<199;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $borderVtxs;
		$previousNumSel=$numSel;
		$tempString=`ls -sl -fl`;
		$numSel=size($tempString);
		if ($numSel==$previousNumSel)
			break;
		}
	delete closestSampler;
	ConvertSelectionToFaces;
	$tempString=`ls -sl -fl`;
	polyCube -n ($section+$part+"AreaMesh"+$leftSuffix) -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	sets -e -forceElement $areaMeshShader ($section+$part+"AreaMesh"+$leftSuffix);
	connectAttr ($geometry+".outMesh") ($section+$part+"AreaMesh"+$leftSuffix+".inMesh");
	refresh;
	disconnectAttr ($geometry+".outMesh") ($section+$part+"AreaMesh"+$leftSuffix+".inMesh");
	parent ($section+$part+"AreaMesh"+$leftSuffix) ("FaceFit"+$section+$part+"Geo"+$leftSuffix);
	select `asobjSetCast "" $tempString ($section+$part+"AreaMesh"+$leftSuffix)`;
	asInvertSelection;
//	setAttr ("FaceFit"+$section+$part+"Geo"+$leftSuffix+".inheritsTransform") 1;//temp switch On, to avoid Delete cmd switching this On
	delete;
//	setAttr ("FaceFit"+$section+$part+"Geo"+$leftSuffix+".inheritsTransform") 0;
	//Offset `outwards`with polyExtrude
	duplicate -n ($section+$part+"AreaMeshExtrude"+$leftSuffix) ($section+$part+"AreaMesh"+$leftSuffix);
	setAttr ($section+$part+"AreaMesh"+$leftSuffix+".v") 0;
	select ($section+$part+"AreaMeshExtrude"+$leftSuffix);
	$tempString=`polyExtrudeFacet -constructionHistory 1 -localTranslateZ ($scale/500.0) -keepFacesTogether 1 -divisions 1 -twist 0 -taper 1 -off 0 -thickness 0 -smoothingAngle 30`;
	rename $tempString[0] ($section+$part+"AreaMeshPolyExtrudeFacet"+$leftSuffix);
	$tempString=`listRelatives -s ($section+$part+"AreaMeshExtrude"+$leftSuffix)`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			rename $tempString[$i] ($section+$part+"AreaMeshExtrude"+$leftSuffix+"OrigShape");
	refresh;
	}

//Non-symmetrical Lip
if ($section=="Lip" && $nonSymmetrical && !`objExists asRunningFaceLipLeft`)
	{
	clear $tempString;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($geometry+".outMesh") closestSampler.inMesh;

	$pos=`xform -q -ws -t ("upperLip"+$part+"Curve.cv[0]")`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$tempString[0]=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	$tempString2[0]=$tempString[0];
	$pos=`xform -q -ws -t ("upperLip"+$part+"Curve.cv[1]")`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$tempString[1]=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	$pos=`xform -q -ws -t ("lowerLip"+$part+"Curve.cv[0]")`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$tempString[1]=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	$righLowerStartVtx=$tempString[1];
	delete closestSampler;
	asFaceFitReSelect Lip $part;
	select -d ($geometry+".vtx[0:999999]");
	select -add $tempString;
	$leftLipSelection=`ls -sl`;

	$nr=`getAttr ("upperLip"+$part+"Curve.spans")`;

	eval ("select "+`asGetFaceFitSelection ("FaceFitLip"+$part+"Curve")`);
	$tempString=`ls -sl -fl`;

	asFaceFitReSelect Lip $part;
	ConvertSelectionToVertices;
	asInvertSelection;
	$tempString3=`ls -sl`;
	asFaceFitReSelect Lip $part;
	ConvertSelectionToVertices;
	select -d $tempString;

	$tempString=`ls -sl -fl`;
	select $tempString2[0];
	for ($i=0;$i<$nr-1;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $tempString3;
		}
	$tempString3=`ls -sl -fl`;
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
	$tempString4=`ls -sl -fl`;
	for ($i=0;$i<size($tempString4);$i++)
		{
		if (!`stringArrayCount $tempString4[$i] $tempString`)
			continue;
		if (`stringArrayCount $tempString4[$i] $tempString3`)
			continue;
		$tempString2[1]=$tempString4[$i];
		}
	createNode -n asRunningFaceLipLeft transform;
	addAttr -ln startVtx -dt "string" asRunningFaceLipLeft;
	addAttr -ln endVtx -dt "string" asRunningFaceLipLeft;
	addAttr -ln righLowerStartVtx -dt "string" asRunningFaceLipLeft;
	setAttr -type "string" asRunningFaceLipLeft.startVtx $tempString2[0];
	setAttr -type "string" asRunningFaceLipLeft.endVtx $tempString2[1];
	setAttr -type "string" asRunningFaceLipLeft.righLowerStartVtx $righLowerStartVtx;
	select $tempString2[1] $leftLipSelection;
	asCreateFaceFit $section $part $upAndLo $mainAndOuter $isSphere $shadingGroup;
	}
if (`objExists asRunningFaceLipLeft`)
	{
	delete asRunningFaceLipLeft;
	asFaceUpdateInfo 1;
	$upperRightNumLipCvs=`getAttr ("upperLip"+$part+"Curve.spans")`;
	$upperLeftNumLipCvs=`getAttr ("upperLip"+$part+"CurveLeft.spans")`;
	$lowerRightNumLipCvs=`getAttr ("lowerLip"+$part+"Curve.spans")`;
	$lowerLeftNumLipCvs=`getAttr ("lowerLip"+$part+"CurveLeft.spans")`;
	if (($upperRightNumLipCvs!=$upperLeftNumLipCvs) ||  ($lowerRightNumLipCvs != $lowerLeftNumLipCvs))
		{
		asFaceFitReSelect Lip $part;
		delete ("FaceFitLip"+$part) ("FaceFitLip"+$part+"Left");
		asFaceUpdateInfo 1;
		select -cl;
		for ($i=0;$i<size($sel);$i++)
			if (`gmatch $sel[$i] "*.e*"`)
				select -add $sel[$i];
		error ("Number of CV`s of the Left and Right side is not matching.\n"
					+"upperRight="+$upperRightNumLipCvs+" upperLeft="+$upperLeftNumLipCvs+"\n"
					+"lowerRight="+$lowerRightNumLipCvs+" lowerLeft="+$lowerLeftNumLipCvs+"\n"
					+"See this video for more details:\n"
					+"https://youtu.be/kz4NaLGMtQg?t=534");
		}
	}

select ("FaceFit"+$section+$part+$leftSuffix);
print ("// FaceFit"+$section+$part+$leftSuffix+" created.\n");
}

global proc asFaceDeselectLowestHalfOfVtx ()
{
$tempString=`ls -sl -fl`;
float $tys[];
float $tysAverage;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	$tys[$y]=$pos[1];
	$tysAverage+=$tys[$y];
	}
$tysAverage=$tysAverage/size($tempString);
select -cl;
for ($y=0;$y<size($tempString);$y++)
	if ($tys[$y]>$tysAverage)
		select -add $tempString[$y];
}

global proc asSelectLeastEdgesPath (string $geometry, int $startVtxNr, int $endVtxNr)
{
int $startEndAreNeightbours;
string $sel[]=`ls -sl`;
string $loopRingVtxs[],$ShortestPathVtxs[],$tempString[],$tempString2[];

//Edge Loop/Ring Utilities works differently if input are neighboring vtx, it then extends, not just contained
select ($geometry+".vtx["+$startVtxNr+"]");
polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
$tempString=`ls -sl -fl`;
select ($geometry+".vtx["+$endVtxNr+"]");
$tempString2=`ls -sl -fl`;
if (`stringArrayCount $tempString2[0] $tempString`)
	{
	select `polySelect -q -asSelectString -shortestEdgePath $startVtxNr $endVtxNr`;
	return;
	}

select $geometry;
//First check for Loop or Ring, as this might be the "Path of Less Edges", which is prefferd over `shortest Path`
select ($geometry+".vtx["+$startVtxNr+"]") ($geometry+".vtx["+$endVtxNr+"]");
$loopRingVtxs=`polySelectSp -q -loop`;

//must contain start & end vtx in path
if (size($loopRingVtxs))
	{
	select $loopRingVtxs;
	$loopRingVtxs=`ls -sl -fl`;
	if (!`stringArrayCount ($geometry+".vtx["+$startVtxNr+"]") $loopRingVtxs`)
		{
		select -cl;
		clear $loopRingVtxs;
		}
	if (!`stringArrayCount ($geometry+".vtx["+$endVtxNr+"]") $loopRingVtxs`)
		{
		select -cl;
		clear $loopRingVtxs;
		}
	}

if (!size($loopRingVtxs))//try edgeRing instead of edgeLoop
	$loopRingVtxs=`polySelectSp -q -ring`;
//must contain end vtx in path
if (size($loopRingVtxs))
	{
	select $loopRingVtxs;
	$loopRingVtxs=`ls -sl -fl`;
	if (!`stringArrayCount ($geometry+".vtx["+$endVtxNr+"]") $loopRingVtxs`)
		{
		select -cl;
		clear $loopRingVtxs;
		}
	}

//special case, loop or ring might have far more edges then shortestEdgePath, as it might loop and the expand,
select $geometry;
select `polySelect -q -asSelectString -shortestEdgePath $startVtxNr $endVtxNr`;
$ShortestPathVtxs=`ls -sl -fl`;
if (size($loopRingVtxs)>size($ShortestPathVtxs)+3)//more then 3 edges more, switching back to shortestEdgePath
	clear $loopRingVtxs;

if (size($loopRingVtxs))
	{
	select $loopRingVtxs;
	ConvertSelectionToContainedEdges;	
	}
else
	{
	select $geometry;
	select `polySelect -q -asSelectString -shortestEdgePath $startVtxNr $endVtxNr`;
	}

}

global proc int asFaceRemoveBodyJaw ()
{
int $return=0;
string $dialog="OK";
if (!`objExists headTopology` && !`objExists asBatch`)
	$dialog=`confirmDialog -t "Confirm"
	-m "This will replace the Jaw from the Body-setup"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog=="OK")
	$return=1;

string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
	if (`objExists Jaw_M`) asRemoveInfluence Jaw_M $skinClusters[$i];

if (`objExists FKOffsetJaw_M`) delete FKOffsetJaw_M;
if (`objExists Jaw_M`) delete Jaw_M;
if (`objExists Jaw`) delete Jaw;

asRemoveUnusedfromBuildPose bodySetup;
return $return;
}

global proc asDeleteAdvancedFace ()
{
global string $gMainProgressBar;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $keepBuildPoseInfo,$cmd;
string $tempString[],$tempString2[],$faceSCs[];
if (!`objExists FaceMotionSystem`)
	return;

progressBar -e -st "Deleting FaceSetup." -bp -ii 1 -min 0 -max 1 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

if (`objExists asFaceBS`)
	delete asFaceBS;

//Add headJoint as inf, if all bound joints will be deleted, to keep skinCluster.
int $haveKeepJoint;
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		$faceSCs[size($faceSCs)]=$tempString[$i];
for ($i=0;$i<size($faceSCs);$i++)
	{
	$tempString=`listConnections ($faceSCs[$i]+".matrix")`;
	$haveKeepJoint=0;
	for ($y=0;$y<size($tempString);$y++)
		if (!`sets -im FaceAllSet $tempString[$y]`)
			$haveKeepJoint=1;
	if (!$haveKeepJoint)
		{
		skinCluster -e -ai $headJoint -lw false -wt 1 $faceSCs[$i];
		}
	}

//lockWeights all but headJoint
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$headJoint)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
//remove previous inf`s
select -cl;
$cmd="skinCluster -e";
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		$cmd+=" -ri "+$tempString[$i];
$cmd+=" "+$skinCluster;
evalEcho ($cmd);
skinPercent -normalize 1 $skinCluster $geometry;
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists lockInfluenceWeights $tempString[$i]`)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
delete `sets -q -nodesOnly FaceAllSet`;
if (`objExists FaceAllSet`)
	delete `sets -q -nodesOnly FaceAllSet`;

//Normalize SkinClusters
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 0 -d 1 ($tempString[$i]+".outputGeometry[0]")`;
	if (`objExists $tempString2[0]`)
		catchQuiet (`skinPercent -normalize 1 $tempString[$i] $tempString2[0]`);
	}

if (!`checkBox -q -v asFaceKeepAllCheckBox`)
	if (`attributeExists run FaceFitSkeleton`)
		setAttr -type "string" FaceFitSkeleton.run "";
if (`checkBox -q -v asFaceKeepAllCheckBox`)
	$keepBuildPoseInfo=", and build pose stored in the \"FaceFitSkeleton.run\" attribute";

if (`objExists asFaceDeltaMush`)
	delete asFaceDeltaMush;

asFaceUpdateFitFace;

if (`attributeExists buildStep FaceFitSkeleton`)
	setAttr FaceFitSkeleton.buildStep 0;
asUpdateButtonEnables;
asFaceUpdateInfo 1;
print ("// Existing AdvancedFace removed"+$keepBuildPoseInfo+".\n");
}

global proc asFaceUpdateFitFace ()
{
//v5.351 to v5.352
if (`attributeExists version FaceGroup`)
	if (`getAttr FaceGroup.version`<5.352 && `asGetScriptVersion`>=5.352)
		{
		if (`objExists FaceFitEyeBrowOuter` && `objExists EyeBrowOuterCurve`) delete FaceFitEyeBrowOuter;
		if (`objExists FaceFitEyeBrowMain`) delete FaceFitEyeBrowMain;
		if (`objExists FaceFitEyeLidInner`)
			{
			asFaceFitReSelect EyeLid "Inner";
			delete FaceFitEyeLidInner;
			asCreateFaceFit EyeLid "Inner" 1 1 0 asGreenSG;
			}
		if (`objExists FaceFitLipInner`)
			{
			asFaceFitReSelect Lip "Inner";
			delete FaceFitLipInner;
			asCreateFaceFit Lip "Inner" 1 1 0 asGreenSG;
			}
		if (`objExists FaceFitAnimateFit`) delete FaceFitAnimateFit;
		}

//v5.354 to v5.355
if (`asGetScriptVersion`>=5.355)
	{
	string $oldNames[]={"cheek","line","cheekRaiser","noseCorner"};
	string $newNames[]={"Cheek","Line","CheekRaiser","NoseCorner"};
	for ($i=0;$i<size($oldNames);$i++)
		if (`objExists ("FaceFit"+$oldNames[$i])`)
			{
			asFaceFitReSelect $oldNames[$i] "";
			delete ("FaceFit"+$oldNames[$i]);
			asCreateFaceFit $newNames[$i] "" 0 0 1 asGreenSG;
			}
	}
select -cl;
}

global proc asConvertAllSoftModBackToControl ()
{
global string $gMainProgressBar;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $currentTime=`currentTime -q`;
string $sel[]=`ls -sl`;
string $tempString[],$controls[];

progressBar -e -st "Converting SoftMod 2 skin-weights" -bp -ii 1 -min 0 -max 1 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

//ensure any controls coverted to softMod, is converted back to control
string $softModHandle;
string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`gmatch $rootLevelObjects[$i] "convertedSoftModHandle_*"`)
		{
		$softModHandle=$rootLevelObjects[$i];
		select $softModHandle;
		asFaceConvertSoftModBackToControl;

		//mirroring for non-symmetrical face
		if ($nonSymmetrical && `gmatch $rootLevelObjects[$i] "convertedSoftModHandle_*_R"`)
			{
			tokenize $rootLevelObjects[$i] "_" $tempString;
			select ($tempString[1]+"_L");
			setAttr ($tempString[1]+"Left.falloffRadius") `getAttr ($tempString[1]+".falloffRadius")`;
			asFaceConvertControlToSoftMod;
			select ("convertedSoftModHandle_"+$tempString[1]+"_L");
			asFaceConvertSoftModBackToControl;
			}
		}

//mirroring at frame 0
currentTime 0;
if (!$nonSymmetrical)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
currentTime $currentTime;

select $sel;
}

global proc asStepBuildPrep (int $stepBuild)
{
int $autoKeyState=`autoKeyframe -q -state`;
string $ctrl;
string $tempString[],$tempString2[];

if ($stepBuild==0)
	return;
if (`attributeExists buildStep FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.buildStep`!=$stepBuild-1)
		{
		print ("// Step:"+$stepBuild+" attempted executed, however previously executed step was:"+`getAttr FaceFitSkeleton.buildStep`+"\n");
		print ("// Possibly caused by a Undo of previous step.\n");
		print ("// Refreshing UI to correctly show current step\n");
		asUpdateButtonEnables;
		asFaceUpdateInfo 1;
		error "Detected skipped step, please try again";
		}

//reset Ctrls as the user may have been testing, without restoring to Zero
if ($autoKeyState) autoKeyframe -state 0;
if (`objExists OnFacecontrols`)
	$tempString=`listRelatives -ad -type nurbsCurve OnFacecontrols`;
if (`objExists ctrlBox`)
	$tempString2=`listRelatives -ad -type nurbsCurve ctrlBox`;//ctrlBox2 ctrls needs values
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	$ctrl=$tempString2[0];
	if (`gmatch $ctrl "ctrlBox*"`)
		continue;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $ctrl;
	}
if ($autoKeyState) autoKeyframe -state 1;
}

global proc asStepBuildComplete (int $stepBuild)
{
if ($stepBuild==0)
	return;

//complete any started `softMod-weighting`
if (size (`ls -type softMod "convertedSoftMod_*"`))
	asConvertAllSoftModBackToControl;

if (`objExists FaceFitSkeleton`)
	{
	if (!`attributeExists buildStep FaceFitSkeleton`)
		addAttr -ln "buildStep" -at long -dv 0 FaceFitSkeleton;
	setAttr FaceFitSkeleton.buildStep $stepBuild;
	}

print ("// Face step:"+$stepBuild+" complete.\n");
asFaceUpdateInfo 1;
}

global proc asBuildAdvancedFace ()
{
int $manuallyRunRestoreStep;
string $tempString[];
string $stepBuildText;

string $m;
string $currentUnitLinear=`currentUnit -q -f`;
$m="Units currently set to: \""+$currentUnitLinear+"\"\nAdvancedSkeleton requires \"cm\".\nClick OK to switch";
if ($currentUnitLinear!="centimeter")
	{
	if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`=="Ok")
		currentUnit -l cm;
	else
		return;
	}

if (`checkBox -q -ex asFaceManuallyRunRestoreStepCheckBox`)
	$manuallyRunRestoreStep=`checkBox -q -v asFaceManuallyRunRestoreStepCheckBox`;

if (`objExists FaceFitSkeleton`)
	if (!`attributeExists buildStep FaceFitSkeleton`)
		addAttr -ln "buildStep" -at long -dv 0 FaceFitSkeleton;

for ($i=1;$i<99;$i++)
	{
	if (!`text -q -ex ("stepBuild"+$i+"Text")`)
		break;
	$stepBuildText=`text -q -l ("stepBuild"+$i+"Text")`;
	tokenize $stepBuildText ":" $tempString;
	$proc="asFace"+`strip $tempString[1]`;

	if ($proc=="asFaceRebuildRestore" && $manuallyRunRestoreStep)
		{
		print ("// Manually run the RebuildRestore Step, to apply the Restore.\n");
		frameLayout -e -cl 0 asFaceStepBuildFrameLayout;
		break;
		}

	print ("// Execute Step:"+$stepBuildText+"\n");
	eval ($proc);
	asStepBuildComplete $i;
	}

select -cl;
if (!$manuallyRunRestoreStep)
	print "// Face Build Complete\n";
}

global proc asFacePrep ()
{
int $rigTypeInt;
int $keepAll=`checkBox -q -v asFaceKeepAllCheckBox`;
int $keepCustomControls=`checkBox -q -v asFaceKeepCustomControlsCheckBox`;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $boundToOtherJoints,$hasConvertedToBlendShapes,$foundLeftover,$previousBuildCompleted;
int $maxInfluences=`asFaceGetMaxInfluences`;
int $tempInts[];
float $pos[],$posA[],$posB[],$posC[],$posD[],$rot[],$sca[];
float $scale,$maxInf;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $rightEye=`textField -q -tx asFaceRightEyeTextField`;
string $leftEye=`textField -q -tx asFaceLeftEyeTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $faceFitElement,$sc,$newSc,$dialog,$includeAsString,$asFaceFitMidText;
string $tempString[],$tempString2[],$tempString3[],$deleteObjs[],$allSetMembers[],$allFaceGeo[],$teethTongueEyes[],$historyNodes[],$infJoints[],$geos[];
string $allNodeTypes[]=`allNodeTypes`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
string $requiredObj[]={"FitEyeBall","FaceFitEyeLidOuter","FaceFitEyeLidMain","FaceFitEyeLidInner"};
if (`attributeExists RigType FaceFitSkeleton`)
	$rigTypeInt=`getAttr FaceFitSkeleton.RigType`;

//check the required FaceFit elements exists
if (!`attributeExists faceScale FaceFitSkeleton`)
	error "Mask not defined. Choose \"Mask\" in the Pre section, by selecting polygons.";

if ($geometry=="") error "\"Face\" object not choosen";
if ($allFaceGeoString=="") error "\"All Head\" objects not choosen";
if ($rightEye=="") error "\"Right Eye\" object not choosen";
if ($leftEye=="") error "\"Left Eye\" object not choosen";

if (`objExists "prefix_FaceGroup"`)
	error "Object \"prefix_FaceGroup\" found, which means a previous build failed. Try to Undo previous build, to restore functional FaceSetup";

//v 5.9414 changed name of NoseCenter to NoseBridge ( partially due to new ctrl called NoseCrease, auto-rename before required FaceFittings check )
if (`objExists FaceFitNoseCenter`)
	{
	print ("// FaceFitNoseCenter detected, as of v5.9414, this is called NoseBridge, now automatically renaming this.\n");
	$tempString=`ls -type transform "*NoseCenter*"`;
	for ($i=0;$i<size($tempString);$i++)
		rename $tempString[$i] `substitute "NoseCenter" $tempString[$i] "NoseBridge"`;
	}

//check the required FaceFittings exists (according to "Include" options)
if (`asFaceIncludeBelowEyes`)
	{//BelowEyes
	$requiredObj[size($requiredObj)]="FaceFitLipOuter";
	$requiredObj[size($requiredObj)]="FaceFitLipMain";
	$requiredObj[size($requiredObj)]="FaceFitLipInner";
	$requiredObj[size($requiredObj)]="FaceFitJawPivot";
	$requiredObj[size($requiredObj)]="FaceFitJawCorner";
	$requiredObj[size($requiredObj)]="FaceFitJawLine";
	$requiredObj[size($requiredObj)]="FaceFitJaw";
	$requiredObj[size($requiredObj)]="FaceFitChinCrease";
	$requiredObj[size($requiredObj)]="FaceFitThroat";
	$requiredObj[size($requiredObj)]="FaceFitCheek";
	$requiredObj[size($requiredObj)]="FaceFitCheekBone";
//	$requiredObj[size($requiredObj)]="FaceFitCheekRaiser";
	$requiredObj[size($requiredObj)]="FaceFitSmileBulge";
	$requiredObj[size($requiredObj)]="FaceFitFrownBulge";
	$requiredObj[size($requiredObj)]="FaceFitNose";
	$requiredObj[size($requiredObj)]="FaceFitNoseUnder";
	$requiredObj[size($requiredObj)]="FaceFitNoseCorner";
	$requiredObj[size($requiredObj)]="FaceFitNoseSide";
	$requiredObj[size($requiredObj)]="FaceFitNoseBridge";
	$requiredObj[size($requiredObj)]="FaceFitNostril";
	}
if (`asFaceIncludeAboveEyes`)
	{//AboveEyes
	$requiredObj[size($requiredObj)]="FaceFitEyeBrowInner";
	$requiredObj[size($requiredObj)]="FaceFitEyeBrowOuter";
	$requiredObj[size($requiredObj)]="FaceFitEyeBrowCenter";
	$requiredObj[size($requiredObj)]="FaceFitForeHead";
	}

//for $nonSymmetrical, also check that Left side has been completed
if ($nonSymmetrical)
	for ($obj in $requiredObj)
		{
		$asFaceFitMidText=`substitute FaceFit $obj "asFaceFitText"`;
		if (`text -q -ex $asFaceFitMidText`)
			if (`text -q -l $asFaceFitMidText`==0)
				$requiredObj[size($requiredObj)]=$obj+"Left";
		}

for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists, the Face<Fit section must be completed.");

if ($nonSymmetrical && !`objExists upperLipOuterCurveLeft`)	//Non-symmetrical was turned On, after Lip was completed
	error "Lip-Fitting was done before Non-Symmetrical was turned On. Delete the current lip-Fitting and re-do the Fitting for Non-Symmetrical model.";

if (!`stringArrayCount "decomposeMatrix" $allNodeTypes`)
	error "AdvancedSkeleton FaceSetup required Node Type \"decomposeMatrix\", which is not currently. Make sure to turn On the \"matrixNodes.mll\" plugin.";

if ($rigTypeInt==1 && `objExists FaceFitUpMidLo`)
	{
	warning "Current selected RigType does not work with \"UpMidLo\", now removing this.";
	delete FaceFitUpMidLo;
	}

createNode -n asSkipModelSymmetryCheck transform;
select $geometry;
asModelChecker;
select -cl;

asFaceUpgradeFaceFitCheck; 

//v>5.9212 no longer use SmileLine
if (`objExists FaceFitSmileLine`) delete FaceFitSmileLine;
if (`objExists FaceFitSmileLineLeft`) delete FaceFitSmileLineLeft;
//v>5.9418 no longer use CheekRaiser
if (`objExists FaceFitCheekRaiser`) delete FaceFitCheekRaiser;
if (`objExists FaceFitCheekRaiserLeft`) delete FaceFitCheekRaiserLeft;


//Ensure consistent curve-direction  added requeirement in 5.9414, so if the Fitting is old, re-build the FitForeHead
if (!`attributeExists directionChecked FaceFitForeHead` && `objExists FaceFitForeHead`)
	{
	print ("// Updating FaceFitForeHead, since it was made with a older version, and the new version has \"direction\" requirements.\n");
	if ($nonSymmetrical)
		asFaceSwitchSide 1;
	asFaceFitReSelect ForeHead "";
	delete FaceFitForeHead;
	asCreateFaceFit ForeHead "" 0 0 0 "";
	if ($nonSymmetrical)
		{
		asFaceSwitchSide 0;
		asFaceFitReSelect ForeHead "";
		delete FaceFitForeHeadLeft;
		asCreateFaceFit ForeHead "" 0 0 0 "";
		asFaceSwitchSide 1;
		}
	}

//Remove any `stray` Run command, this is not to be keept, if a completed rig does not already exists
if (!`objExists "FaceMotionSystem"`)
	if (`attributeExists run FaceFitSkeleton`)
		setAttr -type "string" FaceFitSkeleton.run "";

$scale=`getAttr FaceFitSkeleton.faceScale`;

if (!`objExists $headJoint`)
	error ("headJoint:\""+$headJoint+"\" does not exist, you need to \"Choose Head Joint\". Click on the \"advanced\" checkbox in the \"Pre\" section.");
if (!`objExists $skinCluster`)
	error ("skinCluster:\""+$skinCluster+"\" does not exist, you might need re-choose the \"Face\" object.");
//check that $headJoint is connected to skinCluster, Not the case if using imported rig via NameMatcher, and leaving $headJoint as default
$tempString=`listConnections ($headJoint+".worldMatrix")`;
if (!`size($tempString)`)
	error ("headJoint:\""+$headJoint+"\" is not connected to a SkinCluster, please go to the \"Face>Pre\" section, and click on the"
	+"\"advanced\" checkBox, and choose the correct headJoint (the joint that is skin-weighted to the face)");

if ($multiSkinClusters)
	{
	print ("// OffsetParentMatrix required for \"multiSkinClusters\", now turing ON OffsetParentMatrix.\n");
	checkBox -e -v 1 asBodyOffsetParentMatrixCheckBox;
	asSavePrepInput;
	}

//check face-weighting (unless re-building)
/* removing this for now, as it will promt even with correctly weighted face to head & neck joints
if (!`objExists "FaceMotionSystem"`)
	{
	asSelectFromTextField asFaceMaskTextField;
	ConvertSelectionToVertices;
	refresh;
	$tempString=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster`;
	if (size($tempString)>1 || $tempString[0]!=$headJoint)
		{
		$dialog=`confirmDialog -t "Confirm"
					-m "Selected vertices are not fully weighted to the headjoint."
					-b "Weight face to headjoint" -db "Weight face to headjoint"
					-b "No, keep current weighting" -b "Cancel" -ds "Cancel"`;
		if ($dialog=="Weight face to headjoint")
			skinPercent -tv $headJoint 1 $skinCluster;
		if ($dialog=="Cancel")
			error "Aborted due to Face vertices not weighted to head-joint";
		}
	select -cl;
	}
*/
if (`asIsMayaLT`)
	{
	$dialog=`confirmDialog -t "Confirm"
				-m "Maya LT detected.\n\nFaceSetup will not be as accurate,\ndue to missing deformer types."
				-b "Ok, continue" -db "Ok, continue"
				-b "Cancel" -ds "Cancel"`;
	if ($dialog=="Cancel")
		error "Aborted due to Maya LT warning.";
	}

//ensure not leaving behind assists
if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

//another non-unique name check, first check is at asChooseInput
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	if (`gmatch $allFaceGeo[$i] "*|*"`)
		{
		select $allFaceGeo[$i];
		error ("Selected object: \""+$allFaceGeo[$i]+"\" does not have a unique name, rename to a unique name.");
		}
	if (`objExists $allFaceGeo[$i]`=="")
		error ("Did not find All-Head object:\""+$allFaceGeo[$i]+"\", you need to re-choose AllHead objects.");
	if (`asGetSkinCluster $allFaceGeo[$i]`=="")
		error ("Did not find skinCluster on All-Head object:\""+$allFaceGeo[$i]+"\"");
	}

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;

//$allFaceGeo to non-polysmooth for faster execution and avoid memory full crash
select $allFaceGeo;
displaySmoothness -divisionsU 0 -divisionsV 0 -pointsWire 4 -pointsShaded 1 -polygonObject 1;
select -cl;

if (!`attributeExists buildCompleted FaceFitSkeleton`)
	addAttr -k 0 -ln buildCompleted -at bool -dv 0 FaceFitSkeleton;
if (`getAttr FaceFitSkeleton.buildCompleted`)
		$previousBuildCompleted=1;

if (!$previousBuildCompleted)
	{
	//Auto-cleanup leftovers from previous Build attempts
	$tempString={"FaceAllSet","FaceControlSet","FaceAreas","FaceBuildingSets","eyeLidArea","eyeLidAreaLeft",
		"lipArea","lipFalloffArea","lipFalloffAreaMax","lowerTeethSet","upperTeethSet","FaceMusclesLayer",
		"lowerOS2WSTG_L","lowerOS2WSTG_L","lowerOS2WSTG_R","lowerOS2WSTG_R",
		"allBeforeFaceBuild",
		"FaceMotionSystem","FaceDeformationSystem","FaceBuildInProgress","FaceJoint_M"};
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists $tempString[$i]`)
			{
			if (!$foundLeftover)
				print "// Detected leftover nodes from previous FaceBuild attempt, now removing these:\n";
			print ($tempString[$i]+"\n");
			delete $tempString[$i];
			$foundLeftover=1;
			}
	if ($foundLeftover)
		for ($i=0;$i<size($allFaceGeo);$i++)
			{
			$sc=`asGetSkinCluster $allFaceGeo[$i]`;
			if ($sc!="")
				{
				select $allFaceGeo[$i];
				skinPercent -normalize true $sc;
				dgdirty -a;
				}
			}
	}

//Removed, as we added Model Check button to the Pre section
/*
//check symmetry (unless re-building)
if (!$nonSymmetrical && !`objExists "FaceMotionSystem"`)
	{
	select $geometry;
	if (`gmatch $geometry "*[.]*"`)
		{
		$tempString=`ls -sl -objectsOnly`;
		if (`objectType $tempString[0]`=="mesh")
			$tempString=`listRelatives -p $tempString[0]`;
		select $tempString[0];
		}
	asModelChecker;
	}
*/

//Check $skinCluster
if (`getAttr ($skinCluster+".maintainMaxInfluences")`)
	setAttr ($skinCluster+".maintainMaxInfluences") 0;
if (`getAttr ($skinCluster+".normalizeWeights")`!=1)
	setAttr ($skinCluster+".normalizeWeights") 1;

//turn Off joint vis
if (`attributeExists jointVis Main`)
	setAttr Main.jointVis 0;

//duplicate Fitting to Left, if not using "nonSymmetrical"
if ($nonSymmetrical)
	asFaceShowBothSides;
else
	{
	$tempString=`listRelatives -c -type transform FaceFitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{

		if (`gmatch $tempString[$i] "*Center"` || $tempString[$i]=="FaceFitNose" || $tempString[$i]=="FaceFitNoseUnder" || $tempString[$i]=="FaceFitNoseBridge"
			|| $tempString[$i]=="FaceFitJaw" || $tempString[$i]=="FaceFitChinCrease" || $tempString[$i]=="FaceFitThroat" || $tempString[$i]=="FaceFitChinCrease")
			continue;
		if (`objExists ($tempString[$i]+"Left")`)
			delete ($tempString[$i]+"Left");
		duplicate -n ($tempString[$i]+"Left") $tempString[$i];
		setAttr ($tempString[$i]+"Left.sx") (-1*`getAttr ($tempString[$i]+".sx")`);
		$tempString2=`listRelatives -f -ad -type transform ($tempString[$i]+"Left")`;
		$tempString3=`listRelatives -ad -type transform ($tempString[$i]+"Left")`;
		for ($y=0;$y<size($tempString2);$y++)
			rename $tempString2[$y] ($tempString3[$y]+"Left");
		}
	}

//non-used intermidiate shapes not needed
$tempString=`listRelatives -s -f $geometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`getAttr ($tempString[$i]+".intermediateObject")`)
		continue;
	$connectedToDeformer=0;
	$tempString2=`listConnections $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		$tempString3=`ls -showType $tempString2[$y]`;
		if ($tempString3[1]!="shadingEngine" && $tempString3[1]!="objectSet")
			{
			$connectedToDeformer=1;
			break;
			}
		}
	if (!$connectedToDeformer)
		{
		print ("// Removing un-used intermediate shape:\""+$tempString[$i]+"\"\n");
		delete $tempString[$i];
		}
	}

//disable & flush cached-playback (maya2019 and above)
catchQuiet (`evaluator -name cache -enable 0`);
catchQuiet (`cacheEvaluator -flushCache "destroy"`);

setAttr ($skinCluster+".skinningMethod") 0;//might have been blendWeighted, from FaceSetup by previous version

//$upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
//$lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`+1;

//check that names are avaiable
string $names[]={"Nose_M","Eye_R","Eye1_R","Eye_L","Eye1_L"};
for ($i=0;$i<size($names);$i++)
	if (`objExists $names[$i]` && !`objExists "FaceMotionSystem"`)
		{
		select `ls $names[$i]`;
		error ("A object with the name:\""+$names[$i]+"\" already exists, rename this to something else, before running the Build.\n");
		}
		

//Re-building ?
if (`objExists "FaceMotionSystem"`)
	{
	catchQuiet (`asGoToBuildPose faceSetup`);

	createNode -n prefix_FaceGroup transform;
	setAttr prefix_FaceGroup.v 0;
	addAttr -ln version -at double prefix_FaceGroup;
	setAttr -l 1 prefix_FaceGroup.version `getAttr FaceGroup.version`;

	//SkinWeightsHolder
	polySphere -n asFaceSkinWeightsHolder -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
	connectAttr ($geometry+".outMesh") asFaceSkinWeightsHolder.inMesh;
	refresh;
	disconnectAttr ($geometry+".outMesh") asFaceSkinWeightsHolder.inMesh;
	select `listConnections -s 1 -d 0 -type joint ($skinCluster+".matrix")`;
	select -add asFaceSkinWeightsHolder;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] asFaceSkinWeightsHolderSC;
	parent asFaceSkinWeightsHolder prefix_FaceGroup;
	select $geometry asFaceSkinWeightsHolder;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

	//keepCustomControls
	if (($keepAll || $keepCustomControls) && `objExists FaceCustomSystem`)
		parent -w FaceCustomSystem;

	//changed rig-type since previous build
	if (`attributeExists RigType FaceFitSkeleton`)
		if (`getAttr FaceFitSkeleton.RigType`==0)
			if (size(`ls -type blendShape "asFaceBS*"`))
				{
				//changed from BS to nonBS, delete BS and ensure not copy weights
				delete `ls -type blendShape "asFaceBS*"`;
				delete asFaceSkinWeightsHolder;
				}

	//weight all old FaceJoints to HeadJoint
	asFaceLockWeights 1;
	setAttr ($headJoint+".lockInfluenceWeights") 0;
	$tempString=`listConnections ($skinCluster+".matrix")`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im FaceAllSet $tempString[$i]`)
			setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
	catchQuiet (`skinPercent -tv $headJoint 1 $skinCluster $geometry`);
	removeUnusedForSkin $skinCluster 0; 
	asFaceLockWeights 0;
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if ($allFaceGeo[$i]==$geometry)
			continue;
		$sc=`asGetSkinCluster $allFaceGeo[$i]`;
		catchQuiet (`skinPercent -tv $headJoint 1 $sc $allFaceGeo[$i]`);
		removeUnusedForSkin $sc 0;
		}

	if (`getAttr FaceGroup.v`)
		asToggleFitFace;

	//Some DrivingSystem SDK`s might not be part of FaceAllSet, so adding these
//	//removing this in v 5.8102, is this means ANY custom added  DrivingSystems even for body, will be added
	$tempString=`ls "bwSDK*"`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists AllSet`)//FaceSetup with no BodySetup does not have this
			if (`sets -im AllSet $tempString[$i]`)
				continue;//if in AllSet, it is a Body-DrivingSystem, skip
		$tempString2=`listConnections -s 0 -d 1 $tempString[$i]`;
		if (`sets -im FaceAllSet $tempString[$i]`)
			continue;//Not member of FaceAllSet, probaby a CustomController, skip
		$animCurves=`listConnections -scn 1 -s 1 -d 0 -type animCurve $tempString[$i]`;
		for ($y=0;$y<size($animCurves);$y++)
				if (!`sets -im FaceAllSet $animCurves[$y]`)
					sets -add FaceAllSet $animCurves[$y];
		}

	if (`objExists SquashSetup`)
		{//remove existing squash
		createNode -n prefix_SquashSetup -p prefix_FaceGroup transform;
		if (`attributeExists optimizedSquash SquashSetup`)
			addAttr -k 0 -ln optimizedSquash -at bool -dv true prefix_SquashSetup;
		if (`objExists SquashSet`)//new way (v5.750)
			asDeleteHeadSquash;
		else
			delete SquashSetup SquashControls squashFfd;//old way (pre v5.750)
		}

	$allSetMembers=`sets -q FaceAllSet`;
	$allSetMembers[size($allSetMembers)]="FaceAllSet";
	$allSetMembers[size($allSetMembers)]="FaceControlSet";
	$allSetMembers[size($allSetMembers)]="FaceAreas";

	for ($i=0;$i<size($allSetMembers);$i++)
		if (`objExists $allSetMembers[$i]`)
			$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
		else
			$allSetMembers[$i]="";
	parent prefix_FaceMotionSystem prefix_FaceDeformationSystem prefix_FaceGroup;
	$tempString=`listRelatives -ad -type transform prefix_FaceGroup`;
	for ($i=0;$i<size($tempString);$i++)
		if (!`gmatch $tempString[$i] "prefix_*"`)
			rename $tempString[$i] ("prefix_"+$tempString[$i]);
	}

//could have "leftover Lip/lid assist-softmods"
$deleteObjs={"upperTempSoftModHandle1","lowerTempSoftModHandle1","upperTempSoftModHandle2","lowerTempSoftModHandle2"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

//Re-generate SkinCluster, since old skinCluster can have wrong size of .bindPreMatrix, (removeMultiInstance does not always work)
duplicate -n newSkinClusterLayer $geometry;
asLockAttr newSkinClusterLayer 0 0 0 0;
sets -e -forceElement initialShadingGroup newSkinClusterLayer;
$tempString=`listRelatives -s -f newSkinClusterLayer`; 
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
$infJoints=`listConnections -s 1 -d 0 -type joint ($skinCluster+".matrix")`;
select newSkinClusterLayer $infJoints;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] newSkinClusterSC;
select $geometry newSkinClusterLayer;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete $skinCluster;
select $geometry $infJoints;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] $skinCluster;
select newSkinClusterLayer $geometry;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete newSkinClusterLayer;
if (`objExists asFaceDeltaMush`)
	catchQuiet (`reorderDeformers asFaceDeltaMush $skinCluster $geometry`);


//allBeforeFaceBuild
select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
sets -n allBeforeFaceBuild;
select -cl;

asSetFixedWrapOptions;
asFaceEnsureAdvancedBase;

//keepCustomControls
if (($keepAll || $keepCustomControls) && `objExists |FaceCustomSystem`)
	parent |FaceCustomSystem FaceMotionSystem;

//setting the size of OnFacecontrols (sets the scale the On-Face-controllers `operate` on)
setAttr OnFacecontrols.s -type float3 ($scale/14.4300) ($scale/14.4300) ($scale/14.4300);
setAttr ConstrainedSetup.s -type float3 ($scale/14.4300) ($scale/14.4300) ($scale/14.4300);

select $geometry;
//blendShape -n asFaceBS -frontOfChain;

//Face joint 
select -cl;
joint -n FaceJoint_M;
setAttr FaceJoint_M.drawStyle 2;//Draw-style=none, otherwise looks too busy
asAlign FaceJoint_M $headJoint 1 0 0 0;
move -r 0 0 ($scale*0.1) FaceJoint_M;
//parent FaceJoint_M FaceDeformationSystem;
if ($multiSkinClusters)
	{
	parent FaceJoint_M DeformationSystem;
	setAttr -l 1 FaceJoint_M.inheritsTransform 0;
	if (`attributeExists jointVis Main`)
		connectAttr Main.jointVis FaceJoint_M.v;
	}
else
	parent FaceJoint_M $headJoint;
setAttr FaceJoint_M.segmentScaleCompensate 0;

//Make sure defined skinCluster is correct
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="skinCluster")
		if ($tempString[$y]!=$skinCluster)
			{
			print ("// Updated SkinCluster info, used to be:\""+$skinCluster+"\", now it is:\""+$tempString[$y]+"\".\n");
			$skinCluster=$tempString[$y];
			textField -e -tx $skinCluster asFaceSkinClusterTextField;
			}

//Disable any deltaMush
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="deltaMush")
		setAttr ($tempString[$y]+".envelope") 0;

//teethSets, for tracking on cut-out objects
sets -em -n upperTeethSet;
sets -em -n lowerTeethSet;
sets -add FaceBuildingSets upperTeethSet lowerTeethSet;
if ($upperTeeth!="") {eval ("select "+$upperTeeth);sets -add upperTeethSet;}
if ($lowerTeeth!="") {eval ("select "+$lowerTeeth);sets -add lowerTeethSet;}

// Unlock All SkinInfluences
if (`objExists DeformSet`)
	{
	$deformJointsList=`sets -q "DeformSet"`;
	for ($i=0;$i<size($deformJointsList);$i++)
		if (`attributeExists lockInfluenceWeights $deformJointsList[$i]`)
			if (`getAttr ($deformJointsList[$i]+".lockInfluenceWeights")`)
				setAttr ($deformJointsList[$i]+".lockInfluenceWeights") 0;
	}

//orientationCylinder
if (!`objExists FaceControlOrient`)
	{
	cylinder -n FaceControlOrient -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 180 -r 1 -hr 2 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0;
	sets -e -forceElement asRedSG FaceControlOrient;
	scale -r -p 0 0 0 0.5 0.5 0.5 FaceControlOrient.cv[0:99][0:99];
	move -r -os -wd 0 0.5 0 FaceControlOrient.cv[0:99][0:99];
	$posA=`xform -q -ws -t FaceFitSkeletonCircleShape.cv[0]`;
	$posB=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
	if (`objExists JawPivot`) $posC=`xform -q -ws -t JawPivot`;
	else $posC=`xform -q -ws -t FaceFitSkeletonCircleShape.cv[5]`;
	if (`objExists NoseUnder`) $posD=`xform -q -ws -t NoseUnder`;
	else $posD=`xform -q -ws -t FaceFitSkeletonCircleShape.cv[6]`;
	xform -ws -t 0 $posA[1] $posC[2] FaceControlOrient;
	scale -r ($posC[0]*2) ($posB[1]-$posA[1]) (($posD[2]-$posC[2])*2) FaceControlOrient;
	}
else
	parent -w FaceControlOrient;
refresh;
parent FaceControlOrient FaceBuildInProgressHidden;

//GameEngine Max influencese
if ($maxInfluences)
	{
	skinCluster -e -mi 4 $geometry;
	setAttr ($skinCluster+".maxInfluences") 4;
	setAttr ($skinCluster+".maintainMaxInfluences") 1;
	}

asUpdateButtonEnables;
select -cl;
}

global proc asFaceCtrlBox ()
{
int $phonemes=1;
int $emotions=1;
int $arkit,$robloxHead,$snapChat;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $temp[],$bb[],$pos[],$posA[];
string $side;
string $mask=`textField -q -tx asFaceMaskTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
if (`objExists ctrlBoxOffset`)
	delete ctrlBoxOffset;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $tempString[];

if (`attributeExists Phonemes FaceFitSkeleton`)
	if (!`getAttr FaceFitSkeleton.Phonemes`)
		$phonemes=0;
if (`attributeExists Emotions FaceFitSkeleton`)
	if (!`getAttr FaceFitSkeleton.Emotions`)
		$emotions=0;
if (`attributeExists ARKit FaceFitSkeleton`)
	$arkit=`getAttr FaceFitSkeleton.ARKit`;
if (`attributeExists RobloxHead FaceFitSkeleton`)
	$robloxHead=`getAttr FaceFitSkeleton.RobloxHead`;
if (`attributeExists SnapChat FaceFitSkeleton`)
	$snapChat=`getAttr FaceFitSkeleton.SnapChat`;

setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v 0;

$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBox;
createNode -n ctrlBoxOffset transform;
parent ctrlBox ctrlBoxOffset;
parent ctrlBoxOffset ControlsSetup;

addAttr -k 1 -ln "limits" -at bool -dv true ctrlBox;

addAttr -k 1 -ln "ACtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "EyeCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "AimCtrlVis" -at bool -dv true ctrlBox;
//addAttr -k 1 -ln "Lid1CtrlVis" -at bool -dv true ctrlBox;
//addAttr -k 1 -ln "Lid2CtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "TeethCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "TongueCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RegionsCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "UpMidLoCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "CustomCtrlVis" -at bool -dv true ctrlBox;
if (!`attributeExists jointVis Main`)//If we have AdvSkel body rig, Main.jointVis works, otherwise add attr
	{
	addAttr -k 1 -ln "jointsVis" -at bool -dv false ctrlBox;
	connectAttr ctrlBox.jointsVis FaceJoint_M.v;
	}
//connectAttr ctrlBox.OnFaceCtrlVis OnFacecontrols.v;

setAttr ctrlBox.AimCtrlVis 0;
setAttr ctrlBox.RegionsCtrlVis 0;

setAttr ctrlBox.overrideEnabled 1;
setAttr ctrlBox.overrideColor 17;

//Expand length down
move -r 0 -0.4 0 ctrlBoxShape.cv[2:3];
xform -s ($scale/8.0) ($scale/4.0) ($scale/8.0) ctrlBox;
makeIdentity -a 1 -t 0 -r 0 -s 1 ctrlBox;

eval ("select "+$mask);
$bb=`xform -q -bb`;
$temp[0]=$bb[3]*1.5;
$temp[1]=($bb[1]+$bb[4])/2.0;
$temp[2]=($bb[2]+$bb[5])/2.0;
if (`objExists FitEyeBall`)
	{
	$posA=`xform -q -ws -t FitEyeBall`;
	$temp[1]=$posA[1]-(($scale/4.0)*0.38);
	$temp[2]=$posA[2];
	}
xform -ws -t $temp[0] $temp[1] $temp[2] ctrlBoxOffset;

if (`objExists prefix_ctrlBox`)
	{
	$temp=`getAttr prefix_ctrlBox.t`;
	setAttr ctrlBox.t -type float3 $temp[0] $temp[1] $temp[2];
	$temp=`getAttr prefix_ctrlBox.s`;
	setAttr ctrlBox.s -type float3 $temp[0] $temp[1] $temp[2];
	}

//ctrlBoxTemplate
$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBoxTemplate;
parent ctrlBoxTemplate ctrlBox;
setAttr -type float3 ctrlBoxTemplate.t 0 0 0;
setAttr -type float3 ctrlBoxTemplate.s ($scale/24.0) ($scale/24.0) ($scale/24.0);
setAttr ctrlBoxTemplateShape.overrideEnabled 1;
setAttr ctrlBoxTemplateShape.overrideDisplayType 2;

//ctrlTemplate
duplicate -n ctrlTemplate ctrlBoxTemplate;
parent ctrlTemplate ctrlBoxTemplate;
transformLimits -tx -1 1 -ty -1 1 -tz 0 0 -etx 1 1 -ety 1 1 -etz 1 1 ctrlTemplate;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransYLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransYLimitEnable`);
setAttr ctrlTemplateShape.overrideDisplayType 0;
setAttr ctrlTemplate.rz 45;
setAttr -type float3 ctrlTemplate.s 0.2 0.2 0.2;
setAttr ctrlTemplateShape.overrideEnabled 0;
//setAttr ctrlTemplateShape.overrideColor 17;
makeIdentity -a 1 -t 0 -r 1 -s 1 ctrlTemplate;
setAttr -l 1 -k 0 ctrlTemplate.tz;
setAttr -l 1 -k 0 ctrlTemplate.rx;
setAttr -l 1 -k 0 ctrlTemplate.ry;
setAttr -l 1 -k 0 ctrlTemplate.rz;
setAttr -l 1 -k 0 ctrlTemplate.sx;
setAttr -l 1 -k 0 ctrlTemplate.sy;
setAttr -l 1 -k 0 ctrlTemplate.sz;
setAttr -l 1 -k 0 ctrlTemplate.v;
sets -add FaceControlSet ctrlTemplate;

asFaceCreateCtrlBox "Brow_R" (($scale/4.0)*-0.25) (($scale/4.0)*0.75) 0;
asFaceCreateCtrlBox "Brow_L" (($scale/4.0)*0.25) (($scale/4.0)*0.75) 0;
asFaceCreateCtrlBox "Eye_R" (($scale/4.0)*-0.25) (($scale/4.0)*0.38) 0;
asFaceCreateCtrlBox "Eye_L" (($scale/4.0)*0.25) (($scale/4.0)*0.38) 0;
asFaceCreateCtrlBox "Cheek_R" (($scale/4.0)*-0.25) 0 1;
asFaceCreateCtrlBox "Cheek_L" (($scale/4.0)*0.25) 0 1;
asFaceCreateCtrlBox "Nose_R" (($scale/4.0)*-0.25) (($scale/4.0)*-0.22) 1;
asFaceCreateCtrlBox "Nose_L" (($scale/4.0)*0.25) (($scale/4.0)*-0.22) 1;
asFaceCreateCtrlBox "Lips_M" 0 (($scale/4.0)*-0.42) 0;
asFaceCreateCtrlBox "Mouth_M" 0 (($scale/4.0)*-0.64) 2;
asFaceCreateCtrlBox "MouthCorner_R" (($scale/4.0)*-0.25) (($scale/4.0)*-1) 0;
asFaceCreateCtrlBox "MouthCorner_L" (($scale/4.0)*0.25) (($scale/4.0)*-1) 0;

//scale -r 2 2 2 ctrlBoxMouth_M;

//setAttr -l 0 -k 1 ctrlEye_L.sx;setAttr -l 0 -k 1 ctrlEye_L.sy;setAttr -l 0 -k 1 ctrlEye_L.sz;
//setAttr -l 0 -k 1 ctrlEye_R.sx;setAttr -l 0 -k 1 ctrlEye_R.sy;setAttr -l 0 -k 1 ctrlEye_R.sz;

$tempString=`listAttr -k ctrlBox`;
for ($i=0;$i<size($tempString);$i++)
	setAttr -k 0 -cb 1 ("ctrlBox."+$tempString[$i]);

//Lips
//scale -r 0.35 0.35 0.35 ctrlBoxLips_M;
//(string $name, float $x, float $y, int $half)

//Phonemes
if ($phonemes)
	{
	$tempString[0]=`curve -d 1 -p -0.922009 0 1 -p -0.176985 0 -0.989507 -p 0.194834 0 -0.989507 -p 0.934309 0 1 -p 0.572202 0 1 -p 0.39323 0 0.493605 -p -0.389254 0 0.493605 -p -0.56129 0 1 -p -0.922009 0 1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
	rename $tempString[0] ctrlPhonemes_M;
	sets -add FaceControlSet ctrlPhonemes_M;
	$tempString[0]=`curve -d 1 -p -0.303236 0 0.224453 -p -0.00217431 0 -0.693995 -p 0.305825 0 0.224453 -p -0.303236 0 0.224453 -k 0 -k 1 -k 2 -k 3`;
	rename $tempString[0] ctrlPhonemes_M1;
	parent -add -s ctrlPhonemes_MShape1 ctrlPhonemes_M;
	delete ctrlPhonemes_M1;
	rotate -r -p 0 0 0 -os 90 0 0 ctrlPhonemes_M.cv[0:99];
	scale -r -p 0 0 0 0.6 0.6 0.6 ctrlPhonemes_M.cv[0:99];
	asLockAttr ctrlPhonemes_M 1 1 1 1;
	duplicate -n ctrlBoxPhonemes_M ctrlBoxTemplate;
	delete `listRelatives -f -c -type transform ctrlBoxPhonemes_M`;
	parent ctrlPhonemes_M ctrlBoxPhonemes_M;
	setAttr ctrlBoxPhonemes_M.t -type float3 0 0 0;
	setAttr ctrlBoxPhonemes_M.s -type float3 ($scale/66.0) ($scale/66.0) ($scale/66.0);
	//setAttr ctrlBoxPhonemes_M.ty (($scale/4.0)*-0.81);
	setAttr ctrlBoxPhonemes_M.translateX ($scale/-25.0);
	setAttr ctrlBoxPhonemes_M.ty (($scale/4.0)*-1.3);
	}

//Emotions
if ($emotions)
	{
	circle -n ctrlEmotions_M -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.025 -d 3 -ut 0 -tol 0.000610236 -s 4 -ch 0;
	sets -add FaceControlSet ctrlEmotions_M;
	move -r -0.04 0.075 0 ctrlEmotions_M.cv[0:99];
	circle -n ctrlEmotions_M1 -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.025 -d 3 -ut 0 -tol 0.000610236 -s 4 -ch 0;
	move -r 0.04 0.075 0 ctrlEmotions_M1.cv[0:99];
	parent -add -s ctrlEmotions_M1Shape ctrlEmotions_M;
	delete ctrlEmotions_M1;
	rename ctrlEmotions_M1Shape ctrlEmotions_MShape1;
	move -r -os -wd 0 -0.02 0 ctrlEmotions_MShape.cv[1] ctrlEmotions_MShape1.cv[1];
	move -r -os -wd 0 0.02 0 ctrlEmotions_MShape.cv[3] ctrlEmotions_MShape1.cv[3];
	circle -n ctrlEmotions_M2 -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.07 -d 3 -ut 0 -tol 0.000610236 -s 8 -ch 0;
	move -r -os -wd 0 -0.12 0 ctrlEmotions_M2.cv[1];
	move -r -os -wd 0 -0.07 0 ctrlEmotions_M2.cv[0] ctrlEmotions_M2.cv[2];
	move -r 0 0.04 0 ctrlEmotions_M2.cv[0:99];
	parent -add -s ctrlEmotions_M2Shape ctrlEmotions_M;
	delete ctrlEmotions_M2;
	rename ctrlEmotions_M2Shape ctrlEmotions_MShape2;
	//parent ctrlEmotions_M ctrlBox;
	select ctrlEmotions_MShape.cv[0:99] ctrlEmotions_MShape1.cv[0:99] ctrlEmotions_MShape2.cv[0:99];
	scale -r -p 0 0 0 10 10 10;
	move -r 0 -0.3 0;
	//setAttr ctrlEmotions_M.t -type float3 0 0 0;
	//move -r 0 ($scale*-1.3) 0 ctrlEmotions_M;
	asLockAttr ctrlEmotions_M 1 1 1 1;
	duplicate -n ctrlBoxEmotions_M ctrlBoxTemplate;
	delete `listRelatives -f -c -type transform ctrlBoxEmotions_M`;
	parent ctrlEmotions_M ctrlBoxEmotions_M;
	setAttr ctrlBoxEmotions_M.t -type float3 0 0 0;
	setAttr ctrlBoxEmotions_M.s -type float3 ($scale/66.0) ($scale/66.0) ($scale/66.0);
	setAttr ctrlBoxEmotions_M.ty (($scale/4.0)*-1.3);
	}

//RobloxHead
if ($robloxHead)
	{
	duplicate -n ctrlBoxRobloxHead_M ctrlBoxTemplate;
	delete `listRelatives -f -c -type transform ctrlBoxRobloxHead_M`;
	setAttr ctrlBoxRobloxHead_M.translateX (($scale/25.0)*2);
	setAttr ctrlBoxRobloxHead_M.ty (($scale/4.0)*-1.3);
	setAttr ctrlBoxRobloxHead_M.s -type float3 ($scale/66.0) ($scale/66.0) ($scale/66.0);

	createNode -n ctrlRobloxHead_M -p ctrlBoxRobloxHead_M transform;
	sets -add FaceControlSet ctrlRobloxHead_M;
	createNode -n ctrlRobloxHeadTempXform transform;
	createNode nurbsCurve -n ctrlRobloxHead_MShape -p ctrlRobloxHeadTempXform;
	setAttr ".cc" -type "nurbsCurve" 
		1 4 0 no 3
		5 0 1 2 3 4
		5
		-0.46293206014647192 0.80755095211147043 -1.793123321184243e-016
		0.80967673357217584 0.46493704977017825 -1.0323676353122885e-016
		0.46706283123088332 -0.80515252407831328 1.7877977411336081e-016
		-0.80806518235792024 -0.46923548208151244 1.0419120723559601e-016
		-0.46293206014647192 0.80755095211147043 -1.793123321184243e-016
		;
	createNode nurbsCurve -n ctrlRobloxHead_MShape1 -p ctrlRobloxHeadTempXform;
	setAttr ".cc" -type "nurbsCurve" 
		1 4 0 no 3
		5 0 1 2 3 4
		5
		-0.093420957950459849 0.16141288444794716 -3.5840860157054157e-017
		0.15956795949331018 0.089731233936296548 -1.9924336388820523e-017
		0.090727709937966347 -0.16625073783596675 3.6915079401282191e-017
		-0.16132337720844686 -0.089217502220313286 1.9810265032907567e-017
		-0.093420957950459849 0.16141288444794716 -3.5840860157054157e-017
		;
	parent -add -s ctrlRobloxHead_MShape ctrlRobloxHead_MShape1 ctrlRobloxHead_M;
	delete ctrlRobloxHeadTempXform;
	asLockAttr ctrlRobloxHead_M 1 1 1 1;
	setAttr ctrlRobloxHead_MShape.isHistoricallyInteresting 0;
	setAttr ctrlRobloxHead_MShape1.isHistoricallyInteresting 0;
	}

//ARKit
if ($arkit)
	{
	duplicate -n ctrlBoxARKit_M ctrlBoxTemplate;
	delete `listRelatives -f -c -type transform ctrlBoxARKit_M`;
	setAttr ctrlBoxARKit_M.translateX ($scale/25.0);
	setAttr ctrlBoxARKit_M.ty (($scale/4.0)*-1.3);
	setAttr ctrlBoxARKit_M.s -type float3 ($scale/66.0) ($scale/66.0) ($scale/66.0);

	createNode -n ctrlARKit_M -p ctrlBoxARKit_M transform;
	sets -add FaceControlSet ctrlARKit_M;
	createNode -n ctrlARKitTempXform transform;
	createNode nurbsCurve -n ctrlARKit_MShape -p ctrlARKitTempXform;
		setAttr ".cc" -type "nurbsCurve" 
			3 16 0 no 3
			21 0 0 0 0.20948400980000001 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 15 15
			19
			0.63846096134640429 0.32252763421928005 0
			0.5908738429722421 0.38848194907001943 0
			0.30837388102789964 0.57310297306837465 0
			-0.0015820896781627463 0.31814299945101532 0
			-0.24170475847354664 0.58581709915072566 0
			-0.73451460067053642 0.30795786940643505 0
			-0.70856300895458435 -0.31016186055532613 0
			-0.47735791912155917 -0.69943573629460321 0
			-0.2698062276640491 -0.86573132570269684 0
			0.018081559092066258 -0.67584338018919243 0
			0.29429525233568504 -0.86144015037234545 0
			0.48890166907027149 -0.71951976011925445 0
			0.62095782099046715 -0.51069688745131747 0
			0.68102676565410813 -0.35164017665726316 0
			0.68102673791348933 -0.35164018515497442 0
			0.53121265408213914 -0.26082274878071138 0
			0.40750679534784229 -0.023495892825406491 0
			0.51116180169515046 0.26313239280615475 0
			0.63966206997360631 0.32252762541845964 0
			;
	createNode nurbsCurve -n ctrlARKit_MShape1 -p ctrlARKitTempXform;
		setAttr ".cc" -type "nurbsCurve" 
			3 8 0 no 3
			13 0 0 0 1 2 3 4 5 6 7 8 8 8
			11
			0.32320616941669478 0.90970256535044669 0
			0.33632375210066751 0.79643922188956595 0
			0.24389755522904263 0.61384955188135881 0
			0.09672038795688391 0.52143484977590926 0
			-0.013701450778161539 0.51344955868791731 0
			-0.013701450513186147 0.51344956243314599 0
			-0.013701450513186149 0.51344956243314599 0
			-0.016698808627702306 0.61187047125862426 0
			0.039354082111945757 0.76744943632243734 0
			0.20185915557499434 0.90005632105055489 0
			0.32320615690201521 0.90970254812654594 0
			;
	parent -add -s ctrlARKit_MShape ctrlARKit_MShape1 ctrlARKit_M;
	delete ctrlARKitTempXform;
	asLockAttr ctrlARKit_M 1 1 1 1;
	setAttr ctrlARKit_MShape.isHistoricallyInteresting 0;
	setAttr ctrlARKit_MShape1.isHistoricallyInteresting 0;
	}
//snapChat
if ($snapChat)
	{
	duplicate -n ctrlBoxSnapChat_M ctrlBoxEmotions_M;
	setAttr ctrlBoxSnapChat_M.translateX ($scale/25.0);
	delete ctrlBoxSnapChat_M|ctrlEmotions_M;

	createNode -n ctrlSnapChat_M -p ctrlBoxSnapChat_M transform;
	sets -add FaceControlSet ctrlSnapChat_M;
	createNode -n ctrlSnapChatTempXform transform;
	createNode nurbsCurve -n ctrlSnapChat_MShape -p ctrlSnapChatTempXform;
	setAttr ".cc" -type "nurbsCurve" 
		3 34 0 no 3
		39 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
		 26 27 28 29 30 31 32 33 34 34 34
		37
		0.0030724584016100847 -0.72415333316094221 0
		-0.070068244057445855 -0.72415333316094221 0
		-0.19384481744969426 -0.67633056616848275 0
		-0.33731311842707318 -0.55536709671696727 0
		-0.4554634839378558 -0.56380640853916619 0
		-0.56798764156717252 -0.62006848735382436 0
		-0.5342303942783776 -0.45972156273204795 0
		-0.67769869525575632 -0.46253466667278093 0
		-0.84929803564046447 -0.37814154845079329 0
		-0.63550213614476259 -0.35282361298419695 0
		-0.48359452334518488 -0.2009160001846193 0
		-0.35700484601220361 0.0072536914296166622 0
		-0.63550213614476259 0.05226335448134338 0
		-0.61299730461889934 0.17885303181432483 0
		-0.48359452334518488 0.13946957664406393 0
		-0.39357519724173157 0.13103026482186514 0
		-0.40764071694539622 0.19573165545872218 0
		-0.45177785159041656 0.56867395284608491 0
		0 0.86143228140292361 0
		0.45177785159041656 0.56867395284608491 0
		0.40764071694539622 0.19573165545872218 0
		0.39357519724173157 0.13103026482186514 0
		0.48359452334518488 0.13946957664406393 0
		0.61299730461889934 0.17885303181432483 0
		0.63550213614476259 0.05226335448134338 0
		0.35700484601220361 0.0072536914296166622 0
		0.48359452334518488 -0.2009160001846193 0
		0.63550213614476259 -0.35282361298419695 0
		0.84929803564046447 -0.37814154845079329 0
		0.67769869525575632 -0.46253466667278093 0
		0.5342303942783776 -0.45972156273204795 0
		0.56798764156717252 -0.62006848735382436 0
		0.4554634839378558 -0.56380640853916619 0
		0.33731311842707318 -0.55536709671696727 0
		0.19384481744969426 -0.67633056616848275 0
		0.070068244057445855 -0.72415333316094221 0
		-0.0030724584016100847 -0.72415333316094221 0
		;
	parent -add -s ctrlSnapChat_MShape ctrlSnapChat_M;
	delete ctrlSnapChatTempXform;
	asLockAttr ctrlSnapChat_M 1 1 1 1;
	setAttr ctrlSnapChat_MShape.isHistoricallyInteresting 0;
	}

delete ctrlBoxTemplate;

//ctrlBox2
duplicate -n ctrlBox2Offset ctrlBoxOffset;
rename ctrlBox2Offset|ctrlBox ctrlBox2;
setAttr ctrlBox2Offset.tx (`getAttr ctrlBox2Offset.tx`+($scale/3.5));
delete `listRelatives -c -type transform -f ctrlBox2`;
$tempString=`listAttr -ud ctrlBox2`;
for ($i=0;$i<size($tempString);$i++)
	deleteAttr ("ctrlBox2."+$tempString[$i]);
createNode -n ctrlBox2Constrained -p ConstrainedSetup transform;
asParentConstraint ctrlBox2 ctrlBox2Constrained "";
//parentConstraint ctrlBox2 ctrlBox2Constrained;
//scaleConstraint ctrlBox2 ctrlBox2Constrained;

for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) $side="_R";
	else $side="_L";

	circle -n ("Eye1"+$side) -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.3 -d 3 -ut 0 -tol 0.000610236 -s 8 -ch 0;
	scale -r -p 0 0 0 ($scale/10) ($scale/10) ($scale/10) ("Eye1"+$side+".cv[0:99]");
	setAttr ("Eye1"+$side+".tx") (-0.05*$scale*$b);
	setAttr ("Eye1"+$side+".ty") (0.095*$scale);
	parent -r ("Eye1"+$side) ctrlBox2;

	duplicate -n ("EyeRegion1"+$side) ("Eye1"+$side);
	$pos=`xform -q -ws -t ("EyeRegion1"+$side)`;
	scale -r -p $pos[0] $pos[1] $pos[2] 1.5 1.5 1.5 ("EyeRegion1"+$side+".cv[0:99]");

	circle -n ("EyeBrowRegion1"+$side) -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.3 -d 3 -ut 0 -tol 0.000610236 -s 8 -ch 0;
	scale -r -p 0 0 0 ($scale/7) ($scale/10) ($scale/8) ("EyeBrowRegion1"+$side+".cv[0:99]");
	setAttr ("EyeBrowRegion1"+$side+".tx") (-0.05*$scale*$b);
	setAttr ("EyeBrowRegion1"+$side+".ty") (0.188*$scale);
	move -r -os -wd 0  (0.06*$scale) 0 ("EyeBrowRegion1"+$side+".cv[5]");
	move -r -os -wd 0  (0.03*$scale) 0 ("EyeBrowRegion1"+$side+".cv[4]") ("EyeBrowRegion1"+$side+".cv[6]");
	parent -r ("EyeBrowRegion1"+$side) ctrlBox2;

	setAttr ("Eye1"+$side+"Shape.overrideEnabled") 1;
	setAttr ("Eye1"+$side+"Shape.overrideColor") 18;
	}

circle -n LipRegion1_M -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.3 -d 3 -ut 0 -tol 0.000610236 -s 8 -ch 0;
move -r -os -wd 0 -0.3 0 LipRegion1_M.cv[1];
move -r -os -wd 0 -0.15 0 LipRegion1_M.cv[2] LipRegion1_M.cv[0];
move -r -os -wd 0 0.15 0 LipRegion1_M.cv[3] LipRegion1_M.cv[7];
move -r -os -wd 0 0.25 0 LipRegion1_M.cv[4] LipRegion1_M.cv[6];
move -r -os -wd 0 0.25 0 LipRegion1_M.cv[5];
scale -r -p 0 0 0 ($scale/3.5) ($scale/3.5) ($scale/3.5) LipRegion1_M.cv[0:99];
parent -r LipRegion1_M ctrlBox2;
setAttr LipRegion1_M.ty (-0.25*$scale);

if (`objExists FaceFitUpMidLo`)
	{
	$tempString[0]=`curve -d 1 -p 1 -0.02 0 -p -1 -0.02 0 -p -1 0.02 0 -p 1 0.02 0 -p 1 -0.02 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
	rename $tempString[0] lowerFace1_M;
	scale -r -p 0 0 0 ($scale/50.0) ($scale/10.0) ($scale/10.0) lowerFace1_M.cv[0:99];
	parent -r lowerFace1_M ctrlBox2;
	setAttr lowerFace1_M.tx (0.09*$scale);
	setAttr lowerFace1_M.ty (-0.16*$scale);
	duplicate -n middleFace1_M lowerFace1_M;
	setAttr middleFace1_M.ty (-0.0875*$scale);
	duplicate -n upperFace1_M lowerFace1_M;
	setAttr upperFace1_M.ty (-0.015*$scale);
	}

circle -n NoseRegion1_M -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.3 -d 3 -ut 0 -tol 0.000610236 -s 8 -ch 0;
move -r -os -wd 0 0.1 0 NoseRegion1_M.cv[1];
move -r -os -wd 0 0.3 0 NoseRegion1_M.cv[5];
scale -r -p 0 0 0 ($scale/5) ($scale/5) ($scale/5) NoseRegion1_M.cv[0:99];
scale -r -p 0 0 0 0.5 1 1 NoseRegion1_M.cv[0] NoseRegion1_M.cv[2];
move -r -os -wd 0 -0.1 0 NoseRegion1_M.cv[0] NoseRegion1_M.cv[2];

parent -r NoseRegion1_M ctrlBox2;
setAttr NoseRegion1_M.ty (-0.1*$scale);

//teeth
if (`getAttr FaceFitSkeleton.UpperTeeth`!="")
	{
	$tempString[0]=`curve -d 1 -p 1 -0.02 0 -p -1 -0.02 0 -p -1 0.02 0 -p 1 0.02 0 -p 1 -0.02 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
	rename $tempString[0] upperTeeth1_M;
	scale -r -p 0 0 0 ($scale/50.0) ($scale/10.0) ($scale/10.0) upperTeeth1_M.cv[0:99];
	parent -r upperTeeth1_M ctrlBox2;
	setAttr upperTeeth1_M.tx (-0.1*$scale);
	setAttr upperTeeth1_M.ty (-0.20*$scale);
	setAttr upperTeeth1_MShape.overrideEnabled 1;
	setAttr upperTeeth1_MShape.overrideColor 14;
	duplicate -n lowerTeeth1_M upperTeeth1_M;
	setAttr lowerTeeth1_M.ty (-0.25*$scale);
	}

//Tongue
if (`objExists FaceFitTongue`)
	{
	$tempString[0]=`curve -d 1 -p 1 -0.02 0 -p -1 -0.02 0 -p -1 0.02 0 -p 1 0.02 0 -p 1 -0.02 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
	rename $tempString[0] Tongue11_M;
	scale -r -p 0 0 0 ($scale/50.0) ($scale/10.0) ($scale/10.0) Tongue11_M.cv[0:99];
	parent -r Tongue11_M ctrlBox2;
	setAttr Tongue11_M.tx (0.09*$scale);
	setAttr Tongue11_M.ty (-0.26*$scale);
	setAttr Tongue11_MShape.overrideColor 6;
	duplicate -n Tongue21_M Tongue11_M;
	setAttr Tongue21_M.ty (-0.28*$scale);
	duplicate -n Tongue31_M Tongue11_M;
	setAttr Tongue31_M.ty (-0.30*$scale);
	}

spaceLocator -n tempLoc;
setAttr tempLoc.v 0;
createNode -n tempLocFlip -p FaceMotionSystem transform;
parent tempLoc tempLocFlip;
select -cl;
}

global proc asFaceEyeBall ()
{
int $haveSkinCluster,$infAdded;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $opm=`asGetOpm`;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.faceScale`;
float $bb[],$qt[];
float $pos[3],$sca[3],$eyeBallPos[3];
string $eye,$side,$leftRight,$leftSuffix,$sc;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $headJointNonNS=$headJoint;
string $tempString[],$ffds[],$eyeGeos[],$eyeBallSkinClusters[],$historyNodes[];
string $ffdLattice,$ffdBase;	
string $xyz[]={"x","y","z"};

asFaceHideControllers 1;
setAttr ctrlBox2.v 0;
setAttr ctrlBoxEye_R.v 1;
setAttr ctrlBoxEye_L.v 1;

createNode -n EyeSetup -p FaceDeformationSystem transform;
$eyeBallPos=`xform -q -ws -t FitEyeBall`;

tokenize $headJoint ":" $tempString;
if (size($tempString)>1)
	$headJointNonNS=$tempString[size($tempString)-1];

//non-spherical eyes.
$sca=`getAttr FitEyeBall.s`;
if ($sca[0]>=($sca[1]+0.001) || $sca[0]<=($sca[1]-0.001) || $sca[0]>=($sca[2]+0.001) || $sca[0]<=($sca[2]-0.001))
	{
	if (!`attributeExists nonSphericalEye FitEyeBall`)
		addAttr -ln nonSphericalEye -at bool -dv 1 FitEyeBall;
	$dialog=`confirmDialog -t "Confirm"
		-m "FitEyeBall is squashed.\nCreate Non-spherical Eye-Setup ?"
		-b "Yes" -db "Yes"
		-b "Cancel" -ds "Cancel"`;
	if ($dialog!="Yes")
		{
		select FitEyeBall;
		error "FitEyeBall is squashed.";
		}
	if ($dialog=="Yes")
		if (`attributeExists GameEngine FaceFitSkeleton`)
			if (`getAttr FaceFitSkeleton.GameEngine`)
				error "FitEyeBall is squashed. And options are set to \"game engine\.\nNon-spherical Eye-Setup is not compatible with GameEngines.";
	}

//EyeAimSetup
createNode -n EyeAimSetup -p EyeSetup transform;
createNode -n EyeAimFollowHead -p EyeAimSetup transform;
createNode -n EyeAimStatic -p EyeAimSetup transform;
if ($opm)
	asParentConstraint $headJoint EyeAimFollowHead "";
else
	{
	parentConstraint $headJoint EyeAimFollowHead;
	connectAttr MainAndHeadScaleMultiplyDivide.output EyeAimFollowHead.s;
	}
asAlign EyeAimStatic $headJoint 1 1 0 0;
$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] AimEye_M;
setAttr AimEye_MShape.overrideEnabled 1;
connectAttr ctrlBox.AimCtrlVis AimEye_MShape.overrideVisibility;
//connectAttr ctrlBox.AimCtrlColor AimEye_MShape.overrideColor;
setAttr AimEye_MShape.overrideColor 17;
sets -add FaceControlSet AimEye_M;
//scale -r -p 0 0 0 ($scale/10.0) ($scale/10.0) ($scale/10.0) AimEye_M.cv[0:4];
createNode -n AimAimAt -p EyeAimSetup transform;
xform -ws -t 0 $eyeBallPos[1] $eyeBallPos[2] AimAimAt;
//aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject AimAimAt AimAimAt AimEye_M;
//setAttr -k 0 AimEye_M.rx;setAttr -k 0 AimEye_M.ry;setAttr -k 0 AimEye_M.rz;
createNode -n AimEyeOffset_M transform;
createNode -n AimEyeFollow_M transform;
parent AimEyeFollow_M Aimcontrols;
asAlign AimEyeFollow_M $headJoint 1 1 0 0;
parent AimEye_M AimEyeOffset_M;
setAttr -type float3 AimEyeOffset_M.s ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
asAlign AimEyeOffset_M AimEyeFollow_M 1 0 0 0;
parent AimEyeOffset_M AimEyeFollow_M;
xform -ws -t 0 $eyeBallPos[1] ($eyeBallPos[2]+$faceFitScale) AimEyeOffset_M;
createNode -n AimEyeUpVec transform;
parent AimEyeUpVec EyeAimFollowHead;

if ($opm)
	{
	asParentConstraintBlend "AimEye_M" "AimEyeFollow_M" "EyeAimFollowHead";
	//multMatrix for localSpace
	createNode -n AimFollowMM multMatrix;
	connectAttr AimEyeFollowBM_M.outputMatrix AimFollowMM.matrixIn[0];
	connectAttr Aimcontrols.worldInverseMatrix AimFollowMM.matrixIn[1];
	connectAttr -f AimFollowMM.matrixSum AimEyeFollow_M.offsetParentMatrix;
	}
else
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 AimEye_M;
	createNode -n eyeAimFollowSetRange setRange;
	setAttr eyeAimFollowSetRange.minX 0;setAttr eyeAimFollowSetRange.minY 1;
	setAttr eyeAimFollowSetRange.maxX 1;setAttr eyeAimFollowSetRange.maxY 0;
	setAttr eyeAimFollowSetRange.oldMinX 0;setAttr eyeAimFollowSetRange.oldMinY 0;
	setAttr eyeAimFollowSetRange.oldMaxX 10;setAttr eyeAimFollowSetRange.oldMaxY 10;
	connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueX;
	connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueY;

	parentConstraint $headJoint EyeAimStatic AimEyeFollow_M;
	connectAttr eyeAimFollowSetRange.outValue.outValueY AimEyeFollow_M_parentConstraint1.EyeAimStaticW1;
	connectAttr eyeAimFollowSetRange.outValue.outValueX ("AimEyeFollow_M_parentConstraint1."+$headJointNonNS+"W0");
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) {$side="_R";$leftRight="Right";$leftSuffix="";}
	else {$side="_L";$leftRight="Left";$leftSuffix="Left";}

	$pos=$eyeBallPos;
	if ($side=="_L")
		{
		if (`objExists FitEyeBallLeft`)
			$pos=`xform -q -ws -t FitEyeBallLeft`;
		else
			$pos[0]=$eyeBallPos[0]*-1;
		}

	//EyeRegion
	asCreateFaceController "EyeRegion" $side 4;
//	delete ("EyeRegionJoint"+$side);
	parent ("EyeRegionJoint"+$side) FaceDeformationSystem;
//	parentConstraint ("EyeRegion"+$side)  ("EyeRegionJoint"+$side) ;
//	scaleConstraint ("EyeRegion"+$side)  ("EyeRegionJoint"+$side) ;
	asParentConstraint ("EyeRegion"+$side)  ("EyeRegionJoint"+$side) "";
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeRegionOffset"+$side);
	scale -r -p $pos[0] $pos[1] $pos[2] 6 6 6  ("EyeRegion"+$side+".cv[0:7]");
	parent ("EyeRegionOffset"+$side) ("SideReverse"+$side);
	xform -os -ro 0 0 0 -s 1 1 1 ("EyeRegionOffset"+$side);
	asOPMScaleReset ("EyeRegionJoint"+$side);
	asFacePlaceCtrlByProjection ("EyeRegion"+$side);

	//Eye
	asCreateFaceController "Eye" $side 3;
	setAttr ("Eye"+$side+".rotateOrder") 2;
	setAttr ("EyeOffset"+$side+".s") -type float3 1 1 1;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeOffset"+$side);
	$pos=`xform -q -ws -t ("Eye"+$side)`;
	scale -r -p $pos[0] $pos[1] $pos[2] 2.16 2.16 2.16 ("Eye"+$side+".cv[0:7]");
	setAttr ("Eye"+$side+"Shape.overrideColor") 18;
	connectAttr -f ctrlBox.EyeCtrlVis ("Eye"+$side+"Shape.overrideVisibility");

//	if ($multiSkinClusters)
//		select $headJoint;
//	else
		select FaceJoint_M;
	joint -n ("EyeJoint"+$side);
	setAttr ("EyeJoint"+$side+".rotateOrder") 2;
	xform -ws -t ($eyeBallPos[0]*$b) $eyeBallPos[1] $eyeBallPos[2] ("EyeJoint"+$side);
	if (!`objExists EyeControls`)
		{
		createNode -n EyeControls -p OnFacecontrols transform;
		parent EyeControls ControlsSetup;
		xform -s 1 1 1 EyeControls;
		}
	parent ("EyeOffset"+$side) EyeControls;
	xform -os -ro 0 0 0 -s 1 1 1 ("EyeOffset"+$side);
	orientConstraint FitEyeBall  ("EyeOffset"+$side);
	delete ("EyeOffset"+$side+"_orientConstraint1");

	if ($side=="_L")
		setAttr EyeOffset_L.ry (`getAttr EyeOffset_L.ry`*-1);

	delete `parentConstraint ("Eye"+$side) ("EyeJoint"+$side)`;
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("EyeJoint"+$side);
//	parentConstraint ("Eye"+$side) ("EyeJoint"+$side);
//	scaleConstraint -mo ("Eye"+$side) ("EyeJoint"+$side);
	asParentConstraint ("Eye"+$side) ("EyeJoint"+$side) "";
	setAttr ("EyeJoint"+$side+".segmentScaleCompensate") 0;
	$eyeJoint="EyeJoint"+$side;

	if ($multiSkinClusters)//inverseMatrix out HeadJoint
		{
		$m=`getAttr FaceJoint_M.worldMatrix`;
		setAttr ("EyeJointMM"+$side+".matrixIn[3]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		connectAttr ($headJoint+".worldInverseMatrix") ("EyeJointMM"+$side+".matrixIn[4]");
		$m=`getAttr ($headJoint+".worldMatrix")`;
		setAttr ("EyeJointMM"+$side+".matrixIn[5]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		$m=`getAttr ($headJoint+".worldMatrix")`;
		setAttr ("EyeJointMM"+$side+".matrixIn[5]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		$m=`getAttr FaceJoint_M.inverseMatrix`;
		setAttr ("EyeJointMM"+$side+".matrixIn[6]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		}

	$eye=`textField -q -tx ("asFace"+$leftRight+"EyeTextField")`;
	if ($eye=="")
		continue;
	tokenize $eye " " $tempString;
	clear $eyeGeos;
	for ($i=0;$i<size($tempString);$i++)
		$eyeGeos[$i]=$tempString[$i];

	eval ("select "+$eyeGeos[0]);
	$bb=`xform -q -ws -bb`;
	move -r -os -wd 0 0 (($bb[5]*1.1)-$pos[2]) ("Eye"+$side+".cv[0:7]");

	for ($i=0;$i<size($eyeGeos);$i++)
		{
		$haveSkinCluster=0;
		$infAdded=0;
		$historyNodes=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster" && !`gmatch $historyNodes[$y] "prefix_*"`)
				{
				$haveSkinCluster=1;
				$eyeBallSkinClusters[$i]=$historyNodes[$y];
				$tempString=`listConnections -s 1 -d 0 -type joint ($eyeBallSkinClusters[$i]+".matrix")`;
				if (`stringArrayCount $eyeJoint $tempString`)
					$infAdded=1;
				}

		if ($multiSkinClusters)
			{
			$sc="EyeBallSC"+$side;
			select $eyeJoint $eyeGeos[$i];
			$tempString=`skinCluster -multi 1 -frontOfChain -toSelectedBones`;
			$sc=`rename $tempString[0] $sc`;
			$eyeBallSkinClusters[$i]=$sc;
			}
		else
			{
			if ($haveSkinCluster)
				{
				if (!$infAdded)
					{//influence might already be added, in the case that $eyeGeos[] are {eye.f[0:1] eye.f[3:4]} etc
					skinCluster -e -lw true -wt 0 -ai $eyeJoint $eyeBallSkinClusters[$i];
					if (`attributeExists lockInfluenceWeights $eyeJoint`)
						setAttr ($eyeJoint+".lockInfluenceWeights") 0;
					skinPercent -tv $eyeJoint 1 $eyeBallSkinClusters[$i] $eyeGeos[$i];
					}
				}
			else
				{
				select $eyeJoint $eyeGeos[$i];
				$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
				for ($y=0;$y<size($tempString);$y++)
					$eyeBallSkinClusters[$i]=`rename $tempString[$y] ("eyeSC"+$side)`;
				}
			}
		}

	asDsSdk ("ctrlEye"+$side+".tx") ("SDKEye"+$side+".ry") 1 30;
	asDsSdk ("ctrlEye"+$side+".tx") ("SDKEye"+$side+".ry") -1 -30;
	asDsSdk ("ctrlEye"+$side+".ty") ("SDKEye"+$side+".rx") 1 -30;
	asDsSdk ("ctrlEye"+$side+".ty") ("SDKEye"+$side+".rx") -1 30;

	createNode -n ("AimOffsetEye"+$side) -p AimEye_M transform;
	setAttr ("AimOffsetEye"+$side+".tx") (-1*$b);

	duplicate -n ("AimEye"+$side) AimEye_M;
	delete `listRelatives -c -fullPath -type transform ("AimEye"+$side)`;
	parent -r ("AimEye"+$side) ("AimOffsetEye"+$side);
	connectAttr ctrlBox.AimCtrlVis ("AimEye"+$side+"Shape.overrideVisibility");

	$pos=`xform -q -ws -t AimEye_MShape.cv[4]`;
	$pos[0]*=$b;
	xform -ws -t $pos[0] ($pos[1]+($faceFitScale*0.03)) $pos[2] ("AimEye"+$side+".cv[0]");
	xform -ws -t $pos[0] ($pos[1]+($faceFitScale*-0.03)) $pos[2] ("AimEye"+$side+".cv[1]");
	xform -ws -t $pos[0] $pos[1] $pos[2] ("AimEye"+$side+".cv[2]");
	xform -ws -t ($pos[0]+($faceFitScale*0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[3]");
	xform -ws -t ($pos[0]+($faceFitScale*-0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[4]");

	createNode -n ("EyeAim"+$side) -p ("EyeOffset"+$side) transform;

	if ($opm)
		{
		createNode -n ("EyeAimAM"+$side) aimMatrix;
		setAttr ("EyeAimAM"+$side+".primaryInputAxis") -type float3 0 0 1;
		setAttr ("EyeAimAM"+$side+".secondaryMode") 2;
		setAttr ("EyeAimAM"+$side+".secondaryInputAxis") -type float3 0 1 0;
		setAttr ("EyeAimAM"+$side+".secondaryTargetVector") -type float3 0 1 0;
		connectAttr ("AimEye"+$side+".worldMatrix[0]") ("EyeAimAM"+$side+".primaryTargetMatrix");
		connectAttr AimEyeUpVec.worldMatrix[0] ("EyeAimAM"+$side+".secondaryTargetMatrix");
		connectAttr ("EyeOffset"+$side+".worldMatrix[0]") ("EyeAimAM"+$side+".inputMatrix");
		createNode -n ("EyeAimMM"+$side) multMatrix;
		connectAttr ("EyeAimAM"+$side+".outputMatrix") ("EyeAimMM"+$side+".matrixIn[1]");
		connectAttr ("EyeOffset"+$side+".worldInverseMatrix[0]") ("EyeAimMM"+$side+".matrixIn[2]");
		connectAttr ("EyeAimMM"+$side+".matrixSum") ("EyeAim"+$side+".offsetParentMatrix");
		//-mo
		$m=`getAttr ("EyeAimAM"+$side+".outputMatrix")`;
		$m=`matrixUtil -q -iv $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15]`;
		$qt=`matrixUtil -q -qt $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15]`;
		$m=`matrixUtil -qt $qt[0] $qt[1] $qt[2] $qt[3]`;
		setAttr ("EyeAimMM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		}
	else
		aimConstraint -mo -aimVector 0 0 1 -worldUpType objectrotation -worldUpObject AimEyeUpVec -worldUpVector 0 1 0 ("AimEye"+$side) ("EyeAim"+$side);
	parent ("SDKEye"+$side) ("EyeAim"+$side);

	//non-spherical eyes.
	if (`attributeExists nonSphericalEye FitEyeBall`)
		{
//		for ($z=0;$z<size($xyz);$z++)
//			disconnectAttr ("EyeAimAdd"+$side+".output3D.output3D"+$xyz[$z]) ("Eye"+$side+".r"+$xyz[$z]);
		xform -ws -ro 0 0 0 ("Eye"+$side);

		select $eyeGeos;
//		$tempString=`lattice  -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
		$tempString=`asDeformer ("lattice  -divisions 2 2 2 -objectCentered true  -ldv 2 2 2")`;
		rename $tempString[0] ("squashEyeFfd1"+$side);
		rename $tempString[1] ("squashEyeFfd1Lattice"+$side);
		rename $tempString[2] ("squashEyeFfd1Base"+$side);
		$tempString=`listConnections ("squashEyeFfd1"+$side+".message")`;
		rename $tempString[0] ("squashEyeFfd1Set"+$side);
		setAttr ("squashEyeFfd1"+$side+".outsideLattice") 1;
		delete `orientConstraint ("FitEyeBall"+$leftSuffix) ("squashEyeFfd1Lattice"+$side)`;
		delete `orientConstraint ("FitEyeBall"+$leftSuffix) ("squashEyeFfd1Base"+$side)`;

		$sca=`getAttr ("squashEyeFfd1Lattice"+$side+".s")`;
//		setAttr ("squashEyeFfd1Lattice"+$side+".s") -type float3 1 1 1;
		setAttr ("squashEyeFfd1Lattice"+$side+".s") -type float3 $sca[0] $sca[0] $sca[0];
		for ($i=0;$i<size($eyeGeos);$i++)
			reorderDeformers $eyeBallSkinClusters[$i] ("squashEyeFfd1"+$side) $eyeGeos[$i];

		select $eyeGeos;
//		$tempString=`lattice  -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
		$tempString=`asDeformer ("lattice  -divisions 2 2 2 -objectCentered true  -ldv 2 2 2")`;
		rename $tempString[0] ("squashEyeFfd2"+$side);
		rename $tempString[1] ("squashEyeFfd2Lattice"+$side);
		rename $tempString[2] ("squashEyeFfd2Base"+$side);
		$tempString=`listConnections ("squashEyeFfd2"+$side+".message")`;
		rename $tempString[0] ("squashEyeFfd2Set"+$side);
		setAttr ("squashEyeFfd2"+$side+".outsideLattice") 1;
		delete `orientConstraint ("FitEyeBall"+$leftSuffix) ("squashEyeFfd2Lattice"+$side)`;
		delete `orientConstraint ("FitEyeBall"+$leftSuffix) ("squashEyeFfd2Base"+$side)`;

		setAttr ("squashEyeFfd2Lattice"+$side+".s") -type float3 $sca[0] $sca[1] $sca[2];

//		for ($z=0;$z<size($xyz);$z++)
//			connectAttr ("EyeAimAdd"+$side+".output3D.output3D"+$xyz[$z]) ("Eye"+$side+".r"+$xyz[$z]);
		xform -os -ro 0 0 0 ("Eye"+$side);

		createNode -n ("EyeLattice1"+$side) -p EyeSetup transform;
		createNode -n ("EyeLattice2"+$side) -p EyeSetup transform;
		parentConstraint $headJoint ("EyeLattice2"+$side);
		scaleConstraint $headJoint ("EyeLattice2"+$side);
		parent ("squashEyeFfd1Lattice"+$side) ("squashEyeFfd1Base"+$side) ("EyeLattice1"+$side);
		parent ("squashEyeFfd2Lattice"+$side) ("squashEyeFfd2Base"+$side) ("EyeLattice2"+$side);
		}
	}
if (`objExists FaceFitPupil` || `objExists FaceFitIris`)
	asFacePupilIris;
//select -r ctrlEye_R ctrlEye_L;
select -cl;
}

global proc asFacePupilIris ()
{
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $innerVtxsIsA,$IrisLoopNextToPupilLoop,$loopsFromPupilToIris,$loopsFromIrisToHalfSphere,$type,$addIrisAttr;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $onFaceCtrlScale=`getAttr OnFacecontrols.sx`;
float $eyeRadius,$pupilRadius,$radius,$vtxRadius,$irisRadius,$wouldBeRadius,$factor,$maxX,$maxY,$dist,$dist2,$minDist;
float $eyeBallScale[]=`xform -q -ws -s FitEyeBall`;
float $bb[],$bbA[],$bbB[],$pos[],$posA[],$posB[],$pupilCenterPos[],$irisCenterPos[],$temp[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $pupilText,$irisText,$skinCluster,$maxXVtx,$maxYVtx,$pupilIris,$pupilIrisLowerCase,$setAttrCmdExtra,$eyeCtrl,$buildPose;
string $side,$rightLeft,$leftSuffix,$nearestEyeGeo,$otherGeoSkinCluster,$eyeText,$eyeFaceSelectionObject;
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $vtxs[],$pupilVtxs[],$pupilVtxs[],$tempString[],$tempString2[],$tempString3[],$tempString4[],$sideAVtxs[],$sideBVtxs[];
string $innerVtxs[],$outerVtxs[],$backHalfVtxs[],$irisToBackHalfVtxs[],$eyeGeos[];

createNode -n TempPos transform;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$rightLeft="Right";$leftSuffix="";}
	else {$side="_L";$rightLeft="Left";$leftSuffix="Left";}

	$eyeCtrl="ctrlEye"+$side;
	$eyeText=`textField -q -tx ("asFace"+$rightLeft+"EyeTextField")`;
	$eyeGeos=`stringToStringArray $eyeText " "`;

	//if multiple objects defined as eyeGeo, we need to guess the correct one, by closest Vtx, and re-order it to $eyeGeos[0]
	//But first check if $eyeGeos[] are {eye.f[0:1] eye.f[3:4]} etc, in which case make a temp-combined eyeBall geo from *faces
	if (`gmatch $eyeGeos[0] "*[.]f*"`)
		{
		eval ("select "+$eyeText);
		$tempString=`ls -sl -o`;
		select -cl;
		$tempString2=`listRelatives -p $tempString[0]`;
		$eyeFaceSelectionObject=$tempString2[0];//assuming faceSelection eyeGeo are all faces on 1 object
		duplicate -n TempDuplicatedEye $eyeFaceSelectionObject;
		select -cl;
		for ($i=0;$i<size($eyeGeos);$i++)
			select -add `asobjSetCast "" $eyeGeos TempDuplicatedEye`;
		asInvertSelection;
		delete;
		clear $eyeGeos;
		$eyeGeos[0]=$tempString2[0];
		}
	else
		{
		$minDist=999;
		if (size($eyeGeos)>1)
			{
			$posA=`xform -q -ws -t ("PupilCurve"+$leftSuffix+".cv[0]")`;
			createNode -n closestSampler closestPointOnMesh;
			for ($i=0;$i<size($eyeGeos);$i++)
				{
				connectAttr -f ($eyeGeos[$i]+".outMesh") closestSampler.inMesh;
				setAttr -type float3 closestSampler.inPosition $posA[0] $posA[1] $posA[2];
				$tempString[0]=$eyeGeos[$i]+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
				$posB=`xform -q -ws -t $tempString[0]`;
				$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
				if ($dist<$minDist)
					{
					$minDist=$dist;
					$nearestEyeGeo=$eyeGeos[$i];
					}
				}
			delete closestSampler;
			if ($nearestEyeGeo!=$eyeGeos[0])
				{
				$eyeGeos=`stringArrayRemove {$nearestEyeGeo} $eyeGeos`;
				stringArrayInsertAtIndex 0 $eyeGeos $nearestEyeGeo;
				}
			}
		}

	$pupilText=`asGetFaceFitSelectionOtherObject ("PupilCurve"+$leftSuffix) $eyeGeos[0] $side`;
	$irisText=`asGetFaceFitSelectionOtherObject ("IrisCurve"+$leftSuffix) $eyeGeos[0] $side`;

	if ($pupilText=="") {warning ("Pupil"+$side+" EdgeLoop not defined");continue;}
	if ($irisText=="") {warning ("Iris"+$side+" EdgeLoop not defined");continue;}
	else
		$addIrisAttr=1;


	eval ("select "+$pupilText);
	ConvertSelectionToVertices;
	$pupilVtxs=`ls -sl -fl`;
	$bb=`xform -q -bb`;
	$pupilCenterPos={(($bb[3]+$bb[0])/2.0),(($bb[4]+$bb[1])/2.0),(($bb[5]+$bb[2])/2.0)};
	$pupilRadius=($bb[4]-$bb[1])/2.0;

	eval ("select "+$irisText);
	ConvertSelectionToVertices;
	$irisVtxs=`ls -sl -fl`;
	$bb=`xform -q -bb`;
	$irisCenterPos={(($bb[3]+$bb[0])/2.0),(($bb[4]+$bb[1])/2.0),(($bb[5]+$bb[2])/2.0)};
	$irisRadius=($bb[4]-$bb[1])/2.0;

	//find $eyeGeo & $eyeRadius
//	tokenize $pupilVtxs[0] "[.]" $tempString;
//	$eyeGeo=$tempString[0];
	$bb=`xform -q -ws -bb $eyeGeos[0]`;
	if (`objExists TempDuplicatedEye`)
		$bb=`xform -q -ws -bb TempDuplicatedEye`;
	$eyeRadius=($bb[4]-$bb[1])/2.0;

	//find $backHalfVtxs
	select $eyeGeos[0];
	if (`objExists TempDuplicatedEye`)
		eval ("select "+$eyeText);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	createNode -n tempTransform -p ("EyeJoint"+$side) transform;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempTransform;
		if (`getAttr tempTransform.tz`<0)
			$backHalfVtxs[size($backHalfVtxs)]=$tempString[$i];
		}
	delete tempTransform;

	$tempString=`listHistory $pupilVtxs[0]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]`=="skinCluster")
			if ($tempString[$y]!="squashIKSC" && !`gmatch $tempString[$y] "prefix_*"`)
				$skinCluster=$tempString[$y];

	for ($a=1;$a>-2;$a=$a-2)
		{
		if ($a==1)
			{$pupilIris="Pupil";$pupilIrisLowerCase="pupil";$pos=$pupilCenterPos;$vtxs=$pupilVtxs;$radius=$pupilRadius;$type=2;}
		else
			{$pupilIris="Iris";$pupilIrisLowerCase="iris";$pos=$irisCenterPos;$vtxs=$irisVtxs;$radius=$irisRadius;$type=1;}	

		asCreateFaceController $pupilIris $side $type;
		connectAttr -f ctrlBox.EyeCtrlVis ($pupilIris+$side+"Shape.overrideVisibility");
		select ("EyeJoint"+$side);
		joint -n ($pupilIris+"Joint"+$side);
		setAttr ($pupilIris+"Joint"+$side+".segmentScaleCompensate") 0;
//		parentConstraint ($pupilIris+$side) ($pupilIris+"Joint"+$side);
//		scaleConstraint -mo ($pupilIris+$side) ($pupilIris+"Joint"+$side);
//		asParentConstraint ($pupilIris+$side) ($pupilIris+"Joint"+$side) "";

		scale -p 0 0 0 ($radius*4.0) ($radius*4.0) ($radius*4.0) ($pupilIris+$side+".cv[0:7]");
		move -r -os -wd 0 0 ($scale/100.0) ($pupilIris+$side+".cv[0:7]");
		xform -ws -t $pos[0] $pos[1] $pos[2] ($pupilIris+"Offset"+$side) ($pupilIris+"Joint"+$side);

		parent ($pupilIris+"Offset"+$side) ("Eye"+$side);

		//orient to eye
		setAttr ($pupilIris+"Offset"+$side+".r") 0 0 0;
//		if ($side=="_L")
//			setAttr ($pupilIris+"Offset"+$side+".r") 180 0 180;

		//AddAttr
		if ($a==1) //Add Iris attr first, so Pupil attr appear last
			{
			addAttr -k $addIrisAttr -ln iris -at double -smn -10 -hsn 1 -smx 10 -hsx 1 -dv 0 $eyeCtrl;
			addAttr -k 1 -ln pupil -at double -smn -10 -hsn 1 -smx 10 -hsx 1 -dv 0 $eyeCtrl;
			}
		skinCluster -e -ai ($pupilIris+"Joint"+$side) -lw false -wt 0 $skinCluster;
		eval ("select "+$eyeText);
		skinPercent -tv ("EyeJoint"+$side) 1 $skinCluster;//unusual normalize required (only fresh scene, not undone)
		skinPercent -tv ($pupilIris+"Joint"+$side) 1 $skinCluster $vtxs;
		}

	parent ("PupilOffset"+$side) ("Iris"+$side);
	parent ("PupilJoint"+$side) ("IrisJoint"+$side);

	for ($a=1;$a>-2;$a=$a-2)
		{
		if ($a==1) $pupilIris="Pupil";
		else $pupilIris="Iris";

		asParentConstraint ($pupilIris+$side) ($pupilIris+"Joint"+$side) "";

		if ($multiSkinClusters)//inverseMatrix out HeadJoint
			{
			connectAttr -f  ($headJoint+".worldInverseMatrix") ($pupilIris+"JointMM"+$side+".matrixIn[1]");
			$m=`getAttr ($headJoint+".worldMatrix")`;
			setAttr ($pupilIris+"JointMM"+$side+".matrixIn[2]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
			$tempString=`listRelatives -p ($pupilIris+"Joint"+$side)`;
			connectAttr ($tempString[0]+".worldInverseMatrix") ($pupilIris+"JointMM"+$side+".matrixIn[3]");
			}
		}

	select  $pupilVtxs[0];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $pupilVtxs;
	$tempString=`ls -sl -fl`;


	//Grow A
	select $tempString[0];
	for ($i=0;$i<99;$i++)
		{
		if (`stringArrayCount $tempString[0] $irisVtxs`) // IrisLoops is next to PupilLoop
			{$IrisLoopNextToPupilLoop=1;select $irisVtxs;break;}
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $pupilVtxs $irisVtxs;
		if (size(`ls -sl -fl`)==size($tempString2))//same count as previously
			break;
		$tempString2=`ls -sl -fl`;
		}
	$sideAVtxs=`ls -sl -fl`;

	//Grow B
	if ($tempString[1]=="") //If pupil is a hole in the geometry
		{
		$outerVtxs=$sideAVtxs;
		$innerVtxs=$pupilVtxs;
		}
	else
		{
		select $tempString[1];
		for ($i=0;$i<99;$i++)
			{
			if (`stringArrayCount $tempString[1] $irisVtxs`) // IrisLoops is next to PupilLoop
				{$IrisLoopNextToPupilLoop=1;select $irisVtxs;break;}
			polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
			select -d $pupilVtxs $irisVtxs;
			if (size(`ls -sl -fl`)==size($tempString2))//same count as previously
				break;
			$tempString2=`ls -sl -fl`;
			}
		$sideBVtxs=`ls -sl -fl`;

		//Determine A/B is Inner/Outer
		$bbA=`xform -q -bb $sideAVtxs`;
		$bbB=`xform -q -bb $sideBVtxs`;
		$xyzA=($bbA[3]-$bbA[0]) + ($bbA[4]-$bbA[1]) + ($bbA[5]-$bbA[2]);
		$xyzB=($bbB[3]-$bbB[0]) + ($bbB[4]-$bbB[1]) + ($bbB[5]-$bbB[2]);
		if ($xyzA<$xyzB)
			{
			$innerVtxs=$sideAVtxs;
			$outerVtxs=$sideBVtxs;
			}
		else
			{
			$innerVtxs=$sideBVtxs;
			$outerVtxs=$sideAVtxs;
			}
		}

	//find $loopsFromPupilToIris
	select $pupilVtxs[0];
	for ($i=0;$i<10;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`stringArrayCount $tempString[$y] $irisVtxs`)
				{
				$loopsFromPupilToIris=$i;
				$i=10;
				break;
				}
			}
		}

	skinPercent -tv ("PupilJoint"+$side) 1 $skinCluster $pupilVtxs;
	skinPercent -tv ("PupilJoint"+$side) 1 $skinCluster $innerVtxs;
	skinPercent -tv ("IrisJoint"+$side) 1 $skinCluster $irisVtxs;
	skinPercent -tv ("IrisJoint"+$side) 1 $skinCluster $outerVtxs;

	if (!$IrisLoopNextToPupilLoop)
		{
		select $outerVtxs;
		if (size(`ls -sl`))
			asSmoothFlood ("PupilJoint"+$side) ("IrisJoint"+$side) $loopsFromPupilToIris;
//			weightHammerVerts;
		}
	skinCluster -e -selectInfluenceVerts ("PupilJoint"+$side) $skinCluster;
	$tempString=`ls -sl -fl`;
	skinCluster -e -selectInfluenceVerts ("IrisJoint"+$side) $skinCluster;
	$tempString2=`ls -sl -fl`;
	parent TempPos ("FitEyeBall"+$leftSuffix);
	select $outerVtxs;
	for ($i=0;$i<20;$i++)//polyGrow until reach half-sphere
		{
		$loopsFromIrisToHalfSphere=$i;
		polySelectConstraint -pp 1 -t 0x0001;
		$tempString3=`ls -sl -fl`;
		for ($y=0;$y<size($tempString3);$y++)
			{
			$pos=`xform -q -ws -t $tempString3[$y]`;
			xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
			if (`getAttr TempPos.tz`<0)
				$i=20;
			}
		}

	select $irisVtxs;
	for ($i=1;$i<$loopsFromIrisToHalfSphere;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;
		select -d $tempString $tempString2 $tempString4;
		}
	if (size(`ls -sl`))
		asSmoothFlood ("IrisJoint"+$side) ("EyeJoint"+$side) $loopsFromIrisToHalfSphere;

	//distIrisToEye
	$posA=`xform -q -ws -t FitEyeBall`;
	$posB=`xform -q -ws -t Iris_R`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	createNode -n tempXform -p FitEyeBall transform;
	setAttr tempXform.tz 0.5;
	$posA=`xform -q -ws -t tempXform`;
	delete tempXform;
	$dist2=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	for ($z=0;$z<size($xyz);$z++)
		{
		asEnsureOutputBlendWeighted ($eyeCtrl+".pupil");	
		asDsSdk ($eyeCtrl+".pupil") ("SDKPupil"+$side+".s"+$xyz[$z]) 0 1;
		asDsSdk ($eyeCtrl+".pupil") ("SDKPupil"+$side+".s"+$xyz[$z]) 10 2;
		asEnsureOutputBlendWeighted ($eyeCtrl+".iris");	
		asDsSdk ($eyeCtrl+".iris") ("SDKIris"+$side+".s"+$xyz[$z]) 0 1;
		asDsSdk ($eyeCtrl+".iris") ("SDKIris"+$side+".s"+$xyz[$z]) 10 ($eyeBallScale[0]/($irisRadius*2));
		asDsSdk ($eyeCtrl+".iris") ("SDKIris"+$side+".s"+$xyz[$z]) -10 0;
		keyTangent -index 1 -inTangentType spline -outTangentType spline ("SDKIris"+$side+"_scale"+$XYZ[$z]);
		keyTangent -index 2 -inTangentType flat -outTangentType flat ("SDKIris"+$side+"_scale"+$XYZ[$z]);
		}
	asDsSdk ($eyeCtrl+".iris") ("SDKIris"+$side+".tz") 0 0;
	asDsSdk ($eyeCtrl+".iris") ("SDKIris"+$side+".tz") 10 ($dist*-1);
	asDsSdk ($eyeCtrl+".iris") ("SDKIris"+$side+".tz") -10 $dist2;
	keyTangent -index 0 -outTangentType flat ("SDKIris"+$side+"_translateZ");
	keyTangent -index 1 -inTangentType spline -outTangentType spline ("SDKIris"+$side+"_translateZ");

	//other eyeObjects
	for ($i=1;$i<size($eyeGeos);$i++)
		{
		if (`objExists TempDuplicatedEye`)
			break;
		$tempString=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($tempString);$y++)
			if (`nodeType $tempString[$y]`=="skinCluster")
				if ($tempString[$y]!="squashIKSC")
					$otherGeoSkinCluster=$tempString[$y];
		skinCluster -e -ai ("PupilJoint"+$side) -ai ("IrisJoint"+$side) -lw false -wt 0 $otherGeoSkinCluster;
		select $eyeGeos[0] $eyeGeos[$i];
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;	
		}

	for ($a=1;$a>-2;$a=$a-2)
		{
		if ($a==1)
			{$pupilIris="Pupil";$pupilIrisLowerCase="pupil";$vtxs=$pupilVtxs;}
		else
			{$pupilIris="Iris";$pupilIrisLowerCase="iris";$vtxs=$irisVtxs;}

		if ($a==-1 && !$addIrisAttr)
			continue;

		$buildPose="faceBuildPose";
		if (!`objExists $buildPose`)
			$buildPose="buildPose";
		$setAttrCmdExtra="setAttr "+$eyeCtrl+"."+$pupilIrisLowerCase+" 0;";
		setAttr -type "string" ($buildPose+".udAttr") (`getAttr ($buildPose+".udAttr")`+$setAttrCmdExtra);
		}
	if (`objExists TempDuplicatedEye`)
		delete TempDuplicatedEye;
	}

delete TempPos;
select -cl;
}

global proc asFaceEyeLid ()
{
global string $gMainProgressBar;
int $tempInts[];
int $numSelVtx,$prevNumSelVtx,$twoWayVtxInside,$lidMainVtxNr,$lidInnerVtxNr,$lidOuterVtxNr,$spans,$lockedWeight,$numVtx,$cvNr,$createAttacher,$numGrow,$rotOrder;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $simplerEyeLid=`checkBox -q -v asFaceSimplerEyeLidCheckBox`;
int $gameEngine=`checkBox -q -v asFaceGameEngineCheckBox`;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
int $opm=`asGetOpm`;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
float $maxValue,$maxValue2,$lidFollowMultiplier,$previousMag,$tyValueForCloseLid,$upperTyValueForCloseLid,$lowerTyValueForCloseLid,$dv,$dist,$s;
float $pos[],$posA[],$posB[],$posC[],$rgbValues[],$m[];
string $upperLower,$upperLowerOpposite,$outerMain,$outerMainName,$lidJoint,$eyeJoint,$maxTransform,$maxTransform2,$cmd,$leftSuffix,$InnerOuter,$innerouter,$joint;
string $side,$wireTargetCurve,$eyeBrowInnerVtx,$eyeBrowOuterVtx,$cheekBoneVtx,$noseCornerVtx;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$infs[],$transforms[];	
string $outerVtxs[],$mainVtxs[],$main2Vtxs[],$innerVtxs[],$drivenJoints[],$rowVtxs[],$previousVtxs[];
string $upLoOuterVtxs[],$upLoMainVtxs[],$upLoInnerVtxs[],$innerOuterVtx[],$rowWeightedVtxs[];
string $innerUpperOuterLower[]={"inner","upper","outer","lower"};
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $eyeLash=`textField -q -tx asFaceEyelashTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`getAttr FaceFitSkeleton.faceScale`;

setAttr ctrlEye_L.tx 0;setAttr ctrlEye_L.ty 0;
setAttr ctrlEye_R.tx 0;setAttr ctrlEye_R.ty 0;

asFaceHideControllers 1;
setAttr ctrlBoxEye_R.v 1;
setAttr ctrlBoxEye_L.v 1;
setAttr EyeRegionOffset_R.v 1;
setAttr EyeRegionOffset_L.v 1;

createNode -n LidSetup -p FaceDeformationSystem transform;
createNode -n LidJoints -p LidSetup transform;
createNode -n TempPos transform;
createNode -n FaceBuildEyeLidCurves -p FaceBuildInProgress transform;

if ($multiSkinClusters)
	$skinCluster=`asFaceMultiSkinClusterAdd "EyeLid"`; 

select FaceJoint_M;
joint -n EyeLidJoints_M;
$pos=`xform -q -ws -t Eye_R`;
xform -ws -t 0 $pos[1] $pos[2] EyeLidJoints_M;
setAttr EyeLidJoints_M.drawStyle 2;
skinCluster -e -dr 4 -lw false -wt 0 -ai EyeLidJoints_M $skinCluster;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	createNode -n ("LidSetup"+$side) transform;
	asAlign ("LidSetup"+$side) ("Eye"+$side) 1 1 0 0;
	asParentConstraint ("EyeRegion"+$side) ("LidSetup"+$side) "";
//	parentConstraint ("EyeRegion"+$side) ("LidSetup"+$side);
//	scaleConstraint ("EyeRegion"+$side) ("LidSetup"+$side);
	if (!$opm)
		setAttr ("LidSetup"+$side+"_scaleConstraint1.offset") -type float3 -1 -1 1;

	parent ("LidSetup"+$side) LidSetup;
	parent ("EyeRegionJoint"+$side) LidJoints;
	}

//custom FaceControlOrient object for lid
rename FaceControlOrient FaceControlSuspended;
//right
$posA=`xform -q -ws -t upperEyeLidMainCurve.cv[99]`;
$posB=`xform -q -ws -t upperEyeLidMainCurve.cv[0]`;
polyPlane -n FaceControlOrient -w 1 -h 1 -sx 3 -sy 1 -ax 0 1 0 -cuv 2 -ch 0;
sets -e -forceElement asRedSG FaceControlOrient;
polySoftEdge -a 0 -ch 0 FaceControlOrient;
xform -ws -t 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) FaceControlOrient;
setAttr FaceControlOrient.rx 90;
setAttr FaceControlOrient.s -type float3 $scale $scale $scale;
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[4]`;
xform -ws -t $posA[0] $posC[1] $posA[2] FaceControlOrientShape.vtx[4];
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[0]`;
xform -ws -t $posA[0] $posC[1] $posA[2] FaceControlOrientShape.vtx[0];
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[5]`;
xform -ws -t $posB[0] $posC[1] $posB[2] FaceControlOrientShape.vtx[5];
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[1]`;
xform -ws -t $posB[0] $posC[1] $posB[2] FaceControlOrientShape.vtx[1];
//left
$posA=`xform -q -ws -t upperEyeLidMainCurveLeft.cv[99]`;
$posB=`xform -q -ws -t upperEyeLidMainCurveLeft.cv[0]`;
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[7]`;
xform -ws -t $posA[0] $posC[1] $posA[2] FaceControlOrientShape.vtx[7];
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[3]`;
xform -ws -t $posA[0] $posC[1] $posA[2] FaceControlOrientShape.vtx[3];
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[6]`;
xform -ws -t $posB[0] $posC[1] $posB[2] FaceControlOrientShape.vtx[6];
$posC=`xform -q -ws -t FaceControlOrientShape.vtx[2]`;
xform -ws -t $posB[0] $posC[1] $posB[2] FaceControlOrientShape.vtx[2];
//extend, as oddly shaped eyeLids can actually "overshoot" in X after the corners
scale -r -ocp 1.1 1.1 1 FaceControlOrient.vtx[0] FaceControlOrient.vtx[3:4] FaceControlOrient.vtx[7];
scale -r -ocp 0.7 1.1 1 FaceControlOrient.vtx[1:2] FaceControlOrient.vtx[5:6];
parent FaceControlOrient FaceBuildInProgressHidden;

//eyeLidArea set
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $leftSuffix="";
	else $leftSuffix="Left";

	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
	$outerVtxs=`ls -sl -fl`;
	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidMainCurve"+$leftSuffix)`);
	$mainVtxs=`ls -sl -fl`;
	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidInnerCurve"+$leftSuffix)`);
	$innerVtxs=`ls -sl -fl`;

	select $mainVtxs;
	for ($i=0;$i<20;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;
		select -d $outerVtxs $innerVtxs;
		}
	select -add $mainVtxs;
	sets -n ("eyeLidArea"+$leftSuffix);
	sets -add FaceAreas ("eyeLidArea"+$leftSuffix);
	}

//determine eyeLidOuterArea
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	sets -em -n ("eyeLidOuterArea"+$leftSuffix);
	sets -add FaceAreas ("eyeLidOuterArea"+$leftSuffix);
	if (`objExists ("EyeBrowInner"+$leftSuffix)`)//might be in `skip-above-eye` mode
		eval ("select "+`asGetFaceFitSelection ("EyeBrowInner"+$leftSuffix)`);
	refresh;
	$tempString=`ls -sl -fl`;
	$eyeBrowInnerVtx=$tempString[0];
	if (`objExists ("EyeBrowOuter"+$leftSuffix)`)//might be in `skip-above-eye` mode
		eval ("select "+`asGetFaceFitSelection ("EyeBrowOuter"+$leftSuffix)`);
	refresh;
	$tempString=`ls -sl -fl`;
	$eyeBrowOuterVtx=$tempString[0];

	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);

	//$eyeBrowInnerVtx might not be on the same `shell` (separate eyeLid-shell)
	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
	ConvertSelectionToShell;
	$tempString=`ls -sl -fl`;
	if (!`stringArrayCount $eyeBrowInnerVtx $tempString` && `objExists EyeBrowInner`)
		{//$eyeBrowInnerVtx not be on the same `shell`, so find nearest vtx that is
		duplicate -n asTempSingleShellFace $geometry;
		parent asTempSingleShellFace FaceBuildInProgress;
		select `asobjSetCast "" $tempString asTempSingleShellFace`;
		ConvertSelectionToFaces;
		asInvertSelection;
		doDelete;
		if (`objExists closestSampler`) delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		connectAttr -f asTempSingleShellFace.outMesh closestSampler.inMesh;
		eval ("select "+`asGetFaceFitSelection ("EyeBrowInner"+$leftSuffix)`);
		$pos=`xform -q -ws -t`;
		setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$eyeBrowInnerVtx=($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
		delete asTempSingleShellFace closestSampler;
		}

	//determine $cheekBoneVtx and $noseCornerVtx
	if (`asFaceIncludeBelowEyes`)
		{
		eval ("select "+`asGetFaceFitSelection ("CheekBone"+$leftSuffix)`);
		$tempString=`ls -sl -fl`;
		$cheekBoneVtx=$tempString[0];
		eval ("select "+`asGetFaceFitSelection ("NoseCorner"+$leftSuffix)`);
		$tempString=`ls -sl -fl`;
		$noseCornerVtx=$tempString[0];
		}

	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
	clear $tempString;
	for ($i=0;$i<25;$i++)
		{
		$numGrow=$i+1;
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d ("eyeLidArea"+$leftSuffix);
		select -d $tempString;
		$tempString=`ls -sl -fl`;
		if (`stringArrayCount $eyeBrowInnerVtx $tempString` || `stringArrayCount $eyeBrowOuterVtx $tempString`)
			break;
		if (!`objExists EyeBrowInner` && $i==1)//might be in `skip-above-eye` mode
			break;
		//E.g. chubby has dense mesh between Main and Outer, but sparse mesh outside Outer, so avoid overGrow eyeLidOuterArea
		if (`stringArrayCount $cheekBoneVtx $tempString` || `stringArrayCount $noseCornerVtx $tempString`)
			{
			$numGrow=$numGrow-2;
			if ($side=="_R")
				print ("// EyeLid mesh highly more dense between Main and Outer, than beyond Outer, so reducing eyeLidOuterArea to: "+$numGrow+" edgeRows.\n");
			break;
			}
		}

	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
	for ($i=0;$i<$numGrow;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d ("eyeLidArea"+$leftSuffix);
		}
	$tempString=`ls -sl -fl`;
	if (size($tempString))
		sets -add ("eyeLidOuterArea"+$leftSuffix);		
	refresh;
	}

//find the `size` of the eye
$posA=`xform -q -ws -t upperEyeLidMainCurve.cv[0]`;
$posB=`xform -q -ws -t upperEyeLidMainCurve.cv[99]`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
$s=(1.0/$ctrlScale)*($dist/3.0);

//Setup Lid
int $numLid;
createNode -n tempNearestPointOnCurve nearestPointOnCurve;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max 4 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	$eyeJoint="Eye"+$side;

	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln "upperLidOut" -at double ("LidSetup"+$side);
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln "lowerLidOut" -at double ("LidSetup"+$side);
//	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln "blinkCenter" -at double ("LidSetup"+$side);

//	createNode -n ("blinkCenterReverse"+$side) reverse;
//	connectAttr ("LidSetup"+$side+".blinkCenter") ("blinkCenterReverse"+$side+".inputX");

	createNode -n ("LidLocs"+$side) transform;
	setAttr ("LidLocs"+$side+".inheritsTransform") 0;
	parent ("LidLocs"+$side) LidSetup;
	createNode -n ("LidCurves"+$side) transform;
	parent ("LidCurves"+$side) FaceDeformationSystem;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

	for ($c=0;$c<2;$c++)
			{
			if ($c==0) {$outerMain="Main";$outerMainName="";$createAttacher=1;}//In fit named Main VS Outer, in rig named "" VS Outer
			if ($c==1) {$outerMain="Outer";$outerMainName="Outer";$createAttacher=0;}
			if ($simplerEyeLid && $c==1) continue;

			$numLid=`getAttr ($upperLower+"EyeLid"+$outerMain+"Curve"+$leftSuffix+".spans")`+1;

			duplicate -n ($upperLower+"Lid"+$outerMain+"Curve"+$side) ($upperLower+"EyeLid"+$outerMain+"Curve"+$leftSuffix);
			
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 5 -d 3 -tol 0.004 ($upperLower+"Lid"+$outerMain+"Curve"+$side);	

			if ($side=="_L" && !$nonSymmetrical)
				{
				parent -w ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				refresh;//needed for following makeIdentity to work correctly
				makeIdentity -a 1 -t 1 -r 1 -s 1 ($upperLower+"Lid"+$outerMain+"Curve"+$side);//since auto-generated Left Fitting has sx = -1
				}
			parent ($upperLower+"Lid"+$outerMain+"Curve"+$side) ("LidCurves"+$side);

			duplicate -n ($upperLower+"Lid"+$outerMain+"CurveTweak"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
			if ($outerMain=="Main")
				{
				duplicate -n ($upperLower+"LidCurveFleshy"+$side) ($upperLower+"LidMainCurve"+$side);
				duplicate -n ($upperLower+"LidCurveBlink"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				duplicate -n ($upperLower+"UnClosedLidCurve"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				if ($upperLower=="upper")
					duplicate -n ("lowerClosedLidCurve"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				if ($upperLower=="lower")
					duplicate -n ("upperClosedLidCurve"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				}

			//skin the main curve
			if ($outerMain=="Main")
				{
				select ("EyeRegionJoint"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
				rename $tempString[0] ($upperLower+"Lid"+$outerMain+"SC"+$side);
				}

			connectAttr -f ($upperLower+"Lid"+$outerMain+"Curve"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
			for ($i=0;$i<$numLid;$i++)
				{
				if ($upperLower=="lower" && ($i==0 || $i==($numLid-1)))//no need for lower at the same spot (start & end)
					continue;
				select -cl;
				joint -n ($upperLower+"Lid"+$outerMain+$i+$side);
				setAttr ($upperLower+"Lid"+$outerMain+$i+$side+".segmentScaleCompensate") 0;
				setAttr ($upperLower+"Lid"+$outerMain+$i+$side+".radius") 0.1;
				$pos=`xform -q -ws -t ($upperLower+"EyeLid"+$outerMain+"Curve"+$leftSuffix+".cv["+$i+"]")`;
				xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$outerMain+$i+$side);
				parent ($upperLower+"Lid"+$outerMain+$i+$side) EyeLidJoints_M;

				spaceLocator -n ($upperLower+"Lid"+$outerMain+"Loc"+$i+$side);
				setAttr -type float3 ($upperLower+"Lid"+$outerMain+"Loc"+$i+$side+".localScale") ($scale/100.0) ($scale/100.0) ($scale/100.0);
				parent ($upperLower+"Lid"+$outerMain+"Loc"+$i+$side) ("LidLocs"+$side);
				createNode -n ($upperLower+"Lid"+$outerMain+"Poci"+$i+$side) pointOnCurveInfo;
//				setAttr ($upperLower+"Lid"+$outerMain+"Poci"+$i+$side+".turnOnPercentage") 1;
//				setAttr ($upperLower+"Lid"+$outerMain+"Poci"+$i+$side+".parameter") ($i/($numLid-1.00));
				setAttr tempNearestPointOnCurve.inPosition -type float3 $pos[0] $pos[1] $pos[2];
				setAttr ($upperLower+"Lid"+$outerMain+"Poci"+$i+$side+".parameter") `getAttr tempNearestPointOnCurve.parameter`;

				connectAttr ($upperLower+"Lid"+$outerMain+"Poci"+$i+$side+".position") ($upperLower+"Lid"+$outerMain+"Loc"+$i+$side+".translate");
				connectAttr ($upperLower+"Lid"+$outerMain+"Curve"+$side+"Shape.worldSpace[0]") ($upperLower+"Lid"+$outerMain+"Poci"+$i+$side+".inputCurve");

				createNode -n ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side) transform;
				parent ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side) ("LidSetup"+$side);
				setAttr -type float3 ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side+".t") 0 0 0;

				if ($opm)
					{
					setAttr ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side+".r") 0 0 0;
					createNode -n ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side) aimMatrix;
					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".primaryInputAxis") -type float3 1 0 0;
					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".secondaryMode") 2;
					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".secondaryInputAxis") -type float3 0 1 0;
					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".secondaryTargetVector") -type float3 0 1 0;
					connectAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+$side+".worldMatrix[0]") ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".primaryTargetMatrix");
					connectAttr ("LidSetup"+$side+".worldMatrix[0]") ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".secondaryTargetMatrix");
//					connectAttr ("EyeOffset"+$side+".worldMatrix[0]") ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".inputMatrix");
					connectAttr ("EyeRegion"+$side+".worldMatrix[0]") ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".inputMatrix");
					createNode -n ($upperLower+"Lid"+$outerMain+$i+"AimMM"+$side) multMatrix;
					connectAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimAM"+$side+".outputMatrix") ($upperLower+"Lid"+$outerMain+$i+"AimMM"+$side+".matrixIn[1]");
					connectAttr ("LidSetup"+$side+".worldInverseMatrix[0]") ($upperLower+"Lid"+$outerMain+$i+"AimMM"+$side+".matrixIn[2]");
//					connectAttr ($upperLower+"Lid"+$outerMain+$i+"AimMM"+$side+".matrixSum") ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side+".offsetParentMatrix");

					createNode -n ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimPM"+$side) pickMatrix;
					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimPM"+$side+".useTranslate") 0;
//					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimPM"+$side+".useRotate") 0;
					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimPM"+$side+".useScale") 0;
					setAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimPM"+$side+".useShear") 0;
					connectAttr ($upperLower+"Lid"+$outerMain+$i+"AimMM"+$side+".matrixSum") ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimPM"+$side+".inputMatrix");
					connectAttr ($upperLower+"Lid"+$outerMain+"Loc"+$i+"AimPM"+$side+".outputMatrix") ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side+".offsetParentMatrix");

					}
				else
					aimConstraint -worldUpType objectrotation -worldUpObject ("LidSetup"+$side) -worldUpVector 0 1 0 ($upperLower+"Lid"+$outerMain+"Loc"+$i+$side) ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side);

				createNode -n ($upperLower+"Lid"+$outerMain+$i+"AimEnd"+$side) -p ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side) transform;
				xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$outerMain+$i+"AimEnd"+$side);

				asParentConstraint ($upperLower+"Lid"+$outerMain+$i+"AimEnd"+$side) ($upperLower+"Lid"+$outerMain+$i+$side) "-mo -includePickMatrix";
				if (!$opm)
					delete ($upperLower+"Lid"+$outerMain+$i+$side+"_scaleConstraint1");
				if ($opm)
					{
					setAttr ($upperLower+"Lid"+$outerMain+$i+"PM"+$side+".useScale") 0;
					setAttr ($upperLower+"Lid"+$outerMain+$i+"PM"+$side+".useShear") 0;
					}

				if ($multiSkinClusters)//inverseMatrix out HeadJoint
					{
					$m=`getAttr EyeLidJoints_M.worldMatrix`;
					setAttr ($upperLower+"Lid"+$outerMain+$i+"MM"+$side+".matrixIn[3]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
					connectAttr ($headJoint+".worldInverseMatrix") ($upperLower+"Lid"+$outerMain+$i+"MM"+$side+".matrixIn[4]");
					createNode -n tempXform -p EyeLidJoints_M transform;
					parent tempXform $headJoint;
					$m=`getAttr tempXform.inverseMatrix`;
					delete tempXform;
					setAttr ($upperLower+"Lid"+$outerMain+$i+"MM"+$side+".matrixIn[5]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
					}
				}

			if ($outerMain=="Main")// push-out and bs close only for Main
				{
				for ($i=0;$i<$numLid;$i++)
					{
					if ($upperLower=="lower" && ($i==0 || $i==($numLid-1)))//no need for lower at the same spot (start & end)
						continue;
					//LidOut
					if ($i>0 && $i<$numLid-1)
						{
						createNode -n ($upperLower+"LidOutMult"+$i+$side) multiplyDivide;
						float $factor;
						if ($i<($numLid/2)) $factor=`smoothstep 0 $numLid $i`;
						else $factor=`smoothstep 0 $numLid ($numLid-1-$i)`;
						$factor=$factor*($scale/3.0);
						setAttr ($upperLower+"LidOutMult"+$i+$side+".input1X") $factor;
						connectAttr ("LidSetup"+$side+"."+$upperLower+"LidOut") ($upperLower+"LidOutMult"+$i+$side+".input2X");

						createNode -n ($upperLower+"LidOut"+$i+$side) plusMinusAverage;
						setAttr ($upperLower+"LidOut"+$i+$side+".input1D[0]") `getAttr ($upperLower+"Lid"+$outerMain+$i+"AimEnd"+$side+".tx")`;
						connectAttr ($upperLower+"LidOutMult"+$i+$side+".outputX") ($upperLower+"LidOut"+$i+$side+".input1D[1]");

						connectAttr ($upperLower+"LidOut"+$i+$side+".output1D") ($upperLower+"Lid"+$outerMain+$i+"AimEnd"+$side+".tx");

						if (`attributeExists nonSphericalEye FitEyeBall`)
							{
							if (!`objExists ("LidSetupNonSpAim1"+$side)`)
								{
								createNode -n ("LidSetupNonSpAim1"+$side) -p ("FitEyeBall"+$leftSuffix) transform;
								parent ("LidSetupNonSpAim1"+$side) ("LidSetup"+$side);
								createNode -n ("LidSetupNonSpAim2"+$side) -p ("LidSetupNonSpAim1"+$side) transform;
								}
							parent ($upperLower+"Lid"+$outerMain+$i+"Aim"+$side) ("LidSetupNonSpAim2"+$side);
							}
						}
					}

				select -r ($upperLower+"Lid"+$outerMain+"CurveTweak"+$side) ($upperLower+"LidCurveBlink"+$side) ($upperLower+"LidCurveFleshy"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				blendShape -n ($upperLower+"Lid"+$outerMain+"BS"+$side) -frontOfChain -w 0 1 -w 1 1 -w 2 1;
				}
			else if ($outerMain=="Outer")
				{
				//Remove eye-curvature setup (aimAt setup)
				for ($i=0;$i<$numLid;$i++)
					{
					if ($upperLower=="lower" && ($i==0 || $i==($numLid-1)))//no need for lower at the same spot (start & end)
						continue;
					$pos=`xform -q -ws -t ($upperLower+"LidOuter"+$i+$side)`;
					delete ($upperLower+"LidOuter"+$i+"Aim"+$side);

					if ($opm)
						{
						delete ($upperLower+"LidOuter"+$i+"MM"+$side);
						$m=`getAttr FaceMotionSystem.matrix`;
						setAttr ($upperLower+"LidOuter"+$i+$side+".offsetParentMatrix") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
						xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LidOuter"+$i+$side);

						asParentConstraint ($upperLower+"LidOuterLoc"+$i+$side) ($upperLower+"LidOuter"+$i+$side) "-includePickMatrix";
						setAttr ($upperLower+"LidOuter"+$i+"PM"+$side+".useRotate") 0;
						setAttr ($upperLower+"LidOuter"+$i+"PM"+$side+".useScale") 0;
						setAttr ($upperLower+"LidOuter"+$i+"PM"+$side+".useShear") 0;
						}
					else
						pointConstraint -mo ($upperLower+"LidOuterLoc"+$i+$side) ($upperLower+"LidOuter"+$i+$side);

					if ($multiSkinClusters)//inverseMatrix out HeadJoint
						{
						$m=`getAttr EyeLidJoints_M.worldMatrix`;
						setAttr ($upperLower+"Lid"+$outerMain+$i+"MM"+$side+".matrixIn[3]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
						connectAttr ($headJoint+".worldInverseMatrix") ($upperLower+"Lid"+$outerMain+$i+"MM"+$side+".matrixIn[4]");
						createNode -n tempXform -p EyeLidJoints_M transform;
						parent tempXform $headJoint;
						$m=`getAttr tempXform.inverseMatrix`;
						delete tempXform;
						setAttr ($upperLower+"Lid"+$outerMain+$i+"MM"+$side+".matrixIn[5]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
						}
					}
//				//Just direct connect for LidOuter
//				connectAttr -f ($upperLower+"LidOuterCurveTweak"+$side+"Shape.worldSpace[0]") ($upperLower+"LidOuterCurve"+$side+"Shape.create");
				select -r ($upperLower+"Lid"+$outerMain+"CurveTweak"+$side) ($upperLower+"Lid"+$outerMain+"Curve"+$side);
				blendShape -n ($upperLower+"Lid"+$outerMain+"BS"+$side) -frontOfChain -w 0 1;
				}

			//Controllers
			//inner & Outer Lid
			if ($upperLower=="upper")
				{
				for ($a=0;$a<2;$a++)
					{
					if ($a==0) {$innerouter="inner";$cvNr=0;}
					if ($a==1) {$innerouter="outer";$cvNr=7;}

					asCreatePP ("upperLid"+$outerMain+"Curve"+$side+".cv["+$cvNr+"]") ($innerouter+"Lid"+$outerMainName) $side 2 1 0 $createAttacher;
					asEyeLidAttachPP ($innerouter+"Lid"+$outerMainName) $side;
//					xform -r -os -s $s $s $s ($innerouter+"Lid"+$outerMainName+$side+".cv[0:99]");
					}
				}

			//Lids
			for ($d=1;$d<5;$d++)
				{
				asCreatePP ($upperLower+"Lid"+$outerMain+"Curve"+$side+".cv["+($d+1)+"]") ($upperLower+"Lid"+$d+$outerMainName) $side 1 1 0 $createAttacher;
				asEyeLidAttachPP ($upperLower+"Lid"+$d+$outerMainName) $side;
//				xform -r -os -s $s $s $s ($upperLower+"Lid"+$d+$outerMainName+$side+".cv[0:99]");
				move -r -os -wd 0 0 ($scale/200.0) ($upperLower+"Lid"+$d+$outerMainName+$side+".cv[0:99]");
				}

			//Lid
			delete `pointConstraint ($upperLower+"Lid2"+$outerMainName+$side) ($upperLower+"Lid3"+$outerMainName+$side) TempPos`;
			asCreatePP TempPos ($upperLower+"Lid"+$outerMainName) $side 2 1 0 $createAttacher;
			asEyeLidAttachPP ($upperLower+"Lid"+$outerMainName)  $side;
//			xform -r -os -s $s $s $s ($upperLower+"Lid"+$outerMainName+$side+".cv[0:99]");
			move -r -os -wd 0 0 ($scale/100.0) ($upperLower+"Lid"+$outerMainName+$side+".cv[0:99]");

			if ($outerMain=="Outer")
				{//Main uses curveConstraint method for Driving smaller ctrls, but Outer uses simpler asFaceAddConstrained method
				asFaceAddConstrained ($upperLower+"Lid1"+$outerMainName+$side) ($upperLower+"Lid"+$outerMainName+$side) ("innerLid"+$outerMainName+$side) 6.5;
				asFaceAddConstrained ($upperLower+"Lid2"+$outerMainName+$side) ($upperLower+"Lid"+$outerMainName+$side) ("innerLid"+$outerMainName+$side) 10;
				asFaceAddConstrained ($upperLower+"Lid3"+$outerMainName+$side) ($upperLower+"Lid"+$outerMainName+$side) ("outerLid"+$outerMainName+$side) 10;
				asFaceAddConstrained ($upperLower+"Lid4"+$outerMainName+$side) ($upperLower+"Lid"+$outerMainName+$side) ("outerLid"+$outerMainName+$side) 6.5;
				}

			select ($upperLower+"Lid"+$outerMain+"CurveTweak"+$side);
			select -add ("outerLid"+$outerMainName+"Joint"+$side) ("innerLid"+$outerMainName+"Joint"+$side);
			for ($d=1;$d<5;$d++)
				select -add ($upperLower+"Lid"+$d+$outerMainName+"Joint"+$side);
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($upperLower+"Lid"+$outerMain+"CurveTweakSC"+$side);

			//curve cv weights
			skinPercent -tv ("innerLid"+$outerMainName+"Joint"+$side) 1 ($upperLower+"Lid"+$outerMain+"CurveTweakSC"+$side) ($upperLower+"Lid"+$outerMain+"CurveTweak"+$side+".cv[0]");
			skinPercent -tv ("outerLid"+$outerMainName+"Joint"+$side) 1 ($upperLower+"Lid"+$outerMain+"CurveTweakSC"+$side) ($upperLower+"Lid"+$outerMain+"CurveTweak"+$side+".cv[7]");
			for ($d=2;$d<6;$d++)
				skinPercent -tv ($upperLower+"Lid"+($d-1)+$outerMainName+"Joint"+$side) 1 ($upperLower+"Lid"+$outerMain+"CurveTweakSC"+$side) ($upperLower+"Lid"+$outerMain+"CurveTweak"+$side+".cv["+$d+"]");

			//cv 1 & 6 gets weight-balanced
			skinPercent -tv ("innerLidJoint"+$side) 1 ($upperLower+"LidMainCurveTweakSC"+$side) ($upperLower+"LidMainCurveTweak"+$side+".cv[1]");
			skinPercent -tv ($upperLower+"Lid1Joint"+$side) 0.33 ($upperLower+"LidMainCurveTweakSC"+$side) ($upperLower+"LidMainCurveTweak"+$side+".cv[1]");

			skinPercent -tv ("outerLidJoint"+$side) 1 ($upperLower+"LidMainCurveTweakSC"+$side) ($upperLower+"LidMainCurveTweak"+$side+".cv[6]");
			skinPercent -tv ($upperLower+"Lid4Joint"+$side) 0.33 ($upperLower+"LidMainCurveTweakSC"+$side) ($upperLower+"LidMainCurveTweak"+$side+".cv[6]");

			//HalfMoon
			asFaceHalfMoonCurve ($upperLower+"Lid"+$outerMainName+$side) (90*$upperLowerFactor);
//			for ($d=1;$d<5;$d++)
//				asFaceHalfMoonCurve ($upperLower+"Lid"+$d+$outerMainName+$side) ((`asFaceLidAngle ($upperLower+"Lid"+$d+$side)`*-1)+180);
			if ($upperLower=="upper")
				{
				asFaceHalfMoonCurve ("innerLid"+$outerMainName+$side) 180;
				asFaceHalfMoonCurve ("outerLid"+$outerMainName+$side) 0;
				}
			}

		// Outercolors
		if (!$simplerEyeLid)
			{
			asSetRGBOverrideColor ($upperLower+"LidOuter"+$side+"Shape") {0.147,0.578,0.147};

			for ($d=1;$d<5;$d++)
				asSetRGBOverrideColor ($upperLower+"Lid"+$d+"Outer"+$side+"Shape") {0.0,0.27,1.0}; 

			if ($upperLower=="upper")
				{
				asSetRGBOverrideColor ("innerLidOuter"+$side+"Shape") {0.147,0.578,0.147};
				asSetRGBOverrideColor ("outerLidOuter"+$side+"Shape")  {0.147,0.578,0.147};
				}
			}
		}
	}


//LidCurveFleshy
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	createNode -n ("LidSetupFleshy"+$side) -p LidSetup transform;
	createNode -n ("LidFleshyAimAt"+$side) -p LidSetup transform;
//	asAlign ("LidSetupFleshy"+$side) OnFacecontrols 1 0 0 0;
//	asAlign ("LidFleshyAimAt"+$side) OnFacecontrols 1 0 0 0;
	for ($a=0;$a<size($innerUpperOuterLower);$a++)
		{
		createNode -n ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side) -p ("LidSetup"+$side) transform;
		parent ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side) ("LidSetupFleshy"+$side);

		createNode -n ($innerUpperOuterLower[$a]+"LidFleshyAimAtOffset"+$side) -p ($innerUpperOuterLower[$a]+"LidJoint"+$side) transform;
		parent ($innerUpperOuterLower[$a]+"LidFleshyAimAtOffset"+$side) ("LidFleshyAimAt"+$side);

		createNode -n ($innerUpperOuterLower[$a]+"LidFleshyAimAt"+$side) -p ($innerUpperOuterLower[$a]+"LidFleshyAimAtOffset"+$side) transform;
		connectAttr ($innerUpperOuterLower[$a]+"LidJoint"+$side+".tx") ($innerUpperOuterLower[$a]+"LidFleshyAimAt"+$side+".tx");
		connectAttr ($innerUpperOuterLower[$a]+"LidJoint"+$side+".tz") ($innerUpperOuterLower[$a]+"LidFleshyAimAt"+$side+".tz");

		if ($opm)
			{
			createNode -n ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side) aimMatrix;
			setAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".primaryInputAxis") -type float3 1 0 0;
			setAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".secondaryMode") 2;
			setAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".secondaryInputAxis") -type float3 0 1 0;
			setAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".secondaryTargetVector") -type float3 0 1 0;
			connectAttr ($innerUpperOuterLower[$a]+"LidFleshyAimAt"+$side+".worldMatrix[0]") ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".primaryTargetMatrix");
//			connectAttr ("LidSetup"+$side+".worldMatrix[0]") ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".secondaryTargetMatrix");

//			connectAttr ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side+".worldMatrix[0]") ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".inputMatrix");
			$m=`xform -q -os -m ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side)`;
			setAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".inputMatrix") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side);
/*
			createNode -n ($innerUpperOuterLower[$a]+"LidFleshyAimerMM"+$side) multMatrix;
			connectAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".outputMatrix") ($innerUpperOuterLower[$a]+"LidFleshyAimerMM"+$side+".matrixIn[1]");
			connectAttr ("LidSetup"+$side+".worldInverseMatrix[0]") ($innerUpperOuterLower[$a]+"LidFleshyAimerMM"+$side+".matrixIn[2]");
			connectAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerMM"+$side+".matrixSum") ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side+".offsetParentMatrix");
*/
			connectAttr ($innerUpperOuterLower[$a]+"LidFleshyAimerAM"+$side+".outputMatrix") ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side+".offsetParentMatrix");
			}
		else
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ($innerUpperOuterLower[$a]+"LidFleshyAimAt"+$side) ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side);

		createNode -n ($innerUpperOuterLower[$a]+"LidFleshyAimEnd"+$side) -p ($innerUpperOuterLower[$a]+"Lid"+$side) joint;
		parent ($innerUpperOuterLower[$a]+"LidFleshyAimEnd"+$side) ($innerUpperOuterLower[$a]+"LidFleshyAimer"+$side);

		//rotate (PMA not made for Rot only for Trans, for lip reasons, so add this
		createNode -n ($innerUpperOuterLower[$a]+"LidJointPMAr"+$side) plusMinusAverage;
		connectAttr ($innerUpperOuterLower[$a]+"Lid"+$side+".r") ($innerUpperOuterLower[$a]+"LidJointPMAr"+$side+".input3D[0]");
		connectAttr ("SDK"+$innerUpperOuterLower[$a]+"Lid"+$side+".r") ($innerUpperOuterLower[$a]+"LidJointPMAr"+$side+".input3D[1]");
		connectAttr ($innerUpperOuterLower[$a]+"LidJointPMAr"+$side+".output3D") ($innerUpperOuterLower[$a]+"LidFleshyAimEnd"+$side+".r");
		}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		select ($upperLower+"LidCurveFleshy"+$side) ($upperLower+"LidFleshyAimEnd"+$side);
		select -add ("innerLidFleshyAimEnd"+$side) ("outerLidFleshyAimEnd"+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 2 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"LidCurveFleshySC"+$side);
		skinPercent -tv ("outerLidFleshyAimEnd"+$side) 0.867 ($upperLower+"LidCurveFleshySC"+$side) ($upperLower+"LidCurveFleshy"+$side+".cv[6]");
		skinPercent -tv ("outerLidFleshyAimEnd"+$side) 0.600 ($upperLower+"LidCurveFleshySC"+$side) ($upperLower+"LidCurveFleshy"+$side+".cv[5]");
		skinPercent -tv ("outerLidFleshyAimEnd"+$side) 0.200 ($upperLower+"LidCurveFleshySC"+$side) ($upperLower+"LidCurveFleshy"+$side+".cv[4]");
		skinPercent -tv ("innerLidFleshyAimEnd"+$side) 0.200 ($upperLower+"LidCurveFleshySC"+$side) ($upperLower+"LidCurveFleshy"+$side+".cv[3]");
		skinPercent -tv ("innerLidFleshyAimEnd"+$side) 0.600 ($upperLower+"LidCurveFleshySC"+$side) ($upperLower+"LidCurveFleshy"+$side+".cv[2]");
		skinPercent -tv ("innerLidFleshyAimEnd"+$side) 0.867 ($upperLower+"LidCurveFleshySC"+$side) ($upperLower+"LidCurveFleshy"+$side+".cv[1]");
		}

	//Also, Re-directing Lid-Corner controllers to Drive LidFleshy-Curve, instead of LidTweak-Curve, to get "broader" curve effect
	for ($a=0;$a<2;$a++)
		{
		if ($a==0) $innerouter="inner";
		if ($a==1) $innerouter="outer";

		disconnectAttr ($innerouter+"LidJointPMAt"+$side+".output3D") ($innerouter+"LidJoint"+$side+".t");
		connectAttr -f ($innerouter+"LidJointPMAt"+$side+".output3D.output3Dx") ($innerouter+"LidFleshyAimAt"+$side+".tx");
		connectAttr -f ($innerouter+"LidJointPMAt"+$side+".output3D.output3Dy") ($innerouter+"LidFleshyAimAt"+$side+".ty");
		connectAttr -f ($innerouter+"LidJointPMAt"+$side+".output3D.output3Dz") ($innerouter+"LidFleshyAimAt"+$side+".tz");
		}
	}

//blink curves
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		select -r ($upperLower+"UnClosedLidCurve"+$side) ($upperLower+"ClosedLidCurve"+$side) ($upperLower+"LidCurveBlink"+$side);
		blendShape -n ($upperLower+"LidCurveBlinkBS"+$side) -frontOfChain -w 0 1.0 -w 1 0.0;
		}
	}

//ctrlLid attributes
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		//blink
		if (!`attributeExists blink ($upperLower+"Lid"+$side)`)
			{
			addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ($upperLower+"Lid"+$side);
			asEnsureOutputBlendWeighted ($upperLower+"Lid"+$side+".blink");
			}

		//blinkCenter
		if ($upperLower=="upper")
			{
			addAttr -ln "blinkCenter"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 2 ($upperLower+"Lid"+$side);
			asEnsureOutputBlendWeighted ($upperLower+"Lid"+$side+".blinkCenter");

			createNode -n ($upperLower+"blinkCenterSR"+$side) setRange;
			setAttr ($upperLower+"blinkCenterSR"+$side+".oldMax") -type float3 10 10 10;
			connectAttr ("bw"+$upperLower+"Lid"+$side+"_blink.output") ($upperLower+"blinkCenterSR"+$side+".valueX");

			createNode -n ($upperLower+"blinkCenterPMA"+$side) plusMinusAverage;
			setAttr ($upperLower+"blinkCenterPMA"+$side+".input1D[0]") 10;
			setAttr ($upperLower+"blinkCenterPMA"+$side+".operation") 2;
			connectAttr ("bw"+$upperLower+"Lid"+$side+"_blinkCenter.output") ($upperLower+"blinkCenterPMA"+$side+".input1D[1]");
			connectAttr ($upperLower+"blinkCenterPMA"+$side+".output1D") ($upperLower+"blinkCenterSR"+$side+".maxX");
			connectAttr ("bw"+$upperLower+"Lid"+$side+"_blinkCenter.output") ($upperLower+"blinkCenterSR"+$side+".maxY");
			}
		if ($upperLower=="lower")
			connectAttr ("bw"+$upperLower+"Lid"+$side+"_blink.output") ("upperblinkCenterSR"+$side+".valueY");

		//upperLid TY also drives Blink
		createNode -n tempTransform -p ("upperLid"+$side) transform;
		parent tempTransform ("lowerLid"+$side);
		$tyValueForCloseLid=`getAttr tempTransform.ty`;
		delete tempTransform;
		createNode -n ($upperLower+"blinkBlendMPD1"+$side) multiplyDivide;
		setAttr ($upperLower+"blinkBlendMPD1"+$side+".operation") 2;
		createNode -n ($upperLower+"blinkBlendPMA"+$side) plusMinusAverage;

//		connectAttr ($upperLower+"Lid"+$side+".ty") ($upperLower+"blinkBlendPMA"+$side+".input3D[0].input3Dy");
		//This direct ty connection, means it fails to evaluate, if keyframes exists on tx and we are in Parallel evaluation mode,so:
		createNode -n ($upperLower+"blinkBlendForceParallelEvalPMA"+$side) plusMinusAverage;
		connectAttr ($upperLower+"Lid"+$side+".tx") ($upperLower+"blinkBlendForceParallelEvalPMA"+$side+".input3D[0].input3Dx");
		connectAttr ($upperLower+"Lid"+$side+".ty") ($upperLower+"blinkBlendForceParallelEvalPMA"+$side+".input3D[0].input3Dy");
		connectAttr ($upperLower+"Lid"+$side+".tz") ($upperLower+"blinkBlendForceParallelEvalPMA"+$side+".input3D[0].input3Dz");
		connectAttr ($upperLower+"blinkBlendForceParallelEvalPMA"+$side+".output3D.output3Dy") ($upperLower+"blinkBlendPMA"+$side+".input3D[0].input3Dy");

		connectAttr ("SDK"+$upperLower+"Lid"+$side+".ty") ($upperLower+"blinkBlendPMA"+$side+".input3D[1].input3Dy");
		connectAttr ($upperLower+"blinkBlendPMA"+$side+".output3D.output3Dy") ($upperLower+"blinkBlendMPD1"+$side+".input1Y");
		setAttr ($upperLower+"blinkBlendMPD1"+$side+".input2Y") ($tyValueForCloseLid/-10.0*$upperLowerFactor);
//		connectAttr ($upperLower+"blinkBlendMPD1"+$side+".outputY") ("bw"+$upperLower+"Lid"+$side+"_blink.input[1]");
		createNode -n ($upperLower+"LidBlendWeighted"+$side) blendWeighted;
		if ($upperLower=="upper")
			connectAttr ("upperblinkCenterSR"+$side+".outValueX") ($upperLower+"LidBlendWeighted"+$side+".input[0]");
		if ($upperLower=="lower")
			connectAttr ("upperblinkCenterSR"+$side+".outValueY") ($upperLower+"LidBlendWeighted"+$side+".input[0]");
		connectAttr ($upperLower+"blinkBlendMPD1"+$side+".outputY") ($upperLower+"LidBlendWeighted"+$side+".input[1]");

		asUnitConvertAndReverse ($upperLower+"blinkBlend"+$side) ($upperLower+"LidBlendWeighted"+$side+".output");
		connectAttr ($upperLower+"blinkBlend"+$side+"UnitConversion.output") ($upperLower+"LidCurveBlinkBS"+$side+"."+$upperLower+"ClosedLidCurve"+$side);
		connectAttr ($upperLower+"blinkBlend"+$side+"Reverse.outputX") ($upperLower+"LidCurveBlinkBS"+$side+"."+$upperLower+"UnClosedLidCurve"+$side);

		//lidOut
		if (!`attributeExists lidOut ($upperLower+"Lid"+$side)`)
			{
			addAttr -ln "lidOut" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ($upperLower+"Lid"+$side);
			asEnsureOutputBlendWeighted ($upperLower+"Lid"+$side+".lidOut");
			asUnitConvertAndReverse ($upperLower+"lidOutBlend"+$side) ("bw"+$upperLower+"Lid"+$side+"_lidOut.output");
			}
		connectAttr ($upperLower+"lidOutBlend"+$side+"UnitConversion.output") ("LidSetup"+$side+"."+$upperLower+"LidOut");
		delete ($upperLower+"lidOutBlend"+$side+"Reverse");//not using the reverse
		}


	for ($c=0;$c<2;$c++)//fleshyEye applies to both Main & Outer
		{
		if ($c==0) {$outerMain="Main";$outerMainName="";}//In fit named Main VS Outer, in rig named "" VS Outer
		if ($c==1) {$outerMain="Outer";$outerMainName="Outer";}
		if ($simplerEyeLid && $c==1) continue;

		for ($a=0;$a<size($innerUpperOuterLower);$a++)
			{
			//fleshyEye
			$dv=7;
			if ($innerUpperOuterLower[$a]=="inner" || $innerUpperOuterLower[$a]=="outer")
				$dv=1;
			if ($innerUpperOuterLower[$a]=="lower")
				$dv=3;
			if ($outerMain=="Outer")
				$dv=$dv/5.0;
			createNode -n ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Fleshy"+$side) -p ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Offset"+$side) transform;
			if (`objExists ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Attach"+$side)`)//Main not Outer
				parent ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Fleshy"+$side) ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Attach"+$side);
			parent ("SDK"+$innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side) ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Fleshy"+$side);
			addAttr -ln "fleshy" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv $dv ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side);
			createNode -n ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyMPD") multiplyDivide;
			createNode -n ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTXConversion") unitConversion;
			createNode -n ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTYConversion") unitConversion;
			setAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTXConversion.conversionFactor") (-0.125*$b);
			setAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTYConversion.conversionFactor") -0.130;
			if ($opm)
				{
				if (!`objExists ("EyeJointDM"+$side)`)
					{
					createNode -n ("EyeJointDM"+$side) decomposeMatrix;
					$rotOrder=`getAttr ("EyeJoint"+$side+".rotateOrder")`;
					setAttr ("EyeJointDM"+$side+".inputRotateOrder") $rotOrder;
					connectAttr ("EyeJointMM"+$side+".matrixSum") ("EyeJointDM"+$side+".inputMatrix");
					}
				connectAttr ("EyeJointDM"+$side+".outputRotateY") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTXConversion.input");
				connectAttr ("EyeJointDM"+$side+".outputRotateX") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTYConversion.input");
				}
			else
				{
				connectAttr ("EyeJoint"+$side+".ry") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTXConversion.input");
				connectAttr ("EyeJoint"+$side+".rx") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTYConversion.input");
				}
			connectAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTXConversion.output") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyMPD.input1X");
			connectAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyTYConversion.output") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyMPD.input1Y");
			connectAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+".fleshy") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyMPD.input2X");
			connectAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+".fleshy") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyMPD.input2Y");
			connectAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyMPD.outputX") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Fleshy"+$side+".tx");
			connectAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+$side+"FleshyMPD.outputY") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Fleshy"+$side+".ty");
			//Also drives blink
			if ($outerMain=="Main")
				{
				if (`objExists ($innerUpperOuterLower[$a]+"blinkBlendPMA"+$side)`)
					connectAttr ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"Fleshy"+$side+".ty") ($innerUpperOuterLower[$a]+"blinkBlendPMA"+$side+".input3D[2].input3Dy");
				if (`objExists ($innerUpperOuterLower[$a]+"LidJointPMAt"+$side)`)
					connectAttr -f ($innerUpperOuterLower[$a]+"LidFleshy"+$side+".t") ($innerUpperOuterLower[$a]+"LidJointPMAt"+$side+".input3D[3]");
				//and include in subtract
				connectAttr ($innerUpperOuterLower[$a]+"LidFleshy"+$side+".t") ($innerUpperOuterLower[$a]+"Lid"+$outerMainName+"PMA"+$side+".input3D[2]");
				}
			}
		}

	//asEnsureOutputBlendWeighted
	$tempString=`listAttr -k ("ctrlEye"+$side)`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`getAttr -l ("ctrlEye"+$side+"."+$tempString[$i])`)
			continue;
		asEnsureOutputBlendWeighted ("ctrlEye"+$side+"."+$tempString[$i]);
		}
	}

//NonSymmetrical model could cause `runaway` eyeLidAreaLeft
select eyeLidArea;
$tempString=`ls -sl -fl`;
select eyeLidAreaLeft;
$tempString2=`ls -sl -fl`;
if (size($tempString)!=size($tempString2))
	warning ("eyeLidArea has "+size($tempString)+" verts, but eyeLidAreaLeft has "+size($tempString2)+" verts, probably model is asymmetrical.\n");

//Add joint as influences
string $addInfCmd="skinCluster -e ";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";}
		else {$upperLower="lower";}

		for ($c=0;$c<2;$c++)
			{
			if ($c==0) {$outerMain="Main";$outerMainName="";}//In fit named Main VS Outer, in rig named "" VS Outer
			if ($c==1) {$outerMain="Outer";$outerMainName="Outer";}
			if ($simplerEyeLid && $c==1) continue;

			$numLid=`getAttr ($upperLower+"EyeLid"+$outerMain+"Curve"+$leftSuffix+".spans")`+1;

			for ($i=0;$i<$numLid;$i++)
				{
				if ($upperLower=="lower" && ($i==0 || $i==($numLid-1)))//no need for lower at the same spot (start & end)
					continue;
				progressBar -e -s 1 $gMainProgressBar;
				$addInfCmd+=" -ai "+$upperLower+"Lid"+$outerMain+$i+$side;
				}
			}
		}
	}

$addInfCmd+=" -lw false -wt 0 "+$skinCluster;
eval ($addInfCmd);

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;

//Full weight for $mainVtxs & $innerVtxs
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";}
		else {$upperLower="lower";}

		for ($c=0;$c<2;$c++)
			{
			if ($c==0) {$outerMain="Main";$outerMainName="";}//In fit named Main VS Outer, in rig named "" VS Outer
			if ($c==1) {$outerMain="Outer";$outerMainName="Outer";}
			if ($simplerEyeLid && $c==1) continue;

			$numLid=`getAttr ($upperLower+"EyeLid"+$outerMain+"Curve"+$leftSuffix+".spans")`+1;

			$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLid"+$outerMain+"Curve"+$leftSuffix)`;
			$upLoMainVtxs=`stringToStringArray $tempString[0] " "`;
			$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidInnerCurve"+$leftSuffix)`;
			$upLoInnerVtxs=`stringToStringArray $tempString[0] " "`;

			for ($i=0;$i<size($upLoMainVtxs);$i++)
				{
				if ($upperLower=="lower" && ($i==0 || $i==($numLid-1)))//no need for lower at the same spot (start & end)
					continue;
				//MainVtxs
				$pos=`xform -q -ws -t $upLoMainVtxs[$i]`;
				if ($side=="_L" && $leftSuffix=="") $pos[0]=$pos[0]*-1;
				setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
				skinPercent -tv ($upperLower+"Lid"+$outerMain+$i+$side) 1 $skinCluster ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
				}
			}

		//Main2
		if (!`objExists ($upperLower+"EyeLidMain2Curve")`)
			continue;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidMain2Curve"+$leftSuffix)`;
		$upLoMainVtxs=`stringToStringArray $tempString[0] " "`;
		for ($i=0;$i<size($upLoMainVtxs);$i++)
			{
			if ($upperLower=="lower" && ($i==0 || $i==($numLid-1)))//no need for lower at the same spot (start & end)
				continue;
			//MainVtxs
			$pos=`xform -q -ws -t $upLoMainVtxs[$i]`;
			if ($side=="_L" && $leftSuffix=="") $pos[0]=$pos[0]*-1;
			setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
			if (`objExists ($upperLower+"LidMain"+$i+$side)`)
				$joint=$upperLower+"LidMain"+$i+$side;
			skinPercent -tv $joint 1 $skinCluster ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			}
		}
	}

//after adding eyeLidOuterRing, just hammer eyeLidArea instead of the `per vertex-row`
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	//Hammer between Main & Outer
	select ("eyeLidArea"+$leftSuffix);
	eval ("select -d "+`asGetFaceFitSelection ("FaceFitEyeLidMainCurve"+$leftSuffix)`);
	if (`objExists upperEyeLidMain2Curve`) eval ("select -d "+`asGetFaceFitSelection ("FaceFitEyeLidMain2Curve"+$leftSuffix)`);
	if (size(`ls -sl`))
//		weightHammerVerts;
		asWeightHammerVertsMS 5 $skinCluster;

	//Hammer from Outer and `as far as` eyeBrow
	select ("eyeLidOuterArea"+$leftSuffix);
	eval ("select -d "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
	if (size(`ls -sl`))
//		weightHammerVerts;
		asWeightHammerVertsMS 5 $skinCluster;
	}

//changing the weight-blending to be per vertex-row, to upper to lower bleeding
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	for ($z=0;$z<2;$z++)
		{
		eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
		$outerVtxs=`ls -sl -fl`;
		eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidMainCurve"+$leftSuffix)`);
		$mainVtxs=`ls -sl -fl`;
		eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidInnerCurve"+$leftSuffix)`);
		$innerVtxs=`ls -sl -fl`;

		if (`objExists FaceFitEyeLidMain2`)
			{
			eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidMain2Curve"+$leftSuffix)`);
			$main2Vtxs=`ls -sl -fl`;
			}

		if ($z==0) $innerOuterVtx=$outerVtxs;
		if ($z==1) $innerOuterVtx=$innerVtxs;
		if ($z==1)//if the same edgeLoop has been used for Main & Inner, then skip
			{
			if (`stringArrayCount $innerVtxs[0] $mainVtxs`)
				break;
			}

		//traversing edgeRow is slow for dense models, so we skip this for 500+ verts, with clear $rowWeightedVtxs they will get hammered
		select ("eyeLidArea"+$leftSuffix);
		if (size(`ls -sl -fl`)>500)
			{
			print "// eyeLidArea exceed 500 verticies, using simplified skinning for this area.\n";
			break;
			}

		for ($i=0;$i<size($mainVtxs);$i++)
			{
			select $mainVtxs[$i];
			$lidMainVtxNr=`asComponentToNr $mainVtxs[$i]`;
			for ($a=0;$a<99;$a++)
				{
				ConvertSelectionToEdges;
				ConvertSelectionToVertices;
				select -d $mainVtxs;
				$tempString=`ls -sl -fl`;
				for ($y=0;$y<size($tempString);$y++)
					if (`stringArrayCount $tempString[$y] $innerOuterVtx`)
						{
						$lidOuterVtxNr=`asComponentToNr $tempString[$y]`;
//						select `polySelect -q -asSelectString -shortestEdgePath $lidMainVtxNr $lidOuterVtxNr`;
						asSelectLeastEdgesPath $geometry $lidMainVtxNr $lidOuterVtxNr;
						ConvertSelectionToVertices;
						select -d $mainVtxs[$i];
						if ($z==0)//no need to weight the last row, if it is Outer
							select -d $innerOuterVtx;
						$rowVtxs=`ls -sl -fl`;
						$a=99;
						$y=99;
						break;
						}
				}

			$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $mainVtxs[$i]`;
			$rowWeightedVtxs=`stringArrayCatenate $rowWeightedVtxs $rowVtxs`;

			if ($z==1)//Main to Inner just to have full weight
				{
				if (size($rowVtxs))
					skinPercent -tv $infs[0] 1 $skinCluster $rowVtxs;
				continue;
				}

			select $mainVtxs[$i];
			clear $previousVtxs;
			for ($a=0;$a<size($rowVtxs);$a++)
				{
				ConvertSelectionToEdges;
				ConvertSelectionToVertices;
				$tempString=`ls -sl -fl`;
				select -d $previousVtxs;
				$previousVtxs=$tempString;
				$tempString=`ls -sl -fl`;
				for ($y=0;$y<size($tempString);$y++)
					if (`stringArrayCount $tempString[$y] $rowVtxs`)
						skinPercent -tv $infs[0] (1-((1.0/(size($rowVtxs)+1))*($a+1))) $skinCluster $tempString[$y];
				}
			}
		}

	//then weigh-hammer `left-overs`
	eval ("select "+`asGetFaceFitSelection ("EyeLidInnerAreaMesh"+$leftSuffix)`);
	$tempString=`ls -sl`;
//	select `asobjSetCast "" $tempString EyeLidLayer`;
	select -d $rowWeightedVtxs $mainVtxs $main2Vtxs $outerVtxs $innerVtxs;
	if (size(`ls -sl`))
//		weightHammerVerts;
		asWeightHammerVertsMS 5 $skinCluster;
	}

select -cl;

//if (!$nonSymmetrical)
//	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

delete FaceBuildEyeLidCurves;

//dualQ weight eyeLids
if (!$gameEngine)
	{
	setAttr ($skinCluster+".skinningMethod") 2;
	//flood first
	$tempInts=`polyEvaluate -v $geometry`;
	$numVtx=$tempInts[0];
	for ($i=0;$i<$numVtx;$i++)
	    setAttr ($skinCluster+".bw["+$i+"]") 0;
	//then weight eyeLidArea
	select eyeLidArea eyeLidAreaLeft;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($skinCluster+".bw["+`asComponentToNr $tempString[$i]`+"]") 1;
	}

//eyeLidMainArea
select -cl;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $leftSuffix="";
	else $leftSuffix="Left";

	eval ("select -add "+`asGetFaceFitSelection ("FaceFitEyeLidMainCurve"+$leftSuffix)`);
	if (`objExists upperEyeLidMain2Curve`)
		eval ("select -add "+`asGetFaceFitSelection ("FaceFitEyeLidMain2Curve"+$leftSuffix)`);
	}
sets -n eyeLidMainArea;
sets -add FaceAreas eyeLidMainArea;

//Eyelashes
if ($eyeLash!="")
	{
	eval ("select "+$eyeLash);
	asFaceAttachEyeLashes;
	}

//for $simplerEyeLid, auto-create a `CheekRaiser` (lowerLidOuter)
if ($simplerEyeLid)
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	select ("lowerEyeLidOuterCurve"+$leftSuffix+".cv["+(`getAttr lowerEyeLidOuterCurve.spans`+1)/2+"]");
	$pos=`xform -q -ws -t`;
	xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
	asCreatePP TempPos lowerLidOuter $side 3 1 0 0;
//	parent ("lowerLidOuterJoint"+$side) EyeLidJoints_M;
	skinCluster -e -dr 4 -lw false -wt 0 -ai ("lowerLidOuterJoint"+$side) $skinCluster;
//	xform -r -os -s 1.5 1.5 1.5 ("lowerLidOuter"+$side+".cv[0:99]");
//	setAttr ("lowerLidOuter"+$side+".v") 0;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$tempString[0]=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	skinPercent -tv ("lowerLidOuterJoint"+$side) 1 $skinCluster $tempString[0];
	select $tempString[0];
	for ($i=0;$i<$numGrow;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		}
	select -d ("eyeLidArea"+$leftSuffix) $tempString[0];
	if (size(`ls -sl`))
//		weightHammerVerts;
		asWeightHammerVertsMS 5 $skinCluster;
	select $tempString[0];
//	weightHammerVerts;
	asWeightHammerVertsMS 5 $skinCluster;
	skinPercent -tv ("lowerLidOuterJoint"+$side) 0.5 $skinCluster $tempString[0];
	}

if (`objExists closestSampler`) delete closestSampler;
if (`objExists TempPos`) delete TempPos;

//restore FaceControlOrient;
setAttr FaceControlOrient.v 0;
rename FaceControlOrient FaceControlOrientEye;
rename FaceControlSuspended FaceControlOrient;

delete tempNearestPointOnCurve;

select -cl;
}

global proc asFaceEyeBlink ()
{
int $simplerEyeLid=`checkBox -q -v asFaceSimplerEyeLidCheckBox`;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	asEnsureOutputBlendWeighted ("ctrlEye"+$side+".blink");

	//Blink `fadeouts` Fleshy, so looking upwards when eyeBlink=10 does not open eyeLid
	asUnitConvertAndReverse ("bwctrlEye"+$side+"_blink")("bwctrlEye"+$side+"_blink.output");
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		createNode -n ($upperLower+"Lid"+$side+"FleshyBlinkMPD") multiplyDivide;
		connectAttr ($upperLower+"Lid"+$side+".fleshy") ($upperLower+"Lid"+$side+"FleshyBlinkMPD.input1Y");
		connectAttr ("bwctrlEye"+$side+"_blinkReverse.outputX") ($upperLower+"Lid"+$side+"FleshyBlinkMPD.input2Y");
		connectAttr -f ($upperLower+"Lid"+$side+"FleshyBlinkMPD.outputY")($upperLower+"Lid"+$side+"FleshyMPD.input2Y");
		}
	}

asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;

//fit-anim
asFaceFitAnim ctrlEye_R.blink 10;
asFaceFitAnim ctrlEye_L.blink 10;
asFaceFitAnim upperLid_R.blink 10;
asFaceFitAnim lowerLid_R.blink 10;
asFaceFitAnim upperLid_R.tx -0.2;
asFaceFitAnim lowerLid_R.tx -0.2;
asFaceFitAnim outerLid_R.tx -0.1;

if (!$simplerEyeLid)
	{
	asFaceFitAnim upperLidOuter_R.tx -0.05;
	asFaceFitAnim upperLidOuter_R.ty -0.07;
	asFaceFitAnim lowerLidOuter_R.tx -0.1;
	asFaceFitAnim lowerLidOuter_R.ty 0.1;
	}

if (`asIsMayaLT`)
	warning "Maya LT detected, this version of Maya does not have \"Wrap\" deformer, so Eyelid deformation will not be optimal.";

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceEyeBlinkFinish ()
{
if (`attributeExists EyeBlinkFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln EyeBlinkFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlEye _RL blink 10;
asFaceHideControllers 1;
setAttr ctrlBoxEye_R.v 1;
setAttr ctrlBoxEye_L.v 1;
/*
//asFaceDsFinish will reset fleshy values, so re-apply
setAttr upperLidOuter_R.fleshy 1.4;
setAttr upperLidOuter_L.fleshy 1.4;
*/
}

global proc asFaceLip ()
{
global string $gMainProgressBar;
global string $gSelect;
global string $artSelectObject;
global string $gMove;
setToolTo $gMove;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $nonOverriddenHeadJoint=$headJoint;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $b,$mainNumCv,$ctrlNr,$type,$numCvs,$nrAsInt,$nearestVtx,$end,$lipCtrls,$uInt,$ribbonSpansU,$jointNr,$cvNr;
int $opm=`asGetOpm`;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $innerVtxNr[],$outerVtxNr[],$mainVtxNr[];
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
//float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $faceFitScale=`getAttr FaceFitSkeleton.faceScale`;
float $dist,$prevDist,$currentValue,$factor,$lipDistOffsetScale,$minDist,$minDist1,$minDist2,$value,$driveStartValue,$s,$parameter,$parameterOnUniform,$step;
float $ctrlParameter,$jointParameter,$u;
float $pos[],$posA[],$posB[],$posC[],$posD[],$posAB[],$posUpperA[],$posLowerA[],$libBShapePos[],$rot[];
float $jawPos[],$eyeCnrPos[],$midLipPos[],$noseUnderPos[],$jawPivotPos[],$m[];
string $startVtx,$endVtx,$inOutMain,$side,$inf,$ctrl,$cd,$setRange,$plusMinusAverage,$joint,$grpA,$grpB,$jointOffset,$nr,$cmd,$upperLower;
string $leftSuffix,$letter,$curveCmd,$jointSide,$alignTo,$closestCtrl1,$closestCtrl2;
string $tempString[],$tempString2[],$tempString3[],$completedVtxs[],$endingVtxs[],$allLoopVtxs[],$lipArea[],$lipPress[];
string $rightCnrVtxs[],$leftCnrVtxs[],$loopVtxs[],$lipCtrlsList[];
string $AB[]={"A","B"};
string $tr[]={"t","r"};
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

asFaceEyeBlinkFinish;

asFaceHideControllers 1;
setAttr ctrlBox.RegionsCtrlVis 0;

if (!`objExists upperLipMainCurve`)//skip
	return;

if ($multiSkinClusters)
	{
	$skinCluster=`asFaceMultiSkinClusterAdd "Lip"`; 
	$headJoint="MultiSkinClustersFaceLipJoint_M";
	}

$lipCtrls=12;$end=3;$ribbonSpansU=5;
if (`attributeExists LipCtrls FaceFitSkeleton`)
	{
	$lipCtrls=`getAttr -asString FaceFitSkeleton.LipCtrls`;
	$end=($lipCtrls)/4;
	$ribbonSpansU=($lipCtrls/2)-1;
	}

progressBar -e -st "Lip Falloff" -bp -ii 0 -min 0 -max 14 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

eval ("select "+`asGetFaceFitSelection LipInnerAreaMesh`);
$tempString=`ls -sl`;
//select `asobjSetCast "" $tempString LipLayer`;
$lipArea=`ls -sl -fl`;

createNode -n lipArea objectSet;
sets -add FaceAreas lipArea;
sets -add lipArea $lipArea;

createNode -n LipSetup transform;
parent LipSetup FaceDeformationSystem;
createNode -n LipRibbon -p LipSetup transform;
createNode -n LipFollicles -p LipSetup transform;
createNode -n LipRibbonJoints -p LipSetup transform;
createNode -n LipRibbonLocs -p LipSetup transform;
createNode -n LipRibbonFleshy -p LipSetup transform;
createNode -n LipRibbonFleshyJoints -p LipSetup transform;
createNode -n LipSlider -p LipSetup transform;

createNode -n LipFollowHead -p LipSetup transform;
//parentConstraint $headJoint LipFollowHead;
//asParentConstraint $headJoint LipFollowHead "";
if ($opm)
	asParentConstraint $nonOverriddenHeadJoint LipFollowHead "";
else
	{
	parentConstraint $headJoint LipFollowHead;
	connectAttr MainAndHeadScaleMultiplyDivide.output LipFollowHead.s;
	}
createNode -n LipFollowHeadConstrained transform;
parent LipRibbonJoints LipFollicles LipFollowHeadConstrained LipFollowHead;

select LipFollowHead;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr ($geometry+".outMesh") closestSampler.inMesh;
createNode -n closestNurbsSampler closestPointOnSurface;
createNode -n LipConstruction transform;

//LipJoint
select FaceJoint_M;
joint -n LipJoints_M;
setAttr LipJoints_M.segmentScaleCompensate 0;
setAttr LipJoints_M.drawStyle 2;//Draw-style=none, otherwise looks too busy

$pos=`xform -q -ws -t ("upperLipOuterCurve.cv[0]")`;
$posA=`xform -q -ws -t ("lowerLipOuterCurve.cv[0]")`;
xform -ws -t 0 (($pos[1]+$posA[1])/2.0) `max $pos[2] $posA[2]` LipJoints_M;

//Press & Roll & Pucker addAttrs
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Press") -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlLips_M;
	asEnsureOutputBlendWeighted ("ctrlLips_M."+$upperLower+"Press");
	}
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Squeeze") -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlLips_M;
	asEnsureOutputBlendWeighted ("ctrlLips_M."+$upperLower+"Squeeze");
	}
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Roll") -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlLips_M;
	asEnsureOutputBlendWeighted ("ctrlLips_M."+$upperLower+"Roll");
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Pucker") -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlLips_M;
	asEnsureOutputBlendWeighted ("ctrlLips_M."+$upperLower+"Pucker");
	}

//LipRegion
$posA=`xform -q -ws -t upperLipMainCurve.cv[0]`;
$posB=`xform -q -ws -t lowerLipMainCurve.cv[0]`;
$pos[0]=0;$pos[1]=($posA[1]+$posB[1])/2.0;$pos[2]=($posA[2]+$posB[2])/2.0;

asCreateFaceController "LipRegion" "_M" 4;
delete LipRegionJoint_M;
parent LipRegionOffset_M SideReverse_M;
setAttr LipRegionOffset_M.s -type float3 1 1 1;
scale -r -p 0 0 0 6 6 6 LipRegion_M.cv[0:7];
xform -ws -t 0 $pos[1] $pos[2] LipRegionOffset_M;
move -r 0 0 ($scale/25.0) LipRegion_M.cv[0:99];

$posA=`xform -q -ws -t LipRegion_MShape.cv[1]`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
xform -ws -t $posA[0] $posB[1] $posA[2] LipRegion_MShape.cv[1];
$posA=`xform -q -ws -t LipRegion_MShape.cv[2]`;
xform -ws -t $posA[0] $posB[1] $posA[2] LipRegion_MShape.cv[2];
xform -ws -t ($posA[0]*-1) $posB[1] $posA[2] LipRegion_MShape.cv[0];

$posA=`xform -q -ws -t LipRegion_MShape.cv[5]`;
$posB=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
xform -ws -t $posA[0] $posB[1] $posA[2] LipRegion_MShape.cv[5];
$posA=`xform -q -ws -t LipRegion_MShape.cv[4]`;
xform -ws -t $posA[0] $posB[1] $posA[2] LipRegion_MShape.cv[4];
xform -ws -t ($posA[0]*-1) $posB[1] $posA[2] LipRegion_MShape.cv[6];

$posA=`xform -q -ws -t LipRegion_MShape.cv[3]`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[99]`;
xform -ws -t ($posB[0]*1.2) $posB[1] $posA[2] LipRegion_MShape.cv[3];

$posA=`xform -q -ws -t LipRegion_MShape.cv[7]`;
$posB=`xform -q -ws -t upperLipOuterCurveLeft.cv[99]`;
xform -ws -t ($posB[0]*1.2) $posB[1] $posA[2] LipRegion_MShape.cv[7];

createNode -n asTempNodes transform;
createNode -n asTempMotionPath motionPath;
createNode -n asTempTransform transform;
connectAttr -f asTempMotionPath.allCoordinates asTempTransform.translate;
connectAttr -f asTempMotionPath.r asTempTransform.r;
setAttr asTempMotionPath.fractionMode 0;
setAttr asTempMotionPath.worldUpType 0;
setAttr asTempMotionPath.frontAxis 0;
setAttr asTempMotionPath.upAxis 1;
setAttr asTempMotionPath.inverseFront 1;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$leftSuffix="";$side="_R";}
	else {$leftSuffix="Left";$side="_L";setAttr asTempMotionPath.inverseFront 0;}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		//Create BuildCurves (based on ordered selection)
		for ($a=0;$a<3;$a++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";

			$curveCmd="curve -d 1 ";
	//		eval ("select "+`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`);
			eval ("select "+`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve"+$leftSuffix)`);

			$loopVtxs=`ls -sl -fl`;
			clear $completedVtxs;
	//		$tempString[0]=`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`;
			$tempString[0]=`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve"+$leftSuffix)`;
			$tempString=`stringToStringArray $tempString[0] " "`;
			select $tempString[0];
			for ($i=0;$i<size($loopVtxs);$i++)
				{
				$tempString=`ls -sl -fl`;
				if (size($tempString)==0)
					continue;
				$completedVtxs=`stringArrayCatenate $completedVtxs $tempString`;
				$pos=`xform -q -ws -t $tempString`;
				$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
				ConvertSelectionToEdges;
				ConvertSelectionToVertices;
				$tempString=`ls -sl -fl`;
				for ($y=0;$y<size($tempString);$y++)
					if (!`stringArrayCount $tempString[$y] $loopVtxs`)
						select -d $tempString[$y];
				select -d $completedVtxs;
				}
			$tempString[0]=`eval ($curveCmd)`;
			rename $tempString[0] ($upperLower+"Lip"+$inOutMain+"BuildCurve"+$leftSuffix);
			parent ($upperLower+"Lip"+$inOutMain+"BuildCurve"+$leftSuffix) LipConstruction;
			}
		$mainNumCv=`getAttr ($upperLower+"LipMainBuildCurve"+$leftSuffix+".spans")`+1;

		//Create Joints
		for ($i=0;$i<$mainNumCv;$i++)
			{
			select LipJoints_M;
			joint -n ($upperLower+"LipJoint"+$i+$side);
			setAttr ($upperLower+"LipJoint"+$i+$side+".segmentScaleCompensate") 0;
			setAttr ($upperLower+"LipJoint"+$i+$side+".radius") 0.1;
			$pos=`xform -q -ws -t ($upperLower+ "LipMainBuildCurve"+$leftSuffix+".cv["+$i+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipJoint"+$i+$side);
			}
		//orient Y axis to topology, for localized lip-rolling
		duplicate -n ($upperLower+"LipMainReBuiltCurve"+$leftSuffix) ($upperLower+"LipMainCurve"+$leftSuffix);
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 1 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 ($upperLower+"LipMainReBuiltCurve"+$leftSuffix);
		parent ($upperLower+"LipMainReBuiltCurve"+$leftSuffix) asTempNodes;
		connectAttr -f ($upperLower+"LipMainReBuiltCurve"+$leftSuffix+".worldSpace[0]") asTempMotionPath.geometryPath;
		for ($i=0;$i<$mainNumCv;$i++)
			{
			if ($i==0 || $i==($mainNumCv-1)) $uInt=$i;//$i then skip 1 and 2nd last
			else $uInt=$i-1;
			setAttr asTempMotionPath.uValue $uInt;//actually should be $i then skip 1 and 2nd last
			setAttr ($upperLower+"LipJoint"+$i+$side+".ry") (`getAttr asTempTransform.ry`);
			}
		}
	}
delete asTempMotionPath asTempTransform asTempNodes;

//_M
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	rename ($upperLower+"LipJoint0_R") ($upperLower+"LipJoint0_M");
	delete ($upperLower+"LipJoint0_L");
	}

//remove first and last lower-joints, as they overlap upper-joints
select ("lowerLipJoint"+($mainNumCv-1)+"_R") ("lowerLipJoint"+($mainNumCv-1)+"_L");
delete ("lowerLipJoint"+($mainNumCv-1)+"_R") ("lowerLipJoint"+($mainNumCv-1)+"_L");

//lipSlideSurface, no longer use for constraint, just used for ctrl-align via `FaceControlOrient`
$jawPos=`xform -q -ws -t Jaw`;
$jawPivotPos=`xform -q -ws -t JawPivot`;
//$eyeCnrPos=`xform -q -ws -t upperEyeLidMainCurve.cv[99]`;
$posA=`xform -q -ws -t FitEyeBall`;
$posB=`xform -q -ws -t upperEyeLidMainCurve.cv[99]`;
$eyeCnrPos={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
$midLipPos=`xform -q -ws -t upperLipMainCurve.cv[0]`;
$noseUnderPos=`xform -q -ws -t NoseUnder`;

nurbsPlane -n lipSlideSurface -p 0 0 0 -ax 0 0 1 -w 1 -lr 1 -d 3 -u 2 -v 4 -ch 0;
rotate -r -p 0 0 0 -os 0 0 -90 lipSlideSurface.cv[0:99][0:99];
$s=($noseUnderPos[1]-$midLipPos[1])*2;
scale -r $s $s $s lipSlideSurface.cv[0:99][0:99];
move -r $midLipPos[0] $midLipPos[1] $midLipPos[2] lipSlideSurface.cv[0:99][0:99];

//scaleUp Row 0
$pos=`xform -q -ws -t lipSlideSurface.cv[0][0]`;
$s=($eyeCnrPos[1]-$midLipPos[1])/($pos[1]-$midLipPos[1]);
scale -r -p $midLipPos[0] $midLipPos[1] $midLipPos[2] 1 $s 1 lipSlideSurface.cv[0:4][0];
//and partially Row 1 & 2
scale -r -p $midLipPos[0] $midLipPos[1] $midLipPos[2] 1 ($s*0.85) 1 lipSlideSurface.cv[0:4][1];
//scale -r -p $midLipPos[0] $midLipPos[1] $midLipPos[2] 1 ($s*0.5) 1 lipSlideSurface.cv[0:4][2];

//pull out Row 0
xform -ws -t $eyeCnrPos[0] $eyeCnrPos[1] $eyeCnrPos[2] lipSlideSurface.cv[0][0];
for ($u=1;$u<5;$u++)
	{
	$pos=`xform -q -ws -t ("lipSlideSurface.cv["+$u+"][0]")`;
	xform -ws -t $eyeCnrPos[0] $pos[1] $eyeCnrPos[2] lipSlideSurface.cv[$u][0];
	}

//extra pull cv[2][0]
$posA=`xform -q -ws -t lipSlideSurface.cv[2][0]`;
$pos={(($jawPivotPos[0]+$posA[0])/2.0), $midLipPos[1], (($jawPivotPos[2]+$posA[2])/2.0)};
xform -ws -t $pos[0] $pos[1] $pos[2] lipSlideSurface.cv[2][0];
//and some for neighbours 1-0 & 3.0
$posA=`xform -q -ws -t lipSlideSurface.cv[1][0]`;
$posB=`xform -q -ws -t lipSlideSurface.cv[3][0]`;
xform -ws -t (($pos[0]+$posA[0])/2.0) $posA[1] (($pos[2]+$posA[2])/2.0) lipSlideSurface.cv[1][0];
xform -ws -t (($pos[0]+$posB[0])/2.0) $posB[1] (($pos[2]+$posB[2])/2.0) lipSlideSurface.cv[3][0];

//use motionPath to sample some points
createNode -n asTempMotionPath motionPath;
createNode -n asTempTransform transform;
connectAttr -f upperLipMainBuildCurve.worldSpace[0] asTempMotionPath.geometryPath;
connectAttr -f asTempMotionPath.allCoordinates asTempTransform.translate;
setAttr asTempMotionPath.fractionMode 1;
setAttr asTempMotionPath.uValue 0.25;
$posA=`xform -q -ws -t asTempTransform`;
for ($u=0;$u<5;$u++)
	{
	$pos=`xform -q -ws -t ("lipSlideSurface.cv["+$u+"][2]")`;
	xform -ws -t $posA[0] $pos[1] $posA[2] lipSlideSurface.cv[$u][2];
	}
setAttr asTempMotionPath.uValue 0.75;
$posA=`xform -q -ws -t asTempTransform`;
for ($u=0;$u<5;$u++)
	{
	$pos=`xform -q -ws -t ("lipSlideSurface.cv["+$u+"][1]")`;
	xform -ws -t $posA[0] $pos[1] $posA[2] lipSlideSurface.cv[$u][1];
	}
delete asTempTransform asTempMotionPath;

//Make Left side match Right
for ($u=0;$u<5;$u++)
	for ($v=0;$v<3;$v++)
		{
		$pos=`xform -q -ws -t ("lipSlideSurface.cv["+$u+"]["+$v+"]")`;
		xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ("lipSlideSurface.cv["+$u+"]["+(6-$v)+"]");
		}

//Scale out midway point to `meet` corner of LipMainCurve
createNode -n asTempTransform transform;
$posA=`xform -q -ws -t upperLipMainCurve.cv[99]`;
xform -ws -t $posA[0] $posA[1] $posA[2] asTempTransform;
$prevDist=99;
for ($i=0;$i<99;$i++)
	{
	geometryConstraint lipSlideSurface asTempTransform;
	$posB=`xform -q -ws -t asTempTransform`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist>$prevDist)
		break;
	$prevDist=$dist;
	delete asTempTransform_geometryConstraint1;
	xform -ws -t $posA[0] $posA[1] $posA[2] asTempTransform;
	select -r lipSlideSurface.cv[0][1] lipSlideSurface.cv[0][5] lipSlideSurface.cv[1][1]
		lipSlideSurface.cv[1][5] lipSlideSurface.cv[2][1] lipSlideSurface.cv[2][5] lipSlideSurface.cv[3][1]
		lipSlideSurface.cv[3][5] lipSlideSurface.cv[4][1] lipSlideSurface.cv[4][5];
	scale -r -p 0 0 0 1.05 1 1;
	}

//could have overshot the end-row
$posA=`xform -q -ws -t lipSlideSurface.cv[2][1]`;
$posB=`xform -q -ws -t lipSlideSurface.cv[2][0]`;
if ($posA[0]<$posB[0])//overshot
	{
	select lipSlideSurface.cv[0:4][0] lipSlideSurface.cv[0:4][6];
	scale -r -p 0 0 0 (($posA[0]/$posB[0])*1.2) 1 1 ;
	}

delete asTempTransform;

parent lipSlideSurface LipSlider;
select FaceJoint_M lipSlideSurface;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] lipSlideSurfaceSC;
setAttr lipSlideSurface.v 0;

//custom FaceControlOrient object for lip
rename FaceControlOrient FaceControlSuspended;
duplicate -n FaceControlOrient lipSlideSurface;
sets -e -forceElement asRedSG FaceControlOrient;
parent FaceControlOrient FaceBuildInProgressHidden;

//RibbonCurve
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$curveCmd="curve -d 3 -n "+$upperLower+"LipRibbonCurve";
	$mainNumCv=`getAttr ($upperLower+"LipMainBuildCurve.spans")`+1;
	$jointNr=$mainNumCv-1;
	$jointSide="_L";
	for ($i=0;$i<($mainNumCv*2)-1;$i++)
		{
		if ($jointNr==0) $jointSide="_M";
		$joint=$upperLower+"LipJoint"+$jointNr+$jointSide;
		if ($jointNr==0) $jointSide="_R";
		if (!`objExists $joint`)//lower dont have 1st&last use upper
			$joint="upperLipJoint"+`getAttr upperLipMainBuildCurve.spans`+$jointSide;
		$pos=`xform -q -ws -t $joint`;
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		if ($i<$mainNumCv-1)
			$jointNr--;
		else
			$jointNr++;
		}
	eval ($curveCmd);
	$tempString=`listRelatives -s ($upperLower+"LipRibbonCurve")`;
	rename $tempString[0] ($upperLower+"LipRibbonCurveShape");
	reverseCurve -ch 0 -rpo 1 ($upperLower+"LipRibbonCurve");

	//bind RibbonCurve
	$tempString=`listRelatives -c LipJoints_M`;
	select `ls ($upperLower+"LipJoint*_*")` ($upperLower+"LipRibbonCurve");
	if ($upperLower=="lower")//lower dont have 1st&last use upper
		select -add ("upperLipJoint"+`getAttr upperLipMainBuildCurve.spans`+"_R") ("upperLipJoint"+`getAttr upperLipMainBuildCurve.spans`+"_L");
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($upperLower+"LipRibbonCurveSC");

	//LipRibbonCurveShaped (topology matcher RibbonCurveS, but shaped to mouth
	duplicate -n ($upperLower+"LipMainBuildCurveShaped") ($upperLower+"LipMainBuildCurve");
	duplicate -n ($upperLower+"LipMainBuildCurveShapedLeft") ($upperLower+"LipMainBuildCurveLeft");
	attachCurve -ch 0 -rpo 1 -kmk 1 -m 0 -bb 0.5 -bki 0 -p 0.1 ($upperLower+"LipMainBuildCurveShaped") ($upperLower+"LipMainBuildCurveShapedLeft");
	rename ($upperLower+"LipMainBuildCurveShaped") ($upperLower+"LipRibbonCurveShaped");
	delete ($upperLower+"LipMainBuildCurveShapedLeft");
	parent -w ($upperLower+"LipRibbonCurveShaped");
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 1 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 ($upperLower+"LipRibbonCurveShaped");
	rebuildCurve -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 0 -d 3 -tol 0.01 ($upperLower+"LipRibbonCurveShaped");
	}

//Ribbon
$posA=`xform -q -ws -t upperLipMainCurve.cv[0]`;
$posB=`xform -q -ws -t upperLipMainCurve.cv[99]`;
curve -n tempLoftProfile -d 1 -p  $posB[0] $posA[1] $posB[2] -p 0 $posA[1] $posA[2] -p ($posB[0]*-1) $posA[1] $posB[2] -k 0 -k 1 -k 2;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 5 -d 3 -tol 0.01 tempLoftProfile;
$dist=$posA[2]-$posB[2];
scale -r -p 0cm $posB[1] $posB[2] 1.06 1 1.06 tempLoftProfile.cv[1] tempLoftProfile.cv[6];
scale -r -p 0cm $posB[1] $posB[2] 1.2 1 1.2 tempLoftProfile.cv[2] tempLoftProfile.cv[5];
move -r -os -wd 0 0 ($dist/20.0) tempLoftProfile.cv[1] tempLoftProfile.cv[6];
move -r -os -wd 0 0 ($dist/4.0)  tempLoftProfile.cv[2] tempLoftProfile.cv[5];

extrude -n upperLipRibbon -ch 0 -rn false -po 0 -et 0 -upn 0 -d 0 1 0 -length ($faceFitScale/200.0) -rotation 0 -scale 1 -dl 3 "tempLoftProfile" ;
delete tempLoftProfile;

if ($lipCtrls!=12)
	rebuildSurface -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su $ribbonSpansU -du 3 -sv 0 -dv 1 -tol 0.01 -fr 0 -dir 2 "upperLipRibbon";

duplicate -n lowerLipRibbon upperLipRibbon;
move -r -os -wd 0 ($faceFitScale/-200.0) 0 lowerLipRibbon.cv[0:99][0:99];

$pos=`xform -q -ws -t LipJoints_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] LipFollicles;
//parentConstraint -mo $headJoint LipFollicles;
//scaleConstraint $headJoint LipFollicles;

createNode -n tempNearestPointOnCurve nearestPointOnCurve;

//Sticky Lip
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	createNode -n ("PlaceHolderStickyLip"+$side) transform;
	addAttr -k 1 -ln sticky -at double -min 0 -max 10 -dv 0 ("PlaceHolderStickyLip"+$side);
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$mainNumCv=`getAttr ($upperLower+"LipMainBuildCurve.spans")`+1;
	connectAttr -f ($upperLower+"LipRibbonCurveShapedrebuiltCurve1.worldSpace[0]") tempNearestPointOnCurve.inputCurve;

	if (`asIsMayaLT`)
		continue;

	for ($b=1;$b>-2;$b=$b-2)
		{
		$cvNr=(`getAttr ($upperLower+"LipRibbonCurveShaped.spans")`+2)/2;
		for ($i=0;$i<$mainNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;
			if ($upperLower=="lower" && $i==($mainNumCv-1))//no need for lower at the same spot (start & end)
				continue;

			if ($side=="_R") $cvNr--;
			if ($side=="_L") $cvNr++;

			$tempString[0]=`createNode follicle`;
			$tempString=`listRelatives -p $tempString[0]`;
			rename $tempString[0] ($upperLower+"follicle"+$i+$side);
			parent ($upperLower+"follicle"+$i+$side) LipFollicles;
			setAttr ($upperLower+"follicle"+$i+$side+".collide") 0;
			connectAttr ($upperLower+"LipRibbon.local") ($upperLower+"follicle"+$i+$side+".inputSurface");
			connectAttr -f ("LipFollicles.worldInverseMatrix[0]") ($upperLower+"follicle"+$i+$side+".inputWorldMatrix");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outTranslate") ($upperLower+"follicle"+$i+$side+".t");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outRotate") ($upperLower+"follicle"+$i+$side+".r");

			//determine U value based on un-eveness of distribution of edge-rows in the models lips
			$pos=`xform -q -ws -t ($upperLower+"LipRibbonCurveShaped.cv["+$cvNr+"]")`;
			setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
			$u=`getAttr tempNearestPointOnCurve.result.parameter`;
//			$u=0.5+($u*-$b);
//			$u=0.5+((1.0/(($mainNumCv-1)*2))*$i*-$b);
//			$u=0.5+((1.0/(($mainNumCv-1)*2))*$i*-$b);
			setAttr ($upperLower+"follicle"+$i+$side+".parameterU") $u;
			setAttr ($upperLower+"follicle"+$i+$side+".parameterV") 0.5;

			//add offset to place joints at actual lip instead if evened lip
			createNode -n ($upperLower+"LipPMA"+$i+$side) plusMinusAverage;
			connectAttr ($upperLower+"follicle"+$i+$side+".t") ($upperLower+"LipPMA"+$i+$side+".input3D[0]");
			$posA=`getAttr ($upperLower+"follicle"+$i+$side+".t")`;
			$posB=`getAttr ($upperLower+"LipJoint"+$i+$side+".t")`;
			setAttr ($upperLower+"LipPMA"+$i+$side+".input3D[1]") -type float3 ($posB[0]-$posA[0]) ($posB[1]-$posA[1]) ($posB[2]-$posA[2]);
//			connectAttr ($upperLower+"LipPMA"+$i+$side+".output3D") ($upperLower+"LipJoint"+$i+$side+".t");

			createNode -n ($upperLower+"LipBC"+$i+$side) blendColors;
			setAttr ($upperLower+"LipBC"+$i+$side+".blender") 1;
			connectAttr ($upperLower+"LipPMA"+$i+$side+".output3D") ($upperLower+"LipBC"+$i+$side+".color1");
			connectAttr ($upperLower+"LipPMA"+$i+$side+".output3D") ($upperLower+"LipBC"+$i+$side+".color2");//next override this for Lower`s that are missing Upper`s

			if ($upperLower=="lower")
				{
				if (`objExists ("upperLipBC"+$i+$side)`)
					connectAttr -f ("lowerLipPMA"+$i+$side+".output3D") ("upperLipBC"+$i+$side+".color2");
				if (`objExists ("upperLipPMA"+$i+$side)`)
					connectAttr -f ("upperLipPMA"+$i+$side+".output3D") ("lowerLipBC"+$i+$side+".color2");
				}

			connectAttr ($upperLower+"LipBC"+$i+$side+".output") ($upperLower+"LipJoint"+$i+$side+".t");

			createNode -n ($upperLower+"LipSR"+$i+$side) setRange;
			setAttr ($upperLower+"LipSR"+$i+$side+".min") -type float3 1 1 0;
			setAttr ($upperLower+"LipSR"+$i+$side+".max") -type float3 0.5 0.5 0;
			setAttr ($upperLower+"LipSR"+$i+$side+".oldMin") -type float3 (($u*8)-0) (10-(($u*8)+2)) 0;
			setAttr ($upperLower+"LipSR"+$i+$side+".oldMax") -type float3 (($u*8)+2) (10-(($u*8)-0)) 0;

//			connectAttr ("bwStickyLip_R_translateX.output") ($upperLower+"LipSR"+$i+$side+".valueX");
//			connectAttr ("bwStickyLip_L_translateX.output") ($upperLower+"LipSR"+$i+$side+".valueY");
			connectAttr PlaceHolderStickyLip_R.sticky ($upperLower+"LipSR"+$i+$side+".valueX");	
			connectAttr PlaceHolderStickyLip_L.sticky ($upperLower+"LipSR"+$i+$side+".valueY");	

			createNode -n ($upperLower+"LipMDL"+$i+$side) multDoubleLinear;//mixing R/L
			connectAttr ($upperLower+"LipSR"+$i+$side+".outValueX") ($upperLower+"LipMDL"+$i+$side+".input1");
			connectAttr ($upperLower+"LipSR"+$i+$side+".outValueY") ($upperLower+"LipMDL"+$i+$side+".input2");

			createNode -n ($upperLower+"LipClamp"+$i+$side) clamp;
			setAttr ($upperLower+"LipClamp"+$i+$side+".minR") 0.5;
			setAttr ($upperLower+"LipClamp"+$i+$side+".maxR") 1.0;
			connectAttr ($upperLower+"LipMDL"+$i+$side+".output") ($upperLower+"LipClamp"+$i+$side+".inputR") ;
			connectAttr ($upperLower+"LipClamp"+$i+$side+".outputR") ($upperLower+"LipBC"+$i+$side+".blender") ;
			}
		}
	}

//upperSpans could be higher then lowerSpans, so run over again, and `map` them to the `highest` lower
$mainNumCv=`getAttr upperLipMainBuildCurve.spans`+1;
$cvNr=`getAttr lowerLipMainBuildCurve.spans`-1;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";
	for ($i=1;$i<$mainNumCv;$i++)
		{
		if (!`objExists ("lowerLipJoint"+$i+$side)`)
			connectAttr -f ("lowerLipPMA"+$cvNr+$side+".output3D") ("upperLipBC"+$i+$side+".color2");
		}
	}

//Bind
$tempString=`listRelatives -ad -type joint FaceJoint_M`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Lip*"` && $tempString[$i]!="MultiSkinClustersFaceLipJoint_M")
		select -add $tempString[$i];
$tempString=`ls -sl`;
select -cl;
//faster to add `locked` then unlock
$cmd="skinCluster -e  -dr 4 -lw true -wt 0 ";
for ($i=0;$i<size($tempString);$i++)
	$cmd+=" -ai "+$tempString[$i];
$cmd+=" "+$skinCluster;
eval $cmd;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".lockInfluenceWeights") 0;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$mainNumCv=`getAttr ($upperLower+"LipMainBuildCurve.spans")`+1;

	for ($b=1;$b>-2;$b=$b-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		//Hard weights
		for ($a=0;$a<3;$a++)
			{
			if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";
	
			for ($i=0;$i<$mainNumCv;$i++)
				{
				if ($b==1) $side="_R";
				else $side="_L";
				if ($i==0) $side="_M";
				if ($i==0 && $b==-1) continue;

				if ($upperLower=="lower" && $i==($mainNumCv-1))//no need for lower at the same spot (start & end)
					continue;

				$pos=`xform -q -ws -t ($upperLower+"Lip"+$inOutMain+"BuildCurve.cv["+$i+"]")`;
				if ($side=="_L" && `objExists ($upperLower+"Lip"+$inOutMain+"BuildCurveLeft.cv["+$i+"]")`)
					{
					$pos=`xform -q -ws -t ($upperLower+"Lip"+$inOutMain+"BuildCurveLeft.cv["+$i+"]")`;
					$pos[0]=$pos[0]*-1;
					}
				setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
				select ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
				catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
	
				if ($inOutMain=="Inner") $innerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Outer") $outerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Main") $mainVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				}
			}
	
		//shortestEdgePath vtxs
		for ($i=0;$i<$mainNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;
			if ($upperLower=="lower" && $i==($mainNumCv-1))//no need for lower at the same spot (start & end)
				continue;

			select $geometry;
//			select `polySelect -q -asSelectString -shortestEdgePath $outerVtxNr[$i] $mainVtxNr[$i]`;//outer -> main
			asSelectLeastEdgesPath $geometry $outerVtxNr[$i] $mainVtxNr[$i];
			ConvertSelectionToVertices;
			if ($i==$mainNumCv-1 && $b==1) $rightCnrVtxs=`ls -sl`;
			if ($i==$mainNumCv-1 && $b==-1) $leftCnrVtxs=`ls -sl`;
			catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
			select $geometry;
//			select `polySelect -q -asSelectString -shortestEdgePath $innerVtxNr[$i] $mainVtxNr[$i]`;//inner -> main
			asSelectLeastEdgesPath $geometry $innerVtxNr[$i] $mainVtxNr[$i];
			ConvertSelectionToVertices;
			$tempString=`ls -sl`;
			if ($i==$mainNumCv-1 && $b==1) $rightCnrVtxs=`stringArrayCatenate $rightCnrVtxs $tempString`;
			if ($i==$mainNumCv-1 && $b==-1) $leftCnrVtxs=`stringArrayCatenate $leftCnrVtxs $tempString`;
			catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
			}
		}
	}
delete closestSampler;

//hammer any leftovers
select -cl;
for ($i=0;$i<size($lipArea);$i++)
	{
	if (`skinPercent -transform $headJoint -ignoreBelow 1 -query -value $skinCluster $lipArea[$i]`)
		select -add $lipArea[$i];
	}
if (size(`ls -sl`))
//	weightHammerVerts;
asWeightHammerVertsMS 5 $skinCluster;

//if (!$nonSymmetrical)
//	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;


//create clusters & pingPongs
createNode -n TempPos transform;
createNode -n tempClosestPointOnSurface closestPointOnSurface;
createNode -n tempClosestPointOnSurfaceUniform closestPointOnSurface;
createNode -n asTempMotionPath motionPath;
createNode -n asTempTransform transform;
connectAttr -f asTempMotionPath.r asTempTransform.r;
setAttr asTempMotionPath.frontAxis 0;
setAttr asTempMotionPath.upAxis 1;
connectAttr asTempMotionPath.ro asTempTransform.ro;
setAttr asTempMotionPath.ro 1;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	extrude -n ($upperLower+"LipRibbonCurveExtruded") -ch 0 -rn false -po 0 -et 0 -upn 1 -length ($scale/100) -rotation 0 -scale 1 -dl 3 ($upperLower+"LipRibbonCurve");
	rebuildSurface -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.01 -fr 0  -dir 0 ($upperLower+"LipRibbonCurveExtruded");

	connectAttr -f ($upperLower+"LipRibbon.worldSpace[0]") tempClosestPointOnSurfaceUniform.inputSurface;
	connectAttr -f ($upperLower+"LipRibbonCurveExtruded.worldSpace[0]") tempClosestPointOnSurface.inputSurface;
	$uInt=3;
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$leftSuffix="";$uInt=($ribbonSpansU/2)+2;}
		else {$side="_L";$leftSuffix="Left";$uInt=($ribbonSpansU/2)+1;}


		$step=1.0/(($end*2)+1);
//		$step+=$step*0.5;//1/2 step offset start to avoid double distance btw A L&R
		for ($i=0;$i<$end+1;$i++)
			{
			if ($side=="_R") $uInt--;
			if ($side=="_L") $uInt++;
			$letter=`asNrToLetter ($i+1)`;
			$ctrl=$upperLower+"Lip"+$letter;
			if ($i==$end && $upperLower=="upper") $ctrl="cornerLip";
			if ($i==$end && $upperLower=="lower") continue;
			$type=1;

			//attach to RibbonCurve
//			$parameter=0.5+(($step*$i)+($step*0.5))*-$b;

			//find U value nearest the CV`s that are controlled
			$pos=`xform -q -ws -t ($upperLower+"LipRibbon.cv["+$uInt+"][1]")`;
			setAttr tempClosestPointOnSurface.inPosition -type float3 $pos[0] $pos[1] $pos[2];
			setAttr tempClosestPointOnSurfaceUniform.inPosition -type float3 $pos[0] $pos[1] $pos[2];
			$parameter=`getAttr tempClosestPointOnSurface.result.parameterU`;
			$parameterOnUniform=`getAttr tempClosestPointOnSurfaceUniform.result.parameterU`;
//print ("P:"+$parameter+" : Pu:"+$parameterOnUniform+$ctrl+$side+"\n");

			createNode -n ($ctrl+"POCI"+$side) pointOnCurveInfo;
//			connectAttr -f ($upperLower+"LipRibbonCurveShapedrebuiltCurve1"+".worldSpace[0]") ($ctrl+"POCI"+$side+".inputCurve");
			connectAttr -f ($upperLower+"LipRibbonCurveShapedrebuiltCurve1"+".worldSpace[0]") ($ctrl+"POCI"+$side+".inputCurve");
			setAttr ($ctrl+"POCI"+$side+".turnOnPercentage") 1;
			setAttr ($ctrl+"POCI"+$side+".parameter") $parameterOnUniform;

			$pos=`getAttr ($ctrl+"POCI"+$side+".position")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
			$dist=$ctrlScale*0.2*$upperLowerFactor;
			if ($i==$end-1) $dist=$dist/2.0;
			if ($i==$end) $dist=0;
			//Creating at the `Offset-location` to get correct `projected`, then moving OffsetNode down, then shape node back up
			move -r -os -wd 0 $dist 0 TempPos;

			asCreatePP TempPos $ctrl $side $type 1 0 1;
			move -r -os -wd 0 ($dist*-1) 0 ($ctrl+"Offset"+$side) ($ctrl+"JointOffset"+$side);

			setAttr ($ctrl+"Joint"+$side+".radius") 0.25;
			addAttr -k 0 -ln parameterOnUniform -at double -dv $parameterOnUniform ($ctrl+$side);

			createNode -n ($ctrl+"Loc"+$side) -p LipRibbonLocs transform;
			connectAttr ($ctrl+"POCI"+$side+".position") ($ctrl+"Loc"+$side+".t");

			//swap connection from RibbonCurveShaped to RibbonCurve
			connectAttr -f ($upperLower+"LipRibbonCurve"+".worldSpace[0]") ($ctrl+"POCI"+$side+".inputCurve");
			//and swap $parameter to the nonUniformSampled
			setAttr ($ctrl+"POCI"+$side+".parameter") $parameter;

			if ($opm)
				{
				asParentConstraint ($ctrl+"Loc"+$side) ($ctrl+"Attach"+$side) "-includePickMatrix -mo"; 
				setAttr ($ctrl+"AttachPM"+$side+".useRotate") 0;
				setAttr ($ctrl+"AttachPM"+$side+".useScale") 0;
				setAttr ($ctrl+"AttachPM"+$side+".useShear") 0;
				if ($multiSkinClusters)
					{
					$tempString=`listConnections -p 1 ($ctrl+"AttachMM"+$side+".matrixIn[2]")`;
					$m=`getAttr $tempString[0]`;
					disconnectAttr $tempString[0] ($ctrl+"AttachMM"+$side+".matrixIn[2]");
					setAttr ($ctrl+"AttachMM"+$side+".matrixIn[2]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
					}
				}
			else
				pointConstraint -mo ($ctrl+"Loc"+$side) ($ctrl+"Attach"+$side);

			rename ($ctrl+"Joint"+$side) ($ctrl+"RibbonJoint"+$side);
			rename ($ctrl+"JointOffset"+$side) ($ctrl+"RibbonJointOffset"+$side);
			parent ($ctrl+"RibbonJointOffset"+$side) LipRibbonJoints;//joint not a direct-bind

			move -r -os -wd 0 $dist 0 ($ctrl+$side+".cv[0:99]");

			//bind CVs
			if ($i==0 && $side=="_R")
				{
				select ($upperLower+"LipRibbon") ($ctrl+"RibbonJoint"+$side);
				$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
				rename $tempString[0] ($upperLower+"LipRibbonSC");
				}
			else
				skinCluster -e  -dr 4 -lw false -wt 0 -ai ($ctrl+"RibbonJoint"+$side) ($upperLower+"LipRibbonSC");

			select -r ($upperLower+"LipRibbon.cv["+$uInt+"][0:1]");
			skinPercent -tv ($ctrl+"RibbonJoint"+$side) 1 ($upperLower+"LipRibbonSC");
			}
		}
	}

delete TempPos tempClosestPointOnSurface tempClosestPointOnSurfaceUniform asTempMotionPath asTempTransform;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	delete ($upperLower+"LipRibbonCurveExtruded");
	delete ($upperLower+"LipRibbonCurveShaped");
	delete ($upperLower+"LipRibbonCurveShapedrebuiltCurve1");
	parent ($upperLower+"LipRibbonCurve") ($upperLower+"LipRibbon") LipRibbon;
	}

//cornerLip also affects lowerLip
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$uInt=0;}
	else {$side="_L";$uInt=($end*2)+1;}

	skinCluster -e  -dr 4 -lw false -wt 0 -ai ("cornerLipRibbonJoint"+$side) lowerLipRibbonSC;
	select -r ("lowerLipRibbon.cv["+$uInt+"][0:1]");
	skinPercent -tv ("cornerLipRibbonJoint"+$side) 1 lowerLipRibbonSC;
	}

//Green Lip Controllers
//CreatePP
createNode -n TempPos transform;
for ($i=0;$i<8;$i++)
	{
	$upperLower="";
	$type=2;
	if ($i==0) {$side="_R";$alignTo="cornerLip"+$side;}
	if ($i==1) {$side="_L";$alignTo="cornerLip"+$side;}
	if ($i==2) {$side="_M";$upperLower="upper";$upperLowerFactor=1; $alignTo=$upperLower+"LipA_R";}
	if ($i==3) {$side="_M";$upperLower="lower";$upperLowerFactor=-1;$alignTo=$upperLower+"LipA_R";}
	if ($i==4) {$side="_R";$upperLower="upper";$upperLowerFactor=1; $alignTo=$upperLower+"LipA_R";$type=3;}
	if ($i==5) {$side="_R";$upperLower="lower";$upperLowerFactor=-1;$alignTo=$upperLower+"LipA_R";$type=3;}
	if ($i==6) {$side="_L";$upperLower="upper";$upperLowerFactor=1; $alignTo=$upperLower+"LipA_L";$type=3;}
	if ($i==7) {$side="_L";$upperLower="lower";$upperLowerFactor=-1;$alignTo=$upperLower+"LipA_L";$type=3;}
	if ($side=="_R") $b=1;else $b=-1;

	$ctrl=$upperLower+"Lip";
	$pos=`xform -q -ws -t $alignTo`;
	if ($side=="_M")
		$pos[0]=0;
	xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
	//Creating at the `Offset-location` to get correct `projected`, then moving OffsetNode down, then shape node back up
	if ($side=="_M")
		move -r -os -wd 0 ($ctrlScale*0.2*$upperLowerFactor) 0 TempPos;

	if ($i>3)
		{
		rebuildCurve -n asLipTempCurve -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 ($upperLower+"LipOuterBuildCurve");
		$pos=`xform -q -ws -t asLipTempCurve.cv[2]`;
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] TempPos;
		delete asLipTempCurve;
		}

	asCreatePP TempPos $ctrl $side $type 0 0 0; 
	if ($side=="_M")
		move -r -os -wd 0 ($ctrlScale*0.2*$upperLowerFactor*-1) 0 ($ctrl+"Offset"+$side);
	}
delete TempPos;

asFaceHalfMoonCurve upperLip_M 90;
asFaceHalfMoonCurve lowerLip_M -90;
asFaceHalfMoonCurve Lip_R 0;
asFaceHalfMoonCurve Lip_L 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	addAttr -k 1 -ln sticky -at double -min 0 -max 10 -dv 0 ("Lip"+$side);
	asEnsureOutputBlendWeighted ("Lip"+$side+".sticky");

	$tempString=`listConnections -s 0 -d 1 -p 1 ("PlaceHolderStickyLip"+$side+".sticky")`;
	for ($i=0;$i<size($tempString);$i++)
		connectAttr -f ("bwLip"+$side+"_sticky.output") $tempString[$i];
	delete ("PlaceHolderStickyLip"+$side);
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	move -r -os -wd 0 ($ctrlScale*0.2*$upperLowerFactor) 0 ($upperLower+"Lip_M.cv[0:99]");
	setToolTo $gMove;
	select ($upperLower+"Lip_M.cv[0:99]");
	$pos=`manipMoveContext -q -position "Move"`;
	scale -r -p $pos[0] $pos[1] $pos[2] 2 2 2 ($upperLower+"Lip_M.cv[0:99]");
//	asFacePlaceCtrlByProjection ($upperLower+"Lip_M");
	}

//lidFleshy joints
//setAttr LipRibbonFleshyJoints.s -type float3 $ctrlScale $ctrlScale $ctrlScale;
$tempString={"Lip_R","Lip_L","upperLip_M","lowerLip_M","upperLip_R","upperLip_L","lowerLip_R","lowerLip_L"};
for ($i=0;$i<size($tempString);$i++)
	{
	tokenize $tempString[$i] "_" $tempString2;
	$ctrl=$tempString2[0];
	$side="_"+$tempString2[1];
	$b=1;
	if ($side=="_R")
		$b=-1;

	select LipRibbonFleshyJoints;
	joint -n ($ctrl+"JointFleshy"+$side);
 
	createNode -n ($ctrl+"ConstrainedFleshy"+$side) -p LipFollowHeadConstrained transform;

	if ($opm)
		{
		createNode -n ($ctrl+"ConstrainedFleshyDM"+$side) decomposeMatrix;
//		connectAttr ($ctrl+$side+".worldMatrix") ($ctrl+"ConstrainedFleshyDM"+$side+".inputMatrix");
		createNode -n ($ctrl+"ConstrainedFleshyMM"+$side) multMatrix;
		connectAttr ($ctrl+$side+".worldMatrix") ($ctrl+"ConstrainedFleshyMM"+$side+".matrixIn[0]");
		connectAttr LipFollowHeadConstrained.worldInverseMatrix ($ctrl+"ConstrainedFleshyMM"+$side+".matrixIn[1]");
		connectAttr ($ctrl+"ConstrainedFleshyMM"+$side+".matrixSum") ($ctrl+"ConstrainedFleshyDM"+$side+".inputMatrix");

		connectAttr ($ctrl+"ConstrainedFleshyDM"+$side+".outputTranslate") ($ctrl+"ConstrainedFleshy"+$side+".t");

		if (!`objExists LipRegionDM_M`)
			{
			createNode -n LipRegionDM_M decomposeMatrix;
//			connectAttr LipRegion_M.worldMatrix LipRegionDM_M.inputMatrix;
			createNode -n LipRegionMM_M multMatrix;
			connectAttr LipRegion_M.worldMatrix LipRegionMM_M.matrixIn[0];
			connectAttr LipFollowHeadConstrained.worldInverseMatrix LipRegionMM_M.matrixIn[1];
			connectAttr LipRegionMM_M.matrixSum LipRegionDM_M.inputMatrix;
			}
		connectAttr LipRegionDM_M.outputRotate ($ctrl+"ConstrainedFleshy"+$side+".r");
		}
	else
		{
		pointConstraint ($ctrl+$side) ($ctrl+"ConstrainedFleshy"+$side);
		orientConstraint LipRegion_M ($ctrl+"ConstrainedFleshy"+$side);
		}
	connectAttr ($ctrl+"ConstrainedFleshy"+$side+".t") ($ctrl+"JointFleshy"+$side+".t");
	}
/*
//Joints for `scale-compansating` for mouth-narrow
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";
		select ($upperLower+"LipJointFleshy_M");
		joint -n ($upperLower+"LipJointFleshyNarrow"+$side);
//		setAttr ($upperLower+"LipJointFleshyNarrow"+$side+".tx") ($faceFitScale/-100.0*$b);
		setAttr ($upperLower+"LipJointFleshyNarrow"+$side+".tx") (0.05*$b);
		}
	}
*/

//via curve
createNode -n tempNearestPointOnCurve nearestPointOnCurve;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	addAttr -k 1 -ln fractionMode -at double -min 0 -max 10 -dv 10 ($upperLower+"Lip_M");
	asEnsureOutputBlendWeighted ($upperLower+"Lip_M.fractionMode");
	asUnitConvertAndReverse ($upperLower+"LipFractionMode_M") ("bw"+$upperLower+"Lip_M_fractionMode.output");

	//dup for later use, before adding history
	duplicate -n ($upperLower+"LipRibbonCurveFleshy") ($upperLower+"LipRibbonCurve");
	parent ($upperLower+"LipRibbonCurveFleshy") LipRibbonFleshy;
	$tempString=`listRelatives -s ($upperLower+"LipRibbonCurveFleshy")`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.01 ($upperLower+"LipRibbonCurveFleshy");
/*
	//update position of mid-lip ctrls to cv2
	$pos=`xform -q -ws -t ($upperLower+"LipRibbonCurveFleshy.cv[2]")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipOffset_R");
	$pos=`xform -q -ws -t ($upperLower+"LipRibbonCurveFleshy.cv[4]")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipOffset_L");
*/
//	select LipJointFleshy_R LipJointFleshy_L ($upperLower+"LipJointFleshy_M") ($upperLower+"LipRibbonCurveFleshy");
	select LipJointFleshy_R LipJointFleshy_L ($upperLower+"LipJointFleshy_R") ($upperLower+"LipJointFleshy_L") ($upperLower+"LipRibbonCurveFleshy");
	$tempString=`newSkinCluster "-toSelectedBones -mi 2 -dr 4 -rui false"`;
	rename $tempString[0] ($upperLower+"LipRibbonCurveFleshySC");
	setAttr ($upperLower+"LipRibbonCurveFleshySC.maintainMaxInfluences") 1;

	skinPercent -tv ($upperLower+"LipJointFleshy_R") 1 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[0:2]");
	skinPercent -tv ($upperLower+"LipJointFleshy_L") 1 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[4:6]");
	skinPercent -tv LipJointFleshy_R 1 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[0]");
	skinPercent -tv LipJointFleshy_R 0.670 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[1]");
	skinPercent -tv LipJointFleshy_R 0.100 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[2]");
//	skinPercent -tv ($upperLower+"LipJointFleshy_M") 1 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[3]");
	skinPercent -tv ($upperLower+"LipJointFleshy_R") 1.0 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[3]");
	skinPercent -tv ($upperLower+"LipJointFleshy_L") 0.5 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[3]");
	skinPercent -tv LipJointFleshy_L 0.100 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[4]");
	skinPercent -tv LipJointFleshy_L 0.670 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[5]");
	skinPercent -tv LipJointFleshy_L 1 ($upperLower+"LipRibbonCurveFleshySC") ($upperLower+"LipRibbonCurveFleshy.cv[6]");
	connectAttr -f ($upperLower+"LipRibbonCurveFleshy.worldSpace[0]") tempNearestPointOnCurve.inputCurve;

	//POCI FleshyCurve -> RibbonJointFleshy_R
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$leftSuffix="";$uInt=($ribbonSpansU/2)+2;}
		else {$side="_L";$leftSuffix="Left";$uInt=($ribbonSpansU/2)+1;}

		for ($i=0;$i<$end+1;$i++)
			{
			if ($side=="_R") $uInt--;
			if ($side=="_L") $uInt++;
			$letter=`asNrToLetter ($i+1)`;
			$ctrl=$upperLower+"Lip"+$letter;
			if ($i==$end && $upperLower=="upper") $ctrl="cornerLip";
			if ($i==$end && $upperLower=="lower") continue;

			if ($i==$end)
				{
				if ($side=="_R") $parameter=0;
				if ($side=="_L") $parameter=1;
				}
			else
				{
				$pos=`xform -q -ws -t ($upperLower+"Lip"+$letter+$side)`;
				setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
				$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
				}

			//motionPath instead of poci, to use the parametric option
			createNode -n ($ctrl+"FleshyFractionalBlendColors"+$side) blendColors;
			connectAttr ($upperLower+"LipFractionMode_MReverse.outputX") ($ctrl+"FleshyFractionalBlendColors"+$side+".blender");
			for ($a=1;$a<3;$a++)
				{
				createNode -n ($upperLower+"Lip"+$letter+"RibbonJointFleshy"+$a+$side) -p LipRibbonFleshy transform;
				createNode -n ($ctrl+"FleshyMotionPath"+$a+$side) motionPath;
				setAttr ($ctrl+"FleshyMotionPath"+$a+$side+".fractionMode") ($a-1);
				connectAttr -f ($upperLower+"LipRibbonCurveFleshy.worldSpace[0]") ($ctrl+"FleshyMotionPath"+$a+$side+".geometryPath");

//				setAttr ($ctrl+"FleshyMotionPath"+$a+$side+".uValue") `getAttr ($ctrl+"POCI"+$side+".parameter")`;//re-use $parameter
				setAttr ($ctrl+"FleshyMotionPath"+$a+$side+".uValue") $parameter;

				connectAttr ($ctrl+"FleshyMotionPath"+$a+$side+".allCoordinates") ($upperLower+"Lip"+$letter+"RibbonJointFleshy"+$a+$side+".t");
				// Fleshy + offset -> Offset
				createNode -n ($ctrl+"FleshyAddPMA"+$a+$side) plusMinusAverage;
				connectAttr ($ctrl+"FleshyMotionPath"+$a+$side+".allCoordinates") ($ctrl+"FleshyAddPMA"+$a+$side+".input3D[0]");
				$posA=`getAttr ($ctrl+"FleshyMotionPath"+$a+$side+".allCoordinates")`;
				$posB=`getAttr ($ctrl+"RibbonJointOffset"+$side+".t")`;
				setAttr ($ctrl+"FleshyAddPMA"+$a+$side+".input3D[1]") -type float3 ($posB[0]-$posA[0]) ($posB[1]-$posA[1]) ($posB[2]-$posA[2]);
				connectAttr ($ctrl+"FleshyAddPMA"+$a+$side+".output3D") ($ctrl+"FleshyFractionalBlendColors"+$side+".color"+$a);
				}
			connectAttr ($ctrl+"FleshyFractionalBlendColors"+$side+".output") ($ctrl+"RibbonJointOffset"+$side+".t");
			}
		}
	}

delete tempNearestPointOnCurve;

//LipScale (and rotate)
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$mainNumCv=`getAttr ($upperLower+"LipMainBuildCurve.spans")`+1;

	//multMatrix for scale
	createNode -n ($upperLower+"LipMM_M") multMatrix;
	createNode -n ($upperLower+"LipDM_M") decomposeMatrix;
	connectAttr ($upperLower+"LipMM_M.matrixSum") ($upperLower+"LipDM_M.inputMatrix");
	connectAttr ($upperLower+"Lip_M.matrix") ($upperLower+"LipMM_M.matrixIn[0]");
	connectAttr ("SDK"+$upperLower+"Lip_M.matrix") ($upperLower+"LipMM_M.matrixIn[1]");
	if ($upperLower=="upper")
		{
		connectAttr LipRegion_M.matrix ($upperLower+"LipMM_M.matrixIn[2]");
		connectAttr SDKLipRegion_M.matrix ($upperLower+"LipMM_M.matrixIn[3]");
		}

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

		for ($i=0;$i<$mainNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;
			if ($upperLower=="lower" && $i==($mainNumCv-1))//no need for lower at the same spot (start & end)
				continue;

			$jointParameter=`getAttr ($upperLower+"follicle"+$i+$side+".parameterU")`;
			$minDist1=$minDist2=999;
			for ($y=0;$y<($lipCtrls/2)+2;$y++)
				{
				if ($y==0) $ctrl="cornerLip_L";
				if ($y>0) $ctrl=$upperLower+"Lip"+`asNrToLetter (($lipCtrls/4)-$y+1)`+"_L";
				if ($y>($lipCtrls/4)) $ctrl=$upperLower+"Lip"+`asNrToLetter ($y-($lipCtrls/4))`+"_R";
				if ($y==($lipCtrls/2)+1) $ctrl="cornerLip_R";
				$ctrlParameter=`getAttr ($ctrl+".parameterOnUniform")`;
				$dist=$jointParameter-$ctrlParameter;
				if ($dist>0 && $dist<$minDist1)
					{
					$minDist1=$dist;
					$closestCtrl1=$ctrl;
					}
				if ($dist<0 && ($dist*-1)<$minDist2)
					{
					$minDist2=($dist*-1);
					$closestCtrl2=$ctrl;
					}
				}

			//RX
			$blendWeighted=$upperLower+"LipBW"+$i+$side;
			createNode -n $blendWeighted blendWeighted;
			//standard Ctrl
			connectAttr ($closestCtrl1+".rx") ($blendWeighted+".input[0]");
			connectAttr ($closestCtrl2+".rx") ($blendWeighted+".input[1]");
			//sdk Ctrl
			connectAttr ("SDK"+$closestCtrl1+".rx") ($blendWeighted+".input[2]");
			connectAttr ("SDK"+$closestCtrl2+".rx") ($blendWeighted+".input[3]");
			//green Ctrl
			connectAttr ($upperLower+"Lip_M.rx") ($blendWeighted+".input[4]");
			//green sdk Ctrl
			connectAttr ("SDK"+$upperLower+"Lip_M.rx") ($blendWeighted+".input[5]");
			$value=`smoothstep 0 ($minDist1+$minDist2) $minDist2`;
			$value=`clamp 0 1 $value`;
			setAttr ($blendWeighted+".weight[0]") $value;
			setAttr ($blendWeighted+".weight[1]") (1-$value);
			setAttr ($blendWeighted+".weight[2]") $value;
			setAttr ($blendWeighted+".weight[3]") (1-$value);
			setAttr ($blendWeighted+".weight[4]") (1-((1.0/$mainNumCv)*$i));
			setAttr ($blendWeighted+".weight[5]") (1-((1.0/$mainNumCv)*$i));
			connectAttr ($blendWeighted+".output") ($upperLower+"LipJoint"+$i+$side+".rx");

			//Scale mult Green Ctrl
			connectAttr -f ($upperLower+"LipDM_M.outputScale") ($upperLower+"LipJoint"+$i+$side+".s");
			}
		}
	}

//press squeeze roll pucker sdk
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	//Press
	setKeyframe -t 0 ($upperLower+"Lip_M");
	setKeyframe -t 30 -v 0.2 ($upperLower+"Lip_M.sz");
	asFaceDsFinish ctrlLips _M ($upperLower+"Press") 10;

	//Squeeze
	$posA=`xform -q -ws -t ($upperLower+"Lip_M")`;
	$posB=`xform -q -ws -t ($upperLower+"LipMainCurve.cv[0]")`;
	setKeyframe -t 0 ($upperLower+"Lip_M");
	setKeyframe -t 30 -v 0.3 ($upperLower+"Lip_M.sy");
	setKeyframe -t 30 -v ((($posB[1]-$posA[1])/$ctrlScale)*0.5) ($upperLower+"Lip_M.ty");
	asFaceDsFinish ctrlLips _M ($upperLower+"Squeeze") 10;

	//Roll
/*
	setKeyframe -t 0 ($upperLower+"LipA_R");
	setKeyframe -t 0 ($upperLower+"LipA_L");
	setKeyframe -t 30 -v (0.35*$upperLowerFactor) ($upperLower+"LipA_R.ty");
	setKeyframe -t 30 -v (0.35*$upperLowerFactor) ($upperLower+"LipA_L.ty");
*/
	setKeyframe -t 0 ($upperLower+"Lip_M");
//	setKeyframe -t 30 -v (-0.15*$upperLowerFactor) ($upperLower+"Lip_M.ty");
	setKeyframe -t 30 -v 0.05 ($upperLower+"Lip_M.tz");
	setKeyframe -t 30 -v (-30*$upperLowerFactor) ($upperLower+"Lip_M.rx");
//	setKeyframe -t 30 -v 0.85 ($upperLower+"Lip_M.sy");
	asFaceDsFinish ctrlLips _M ($upperLower+"Roll") 10;

	setKeyframe -t 0 ($upperLower+"Lip_M");
	setKeyframe -t 30 -v -0.35 ($upperLower+"Lip_M.tz");
	asFaceDsFinish ctrlLips _M ($upperLower+"Roll") -10;

	//Pucker
	$posA=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
	$posB=`xform -q -ws -t upperLipMainCurve.cv[0]`;
	$value=$posA[1]-$posB[1];//relative to lip thickness
	setKeyframe -t 0 ($upperLower+"Lip_M");
	setKeyframe -t 30 -v (0.15*$upperLowerFactor) ($upperLower+"Lip_M.ty");
	setKeyframe -t 30 -v 0.25 ($upperLower+"Lip_M.tz");
	setKeyframe -t 30 -v (-30*$upperLowerFactor) ($upperLower+"Lip_M.rx");
//	setKeyframe -t 30 -v 0.7 ($upperLower+"Lip_M.sy");
	asFaceDsFinish ctrlLips _M ($upperLower+"Pucker") 10;

	setKeyframe -t 0 Lip_R Lip_L;
	setKeyframe -t 30 -v (($value/$ctrlScale)*-0.3) Lip_R.tx;
	setKeyframe -t 30 -v (($value/$ctrlScale)*-0.3) Lip_L.tx;
	asFaceDsFinish ctrlLips _M ($upperLower+"Pucker") 10;
	}

//last nr lipJoint -> cornerLipJoint_R
$mainNumCv=`getAttr upperLipMainCurve.spans`;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	rename ("upperLipJoint"+$mainNumCv+$side) ("cornerLipJoint"+$side);
	}

parent upperLipOffset_M lowerLipOffset_M LipOffset_R LipOffset_L LipRegion_M;

rename FaceControlOrient FaceControlOrientLip;
rename FaceControlSuspended FaceControlOrient;

//LipsTogether, added for "Connect  to MetaHuman-Animator" to work better, since MetaHuman have "LipsTogether" function
//that is like "StickyLips", but Only "reverses" CTRL_C_jaw
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		createNode -n ($upperLower+"LipsTogetherStatic"+$side) -p ($upperLower+"Lip"+$side) transform;
		parent ($upperLower+"LipsTogetherStatic"+$side) ($upperLower+"LipConstrainedFleshy_M");
		duplicate -n ($upperLower+"LipsTogetherFollow"+$side) ($upperLower+"LipsTogetherStatic"+$side);
		createNode -n ($upperLower+"LipFollow"+$side) -p ($upperLower+"LipOffset"+$side) transform;
		parent ("SDK"+$upperLower+"Lip"+$side) ($upperLower+"LipFollow"+$side);
		if ($opm)
			{
			createNode -n ($upperLower+"LipsTogetherFollowBM"+$side) blendMatrix;
			connectAttr upperLip_M.worldMatrix ($upperLower+"LipsTogetherFollowBM"+$side+".inputMatrix");
			connectAttr lowerLip_M.worldMatrix ($upperLower+"LipsTogetherFollowBM"+$side+".target[0].targetMatrix");
			setAttr ($upperLower+"LipsTogetherFollowBM"+$side+".target[0].weight") 0.5;
			createNode -n ($upperLower+"LipsTogetherFollowMM"+$side) multMatrix;
			$m=`xform -q -os -m ($upperLower+"LipsTogetherFollow"+$side)`;
//			setAttr ($upperLower+"LipsTogetherFollowMM"+$side+".matrixIn[2]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];

			createNode -n ($upperLower+"LipsTogetherFollowPM"+$side) pickMatrix;
			setAttr ($upperLower+"LipsTogetherFollowPM"+$side+".useScale") 0;
			setAttr ($upperLower+"LipsTogetherFollowPM"+$side+".useShear") 0;
			connectAttr ($upperLower+"LipsTogetherFollowBM"+$side+".outputMatrix") ($upperLower+"LipsTogetherFollowPM"+$side+".inputMatrix");
			connectAttr ($upperLower+"LipsTogetherFollowPM"+$side+".outputMatrix") ($upperLower+"LipsTogetherFollowMM"+$side+".matrixIn[1]");

//			connectAttr ($upperLower+"LipsTogetherFollowBM"+$side+".outputMatrix") ($upperLower+"LipsTogetherFollowMM"+$side+".matrixIn[0]");
			connectAttr ($upperLower+"LipConstrainedFleshy_M.worldInverseMatrix") ($upperLower+"LipsTogetherFollowMM"+$side+".matrixIn[2]");
			connectAttr ($upperLower+"LipsTogetherFollowMM"+$side+".matrixSum") ($upperLower+"LipsTogetherFollow"+$side+".offsetParentMatrix");
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 ($upperLower+"LipsTogetherFollow"+$side);

			delete `pointConstraint ($upperLower+"LipsTogetherStatic"+$side) ($upperLower+"LipsTogetherFollow"+$side)`;

			createNode -n ($upperLower+"LipFollowBM"+$side) blendMatrix;
			connectAttr ($upperLower+"LipsTogetherStatic"+$side+".worldMatrix") ($upperLower+"LipFollowBM"+$side+".inputMatrix");
			connectAttr ($upperLower+"LipsTogetherFollow"+$side+".worldMatrix") ($upperLower+"LipFollowBM"+$side+".target[0].targetMatrix");
//			setAttr ($upperLower+"LipFollowBM"+$side+".target[0].weight") 0.5;


			createNode -n ($upperLower+"LipFollowMM"+$side) multMatrix;
			connectAttr ($upperLower+"LipFollowBM"+$side+".outputMatrix") ($upperLower+"LipFollowMM"+$side+".matrixIn[0]");
			connectAttr ($upperLower+"LipOffset"+$side+".worldInverseMatrix") ($upperLower+"LipFollowMM"+$side+".matrixIn[1]");
//			connectAttr ($upperLower+"LipFollowMM"+$side+".matrixSum") ($upperLower+"LipFollow"+$side+".offsetParentMatrix");

			createNode -n ($upperLower+"LipFollowPM"+$side) pickMatrix;
			setAttr ($upperLower+"LipFollowPM"+$side+".useRotate") 0;
			setAttr ($upperLower+"LipFollowPM"+$side+".useScale") 0;
			setAttr ($upperLower+"LipFollowPM"+$side+".useShear") 0;
			connectAttr ($upperLower+"LipFollowMM"+$side+".matrixSum") ($upperLower+"LipFollowPM"+$side+".inputMatrix");
			connectAttr ($upperLower+"LipFollowPM"+$side+".outputMatrix") ($upperLower+"LipFollow"+$side+".offsetParentMatrix");;

			}
		else
			{
			pointConstraint -mo upperLip_M lowerLip_M ($upperLower+"LipsTogetherFollow"+$side);
			pointConstraint ($upperLower+"LipsTogetherFollow"+$side) ($upperLower+"LipsTogetherStatic"+$side) ($upperLower+"LipFollow"+$side);
			}


		addAttr -k 1 -ln lipsTogether -at double -min 0 -max 10 -dv 0 ($upperLower+"Lip"+$side);
		asEnsureOutputBlendWeighted ($upperLower+"Lip"+$side+".lipsTogether");
		asUnitConvertAndReverse ($upperLower+"LipsTogether"+$side) ("bw"+$upperLower+"Lip"+$side+"_lipsTogether.output");
		if ($opm)
			connectAttr ($upperLower+"LipsTogether"+$side+"UnitConversion.output") ($upperLower+"LipFollowBM"+$side+".target[0].weight");
		else
			{
			connectAttr ($upperLower+"LipsTogether"+$side+"UnitConversion.output") ($upperLower+"LipFollow"+$side+"_pointConstraint1."+$upperLower+"LipsTogetherFollow"+$side+"W0");
			connectAttr ($upperLower+"LipsTogether"+$side+"Reverse.outputX") ($upperLower+"LipFollow"+$side+"_pointConstraint1."+$upperLower+"LipsTogetherStatic"+$side+"W1");
			}
		}
	}

//lipMainArea
eval ("select -add "+`asGetFaceFitSelection FaceFitLipMainCurve`);
sets -n lipMainArea;
sets -add FaceAreas lipMainArea;

delete LipConstruction;
if (`objExists closestNurbsSampler`) delete closestNurbsSampler;

setAttr ctrlBoxLips_M.v 1;
setAttr -l 1 -k 0 ctrlLips_M.tx;
setAttr -l 1 -k 0 ctrlLips_M.ty;

select -cl;
setToolTo $gSelect;
}

global proc asFaceLipFalloff ()
{
global string $gMove;
int $lipCtrls=`asGetLipCtrls`;
int $test,$update,$lipFalloff,$numCVs,$vtxsFromLipToNose;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $numIterations=`intField -q -v lipFalloffIterationsIntField`;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $vtxNrs[];
float $value,$factor,$faceWeightAddValue,$minDist,$dist,$weight,$portion,$weightValue,$fadeDist,$falloffRadius,$weight;
float $scale=`asGetScale`;
float $sideTreshold=0.01*$scale;
float $fadeFloat=1.3;
if (`floatField -q -ex asFaceLipFalloffSideFadeFloatField`)
	$fadeFloat=`floatField -q -v asFaceLipFalloffSideFadeFloatField`;
float $pos[],$posA[],$posB[],$values[],$weights[],$heightweight[],$widthweight[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $innerOuter,$inf,$closestLipOuterCurveVtx,$side,$leftSuffix,$vtxNrA,$vtxNrB;
string $tempString[],$tempString2[],$tempString3[],$infs[],$lipFalloffInsideMouthArea[],$upperVtxs[],$lowerVtxs[],$upperVtxsL[],$lowerVtxsL[];
string $innerLipFalloffVtxs[],$outerLipFalloffVtxs[],$lipOuterCurveVtx[],$previousSel[],$nonLipFalloffAreaVtxs[],$doneVtxs[];

if (!`objExists upperLipMainCurve`)//skip
	return;

if ($multiSkinClusters)
	{
	$skinCluster="LipSC";
	$headJoint="MultiSkinClustersFaceLipJoint_M";
	}

if (`objExists asFaceLipFalloffTest`)
	{
	$test=1;
	delete asFaceLipFalloffTest;
	}

if (`objExists asFaceLipFalloffUpdate`)
	{
	$update=1;
	delete asFaceLipFalloffUpdate;
	}

//get these before pose changes
$vtxNrA=`asGetFaceFitSelection upperLipOuterCurve.cv[0]`;
$vtxNrB=`asGetFaceFitSelection NoseUnder`;

currentTime 0;
asFaceLockWeights 1;
setAttr ($headJoint+".lockInfluenceWeights") 0;
$tempString=`listRelatives -c -type joint LipJoints_M`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".lockInfluenceWeights") 0;

//vtxsFromLipToNose
if ($test || $update)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
else
	{
	if (!`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	addAttr -ln "vtxsFromLipToNose" -at long -dv 3 FaceFitSkeleton;
	$vtxsFromLipToNose=0;
	select $vtxNrA;
	for ($i=0;$i<25;$i++)
		{
		$tempString=`ls -sl -fl`;
		if (`stringArrayCount $vtxNrB $tempString`)
			break;
		$vtxsFromLipToNose++;
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		}
	if ($vtxNrA==$vtxNrB) $vtxsFromLipToNose=0;//this is the case for democharacter "max"
	setAttr FaceFitSkeleton.vtxsFromLipToNose $vtxsFromLipToNose;
	asFaceUpdateInfo 1;
	}

select -cl;
setFocus MayaWindow;//ensure execution of intField -cc cmd, if focus is still at intField

if (!$test)
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 upperLipA_R upperLipB_R lowerLipA_R lowerLipB_R Lip_R;

if (`objExists lipFalloffArea`) delete lipFalloffArea;
if (`objExists lipFalloffInsideMouthArea`) delete lipFalloffInsideMouthArea;
createNode -n lipFalloffArea objectSet;
sets -add FaceAreas lipFalloffArea;
if (!`objExists lipFalloffAreaMax`)
	{
	createNode -n lipFalloffAreaMax objectSet;
	sets -add FaceBuildingSets lipFalloffAreaMax;
	}

for ($a=0;$a<2;$a++)
	{
	if ($a==0) $innerOuter="Inner";
	if ($a==1) $innerOuter="Outer";

	$lipFalloff=`intField -q -v ("lipFalloff"+$innerOuter+"IntField")`;

	duplicate -n ("upperLip"+$innerOuter+"Curve_L") ("upperLip"+$innerOuter+"Curve");
	duplicate -n ("lowerLip"+$innerOuter+"Curve_L") ("lowerLip"+$innerOuter+"Curve");
	setAttr ("upperLip"+$innerOuter+"Curve_L.sx") -1;
	setAttr ("lowerLip"+$innerOuter+"Curve_L.sx") -1;

	eval ("select "+`asGetFaceFitSelection ("upperLip"+$innerOuter+"Curve")`);
	$tempString=`ls -sl`;
//	select `asobjSetCast "" $tempString LipLayer`;
	$upperVtxs=`ls -sl -fl`;
	eval ("select "+`asGetFaceFitSelection ("lowerLip"+$innerOuter+"Curve")`);
	$tempString=`ls -sl`;
//	select `asobjSetCast "" $tempString LipLayer`;
	$lowerVtxs=`ls -sl -fl`;

	//+left side
	if (`objExists ("upperLip"+$innerOuter+"CurveLeft")`)
		eval ("select "+`asGetFaceFitSelection ("upperLip"+$innerOuter+"CurveLeft")`);
	else
		eval ("select "+`asGetFaceFitSelection ("upperLip"+$innerOuter+"Curve_L")`);
	$tempString=`ls -sl`;
//	select `asobjSetCast "" $tempString LipLayer`;
	$upperVtxsL=`ls -sl -fl`;
	if (`objExists ("lowerLip"+$innerOuter+"CurveLeft")`)
		eval ("select "+`asGetFaceFitSelection ("lowerLip"+$innerOuter+"CurveLeft")`);
	else
		eval ("select "+`asGetFaceFitSelection ("lowerLip"+$innerOuter+"Curve_L")`);
	$tempString=`ls -sl`;
//	select `asobjSetCast "" $tempString LipLayer`;
	$lowerVtxsL=`ls -sl -fl`;

	select $upperVtxs $lowerVtxs $upperVtxsL $lowerVtxsL;
	for ($i=0;$i<$lipFalloff;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;
		select -d lipArea;
		}
	select -d lipArea;
	if (size(`ls -sl`))
		{
		sets -add lipFalloffArea `ls -sl`;
		sets -add lipFalloffAreaMax `ls -sl`;
		}
	if ($innerOuter=="Inner") $innerLipFalloffVtxs=`ls -sl -fl`;
	if ($innerOuter=="Outer") $outerLipFalloffVtxs=`ls -sl -fl`;

	delete ("upperLip"+$innerOuter+"Curve_L") ("lowerLip"+$innerOuter+"Curve_L");
	}

select lipFalloffArea;
refresh;

if ($test)
	{
	currentTime 30;
	return;
	}

eval ("select "+`asGetFaceFitSelection FaceFitLipOuterCurve`);
$lipOuterCurveVtx=`ls -sl -fl`;

//flood to head first, as rhis function might have ran previously with a larger falloff
select lipFalloffAreaMax;
catchQuiet (`skinPercent -tv $headJoint 1 $skinCluster`);

//just hammer
select lipFalloffArea;
//asWeightHammerVerts $numIterations;
asWeightHammerVertsMS $numIterations $skinCluster;

//just hammer inside
select $lipFalloffInsideMouthArea;
if (size(`ls -sl`))
	asWeightHammerVertsMS 5 $skinCluster;
//	weightHammerVerts;

//Keep weighing on LipFalloffLayer
if (!`objExists lipOffJoint`)
	{
	select $headJoint;
	joint -n lipOffJoint;
	parent lipOffJoint FaceBuildInProgressHidden;
	}


if (`objExists LipFalloffLayer`)
	delete LipFalloffLayer;
duplicate -n LipFalloffLayer templateLayer;
select `listConnections -s 1 -d 0 -type joint $skinCluster` LipFalloffLayer;
select -d $headJoint;
select -add lipOffJoint;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] LipFalloffLayerSC;
select $geometry LipFalloffLayer;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
skinPercent -pruneWeights 0.01 LipFalloffLayerSC;

for ($i=2;$i<($lipCtrls/4);$i++)
	{
	setKeyframe -t 0 -v 0 ("upperLip"+`asNrToLetter $i`+"_R.ty");
	setKeyframe -t 30 -v 1 ("upperLip"+`asNrToLetter $i`+"_R.ty");
	}
currentTime 30;

select -cl;
}
/*
global proc asFaceLipCorner ()
{
int $numBlends;
float $mainNumCv;
string $lastLipLetter=`asGetLastLipLetter`;

asFaceRemoveFitAnimationsFromOnFaceCtrls;
refresh;

setKeyframe -t 0 -v 0 ("upperLip"+$lastLipLetter+"_R.ty");
setKeyframe -t 30 -v 0.5 ("upperLip"+$lastLipLetter+"_R.ty");
setKeyframe -t 0 -v 0 ("lowerLip"+$lastLipLetter+"_R.ty");
setKeyframe -t 30 -v -0.5 ("lowerLip"+$lastLipLetter+"_R.ty");
currentTime 30;

$mainNumCv=`getAttr upperLipMainCurve.spans`;
if ($mainNumCv<10)
	$numBlends=0;
if ($mainNumCv>9)
	$numBlends=1;
if ($mainNumCv>14)
	$numBlends=2;
if ($mainNumCv>17)
	$numBlends=3;
intField -e -v $numBlends lipCornerIntField;

asFaceLipCornerUpdate;
}

global proc asFaceLipCornerUpdate ()
{
int $vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
int $numBlends=`intField -q -v lipCornerIntField`;
float $currentTime=`currentTime -q`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $side,$upperLower;
string $vtxs[];

//keep preLipCorner weights, so we can revert
//if ($currentTime!=30) currentTime 0;
currentTime 0;
if (`objExists PreLipCornerLayer`)
	{
	select PreLipCornerLayer $geometry;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation name;
	}
else
	{
	duplicate -n PreLipCornerLayer templateLayer;
	select `listConnections -s 1 -d 0 -type joint ($skinCluster+".matrix")`;
	select -add PreLipCornerLayer;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] PreLipCornerLayerSC;
	select $geometry PreLipCornerLayer;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation name;
	}
//if ($currentTime!=30) currentTime $currentTime;
currentTime 30;

//towards lipCnr blend weights
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		$blendNum=0;
		for ($i=99;$i>0;$i--)
			{
			if (!`objExists ($upperLower+"LipJoint"+$i+$side)`)
				continue;

			$vtxs=`asInfluenceVerts ($upperLower+"LipJoint"+$i+$side) $skinCluster 1.0`;
			$weight=(1-((1.0/($numBlends+1))*($blendNum+1)));
			if (size($vtxs))
				{
				catchQuiet (`skinPercent -tv ("LipJoint"+$side) 0 $skinCluster $vtxs`);
				if ($blendNum<$numBlends)
					catchQuiet (`skinPercent -tv ("LipJoint"+$side) $weight $skinCluster $vtxs`);
				}
			$blendNum++;
			}
		}
	}
select lipFalloffArea;
//if (size(`ls -sl`))
//	weightHammerVerts;
asWeightHammerVerts ($vtxsFromLipToNose*4);

select -cl;
}
*/
global proc asFaceFaceCage ()
{
global string $gSelect;
setToolTo $gSelect;
//int $modifier=`getModifiers`;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $numCv,$midwayCvNr,$numVtx,$numSmoo,$type,$numEyeBrowMid,$cvNr,$split1CvNr,$split2CvNr;
int $simplerEyeLid,$upperEyeLidOuterNumCVs,$lowerEyeLidOuterNumCVs,$upperLipOuterNumCVs,$lowerLipOuterNumCVs;
int $topCvNr,$innerEyeCnrNr,$outerEyeCnrNr,$sideCvNum,$noseCvNr;
int $opm=`asGetOpm`;
int $hasAboveEye=`objExists EyeBrowInner`;
int $hasBelowEye=`objExists upperLipMainCurve`;
int $tempInts[];
float $dist,$value,$headWeight,$sumWeight,$weight,$u;
float $pos[],$posA[],$posB[],$posC[],$values[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $side,$leftSuffix,$target,$previousTarget,$weightJoint,$cmd,$lipLid,$upperLower,$curveCmd,$vtxClosestToCenter,$mm;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$cageJoints[],$infs[],$eyeBrows[],$lipCageVtxs[],$lidCageVtxs[];
string $pps[]={"CheekBone","NoseSide","NoseBridge","NoseCorner","NoseUnder","FrownBulge",
	"SmileBulge","Cheek","ChinCrease","Nose","Nostril"};

asFaceRemoveFitAnimationsFromOnFaceCtrls;
asFaceHideControllers 1;

if (!`objExists upperLipMainCurve` && !`objExists EyeBrowInner`)//skip
	return;

if ($multiSkinClusters)
	$skinCluster=`asFaceMultiSkinClusterAdd "Cage"`; 

$simplerEyeLid=`checkBox -q -v asFaceSimplerEyeLidCheckBox`;
$upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`;
$lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`;
if ($hasBelowEye)
	{
	$upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`;
	$lowerLipOuterNumCVs=`getAttr lowerLipOuterCurve.spans`;
	}
if ($hasAboveEye)
	{
	$topCvNr=`getAttr FaceFitForeHead.topCvNr`;
	$innerEyeCnrNr=`getAttr FaceFitForeHead.innerEyeCnrNr`;
	$outerEyeCnrNr=`getAttr FaceFitForeHead.outerEyeCnrNr`;
	$sideCvNum=`getAttr FaceFitForeHead.sideCvNr`;
	$noseCvNr=`getAttr FaceFitForeHead.noseCvNr`;
	for ($i=1;$i<4;$i++)
		if (`objExists ("EyeBrowMid"+$i)`)
			$numEyeBrowMid=$i;
	}

//guesstimate numSmoo
if ($hasBelowEye)
	{
	eval ("select "+`asGetFaceFitSelection Cheek`);
	$tempString=`ls -sl`;
	eval ("select "+`asGetFaceFitSelection upperLipOuterCurve.cv[99]`);
	$tempString2=`ls -sl`;
	select $tempString[0];
	for ($i=0;$i<20;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;
		$tempString3=`ls -sl -fl`;
		if (`stringArrayCount $tempString2[0] $tempString3`)
			break;
		}
	select -cl;
	if ($i>1) $numSmoo=1;
	if ($i>10) $numSmoo=2;
	intField -e -v $numSmoo faceCageIntField;
	}

if ($hasAboveEye)
	{
	$eyeBrows={"EyeBrowInner"};
	for ($a=1;$a<4;$a++)
		if (`objExists ("EyeBrowMid"+$a)`)
			$eyeBrows[size($eyeBrows)]=("EyeBrowMid"+$a);
	$eyeBrows[size($eyeBrows)]="EyeBrowOuter";
	if (`objExists EyeBrowCenter`)
		$eyeBrows[size($eyeBrows)]="EyeBrowCenter";
	$pps=`stringArrayCatenate $pps $eyeBrows`;
	}

//pingpongs
createNode -n TempPos transform;
for ($i=0;$i<size($pps);$i++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$leftSuffix="";$side="_R";}
		else {$leftSuffix="Left";$side="_L";}

		$type=3;
		if ($pps[$i]=="NoseBridge" || $pps[$i]=="Nose" || $pps[$i]=="NoseUnder" || $pps[$i]=="ChinCrease" || $pps[$i]=="EyeBrowCenter")
			{
			if ($side=="_R")
				$side="_M";
			if ($side=="_L")
				continue;
			}
		if (`gmatch $pps[$i] "EyeBrow*"`)
			$type=1;
		if ($pps[$i]=="EyeBrowInner")
			$type=2;
		if (!`objExists ($pps[$i]+$leftSuffix)`)
			continue;
		$pos=`xform -q -ws -t ($pps[$i]+$leftSuffix)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
		asCreatePP TempPos $pps[$i] $side $type 1 0 0;

		if (`gmatch $pps[$i] "EyeBrow*"`)
			xform -r -os -s 1.5 1.5 1.5 ($pps[$i]+$side+".cv[0:99]");
		$cageJoints[size($cageJoints)]=($pps[$i]+"Joint"+$side);
		}
	}


//Adding NoseCrease controller
if ($hasBelowEye)
	{
	if ($hasAboveEye)//Use FitForeHead if exists
		{
		$pos=`xform -q -ws -t ("ForeHeadCurve.cv["+$noseCvNr+"]")`;
		}
	else//else pathTrace
		{
		$tempString[0]=`asGetFaceFitSelection upperEyeLidOuterCurve.cv[0]`;
		$tempInts[0]=`asComponentToNr $tempString[0]`;
		$tempString[0]=`asGetFaceFitSelection ("upperEyeLidOuterCurve"+$leftSuffix+".cv[0]")`;
		$tempInts[1]=`asComponentToNr $tempString[0]`;
		asSelectLeastEdgesPath $geometry $tempInts[0] $tempInts[1];
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		if (size($tempString)==0)//can happen if eyeLids are `shells` e.g. Max
			{
			$pos=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
			$tempString=`spaceLocator`;
			rename $tempString[0] TempLocator;
			xform -ws -t 0 $pos[1] $pos[2] TempLocator;
			$tempString[0]=`asGetFaceFitSelection TempLocator`;
			delete TempLocator;
			}
		$dist=999;
		$vtxClosestToCenter=$tempString[0];
		for ($i=0;$i<size($tempString);$i++)
			{
			$pos=`xform -q -ws -t $tempString[$i]`;
			if (abs($pos[0])<$dist)
				{
				$vtxClosestToCenter=$tempString[$i];
				$dist=abs($pos[0]);
				}
			}
		$pos=`xform -q -ws -t $vtxClosestToCenter`;
		}

	xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
	asCreatePP TempPos NoseCrease _M 3 1 0 0;
	$cageJoints[size($cageJoints)]="NoseCreaseJoint_M";
	}

//using lowerLidOuter
$cageJoints[size($cageJoints)]="lowerLidOuterJoint_R";
$cageJoints[size($cageJoints)]="lowerLidOuterJoint_L";
if (!$simplerEyeLid)
	{
	parent lowerLidOuterJoint_R lowerLidOuterJoint_L FaceJoint_M;
	if ($opm)
		{
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			connectAttr -f FaceJoint_M.worldInverseMatrix ("lowerLidOuterJointMM"+$side+".matrixIn[2]");
			xform -os -t 0 0 0 ("lowerLidOuterJoint"+$side);
			asOPMScaleReset ("lowerLidOuterJoint"+$side);
			}
		}
	}

delete TempPos;

if ($multiSkinClusters)//inverseMatrix out HeadJoint
	for ($y=0;$y<size($cageJoints);$y++)
		{
		tokenize $cageJoints[$y] "_" $tempString;
		$mm=$tempString[0]+"MM_"+$tempString[1];
		connectAttr -f  ($headJoint+".worldInverseMatrix") ($mm+".matrixIn[2]");
		$m=`getAttr ($headJoint+".worldMatrix")`;
		setAttr ($mm+".matrixIn[3]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		$tempString=`listRelatives -p $cageJoints[$y]`;
		connectAttr ($tempString[0]+".worldInverseMatrix") ($mm+".matrixIn[4]");
		}


//CheekRaiser placeHolder
if ($hasBelowEye)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$leftSuffix="";}
		else {$side="_L";$leftSuffix="Left";}

		createNode -n ("CheekRaiser"+$leftSuffix) -p FaceBuildInProgressHidden transform;
		$pos=`xform -q -ws -t ("lowerLidOuter"+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("CheekRaiser"+$leftSuffix);
		}
	}


//Cheek Cage
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}
	
	//these can vary from Left to Right
	if ($hasAboveEye)
		{
		$topCvNr=`getAttr ("FaceFitForeHead.topCvNr")`;
		$innerEyeCnrNr=`getAttr ("FaceFitForeHead"+$leftSuffix+".innerEyeCnrNr")`;
		$outerEyeCnrNr=`getAttr ("FaceFitForeHead"+$leftSuffix+".outerEyeCnrNr")`;
		$sideCvNum=`getAttr ("FaceFitForeHead"+$leftSuffix+".sideCvNr")`;
		$noseCvNr=`getAttr ("FaceFitForeHead"+$leftSuffix+".noseCvNr")`;
		}

	asFacet ("SmileBulge"+$leftSuffix) ("Cheek"+$leftSuffix) ("FrownBulge"+$leftSuffix);
	asFacet ("Cheek"+$leftSuffix) ("SmileBulge"+$leftSuffix) ("CheekBone"+$leftSuffix);
//	asFacet ("CheekRaiser"+$leftSuffix) ("SmileBulge"+$leftSuffix) ("NoseCorner"+$leftSuffix);
//	asFacet ("CheekRaiser"+$leftSuffix) ("NoseCorner"+$leftSuffix) ("NoseSide"+$leftSuffix);
	asFacet ("CheekRaiser"+$leftSuffix) ("SmileBulge"+$leftSuffix) ("NoseSide"+$leftSuffix);
	asFacet ("NoseCorner"+$leftSuffix) ("NoseSide"+$leftSuffix) ("SmileBulge"+$leftSuffix);

	asFacet ("SmileBulge"+$leftSuffix) ("CheekRaiser"+$leftSuffix) ("CheekBone"+$leftSuffix);
	asFacet ("Cheek"+$leftSuffix) ("CheekBone"+$leftSuffix) ("JawPivot"+$leftSuffix);
	asFacet ("Cheek"+$leftSuffix) ("JawPivot"+$leftSuffix) ("JawCorner"+$leftSuffix);
	asFacet ("Cheek"+$leftSuffix) ("JawCorner"+$leftSuffix) ("JawLine"+$leftSuffix);
	asFacet ("Cheek"+$leftSuffix) ("JawLine"+$leftSuffix) ("FrownBulge"+$leftSuffix);
	asFacet ("FrownBulge"+$leftSuffix) ("JawLine"+$leftSuffix) Jaw;
	asFacet Jaw ChinCrease ("FrownBulge"+$leftSuffix);

	asFacet ("SmileBulge"+$leftSuffix) ("FrownBulge"+$leftSuffix) ("upperLipOuterCurve"+$leftSuffix+".cv[99]");
	for ($i=0;$i<$lowerLipOuterNumCVs+1;$i++)
		{
		if ($i<$lowerLipOuterNumCVs/2)
			$target="ChinCrease";
		else
			$target="FrownBulge"+$leftSuffix;
		asFacet $target ("lowerLipOuterCurve"+$leftSuffix+".cv["+$i+"]") ("lowerLipOuterCurve"+$leftSuffix+".cv["+($i+1)+"]");
		}
	asFacet ("FrownBulge"+$leftSuffix) ChinCrease ("lowerLipOuterCurve"+$leftSuffix+".cv["+($lowerLipOuterNumCVs/2)+"]");

	$split1CvNr=`asRoundFloatToInt ($upperLipOuterNumCVs*0.3)`;
	$split2CvNr=`asRoundFloatToInt ($upperLipOuterNumCVs*0.6)`;
	for ($i=0;$i<$upperLipOuterNumCVs+1;$i++)
		{
		if ($i<$split1CvNr)
			$target="NoseUnder";
		else if ($i<$split2CvNr)
			$target="NoseCorner"+$leftSuffix;
		else
			$target="SmileBulge"+$leftSuffix;
		asFacet ("upperLipOuterCurve"+$leftSuffix+".cv["+$i+"]") $target ("upperLipOuterCurve"+$leftSuffix+".cv["+($i+1)+"]");
		}
	asFacet ("NoseCorner"+$leftSuffix) ("SmileBulge"+$leftSuffix) ("upperLipOuterCurve"+$leftSuffix+".cv["+$split2CvNr+"]");
	asFacet ("NoseCorner"+$leftSuffix) ("upperLipOuterCurve"+$leftSuffix+".cv["+$split1CvNr+"]") NoseUnder;
	asFacet ("NoseCorner"+$leftSuffix) NoseUnder ("Nostril"+$leftSuffix);
	asFacet NoseUnder Nose ("Nostril"+$leftSuffix);
	asFacet ("NoseSide"+$leftSuffix) ("NoseCorner"+$leftSuffix) ("Nostril"+$leftSuffix);
	asFacet ("NoseSide"+$leftSuffix) ("Nostril"+$leftSuffix) Nose;
	asFacet NoseBridge ("NoseSide"+$leftSuffix) Nose;
	asFacet ("lowerEyeLidOuterCurve"+$leftSuffix+".cv[0]") ("NoseSide"+$leftSuffix) NoseBridge;
//	asFacet ("lowerEyeLidOuterCurve"+$leftSuffix+".cv[0]") NoseBridge ("ForeHeadCurve"+$leftSuffix+".cv["+$noseCvNr+"]");
	asFacet ("lowerEyeLidOuterCurve"+$leftSuffix+".cv[0]") NoseBridge ("ForeHeadCurve.cv["+$noseCvNr+"]");

	//determine which cvNr on "lowerEyeLidOuterCurve" that is closest to CheekRaiser
	createNode -n tempNearestPointOnCurve nearestPointOnCurve;
	connectAttr -f ("lowerEyeLidOuterCurve"+$leftSuffix+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
	if ($hasBelowEye)
		$pos=`xform -q -ws -t ("CheekRaiser"+$leftSuffix)`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	$u=`getAttr tempNearestPointOnCurve.result.parameter`;
	delete tempNearestPointOnCurve;

	for ($i=0;$i<$lowerEyeLidOuterNumCVs+1;$i++)
		{
		if ($i<$u/2)
			$target="NoseSide"+$leftSuffix;
		else if ($i<$u)
			$target="CheekRaiser"+$leftSuffix;
		else
			$target="CheekBone"+$leftSuffix;
		asFacet $target ("lowerEyeLidOuterCurve"+$leftSuffix+".cv["+$i+"]") ("lowerEyeLidOuterCurve"+$leftSuffix+".cv["+($i+1)+"]");
		}

	asFacet ("CheekRaiser"+$leftSuffix) ("NoseSide"+$leftSuffix) ("lowerEyeLidOuterCurve"+$leftSuffix+".cv["+(($u/2)+1)+"]");
	asFacet ("CheekBone"+$leftSuffix) ("CheekRaiser"+$leftSuffix) ("lowerEyeLidOuterCurve"+$leftSuffix+".cv["+($u+1)+"]");

	$midwayCvNr=$sideCvNum+(($outerEyeCnrNr-$sideCvNum)/2);//must be same split as what places lowerLidOuter_R

	asFacet ("JawPivot"+$leftSuffix) ("ForeHeadCurve"+$leftSuffix+".cv["+$midwayCvNr+"]") ("ForeHeadCurve"+$leftSuffix+".cv["+$sideCvNum+"]");
	asFacet ("JawPivot"+$leftSuffix) ("CheekBone"+$leftSuffix) ("ForeHeadCurve"+$leftSuffix+".cv["+$midwayCvNr+"]");
	asFacet ("ForeHeadCurve"+$leftSuffix+".cv["+$outerEyeCnrNr+"]") ("ForeHeadCurve"+$leftSuffix+".cv["+$midwayCvNr+"]") ("CheekBone"+$leftSuffix);

	//Above eye
	asFacet ("ForeHeadCurve.cv["+$noseCvNr+"]") EyeBrowCenter ("upperEyeLidOuterCurve"+$leftSuffix+".cv[0]");
	asFacet EyeBrowCenter ("EyeBrowInner"+$leftSuffix) ("upperEyeLidOuterCurve"+$leftSuffix+".cv[0]");

	$fraction=$upperEyeLidOuterNumCVs/(2+$numEyeBrowMid);
	for ($i=0;$i<$upperEyeLidOuterNumCVs+1;$i++)
		{
		if ($i<($fraction*1))
			$target="EyeBrowInner"+$leftSuffix;
		else if ($i<($fraction*2) && `objExists EyeBrowMid1`)
			$target="EyeBrowMid1"+$leftSuffix;
		else if ($i<($fraction*3) && `objExists EyeBrowMid2`)
			$target="EyeBrowMid2"+$leftSuffix;
		else if ($i<($fraction*4) && `objExists EyeBrowMid3`)
			$target="EyeBrowMid3"+$leftSuffix;
		else if ($i<($fraction*5))
			$target="EyeBrowOuter"+$leftSuffix;
		asFacet ("upperEyeLidOuterCurve"+$leftSuffix+".cv["+$i+"]") $target ("upperEyeLidOuterCurve"+$leftSuffix+".cv["+($i+1)+"]");

		if ($target!=$previousTarget && $i>0)
			asFacet $previousTarget $target ("upperEyeLidOuterCurve"+$leftSuffix+".cv["+$i+"]");
		$previousTarget=$target;
		}

	//reBuild ForeHeadCurve From Top to side
	if ($hasAboveEye)
		{
		$curveCmd="curve -d 1 -n ForeHeadTopToSideCurve"+$leftSuffix;
		for ($i=$topCvNr;$i<$sideCvNum+1;$i++)
			{
			$pos=`xform -q -ws -t ("ForeHeadCurve"+$leftSuffix+".cv["+$i+"]")`;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		eval ($curveCmd);
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s (4+$numEyeBrowMid) -d 1 -tol 0.01 ("ForeHeadTopToSideCurve"+$leftSuffix);
		parent ("ForeHeadTopToSideCurve"+$leftSuffix) FaceBuildInProgressHidden;
		}

	asFacet EyeBrowCenter ("ForeHeadTopToSideCurve"+$leftSuffix+".cv[0]") ("EyeBrowInner"+$leftSuffix);
	asFacet ("ForeHeadTopToSideCurve"+$leftSuffix+".cv[0]") ("ForeHeadTopToSideCurve"+$leftSuffix+".cv[1]") ("EyeBrowInner"+$leftSuffix);
	$cvNr=1;
	$previousTarget="EyeBrowInner"+$leftSuffix;
	for ($i=1;$i<$numEyeBrowMid+2;$i++)
		{
		$target="EyeBrowMid"+$i+$leftSuffix;
		if ($i==$numEyeBrowMid+1)
			$target="EyeBrowOuter"+$leftSuffix;
		asFacet ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+$cvNr+"]") ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+($cvNr+1)+"]") $target;
		asFacet ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+$cvNr+"]") $target $previousTarget;
		$previousTarget=$target;
		$cvNr++;
		}

	asFacet ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+(4+$numEyeBrowMid-1)+"]") ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+(4+$numEyeBrowMid)+"]") ("ForeHeadCurve"+$leftSuffix+".cv["+$midwayCvNr+"]");
	asFacet ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+(4+$numEyeBrowMid-2)+"]") ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+(4+$numEyeBrowMid-1)+"]") ("EyeBrowOuter"+$leftSuffix);
	asFacet ("ForeHeadTopToSideCurve"+$leftSuffix+".cv["+(4+$numEyeBrowMid-1)+"]") ("ForeHeadCurve"+$leftSuffix+".cv["+$midwayCvNr+"]") ("EyeBrowOuter"+$leftSuffix);
	asFacet ("ForeHeadCurve"+$leftSuffix+".cv["+$midwayCvNr+"]") ("ForeHeadCurve"+$leftSuffix+".cv["+$outerEyeCnrNr+"]") ("EyeBrowOuter"+$leftSuffix);
	}

//merge
select `ls "asCageFacet*"`;
polyUnite -ch 0 -mergeUVSets 1 -name asCage;
polyMergeVertex -ch 0 -d 0.01 -am 1 asCage;
polyNormal -ch 0 -normalMode 2 -userNormalMode 0 asCage;
//polyNormal -ch 0 -normalMode 0 -userNormalMode 0 asCage;
select asCage;
sets -e -forceElement asRedSG asCage;

//bind
select -cl;
//joint -n asTempLipLidJoint;
select asCage $headJoint $cageJoints;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] asCageSC;
skinPercent -tv $headJoint 1 asCageSC asCage;
$tempInts=`polyEvaluate -v asCage`;
$numVtx=$tempInts[0];
for ($i=0;$i<$numVtx;$i++)
	{
	$posA=`xform -q -ws -t ("asCage.vtx["+$i+"]")`;
	for ($y=0;$y<size($cageJoints);$y++)
		{
		$weightJoint=$cageJoints[$y];
		$posB=`xform -q -ws -t ($cageJoints[$y])`;
		$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($dist<0.01)
			skinPercent -tv $weightJoint 1 asCageSC ("asCage.vtx["+$i+"]");
		}
	}

for ($i=0;$i<size($cageJoints);$i++)
	{
	if ($simplerEyeLid && `gmatch $cageJoints[$i] "lowerLidOuterJoint_*"`)//already bound if $simplerEyeLid
		continue;
	skinCluster -e -dr 4 -lw false -wt 0 -ai $cageJoints[$i] $skinCluster;
	}

//determine Lid/Pip Verts
createNode -n closestSampler closestPointOnMesh;
connectAttr -f asCage.outMesh closestSampler.inMesh;

$tempString={"upperLipOuterCurve","upperLipOuterCurveLeft","lowerLipOuterCurve","lowerLipOuterCurveLeft"};
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`objExists $tempString[$i]`)
		continue;
	$spans=`getAttr ($tempString[$i]+".spans")`;
	for ($y=0;$y<$spans+1;$y++)
		{
		$pos=`xform -q -ws -t ($tempString[$i]+".cv["+$y+"]")`;
		setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$lipCageVtxs[size($lipCageVtxs)]="asCage.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
		}
	}

$tempString={"upperEyeLidOuterCurve","upperEyeLidOuterCurveLeft","lowerEyeLidOuterCurve","lowerEyeLidOuterCurveLeft"};
//createNode -n closestSampler closestPointOnMesh;
//connectAttr -f asCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`objExists $tempString[$i]`)
		continue;
	$spans=`getAttr ($tempString[$i]+".spans")`;
	for ($y=0;$y<$spans+1;$y++)
		{
		$pos=`xform -q -ws -t ($tempString[$i]+".cv["+$y+"]")`;
		setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$lidCageVtxs[size($lidCageVtxs)]="asCage.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
		}
	}

delete closestSampler;

//Lip/Lid weighting of cage
clear $tempString;
if ($hasBelowEye)
	$tempString =`listRelatives -ad -type joint LipJoints_M`;
$tempString2=`listRelatives -ad -type joint EyeLidJoints_M`;
if ($simplerEyeLid)
	$tempString2={"lowerLidOuterJoint_R","lowerLidOuterJoint_L"};
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($simplerEyeLid && `gmatch $tempString[$i] "lowerLidOuterJoint_*"`)//already bound if $simplerEyeLid
		continue;
	skinCluster -e -lw false -wt 0 -ai $tempString[$i] asCageSC;
	}
select ($geometry+".vtx[0:99999]") $lidCageVtxs;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select -cl;
joint -n cageOffJoint;
parent cageOffJoint FaceBuildInProgressHidden;
skinCluster -e -lw false -wt 0 -ai cageOffJoint asCageSC;
if (size($lipCageVtxs))
	skinPercent -tv cageOffJoint 1 asCageSC $lipCageVtxs;
//also bind to $geometry, for the copy process
skinCluster -e -lw false -wt 0 -ai cageOffJoint $skinCluster;

select $cageJoints;
sets -n asCageJoints;
sets -add FaceBuildingSets asCageJoints;

//Build the NoseRegion as this point, as we will use it before asFaceNose(), (in asFaceLipSide)
if ($hasBelowEye)
	{
	$posA=`xform -q -ws -t Nose`;
	$posB=`xform -q -ws -t NoseCorner`;
	asCreateFaceController "NoseRegion" "_M" 4;
	delete NoseRegionJoint_M;
	parent NoseRegionOffset_M SideReverse_M;
	setAttr NoseRegionOffset_M.s -type float3 1 1 1;
	scale -r -p 0 0 0 6 6 6 NoseRegion_M.cv[0:7];
	xform -ws -t 0 $posA[1] (($posA[2]+$posB[2])/2.0) NoseRegionOffset_M;

	$posA=`xform -q -ws -t NoseRegion_M.cv[1]`;
	$posB=`xform -q -ws -t NoseCorner`;
	$posC=`xform -q -ws -t Nose`;
	xform -ws -t 0 ($posC[1]-($posB[0]*1.5)) $posA[2] NoseRegion_M.cv[1];

	$posA=`xform -q -ws -t NoseRegion_M.cv[5]`;
	$posB=`xform -q -ws -t NoseUnder`;
	$posC=`xform -q -ws -t NoseCorner`;
	xform -ws -t 0 $posB[1] $posA[2] NoseRegion_M.cv[5];
	xform -ws -t ($posC[0]/ 2.0) $posB[1] $posA[2] NoseRegion_M.cv[4];
	xform -ws -t ($posC[0]/-2.0) $posB[1] $posA[2] NoseRegion_M.cv[6];

	$posA=`xform -q -ws -t NoseRegion_M.cv[3]`;
	$posB=`xform -q -ws -t NoseCorner`;
	xform -ws -t ($posB[0]* 1.2) ($posB[1]+($posB[0]/-5.0)) $posA[2] NoseRegion_M.cv[3];
	xform -ws -t ($posB[0]*-1.2) ($posB[1]+($posB[0]/-5.0)) $posA[2] NoseRegion_M.cv[7];

	xform -ws -t ($posB[0]* 0.65) ($posB[1]+($posB[0]/-2.0)) $posA[2] NoseRegion_M.cv[2];
	xform -ws -t ($posB[0]*-0.65) ($posB[1]+($posB[0]/-2.0)) $posA[2] NoseRegion_M.cv[0];
	parent NostrilOffset_R NostrilOffset_L NoseSideOffset_R NoseSideOffset_L NoseOffset_M NoseUnderOffset_M NoseBridgeOffset_M
		NoseCornerOffset_R NoseCornerOffset_L NoseRegion_M;
	}

//hide EyeBrow Ctrls for now
$tempString=`listRelatives -ad -type transform OnFacecontrols`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "EyeBrow*Offset_*"`)
		setAttr ($tempString[$i]+".v") 0;

setAttr ($geometry+".v") 0;

select -cl;
}

global proc asFaceCageToSkin ()
{
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $hasAboveEye=`objExists EyeBrowInner`;
int $hasBelowEye=`objExists upperLipMainCurve`;
float $value;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $side,$leftSuffix,$InnerOuter;
string $tempString[],$tempString2[];

if (!$hasAboveEye && !$hasBelowEye)//skip
	return;

if ($multiSkinClusters)
	$skinCluster="CageSC";

setAttr ($geometry+".v") 1;
setAttr asCage.v 0;

//CageLayer
duplicate -n CageLayer templateLayer;
select `listConnections -s 1 -d 0 -type joint $skinCluster` CageLayer;
if ($hasBelowEye)
	select -d `listRelatives -ad -type joint LipJoints_M`;
select -add cageOffJoint;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] CageLayerSC;
parent -w CageLayer;
if ($multiSkinClusters)
	skinPercent -tv cageOffJoint 1 CageLayerSC CageLayer;
else
	{
	select $geometry CageLayer;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

asFaceCheekCageSmoothUpdate;

//save eyeBrowArea & eyeBrowLineArea set
if ($hasAboveEye)
	{
	select -cl;
	sets -em -n eyeBrowArea;
	sets -em -n eyeBrowLineArea;
	sets -add FaceAreas eyeBrowLineArea eyeBrowArea;
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$leftSuffix="";}
		else {$side="_L";$leftSuffix="Left";}

		for ($d=0;$d<2;$d++)
			{
			if ($d==0) {$InnerOuter="Inner";$innerouter="inner";}
			if ($d==1) {$InnerOuter="Outer";$innerouter="outer";}

			skinCluster -e -siv ("EyeBrow"+$InnerOuter+"Joint"+$side) $skinCluster;
			sets -add eyeBrowArea `ls -sl`;
			sets -add eyeBrowLineArea `asGetFaceFitSelection ("EyeBrow"+$InnerOuter+$leftSuffix)`;
			}

		for ($i=1;$i<4;$i++)
			if (`objExists ("EyeBrowMid"+$i+"Joint"+$side)`)
				{
				skinCluster -e -siv ("EyeBrowMid"+$i+"Joint"+$side) $skinCluster;
				sets -add eyeBrowArea `ls -sl`;
				sets -add eyeBrowLineArea `asGetFaceFitSelection ("EyeBrowMid"+$i+$leftSuffix)`;
				}
		}
	}

if ($hasBelowEye)
	{
	setAttr LipRegionOffset_M.v 1;
	setAttr LipOffset_R.v 1;
	setAttr LipOffset_L.v 1;
	setAttr upperLipOffset_M.v 1;
	setAttr lowerLipOffset_M.v 1;
	}

select -cl;
}

global proc asFaceCheekCageSmoothUpdate ()
{
global string $gMainProgressBar;
global string $gSelect;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $numSmoo=`intField -q -v faceCageIntField`;
int $numIterations=`intField -q -v lipFalloffIterationsIntField`;
float $lipOffWeight,$sumWeight,$eyeCnrTy;
float $values[],$pos[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $eyeLash=`textField -q -tx asFaceEyelashTextField`;
string $cageOffJoint="cageOffJoint";
string $cageJoints[]=`sets -q asCageJoints`;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[],$infs[],$maskNoPeriVtxs[];
string $areas[]={"lipFalloffArea","eyeLidOuterArea","eyeLidOuterAreaLeft"};

select -cl;
for ($i=0;$i<size($areas);$i++)
	if (`objExists $areas[$i]`)
	select -add $areas[$i];
$tempString=`ls -sl -fl`;
progressBar -e -st "Cage weights" -bp -ii 0 -min 0 -max `size($tempString)` $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

//find $maskNoPeriVtxs
eval ("select "+`getAttr FaceFitSkeleton.Mask`);
if ($eyeLash!="") eval ("select -d "+$eyeLash);//exlude eyelashes
ConvertSelectionToVertices;
//exlude perimeter
$tempString=`ls -sl`;
ConvertSelectionToVertexPerimeter;
$tempString2=`ls -sl`;
select $tempString;
select -d $tempString2;
$maskNoPeriVtxs=`ls -sl`;

//Above/Below Eyes Skipping
if (!`asFaceIncludeBelowEyes`)
	{
	eval ("select "+`asGetFaceFitSelection ("ForeHeadAreaMesh")`);
	eval ("select -add "+`asGetFaceFitSelection ("ForeHeadAreaMeshLeft")`);
	$maskNoPeriVtxs=`ls -sl`;
	}
if (!`asFaceIncludeAboveEyes`)
	{
	//just skip above a certain height
	$pos=`xform -q -ws -t upperEyeLidMainCurve.cv[0]`;
	$eyeCnrTy=$pos[1];
	select $maskNoPeriVtxs;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		if ($pos[1]>$eyeCnrTy)
			select -d $tempString[$i];
		}
	$maskNoPeriVtxs=`ls -sl`;
	}

if ($multiSkinClusters)//swap weight from Head-M to cageOffJoint
	{
	$tempString=`listConnections -s 1 -d 0 -type joint asCageSC`;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
	setAttr Head_M.lockInfluenceWeights 0;
	setAttr cageOffJoint.lockInfluenceWeights 0;
	skinPercent -tv Head_M 0 asCageSC asCage;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
	}

//transfer weights from Cage to CageLayer
select `asobjSetCast "" $maskNoPeriVtxs CageLayer`;
$tempString=`ls -sl -fl`;
select asCage $tempString; 
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//copySkinWeights seems to not yet work on sel vtxs only (when spesifying -ss & -ds), so manually fix
//if ($multiSkinClusters)

//apply the smoothing on the CageLayer
setAttr CageLayer.v 1;
select CageLayer;
ArtPaintSkinWeightsTool; 
//artAttrSkinToolScript 4;//Maya2018(pre2018.1) needs this
//some systems needs this (not sure why)
source artAttrSkinJointMenu;
for ($a=0;$a<$numSmoo;$a++)
	for ($i=0;$i<size($cageJoints);$i++)
		{
		if (`gmatch $cageJoints[$i] "EyeBrow*"`)
			continue;
		artAttrSkinPaintCtx -e -sao smooth -influence $cageJoints[$i] artAttrSkinContext;
		artSkinInflListChanging $cageJoints[$i] 1;
		artSkinInflListChanged artAttrSkinPaintCtx;
		refresh;
		artFloodSurfaces;
		refresh;
		}
setToolTo $gSelect;
setAttr CageLayer.v 0;

if ($multiSkinClusters)
	{
	$skinCluster="CageSC";
	$cageOffJoint="MultiSkinClustersFaceCageJoint_M";
	}


//Copy weights from CageLayer to $geometry
select `asobjSetCast "" $maskNoPeriVtxs CageLayer`;
select -add $maskNoPeriVtxs;
if (`objExists lipArea`) select -d lipArea;
if (`objExists eyeLidArea`) select -d eyeLidArea;
if (`objExists eyeLidAreaLeft`) select -d eyeLidAreaLeft;

if ($multiSkinClusters)
	{
	copySkinWeights -ss CageLayerSC -ds CageSC -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	//copySkinWeights seems to not yet work on sel vtxs only (when spesifying -ss & -ds), so manually fix
	select eyeLidArea eyeLidAreaLeft eyeLidMainArea;
	skinPercent -tv MultiSkinClustersFaceCageJoint_M 1 CageSC;
	}
else
	{
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

	//Then do the `balanced` transfer of Lip (and eyelid) Falloff Areas, maybe skip eyeLid considering clariee
	//select lipFalloffArea eyeLidOuterArea eyeLidOuterAreaLeft;
	select -cl;
	if (`objExists lipFalloffArea`)
		select -add lipFalloffArea;
	$tempString=`ls -sl -fl`;
	$tempString2=`asobjSetCast "" $tempString LipFalloffLayer`;
	//$tempString3=`asobjSetCast "" $tempString CageLayer`;
	select -cl;
	for ($i=0;$i<size($tempString);$i++)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$lipOffWeight=`skinPercent -t lipOffJoint -q -v LipFalloffLayerSC $tempString2[$i]`;
		$infs=`skinPercent -ignoreBelow 0.01 -q -t LipFalloffLayerSC $tempString2[$i]`;
		$values=`skinPercent -ignoreBelow 0.01 -q -v LipFalloffLayerSC $tempString2[$i]`;
		$cmd="skinPercent -tv "+$cageOffJoint+" 0";
		for ($y=0;$y<size($infs);$y++)
			{
			if ($infs[$y]=="lipOffJoint")
				continue;
			$weight=$values[$y];
			$cmd+=" -tv "+$infs[$y]+" "+$weight;
			}
		$cmd+=" "+$skinCluster+" "+$tempString[$i];
		eval ($cmd);
		}
	}

//some areas just outside of eyeLidOuterArea might still have some cageOffJoint weights, flip these to zero
//this was commented out in v 6.250 (as it is not good for multiSkinCluster), but re-added in v6.2706 as it`s needed for non-multiSkinCluster)
if (!$multiSkinClusters)
	skinPercent -tv $cageOffJoint 0 $skinCluster $geometry;

select $sel;
}

global proc asFaceFaceCageFinish ()
{
string $deleteObjs[];

if (!`objExists upperLipMainCurve` && !`objExists EyeBrowInner`)//skip
	return;

if (`attributeExists FaceCageFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln FaceCageFinish -at bool -dv true FaceBuildInProgress;

parent asCage FaceBuildInProgressHidden;
$deleteObjs={"CageLayer","LipFalloffLayer"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asFaceEyeBrow ()
{
int $b;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
float $dist;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $pos[],$posA[],$posB[],$outerUpDownTowardsPos[];
string $curveCmd,$side,$leftSuffix,$eyeBrowInnerVtx,$eyeBrowOuterVtx;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $eyeBrow=`textField -q -tx asFaceEyebrowTextField`;
string $tempString[],$tempString2[],$tempString3[],$eyeBrowGeos[],$outSideForeHeadVtxs[];

asFaceFaceCageFinish;

if (!`objExists EyeBrowInner`)//skip
	return;

if ($multiSkinClusters)
	{
	$skinCluster="CageSC";
	$headJoint="MultiSkinClustersFaceCageJoint_M";
	}

asFaceHideControllers 1;
//show EyeBrow Ctrls for now
$tempString=`listRelatives -ad -type transform OnFacecontrols`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "EyeBrow*Offset_*"`)
		setAttr ($tempString[$i]+".v") 1;
setAttr ctrlBoxBrow_R.v 1;
setAttr ctrlBoxBrow_L.v 1;
if (`objExists NoseCreaseOffset_M`)
	setAttr NoseCreaseOffset_M.v 1;
setAttr ctrlBox.RegionsCtrlVis 1;

//find $outerUpDownTowardsPos for later usage
if (`objExists tempPointOnCurveInfo`) delete tempPointOnCurveInfo;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f ForeHeadTopToSideCurve.worldSpace[0] tempPointOnCurveInfo.inputCurve;

setAttr tempPointOnCurveInfo.parameter 0.65;
$outerUpDownTowardsPos=`getAttr tempPointOnCurveInfo.position`;
createNode -n TempPos transform;
createNode -n TempPos2 transform;
xform -ws -t $outerUpDownTowardsPos[0] $outerUpDownTowardsPos[1] $outerUpDownTowardsPos[2] TempPos;
delete `pointConstraint EyeBrowOuter TempPos TempPos2`;
$outerUpDownTowardsPos=`xform -q -ws -t TempPos2`;
delete TempPos TempPos2 tempPointOnCurveInfo;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$rightLeft="Right";$leftSuffix="";}
	else {$side="_L";$rightLeft="Left";$leftSuffix="Left";}

	//EyeBrowRegion
	asCreateFaceController "EyeBrowRegion" $side 4;
//	setAttr ("EyeBrowRegion"+$side+"Shape.overrideColor") 14;
	asFaceHalfMoonCurve ("EyeBrowRegion"+$side) 90;
	delete ("EyeBrowRegionJoint"+$side);
	parent ("EyeBrowRegionOffset"+$side) ("SideReverse"+$side);
	xform -os -ro 0 0 0 -s 1 1 1 ("EyeBrowRegionOffset"+$side);
	setAttr ("EyeBrowRegionOffset"+$side+".s") -type float3 1 1 1;
	$posA=`xform -q -ws -t EyeBrowInner`;
	$posB=`xform -q -ws -t EyeBrowOuter`;
	$pos[0]=($posA[0]+$posB[0])/(2.0*$b);$pos[1]=($posA[1]+$posB[1])/2.0;$pos[2]=($posA[2]+$posB[2])/2.0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeBrowRegionOffset"+$side);
	$dist=$posA[0]-$posB[0];
	scale -r -p $pos[0] $pos[1] $pos[2] ($scale/$dist) ($scale/($dist*2)) ($scale/$dist) ("EyeBrowRegion"+$side+".cv[0:7]");
	asFacePlaceCtrlByProjection ("EyeBrowRegion"+$side);

	createNode -n ("EyeBrowRegionConstrainTo"+$side) transform;
	parent ("EyeBrowRegionConstrainTo"+$side) ("EyeBrowRegion"+$side);
	xform -os -t 0 0 0 -s 1 1 1 ("EyeBrowRegionConstrainTo"+$side);
	$pos=`xform -q -ws -t ("EyeBrowInner"+$leftSuffix)`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeBrowRegionConstrainTo"+$side);
	}

//Constrained
//v 6.0531 removed asFaceAddConstrained from EyeBrowRegion to ctrls, and restored old asFaceAddConstrained
/*
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	asFaceAddConstrained ("EyeBrowInner"+$side) ("EyeBrowRegion"+$side) ("FaceStatic"+$side) 10;

	if (`objExists ("EyeBrowMid1"+$side)`) asFaceAddConstrained ("EyeBrowMid1"+$side) ("EyeBrowRegion"+$side) ("FaceStatic"+$side) 10;
	if (`objExists ("EyeBrowMid2"+$side)`) asFaceAddConstrained ("EyeBrowMid2"+$side) ("EyeBrowRegion"+$side) ("FaceStatic"+$side) 10;
	if (`objExists ("EyeBrowMid3"+$side)`) asFaceAddConstrained ("EyeBrowMid3"+$side) ("EyeBrowRegion"+$side) ("FaceStatic"+$side) 10;

	asFaceAddConstrained ("EyeBrowOuter"+$side) ("EyeBrowRegion"+$side) ("FaceStatic"+$side) 10;
	}
*/
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (`objExists ("EyeBrowMid1"+$side)`)
		asFaceAddConstrained ("EyeBrowMid1"+$side) ("EyeBrowInner"+$side) ("EyeBrowRegion"+$side) 3;
	if (`objExists ("EyeBrowMid3"+$side)`)
		{
		asFaceAddConstrained ("EyeBrowMid3"+$side) ("EyeBrowOuter"+$side) ("EyeBrowRegion"+$side) 3;
		//in case there is a Mid3, also constrain Mid2 to get same behaviour from all Mids
		asFaceAddConstrained ("EyeBrowMid2"+$side) ("EyeBrowOuter"+$side) ("EyeBrowRegion"+$side) 1;
		}
	else if (`objExists ("EyeBrowMid2"+$side)`)
		asFaceAddConstrained ("EyeBrowMid2"+$side) ("EyeBrowOuter"+$side) ("EyeBrowRegion"+$side) 3;

	parent ("EyeBrowInnerOffset"+$side) ("EyeBrowOuterOffset"+$side) ("EyeBrowRegion"+$side);
	$pos=`xform -q -ws -t ("EyeBrowInner"+$side)`;
	scale -r -p $pos[0] $pos[1] $pos[2] 0.6 0.6 0.6 ("EyeBrowInner"+$side+".cv[0:99]");
	}


//EyeBrowCenter_M stay in middle of Left/Right EyeBrowInner
addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 EyeBrowCenter_M;
createNode -n EyeBrowCenterFollow_M -p EyeBrowCenterOffset_M transform;
createNode -n EyeBrowCenterFollowUnitConversion unitConversion;
setAttr EyeBrowCenterFollowUnitConversion.conversionFactor 0.1;
connectAttr EyeBrowCenter_M.follow EyeBrowCenterFollowUnitConversion.input;
parent SDKEyeBrowCenter_M EyeBrowCenterFollow_M;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	createNode -n ("EyeBrowCenterBlenderPMA"+$side) plusMinusAverage;
	connectAttr ("EyeBrowInner"+$side+".t")    ("EyeBrowCenterBlenderPMA"+$side+".input3D[0]");
	connectAttr ("SDKEyeBrowInner"+$side+".t") ("EyeBrowCenterBlenderPMA"+$side+".input3D[1]");
	connectAttr ("EyeBrowRegion"+$side+".t") ("EyeBrowCenterBlenderPMA"+$side+".input3D[2]");
	connectAttr ("SDKEyeBrowRegion"+$side+".t") ("EyeBrowCenterBlenderPMA"+$side+".input3D[3]");
	}
createNode -n ("EyeBrowCenterBlenderPMA_M") plusMinusAverage;
setAttr ("EyeBrowCenterBlenderPMA_M.operation") 3;
connectAttr ("EyeBrowCenterBlenderPMA_R.output3D") ("EyeBrowCenterBlenderPMA_M.input3D[0]");
connectAttr ("EyeBrowCenterBlenderPMA_L.output3D") ("EyeBrowCenterBlenderPMA_M.input3D[1]");
createNode -n ("EyeBrowCenterBlenderMPD_M") multiplyDivide;
connectAttr ("EyeBrowCenterBlenderPMA_M.output3Dy") ("EyeBrowCenterBlenderMPD_M.input1Y");
connectAttr ("EyeBrowCenterBlenderPMA_M.output3Dz") ("EyeBrowCenterBlenderMPD_M.input1Z");
connectAttr EyeBrowCenterFollowUnitConversion.output ("EyeBrowCenterBlenderMPD_M.input2Y");
connectAttr EyeBrowCenterFollowUnitConversion.output ("EyeBrowCenterBlenderMPD_M.input2Z");
connectAttr ("EyeBrowCenterBlenderMPD_M.outputY") ("EyeBrowCenterFollow_M.ty");
connectAttr ("EyeBrowCenterBlenderMPD_M.outputZ") ("EyeBrowCenterFollow_M.tz");

//DrivingSystem
$posA=`xform -q -ws -t EyeBrowInner`;
$posB=`xform -q -ws -t FitEyeBall`;
$dist=(($posA[1]-$posB[1])/$ctrlScale)/2.0;
if ($dist<0.25) $dist=0.25;
if ($dist>1.0) $dist=1.0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (`objExists EyeBrowInner_R`)
		{
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowRegion"+$side+".ty") 1 $dist;
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowRegion"+$side+".ty") -1 ($dist*-1);
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowInner"+$side+".ty") 1 $dist;
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowInner"+$side+".ty") -1 ($dist*-1);
		}
	if (`objExists EyeBrowMid1_R`)
		{
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid1"+$side+".ty") 1 ($dist*0.3);
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid1"+$side+".ty") -1 ($dist*-0.3);
		}
	if (`objExists EyeBrowMid2_R`)
		{
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid2"+$side+".ty") 1 ($dist*0.25);
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid2"+$side+".ty") -1 ($dist*-0.25);
		}

	if (`objExists NoseCrease_M`)
		{
		asDsSdk ("ctrlBrow"+$side+".tx") SDKNoseCrease_M.ty 1 ($dist*0.02);
		asDsSdk ("ctrlBrow"+$side+".ty") SDKNoseCrease_M.ty 1 ($dist*0.02);
		}
	}

//squeeze
$curveCmd="curve -d 1 -n EyeBrowCurve ";
$pos=`xform -q -ws -t EyeBrowCenter`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowInner`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
if (`objExists EyeBrowMid1_R`) {$pos=`xform -q -ws -t EyeBrowMid1_R`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];}
if (`objExists EyeBrowMid2_R`) {$pos=`xform -q -ws -t EyeBrowMid2_R`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];}
if (`objExists EyeBrowMid3_R`) {$pos=`xform -q -ws -t EyeBrowMid3_R`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];}
$pos=`xform -q -ws -t EyeBrowOuter`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
eval ($curveCmd);
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 0 -d 3 -tol 0.01 EyeBrowCurve;
createNode -n TempPos transform;
createNode -n tempMotionPath motionPath;
setAttr tempMotionPath.fractionMode 1;
connectAttr EyeBrowCurve.worldSpace tempMotionPath.geometryPath;
connectAttr tempMotionPath.allCoordinates TempPos.t;
connectAttr tempMotionPath.rotate TempPos.rotate;
setAttr tempMotionPath.worldUpType 0;
setAttr tempMotionPath.upAxis 1;
setAttr tempMotionPath.frontAxis 0;
setAttr tempMotionPath.inverseFront 1;
createNode -n tempNearestPointOnCurve nearestPointOnCurve;
connectAttr -f EyeBrowCurve.worldSpace[0] tempNearestPointOnCurve.inputCurve;
createNode -n TempPos2 transform;
connectAttr TempPos2.t tempNearestPointOnCurve.inPosition;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	addAttr -k 1 -ln squeeze -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
	asEnsureOutputBlendWeighted ("ctrlBrow"+$side+".squeeze");
	$pos=`xform -q -ws -t EyeBrowInner_R`;
//	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowCenter_M.ty") 10 (($pos[0]/$ctrlScale)*-0.05);

	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowInner"+$side+".tx") 10 (($pos[0]/$ctrlScale)*0.50);
	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowInner"+$side+".ty") 10 (($pos[0]/$ctrlScale)*0.25);
//	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowInner"+$side+".sx") 10 0.25;

	clear $tempString;
	$tempString={"EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowOuter"};
	for ($i=0;$i<size($tempString);$i++)
		{
		if (!`objExists ($tempString[$i]+$side)`)
			continue;
		asAlign TempPos2 ($tempString[$i]+"_R") 1 0 0 0;
		delete `geometryConstraint EyeBrowCurve TempPos2`;
//		refresh;
		$percentage=`getAttr tempNearestPointOnCurve.parameter`;
		setAttr "tempMotionPath.uValue" $percentage;
		$rot[1]=`getAttr TempPos.ry`;
		setAttr "tempMotionPath.uValue" ($percentage-0.1);
		$rot[1]=($rot[1]-`getAttr TempPos.ry`);
		$pos=`xform -q -ws -t TempPos`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($tempString[$i]+"_R");
		$pos=`getAttr ($tempString[$i]+"_R.t")`;
		setAttr ($tempString[$i]+"_R.t") 0 0 0;
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".tx") 10 $pos[0];
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".ty") 10 $pos[1];
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".tz") 10 $pos[2];
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".ry") 10 $rot[1];
		}
	}
delete TempPos TempPos2 tempNearestPointOnCurve EyeBrowCurve;

//outerUpDown
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	addAttr -k 1 -ln outerUpDown -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
	asEnsureOutputBlendWeighted ("ctrlBrow"+$side+".outerUpDown");
	xform -ws -t $outerUpDownTowardsPos[0] $outerUpDownTowardsPos[1] $outerUpDownTowardsPos[2] EyeBrowOuter_R;
	$pos=`getAttr EyeBrowOuter_R.t`;
	setAttr EyeBrowOuter_R.t 0 0 0;
	clear $tempString;
	$tempString={"EyeBrowInner","EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowOuter"};
	for ($i=0;$i<size($tempString);$i++)
		{
		if (!`objExists ($tempString[$i]+$side)`)
			continue;
		$percentage=`smoothstep 0 1 (0.2*($i+1))`;
		asDsSdk ("ctrlBrow"+$side+".outerUpDown") ("SDK"+$tempString[$i]+$side+".tx") 10 ($pos[0]*$percentage);
		asDsSdk ("ctrlBrow"+$side+".outerUpDown") ("SDK"+$tempString[$i]+$side+".ty") 10 ($pos[1]*$percentage);
		asDsSdk ("ctrlBrow"+$side+".outerUpDown") ("SDK"+$tempString[$i]+$side+".tz") 10 ($pos[2]*$percentage);
		}
	}

//pruneOff centerVtxs
skinCluster -e -selectInfluenceVerts EyeBrowCenterJoint_M $skinCluster;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] "*.*"`)
		continue;
	if (`skinPercent -t $headJoint -q $skinCluster $tempString[$i]`>0.99)
		skinPercent -tv $headJoint 1 $skinCluster $tempString[$i];
	}

//Find a way to dermind vtxs between EyeBrowLine & upperEyeLidOuterCurve, and Hammer
//hint start with upperEyeLidOuterCurve, the grow and Deselect outside ForeHeadArea, once reached EyeBrow, Bingo
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	eval ("select "+`asGetFaceFitSelection ("EyeBrowInner"+$leftSuffix)`);$tempString=`ls -sl -fl`;$eyeBrowInnerVtx=$tempString[0];
	eval ("select "+`asGetFaceFitSelection ("EyeBrowOuter"+$leftSuffix)`);$tempString=`ls -sl -fl`;$eyeBrowOuterVtx=$tempString[0];

	eval ("select "+`asGetFaceFitSelection ("ForeHeadAreaMesh"+$leftSuffix)`);
	asInvertSelection;
	$outSideForeHeadVtxs=`ls -sl`;
	eval ("select "+`asGetFaceFitSelection ("upperEyeLidOuterCurve"+$leftSuffix)`);
	$tempString2=`ls -sl`;

	for ($i=0;$i<25;$i++)
		{
		$tempString3=`ls -sl -fl`;
		if (`stringArrayCount $eyeBrowInnerVtx $tempString3` || `stringArrayCount $eyeBrowOuterVtx $tempString3`)
			break;
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $outSideForeHeadVtxs;
		}
	eval ("select "+`asGetFaceFitSelection ("upperEyeLidOuterCurve"+$leftSuffix)`);
	for ($y=0;$y<($i-1);$y++)
		{
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $outSideForeHeadVtxs;
		}
	select -d $tempString2;
	if (size(`ls -sl`))
//		weightHammerVerts;
		asWeightHammerVertsMS 5 $skinCluster;
	}


//attach eyeBrow objects
$eyeBrowGeos=`stringToStringArray $eyeBrow " "`;
for ($i=0;$i<size($eyeBrowGeos);$i++)
	{
	$sc=`asGetSkinCluster $eyeBrowGeos[$i]`;
	if ($sc=="")
		error ("Did not find skinCluster on eyeBrow object:\""+$eyeBrowGeos[$i]+"\"");

	if ($multiSkinClusters)
		{
		if (!`objExists MultiSkinClustersFaceEyeBrowJoint_M`)
			{
			createNode -n MultiSkinClustersFaceEyeBrowJoint_M -p FaceJoint_M joint;
			setAttr MultiSkinClustersFaceEyeBrowJoint_M.drawStyle 2;
			setAttr -l 1 MultiSkinClustersFaceEyeBrowJoint_M.inheritsTransform 0;
			}
		select MultiSkinClustersFaceEyeBrowJoint_M $eyeBrowGeos[$i];
		$tempString=`skinCluster -multi 1 -frontOfChain -toSelectedBones`;
		$sc=`rename $tempString[0] EyeBrowSC`;
		}


	if ($sc==$skinCluster)
		{//eyebrow choosen, was "faces" of $geoemtry (polyMerged eyeBrow and face)
		select asCage $eyeBrowGeos[$i];
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		continue;
		}
	$cmd="skinCluster -e -dr 4 -lw false -wt 0 -ai EyeBrowCenterJoint_M";
	$tempString={"EyeBrowInner","EyeBrowOuter","EyeBrowMid1","EyeBrowMid2","EyeBrowMid3"};
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($y=0;$y<size($tempString);$y++)
			if (`objExists $tempString[$y]`)
				$cmd+=" -ai "+$tempString[$y]+"Joint"+$side;
		}
	$cmd+=" "+$sc;
	eval ($cmd);
	if (!$multiSkinClusters)
		skinPercent -tv `textField -q -tx asFaceHeadJointTextField` 0 $sc $eyeBrowGeos[$i];//on clairee this is needed for the next copSkin to work(m2019)
	select $geometry $eyeBrowGeos[$i];
	if ($multiSkinClusters)
		copySkinWeights -ss CageSC -ds $sc -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	else
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	select $eyeBrowGeos[$i];
	}
select -cl;
}

global proc asFaceSquint ()
{
int $simplerEyeLid=`checkBox -q -v asFaceSimplerEyeLidCheckBox`;
float $dist,$factor;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
float $posA[],$posB[];
string $tempString[];

//multiply blink & squint, so they mix if both applied
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	createNode -n ("eyeLidBlinkSquintMPD"+$side) multiplyDivide;
	connectAttr ("SDKEyeRegion"+$side+".sy") ("eyeLidBlinkSquintMPD"+$side+".input1X");
	connectAttr ("SDKEyeRegion"+$side+".sy") ("eyeLidBlinkSquintMPD"+$side+".input2X");
	connectAttr ("eyeLidBlinkSquintMPD"+$side+".outputX") ("upperLidMainBS"+$side+".upperLidCurveBlink"+$side);
	connectAttr ("eyeLidBlinkSquintMPD"+$side+".outputX") ("lowerLidMainBS"+$side+".lowerLidCurveBlink"+$side);
	}

//determine eye-opening height, and Squint will be relative to this height
$posA=`xform -q -ws -t upperLid_R`;
$posB=`xform -q -ws -t lowerLid_R`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
$factor=($dist/$ctrlScale)*0.75;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	addAttr -ln squint -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 0 ("ctrlEye"+$side);
	asEnsureOutputBlendWeighted ("ctrlEye"+$side+".squint");
	}

asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;

//fit-anim
asFaceFitAnim ctrlEye_R.squint 10;
asFaceFitAnim ctrlEye_L.squint 10;
if (`asFaceIncludeAboveEyes`)
	{
	asFaceFitAnim EyeRegion_R.sy 0.75;
	asFaceFitAnim EyeBrowRegion_R.ty (-0.75*$factor);
	}
asFaceFitAnim upperLid_R.ty (-0.4*$factor);
asFaceFitAnim lowerLid_R.tx (-0.4*$factor);
asFaceFitAnim lowerLid_R.ty (0.525*$factor);
asFaceFitAnim outerLid_R.tx (-0.15*$factor);
//asFaceFitAnim EyeBrowOuter_R.ty (-0.15*$factor);
if (!$simplerEyeLid)
	{
	asFaceFitAnim upperLidOuter_R.ty (-0.2*$factor);
	asFaceFitAnim outerLidOuter_R.sy 0.5;
	asFaceFitAnim innerLidOuter_R.sy 0.5;
	}
//lowerLidOuter now also in $simplerEyeLid
asFaceFitAnim lowerLidOuter_R.tx (-0.07*$factor);
asFaceFitAnim lowerLidOuter_R.ty (0.07*$factor);

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceSquintFinish ()
{
if (`attributeExists SquintFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln SquintFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlEye _RL squint 10;
asFaceHideControllers 1;
setAttr ctrlBoxEye_R.v 1;
setAttr ctrlBoxEye_L.v 1;
}

global proc asFaceSmilePull ()
{
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $opm=`asGetOpm`;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
float $falloffRadius,$pullDist;
float $posA[],$posB[],$lipPulledPos[],$smileBulgePulledPos[],$frownBulgePulledPos[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $tempString[];

asFaceSquintFinish;

if (!`objExists upperLipMainCurve`)//skip
	return;

//ZygomaticusMajor
if (!`objExists FaceMuscles`) createNode -n FaceMuscles -p FaceBuildInProgress transform;
if (!`objExists FaceMusclesLayer`) createDisplayLayer -name FaceMusclesLayer;
createNode -n ZygomaticusMajor -p FaceMuscles transform;
$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r ($scale/25.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] ZygomaticusMajor_curve1;
setAttr ZygomaticusMajor_curve1.v 0;
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t upperEyeLidOuterCurve.cv[99]`;
spaceLocator -n ZygomaticusMajorPosition1;
parent ZygomaticusMajorPosition1 ZygomaticusMajor;
setAttr ZygomaticusMajorPosition1.v 0;
setAttr ZygomaticusMajorPosition1.overrideEnabled 1;
setAttr ZygomaticusMajorPosition1.overrideColor 17;
setAttr ZygomaticusMajorPosition1Shape.localScale -type float3 ($scale/15.0) ($scale/15.0) ($scale/15.0);

//instead of half-way btw JawPivot and eyeCurve, slide towards JawPivot, until 45 degrees
createNode -n tempXform -p Lip_R transform;
createNode -n tempXform2 transform;
xform -ws -t $posB[0] $posB[1] $posB[2] tempXform2;
pointConstraint tempXform2 JawPivot tempXform;
geometryConstraint $geometry tempXform;
setAttr "tempXform.displayLocalAxis" 1;
for ($i=0;$i<101;$i++)
	{
	setAttr tempXform_pointConstraint1.tempXform2W0 (1-($i/100.0));
	setAttr tempXform_pointConstraint1.JawPivotW1 ($i/100.0);
	refresh;
	if (`getAttr tempXform.tx`>`getAttr tempXform.ty`)
		break;
	}
$posB=`xform -q -ws -t tempXform`;
delete tempXform tempXform2;

xform -ws -t $posB[0] $posB[1] $posB[2] ZygomaticusMajorPosition1;
//delete `geometryConstraint $geometry ZygomaticusMajorPosition1`;
parent -r ZygomaticusMajor_curve1 ZygomaticusMajorPosition1;
delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpObject Lip_R Lip_R ZygomaticusMajorPosition1`;
duplicate -n ZygomaticusMajorPosition2 ZygomaticusMajorPosition1;
rename ZygomaticusMajorPosition2|ZygomaticusMajor_curve1 ZygomaticusMajor_curve2;
duplicate -n ZygomaticusMajorPosition3 ZygomaticusMajorPosition1;
rename ZygomaticusMajorPosition3|ZygomaticusMajor_curve1 ZygomaticusMajor_curve3;
setAttr ZygomaticusMajor_curve1.scaleX 0;
setAttr ZygomaticusMajor_curve2.scaleX 0.5;
setAttr ZygomaticusMajor_curve3.scaleX 0;
$posA=`xform -q -ws -t ZygomaticusMajorPosition2`;
$posB=`xform -q -ws -t Lip_R`;
xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) ZygomaticusMajorPosition2;
xform -ws -t $posB[0] $posB[1] $posB[2] ZygomaticusMajorPosition3;
loft -n ZygomaticusMajor_loft -ch 1 -u 1 -c 0 -ar 0 -d 3 -ss 1 -rn 0 -po 0 -rsn true "ZygomaticusMajor_curve1" "ZygomaticusMajor_curve2" "ZygomaticusMajor_curve3";
sets -e -forceElement asFaceRedSG ZygomaticusMajor_loft;
parent ZygomaticusMajor_loft ZygomaticusMajor;
createNode -n ZygomaticusMajorScale -p ZygomaticusMajorPosition1 transform;
setKeyframe -t 0 -v 1 ZygomaticusMajorScale.s;
setKeyframe -t 30 -v 0.75 ZygomaticusMajorScale.s;
setKeyframe -t 0 -v 1 ZygomaticusMajorPosition2.s;
setKeyframe -t 30 -v 1.3 ZygomaticusMajorPosition2.s;
currentTime 0;
parentConstraint -mo ZygomaticusMajorScale ZygomaticusMajorPosition3;
parentConstraint ZygomaticusMajorPosition1 ZygomaticusMajorPosition3 ZygomaticusMajorPosition2;
parentConstraint -mo ZygomaticusMajorScale Lip_R;

//for showing ZygomaticusMajor
catchQuiet (`setAttr ($geometry+".overrideEnabled") 1`);
catchQuiet (`setAttr ($geometry+".overrideShading") 0`);
for ($i=0;$i<30;$i=$i+1)
	{
	currentTime $i;
	refresh;
	}
catchQuiet (`setAttr ($geometry+".overrideEnabled") 0`);
catchQuiet (`setAttr ($geometry+".overrideShading") 1`);
setAttr FaceMusclesLayer.v 0;
currentTime 0;

$tempString=`listRelatives -type joint -ad FaceJoint_M`;
$tempString[size($tempString)]="Face_M";
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists lockInfluenceWeights $tempString[$i]`)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
setAttr ($headJoint+".lockInfluenceWeights") 0;

//FitLoc placeholder for Lip (stores falloff attrs)
if (!`objExists Lip`)
	{
	$posA=`xform -q -ws -t Lip_R`;
	$posB=`xform -q -ws -t SmileBulge`;
	$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	//note this falloffRadius will be larger then the default, causing it to `pop` bigger.
	//it can be odd, but likly more correct
	createNode -n Lip -p LipSetup transform;
	asAlign Lip Lip_R 1 0 0 0;
	addAttr -k 1 -ln falloffRadius -at double -dv $falloffRadius Lip;
	if ($nonSymmetrical)
		{
		duplicate -n LipLeft Lip;
		asAlign LipLeft Lip_L 1 0 0 0;
		}
	}

createNode -n LipPulled -p Lip_R transform;
createNode -n SmileBulgePulled -p SmileBulge_R transform;
createNode -n FrownBulgePulled -p FrownBulge_R transform;
parent LipPulled SmileBulgePulled FrownBulgePulled ZygomaticusMajorScale;

asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;

currentTime 30;
parent LipPulled SDKLip_R;
parent SmileBulgePulled SDKSmileBulge_R;
parent FrownBulgePulled SDKFrownBulge_R;
//$lipPulledPos=`getAttr LipPulled.t`;
//change to pulled and attached to slide
if ($opm)
	{
	//get from OPM attr
	createNode -n tempTransform -p cornerLipAttach_R transform;
	parent tempTransform cornerLipOffset_R;
	$lipPulledPos=`getAttr tempTransform.t`;
	delete tempTransform;
	}
else
	$lipPulledPos=`getAttr cornerLipAttach_R.t`;
$smileBulgePulledPos=`getAttr SmileBulgePulled.t`;
$frownBulgePulledPos=`getAttr FrownBulgePulled.t`;
$pullDist=`mag<<$lipPulledPos[0],$lipPulledPos[1],$lipPulledPos[2]>>`;
delete Lip_R_parentConstraint1;
currentTime 0;

setAttr ctrlBoxMouthCorner_R.v 1;
setAttr ctrlBoxMouthCorner_L.v 1;

//create blendedAttr for mouthCorner X&Y (smile,frown,narrow)
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	//smile
	setAttr ("ctrlMouthCorner"+$side+".tx") 1;setAttr ("ctrlMouthCorner"+$side+".ty") 1;
	asCreateCustomBlendedAttribute {("ctrlMouthCorner"+$side+".tx"),("ctrlMouthCorner"+$side+".ty")} "smile";

	//frown
	setAttr ("ctrlMouthCorner"+$side+".tx") 1;setAttr ("ctrlMouthCorner"+$side+".ty") -1;
	asCreateCustomBlendedAttribute {("ctrlMouthCorner"+$side+".tx"),("ctrlMouthCorner"+$side+".ty")} "frown";

	//narrow-smile
	setAttr ("ctrlMouthCorner"+$side+".tx") -1;setAttr ("ctrlMouthCorner"+$side+".ty") 1;
	asCreateCustomBlendedAttribute {("ctrlMouthCorner"+$side+".tx"),("ctrlMouthCorner"+$side+".ty")} "narrowSmile";

	//narrow-frown
	setAttr ("ctrlMouthCorner"+$side+".tx") -1;setAttr ("ctrlMouthCorner"+$side+".ty") -1;
	asCreateCustomBlendedAttribute {("ctrlMouthCorner"+$side+".tx"),("ctrlMouthCorner"+$side+".ty")} "narrowFrown";
/*
	//narrow (just narrrow)
	setAttr ("ctrlMouthCorner"+$side+".tx") -1;setAttr ("ctrlMouthCorner"+$side+".ty") 0;
	asCreateCustomBlendedAttribute {("ctrlMouthCorner"+$side+".tx"),("ctrlMouthCorner"+$side+".ty")} "narrow";
*/
	setAttr ("ctrlMouthCorner"+$side+".tx") 0;setAttr ("ctrlMouthCorner"+$side+".ty") 0;
	}
setAttr ctrlMouthCorner_R.tx 1;setAttr ctrlMouthCorner_R.ty 1;

//fit-anim
asFaceFitAnim ctrlMouthCorner_R.tx 1;
asFaceFitAnim ctrlMouthCorner_R.ty 1;
asFaceFitAnim ctrlMouthCorner_L.tx 1;
asFaceFitAnim ctrlMouthCorner_L.ty 1;
asFaceFitAnim Lip_R 0;
asFaceFitAnim Lip_R.tx $lipPulledPos[0];
asFaceFitAnim Lip_R.ty $lipPulledPos[1];
asFaceFitAnim Lip_R.tz $lipPulledPos[2];

asFaceFitAnim SmileBulge_R 0;
asFaceFitAnim SmileBulge_R.tx ($smileBulgePulledPos[0]*0.8);
asFaceFitAnim SmileBulge_R.ty ($smileBulgePulledPos[1]*0.8);
asFaceFitAnim SmileBulge_R.tz (0.33*$pullDist);

asFaceFitAnim FrownBulge_R 0;
asFaceFitAnim FrownBulge_R.tx ($frownBulgePulledPos[0]*0.7);
asFaceFitAnim FrownBulge_R.ty ($frownBulgePulledPos[1]*0.7);
asFaceFitAnim FrownBulge_R.tz (0.212*$pullDist);

//Maybe No CheekRaiser and No lowerLidOuter, as they look add when Driven by ctrlMouthCorner_R.tx
//Maybe re-add CheekRaiser again, e.g powder neeeds it, and ctrlMouthCorner_R mixed attrs now seems to no longer be used
//No longer using CheekRaiser, so use lowerLidOuter_R
if (`objExists lowerLidOuter_R`)
	{
	asFaceFitAnim lowerLidOuter_R 0;
	asFaceFitAnim lowerLidOuter_R.tx ($frownBulgePulledPos[0]*0.0075);
	asFaceFitAnim lowerLidOuter_R.ty ($frownBulgePulledPos[1]*0.025);
	asFaceFitAnim lowerLidOuter_R.tz (0.1*$pullDist);
	}

asFaceFitAnim CheekBone_R 0;
asFaceFitAnim CheekBone_R.tx ($frownBulgePulledPos[0]*0.025);
asFaceFitAnim CheekBone_R.ty ($frownBulgePulledPos[1]*0.1);
asFaceFitAnim CheekBone_R.tz (0.1*$pullDist);

asFaceFitAnim Cheek_R 0;
asFaceFitAnim Cheek_R.tx ($frownBulgePulledPos[0]*0.1);
asFaceFitAnim Cheek_R.ty ($frownBulgePulledPos[1]*0.25);
asFaceFitAnim Cheek_R.tz (0.3*$pullDist);

asFaceFitAnim NoseCorner_R 0;
asFaceFitAnim NoseCorner_R.tx ($frownBulgePulledPos[0]*0.1);
asFaceFitAnim NoseCorner_R.ty ($frownBulgePulledPos[1]*0.1);

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceSmilePullFinish ()
{
string $deleteObjs[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

if (`attributeExists SmilePullFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln SmilePullFinish -at bool -dv true FaceBuildInProgress;

$deleteObjs={"Lip","FaceMuscles","FaceMusclesLayer"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;

currentTime 30;
$drivenCtrls={"Lip","SmileBulge","FrownBulge","lowerLidOuter","CheekBone","Cheek","NoseCorner"};
createNode -n SmileValues -p FaceBuildInProgress transform;
asLockAttr SmileValues 1 1 1 1;
for ($i=0;$i<size($drivenCtrls);$i++)
	if (`objExists ($drivenCtrls[$i]+"_R")`)
		for ($y=0;$y<size($trs);$y++)
			for ($z=0;$z<size($xyz);$z++)
				addAttr -k 1 -ln ($drivenCtrls[$i]+"_R_"+$trs[$y]+$xyz[$z]) -at double -dv `getAttr ($drivenCtrls[$i]+"_R."+$trs[$y]+$xyz[$z])` SmileValues;

asFaceDsFinish ctrlMouthCorner _RL smile 1;
asFaceHideControllers 1;
setAttr ctrlBoxMouthCorner_R.v 1;
setAttr ctrlBoxMouthCorner_L.v 1;
}

global proc asFaceFrownPull ()
{
float $value;
string $obj,$attr;
string $tempString[],$tempString2[];

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceSmilePullFinish;

//fit-anim
asFaceFitAnim ctrlMouthCorner_R.tx 1;
asFaceFitAnim ctrlMouthCorner_R.ty -1;
asFaceFitAnim ctrlMouthCorner_L.tx 1;
asFaceFitAnim ctrlMouthCorner_L.ty -1;

//default to be just Smile with ty*=-1
$tempString=`listAttr -ud SmileValues`;
for ($i=0;$i<size($tempString);$i++)
	{
	tokenize $tempString[$i] "_" $tempString2;
	$obj=$tempString2[0]+"_"+$tempString2[1];
	$attr=$tempString2[2];
	$value=`getAttr ("SmileValues."+$tempString[$i])`;
	if ($attr=="ty" || $attr=="rz")
		$value*=-1;
	asFaceFitAnim ($obj+"."+$attr) $value;
	}

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceFrownPullFinish ()
{
if (`attributeExists FrownPullFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln FrownPullFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlMouthCorner _RL frown 1;
asFaceHideControllers 1;
setAttr ctrlBoxMouthCorner_R.v 1;
setAttr ctrlBoxMouthCorner_L.v 1;

asFaceNarrowSmileAndFrown;
}

global proc asFaceNarrowSmileAndFrown ()
{
int $b,$upperLowerFactor;
int $lipCtrls=`asGetLipCtrls`;
string $obj,$attr,$side,$upperLower;
float $value;
string $tempString[],$tempString2[],$drivenCtrls[];
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceRemoveFitAnimationsFromOnFaceCtrls;

asFaceSmilePullController;

//auto-lip-narrow
//find the drivingValue, how far SmilePull_R.tx goes before scale to zero
/*
float $angle=`getAttr SmilePullOffset_R.ry`;
float $pi=3.142;
float $radians=$angle*($pi / 180);
float $opposite=`getAttr SmilePullOffset_R.tx`;
float $hypotenuse=sqrt(pow($opposite, 2) + pow($opposite * tan($radians), 2));
float $xFromMid=($hypotenuse*-1)/2.0;//full downScale at halfway to mid
*/
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
/*
		for ($z=0;$z<size($xyz);$z++)
			{
			setDrivenKeyframe -itt linear -ott linear -dv 0         -v 1 -currentDriver ("bwctrlMouthCorner"+$side+"_translateX.output") ($upperLower+"LipJointFleshyNarrow"+$side+".s"+$xyz[$z]);
			setDrivenKeyframe -itt linear -ott linear -dv $xFromMid -v 0 -currentDriver ("bwctrlMouthCorner"+$side+"_translateX.output") ($upperLower+"LipJointFleshyNarrow"+$side+".s"+$xyz[$z]);
			keyTangent -index 1 -inTangentType flat ($upperLower+"LipJointFleshyNarrow"+$side+"_scale"+$XYZ[$z]);
			}
*/
		//replaced when added new-blue upperLip_R
//		asDsSdk ("ctrlMouthCorner"+$side+".tx") ("SDK"+$upperLower+"Lip"+$side+".tx") -1 ($xFromMid*0.5);
		asDsSdk ("ctrlMouthCorner"+$side+".tx") ("SDK"+$upperLower+"Lip"+$side+".tx") -1 (`getAttr SmileValues.Lip_R_tx`/-2.0);
		setAttr ("SDK"+$upperLower+"Lip"+$side+"_translateX.postInfinity") 1;
		}
	}


//automake the narrowSmile & narrowFrown DS
clear $drivenCtrls;
//narrowSmile
$tempString=`listAttr -ud SmileValues`;
for ($i=0;$i<size($tempString);$i++)
	{
	tokenize $tempString[$i] "_" $tempString2;
	$obj=$tempString2[0]+"_"+$tempString2[1];
	$attr=$tempString2[2];
	$value=`getAttr ("SmileValues."+$tempString[$i])`;
	if ($attr=="tx")
		$value*=-1;
	if ($attr=="tz")
		continue;
	asFaceFitAnim ($obj+"."+$attr) $value;
	if (!`stringArrayCount $tempString2[0] $drivenCtrls`)
		$drivenCtrls[size($drivenCtrls)]=$tempString2[0];
	}
asFaceFitAnim ctrlMouthCorner_R.tx -1;
asFaceFitAnim ctrlMouthCorner_R.ty 1;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlMouthCorner _RL narrowSmile 1;

//narrowFrown
$tempString=`listAttr -ud SmileValues`;
for ($i=0;$i<size($tempString);$i++)
	{
	tokenize $tempString[$i] "_" $tempString2;
	$obj=$tempString2[0]+"_"+$tempString2[1];
	$attr=$tempString2[2];
	$value=`getAttr ("SmileValues."+$tempString[$i])`;
	if ($attr=="tx")
		$value*=-1;
	if ($attr=="ty")
		$value*=-1;
	if ($attr=="tz")
		continue;
	asFaceFitAnim ($obj+"."+$attr) $value;
	if (!`stringArrayCount $tempString2[0] $drivenCtrls`)
		$drivenCtrls[size($drivenCtrls)]=$tempString2[0];
	}
asFaceFitAnim ctrlMouthCorner_R.tx -1;
asFaceFitAnim ctrlMouthCorner_R.ty -1;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlMouthCorner _RL narrowFrown 1;
asFaceHideControllers 1;
setAttr ctrlBoxMouthCorner_R.v 1;
setAttr ctrlBoxMouthCorner_L.v 1;
setAttr SmilePullOffset_R.v 1;
setAttr SmilePullOffset_L.v 1;

//ctrlMouth_M.tx to be `tapped in` to ctrlMouthCorner_R.tx
connectAttr bwctrlMouth_M_translateX.output bwctrlMouthCorner_R_translateX.input[2];
connectAttr bwctrlMouth_M_translateX.output bwctrlMouthCorner_L_translateX.input[2];
}

global proc asFaceSmilePullController ()
{
int $autoKeyState=`autoKeyframe -q -state`;
float $posA[],$posB[];
float $tx,$ty,$rotY;

if ($autoKeyState) autoKeyframe -state 0;

createNode -n tempXform -p LipOffset_R transform;
parent tempXform SideReverse_R;
$rotY=`getAttr tempXform.ry`;
delete tempXform;

//Create
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	asCreateFaceController "SmilePull" $side 2;
	setAttr ("SmilePull"+$side+"Shape.overrideColor") 17;
	$pos=`xform -q -ws -t ("Lip"+$side)`;
	scale -r -p 0 0 0 1.8 1.8 1.8 ("SmilePull"+$side+".cv[0:99]");
	xform -ws -t $pos[0] $pos[1] $pos[2] ("SmilePullOffset"+$side);
	parent ("SmilePullOffset"+$side) ("SideReverse"+$side);
	setAttr ("SmilePullOffset"+$side+".s") -type float3 1 1 1;
	asFaceHalfMoonCurve ("SmilePull"+$side) 0;
	setAttr ("SmilePullOffset"+$side+".ry") $rotY;
//	rotate -r -os 0 (($rotY*-1)/2.0) 0 ("SmilePullOffset"+$side);

	asLockAttr  ("SmilePull"+$side) 1 1 1 1;
	setAttr -k 1 -l 0 ("SmilePull"+$side+".tx");
	setAttr -k 1 -l 0 ("SmilePull"+$side+".ty");

	asFacePlaceCtrlByProjection ("SmilePull"+$side);

	//find driverValue, how far SmilePull needs travel, to equivalent ctrlMouthCorner=1
	if ($side=="_R")
		{
		createNode -n tempTransform1 -p SmilePull_R transform;
		pointConstraint Lip_R tempTransform1;
		setAttr ctrlMouthCorner_R.tx 1;
		$tx=`getAttr tempTransform1.tx`;
		setAttr ctrlMouthCorner_R.tx 0;
		setAttr ctrlMouthCorner_R.ty 1;
		$ty=`getAttr tempTransform1.ty`;
		setAttr ctrlMouthCorner_R.ty 0;
		delete tempTransform1;
		}

	asEnsureOutputBlendWeighted ("SmilePull"+$side+".tx");
	asEnsureOutputBlendWeighted ("SmilePull"+$side+".ty");
	asDsSdk ("SmilePull"+$side+".tx") ("bwctrlMouthCorner"+$side+"_translateX.input") $tx 1.0;
	asDsSdk ("SmilePull"+$side+".ty") ("bwctrlMouthCorner"+$side+"_translateY.input") $ty 0.5;
	}


if ($autoKeyState) autoKeyframe -state 1;
}

global proc asFaceCheek ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $vtxNrs[];
float $falloffRadius,$distToEyeCurve,$weight,$value,$distToSmileBulge,$distToFrownBulge;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $posA[],$posB[],$posC[],$posD[],$weights[];
string $side,$leftSuffix;
string $xyz[]={"x","y","z"};
string $infJoints[],$tempString[],$copyToVtx[];

if (!`objExists upperLipMainCurve`)//skip
	return;

//asFaceNarrowPullFinish;
asFaceFrownPullFinish;
asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;

//fit-anim
asFaceFitAnim ctrlCheek_R.tx 1;
asFaceFitAnim ctrlCheek_L.tx 1;
//asFaceFitAnim Cheek_R.tx 0.75;
asFaceFitAnim Cheek_R 0;
asFaceFitAnim Cheek_R.tz 1.0;
asFaceFitAnim Cheek_R.sx 1.2;
asFaceFitAnim Cheek_R.sy 1.2;
asFaceFitAnim Cheek_R.sz 1.2;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceCheekFinish ()
{
if (`attributeExists CheekFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln CheekFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlCheek _RL tx 1;
asFaceHideControllers 1;
setAttr ctrlBoxCheek_R.v 1;
setAttr ctrlBoxCheek_L.v 1;
}

global proc asFaceCheekRaiser ()
{
float $falloffRadius,$lowerLidTy;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
float $posA[],$posB[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $side,$leftSuffix;
string $tempString[],$lineVtxs[];

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceCheekFinish;

//calculate $lowerLidTy to `half-close`
createNode -n tempXform -p lowerLid_R transform;
pointConstraint innerLid_R outerLid_R tempXform;
$lowerLidTy=`getAttr tempXform.ty`/2.0;
delete tempXform;

asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;

//fit-anim
asFaceFitAnim ctrlCheek_R.ty 1;
asFaceFitAnim ctrlCheek_L.ty 1;
asFaceFitAnim lowerLid_R.ty 0.5;
asFaceFitAnim lowerLidOuter_R.ty 0.45;
asFaceFitAnim lowerLidOuter_R.tz 0.1;
asFaceFitAnim CheekBone_R.ty 0.1;
asFaceFitAnim NoseSide_R.ty 0.2;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceCheekRaiserFinish ()
{
if (`attributeExists CheekRaiserFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln CheekRaiserFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlCheek _RL ty 1;
asFaceHideControllers 1;
setAttr ctrlBoxCheek_R.v 1;
setAttr ctrlBoxCheek_L.v 1;
}

global proc asFaceJawWeighing ()
{
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $opm=`asGetOpm`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster="JawLayerSC";
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $pos[],$pos2[],$posA[],$posB[],$bb[];
string $tempString[],$lipCtrl[],$lipSide[],$lipUpLo[];
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $tr[]={"t","r"};
string $upLoCtrl,$side;

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceCheekRaiserFinish;

//JawCurves, used to be in Pre section, but moved to here
//It still creates FaceFitJawCurves as a Fit-Element, and will be keept as a Fit
if (!`objExists FaceFitJawCurves`)
	asFaceFitJawCurves;

//create LayerMesh (weightBysoftmod ignores locked weights)
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n JawLayer templateLayer;
select $headJoint JawLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] JawLayerSC;
asShowLayer Jaw;

asFaceHideControllers 1;

//create Jaw Ctrl & joint here, as SmileLineDown will partially follow the jaw
asCreateFaceController "Jaw" "_M" 2;
select FaceJoint_M;
joint -n JawJoint_M;
setAttr JawJoint_M.segmentScaleCompensate 0;
$pos=`xform -q -ws -t JawPivot`;
xform -ws -t 0 $pos[1] $pos[2] JawOffset_M;
asAlign JawJoint_M Jaw_M 1 0 0 0;
parent JawOffset_M SideReverse_M;
setAttr JawOffset_M.s -type float3 1 1 1;
if ($opm)
	{
	asParentConstraint Jaw_M JawJoint_M "-mo";
	if ($multiSkinClusters)//inverseMatrix out HeadJoint
		{
		connectAttr -f ($headJoint+".worldInverseMatrix") JawJointMM_M.matrixIn[2];
		$m=`getAttr ($headJoint+".worldMatrix")`;
		setAttr JawJointMM_M.matrixIn[3] -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		$tempString=`listRelatives -p JawJoint_M`;
		connectAttr ($tempString[0]+".worldInverseMatrix") JawJointMM_M.matrixIn[4];
		}
	}
else
	{
	parentConstraint Jaw_M JawJoint_M;
	scaleConstraint -mo Jaw_M JawJoint_M;
	}
asFaceHalfMoonCurve Jaw_M -90;
move -r -os 0 0.25 0 Jaw_M.cv[0:99];
scale -r -p 0 $pos[1] $pos[2] 5 5 5 Jaw_M.cv[0:99];
$pos2=`xform -q -ws -t Jaw`;
move -r 0 ($pos2[1]-$pos[1]) (($pos2[2]-$pos[2])*1.1) Jaw_M.cv[0:99];
//asFacePlaceCtrlByProjection Jaw_M;

//JawMix_M, for tongue and lowerteeth to follow
createNode -n JawMix_M -p JawOffset_M transform;
createNode -n JawMixTPMA plusMinusAverage;
createNode -n JawMixRPMA plusMinusAverage;
connectAttr Jaw_M.t JawMixTPMA.input3D[0];
connectAttr Jaw_M.r JawMixRPMA.input3D[0];
connectAttr SDKJaw_M.t JawMixTPMA.input3D[1];
connectAttr SDKJaw_M.r JawMixRPMA.input3D[1];
connectAttr JawMixTPMA.output3D JawMix_M.t;
connectAttr JawMixRPMA.output3D JawMix_M.r;
createNode -n JawMixSMPD multiplyDivide;
connectAttr Jaw_M.s JawMixSMPD.input1;
connectAttr SDKJaw_M.s JawMixSMPD.input2;
connectAttr JawMixSMPD.output JawMix_M.s;

//parentConstraint -mo Jaw_M JawFollow_M;
//scaleConstraint -mo Jaw_M JawFollow_M;
asParentConstraint Jaw_M JawFollow_M "-mo";

string $upperLower,$upperLowerTeeth;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerTeeth=$upperTeeth;}
	else {$upperLower="lower";$upperLowerTeeth=$lowerTeeth;}

	if ($upperLowerTeeth!="")
		{
		eval ("select "+$upperLowerTeeth);
		showHidden -a;
		refresh;
		$tempString=`ls -sl -o`;
		if (size($tempString)>1)
			{
			//for multiple teeth objects, dup&group to get bb
			duplicate -rr;
			parent -w;
			group -n BoundingBoxGroup;
			$bb=`xform -q -ws -bb`;
			delete BoundingBoxGroup;
			}
		else
			$bb=`xform -q -ws -bb`;
		eval ("select "+$upperLowerTeeth);
		asShowLayer Jaw;

		asCreateFaceController ($upperLower+"Teeth") "_M" 4;
		parent ($upperLower+"TeethJoint_M") FaceJoint_M;
		parent ($upperLower+"TeethOffset_M") SideReverse_M;
		setAttr ($upperLower+"TeethOffset_M.s") -type float3 1 1 1;
		rotate -r -p 0 0 0 -os -90 0 0 ($upperLower+"Teeth_M.cv[0:7]");
		scale (($bb[3]-$bb[0])/($scale*0.03)) 1 (($bb[5]-$bb[2])/($scale*0.03)) ($upperLower+"Teeth_M.cv[0:7]");
		xform -ws -t 0 (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0) ($upperLower+"TeethOffset_M");
		move -r 0 0 ($scale/-10.0) ($upperLower+"Teeth_M.cv[0:99]");
		connectAttr -f ctrlBox.TeethCtrlVis ($upperLower+"Teeth_MShape.overrideVisibility");

		if ($upperLower=="lower")
			asFaceAddConstrained lowerTeeth_M JawFollow_M JawStatic_M 10;

		if ($opm)
			{
			asParentConstraint ($upperLower+"Teeth_M") ($upperLower+"TeethJoint_M") "";
			asOPMScaleReset ($upperLower+"TeethJoint_M");
			}
		else
			{
			parentConstraint ($upperLower+"Teeth_M") ($upperLower+"TeethJoint_M");
			scaleConstraint -mo ($upperLower+"Teeth_M") ($upperLower+"TeethJoint_M");
			}
		}
	}
setAttr JawJoint_M.segmentScaleCompensate 0;
if (`objExists upperTeethJoint_M`)
	setAttr upperTeethJoint_M.segmentScaleCompensate 0;
if (`objExists lowerTeethJoint_M`)
setAttr lowerTeethJoint_M.segmentScaleCompensate 0;

if (`objExists upperTeethOffset_M`) setAttr upperTeethOffset_M.v 0;
if (`objExists lowerTeethOffset_M`) setAttr lowerTeethOffset_M.v 0;

skinCluster -e -lw false -wt 0 -ai JawJoint_M $skinCluster;

//Skin jaw-curves
select FaceJoint_M JawJoint_M JawCurve;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawCurveSC;

//Create the JawOpenLayer mesh
duplicate -n JawOpenLayer templateLayer;
parent JawOpenLayer FaceBuildInProgress;
setAttr JawLayer.v 0;
setAttr JawOpenLayer.v 1;
sets -e -forceElement initialShadingGroup JawOpenLayer;
select JawOpenLayer FaceJoint_M JawJoint_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawOpenLayerSC;
skinPercent -tv FaceJoint_M 1 JawOpenLayerSC JawOpenLayer.vtx[0:99999];

select `asobjSetCast lipArea {} JawOpenLayer`;
sets -n lipAreaJawOpenLayer;
sets -add FaceBuildingSets lipAreaJawOpenLayer;

asFaceLockWeights 0;
asSkinTeeth;

asFaceDesignMouthOpen;
asFaceWeightLips;
asFaceUpdateJawCurvesWeights;

setAttr JawLayer.v 0;

parent FaceFitJawCurves FaceBuildInProgress;
parent mouthOpenSoftModHandle FaceBuildInProgressHidden;

currentTime 30;
//select Jaw_M;
//autoKeyframe -st 1;
select -cl;
}

global proc asFaceJawWeighingFinish ()
{
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $opm=`asGetOpm`;
float $values[],$smileWeightsR[],$smileWeightsL[],$frownWeightsR[],$frownWeightsL[],$m[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $upperLower;
string $tempString[],$tempString2[],$infs[];
string $AB[]={"A","B"};

if (!`objExists upperLipMainCurve`)//skip
	return;

if (`attributeExists JawWeighingFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln JawWeighingFinish -at bool -dv true FaceBuildInProgress;

currentTime 0;
delete JawCurveSC;
parent JawOpenLayer DeformationLayers;

if ($multiSkinClusters)
	$skinCluster=`asFaceMultiSkinClusterAdd "Jaw"`; 

//finish Jaw
parent FaceFitJawCurves FaceFitSkeleton;

asShowLayer Normal;

setAttr LipRegionOffset_M.v 1;
setAttr lowerLipOffset_M.v 1;

if (!$multiSkinClusters)
	{
	asFaceAddConstrained upperLip_M JawFollow_M lowerFaceStatic_M 0;
	asFaceAddConstrained lowerLip_M JawFollow_M lowerFaceStatic_M 10;
	asFaceAddConstrained ChinCrease_M JawFollow_M lowerFaceStatic_M 8;
	//asFaceAddConstrained NoseUnder_M JawFollow_M middleFaceStatic_M 0.25;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";

		if ($opm)
			asParentConstraint Jaw_M ("JawFollow"+$side) "-mo";
		else
			{
			parentConstraint -mo Jaw_M ("JawFollow"+$side);
			scaleConstraint -mo Jaw_M ("JawFollow"+$side);
			}

		setAttr ("LipOffset"+$side+".v") 1;
		asFaceAddConstrained ("Lip"+$side) ("JawFollow"+$side) ("lowerFaceStatic"+$side) 5;
		asFaceAddConstrained ("Cheek"+$side) ("JawFollow"+$side) ("middleFaceStatic"+$side) 5;
		asFaceAddConstrained ("FrownBulge"+$side) ("JawFollow"+$side) ("middleFaceStatic"+$side) 8;
		asFaceAddConstrained ("SmileBulge"+$side) ("JawFollow"+$side) ("middleFaceStatic"+$side) 2;
	//	asFaceAddConstrained ("NoseCorner"+$side) ("JawFollow"+$side) ("middleFaceStatic"+$side) 0.25;//Nope, already following lip..nope,re-aplied..nope re-removed
		asFaceAddConstrained ("CheekBone"+$side) ("JawFollow"+$side) ("middleFaceStatic"+$side) 1;

		//asFaceAddConstrained in OPM does not allow for constrained to be child of a movable ctrl (e.g LipRegion_M). so change source of invMatrix
		if ($opm && !$multiSkinClusters)
			{
			createNode -n ("LipOffsetUnderLipRegion"+$side) -p ("LipOffset"+$side) transform;
			parent ("LipOffsetUnderLipRegion"+$side) LipRegionOffset_M;
			for ($i=0;$i<size($AB);$i++)
				{
				connectAttr -f ("LipOffsetUnderLipRegion"+$side+".worldInverseMatrix") ("LipMM"+$AB[$i]+$side+".matrixIn[2]");
				if ($side=="_L")//upper/lower as well
					{
					for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
						{
						if ($upperLowerFactor==1) $upperLower="upper";
						else $upperLower="lower";

						if ($AB[$i]=="A")
							{
							createNode -n ($upperLower+"LipOffsetUnderLipRegion_M") -p ($upperLower+"LipOffset_M") transform;
							parent ($upperLower+"LipOffsetUnderLipRegion_M") LipRegionOffset_M;
							}
						connectAttr -f ($upperLower+"LipOffsetUnderLipRegion_M.worldInverseMatrix") ($upperLower+"LipMM"+$AB[$i]+"_M"+".matrixIn[2]");
						}
					}
				}
	/*
			for ($i=0;$i<size($AB);$i++)
				{
				createNode -n tempTransform -p ("LipOffset"+$side) transform;
				parent tempTransform LipRegionOffset_M;
				$m=`getAttr tempTransform.matrix`;
				delete tempTransform;

				setAttr ("LipMM"+$AB[$i]+$side+".matrixIn[3]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
				connectAttr -f LipRegionOffset_M.worldInverseMatrix ("LipMM"+$AB[$i]+$side+".matrixIn[2]");
				}
	*/
			}
		}
	}
dgdirty -a;

skinCluster -e -lw false -wt 0 -ai JawJoint_M $skinCluster;

//lock`n`copy
$tempString=`listRelatives -type joint -ad FaceJoint_M`;
$tempString[size($tempString)]="FaceJoint_M";
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists lockInfluenceWeights $tempString[$i]`)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
setAttr JawJoint_M.lockInfluenceWeights 0;
//setAttr Head_M.lockInfluenceWeights 0;
setAttr ($headJoint+".lockInfluenceWeights") 0;
if ($multiSkinClusters)
	setAttr MultiSkinClustersFaceJawJoint_M.lockInfluenceWeights 0;

select JawOpenLayer;
skinCluster -e -selectInfluenceVerts JawJoint_M;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] "*.*"`)
		continue;
	$tempString2[0]=`substitute "JawOpenLayer" $tempString[$i] $geometry`;
	$value=`skinPercent -t JawJoint_M -q -v JawOpenLayerSC $tempString[$i]`;
	catchQuiet (`skinPercent -tv JawJoint_M $value $skinCluster $tempString2[0]`);
	}
asFaceLockWeights 0;

//re-hammer lipFalloffArea, as some vtx are following jaw too much, weighted to both jaw, and lipJoints that are folloing jaw
//First determine SmileFrownVtx as these will `retain` weights
//section removed in v6
//select lipFalloffArea;
//if (size(`ls -sl`))
//	weightHammerVerts;

//change the jaw animation to DrivingSystem
currentTime 30;

asDsSdk ctrlMouth_M.ty SDKJaw_M.ty -1 `getAttr Jaw_M.ty`;
asDsSdk ctrlMouth_M.ty SDKJaw_M.tz -1 `getAttr Jaw_M.tz`;
asDsSdk ctrlMouth_M.ty SDKJaw_M.rx -1 `getAttr Jaw_M.rx`;

delete `listConnections -s 1 -d 0 -type animCurve Jaw_M`;
delete `listConnections -s 1 -d 0 -type animCurve ctrlMouth_M`;

setAttr ctrlMouth_M.ty 0;

setAttr -l 0 Jaw_M.tx;
setAttr -l 0 Jaw_M.ry;
setAttr -l 0 Jaw_M.rz;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 Jaw_M;

asFaceHideControllers 1;
setAttr ctrlBoxMouth_M.v 1;
}

global proc asFaceJawOpen ()
{
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
float $pos[];
float $scale=`asGetScale`;
string $lastLipLetter=`asGetLastLipLetter`;

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceJawWeighingFinish;

asFaceHideControllers 1;
asShowLayer Normal;

asFaceMirrorConnectCtrls 1;

//fit-anim
asFaceFitAnim ctrlMouth_M.ty -1;
//if (!$multiSkinClusters)
	{
	asFaceFitAnim Cheek_R 0;
	asFaceFitAnim Cheek_R.tz -0.3;
	asFaceFitAnim Lip_R 0;
	asFaceFitAnim Lip_R.tx -0.4;
	/*removed in v 6.0544, as this lip-rounding does not work well with the new "lipsTogeter" system ( added for improved MetaHuman Animator compatability)
	asFaceFitAnim ("upperLip"+$lastLipLetter+"_R") 0;
	asFaceFitAnim ("lowerLip"+$lastLipLetter+"_R") 0;
	asFaceFitAnim ("upperLip"+$lastLipLetter+"_R.ty")  0.1;
	asFaceFitAnim ("lowerLip"+$lastLipLetter+"_R.ty") -0.1;
	*/
	asFaceFitAnim NoseCorner_R 0;
	asFaceFitAnim NoseCorner_R.ty -0.2;
	asFaceFitAnim NoseUnder_M 0;
	asFaceFitAnim NoseUnder_M.ty -0.05;
	}

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceJawOpenFinish ()
{
if (`attributeExists JawOpenFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln JawOpenFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlMouth _M ty -1;
asFaceHideControllers 1;
setAttr ctrlBoxMouth_M.v 1;
select -cl;
}

global proc asFaceLipUp ()
{
string $upperLower;

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceJawOpenFinish;

asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;
setAttr -l 0 -k 1 ctrlLips_M.tx;
setAttr -l 0 -k 1 ctrlLips_M.ty;

//fit-anim
asFaceFitAnim ctrlLips_M.ty 1;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	asFaceFitAnim ($upperLower+"Lip_M") 0;
	asFaceFitAnim ($upperLower+"Lip_M.ty") 0.8;
	asFaceFitAnim ($upperLower+"Lip_M.sy") 0.8;
//	asFaceFitAnim ($upperLower+"Lip_M.tz") 0.4;
	}

asFaceFitAnim Lip_R 0;
asFaceFitAnim Lip_R.tx 0.1;
asFaceFitAnim Lip_R.ty 0.7;
asFaceFitAnim SmileBulge_R 0;
asFaceFitAnim SmileBulge_R.ty 0.2;
asFaceFitAnim SmileBulge_R.tz 0.75;
asFaceFitAnim FrownBulge_R 0;
asFaceFitAnim FrownBulge_R.ty 0.2;

asFaceFitAnim CheekBone_R 0;
asFaceFitAnim CheekBone_R.tx 0.1;
asFaceFitAnim CheekBone_R.ty 0.1;

asFaceFitAnim NoseCorner_R 0;
asFaceFitAnim NoseCorner_R.ty 0.3;
asFaceFitAnim NoseSide_R 0;
asFaceFitAnim NoseSide_R.ty 0.2;
asFaceFitAnim Nostril_R.tx 0.05;
asFaceFitAnim Nostril_R.ty 0.1;

asFaceFitAnim Nose_M 0;
asFaceFitAnim Nose_M.ty 0.05;
asFaceFitAnim NoseBridge_M 0;
asFaceFitAnim NoseBridge_M.ty 0.04;
asFaceFitAnim NoseUnder_M 0;
asFaceFitAnim NoseUnder_M.ty 0.3;
asFaceFitAnim ChinCrease_M 0;
asFaceFitAnim ChinCrease_M.ty 0.75;
asFaceFitAnim ChinCrease_M.tz 0.25;
//asFaceFitAnim ctrlMouth_M.upperSqueeze 3;//unable to include in asFaceStoreAsDsSdk
//asFaceFitAnim ctrlMouth_M.lowerSqueeze 3;

select upperLip_M lowerLip_M Nose_M NoseBridge_M NoseUnder_M ChinCrease_M;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	select -add ("Lip"+$side) ("SmileBulge"+$side) ("FrownBulge"+$side) ("CheekBone"+$side) ("NoseCorner"+$side) ("NoseSide"+$side) ("Nostril"+$side) ;
	}
sets -n LipUpControls;
sets -add FaceBuildingSets LipUpControls;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceLipUpFinish ()
{
if (`attributeExists LipUpFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln LipUpFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlLips _M ty 1;
asFaceHideControllers 1;
setAttr ctrlBoxLips_M.v 1;
}

global proc asFaceLipDown ()
{
float $value;
string $ctrl;
string $tempString[],$tempString2[],$attrs[];

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceLipUpFinish;

asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;

//fit-anim
asFaceFitAnim ctrlLips_M.ty -1;

//mute LipUpSDK, and apply `opposite` value as fit-anim
currentTime 0;
$tempString=`sets -q LipUpControls`;
for ($i=0;$i<size($tempString);$i++)
	{
	$ctrl=$tempString[$i];
	$attrs=`listAttr -k ("SDK"+$ctrl)`;
	for ($y=0;$y<size($attrs);$y++)
		{
		$tempString2=`listConnections -s 1 -d 0 ("SDK"+$ctrl+"."+$attrs[$y])`;
		if (!size($tempString2))
			continue;
//		currentTime 30;
		$value=`getAttr -t 30 ("SDK"+$ctrl+"."+$attrs[$y])`;
		if (`gmatch $attrs[$y] "scale*"`)
			$value=1-($value-1);
//		currentTime 0;
		mute ("SDK"+$ctrl+"."+$attrs[$y]);
//		currentTime 30;
		if (!`gmatch $ctrl "*_L"`)
			asFaceFitAnim ($ctrl+"."+$attrs[$y]) $value;
		}
	}
setKeyframe -t 0 -v 1 upperLip_M.sy upperLip_M.sz lowerLip_M.sy lowerLip_M.sz;

asFaceFitAnim SmileBulge_R.tz 0.1;
asFaceFitAnim FrownBulge_R.tz 0.1;
asFaceFitAnim ChinCrease_M.ty -0.3;
asFaceFitAnim ChinCrease_M.tz 0.1;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceLipDownFinish ()
{
string $ctrl;
string $tempString[];

if (`attributeExists LipDownFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln LipDownFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;

//unMute LipUpSDK
currentTime 0 ;
$tempString=`sets -q LipUpControls`;
for ($i=0;$i<size($tempString);$i++)
	{
	$ctrl=$tempString[$i];
	mute -disable ("SDK"+$ctrl);
	}

asFaceDsFinish ctrlLips _M ty -1;
asFaceHideControllers 1;
setAttr ctrlBoxLips_M.v 1;
}

global proc asFaceLipSide ()
{
string $upperLower;

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceLipDownFinish;
asFaceHideControllers 1;
setAttr ctrlBox.RegionsCtrlVis 1;

//fit-anim
asFaceFitAnim ctrlLips_M.tx -1;

asFaceFitAnim LipRegion_M 0;
asFaceFitAnim LipRegion_M.tx -1.2;
asFaceFitAnim LipRegion_M.ry -25;
asFaceFitAnim LipRegion_M.sx 0.8;
asFaceFitAnim LipRegion_M.sz 0.8;

asFaceFitAnim NoseRegion_M 0;
asFaceFitAnim NoseRegion_M.tx -0.3;
asFaceFitAnim NoseRegion_M.ty -0.05;
asFaceFitAnim NoseRegion_M.ry -5;
asFaceFitAnim NoseRegion_M.rz -5;

//Right
asFaceFitAnim SmileBulge_R 0;
asFaceFitAnim SmileBulge_R.tx 0.35;
asFaceFitAnim SmileBulge_R.ty 0.2;
asFaceFitAnim SmileBulge_R.tz 0.7;
asFaceFitAnim FrownBulge_R 0;
asFaceFitAnim FrownBulge_R.tx 0.35;
asFaceFitAnim FrownBulge_R.ty -0.2;
asFaceFitAnim FrownBulge_R.tz 0.7;
asFaceFitAnim CheekBone_R 0;
asFaceFitAnim CheekBone_R.tx 0.25;
asFaceFitAnim CheekBone_R.ty 0.25;

//Left
asFaceFitAnim SmileBulge_L 0;
asFaceFitAnim SmileBulge_L.tx -0.35;
asFaceFitAnim SmileBulge_L.ty -0.05;
asFaceFitAnim SmileBulge_L.tz -0.1;
asFaceFitAnim FrownBulge_L 0;
asFaceFitAnim FrownBulge_L.tx -0.35;
asFaceFitAnim FrownBulge_L.ty 0.05;
asFaceFitAnim FrownBulge_L.tz -0.1;
asFaceFitAnim CheekBone_L 0;
asFaceFitAnim CheekBone_L.tx -0.25;
asFaceFitAnim CheekBone_L.ty -0.1;

asFaceFitAnim ChinCrease_M 0;
asFaceFitAnim ChinCrease_M.tx -0.5;

select LipRegion_M NoseRegion_M ChinCrease_M;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	select -add ("SmileBulge"+$side) ("FrownBulge"+$side) ("CheekBone"+$side);
	}
sets -n LipSideControls;
sets -add FaceBuildingSets LipSideControls;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceLipSideFinish ()
{
int $numChar,$b;
float $value;
string $sdkAnimCurve,$sourceBwPlug,$targetBwPlug,$side,$ctrl,$leftCtrl;
string $tempString[],$tempString2[],$drivenCtrls[];
string $trs[]={"translate","rotate","scale"};
string $XYZ[]={"X","Y","Z"};

if (`attributeExists LipSideFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln LipSideFinish -at bool -dv true FaceBuildInProgress;

//store LipLeftValues
currentTime 30;
$tempString=`listRelatives -ad -type nurbsCurve OnFacecontrols`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	$ctrl=$tempString2[0];
	if (!`gmatch $ctrl "*_L"`)
		continue;
	$tempString2=`listConnections -s 1 -d 0 -type animCurve $ctrl`;
	if (!size($tempString2))
		continue;
	$drivenCtrls[size($drivenCtrls)]=$ctrl;
	}
createNode -n LipLeftValues -p FaceBuildInProgress transform;
asLockAttr LipLeftValues 1 1 1 1;
for ($i=0;$i<size($drivenCtrls);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($XYZ);$z++)
			addAttr -k 1 -ln ($drivenCtrls[$i]+"_"+$trs[$y]+$XYZ[$z]) -at double -dv `getAttr ($drivenCtrls[$i]+"."+$trs[$y]+$XYZ[$z])` LipLeftValues;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlLips _M tx -1;

//special case, setting "Left" behaviour by adding `neg` keys on Right
if (`objExists bwSDKLipRegion_M_scaleX`)
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 1 -v 0.8 -cd bwctrlLips_M_translateX.output bwSDKLipRegion_M_scaleX.input[0];
if (`objExists bwSDKLipRegion_M_scaleZ`)
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 1 -v 0.8 -cd bwctrlLips_M_translateX.output bwSDKLipRegion_M_scaleZ.input[0];

$sourceBwPlug="bwctrlLips_M_translateX.output";
$tempString=`listConnections -s 0 -d 1 $sourceBwPlug`;
for ($i=0;$i<size($tempString);$i++)
	{
	$sdkAnimCurve=$tempString[$i];
	tokenize $sdkAnimCurve "_" $tempString2;
	$side="_"+$tempString2[1];
	$ctrl=`substitute "SDK" $tempString2[0] ""`+$side;
	$attr=$tempString2[2];
	while (`gmatch $attr "*[0-9]"`)
		{
		$numChar=size($attr);
		$attr=`substring $attr 1 ($numChar-1)`;
		}
	if ($side=="_R") $b=1;
	if ($side=="_L") $b=-1;
	if ($side!="_R")
		continue;
	$leftCtrl=`substitute "_R" $ctrl "_L"`;
	if (!`attributeExists ($leftCtrl+"_"+$attr) LipLeftValues`)
		continue;

	$tempString2=`listConnections -s 0 -d 1 -p 1 ($sdkAnimCurve+".output")`;
	$targetBwPlug=$tempString2[0];
	$value=`getAttr ("LipLeftValues."+$leftCtrl+"_"+$attr)`;
//print ($sdkAnimCurve+".output  "+$targetBwPlug+" : "+$value+" : "+$side+" : "+$b+";\n");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 1 -v $value -cd $sourceBwPlug $targetBwPlug;
	//and set -1 for the Left as well
	setDrivenKeyframe -itt "linear" -ott "linear" -dv -1 -v $value -cd `substitute "_R" $sourceBwPlug "_L"` `substitute "_R" $targetBwPlug "_L"`;
	}

asFaceHideControllers 1;
setAttr ctrlBox.RegionsCtrlVis 0;
setAttr ctrlBoxLips_M.v 1;
}

global proc asFaceSnarl ()
{
int $lipCtrls=`asGetLipCtrls`;
float $noseSidePos[],$noseCornerPos[],$upperLipBPos[],$pos[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[];

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceLipSideFinish;

asFaceHideControllers 1;
asFaceMirrorConnectCtrls 1;

if (`objExists NoseSide_R`)
	{
	createNode -n TempPos -p upperLidMain0_R transform;
	delete `geometryConstraint $geometry TempPos`;
	parent TempPos NoseSide_R;
	setAttr TempPos.tx 0;
	setAttr TempPos.tz 0;
	delete `geometryConstraint $geometry TempPos`;
	createNode -n TempPos2 transform;
	pointConstraint -w 0.25 TempPos NoseSide_R TempPos2;
	pointConstraint -w 0.75 NoseSide_R TempPos2;
	delete TempPos2_pointConstraint1;
	delete `geometryConstraint $geometry TempPos2`;
	parent TempPos2 NoseSideOffset_R;
	$noseSidePos=`getAttr TempPos2.t`;
	delete `pointConstraint NoseCorner_R NoseSide_R TempPos2`;
	parent TempPos2 NoseCornerOffset_R;
	$noseCornerPos=`getAttr TempPos2.t`;
	delete `pointConstraint NoseCorner_R upperLipB_R TempPos2`;
	parent TempPos2 upperLipBOffset_R;
	$upperLipBPos=`getAttr TempPos2.t`;
	delete TempPos TempPos2;
	}
else
	{
	$noseSidePos={0.0, 0.25, 0.0};
	$noseCornerPos={0.0, 0.5, 0.0};
	$upperLipBPos={0.0, 0.75, 0.0};
	}


//fit-anim
asFaceFitAnim ctrlNose_R.ty 1;
asFaceFitAnim ctrlNose_L.ty 1;
asFaceFitAnim NoseCorner_R 0;
//asFaceFitAnim NoseCorner_R.tx $noseCornerPos[0];
asFaceFitAnim NoseCorner_R.ty ($noseCornerPos[1]*1.0);
//asFaceFitAnim NoseCorner_R.tz $noseCornerPos[2];
asFaceFitAnim NoseSide_R 0;
asFaceFitAnim NoseSide_R.tx $noseSidePos[0];
asFaceFitAnim NoseSide_R.ty $noseSidePos[1];
asFaceFitAnim NoseSide_R.tz $noseSidePos[2];

asFaceFitAnim NoseUnder_M.ty ($noseCornerPos[1]*0.2);
asFaceFitAnim Nostril_R.ty ($noseCornerPos[1]*0.25);
asFaceFitAnim Nose_M.ty ($noseCornerPos[1]*0.075);
asFaceFitAnim NoseBridge_M.ty ($noseCornerPos[1]*0.04);
asFaceFitAnim SmileBulge_R.ty ($noseCornerPos[1]*0.3);

//asFaceFitAnim NoseCrease_M.ty ($noseCornerPos[1]*-0.04);
/*
for ($i=1;$i<($lipCtrls/4);$i++)
	{
	setAttr ("upperLip"+`asNrToLetter $i`+"Offset_R.v") 1;
	setAttr ("upperLip"+`asNrToLetter $i`+"Offset_L.v") 1;

	if ($i==1)//fraction on A
		{$pos[0]=$upperLipBPos[0]*0.2;$pos[1]=$upperLipBPos[1]*0.2;$pos[2]=$upperLipBPos[2]*0.2;}
	else
		$pos=$upperLipBPos;

	asFaceFitAnim ("upperLip"+`asNrToLetter $i`+"_R") 0;
	asFaceFitAnim ("upperLip"+`asNrToLetter $i`+"_R.tx") $pos[0];
	asFaceFitAnim ("upperLip"+`asNrToLetter $i`+"_R.ty") $pos[1];
	asFaceFitAnim ("upperLip"+`asNrToLetter $i`+"_R.tz") $pos[2];
	}
*/
/*
asFaceFitAnim upperLip_R.tx $upperLipBPos[0];
asFaceFitAnim upperLip_R.ty $upperLipBPos[1];
asFaceFitAnim upperLip_R.tz $upperLipBPos[2];
*/

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
select -cl;
}

global proc asFaceSnarlFinish ()
{
float $noseCornerPos[];

if (`attributeExists SnarlFinish FaceBuildInProgress`)
	return;
addAttr -k 0 -ln SnarlFinish -at bool -dv true FaceBuildInProgress;

asFaceMirrorConnectCtrls 0;
asFaceRemoveFitAnimFromCtrlBox;
asFaceDsFinish ctrlNose _RL ty 1;

setAttr ctrlNose_R.ty 1;
$noseCornerPos=`getAttr SDKNoseCorner_R.t`;
setAttr ctrlNose_R.ty 0;

asFaceFitAnim NoseSide_R.ty ($noseCornerPos[1]*-0.05);
asFaceFitAnim NoseCorner_R.tx ($noseCornerPos[1]*0.1);
asFaceFitAnim Nostril_R.tx ($noseCornerPos[1]*0.2);
asFaceFitAnim Nostril_R.tz ($noseCornerPos[1]*0.2);
asFaceDsFinish ctrlNose _RL tx 1;

asFaceHideControllers 1;
setAttr ctrlBoxNose_R.v 1;
setAttr ctrlBoxNose_L.v 1;
select -cl;
}

global proc asFaceTongue ()
{
global string $gSelect;
setToolTo $gSelect;
int $modifier=`getModifiers`;
int $opm=`asGetOpm`;
int $numTongueCtrls=4;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $tempString[],$tongueJointVtxs[];
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceSnarlFinish;

if (!`objExists FaceFitTongue`)//skip
	return;

float $pos[],$bb[];
float $scale=`getAttr FaceFitSkeleton.faceScale`;
string $side;
string $tongueSkinCluster="";
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

for ($i=0;$i<99;$i++)
	{
	if (!`objExists ("Tongue"+$i)`)
		break;
	$numTongueCtrls=$i;
	}

asFaceHideControllers 1;

asShowLayer Normal;

if ($tongue=="")
	return;

//Display only tongue geo
if (`gmatch $tongue "*[.]*"`)
	setAttr ($geometry+".v") 1;
else
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 0;
		}
	setAttr ($tongue+".v") 1;
	}

if (!`objExists TongueCurve`)
	{
	//If tongue geometry has been choosen, but not Fit-tongue, we create default FitTongue.
	print ("// No Fit Tongue was found, Now creating Default Fit Tongue.\n");
	asCreateFaceFit Tongue "" 0 0 0 "asBlueSG";
	}

for ($i=0;$i<$numTongueCtrls;$i++)
	{
	asCreateFaceController ("Tongue"+$i) "_M" 4;
	//was removed in v5.842 to resolve "Non-uniform scaling of Tongue issue",
	//but that cause tongue to not scale correctly when scaling Head (or Main), so restoring segmentScaleCompensate=0,
	//and swapping scaleConstraints for connections to address the "Non-uniform scaling of Tongue issue"
	setAttr ("Tongue"+$i+"Joint_M.segmentScaleCompensate") 0;
	setAttr ("Tongue"+$i+"_MShape.overrideColor") 6;
	connectAttr -f ctrlBox.TongueCtrlVis ("Tongue"+$i+"_MShape.overrideVisibility");
//	$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
	$pos=`xform -q -ws -t ("Tongue"+$i)`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i+"Offset_M");
	xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i+"Joint_M");
	scale -r -p $pos[0] $pos[1] $pos[2] (3.4*2.0) 3.4 1 ("Tongue"+$i+"_M.cv[0:7]");
	rotate -r -os 0 90 0 ("Tongue"+$i+"_M.cv[0:7]");
	parent ("Tongue"+$i+"Offset_M") SideReverse_M;
	setAttr ("Tongue"+$i+"Offset_M.s") -type float3 1 1 1;
	}

for ($i=1;$i<$numTongueCtrls+1;$i++)
	{
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ("Tongue"+$i) ("Tongue"+($i-1)+"Offset_M")`;
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ("Tongue"+$i) ("Tongue"+($i-1)+"Joint_M")`;
	}
for ($i=1;$i<$numTongueCtrls;$i++)
	{
	parent ("Tongue"+$i+"Offset_M") ("Tongue"+($i-1)+"_M");
	parent ("Tongue"+$i+"Joint_M") ("Tongue"+($i-1)+"Joint_M");
	}
parent Tongue0Joint_M FaceJoint_M;
for ($i=0;$i<$numTongueCtrls;$i++)
	{
	if ($opm)
		asParentConstraint ("Tongue"+$i+"_M") ("Tongue"+$i+"Joint_M") "-mo"; 
	else
		{
		parentConstraint -mo ("Tongue"+$i+"_M") ("Tongue"+$i+"Joint_M");
		for ($z=0;$z<size($xyz);$z++)
			{
			createNode -n ("Tongue"+$i+"Joint_MScaleMPD") multiplyDivide;
			connectAttr ("Tongue"+$i+"_M.s"+$xyz[$z]) ("Tongue"+$i+"Joint_MScaleMPD.input1"+$XYZ[$z]);
			connectAttr ("SDKTongue"+$i+"_M.s"+$xyz[$z]) ("Tongue"+$i+"Joint_MScaleMPD.input2"+$XYZ[$z]);
			connectAttr ("Tongue"+$i+"Joint_MScaleMPD.output"+$XYZ[$z]) ("Tongue"+$i+"Joint_M.s"+$xyz[$z]);
	//		connectAttr ("Tongue"+$i+"_M.s"+$xyz[$z]) ("Tongue"+$i+"Joint_M.s"+$xyz[$z]);
			}
		}
	}

//follow jaw
asFaceAddConstrained Tongue0_M JawFollow_M lowerFaceStatic_M 10;

//Polycube skin method
polyCube -n tempWeightCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz $numTongueCtrls -ax 0 1 0 -cuv 4 -ch 1;
//xform -s $scale $scale $scale tempWeightCube;
eval ("select "+$tongue);
$bb=`xform -q -ws -bb`;

for ($i=0;$i<$numTongueCtrls+1;$i++)
	{
	select tempWeightCube;
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 0.1 -da 0 0 1 -dp 0 0 (-0.5+((1.0/$numTongueCtrls)*$i));
	$tempString=`ls -sl`;
	$tongueJointVtxs[$i]=`stringArrayToString $tempString " "`;
	$tempString=`lattice -n ("TongueLattice"+$i) -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
	}
polySelectConstraint -m 0;
for ($i=0;$i<$numTongueCtrls+1;$i++)
	{
	$pos=`xform -q -ws -t ("Tongue"+$i)`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("TongueLattice"+$i+"Lattice");
	xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 ("TongueLattice"+$i+"Lattice");
	}

select tempWeightCube;
DeleteHistory;
select -r tempWeightCube;
for ($i=0;$i<$numTongueCtrls;$i++)
	select -add ("Tongue"+$i+"Joint_M");
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] tongueBoxSC;

for ($i=0;$i<$numTongueCtrls;$i++)
	{
	eval ("select "+$tongueJointVtxs[$i]);
	if ($i==$numTongueCtrls-1)
		eval ("select -add "+$tongueJointVtxs[$i+1]);
	skinPercent -tv ("Tongue"+$i+"Joint_M") 1 tongueBoxSC `ls -sl`;
	if ($i>0)
		{
		eval ("select "+$tongueJointVtxs[$i]);
		skinPercent -tv ("Tongue"+($i-1)+"Joint_M") 0.5 tongueBoxSC `ls -sl`;
		}
	}


string $historyNodes[];
tokenize $tongue $tempString;
if(size($tempString))
	$historyNodes=`listHistory $tempString[0]`;
else
	$historyNodes=`listHistory $tongue`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="skinCluster")
		if (!`gmatch $historyNodes[$i] "prefix_*"` && $historyNodes[$i]!="squashIKSC")
			{
			$tongueSkinCluster=$historyNodes[$i];
			break;
			}
if ($tongueSkinCluster=="")
	{
	select -r $tongue;
	for ($i=0;$i<$numTongueCtrls;$i++)
		select -add ("Tongue"+$i+"Joint_M");
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] tongueSC;
	$tongueSkinCluster="tongueSC";
	}
else
	for ($i=0;$i<$numTongueCtrls;$i++)
		skinCluster -e -lw true -wt 0 -ai ("Tongue"+$i+"Joint_M") $tongueSkinCluster;

for ($i=0;$i<$numTongueCtrls;$i++)
	setAttr ("Tongue"+$i+"Joint_M.liw") 0;
eval ("select "+$tongue);
ConvertSelectionToVertices;
catchQuiet (`skinPercent -tv Tongue0Joint_M 1 $tongueSkinCluster`);

//if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)//a case had tongue part of a InnerMouth object
if (`gmatch $tongue "*[.]*"`)
	{
	eval ("select "+$tongue);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select tempWeightCube;
	select -add $tempString;
	}
else
	{
	select tempWeightCube;
	select -add $tongue;
	}

copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
//skinCluster -e -removeUnusedInfluence 1 $tongueSkinCluster;
if ($modifier!=4)
	delete tempWeightCube;

select -cl;
}

global proc asFaceTongueFinish ()
{
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $tempString[],$allFaceGeo[],$infs[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

if (!`objExists FaceFitTongue`)//skip
	return;

if (`objExists tempWeightCube`)
	delete tempWeightCube;

//Display all again, after finishing tongue
if (!`gmatch $tongue "*[.]*"`)
	for ($i=0;$i<size($allFaceGeo);$i++)
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 1;
}

global proc asFaceRegions ()
{
string $tempString[];

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceTongueFinish;

asFaceHideControllers 1;
setAttr ctrlBox2.v 1;
setAttr ctrlBox.RegionsCtrlVis 1;
catchQuiet (`setAttr EyeRegionOffset_R.v 1`);
catchQuiet (`setAttr EyeRegionOffset_L.v 1`);
catchQuiet (`setAttr EyeBrowRegionOffset_R.v 1`);
catchQuiet (`setAttr EyeBrowRegionOffset_L.v 1`);
catchQuiet (`setAttr EyeBrowRegionOffset_M.v 1`);
catchQuiet (`setAttr NoseRegionOffset_M.v 1`);
catchQuiet (`setAttr LipRegionOffset_M.v 1`);

//ctrlBox2
$tempString=`listRelatives -c -type transform ctrlBox2`;
for ($i=0;$i<size($tempString);$i++)
	{
	$ctrl=`substitute "1" $tempString[$i] ""`;
	if (!`objExists $ctrl`)
		{
		setAttr ($tempString[$i]+".v") 0;
		continue;
		}
	asAddCtrlBox2Shape $ctrl;
	}

asShowLayer Normal;
select -cl;
}

global proc asFaceEyeAim ()
{
asFaceHideControllers 1;

setAttr ctrlBox2.v 0;
setAttr ctrlBox.RegionsCtrlVis 0;
setAttr ctrlBox.AimCtrlVis 1;
setAttr AimEyeOffset_M.v 1;
select -cl;
}

global proc asFaceUpMidLo ()
{
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $numVtx;
int $tempInts[],$vtxNrs[];
float $pos[],$posA[],$posB[],$weights[],$values[];
float $headJointWeights[],$upperFaceWeights[],$middleFaceWeights[],$lowerFaceWeights[];
float $headJointWeight,$upperFaceWeight,$middleFaceWeight,$lowerFaceWeight;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $centerTolerance=0.01*$scale;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $rightEye=`textField -q -tx asFaceRightEyeTextField`;
string $leftEye=`textField -q -tx asFaceLeftEyeTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $eyeBrow=`textField -q -tx asFaceEyebrowTextField`;
string $eyeLash=`textField -q -tx asFaceEyelashTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $nonOverriddenHeadJoint=$headJoint;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $sc;
string $tempString[],$infs[],$allFaceGeo[],$definedGeos[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

setAttr ctrlBox.AimCtrlVis 0;

if (!`objExists upperFace`)//skip
	return;

if ($multiSkinClusters)
	{
	$skinCluster=`asFaceMultiSkinClusterAdd "UpMidLoc"`; 
	$headJoint="MultiSkinClustersFaceUpMidLocJoint_M";
	}

//create LayerMesh (weightBysoftmod ignores locked weights)
duplicate -n UpMidLoLayer templateLayer;
duplicate -n UpMidLoAllHeadCombinedLayer allHeadCombinedLayer;
asShowLayer UpMidLo;
parent -w UpMidLoLayer;

asFaceHideControllers 1;
setAttr ctrlBox2.v 1;
setAttr ctrlBox.UpMidLoCtrlVis 1;

asFaceLockWeights 1;
setAttr ($headJoint+".lockInfluenceWeights") 0;
if ($multiSkinClusters)
	setAttr MultiSkinClustersFaceUpMidLocJoint_M.lockInfluenceWeights 0;

for ($a=0;$a<3;$a++)
	{
	if ($a==0) $upperLower="upper";
	if ($a==1) $upperLower="middle";
	if ($a==2) $upperLower="lower";

	select FaceJoint_M;
	joint -n ($upperLower+"FaceJoint_M");
	setAttr ($upperLower+"FaceJoint_M.segmentScaleCompensate") 0;
	$pos=`xform -q -ws -t ($upperLower+"Face")`;
	xform -ws -t 0 $pos[1] $pos[2] ($upperLower+"FaceJoint_M");
	$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 180 -r 4 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
	rename $tempString[0] ($upperLower+"Face"+"_M");
	connectAttr ctrlBox.UpMidLoCtrlVis ($upperLower+"Face"+"_MShape.overrideVisibility");
	$posB=`xform -q -ws -t JawPivot`;
	scale -r -p 0 0 0 ((-4.5*$posB[0])/$scale) ((-4.5*$posB[0])/$scale) ((-4.5*$posB[0])/$scale) ($upperLower+"Face"+"_M.cv[0:99]");
	rotate -r 0 -90 0 ($upperLower+"Face"+"_M.cv[0:99]");
	sets -add FaceControlSet ($upperLower+"Face"+"_M");
	setAttr ($upperLower+"Face"+"_MShape.overrideEnabled") 1;
	setAttr ($upperLower+"Face"+"_MShape.overrideColor") 17;
	createNode -n ($upperLower+"FaceOffset_M") transform;
	parent ($upperLower+"Face"+"_M") ($upperLower+"FaceOffset_M");
	parent ($upperLower+"FaceOffset_M") OnFacecontrols;
	setAttr ($upperLower+"FaceOffset_M.s") -type float3 1 1 1;
	asAlign ($upperLower+"FaceOffset_M") ($upperLower+"FaceJoint_M") 1 0 0 0;
	asParentConstraint ($upperLower+"Face"+"_M") ($upperLower+"Face"+"Joint_M") "-mo"; 

	if ($multiSkinClusters)//inverseMatrix out HeadJoint
		{
		connectAttr -f ($nonOverriddenHeadJoint+".worldInverseMatrix") ($upperLower+"FaceJointMM_M.matrixIn[2]");
		$m=`getAttr ($nonOverriddenHeadJoint+".worldMatrix")`;
		setAttr ($upperLower+"FaceJointMM_M.matrixIn[3]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		connectAttr FaceJoint_M.worldInverseMatrix ($upperLower+"FaceJointMM_M.matrixIn[4]");
		}
	if (!$multiSkinClusters)
		{
		createNode -n ($upperLower+"SideReverse_R") -p SideReverse_R transform;
		createNode -n ($upperLower+"SideReverse_L") -p SideReverse_L transform;
		createNode -n ($upperLower+"SideReverse_M") -p SideReverse_M transform;
		parent ($upperLower+"SideReverse_R") ($upperLower+"SideReverse_L") ($upperLower+"SideReverse_M") ($upperLower+"Face_M");
		}

	asAddCtrlBox2Shape ($upperLower+"Face"+"_M");
	}

if (!$multiSkinClusters)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";

		if (`asFaceIncludeAboveEyes`)
			parent ("EyeRegionOffset"+$side) ("EyeOffset"+$side) ("EyeBrowRegionOffset"+$side) ("upperSideReverse"+$side);
		parent ("middleFaceStatic"+$side) ("middleSideReverse"+$side);
		parent ("lowerFaceStatic"+$side) ("SmilePullOffset"+$side) ("lowerSideReverse"+$side);
		}

	if (`asFaceIncludeAboveEyes`)
		parent EyeBrowCenterOffset_M NoseCreaseOffset_M upperSideReverse_M;
	parent NoseRegionOffset_M  middleFaceStatic_M middleSideReverse_M;
	//if (`objExists NoseBridgeOffset_M`) parent NoseBridgeOffset_M middleSideReverse_M;
	parent JawOffset_M lowerFaceStatic_M lowerSideReverse_M;
	if (`objExists upperTeethOffset_M`) parent upperTeethOffset_M lowerSideReverse_M;
	}

//UpMidLoLayer
select FaceJoint_M upperFaceJoint_M middleFaceJoint_M lowerFaceJoint_M UpMidLoLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] UpMidLoSC;
skinPercent -tv middleFaceJoint_M 1 UpMidLoSC UpMidLoLayer;

$posA=`xform -q -ws -t upperFace`;
select UpMidLoLayer;
polySelectConstraint -m 3 -t 1 -d 3 -db $posA[1] 9999 -da 0 1 0 -dp 0 0 0;
skinPercent -tv upperFaceJoint_M 1 UpMidLoSC;
$posA=`xform -q -ws -t lowerFace`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 $posA[1] -da 0 1 0 -dp 0 0 0;
skinPercent -tv lowerFaceJoint_M 1 UpMidLoSC;
polySelectConstraint -m 0;
select UpMidLoLayer;
asSmoothFlood upperFaceJoint_M middleFaceJoint_M 10;
asSmoothFlood lowerFaceJoint_M middleFaceJoint_M 10;
asSmoothFlood lowerFaceJoint_M FaceJoint_M 10;

//transfer to $geometry
skinCluster -e -lw false -wt 0 -ai upperFaceJoint_M -ai middleFaceJoint_M -ai lowerFaceJoint_M $skinCluster;

//lipSlideSurface
skinCluster -e -lw false -wt 0 -ai lowerFaceJoint_M lipSlideSurfaceSC;
skinPercent -tv lowerFaceJoint_M 1 lipSlideSurfaceSC lipSlideSurface;

$tempInts=`polyEvaluate -v $geometry`;
$numVtx=$tempInts[0];
for ($i=0;$i<$numVtx;$i++)
	{
	$pos=`xform -q -ws -t ("UpMidLoLayer.vtx["+$i+"]")`;
	if (!$nonSymmetrical && $pos[0]>($centerTolerance))
		continue;

	$infs=`skinPercent -ignoreBelow 0.01 -q -t $skinCluster ($geometry+".vtx["+$i+"]")`;
	$values=`skinPercent -ignoreBelow 0.01 -q -v $skinCluster ($geometry+".vtx["+$i+"]")`;
	if (!`stringArrayCount $headJoint $infs`)
		continue;
	$vtxNrs[size($vtxNrs)]=$i;
	$headJointWeight=`skinPercent -t $headJoint -q -v $skinCluster ($geometry+".vtx["+$i+"]")`;
	$headJointWeights[size($headJointWeights)]=0;

	$upperFaceWeight =`skinPercent -t upperFaceJoint_M  -q -v UpMidLoSC ("UpMidLoLayer.vtx["+$i+"]")`;
	$middleFaceWeight =`skinPercent -t middleFaceJoint_M  -q -v UpMidLoSC ("UpMidLoLayer.vtx["+$i+"]")`;
	$lowerFaceWeight =`skinPercent -t lowerFaceJoint_M  -q -v UpMidLoSC ("UpMidLoLayer.vtx["+$i+"]")`;

	$upperFaceWeights[size($upperFaceWeights)] = $headJointWeight * $upperFaceWeight;
	$middleFaceWeights[size($middleFaceWeights)] = $headJointWeight * $middleFaceWeight;
	$lowerFaceWeights[size($lowerFaceWeights)] = $headJointWeight * $lowerFaceWeight;
	}
asSkinWeightSet $headJoint $geometry $skinCluster $vtxNrs $headJointWeights;
asSkinWeightSet upperFaceJoint_M $geometry $skinCluster $vtxNrs $upperFaceWeights;
asSkinWeightSet middleFaceJoint_M $geometry $skinCluster $vtxNrs $middleFaceWeights;
asSkinWeightSet lowerFaceJoint_M $geometry $skinCluster $vtxNrs $lowerFaceWeights;

if (!$nonSymmetrical)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//transfer to objects other then $geometry
$definedGeos[0]=$geometry;
$tempString=`stringToStringArray $rightEye " "`; $definedGeos=`stringArrayCatenate $definedGeos $tempString`;
$tempString=`stringToStringArray $leftEye " "`; $definedGeos=`stringArrayCatenate $definedGeos $tempString`;
$tempString=`stringToStringArray $upperTeeth " "`; $definedGeos=`stringArrayCatenate $definedGeos $tempString`;
$tempString=`stringToStringArray $lowerTeeth " "`; $definedGeos=`stringArrayCatenate $definedGeos $tempString`;
$tempString=`stringToStringArray $tongue " "`; $definedGeos=`stringArrayCatenate $definedGeos $tempString`;
$tempString=`stringToStringArray $eyeBrow " "`; $definedGeos=`stringArrayCatenate $definedGeos $tempString`;
$tempString=`stringToStringArray $eyeLash " "`; $definedGeos=`stringArrayCatenate $definedGeos $tempString`;
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	if ($multiSkinClusters)
		{
		if ($allFaceGeo[$i]==$geometry)
			continue;

		select $allFaceGeo[$i] MultiSkinClustersFaceUpMidLocJoint_M upperFaceJoint_M middleFaceJoint_M lowerFaceJoint_M;
		$tempString=`skinCluster -multi 1 -frontOfChain -toSelectedBones`;
		$sc=`rename $tempString[0] UpMidLocSC`;
		select UpMidLoLayer $allFaceGeo[$i];
		copySkinWeights -ss $skinCluster -ds $sc -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}
	else
		{
		if (`stringArrayCount $allFaceGeo[$i] $definedGeos`)
			continue;

		$sc=`asGetSkinCluster $allFaceGeo[$i]`;
		skinCluster -e -lw false -wt 0 -ai upperFaceJoint_M -ai middleFaceJoint_M -ai lowerFaceJoint_M $sc;
		select UpMidLoLayer $allFaceGeo[$i];
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}
	}

//asFaceHideControllers 0;
parent UpMidLoLayer DeformationLayers;
asShowLayer Normal;
}

global proc asFacePhonemes ()
{
int $inputNr;
float $scale=`asGetScale`;
float $value;
float $pos[],$rot[],$values[],$tValues[],$rValues[];
string $frownBulgeTowardsVtx,$side,$bw,$lipJaw;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[],$tempString2[],$tempString3[],$tempString3A[],$tempString4[];
string $phonemes[]={"aaa","eh","ahh","ohh","uuu","iee","rrr","www","sss","fff","tth","mbp","ssh","schwa","gk","lntd"};
string $mouthWideCtrls[]={"SDKLip","SmileBulge","FrownBulge","Cheek","NoseCorner"};
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};

if (`attributeExists Phonemes FaceFitSkeleton`)
	if (!`getAttr FaceFitSkeleton.Phonemes`)
		return;

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceHideControllers 1;
setAttr ctrlBox2.v 0;
setAttr ctrlBox.AimCtrlVis 0;
setAttr ctrlBoxPhonemes_M.v 1;

asShowLayer Normal;

if (`objExists upperFaceLocator_M`) delete upperFaceLocator_M;
if (`objExists lowerFaceLocator_M`) delete lowerFaceLocator_M;
if (`objExists underFaceLocator_M`) delete underFaceLocator_M;

//store LipSmileValues
xform -os -t 1 1 0 ctrlMouthCorner_R;
createNode -n LipSmileValues -p SDKLip_R transform;
parent LipSmileValues `listRelatives -p SDKLip_R`;
xform -os -t 0 0 0 ctrlMouthCorner_R;

createNode -n tempXform transform;
createNode -n tempXform2 transform;

for ($i=0;$i<size($phonemes);$i++)
	{
	addAttr -k 1 -ln $phonemes[$i] -at double -smn 0 -hsn 1 -smx 10 -hsx 1 ctrlPhonemes_M;
	asEnsureOutputBlendWeighted ("ctrlPhonemes_M."+$phonemes[$i]);
	}

addAttr -k 1 -ln multipliers ctrlPhonemes_M;
setAttr ctrlPhonemes_M.multipliers -l 1;
addAttr -k 1 -ln jaw -at double -smn 0 -hsn 1 -smx 2 -hsx 1 -dv 1 ctrlPhonemes_M;
asEnsureOutputBlendWeighted ctrlPhonemes_M.jaw;
addAttr -k 1 -ln lip -at double -smn 0 -hsn 1 -smx 2 -hsx 1 -dv 1 ctrlPhonemes_M;
asEnsureOutputBlendWeighted ctrlPhonemes_M.lip;

//find $SmileTowardsVtx
if (`objExists tempNearestPointOnCurve`) delete tempNearestPointOnCurve;
createNode -n tempNearestPointOnCurve nearestPointOnCurve;
connectAttr -f JawCurve.worldSpace[0] tempNearestPointOnCurve.inputCurve;
$pos=`xform -q -ws -t SmileBulge`;
setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
$pos=`getAttr tempNearestPointOnCurve.result.position`;
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$frownBulgeTowardsVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete tempNearestPointOnCurve closestSampler;

//jawPhonemes
for ($i=0;$i<size($phonemes);$i++)
	{
	$value=0;
	if ($phonemes[$i]=="aaa") $value=0.9;
	if ($phonemes[$i]=="eh") $value=0.5;
	if ($phonemes[$i]=="ahh") $value=1.0;
	if ($phonemes[$i]=="ohh") $value=0.75;
	if ($phonemes[$i]=="uuu") $value=0.25;
	if ($phonemes[$i]=="iee") $value=0.25;
	if ($phonemes[$i]=="rrr") $value=0.5;
	if ($phonemes[$i]=="www") $value=0.4;
	if ($phonemes[$i]=="mbp") $value=0.4;
	if ($phonemes[$i]=="fff") $value=0.2;
	if ($phonemes[$i]=="tth") $value=0.2;
	if ($phonemes[$i]=="schwa") $value=0.5;
	if ($phonemes[$i]=="gk") $value=0.5;
	if ($phonemes[$i]=="lntd") $value=0.5;
	if ($value!=0)
		{
		setAttr ctrlMouth_M.ty (-1*$value);
		$pos=`getAttr SDKJaw_M.t`;
		$rot=`getAttr SDKJaw_M.r`;
		setAttr ctrlMouth_M.ty 0;
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKJaw_M.ty 10 $pos[1];	
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKJaw_M.tz 10 $pos[2];	
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKJaw_M.rx 10 $rot[0];	
		}
	}

//jaw Translate Forward Phonemes
for ($i=0;$i<size($phonemes);$i++)
	{
	$value=0;
	if ($phonemes[$i]=="ohh") {$value=0.1;}
	if ($phonemes[$i]=="sss") {$value=0.1;}
	if ($phonemes[$i]=="ssh") {$value=0.1;}
	if ($value!=0)
//		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) bwctrlMouth_M_jawForward.input 10 $value;
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) "SDKJaw_M.tz" 10 $value;
	}

	// Mouth narrowWide
for ($i=0;$i<size($phonemes);$i++)
	{
	$value=0;
	if ($phonemes[$i]=="aaa") $value=0.3;
	if ($phonemes[$i]=="eh") $value=0.5;
	if ($phonemes[$i]=="ohh") $value=-0.65;
	if ($phonemes[$i]=="uuu") $value=-0.75;
	if ($phonemes[$i]=="iee") $value=0.5;
	if ($phonemes[$i]=="www") $value=-1;
	if ($phonemes[$i]=="sss") $value=-0.15;
	if ($phonemes[$i]=="fff") $value=0.2;
	if ($phonemes[$i]=="ssh") $value=-0.4;
	if ($value!=0)
		{
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) $side="_R"; else $side="_L";

			for ($y=0;$y<size($mouthWideCtrls);$y++)
				{
				setAttr ctrlMouth_M.tx $value;
				$pos=`getAttr ($mouthWideCtrls[$y]+$side+".t")`;
				setAttr ctrlMouth_M.tx 0;
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) ($mouthWideCtrls[$y]+$side+".tx") 10 $pos[0];
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) ($mouthWideCtrls[$y]+$side+".ty") 10 $pos[1];
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) ($mouthWideCtrls[$y]+$side+".tz") 10 $pos[2];
				}
			}
		}
	}

//Other controls
for ($i=0;$i<size($phonemes);$i++)
	{
	setAttr ("ctrlPhonemes_M."+$phonemes[$i]) 10;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";

		//MouthCorner upDown
		$value=0;
		if ($phonemes[$i]=="iee") $value=0.2;
		if ($phonemes[$i]=="fff") $value=0.2;
		if ($value!=0)
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) ("SDKLip"+$side+".ty") 10 (`getAttr LipSmileValues.ty`*$value);
		}

	//upperLip_M
	$values={0,0,0};
	if ($phonemes[$i]=="ohh") {$values[2]=0.25;}
	if ($phonemes[$i]=="uuu") {$values[2]=0.45;}
	if ($phonemes[$i]=="iee") {$values[1]=0.1;}
	if ($phonemes[$i]=="rrr") {$values[1]=0.1;$values[2]=0.1;}
	if ($phonemes[$i]=="mbp") {$values[1]=-0.45;$values[2]=-0.45;}
	if ($phonemes[$i]=="sss") {$values[1]=0.1;}
	if ($phonemes[$i]=="ssh") {$values[1]=0.1;$values[2]=0.25;}
	if ($values[0]!=0 || $values[1]!=0 || $values[2]!=0)
		{
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.ty 10 $values[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.tz 10 $values[2];
		}

	//lowerLip_M
	$values={0,0,0};
	if ($phonemes[$i]=="ohh") {$values[2]=0.25;}
	if ($phonemes[$i]=="uuu") {$values[2]=0.45;}
	if ($phonemes[$i]=="iee") {$values[1]=-0.45;}
	if ($phonemes[$i]=="rrr") {$values[1]=-0.1;$values[2]=0.1;}
	if ($phonemes[$i]=="mbp") {$values[1]=0.25;$values[2]=-0.25;}
	if ($phonemes[$i]=="sss") {$values[1]=-0.45;}
	if ($phonemes[$i]=="fff") {$values[2]=-0.25;}
	if ($phonemes[$i]=="ssh") {$values[1]=-0.25;$values[2]=0.25;}
	if ($values[0]!=0 || $values[1]!=0 || $values[2]!=0)
		{
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.ty 10 $values[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.tz 10 $values[2];
		}

	//upperLip_M roll
	$value=0;
	if ($phonemes[$i]=="ohh") $value=3;
	if ($phonemes[$i]=="uuu") $value=6;
	if ($phonemes[$i]=="rrr") $value=3;
	if ($phonemes[$i]=="www") $value=3;
	if ($phonemes[$i]=="mbp") $value=-6;
	if ($phonemes[$i]=="sss") $value=1.5;
	if ($phonemes[$i]=="tth") $value=2;
	if ($phonemes[$i]=="ssh") $value=5;
	if ($value!=0)
		{
		setAttr ctrlLips_M.upperRoll $value;
		$pos=`getAttr SDKupperLip_M.t`;
		$rot=`getAttr SDKupperLip_M.r`;
		setAttr ctrlLips_M.upperRoll 0;
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.tx 10 $pos[0];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.ty 10 $pos[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.tz 10 $pos[2];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.rx 10 $rot[0];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.ry 10 $rot[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKupperLip_M.rz 10 $rot[2];
		}

	//lowerLip_M roll
	$value=0;
	if ($phonemes[$i]=="ohh") $value=3;
	if ($phonemes[$i]=="uuu") $value=6;
	if ($phonemes[$i]=="rrr") $value=3;
	if ($phonemes[$i]=="www") $value=3;
	if ($phonemes[$i]=="mbp") $value=-4;
	if ($phonemes[$i]=="sss") $value=3;
	if ($phonemes[$i]=="fff") $value=-5;
	if ($phonemes[$i]=="tth") $value=2;
	if ($phonemes[$i]=="ssh") $value=5;
	if ($value!=0)
		{
		setAttr ctrlLips_M.lowerRoll $value;
		$pos=`getAttr SDKlowerLip_M.t`;
		$rot=`getAttr SDKlowerLip_M.r`;
		setAttr ctrlLips_M.lowerRoll 0;
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.tx 10 $pos[0];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.ty 10 $pos[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.tz 10 $pos[2];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.rx 10 $rot[0];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.ry 10 $rot[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) SDKlowerLip_M.rz 10 $rot[2];
		}

	//tongue
	$values={0,0,0};// Rz of tongue1,2,3
	if ($phonemes[$i]=="rrr") {$values[0]=17;$values[1]=17;$values[2]=17;}
	if ($phonemes[$i]=="tth") {$values[0]=10;$values[1]=10;$values[2]=10;}
	if ($phonemes[$i]=="gk") {$values[0]=0;$values[1]=40;$values[2]=-80;}
	if ($phonemes[$i]=="lntd") {$values[0]=0;$values[1]=10;$values[2]=40;}
	if (($values[0]!=0 || $values[1]!=0 || $values[2]!=0) && `objExists Tongue3_M`)
		for ($a=1;$a<4;$a++)
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]) ("SDKTongue"+$a+"_M.rz") 10 $values[$a];

	setAttr ("ctrlPhonemes_M."+$phonemes[$i]) 0;
	}

//connect the Jaw/Lip Multiplier to the weights
$tempString=`listConnections -s 0 -d 1 -type blendWeighted ctrlPhonemes_M`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 0 -d 1 -type animCurve $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		$tempString3=`listConnections -s 0 -d 1 -type blendWeighted $tempString2[$y]`;
		$tempString3A=`listConnections -s 0 -d 1 -p 1 -type blendWeighted $tempString2[$y]`;
		for ($z=0;$z<size($tempString3);$z++)
			{
			$bw=$tempString3[$z];
			tokenize $tempString3A[0] "[" $tempString4;			
			$inputNr=`substitute "]" $tempString4[1] ""`;
			$lipJaw="lip";
			if (`gmatch $bw "*Jaw_M*"` || $bw=="bwctrlMouth_M_translateY")
				$lipJaw="jaw";
			if (!`isConnected ("bwctrlPhonemes_M_"+$lipJaw+".output") ($bw+".weight["+$inputNr+"]")`)
				connectAttr ("bwctrlPhonemes_M_"+$lipJaw+".output") ($bw+".weight["+$inputNr+"]");
			}
		}
	}

delete tempXform tempXform2;
//select ctrlPhonemes_M;
select -cl;
}

global proc asFaceEmotions ()
{
int $smilePullInputNum=1;
float $value;
float $pos[],$pos2[],$rot[];
string $driver;
string $emotions[]={"happy","angry","sad","surprise","fear","disgust","contempt"};
string $eyeBrowLocs[]={"EyeBrowInner","EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowOuter"};
string $tempString[];

if (`attributeExists Emotions FaceFitSkeleton`)
	if (!`getAttr FaceFitSkeleton.Emotions`)
		return;

if (!`objExists upperLipMainCurve`)//skip
	return;

asFaceHideControllers 1;
setAttr ctrlBoxEmotions_M.v 1;

for ($i=0;$i<size($emotions);$i++)
	{
	addAttr -k 1 -ln $emotions[$i] -at double -smn 0 -hsn 1 -smx 10 -hsx 1 ctrlEmotions_M;
	asEnsureOutputBlendWeighted ("ctrlEmotions_M."+$emotions[$i]);
	}

//happy
$driver="ctrlEmotions_M.happy";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	asDsSdk $driver ("SDKEyeBrowOuter"+$side+".ty") 10 -0.1;

	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateX.input") 10 1;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateY.input") 10 1;
	asDsSdk $driver ("bwctrlEye"+$side+"_blink.input") 10 3;
	}
asDsSdk $driver SDKupperLip_M.ty 10 0.1;
asDsSdk $driver SDKlowerLip_M.ty 10 0.1;
asDsSdk $driver SDKNoseRegion_M.tz 10 -0.1;
asDsSdk $driver SDKNoseRegion_M.rx 10 5;
setAttr $driver 10;refresh;setAttr $driver 0;

//angry
$driver="ctrlEmotions_M.angry";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	
	asDsSdk $driver ("bwctrlBrow"+$side+"_translateX.input") 10 -0.5;
	asDsSdk $driver ("bwctrlBrow"+$side+"_translateY.input") 10 -0.5;
	asDsSdk $driver ("bwctrlBrow"+$side+"_squeeze.input") 10 8;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateX.input") 10 -0.5;
//	asDsSdk $driver ("SDKNoseCorner"+$side+".tx") 10 -0.5;
	asDsSdk $driver ("bwctrlEye"+$side+"_blink.input") 10 3;
	asDsSdk $driver ("bwctrlEye"+$side+"_squint.input") 10 3;
	if (`objExists Nostril_R`)
		asDsSdk $driver ("SDKNostril"+$side+".tx") 10 0.2;
	}
asDsSdk $driver ("bwctrlLips_M_upperSqueeze.input") 10 5;
asDsSdk $driver ("bwctrlLips_M_lowerSqueeze.input") 10 5;
setAttr $driver 10;refresh;setAttr $driver 0;

//sad
$driver="ctrlEmotions_M.sad";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	asDsSdk $driver ("bwctrlBrow"+$side+"_translateX.input") 10 0.5;
	asDsSdk $driver ("bwctrlBrow"+$side+"_translateY.input") 10 -0.5;
	asDsSdk $driver ("bwctrlBrow"+$side+"_squeeze.input") 10 5;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateX.input") 10 0.5;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateY.input") 10 -0.5;
	asDsSdk $driver ("bwctrlEye"+$side+"_blink.input") 10 3;
	asDsSdk $driver ("bwctrlEye"+$side+"_squint.input") 10 3;
//	if (`objExists Nostril_R`)
//		asDsSdk $driver ("SDKNostril"+$side+".tx") 10 0.4;
	}
asDsSdk $driver ("bwctrlLips_M_upperSqueeze.input") 10 3;
asDsSdk $driver ("bwctrlLips_M_lowerSqueeze.input") 10 3;
setAttr $driver 10;refresh;setAttr $driver 0;

//surprise
$driver="ctrlEmotions_M.surprise";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	asDsSdk $driver ("bwctrlBrow"+$side+"_translateY.input") 10 0.75;
	asDsSdk $driver ("bwctrlEye"+$side+"_blink.input") 10 -1;
	asDsSdk $driver ("bwctrlEye"+$side+"_squint.input") 10 -1;
	}
asDsSdk $driver bwctrlMouth_M_translateY.input 10 -1;
setAttr $driver 10;refresh;setAttr $driver 0;

//fear
$driver="ctrlEmotions_M.fear";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	asDsSdk $driver ("bwctrlBrow"+$side+"_translateX.input") 10 1.0;
	asDsSdk $driver ("bwctrlBrow"+$side+"_squeeze.input") 10 7;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateX.input") 10 0.4;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateY.input") 10 -0.25;
	asDsSdk $driver ("SDKNoseCorner"+$side+".ty") 10 -0.1;
	if (`objExists lowerLidOuter_R`)
		asDsSdk $driver ("SDKlowerLidOuter"+$side+".ty") 10 -0.1;
	asDsSdk $driver ("SDKupperLid"+$side+".ty") 10 0.1;
	asDsSdk $driver ("SDKlowerLid"+$side+".ty") 10 -0.1;
	}
asDsSdk $driver bwctrlMouth_M_translateY.input 10 -0.75;
asDsSdk $driver ("bwctrlLips_M_upperSqueeze.input") 10 3;
asDsSdk $driver ("bwctrlLips_M_lowerSqueeze.input") 10 3;
setAttr $driver 10;refresh;setAttr $driver 0;

//disgust
$driver="ctrlEmotions_M.disgust";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	
//	asDsSdk $driver ("bwctrlBrow"+$side+"_translateX.input") 10 -0.5;
//	asDsSdk $driver ("bwctrlBrow"+$side+"_translateY.input") 10 -0.5;
	asDsSdk $driver ("bwctrlBrow"+$side+"_squeeze.input") 10 5;

	asDsSdk $driver ("bwctrlEye"+$side+"_squint.input") 10 3;
	asDsSdk $driver ("bwctrlNose"+$side+"_translateY.input") 10 0.75;
	asDsSdk $driver ("bwctrlCheek"+$side+"_translateY.input") 10 1;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateX.input") 10 0.25;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateY.input") 10 -0.25;
//	asDsSdk $driver ("SDKNoseCorner"+$side+".ty") 10 0.3;
	}
asDsSdk $driver SDKlowerLip_M.ty 10 -0.5;
setAttr $driver 10;refresh;setAttr $driver 0;

//contempt
$driver="ctrlEmotions_M.contempt";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateX.input") 10 0.6;
	asDsSdk $driver ("bwctrlMouthCorner"+$side+"_translateY.input") 10 0.3;
	}
setAttr $driver 10;refresh;setAttr $driver 0;

//select ctrlEmotions_M;
select -cl;
}

global proc asFaceDsSdk ()
{
if (!`objExists upperLipMainCurve`)//skip
	return;

//add jawForward
addAttr -k 1 -ln jawForward -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
asEnsureOutputBlendWeighted ctrlMouth_M.jawForward;
asDsSdk ctrlMouth_M.jawForward SDKJaw_M.tz 10 2;

//add jawSide
addAttr -k 1 -ln jawSide -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
asEnsureOutputBlendWeighted ctrlMouth_M.jawSide;
asDsSdk ctrlMouth_M.jawSide SDKJaw_M.ry 10 15;
}

global proc asFaceExtras ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $extras=`textField -q -tx asFaceExtrasTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $cmd,$sc;
string $extraGeos[],$tempString[],$faceJoints[],$alreadyInfluencingJoints[];

$extraGeos=`stringToStringArray $extras " "`;
$faceJoints=`listRelatives -ad -type joint FaceJoint_M`;
$faceJoints[size($faceJoints)]="FaceJoint_M";

for ($i=0;$i<size($extraGeos);$i++)
	{
	print ("// Weighting Extras object: \""+$extraGeos[$i]+"\".\n");
	$sc=`asGetSkinCluster $extraGeos[$i]`;
	if ($sc==$skinCluster)//if extraGeo is part of Main mesh
		continue;
	$alreadyInfluencingJoints=`listConnections -s 1 -d 0 -type joint $sc`;
	$cmd="skinCluster -e";
	for ($y=0;$y<size($faceJoints);$y++)
		if ($faceJoints[$y]!=$headJoint)
			if (!`stringArrayCount $faceJoints[$y] $alreadyInfluencingJoints`)
				$cmd+=" -ai "+$faceJoints[$y];
	$cmd+=" "+$sc;
	eval $cmd;
	select $geometry $extraGeos[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	removeUnusedForSkin $sc 0;
	}
select -cl;
}

global proc asFaceFinish ()
{
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $numMatrix;
float $radius;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $setAttrCmd;
string $controlSetMembers[],$tempString[],$tempString2[],$deleteObjs[];

asFaceDsSdk;//some extra DrivingSystems
asFaceExtras;

//default visibilities
asFaceHideControllers 0;
setAttr ctrlBox2.v 1;
refresh;
//setAttr ctrlBox.RegionsCtrlVis 1;
setAttr ctrlBox.EyeCtrlVis 0;
setAttr ctrlBox.AimCtrlVis 1;

asFaceLockWeights 0;

//prune small weights
select $geometry;
skinPercent -pruneWeights 0.01 $skinCluster;

//jointRadius
$tempString=`listRelatives -ad -type joint FaceJoint_M`;
$tempString[size($tempString)]="FaceJoint_M";
for ($i=0;$i<size($tempString);$i++)
	{
	$radius=0.2;
	if (`gmatch $tempString[$i] "*LidMain*"`)
		$radius=0.1;
	if (`gmatch $tempString[$i] "*LipJoint*"`)
		$radius=0.1;
	setAttr ($tempString[$i]+".radius") $radius;
	}

//move constraints
$tempString=`listRelatives -ad -type constraint FaceJoint_M`;
if (size($tempString))
	parent $tempString DeformJointConstraints;

//Keep FaceControlOrient as a FitElement
if (`objExists FaceControlOrient`)
	{
	if (!`objExists FaceFitControlOrient`)
		createNode -n FaceFitControlOrient -p FaceFitSkeleton transform;
	parent FaceControlOrient FaceFitControlOrient;
	setAttr FaceControlOrient.v 0; 
	}

$deleteObjs={"tempLocFlip","FaceBuildInProgress","DeformationLayers","SmileBulgePulled","FrownBulgePulled"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

//delete tempGenerated Left fitters
if (!$nonSymmetrical)
	{
	$tempString=`listRelatives -c -type transform FaceFitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "*Left"`)
			delete $tempString[$i];
	}

//merge eyeLidArea & eyeLidAreaLeft
if (`objExists eyeLidAreaLeft`)
	{
	select eyeLidAreaLeft;
	sets -add eyeLidArea `ls -sl`;
	delete eyeLidAreaLeft;
	}

if (`attributeExists RobloxHead FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.RobloxHead`)
		asFaceRobloxHead;

if (`attributeExists ARKit FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.ARKit`)
		asConnectARKit "";

if (`attributeExists SnapChat FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.SnapChat`)
		asConnectARKit "";

//Also update buildPose
select `sets -q FaceControlSet`;
$controlSetMembers=`ls -sl`;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k -shortNames $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

//version
if (!`attributeExists version FaceGroup`)
	addAttr -ln version -at double FaceGroup;
setAttr -l 0 FaceGroup.version;
setAttr -l 1 FaceGroup.version `asGetScriptVersion`;

catchQuiet (`setAttr FaceFitSkeleton.buildCompleted 1`);

//update AllSet
select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
select -d allBeforeFaceBuild;
//not include any `intermediate` meshes, as these most likely belong to the model
select -d `ls -type mesh -intermediateObjects`;
//not include any Fit-elements that might have been created in the Build e.g. JawCurves & FaceControlOrient
select -d `listRelatives -ad FaceFitSkeleton`;
//include "FaceAreas" sets
select -add -ne `sets -q FaceAreas` FaceAreas;
sets -add FaceAllSet `ls -sl`;

sets -rm FaceBuildingSets allBeforeFaceBuild;
delete `sets -q FaceBuildingSets`;

//asEnsureSDKcurvesNamed;

//name auto generated unitConversion nodes
$tempString=`ls -type unitConversion`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]` && `gmatch $tempString[$i] "unitConversion*"`)
		{
		$tempString2=`listConnections -s 1 -d 0 -p 1 $tempString[$i]`;
		rename $tempString[$i] (`substitute "[.]" $tempString2[0] "_"`+"UC");
		}

asGoToBuildPose faceSetup;//as we might have "keept buildpose" from previous build.

//Resore any deltaMush
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="deltaMush")
		setAttr ($tempString[$y]+".envelope") 1;

//isHistoricallyInteresting
asSetIsHistoricallyInteresting FaceControlSet;

if (`attributeExists RigType FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.RigType`>0)//blendshapes
		if (!`objExists asFaceBS`)//if rebuilding, asBSConvertDStoBS happens in asFaceRebuildRestore
			{
			checkBox -e -v (`getAttr FaceFitSkeleton.RigType`-1) asKeepJointsCheckBox;
			asBSConvertDStoBS;
			}

cycleCheck -e on;

evalDeferred ("sets -clear allBeforeFaceBuild;delete allBeforeFaceBuild;");


asUpdateButtonEnables;
select -cl;
print ("// Advanced Face created\n");
}

global proc asFaceRobloxHead ()
{
int $autoKeyState=`autoKeyframe -q -state`;
string $side,$leftRight,$oppositeSide;
//Roblox shapes from https://github.com/Roblox/avatar/tree/main/Dynamic_Head/FACS_Controls
string $rbShapes[]={"ChinRaiserUpperLip","ChinRaiser","FlatPucker","Funneler","LowerLipSuck","LipPresser","LipsTogether","MouthLeft",
									"MouthRight","Pucker","UpperLipSuck","LeftCheekPuff","LeftDimpler","LeftLipCornerDown","LeftLowerLipDepressor",
									"LeftLipCornerPuller","LeftLipStretcher","LeftUpperLipRaiser","RightCheekPuff","RightDimpler","RightLipCornerDown",
									"RightLowerLipDepressor","RightLipCornerPuller","RightLipStretcher","RightUpperLipRaiser","JawDrop","JawLeft","JawRight",
									"Corrugator","LeftBrowLowerer","LeftOuterBrowRaiser","LeftNoseWrinkler","LeftInnerBrowRaiser","RightBrowLowerer",
									"RightOuterBrowRaiser","RightInnerBrowRaiser","RightNoseWrinkler","EyesLookDown","EyesLookLeft","EyesLookUp",
									"EyesLookRight","LeftCheekRaiser","LeftEyeUpperLidRaiser","LeftEyeClosed","RightCheekRaiser","RightEyeUpperLidRaiser",
									"RightEyeClosed","TongueDown","TongueOut","TongueUp"};

for ($i=0;$i<size($rbShapes);$i++)
	{
	addAttr -k 1 -ln $rbShapes[$i] -at double -smn 0 -hsn 1 -smx 10 -hsx 1 ctrlRobloxHead_M;
	asEnsureOutputBlendWeighted ("ctrlRobloxHead_M."+$rbShapes[$i]);
	}
select ctrlRobloxHead_M;

currentTime 0;
if ($autoKeyState) autoKeyframe -state 0;
for ($i=0;$i<size($rbShapes);$i++)
	{
	if ($rbShapes[$i]=="ChinRaiserUpperLip") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKupperLip_M.ty 10 0.5;
	if ($rbShapes[$i]=="ChinRaiser") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKlowerLip_M.ty 10 0.5;
	if ($rbShapes[$i]=="JawDrop") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.ty 10 -1;
	if ($rbShapes[$i]=="JawLeft") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.jawSide 10 10;
	if ($rbShapes[$i]=="JawRight") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.jawSide 10 -10;
	if ($rbShapes[$i]=="Corrugator")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlBrow_R.squeeze 10 10;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlBrow_L.squeeze 10 10;
		}
	if ($rbShapes[$i]=="FlatPucker")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.upperPucker 10 5;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.lowerPucker 10 5;
		}
	if ($rbShapes[$i]=="Funneler")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i])  ctrlMouth_M.upperPucker 10 10;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i])  ctrlMouth_M.lowerPucker 10 10;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i])  SDKupperLip_M.ty 10 0.3;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i])  SDKlowerLip_M.ty 10 -0.3;
		}
	if ($rbShapes[$i]=="LowerLipSuck")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.lowerPress 10 5;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.lowerRoll 10 -5;
		}
	if ($rbShapes[$i]=="LipPresser")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.upperPress 10 5;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.lowerPress 10 5;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.upperSqueeze 10 5;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.lowerSqueeze 10 5;
		}
	if ($rbShapes[$i]=="LipsTogether")//mixed with the opposite amount of JawOpen gives stickylips 
		{
		setAttr ctrlMouth_M.ty 0;
		$posA=`xform -q -ws -t lowerLip_M`;
		setAttr ctrlMouth_M.ty -1;
		$posB=`xform -q -ws -t lowerLip_M`;
		xform -ws -t $posB[0] ($posB[1]+($posA[1]-$posB[1])) $posB[2] lowerLip_M;
		$posA=`getAttr lowerLip_M.t`;
		setAttr ctrlMouth_M.ty 0;
		setAttr lowerLip_M.t -type float3 0 0 0;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKlowerLip_M.ty 10 ($posA[1]/2.0);
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKupperLip_M.ty 10 ($posA[1]/-2.0);
		}
	if ($rbShapes[$i]=="MouthLeft") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlLips_M.tx 10 1;
	if ($rbShapes[$i]=="MouthRight") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlLips_M.tx 10 -1;
	if ($rbShapes[$i]=="Pucker")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.upperPucker 10 10;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.lowerPucker 10 10;
		}
	if ($rbShapes[$i]=="UpperLipSuck") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlMouth_M.upperSqueeze 10 10;
	if ($rbShapes[$i]=="EyesLookDown")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_R.ty 10 -1;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_L.ty 10 -1;
		}
	if ($rbShapes[$i]=="EyesLookLeft")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_R.tx 10 1;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_L.tx 10 1;
		}
	if ($rbShapes[$i]=="EyesLookUp")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_R.ty 10 1;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_L.ty 10 1;
		}
	if ($rbShapes[$i]=="EyesLookRight")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_R.tx 10 -1;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ctrlEye_L.tx 10 -1;
		}
	if ($rbShapes[$i]=="TongueDown") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKTongue0_M.rz 10 -30;
	if ($rbShapes[$i]=="TongueOut")
		{
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKTongue0_M.tx 10 1.5;
		asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKTongue0_M.rz 10 15;
		}
	if ($rbShapes[$i]=="TongueUp") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) SDKTongue0_M.rz 10 30;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1)  {$side="_R";$leftRight="Right";$oppositeSide="_L";}
		if ($b==-1) {$side="_L";$leftRight="Left";$oppositeSide="_R";}

		if ($rbShapes[$i]==$leftRight+"CheekPuff") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlCheek"+$side+".tx") 10 0.4;
		if ($rbShapes[$i]==$leftRight+"Dimpler") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlMouthCorner"+$side+".tx") 10 0.3;

		if ($rbShapes[$i]==$leftRight+"LipCornerDown")
			{
			asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlMouthCorner"+$side+".tx") 10  0.5;
			asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlMouthCorner"+$side+".ty") 10 -0.5;
			}
		if ($rbShapes[$i]==$leftRight+"LowerLipDepressor") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("SDKlowerLipA"+$side+".ty") 10 -0.75;
		if ($rbShapes[$i]==$leftRight+"LipCornerPuller")
			{
			asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlMouthCorner"+$side+".tx") 10 0.75;
			asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlMouthCorner"+$side+".ty") 10 0.75;
			}
		if ($rbShapes[$i]==$leftRight+"LipStretcher") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlMouthCorner"+$side+".tx") 10 0.75;
		if ($rbShapes[$i]==$leftRight+"UpperLipRaiser") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("SDKupperLipA"+$side+".ty") 10 0.75;
		if ($rbShapes[$i]==$leftRight+"EyeClosed") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlEye"+$side+".blink") 10 10;

		if ($rbShapes[$i]==$leftRight+"BrowLowerer") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlBrow"+$side+".tx") 10 -1;
		if ($rbShapes[$i]==$leftRight+"OuterBrowRaiser") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlBrow"+$side+".outerUpDown") 10 10;
		if ($rbShapes[$i]==$leftRight+"NoseWrinkler")
			{
			asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlBrow"+$side+".outerUpDown") 10 -5;
			asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlNose"+$side+".ty") 10 1;
			}
		if ($rbShapes[$i]==$leftRight+"InnerBrowRaiser") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlBrow"+$side+".tx") 10 1;
		if ($rbShapes[$i]==$leftRight+"CheekRaiser") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("CheekRaiser"+$side+".ty") 10 0.75;
		if ($rbShapes[$i]==$leftRight+"EyeUpperLidRaiser") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("SDKupperLid"+$side+".ty") 10 0.5;
		if ($rbShapes[$i]==$leftRight+"EyeClosed") asDsSdk ("ctrlRobloxHead_M."+$rbShapes[$i]) ("ctrlEye"+$side+".blink") 10 10;
		}
	}
if ($autoKeyState) autoKeyframe -state 1;
select ctrlRobloxHead_M;
}

global proc asFaceRebuildRestore ()
{
int $numKeys,$customizedDrivingSystemCurve,$haveSkinCluster,$spans,$degree,$numCVs,$numSdkAnimCurves;
int $keepAll=`checkBox -q -v asFaceKeepAllCheckBox`;
int $keepSkinWeights=`checkBox -q -v asFaceKeepSkinWeightsCheckBox`;
int $keepHeadSquash=`checkBox -q -v asFaceKeepHeadSquashCheckBox`;
int $keepBlendShapes=`checkBox -q -v asFaceKeepBlendShapesCheckBox`;
int $keepCorrectiveShapes=`checkBox -q -v asFaceKeepCorrectiveShapesCheckBox`;
int $keepDrivingSystems=`checkBox -q -v asFaceKeepDrivingSystemsCheckBox`;
int $keepCurveShapes=`checkBox -q -v asFaceKeepCurveShapesCheckBox`;
float $fc[],$vc[],$pFc[],$pVc[],$range[],$softRange[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $newAnimCurve,$blendWeighted,$deltaMush,$curveShape,$prefixCurveShape,$nonPrefixDriverPlug,$driverObj,$driverAttr;
string $animCurve,$prefixAnimCurve,$inBw,$outBw;
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$softMinMax,$enumName,$nonPrefixed,$tweakedAttrName;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[],$historyNodes[],$allFaceGeo[],$animCurves[],$cmds[],$asFaceBSs[];
string $drivers[],$sdks[],$driverPlugs[],$targets[],$prefixTargets[],$userAttrs[],$allSetMembers[],$addAttrCmds[];
string $controls[]=`sets -q FaceControlSet`;
string $correctiveShapeNodes[]=`ls -r 1 -type blendShape "*Corrective*"`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//Restore procedures done after FaceBuild
if (!`objExists prefix_FaceGroup`)
	return;

//restore udAttrs
$allSetMembers=`sets -q prefix_FaceControlSet`;
for ($i=0;$i<size($allSetMembers);$i++)
	{
	$nonPrefixed=`substitute "prefix_" $allSetMembers[$i] ""`;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"` || $at=="message")
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$softMinMax="";
		if (`attributeQuery -softRangeExists -n $allSetMembers[$i] $ln`)
			{
			$softRange=`attributeQuery -n $allSetMembers[$i] -softRange $ln`;
			$softMinMax="-smn "+$softRange[0]+" -hsn 1 -smx "+$softRange[1]+" -hsx 1";
			}
		$enumName="";
		if ($at=="enum")
			$enumName="-en \""+`addAttr -q -en ($allSetMembers[$i]+"."+$userAttrs[$y])`+"\"";
		if (!`attributeExists $userAttrs[$y] $nonPrefixed`)
			{
			eval ("addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$softMinMax+" "+$enumName+" "+$nonPrefixed);
			$tweakedAttrName=$nonPrefixed+"_"+$sn+"_tweaked";
			if (!`objExists prefix_FaceSetupEditHistory`)
				createNode -n prefix_FaceSetupEditHistory -p prefix_ControlsSetup transform;
			if (!`attributeExists $tweakedAttrName prefix_FaceSetupEditHistory`)
				addAttr -k 0 -dv 1 -ln $tweakedAttrName -at bool prefix_FaceSetupEditHistory;
			}
		}
	}

if (`objExists prefix_FaceSetupEditHistory`)
	{
	parent prefix_FaceSetupEditHistory ControlsSetup;
	rename prefix_FaceSetupEditHistory FaceSetupEditHistory;
	sets -rm prefix_FaceAllSet FaceSetupEditHistory;
	sets -add FaceAllSet FaceSetupEditHistory;
	}

//transfer weights from previous face-build
if ($keepSkinWeights && `objExists prefix_asFaceSkinWeightsHolder`)
	{
	print ("// Restoring SkinWeights.\n");
	select prefix_asFaceSkinWeightsHolder $geometry;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

//keepDrivingSystems
if ($keepAll || $keepDrivingSystems)
	{
	//changing in v 5.8871 from old detect-by-compare-animCurve, to saving info upen Edit
	//This should avoid the undesired `restores` when ReBuilding with version that has a feature change
	clear $tempString;
	if (`objExists FaceSetupEditHistory`)
		$tempString=`listAttr -ud -string "*_tweaked" FaceSetupEditHistory`;
	for ($i=0;$i<size($tempString);$i++)
		{
		print ("// Restoring edited DrivingSystem:"+$tempString[$i]+", (");
		tokenize $tempString[$i] "_" $tempString2;
		$driverObj=$tempString2[0]+"_"+$tempString2[1];
		$driverAttr=$tempString2[2];
		clear $tempString2;
		if (`attributeExists $driverAttr ("prefix_"+$driverObj)`)
			$tempString2=`listConnections -s 0 -d 1 -type blendWeighted ("prefix_"+$driverObj+"."+$driverAttr)`;
		$numSdkAnimCurves=0;
		for ($y=0;$y<size($tempString2);$y++)
			{
			$inBw=`substitute "prefix_" $tempString2[$y] ""`;
			if (!`objExists $inBw`)
				asEnsureOutputBlendWeighted ($driverObj+"."+$driverAttr);
			$tempString3=`listConnections -s 0 -d 1 -type animCurve $tempString2[$y]`;
			for ($z=0;$z<size($tempString3);$z++)
				{
				if (!`gmatch $tempString3[$z] "prefix_*"`)//was added and therefore not in FaceAllSet
					$tempString3[$z]=`rename $tempString3[$z] ("prefix_"+$tempString3[$z])`;
				$prefixAnimCurve=$tempString3[$z];
				$animCurve=`substitute "prefix_" $prefixAnimCurve ""`;
				tokenize $animCurve "_" $tempString5;
				$tempString4=`listConnections -s 0 -d 1 -type blendWeighted ($prefixAnimCurve+".output")`;
				$outBw=`substitute "prefix_" $tempString4[0] ""`;
				if (`objExists $animCurve`)
					nodeCast -swapNames 1 $prefixAnimCurve $animCurve;
				else
					{
					//Make new animCurve
					duplicate -n $animCurve $prefixAnimCurve;
					sets -rm prefix_FaceAllSet $animCurve;
					connectAttr ($inBw+".output") ($animCurve+".input");
					if (!`objExists $outBw`)
						{
						$attr=$tempString5[2];
						while (`gmatch $attr "*[0-9]"`)
							{//strip numbers of the end
							$numChar=size($attr);
							$attr=`substring $attr 1 ($numChar-1)`;
							}
						asEnsureBlendWeighted (`substitute "bw" $tempString5[0] ""`+"_"+$tempString5[1]+"."+$attr);
						}
					$tempString5=`listConnections -s 0 -d 1 -scn 1 ($prefixAnimCurve+".output")`;
					$tempString5[0]=`substitute "prefix_" $tempString5[0] ""`;
					$tempString5[1]=$tempString5[0]+".input["+`getAttr -s ($tempString5[0]+".input")`+"]";
//print ("connectAttr "+$animCurve+".output  "+$tempString5[1]+"\n");
					connectAttr -f ($animCurve+".output") $tempString5[1];
					}
				$numSdkAnimCurves++;
				}
			}
		print ($numSdkAnimCurves+" sdk-animCurves.)\n");
		}
	}

if (($keepAll || $keepHeadSquash) && `objExists prefix_SquashSetup`)
	{
	print ("// Restoring HeadSquash.\n");
	asAdvancedSquash;
	if (`attributeExists optimizedSquash prefix_SquashSetup`)
		{
		print ("// Restoring Optimize HeadSquash.\n");
		asOptimizeSquash;
		}
	}

//BlendShapes
if (($keepAll || $keepBlendShapes) && `objExists asFaceBS`)
	{
	print ("// Restoring BlendShapes.\n");
//	asBSExtractAll
	$asFaceBSs=`ls -type blendShape "asFaceBS*"`;
	for ($i=0;$i<size($asFaceBSs);$i++)
		{
		if (!`objExists ("prefix_"+$asFaceBSs[$i])`)
			continue;
		$targets=`listAttr -m ($asFaceBSs[$i]+".weight")`;
		$prefixTargets=`listAttr -m ("prefix_"+$asFaceBSs[$i]+".weight")`;
		for ($y=0;$y<size($targets);$y++)
			{
			if (!`stringArrayCount $targets[$y] $prefixTargets`)
				continue;
			//to be connected..
			}
		}
	}

//Corrective BlendShapes
if (($keepAll || $keepCorrectiveShapes) && size($correctiveShapeNodes))
	{
	print ("// Restoring Corrective Shapes.\n");
	for ($i=0;$i<size($correctiveShapeNodes);$i++)
		{
		//reconnect Corrective to asFaceBS
		if (`objExists asFaceBS` && `objExists FaceCorrective`)
			{
			$tempString=`listAttr -m asFaceBS.w`;
			blendShape -e -t $geometry `size($tempString)` FaceCorrective 1 asFaceBS;
			setAttr asFaceBS.FaceCorrective 1;
			}
		//change SDK`s to be driven by the non-prefix-ctrls
		$sdks=`listConnections -s 1 -d 0 -type animCurve $correctiveShapeNodes[$i]`;
		for ($z=0;$z<size($sdks);$z++)
			{
			$drivers=`listConnections -s 1 -d 0 -c 1 -type transform $sdks[$z]`;
			$driverPlugs=`listConnections -s 1 -d 0 -c 1 -p 1 -type transform $sdks[$z]`;
			for ($y=0;$y<size($drivers);$y=$y+2)
				if (`gmatch $drivers[$y+1] "prefix_*"`)
					if (`objExists $drivers[$y+1]`)
						{
						$nonPrefixDriverPlug=`substitute "prefix_" $driverPlugs[$y+1] ""`;
						if (!`objExists $nonPrefixDriverPlug`)
							continue;
						connectAttr -f $nonPrefixDriverPlug $drivers[$y];
						}
			}
		}
	}

//keepCurveShapes
if ($keepAll || $keepCurveShapes)
	{
	print ("// Restoring control shapes and colors.\n");
	for ($i=0;$i<size($controls);$i++)
		{
		if (!`objExists $controls[$i]`)
			continue;
		$tempString=`listRelatives -s $controls[$i]`;
		for ($z=0;$z<size($tempString);$z++)
			{
			$curveShape=$tempString[$z];
			$prefixCurveShape="prefix_"+$tempString[$z];
			if (!`objExists $curveShape` || !`objExists $prefixCurveShape`)
				continue;
			if (`objectType $curveShape`!="nurbsCurve" || `objectType $prefixCurveShape`!="nurbsCurve")
				continue;

			if (`getAttr prefix_FaceGroup.version`<5.764 && `gmatch $curveShape "Iris_*Shape"`)//versions prior to 5.764 had different Iris orientation
				continue;
			if (`getAttr prefix_FaceGroup.version`<5.764 && `gmatch $curveShape "Pupil_*Shape"`)//versions prior to 5.764 had different Pupil orientation
				continue;

			$spans=`getAttr ($prefixCurveShape+".spans")`;
			$degree=`getAttr ($prefixCurveShape+".degree")`;
			$numCVs=$spans+$degree;
			for ($y=0;$y<$numCVs;$y++)
				{
				$cvPos=`getAttr ($prefixCurveShape+".controlPoints["+$y+"]")`;
				$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
				}
			//color
			$cmds[size($cmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($prefixCurveShape+".overrideColor")`+";";
			}
		}
	for ($cmd in $cmds)
		if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

//Below 2 lines swapped cause Error :prefix_lowerOS2WSTG_L (Transform Geometry): Do not know how to handle given geometry data
if (`objExists prefix_FaceAllSet`) delete `sets -q prefix_FaceAllSet`;
if (`objExists prefix_FaceGroup`) delete prefix_FaceGroup;

print ("// Advanced Face Rebuild complete.\n");
asUpdateButtonEnables;
}

global proc asFaceResetBuildStep ()
{
int $buildStep,$newBuildStep;
if (!`objExists FaceFitSkeleton`)
	return;
$buildStep=`getAttr FaceFitSkeleton.buildStep`;
if ($buildStep==0)
	{
	for ($i=0;$i<99;$i++)
		if (!`columnLayout -q -ex ("asStepBuildColumnLayout"+$i)`)
			break;
	$newBuildStep=$i-2;
	}
setAttr FaceFitSkeleton.buildStep $newBuildStep;
asFaceUpdateInfo 1;
}

global proc int asGetLipCtrls ()
{
int $lipCtrls=12;
if (`attributeExists LipCtrls FaceFitSkeleton`)
	$lipCtrls=`getAttr -asString FaceFitSkeleton.LipCtrls`;
return $lipCtrls;
}

global proc int asFaceGetMaxInfluences ()
{
int $maxInfluences;
if (`attributeExists GameEngine FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.GameEngine`)
		if (`attributeExists UseMaxInf FaceFitSkeleton`)
			if (`getAttr FaceFitSkeleton.UseMaxInf`)
				$maxInfluences=`getAttr -asString FaceFitSkeleton.MaxInf`;

return $maxInfluences;
}

global proc int asFaceIncludeAboveEyes ()
{
int $include=1;
if (`attributeExists Include FaceFitSkeleton`)
	{
	$includeAsString=`getAttr -asString FaceFitSkeleton.Include`;
	if ($includeAsString=="Skip Above Eyes") $include=0;
	if ($includeAsString=="Skip Below Eyes") $include=1;
	if ($includeAsString=="Skip Above+Below Eyes") $include=0;
	}
return $include;
}

global proc int asFaceIncludeBelowEyes ()
{
int $include=1;
if (`attributeExists Include FaceFitSkeleton`)
	{
	$includeAsString=`getAttr -asString FaceFitSkeleton.Include`;
	if ($includeAsString=="Skip Above Eyes") $include=1;
	if ($includeAsString=="Skip Below Eyes") $include=0;
	if ($includeAsString=="Skip Above+Below Eyes") $include=0;
	}
return $include;
}

global proc string asFaceMultiSkinClusterAdd (string $name)
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $jointName="MultiSkinClustersFace"+$name+"Joint_M";
string $sc=$name+"SC";
string $tempString[];

createNode -n $jointName -p FaceJoint_M joint;
setAttr ($jointName+".drawStyle") 2;
setAttr -l 1 ($jointName+".inheritsTransform") 0;
select $jointName $geometry;
//$tempString=`skinCluster -multi 1`;
$tempString=`skinCluster -multi 1 -frontOfChain -toSelectedBones`;
rename $tempString[0] $sc;

//reorderDeformers $skinCluster $sc $geometry;

return $sc;
}

global proc asOPMScaleReset (string $joint)
{
int $opm=`asGetOpm`;
float $m[],$m2[];
float $scale;
string $mm,$side;
string $tempString[];

if (!$opm)
	return;

tokenize $joint "_" $tempString;
$side="_"+$tempString[1];

$m=`getAttr ($joint+".offsetParentMatrix")`;
$m2=`getAttr ("SideReverse"+$side+".worldInverseMatrix")`;
$scale=$m[10];
if ($scale<1.001 && $scale>0.999)
	return;

$tempString=`listConnections -s 1 -d 0 -type multMatrix ($joint+".offsetParentMatrix")`;
$mm=$tempString[0];
if ($mm=="")
	{
	warning ("Failed to asOPMScaleReset \""+$joint+"\" as it is not connected to multMatrix.\n");
	return;
	}

createNode -n tempMatrixTransform transform;
$m=`xform -q -os -m tempMatrixTransform`;
delete tempMatrixTransform;

$tempString=`listConnections -s 1 -d 0 ($mm+".matrixIn[0]")`;
if ($tempString[0]=="")
	$m=`getAttr ($mm+".matrixIn[0]")`;
else
	asInsertMMPlug "" $mm 0;
$m={$m2[0],$m[1],$m[2],$m[3],$m[4],$m2[5],$m[6],$m[7],$m[8],$m[9],$m2[10],$m[11],$m[12],$m[13],$m[14],$m[15]};
setAttr ($mm+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
}

global proc string asGetLastLipLetter ()
{
int $lipCtrls=`asGetLipCtrls`;
string $lastLipLetter=`asNrToLetter ($lipCtrls/4)`;
return $lastLipLetter;
}

global proc asSelectVtxsFromFit (string $fit, string $geometry)
{
float $pos[];
string $tempString[];

select -cl;
if (`objExists closestSamplerVtxsFromFit`)
	delete closestSamplerVtxsFromFit;
createNode -n closestSamplerVtxsFromFit closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerVtxsFromFit.inMesh;
connectAttr -f ($geometry+".worldMatrix[0]") closestSamplerVtxsFromFit.inputMatrix;

$tempString=`listRelatives -s -type nurbsCurve $fit`;
if ($tempString[0]=="")
	{
	$pos=`xform -q -ws -t  $fit`;
	setAttr -type float3 closestSamplerVtxsFromFit.inPosition $pos[0] $pos[1] $pos[2];
	select -add ($geometry+".vtx["+`getAttr closestSamplerVtxsFromFit.result.closestVertexIndex`+"]");
	}
else
	{
	//select geoVtx along curve
	for ($i=0;$i<`getAttr ($fit+".spans")`+1;$i++)
		{
		$pos=`xform -q -ws -t ($fit+".cv["+$i+"]")`;
		setAttr -type float3 closestSamplerVtxsFromFit.inPosition $pos[0] $pos[1] $pos[2];
		select -add ($geometry+".vtx["+`getAttr closestSamplerVtxsFromFit.result.closestVertexIndex`+"]");
		}
	}

delete closestSamplerVtxsFromFit;
}

global proc asFaceMirrorConnectCtrls (int $connect)
{
string $ctrl,$leftCtr;
string $tempString[],$attrs[];

$tempString=`listRelatives -ad -type transform OnFacecontrols`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Offset_[R]"`)
		{
		$ctrl=`substitute "Offset" $tempString[$i]""`;
		$leftCtr=`substitute "_R" $ctrl "_L"`;
		$attrs=`listAttr -k $ctrl`;
		for ($y=0;$y<size($attrs);$y++)
			{
			if (!`attributeExists $attrs[$y] $leftCtr`)
				continue;
			if ($connect)
				connectAttr ($ctrl+"."+$attrs[$y]) ($leftCtr+"."+$attrs[$y]);
			else if (`isConnected ($ctrl+"."+$attrs[$y]) ($leftCtr+"."+$attrs[$y])`)
				disconnectAttr ($ctrl+"."+$attrs[$y]) ($leftCtr+"."+$attrs[$y]);
			}
		}
}

global proc asFaceRemoveFitAnimFromCtrlBox ()
{
string $tempString[],$tempString2[],$attrs[];
string $ctrl;

$tempString=`listRelatives -ad -type transform ctrlBox`;
for ($i=0;$i<size($tempString);$i++)
	{
	$ctrl=$tempString[$i];
	if (`gmatch $ctrl "ctrlBox*"`)
		continue;
	$tempString2=`listConnections -s 1 -d 0 -type animCurve $ctrl`;
	for ($y=0;$y<size($tempString2);$y++)
		delete $tempString2[$y];
	$attrs=`listAttr -k $ctrl`;
	for ($y=0;$y<size($attrs);$y++)
		if (!`getAttr -l ($ctrl+"."+$attrs[$y])`)
			setAttr ($ctrl+"."+$attrs[$y]) 0;
	}
}

global proc asFaceRemoveFitAnimationsFromOnFaceCtrls ()
{
string $ctrl;
string $tempString[],$tempString2[];

$tempString=`listRelatives -ad -type transform OnFacecontrols`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Offset_*"`)
		{
		$ctrl=`substitute "Offset" $tempString[$i]""`;
		$tempString2=`listConnections -s 1 -d 0 -type animCurve $ctrl`;
		if (size($tempString2))
			delete $tempString2;
		xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $ctrl;
		}

//Also remove the "Values Transforms"
$tempString=`listRelatives -ad -type transform OnFacecontrols`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Values_[A-Z]"`)
		delete $tempString[$i];
}

global proc asFaceFitAnim (string $objAttr, float $value)
{
float $defaultValue=0;
string $obj;
string $tempString[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

if (`gmatch $objAttr "*.*"`)
	{
	tokenize $objAttr "." $tempString;
	$obj=$tempString[0];
	}
else
	$obj=$objAttr;

//make sure controller is visible
select $obj;
showHidden -a;

if (`gmatch $objAttr "*.s[a-z]"`)
	$defaultValue=1;

if (!`objExists $objAttr`)
	return;

if (`gmatch $objAttr "*.*"`)
	{
	setKeyframe -shape 0 -t  0 -v $defaultValue $objAttr;
	setKeyframe -shape 0 -t 30 -v $value 				$objAttr;
	}
else
	{
	for ($y=0;$y<size($trs);$y++)
		{
		if ($trs[$y]=="s") $defaultValue=1;
		else $defaultValue=0;
		for ($z=0;$z<size($xyz);$z++)
			{
			setKeyframe -shape 0 -t  0 -v $defaultValue ($obj+"."+$trs[$y]+$xyz[$z]);
			setKeyframe -shape 0 -t 30 -v $defaultValue ($obj+"."+$trs[$y]+$xyz[$z]);
			}
		}
	}
}

global proc asFaceDsFinish (string $driveObj, string $driveSide, string $driveAttr, float $driveValue)
{
int $numLetters;
string $ctrl;
string $drivenCtrlsSide[],$drivenCtrlsMiddle[],$tempString[];

$tempString=`listRelatives -ad -type nurbsCurve OnFacecontrols`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	$ctrl=$tempString2[0];
	$tempString2=`listConnections -s 1 -d 0 -type animCurve $ctrl`;
	if (!size($tempString2))
		continue;
	$numLetters=size($ctrl);
	if (`gmatch $ctrl "*_L"`)
		continue;
	if (`gmatch $ctrl "*_R"`)
		$drivenCtrlsSide[size($drivenCtrlsSide)]=`substring $ctrl 1 ($numLetters-2)`;
	else
		$drivenCtrlsMiddle[size($drivenCtrlsMiddle)]=`substring $ctrl 1 ($numLetters-2)`;
	}

if (size($drivenCtrlsSide))
	asFaceStoreAsDsSdk $drivenCtrlsSide "_RL" $driveObj $driveSide $driveAttr $driveValue;
if (size($drivenCtrlsMiddle))
	asFaceStoreAsDsSdk $drivenCtrlsMiddle "_M" $driveObj $driveSide $driveAttr $driveValue;

asFaceRemoveFitAnimationsFromOnFaceCtrls;
}

global proc asFaceStoreAsDsSdk (string $ctrls[], string $ctrlsSide, string $driveObj, string $driveSide, string $driveAttr, float $driveValue)
{
int $autoKeyState=`autoKeyframe -q -state`;
int $skipCtrl[],$attrHaveFitAnim[];
float $inLoopDriveValue;
float $drivenValues[];
string $valuObj,$ctrl,$side,$driveObjSide;
string $tempString[],$attrs[];

if ($autoKeyState) autoKeyframe -state 0;
for ($i=0;$i<size($ctrls);$i++)
	{
	currentTime 30;
	$skip=0;
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		if ($ctrlsSide=="_M") $side="_M";
		if ($ctrlsSide=="_M" && $driveSide=="_M" && $b==-1) continue;
		if ($side=="_M") $valuObj=$ctrls[$i]+"Values"+$side;
		else $valuObj=$ctrls[$i]+"Values_R";
		$ctrl=$ctrls[$i]+$side;
		if (!`objExists $ctrl`)
			{
			print ("// control:\""+$ctrl+"\" not found. skipping.\n");
			$skipCtrl[$i]=1;
			}

		if (!`objExists $valuObj` && !$skipCtrl[$i])
			{
			createNode -n $valuObj -p $ctrl transform;
			parent $valuObj `listRelatives -p $ctrl`;
			}
		}

	currentTime 0;
	if ($skipCtrl[$i])
		continue;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
//		if ($ctrlsSide=="_M") $side="_M";
		if ($ctrlsSide=="_M" && $driveSide=="_M" && $b==-1) continue;
		if ($ctrlsSide=="_M")
			{
			$ctrl=$ctrls[$i]+"_M";
			$valuObj=$ctrls[$i]+"Values"+"_M";
			}
		else
			{
			$ctrl=$ctrls[$i]+$side;
			$valuObj=$ctrls[$i]+"Values_R";
			}
		delete -staticChannels $ctrl;
		if ($driveSide=="_RL")
			$driveObjSide=$driveObj+$side;
		if ($driveSide=="_M")
			$driveObjSide=$driveObj+"_M";
		$inLoopDriveValue=$driveValue;

		$attrs=`listAttr -k $ctrl`;
		for ($y=0;$y<size($attrs);$y++)
			{
			if ($b==1)
				{
				if (`attributeExists $attrs[$y] $valuObj`)
					$drivenValues[$y]=`getAttr ($valuObj+"."+$attrs[$y])`;
				else //custom attr, do not use SDK node
					$drivenValues[$y]=`getAttr -t 30 ($ctrl+"."+$attrs[$y])`;

				$tempString=`listConnections -s 1 -d 0 -type animCurve ($ctrl+"."+$attrs[$y])`;
				if (size($tempString))
					$attrHaveFitAnim[$y]=1;
				else
					$attrHaveFitAnim[$y]=0;
				}
			if (!$attrHaveFitAnim[$y])
				continue;

			if ($ctrlsSide=="_M" && $side=="_L")//side drive center e.g. ctrlMouthCorner_L drive LipRegion_M
				if ($attrs[$y]=="translateX" || $attrs[$y]=="rotateY" || $attrs[$y]=="rotateZ")
					$drivenValues[$y]*=-1;

			if ($driveObj=="ctrlLips" && $driveSide=="_M" && $driveAttr=="tx" && $side=="_L")//ctrlLips_M.tx special case
				$inLoopDriveValue=1;

			if (`gmatch $attrs[$y] "scale[X-Z]"`)
				setAttr ($ctrl+"."+$attrs[$y]) 1;
			else
				setAttr ($ctrl+"."+$attrs[$y]) 0;

			if (`gmatch $driveObj "ctrlMouth*"` && ($driveObj+"_M."+$driveAttr)!="ctrlMouth_M.ty")
				{//	ctrlMouthCorner splits into X and Y driving, for more intuitive joystick (except ctrlMouth_M.ty. mouthOpen->lipNarrow)
				if ($driveAttr=="tx" && ($attrs[$y]=="translateY" || $attrs[$y]=="rotateZ"))
					continue;
				if ($driveAttr=="ty" && !	($attrs[$y]=="translateY" || $attrs[$y]=="rotateZ"))
					continue;
				}

			if (!`attributeExists $attrs[$y] $valuObj`)//custom attr, do not use SDK node
				{
				if (`objExists ("bw"+$ctrl+"_"+$attrs[$y])`)
					asDsSdk ($driveObjSide+"."+$driveAttr) ("bw"+$ctrl+"_"+$attrs[$y]+".input") $inLoopDriveValue $drivenValues[$y];
				}
			else
				asDsSdk ($driveObjSide+"."+$driveAttr) ("SDK"+$ctrl+"."+$attrs[$y]) $inLoopDriveValue $drivenValues[$y];
			}
		}
	}
if ($autoKeyState) autoKeyframe -state 1;
}

global proc asTweakWeightHammerVerts ()
{
int $numIterations=`intField -q -v asWeightHammerVertsIterationsIntField`;
asWeightHammerVerts $numIterations;
}

global proc asWeightHammerVerts (int $numIterations)
{
//default Hammervalue of swi==5, increase in some circumstances
int $maxInfluences=`asFaceGetMaxInfluences`;
int $obeyMaxInfluences;
string $currentSelection[] = `ls -selection`;
string $buff[];
string $geomName,$sCluster;

if (!size($currentSelection))
	return;

if ($maxInfluences>0)
	$obeyMaxInfluences=1;

tokenize($currentSelection[0],".",$buff);
$geomName = $buff[0];
$sCluster = findRelatedSkinCluster( $geomName );
if ($sCluster=="")
	return;

skinCluster -e -smoothWeights 0 -smoothWeightsMaxIterations $numIterations -obeyMaxInfluences $obeyMaxInfluences $sCluster;
}

global proc asWeightHammerVertsMS (int $numIterations, string $sCluster)
{
//default Hammervalue of swi==5, increase in some circumstances
int $maxInfluences=`asFaceGetMaxInfluences`;
int $obeyMaxInfluences;
string $currentSelection[] = `ls -selection`;

if (!size($currentSelection))
	return;

if ($maxInfluences>0)
	$obeyMaxInfluences=1;


skinCluster -e -smoothWeights 0 -smoothWeightsMaxIterations $numIterations -obeyMaxInfluences $obeyMaxInfluences $sCluster;
}

global proc asFacePaintSkinWeights ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $name,$side;
string $joint=$headJoint;
string $sel[]=`ls -sl`;
string $tempString[];

select $geometry;
if (`objExists FaceJointsLayer`)
	{
	if (!`getAttr FaceJointsLayer.v`)
		{
		print ("// SkinLayers detected, now switching to FaceJoints layer. (Use the Layers section to switch back to Normal layer))\n");
		asShowLayer FaceJoints;
		}
	select FaceJointsLayer;
	}
ArtPaintSkinWeightsTool;
toolPropertyWindow;

if ($sel[0]!="")
	{
	tokenize $sel[0] "_" $tempString;
	$name=$tempString[0];
	$side="_"+$tempString[1];
	if (`objExists ($name+"Joint"+$side)`)
		$joint=$name+"Joint"+$side;
	}

artAttrSkinPaintCtx -e -influence $joint artAttrSkinContext;
artSkinInflListChanging $joint 1;
artSkinInflListChanged artAttrSkinPaintCtx;
toolPropertyWindow;
}

global proc asFaceLockWeights (int $lock)
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $topJoint=$headJoint;
string $tempString[];

//if AdvSkel body rig, include body joints
if (`objExists Root_M`)
	$topJoint="Root_M";

//$tempString=`listRelatives -type joint -ad $topJoint`;
//$tempString[size($tempString)]=$topJoint;
//changed to ALL joints, since a FaceRig can be applied to a non-advBody rig, so skinCluster has `unknown` infls
$tempString=`ls -type joint`;
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists lockInfluenceWeights $tempString[$i]`)
		setAttr ($tempString[$i]+".lockInfluenceWeights") $lock;
}

global proc asAddCtrlBox2Shape (string $ctrl)
{
int $numCv;
int $opm=`asGetOpm`;
float $pos[];
string $tempString[];

tokenize $ctrl "_" $tempString;
$ctrl1=$tempString[0]+"1_"+$tempString[1];

duplicate -n ($ctrl1+"2") $ctrl1;
parent -add -s ($ctrl1+"2Shape") $ctrl;
delete ($ctrl1+"2");
$numCv=`asGetCurveNumCvs $ctrl1`;
for ($y=0;$y<$numCv;$y++)
	{
	$pos=`xform -q -ws -t ($ctrl1+"Shape.cv["+$y+"]")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($ctrl1+"2Shape.cv["+$y+"]");
	}
rename ($ctrl1+"2Shape") ($ctrl1+"Shape");
delete $ctrl1;
setAttr ($ctrl1+"Shape.overrideEnabled") 1;
setAttr ($ctrl1+"Shape.overrideColor") `getAttr ($ctrl+"Shape.overrideColor")`;

duplicate -n ($ctrl+"2") $ctrl;
parent -add -s ($ctrl+"2|"+$ctrl1+"Shape") $ctrl;
delete ($ctrl+"2");
rename ($ctrl1+"Shape1") ($ctrl1+"OrigShape");
setAttr ($ctrl1+"OrigShape.intermediateObject") 1;

createNode -n ($ctrl+"TG") transformGeometry;
connectAttr -f ($ctrl1+"OrigShape.worldSpace[0]") ($ctrl+"TG.inputGeometry");
connectAttr -f ($ctrl+"TG.outputGeometry") ($ctrl1+"Shape.create");

createNode -n ($ctrl+"TGXformOffset") -p $ctrl transform;
parent ($ctrl+"TGXformOffset") ctrlBox2Constrained;
createNode -n ($ctrl+"TGXform") -p ($ctrl+"TGXformOffset") transform;
asParentConstraint $ctrl ($ctrl+"TGXform") ""; 
//parentConstraint $ctrl ($ctrl+"TGXform");
//scaleConstraint $ctrl ($ctrl+"TGXform");
if ($opm)
	connectAttr -f ($ctrl+"TGXform.offsetParentMatrix") ($ctrl+"TG.transform");
else
	connectAttr -f ($ctrl+"TGXform.matrix") ($ctrl+"TG.transform");
setAttr ($ctrl+"TG.invertTransform") 1;
}

global proc asFaceHideControllers (int $hide)
{
string $tempString[];

$tempString=`listRelatives -ad -type transform ControlsSetup`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Offset_[A-Z]"`)
		setAttr ($tempString[$i]+".v") (!$hide);

$tempString=`listRelatives -c -type transform ctrlBox ctrlBox2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") (!$hide);
}

global proc asAddLeastEdgesPathToSet (string $geometry, string $startPosObj, string $endPosObj)
{
int $startVtxNr,$endVtxNr;
float $pos[];
string $tempString[],$edgesToRemove[];
string $sel[]=`ls -sl`;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;

$pos=`xform -q -ws -t $startPosObj`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$startVtxNr=`getAttr closestSampler.result.closestVertexIndex`;

$pos=`xform -q -ws -t $endPosObj`;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$endVtxNr=`getAttr closestSampler.result.closestVertexIndex`;

asSelectLeastEdgesPath $geometry $startVtxNr $endVtxNr;
$tempString=`ls -sl -fl`;

//remove edges that are `double up`, to avoid `outsticking lines`
if (!`objExists leastEdgesPathSet`)
	sets -em -n leastEdgesPathSet;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im leastEdgesPathSet $tempString[$i]`)
		$edgesToRemove[size($edgesToRemove)]=$tempString[$i];
for ($i=0;$i<size($edgesToRemove);$i++)
	{
	//remove from set and from $tempString[]
	sets -rm leastEdgesPathSet $edgesToRemove[$i];
	$tempString=`stringArrayRemove {$edgesToRemove[$i]} $tempString`;
	}

sets -add leastEdgesPathSet $tempString;
select $sel;
}

global proc asFaceHalfMoonCurve (string $ctrl, float $rotation)
{
int $cv1Nr=7;
int $cv2Nr=3;
float $factor=8;
float $posA[],$posB[];	

for ($i=0;$i<3;$i++)
	{
	if ($i==1) {$cv1Nr=0;$cv2Nr=2;}
	if ($i==2) {$cv1Nr=6;$cv2Nr=4;}
	if ($i>0) $factor=4;

	$posA=`xform -q -ws -t ($ctrl+".cv["+$cv1Nr+"]")`;
	$posB=`xform -q -ws -t ($ctrl+".cv["+$cv2Nr+"]")`;
	xform -ws -t ((($posA[0]*$factor)+($posB[0]*1))/($factor+1)) ((($posA[1]*3)+($posB[1]*1))/4.0) ((($posA[2]*3)+($posB[2]*1))/4.0) ($ctrl+".cv["+$cv2Nr+"]");
	}

$posA=`xform -q -ws -t ($ctrl+".cv[1]")`;
$posB=`xform -q -ws -t ($ctrl+".cv[3]")`;
xform -ws -t ((($posA[0]*$factor)+($posB[0]*1))/($factor+1)) $posA[1] $posA[2] ($ctrl+".cv[1]");

$posA=`xform -q -ws -t ($ctrl+".cv[5]")`;
$posB=`xform -q -ws -t ($ctrl+".cv[3]")`;
xform -ws -t ((($posA[0]*$factor)+($posB[0]*1))/($factor+1)) $posA[1] $posA[2] ($ctrl+".cv[5]");

$posA=`xform -q -ws -t $ctrl`;

scale -r -p $posA[0] $posA[1] $posA[2] 0.8 1.0 1.0 ($ctrl+".cv[0:99]");
if (`gmatch $ctrl "*LidOuter*"`)
	scale -r -p $posA[0] $posA[1] $posA[2] 0.75 1.5 1 ($ctrl+".cv[0:99]");

rotate -r -p $posA[0] $posA[1] $posA[2] -os 0 0 $rotation ($ctrl+".cv[0:99]");

}

global proc asFaceAddConstrained (string $target, string $sourceA, string $sourceB, float $value)
{
int $opm=`asGetOpm`;
int $plugNr;
float $m[];
string $targetName,$targetSide,$sourceAName,$sourceASide,$sourceBName,$sourceBSide,$source;
string $xformA=$sourceA;
string $xformB=$sourceB;
string $AB[]={"A","B"};
string $xyz[]={"x","y","z"};
string $tempString[];

tokenize $target "_" $tempString;$targetName=$tempString[0];$targetSide="_"+$tempString[1];
tokenize $sourceA "_" $tempString;$sourceAName=$tempString[0];$sourceASide="_"+$tempString[1];
tokenize $sourceB "_" $tempString;$sourceBName=$tempString[0];$sourceBSide="_"+$tempString[1];

addAttr -k 1 -ln ("follow"+$sourceA) -at double -min 0 -max 10 -dv $value ($targetName+$targetSide);
asUnitConvertAndReverse ($targetName+$targetSide+"Blend"+$sourceA) ($targetName+$targetSide+".follow"+$sourceA);
//bw override , to allow other drivers to drive this same attr
asEnsureOutputBlendWeighted ($targetName+$targetSide+"."+"follow"+$sourceA);
connectAttr -f ("bw"+$targetName+$targetSide+"_"+"follow"+$sourceA+".output") ($targetName+$targetSide+"Blend"+$sourceA+"UnitConversion.input");
connectAttr -f ($targetName+$targetSide+"Blend"+$sourceA+"UnitConversion.output") ($targetName+$targetSide+"Blend"+$sourceA+"Reverse.inputX");

if ($opm)
	{
	createNode -n ($targetName+"Follow"+$targetSide) -p ($targetName+"Offset"+$targetSide) transform;
	parent ("SDK"+$targetName+$targetSide) ($targetName+"Follow"+$targetSide);
	createNode -n ($targetName+"BM"+$targetSide) blendMatrix;

	for ($i=0;$i<size($AB);$i++)
		{
		if ($i==0) $source=$sourceA;
		if ($i==1) $source=$sourceB;
		createNode -n ($targetName+"MM"+$AB[$i]+$targetSide) multMatrix;
		createNode -n tempMatrixTransform -p ($targetName+$targetSide) transform;
		parent tempMatrixTransform $source;
		$m=`xform -q -os -m tempMatrixTransform`;
		delete tempMatrixTransform;
		setAttr ($targetName+"MM"+$AB[$i]+$targetSide+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		connectAttr ($source+".worldMatrix") ($targetName+"MM"+$AB[$i]+$targetSide+".matrixIn[1]");
//		$m=`getAttr ($targetName+$targetSide+".worldInverseMatrix")`;
//		setAttr ($targetName+"MM"+$AB[$i]+$targetSide+".matrixIn[2]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		$tempString=`listRelatives -p ($targetName+"Follow"+$targetSide)`;
		connectAttr ($tempString[0]+".worldInverseMatrix") ($targetName+"MM"+$AB[$i]+$targetSide+".matrixIn[2]");
		}
	connectAttr ($targetName+"MMA"+$targetSide+".matrixSum") ($targetName+"BM"+$targetSide+".inputMatrix");
	connectAttr ($targetName+"MMB"+$targetSide+".matrixSum") ($targetName+"BM"+$targetSide+".target[0].targetMatrix");
	connectAttr ($targetName+$targetSide+"Blend"+$sourceA+"Reverse.outputX") ($targetName+"BM"+$targetSide+".target[0].weight");
	connectAttr ($targetName+"BM"+$targetSide+".outputMatrix") ($targetName+"Follow"+$targetSide+".offsetParentMatrix");
	return;
	}

if (!`objExists ($targetName+"Follow"+$targetSide)`)
	{
	createNode -n ($targetName+"Follow"+$targetSide) -p ($targetName+"Offset"+$targetSide) transform;
	parent ("SDK"+$targetName+$targetSide) ($targetName+"Follow"+$targetSide);
	createNode -n ($targetName+"ConstrainedPMAT"+$targetSide) plusMinusAverage;
	createNode -n ($targetName+"ConstrainedPMAR"+$targetSide) plusMinusAverage;
	createNode -n ($targetName+"ConstrainedPMAS"+$targetSide) plusMinusAverage;
	for ($z=0;$z<size($xyz);$z++)
		{
		connectAttr ($targetName+"ConstrainedPMAT"+$targetSide+".output3D"+$xyz[$z]) ($targetName+"Follow"+$targetSide+".t"+$xyz[$z]);
		connectAttr ($targetName+"ConstrainedPMAR"+$targetSide+".output3D"+$xyz[$z]) ($targetName+"Follow"+$targetSide+".r"+$xyz[$z]);
		connectAttr ($targetName+"ConstrainedPMAS"+$targetSide+".output3D"+$xyz[$z]) ($targetName+"Follow"+$targetSide+".s"+$xyz[$z]);
		}
	}

createNode -n ($targetName+"ConstrainedOffset"+$sourceA+$targetSide) -p ($targetName+"Offset"+$targetSide) transform;
parent ($targetName+"ConstrainedOffset"+$sourceA+$targetSide) ConstrainedSetup;


//Not constrain directly to source, as it might be side-reverse, so create itermidiate source that is parentConstraint (ignoring scale) to source
if ($sourceASide!=$targetSide)
	{
	$xformA=$targetName+"PS"+$sourceA+$targetSide;
	createNode -n $xformA -p ($targetName+"ConstrainedOffset"+$sourceA+$targetSide) transform;
	parentConstraint -mo $sourceA ($targetName+"PS"+$sourceA+$targetSide);
	}
if ($sourceBSide!=$targetSide)
	{
	createNode -n ($targetName+"ConstrainedOffset"+$sourceB+$targetSide) -p ($targetName+"Offset"+$targetSide) transform;
	parent ($targetName+"ConstrainedOffset"+$sourceB+$targetSide) ConstrainedSetup;

	$xformB=$targetName+"PS"+$sourceB+$targetSide;
	createNode -n $xformB -p ($targetName+"ConstrainedOffset"+$sourceB+$targetSide) transform;
	parentConstraint -mo $sourceB ($targetName+"PS"+$sourceB+$targetSide);
	}

createNode -n ($targetName+"Constrained"+$sourceA+$targetSide) -p ($targetName+"ConstrainedOffset"+$sourceA+$targetSide) transform;
parentConstraint -mo $xformB $xformA ($targetName+"Constrained"+$sourceA+$targetSide);






connectAttr ($targetName+$targetSide+"Blend"+$sourceA+"Reverse.outputX") ($targetName+"Constrained"+$sourceA+$targetSide+"_parentConstraint1."+$xformB+"W0");
connectAttr ($targetName+$targetSide+"Blend"+$sourceA+"UnitConversion.output") ($targetName+"Constrained"+$sourceA+$targetSide+"_parentConstraint1."+$xformA+"W1");

//scale
createNode -n ($targetName+"ConstrainedScaleBC"+$sourceA+$targetSide) blendColors;
connectAttr ($sourceA+".s") ($targetName+"ConstrainedScaleBC"+$sourceA+$targetSide+".color1");
connectAttr ($sourceB+".s") ($targetName+"ConstrainedScaleBC"+$sourceA+$targetSide+".color2");
connectAttr ($targetName+"ConstrainedScaleBC"+$sourceA+$targetSide+".output") ($targetName+"Constrained"+$sourceA+$targetSide+".s");
connectAttr ($targetName+$targetSide+"Blend"+$sourceA+"UnitConversion.output") ($targetName+"ConstrainedScaleBC"+$sourceA+$targetSide+".blender");

$plugNr=`getAttr -s ($targetName+"ConstrainedPMAT"+$targetSide+".input3D")`;
connectAttr ($targetName+"Constrained"+$sourceA+$targetSide+".t") ($targetName+"ConstrainedPMAT"+$targetSide+".input3D["+$plugNr+"]");
connectAttr ($targetName+"Constrained"+$sourceA+$targetSide+".r") ($targetName+"ConstrainedPMAR"+$targetSide+".input3D["+$plugNr+"]");
connectAttr ($targetName+"Constrained"+$sourceA+$targetSide+".s") ($targetName+"ConstrainedPMAS"+$targetSide+".input3D["+$plugNr+"]");
}

global proc string asGetFaceFitSelectionOtherObject (string $object, string $otherObject, string $side)
{
string $selection;
string $sel[]=`ls -sl`;

createNode -n asGetFaceFitSelectionOtherObject transform;
select $otherObject;
$selection=`asGetFaceFitSelection $object`;
delete asGetFaceFitSelectionOtherObject;
select $sel;
return $selection;
}

global proc string asGetFaceFitSelection (string $object)
{
int $tempInts[];
int $form,$spans,$degrees,$numCv,$vtxNr,$numVtx;
float $radius,$maxScale;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $pos[],$pos2[],$s[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $selection,$objectType;
string $sel[]=`ls -sl`;
string $tempString[],$curves[],$groupChildren[];
$tempString=`listRelatives -s $object`;
if ($tempString[0]!="")
	$objectType=`objectType $tempString[0]`;
if (`gmatch $object "*[.]*"`)//allow for cv on a curve. e.g. upperLipOuterCurve.cv[0]
	$objectType="locator";

if (`objExists asGetFaceFitSelectionOtherObject`)
	$geometry=$sel[0];

if (`gmatch $geometry "*[.]*"`)//allow for $object to be faceSelection e.g. eyeBall part of main mesh
	{
	$tempString=`ls -sl -objectsOnly $geometry`;
	$geometry=$tempString[0];
	}

if (`objExists closestSamplerFitSelection2`) delete closestSamplerFitSelection2;
createNode -n closestSamplerFitSelection2 closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection2.inMesh;

if ($objectType=="locator")
	{
	$pos=`xform -q -ws -t $object`;
	setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
	$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
	$selection=($geometry+".vtx["+$vtxNr+"]");
	}
else if ($objectType=="mesh")
	{
	if (`objExists ($object+"PolyExtrudeFacet")`)
		setAttr ($object+"PolyExtrudeFacet.nodeState") 1;
	$tempInts=`polyEvaluate -v $object`;
	$numVtx=$tempInts[0];
	for ($i=0;$i<$numVtx;$i++)
		{
		$pos=`xform -q -ws -t ($object+".vtx["+$i+"]")`;
		setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
		$selection+=($geometry+".vtx["+$vtxNr+"] ");
		}
	if (`objExists ($object+"PolyExtrudeFacet")`)
		setAttr ($object+"PolyExtrudeFacet.nodeState") 0;
	}
else if ($tempString[0]=="")
	{
	$groupChildren=`listRelatives -c $object`;
	for ($i=0;$i<size($groupChildren);$i++)
		{
		$tempString=`listRelatives -s $groupChildren[$i]`;
		if (`gmatch $groupChildren[$i] "*Profile*"`)
			continue;
		if ($tempString[0]!="")
			$curves[size($curves)]=$groupChildren[$i];
		}
	}
else
	$curves[0]=$object;

for ($i=0;$i<size($curves);$i++)
	{
	$spans=`getAttr ($curves[$i]+".spans")`;
	$degrees=`getAttr ($curves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
		$selection+=($geometry+".vtx["+$vtxNr+"] ");
		}
	}

delete closestSamplerFitSelection2;
select $sel;
return $selection;
}

global proc string[] asobjSetCast (string $set, string $components[], string $destObj)
{
string $tempString[],$return[];

if ($set!="")
	{
	select $set;
	$tempString=`ls -sl -fl`;
	}
else
	$tempString=$components;

string $tempString2[];
tokenize $tempString[0] "[.]" $tempString2;
string $sourceObj=$tempString2[0];
for ($i=0;$i<size($tempString);$i++)
	{
	$return[$i]=`substitute $sourceObj $tempString[$i] $destObj`;
	}

return $return;
}

global proc asFaceFitReSelect (string $section, string $part)
{
string $leftSuffix;
if (`gmatch $section "*_R"`)// a method for ensuring Right, even if FaceFitSkeleton.NonSymSide is set to Left
	$section=`substitute "_R" $section ""`;
else
	if (`attributeExists NonSym FaceFitSkeleton`)
		if (`getAttr FaceFitSkeleton.NonSymSide`=="Left")
			$leftSuffix="Left";
string $faceFitNode="FaceFit"+$section+$part+$leftSuffix;
print ("// ReSelecting: "+$section+" : "+$part+$leftSuffix+"\n");
if (`objExists $faceFitNode`)
	if (`attributeExists selection $faceFitNode`)
		evalEcho ("select "+`getAttr ($faceFitNode+".selection")`);
}

global proc asFaceUpdateLipShapeBySoftMod ()
{
setAttr JawOpenLayer.v 1;
setAttr LipDeform.v 0;
asFaceWeightLips;
asFaceUpdateJawCurvesWeights;
print "// Updated\n";
}

global proc asFacet (string $objA,string $objB,string $objC)
{
if (!`objExists $objA` || !`objExists $objB` || !`objExists $objC`)
	return;
float $posA[]=`xform -q -ws -t $objA`;
float $posB[]=`xform -q -ws -t $objB`;
float $posC[]=`xform -q -ws -t $objC`;
string $tempString[]=`polyCreateFacet -ch 0 -n asCageFacet -p $posA[0] $posA[1] $posA[2] -p $posB[0] $posB[1] $posB[2] -p $posC[0] $posC[1] $posC[2]`;

if (`gmatch $objA "*Left"` || `gmatch $objB "*Left"` || `gmatch $objC "*Left"`)
	polyNormal -ch 0 -normalMode 0 -userNormalMode 0 $tempString[0];
}

global proc asFaceWeightLips ()
{
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
float $weight;
float $values[],$pos[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[],$lipMainVtxs[],$lipOuterVtxs[],$lipInnerVtxs[],$lipAreaVtxs[],$infs[];
string $sel[]=`ls -sl`;

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 1;
float $currentTime=`currentTime -q`;
currentTime 0;

skinPercent -tv FaceJoint_M 1 JawOpenLayerSC JawOpenLayer.vtx[0:99999];

duplicate -n lipWeighter $geometry;
$tempString=`listRelatives -s -f lipWeighter`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
sets -rm lipArea lipWeighter.vtx[0:99999];
sets -add mouthOpenSoftModSet lipWeighter;
sets -add mouthOpenSoftModSet JawCurveMid.cv[1:4];
setAttr mouthOpenSoftModHandle.ty 0;
if (!`objExists lipAreaJawOpenLayer`)
	{
	createNode -n lipAreaJawOpenLayer objectSet;
	sets -add FaceBuildingSets lipAreaJawOpenLayer;
	}
select lipArea;
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString JawOpenLayer`;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	string $vtxOnLipWeighter=`substitute JawOpenLayer $tempString[$i] lipWeighter`;
	$posA=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 1;
	$posB=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 0;
	$weight=$posB[1]-$posA[1];
	$tempString[0]=`substitute $geometry $tempString[$i] JawOpenLayer`;
	sets -add lipAreaJawOpenLayer $tempString[0];
	catchQuiet (`skinPercent -tv JawJoint_M $weight JawOpenLayerSC $tempString[0]`);
	}
delete lipWeighter;

//Smooth Lip weights, since the SoftMod (with surface falloff) will create some lip-crunching
select `asobjSetCast lipArea {} JawOpenLayer`;
$lipAreaVtxs=`ls -sl -fl`;
eval ("select "+`asGetFaceFitSelection FaceFitLipMainCurve`);
$lipMainVtxs=`ls -sl`;
select `asobjSetCast "" $lipMainVtxs JawOpenLayer`;
$lipMainVtxs=`ls -sl -fl`;

eval ("select "+`asGetFaceFitSelection FaceFitLipOuterCurve`);
$lipOuterVtxs=`ls -sl`;
select `asobjSetCast "" $lipOuterVtxs JawOpenLayer`;
$lipOuterVtxs=`ls -sl -fl`;

eval ("select "+`asGetFaceFitSelection FaceFitLipInnerCurve`);
$lipInnerVtxs=`ls -sl`;
select `asobjSetCast "" $lipInnerVtxs JawOpenLayer`;
$lipInnerVtxs=`ls -sl -fl`;

for ($i=0;$i<size($lipOuterVtxs);$i++)
	{
	select $lipOuterVtxs[$i];
	for ($a=0;$a<99;$a++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $tempString[$y] $lipMainVtxs`)
				{
				$infs=`skinPercent -q -t JawOpenLayerSC $tempString[$y]`;
				$values=`skinPercent -q -v JawOpenLayerSC $tempString[$y]`;
				for ($z=0;$z<size($infs);$z++)
					if ($infs[$z]=="JawJoint_M")
						$weight=$values[$z];
				skinPercent -tv JawJoint_M $weight JawOpenLayerSC $lipOuterVtxs[$i];
				$a=99;
				}
		}
	}

for ($i=0;$i<size($lipInnerVtxs);$i++)
	{
	select $lipInnerVtxs[$i];
	for ($a=0;$a<99;$a++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $tempString[$y] $lipMainVtxs`)
				{
				$infs=`skinPercent -q -t JawOpenLayerSC $tempString[$y]`;
				$values=`skinPercent -q -v JawOpenLayerSC $tempString[$y]`;
				for ($z=0;$z<size($infs);$z++)
					if ($infs[$z]=="JawJoint_M")
						$weight=$values[$z];
				skinPercent -tv JawJoint_M $weight JawOpenLayerSC $lipInnerVtxs[$i];
				$a=99;
				}
		}
	}

select $lipAreaVtxs;
select -d $lipMainVtxs $lipOuterVtxs $lipInnerVtxs;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[0]>-0.001)
		select -d $tempString[$i];
	}
if (size(`ls -sl`))
	weightHammerVerts;
select JawOpenLayer;
if (!$nonSymmetrical)
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 0;
currentTime $currentTime;
select $sel;
}

global proc asFaceUpdateJawCurvesWeights ()
{
global string $gMainPane;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
float $posA[],$posB[],$posC[];
float $bbCurveTop[],$bbCurveBottom[];
float $faceFitScale=`getAttr FaceFitSkeleton.faceScale`;
float $maxDist;
string $tempString[],$ySel[],$zSelInv[],$infJoints[],$lipFalloffAreaVtxs[];
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $numJawSmooths=`intField -q -v asFaceNumJawSmooths`;
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
float $currentTime=`currentTime -q`;
currentTime 0;

progressBar -e -st ("Update Jaw Weights") -bp -ii 0 -min 0 -max 1 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 1;

if (`objExists jawArea`) delete jawArea;
if (`objExists jawCurveVtxs`) delete jawCurveVtxs;

asSelectCurveVtx JawCurve;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] JawOpenLayer`;
string $jawCurveVtxs[]=`ls -sl -fl`;
sets -n jawCurveVtxs;
sets -add FaceBuildingSets jawCurveVtxs;
asSelectCurveVtx JawCurveMid;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] JawOpenLayer`;
string $jawCurveMidVtxs[]=`ls -sl -fl`;

skinPercent -tv JawJoint_M 1 JawOpenLayerSC $jawCurveVtxs;
skinPercent -tv JawJoint_M 0.5 JawOpenLayerSC $jawCurveMidVtxs;

//taper off skinWeights towards the jawPivot, based on distance
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t Jaw`;
$maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv JawJoint_M (($dist/$maxDist)*2) JawOpenLayerSC $jawCurveVtxs[$i];
	}

//taper off skinWeights towards the jawPivot, based on distance (50vtx)
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveMidVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveMidVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv JawJoint_M ($dist/$maxDist) JawOpenLayerSC $jawCurveMidVtxs[$i];
	}

//Select vtxs with curve boundaries, first from BB polySeConstr for speed
duplicate -n JawCurveTopSampler JawCurveTop;
duplicate -n JawCurveBottomSampler JawCurveBottom;
select JawCurveTopSampler.cv[0:6] JawCurveBottomSampler.cv[0:5];
move -x 0;
//include Jaw vtx
move -r 0 -0.001 0 JawCurveBottomSampler.cv[5];
//Jaw can be lower than throat on some characters
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t Throat`;
if ($posA[1]<$posB[1])
	{
	xform -ws -t 0 $posA[1] $posA[2] JawCurveBottomSampler.cv[5];
	//And there might be vtx`s lower then Jaw loc
	$posC=`xform -q -ws -t JawCurveBottomSampler.cv[4]`;
	xform -ws -t 0 ($posA[1]-($faceFitScale/10.0)) (($posA[2]+$posC[2])/2.0) JawCurveBottomSampler.cv[4];
	}
spaceLocator -n samplerLocator;
spaceLocator -n samplerLocatorTop;
spaceLocator -n samplerLocatorBottom;
parent samplerLocatorTop samplerLocatorBottom samplerLocator;
select JawCurveTopSampler samplerLocatorTop;geometryConstraint -weight 1;
select samplerLocator samplerLocatorTop;pointConstraint;
select JawCurveBottomSampler samplerLocatorBottom;geometryConstraint -weight 1;
select samplerLocator samplerLocatorBottom;pointConstraint;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenLayer;
//polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[4] -da 0 1 0 -dp 0 0 0;
//updated to all for jaw to be under world Y axis(fish)
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveTop[4]-$bbCurveBottom[1])/1.99) -dp 0 (($bbCurveTop[4]+$bbCurveBottom[1])/2.0) 0 -da 0 1 0;
$ySel=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[2]-100);
$zSelInv=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
asInvertSelection;
string $outsideOuterBoundsVtxs[]=`ls -sl`;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenLayer;
//polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
//updated to all for jaw to be under world Y axis(fish)
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveTop[1]-$bbCurveBottom[1])/2.0) -dp 0 (($bbCurveTop[1]+$bbCurveBottom[1])/2.0) 0 -da 0 1 0;
$ySel=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[5]-100);
$zSelInv=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
string $insideInnerBoundsVtxs[]=`ls -sl`;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenLayer;
//polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveTop[4] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
//updated to all for jaw to be under world Y axis(fish)
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveTop[4]-$bbCurveTop[1])/2.0) -dp 0 (($bbCurveTop[4]+$bbCurveTop[1])/2.0) 0 -da 0 1 0;
string $yOnBoundSel[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 ((($bbCurveBottom[5]-$bbCurveBottom[2])/2.0)*1.001) -da 0 0 1 -dp 0 0 (($bbCurveBottom[5]+$bbCurveBottom[2])/2.0);
string $zOnBoundSelInv[]=`ls -sl`;
polySelectConstraint -m 0;
select $yOnBoundSel $zOnBoundSelInv;
select -d $outsideOuterBoundsVtxs;
string $onBoundsVtxs[]=`ls -sl -fl`;

select -cl;
for ($i=0;$i<size($onBoundsVtxs);$i++)
	{
	$pos=`xform -q -ws -t $onBoundsVtxs[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] samplerLocator;
	refresh;
	if (`getAttr samplerLocatorTop.ty`>0)
		select -add $onBoundsVtxs[$i];
	}

select -add $insideInnerBoundsVtxs;
select -d lipAreaJawOpenLayer;
sets -n jawArea;
sets -add FaceBuildingSets jawArea;
select -d $jawCurveVtxs $jawCurveMidVtxs;

if (size(`ls -sl`))
	{
	weightHammerVerts;
	copySkinWeights -ss -ds -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

select jawArea;
//asSmoothFlood FaceJoint_M JawJoint_M $numJawSmooths;
select JawOpenLayer JawCurve;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//fix the weighting just above upperLip
select lipAreaJawOpenLayer;
string $completedVtxs[]=`ls -sl -fl`;
//eval ("select "+`getAttr FaceFitLipOuter.upperSelection`);
eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
$tempString=`ls -sl -fl`;
float $bb[]=`xform -q -bb`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] JawOpenLayer`;
string $lipOutherVtxs[]=`ls -sl -fl`;
for ($i=0;$i<size($lipOutherVtxs);$i++)
	{
	$posA=`xform -q -ws -t $lipOutherVtxs[$i]`;
//	if ($posA[0]>0)
//		continue;
	select $lipOutherVtxs[$i];
	float $prevWeights[];
	float $onLipWeights[]=`skinPercent -ignoreBelow 0.001 -q -v JawOpenLayerSC`;
	select $lipOutherVtxs[$i];
	for ($y=0;$y<$vtxsFromLipToNose;$y++)
		{
		asWsPickWalk 0 1 0;
//		refresh;
		$tempString=`ls -sl -fl`;
		if (`sets -im lipAreaJawOpenLayer $tempString[0]`)
			continue;
		float $newWeight=$onLipWeights[1]-(($onLipWeights[1]/$vtxsFromLipToNose)*$y);
		skinPercent -tv JawJoint_M $newWeight JawOpenLayerSC;
		}
	}

if (!$nonSymmetrical)
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;


select jawArea;
select -d jawCurveVtxs;
currentTime 30;
asSmoothFlood FaceJoint_M JawJoint_M $numJawSmooths;

if (!$nonSymmetrical)
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 0;

delete samplerLocator JawCurveTopSampler JawCurveBottomSampler;

//remove all jaw weights, as the jawAre might have been reduced by adjustment of JawCurves
skinPercent -tv JawJoint_M 0 JawLayerSC JawLayer;

//transfer to JawLayer mesh - from:LipDeform
select `asobjSetCast lipArea {} LipDeform`;
select -add `asobjSetCast lipArea {} JawLayer`;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//Hammer $lipFalloffAreaVtxs
select `asobjSetCast lipFalloffArea {} JawOpenLayer`;
$lipFalloffAreaVtxs=`ls -sl -fl`;
select $lipFalloffAreaVtxs;
if (size(`ls -sl`))
	weightHammerVerts;

//if teeth part of Main mesh
if (`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString JawOpenLayer`;
	skinPercent -tv JawJoint_M 1 JawOpenLayerSC `ls -sl`;
	}
//if tongue part of Main mesh
//if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)//a case had tongue part of a InnerMouth object
//if (`gmatch $tongue "*[.]*"`)//but here is asobjSetCast so re-enable gmatch
if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
	{
	eval ("select "+$tongue);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString JawOpenLayer`;
	skinPercent -tv JawJoint_M 1 JawOpenLayerSC `ls -sl`;
	}

currentTime 0 ;
if (`objExists FaceFitLipMainLeft`)
	{
	select -r `asobjSetCast lipArea {} JawOpenLayer`;
	asInvertSelection;
	copySkinWeights -ss -ds -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
else
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

currentTime $currentTime;
select $sel;
}

global proc asWsPickWalk (int $x, int $y, int $z)
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "No selection provided to asWsPickWalk";
float $posA[]=`xform -q -ws -t $sel[0]`;
ConvertSelectionToEdges;
ConvertSelectionToVertices;
string $expandSel[]=`ls -sl -fl`;
float $dist,$maxWeight;
//float $minDist=9999;
for ($i=0;$i<size($expandSel);$i++)
	{
	if ($expandSel[$i]==$sel[0])
		continue;
	float $posB[]=`xform -q -ws -t $expandSel[$i]`;
	if ($x==1 && $posB[0]<$posA[0]) continue;
	if ($y==1 && $posB[1]<$posA[1]) continue;
	if ($z==1 && $posB[2]<$posA[2]) continue;
	if ($x==-1 && $posB[0]>$posA[0]) continue;
	if ($y==-1 && $posB[1]>$posA[1]) continue;
	if ($z==-1 && $posB[2]>$posA[2]) continue;

	$xDist=abs($posB[0]-$posA[0]);
	$yDist=abs($posB[1]-$posA[1]);
	$zDist=abs($posB[2]-$posA[2]);
	$xyzDist=$xDist+$yDist+$zDist;
	if (abs($x)) $weight=$xDist/$xyzDist;
	if (abs($y)) $weight=$yDist/$xyzDist;
	if (abs($z)) $weight=$zDist/$xyzDist;

	if ($weight>$maxWeight)
		{
		$maxWeight=$weight;
		select $expandSel[$i];
		}
	}
string $tempString[]=`ls -sl -fl`;
if (size($tempString)>1)
	select $tempString[0];
}

global proc string[] asDeformer (string $deformer)
{
int $deformationUseComponentTags;
string $return[];

//Maya2022 needs deformationUseComponentTags optionVar set to 0, to create legacy deformer-sets
if (`asMayaVersionAsFloat`>=2022)
	{
	$deformationUseComponentTags=`optionVar -q deformationUseComponentTags`;
	if ($deformationUseComponentTags)
		optionVar -iv deformationUseComponentTags 0;
	}

if ($deformer=="softMod")
	$return=`softMod -falloffMode 1 -falloffAroundSelection 0`;
else if ($deformer=="cluster")
	$return=`cluster -envelope 1`;
else
	$return=`eval ($deformer)`;

if ($deformationUseComponentTags)
	optionVar -iv deformationUseComponentTags 1;

return $return;
}

global proc asCurveOffsetMesh (string $curve, string $geometry ,float $offset)
{
float $spans=`getAttr ($curve+".spans")`;
float $startPos[]=`xform -q -ws -t ($curve+".cv[0]")`;
float $endPos[]=`xform -q -ws -t ($curve+".cv[99]")`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 20 -d 3 -tol 0.01 $curve;
spaceLocator -n constraintLoc;
spaceLocator -n constraintLoc2;
parent constraintLoc2 constraintLoc;
setAttr constraintLoc2.tx $offset;
select $geometry constraintLoc;
geometryConstraint -weight 1;
select $geometry constraintLoc;
normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
for ($i=0;$i<23;$i++)
    {
    $posA=`xform -q -ws -t ($curve+".cv["+$i+"]")`;
    xform -ws -t $posA[0] $posA[1] $posA[2] constraintLoc;
    $posB=`xform -q -ws -t constraintLoc2`;
    xform -ws -t $posB[0] $posB[1] $posB[2] ($curve+".cv["+$i+"]");
    }
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 3 -tol 0.01 $curve;
delete constraintLoc;
xform -ws -t $startPos[0] $startPos[1] $startPos[2] ($curve+".cv[0]");
xform -ws -t $endPos[0] $endPos[1] $endPos[2] ($curve+".cv[99]");
}

global proc asFaceWrapDeformToFace ()
{
float $pos[];
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $shape;
string $tempString[];
//remove possible existing defomers first
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	DeleteHistory;
	}
for ($i=0;$i<size($sel);$i++)
	{
	select -r $sel[$i];
	select -add $geometry;
	$tempString=`doWrapArgList "6" { "1","0","1", "2", "0", "1", "1", "0" }`;
	rename $tempString[0] eyeBrowWrap;
	}
print ("// WrapDeformer created\n");
}

global proc asFaceSwapControlsToSpheres ()
{
int $keepOffset=`checkBox -q -v asFaceSwapControlsKeepOffsetCheckBox`;
float $mag;
//float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $faceFitScale=`getAttr FaceFitSkeleton.faceScale`;
float $posA[],$posB[];
string $sel[]=`ls -sl`;
string $aCtrls[]=`listConnections ctrlBox.ACtrlVis`;
string $bCtrls[]=`listConnections ctrlBox.BCtrlVis`;
string $cCtrls[]=`listConnections ctrlBox.CCtrlVis`;
string $onFaceCtrls[]=`stringArrayCatenate $aCtrls $bCtrls`;
$onFaceCtrls=`stringArrayCatenate $onFaceCtrls $cCtrls`;
string $tempString[];

asFaceEnsureShaders;

for ($i=0;$i<size($onFaceCtrls);$i++)
	{
	if (`gmatch $onFaceCtrls[$i] "SmilePull_*"`)
		continue;
	$tempString=`listRelatives -s $onFaceCtrls[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`objectType $tempString[0]`!="nurbsCurve")
		continue;
	$posA=`xform -q -ws -t ($onFaceCtrls[$i]+".cv[1]")`;
	$posB=`xform -q -ws -t ($onFaceCtrls[$i]+".cv[5]")`;
	$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
	$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (($mag*5)/$faceFitScale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
	rename $tempString[0] ($onFaceCtrls[$i]+"Sphere");
	parent -add -s ($onFaceCtrls[$i]+"SphereShape") $onFaceCtrls[$i];
	delete ($onFaceCtrls[$i]+"Shape");
	rename ($onFaceCtrls[$i]+"SphereShape") ($onFaceCtrls[$i]+"Shape");
	delete ($onFaceCtrls[$i]+"Sphere");

	if (`stringArrayCount $onFaceCtrls[$i] $aCtrls`) sets -e -forceElement asFaceGreenSG ($onFaceCtrls[$i]+"Shape");
	if (`stringArrayCount $onFaceCtrls[$i] $bCtrls`) sets -e -forceElement asFaceRedSG ($onFaceCtrls[$i]+"Shape");
	if (`stringArrayCount $onFaceCtrls[$i] $cCtrls`) sets -e -forceElement asFaceBlueSG ($onFaceCtrls[$i]+"Shape");

	if (!$keepOffset)
		continue;
	$posB=`xform -q -ws -t ($onFaceCtrls[$i]+".cv[0][0]")`;
	$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
	move -r 0 0 $mag ($onFaceCtrls[$i]+".cv[0:99][0:99]");
	}
select $sel;
}

global proc asFaceDetachControllers ()
{
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$sc=`asGetSkinCluster $allFaceGeo[$i]`;
	setAttr ($sc+".envelope") 0;
	}
print "// Controllers Detached.\n";
}

global proc asFaceAttachControllers ()
{
float $pos[],$pos2[],$rot[];
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $offsetNode,$mirrorCtrl,$mirrorOffsetNode,$constraint,$restorePoseCmd;
string $sel[]=`ls -sl`;
string $tempString[],$layers[],$historyNodes[],$controls[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//use asMirror
$restorePoseCmd=`asGetRestorePoseCmd`;
if (`window -q -ex tempWindow`)
	deleteUI tempWindow;
window tempWindow;
columnLayout;
optionMenu tempWindowOptionMenu;
	menuItem -l ":";
text -l "ControlSet " tempWindowControlSetsText;
optionVar -sv asMOSide "asMOSideR2L";
optionVar -sv asMOSpace "asMOSpaceMain";
optionVar -sv asMOAxis "asMOAxisX";
optionVar -sv asMOSelOnly "asMOSelOnlyAll";
text -e -l "FaceControlSet " tempWindowControlSetsText;
asMirror tempWindow;
deleteUI tempWindow;

$controls=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (`gmatch $controls[$i] "Iris_*"` || `gmatch $controls[$i] "Pupil_*"`)
		continue;
	clear $pos;
	clear $rot;
	if (`getAttr -k ($controls[$i]+".tx")`)
		{
		$pos=`getAttr ($controls[$i]+".t")`;
		$pos2=`xform -q -ws -t $controls[$i]`;
		}
	if (`getAttr -k ($controls[$i]+".rx")`)
		{
//		setAttr tempTransformFlip.sx 1;
//		delete `orientConstraint $controls[$i] tempTransform`;
		$rot=`getAttr ($controls[$i]+".r")`;
		}
	if (!($pos[0]!=0 || $pos[1]!=0 || $pos[2]!=0 || $rot[0]!=0 || $rot[1]!=0 || $rot[2]!=0))
		continue;

	tokenize $controls[$i] "_" $tempString;
	$offsetNode=$tempString[0]+"Offset_"+$tempString[1];
	if (!`objExists $offsetNode`)
		continue;

	createNode -n tempTransform -p $controls[$i] transform;
	$tempString=`listRelatives -p $offsetNode`;
	parent tempTransform $tempString[0];
	delete `parentConstraint tempTransform $offsetNode`;
	delete tempTransform;
	xform -os -t 0 0 0 -ro 0 0 0 $controls[$i];
	print ("// oriented:"+$controls[$i]+".\n");
	}

//freezeSkinCluster 
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$sc=`asGetSkinCluster $allFaceGeo[$i]`;
	freezeSkinCluster $sc;
	setAttr ($sc+".envelope") 1;
	}

//eval($restorePoseCmd);
dgdirty -a;
print "// Controllers Attached.\n";
select $sel;
}

global proc asFaceAttachEyeLashes ()
{
int $modifier=`getModifiers`;
int $multiSkinClusters=`checkBox -q -v asFaceMultiSkinClustersCheckBox`;
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "Nothing selected";
int $numLid,$haveSkinCluster;
float $pos[],$values[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
int $gameEngine=`checkBox -q -v asFaceGameEngineCheckBox`;
string $sc,$side,$upperLower,$name,$addInfCmd,$multiSkinClusterCmd;
string $tempString[],$historyNodes[],$infs[];

//eyeLidCage
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		for ($y=1;$y<99;$y++)
			{
			if (`objExists ($upperLower+"LidMain"+$y+$side)`)
				$numLid=$y;
			else
				break;
			}

		polyPlane -n ($upperLower+"EyeLidCage"+$side) -w 1 -h 1 -sx ($numLid-1) -sy 1 -ax 0 1 0 -cuv 2 -ch 1;
		for ($y=1;$y<$numLid+1;$y++)
			{
			$pos=`xform -q -ws -t ($upperLower+"LidMain"+$y+$side)`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			$pos=`xform -q -ws -t FitEyeBall`;
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 4 4 4 ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			}
		select ($upperLower+"EyeLidCage"+$side);
		for ($y=1;$y<$numLid+1;$y++)
			select -add ($upperLower+"LidMain"+$y+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"EyeLidCageSC"+$side);
		select $geometry ($upperLower+"EyeLidCage"+$side);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

		for ($y=1;$y<$numLid+1;$y++)
			{
			$infs=`skinPercent -ignoreBelow 0.001 -q -t ($upperLower+"EyeLidCageSC"+$side) ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]")`;
			$values=`skinPercent -ignoreBelow 0.001 -q -v ($upperLower+"EyeLidCageSC"+$side) ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]")`;
			for ($z=0;$z<size($infs);$z++)
				{
				skinPercent -tv $infs[$z] $values[$z] ($upperLower+"EyeLidCageSC"+$side) ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
				}
			}
		}
	}

//add infl
for ($i=0;$i<size($sel);$i++)
	{
	$addInfCmd="skinCluster -e -dr 4 ";
	$multiSkinClusterCmd="select "+$sel[$i];
	$historyNodes=`listHistory $sel[$i]`;
	$haveSkinCluster=0;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$sc=$historyNodes[$y];
			}
	if ($sc==$skinCluster)//if eyelashes are part of Main mesh
		continue;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			for ($y=1;$y<99;$y++)
				{
				if (`objExists ($upperLower+"LidMain"+$y+$side)`)
					$numLid=$y;
				else
					break;
				}

			for ($y=1;$y<$numLid+1;$y++)
				{
				$addInfCmd+=" -ai "+$upperLower+"LidMain"+$y+$side;
				$multiSkinClusterCmd+=" "+$upperLower+"LidMain"+$y+$side;
				}
			}
		}
	$addInfCmd+=" "+$sc;
	$multiSkinClusterCmd+=";skinCluster -multi 1 -frontOfChain -toSelectedBones -name EyeLidSC";
	if ($multiSkinClusters)
		eval ($multiSkinClusterCmd);
	else
		eval ($addInfCmd);

	//dualQ weight eyeLashes to match the eyeLids
	if (!$gameEngine)
		setAttr ($sc+".skinningMethod") 1;
	}

//cageWeights to eyeLash geo
for ($i=0;$i<size($sel);$i++)
	{
	select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
	select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

if ($modifier!=4)
	delete upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;


select $sel;
print ("// Attached EyeLashes.\n");
}

global proc float asCurveChkSum (string $curve)
{
int $form,$spans,$degrees,$numCv;
float $chkSum;
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2) $numCv=$spans;
else $numCv=$spans+$degrees;
for ($i=0;$i<$numCv;$i++)
	{
	$pos=`xform -q -ws -t ($curve+".cv["+$i+"]")`;
	$chkSum=$chkSum+$pos[0]+$pos[1]+$pos[2];
	}

return $chkSum;
}

global proc asFaceDeleteFromCheckBox (string $region)
{
string $leftSuffix;
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSymSide`=="Left")
		$leftSuffix="Left";

string $dialog=`confirmDialog -t "Confirm"
	-m ("Delete "+$region)
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	{
	checkBox -e -v 1 ("asFaceFit"+$region);
	return;
	}
if (`objExists ("FaceFit"+$region+$leftSuffix)`)
	delete ("FaceFit"+$region+$leftSuffix);

if (`gmatch $region "Lip*"` && `objExists ("FaceFit"+$region+"Left")`)
	delete ("FaceFit"+$region+"Left");

checkBox -e -ed 0 ("asFaceFit"+$region);
}

global proc asFaceFitHide (string $sections, string $parts)
{
string $leftSuffix;
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSymSide`=="Left")
		$leftSuffix="Left";
int $vis=`getAttr ("FaceFit"+$sections+$parts+$leftSuffix+".v")`;
setAttr ("FaceFit"+$sections+$parts+$leftSuffix+".v") (!$vis);
}

global proc asSmoothFlood (string $infA, string $infB, int $numSmoo)
{
global string $gSelect;
string $selO[]=`ls -sl -o`;
if ($selO[0]=="")
	return;

string $tempString[]=`listHistory $selO[0]`;
string $skinCluster;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="skinCluster")
		$skinCluster=$tempString[$y];

//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;

if ($infB!="")
	for ($i=0;$i<size($infJoints);$i++)
		{
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 1;
		if ($infJoints[$i]==$infA || $infJoints[$i]==$infB)
			setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
		}

ArtPaintSkinWeightsTool; 
//artAttrSkinToolScript 4;//Maya2018(pre2018.1) needs this
//some systems needs this (not sure why)
source artAttrSkinJointMenu;
artAttrSkinPaintCtx -e -sao smooth -influence $infA artAttrSkinContext;
artSkinInflListChanging $infA 1;
artSkinInflListChanged artAttrSkinPaintCtx;
for ($i=0;$i<$numSmoo;$i++)
	artFloodSurfaces;

for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
setToolTo $gSelect;
}

global proc asSkinTeeth ()
{
global string $gSelect;
int $tempSkinTongue=1;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="upperTeethJoint_M";
string $lowerTeethJoint="lowerTeethJoint_M";
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $upperTeethInVtxString,$lowerTeethInVtxString,$tongueInVtxString;
string $tempString[];

//make sure teeth & tongue geo is in vtxs
if ($upperTeeth!="") 
	{
	eval ("select "+$upperTeeth);
	catchQuiet (`ConvertSelectionToVertices`);//some cases prompts results of ConvertSelectionToVertices
	$tempString=`ls -sl`;
	$upperTeethInVtxString=`stringArrayToString $tempString " "`;
	}
if ($lowerTeeth!="") 
	{
	eval ("select "+$lowerTeeth);
	catchQuiet (`ConvertSelectionToVertices`);//some cases prompts results of ConvertSelectionToVertices
	$tempString=`ls -sl`;
	$lowerTeethInVtxString=`stringArrayToString $tempString " "`;
	}
if ($tongue!="") 
	{
	eval ("select "+$tongue);
	catchQuiet (`ConvertSelectionToVertices`);//some cases prompts results of ConvertSelectionToVertices
	$tempString=`ls -sl`;
	$tongueInVtxString=`stringArrayToString $tempString " "`;
	}

//teeth
string $upperLower,$teeth,$teethJoint,$teethObject;
string $teethObjects[];
string $teethSC=$skinCluster;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$teeth=$upperTeethInVtxString;$teethJoint=$upperTeethJoint;}
	else {$upperLower="lower";$teeth=$lowerTeethInVtxString;$teethJoint=$lowerTeethJoint;}
		
	if ($teeth=="")
		continue;

  eval ("select "+$teeth);
  $teethObjects=`ls -sl -o`;

	for ($i=0;$i<size($teethObjects);$i++)
		{
		$teethObject=$teethObjects[$i];
		int $haveSkinCluster=0;
	
		string $historyNodes[]=`listHistory -pdo 1 -il 2 $teethObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$teethSC=$historyNodes[$y];
				}
		if (!$haveSkinCluster)
			{
			select $teethJoint;
			select -add $teethObjects[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($upperLower+"TeethSC");
			}
		else if (`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)
			{
			skinCluster -e -ai $teethJoint -lw false -wt 0 $skinCluster;
			eval ("select "+$teeth);
			skinPercent -tv $teethJoint 1 $skinCluster;
			}
		else
			{
			$tempString=`listConnections ($teethSC+".matrix")`;
			if (!`stringArrayCount $teethJoint $tempString`)
				skinCluster -e -ai $teethJoint -lw false -wt 0 $teethSC;
			eval ("select "+$teeth);
			catchQuiet (`skinPercent -tv $teethJoint 1 $teethSC`);
//			skinCluster -e -ri $headJoint $teethSC;//removed cause can cause Maya to quietly stop evaluation from here onward.
			}
		}
	}
//Temp skin tongue as well, for easier jaw-weighting
//if teeth part of Main mesh, then skip as weight will be on JawLayer
//if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)//a case had tongue part of a InnerMouth object
if (`gmatch $tongue "*[.]*"`)
	$tempSkinTongue=0;
if ($tongue!="" && $tempSkinTongue)
	{
	eval ("select "+$tongueInVtxString);
	$tempString=`ls -sl -o`;
	string $tongueObject=$tempString[0];
	int $haveSkinCluster=0;
	string $historyNodes[]=`listHistory -pdo 1 -il 2 $tongueObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$skinCluster=$historyNodes[$y];
				}
	if (!$haveSkinCluster)
		{
		select JawJoint_M;
		select -add $tongueObject;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] TongueSC;
		}
	else //if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)//a case had tongue part of a InnerMouth object
//		if (`gmatch $tongue "*[.]*"`)//but here is asobjSetCast so re-enable gmatch
		if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
		{
		eval ("select "+$tongueInVtxString);
		$tempString=`ls -sl`;
		select `asobjSetCast "" $tempString JawOpenLayer`;
		skinPercent -tv JawJoint_M 1 JawOpenLayerSC `ls -sl`;
		}
	else
		{
		$tempString=`listConnections ($skinCluster+".matrix")`;
		if (!`stringArrayCount JawJoint_M $tempString`)
			skinCluster -e -ai JawJoint_M -lw false -wt 0 $skinCluster;
		eval ("select "+$tongueInVtxString);
		skinPercent -tv JawJoint_M 1 $skinCluster `ls -sl`;
//		skinCluster -e -ri $headJoint $skinCluster;//removed cause can cause Maya to quietly stop evaluation from here onward.
		}
	}

setToolTo $gSelect;
}

global proc asSelectCurveVtx (string $curve)
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[]=`listRelatives -s $curve`;
string $curveShape=$tempString[0];

string $tmpObjs[]={"tempLocator","tempPointOnCurveInfo","samplerMesh","closestSampler"};
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
spaceLocator -n tempLocator;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
connectAttr -f ($curveShape+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
setAttr tempPointOnCurveInfo.parameter 0.5;
connectAttr tempPointOnCurveInfo.position tempLocator.t;
setAttr tempLocator.v 0;

asCreateSamplerMesh $geometry; 
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr tempLocator.worldPosition closestSampler.inPosition;
setAttr "tempPointOnCurveInfo.parameter" 1;
select -cl;
int $previousVtx;
for ($i=0;$i<101;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter (0.01*$i);
	int $vtx=`getAttr closestSampler.result.closestVertexIndex`;
	if($vtx!=$previousVtx)
		{
		select -add ($geometry+".vtx["+$vtx+"]");
		string $currentSel[]=`ls -sl`;
//		refresh;
		select $currentSel;
		}
	$previousVtx=$vtx;
	}
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
}

global proc asFacePaintDeltaMush ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;

if (!`objExists asFaceDeltaMush`)
	error "asFaceDeltaMush not found, Create DeltaMush first.";

select $geometry;

artAttrToolScript 4 "deltaMush";
}

global proc asFacePaintClusterWeights ()
{
global string $artSelectObject;
string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrune" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;
	
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[0];
$side="_"+$tempString[1];

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
setAttr ClustersRegion.v 1;

if ($dialog=="UnPrune")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ClustersRegion.vtx[0:999999];
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
select ClustersRegion;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
}

global proc asFaceCreateSkinLayer (string $layer)
{
string $name,$geo,$inLayerName,$asFaceBS;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[],$tempString2[],$tempString3[];

duplicate -n ($layer+"Layer")  TemplateLayer;
$tempString=`listRelatives -c -type transform ($layer+"Layer")`;
for ($i=0;$i<size($tempString);$i++)
	{
	$name=`substitute "TemplateLayer_" $tempString[$i] ""`;
	$inLayerName=$layer+"Layer_"+$name;
	rename ($layer+"Layer|"+$tempString[$i]) $inLayerName;


	$tempString2=`listRelatives -s ("FaceJointsLayer_"+$name)`;
	$tempString3=`listConnections -s 0 -d 1 -type blendShape $tempString2[0]`;
	$asFaceBS=$tempString3[0];

	//find $geo from BlendShape node
	$tempString2=`listHistory -f 1 $asFaceBS`;
	for ($y=0;$y<size($tempString2);$y++)
		if (`objectType $tempString2[$y]`=="mesh")
			{
			$tempString3=`listRelatives -p $tempString2[$y]`;
			$geo=$tempString3[0];
			}

	blendShape -e -tc 0 -t $geo `getAttr -s ($asFaceBS+".w")` $inLayerName 1 $asFaceBS;
	setAttr ($asFaceBS+"."+$inLayerName) 1;
	}
}

global proc asShowLayer (string $layer)
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $rightEye=`textField -q -tx asFaceRightEyeTextField`;
string $leftEye=`textField -q -tx asFaceLeftEyeTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $tempString[],$tempString2[],$allFaceGeo[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`stringArrayCount $geometry $allFaceGeo`)
	$allFaceGeo[size($allFaceGeo)]=$geometry;


if (!`objExists DeformationLayers`)
	return;

int $normal=0;
if ($layer=="Normal") $normal=1;

for ($i=0;$i<size($allFaceGeo);$i++)
	setAttr ($allFaceGeo[$i]+".v") $normal;

string $layers[]=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($layers);$i++)
	{
	if (`getAttr -l ($layers[$i]+".v")`)
		setAttr -l 0 ($layers[$i]+".v");
	setAttr ($layers[$i]+".v") 0;
	}
select -cl;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v (!$normal);
setAttr -l $normal DeformationLayers.v;
if (!$normal)
	for ($i=0;$i<size($layers);$i++)
		if (`gmatch $layers[$i] ($layer+"Layer*")`)
			{
			setAttr ($layers[$i]+".v") (!$normal);
			if (!$normal) select -add $layers[$i];
			}
}

global proc asBlendShapeFrontOfChain (string $name)
{
//Maya 2018 onwards pops up warning dialog here, (e.g. if headsquahs has been added) (deformation-order compatability)
//so we try first to se if -suppressDialog flag is accepted
if (catchQuiet (`blendShape -n $name -frontOfChain -suppressDialog`))
	blendShape -n $name -frontOfChain;
}

global proc asBSConvertDStoBS ()
{
global string $gMainProgressBar;
int $opm=`asGetOpm`;
int $autoKeyState=`autoKeyframe -q -state`;
int $keepJoints=`checkBox -q -v asKeepJointsCheckBox`;
int $keepBSTarget=`checkBox -q -v asKeepBSTargetsCheckBox`;
int $keepLine,$reacedInfluenceAttr,$numChar,$sideFactor,$sideStepNr,$sideStepLeftNr,$sideStepRightNr,$start,$end;
int $limitsStatus=`getAttr ctrlBox.limits`;
int $keep,$gameEngine,$useSkinLayers,$b,$scaledCtrl,$posOnlyAttr;
int $values[]={1,-1};
float $ctrlScale=`getAttr OnFacecontrols.sx`;
float $cheekPos[]=`xform -q -ws -t JawPivot`;
float $drivingValue,$factor;
float $transformLimits[],$softLimits[],$pos[],$pos2[],$rot[],$rot2[],$softMaxs[],$pos[],$pos2[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $rightEye=`textField -q -tx asFaceRightEyeTextField`;
string $leftEye=`textField -q -tx asFaceLeftEyeTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $eyeBrow=`textField -q -tx asFaceEyebrowTextField`;
string $eyeLash=`textField -q -tx asFaceEyelashTextField`;
string $extras=`textField -q -tx asFaceExtrasTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $exp,$newExp,$obj,$attr,$setAttrCmdExtra,$cmd,$sc,$sc2,$posNeg,$upMidLoLayerGeometry,$upMidLoLayerEye,$eyeGeoText,$outerMain,$upperLower;
string $name,$layerSuffix,$inOut,$side,$existingCmd,$newCmd,$asFaceBS,$targetName,$existingCmd,$newCmd,$sideLessObj,$setAttrCmd,$parent;
//string $blendedAttrs[]={"txPos_tyPos","txPos_tyNeg","txNeg_tyPos","txNeg_tyNeg"};
string $trs[]={"t","r","s"};
string $trsLong[]={"Translate","Rotate","Scale"};
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $upperMiddleLower[]={"upper","middle","lower"};
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$geos[],$sdkNodes[],$objAttrs[],$phonemesAttrs[],$phonemesPreBSSDKs[],$objs[],$phonemes[];
string $deleteObjs[],$upperTeethObjs[],$lowerTeethObjs[],$attrs[],$udAttrs[],$historyNodes[],$keepingJoints[],$keepControls[],$keepSDKs[],$attachers[],$eyeGeos[];
string $lipRibbonJoints[],$tackOnCtrls[],$ctrls[],$controls[];
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
//if (`attributeExists RigType FaceFitSkeleton`)
//	$rigTypeInt=`getAttr FaceFitSkeleton.RigType`;
//only use $keepJoints and not $rigTypeInt (asKeepJointsCheckBox switched On by asFaceFinish() in case of Build
if (`attributeExists GameEngine FaceFitSkeleton`)
	$gameEngine=`getAttr FaceFitSkeleton.GameEngine`;
if ($keepJoints && !$gameEngine)
	$useSkinLayers=1;

tokenize $upperTeeth $tempString;
for ($i=0;$i<size($tempString);$i++)
	$upperTeethObjs[$i]=$tempString[$i];
tokenize $lowerTeeth $tempString;
for ($i=0;$i<size($tempString);$i++)
	$lowerTeethObjs[$i]=$tempString[$i];

if ($useSkinLayers)
	asVersionRequirementCheck face 5.791;

if (`objExists asFaceBS`)
	error "Already converted to BlendShapes.";
if (`attributeExists convertedToBlendShapes asFaceBS`)
	error ("Already converted to blendShapes, using a older version of AdvancedSkeleton");
//if ($opm && $keepJoints)
//	error ("OffsetParentMatrix FaceSetup detected, this can not be converted to BS with \"keep joints\"(Mixed Mode)");

select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
sets -n allBeforeConvertToBS;
select -cl;

if ($autoKeyState)
	autoKeyframe -state 0;

if (!`attributeExists RigType FaceFitSkeleton`)
	asFaceUpdateInfo 0;//adds the RigType attr

catchQuiet (`setAttr FaceFitSkeleton.RigType (1+$keepJoints)`);//catchQuiet since old version rigs have only 2 options
asFaceUpdateInfo 1;//stores the new value

if ($useSkinLayers)
	{
	//`move` skinCluster to a skinLayer
	setAttr -l 0 FaceDeformationSystem.v;
	setAttr FaceDeformationSystem.v 1;	
	$tempString=`listRelatives -c -type transform FaceDeformationSystem`;
	for ($i=0;$i<size($tempString);$i++)
		{
		setAttr ($tempString[$i]+".v") 0;
		setAttr -l 1 ($tempString[$i]+".v");
		}
	parent FaceJoint_M FaceDeformationSystem;
	setAttr -l 0 FaceJoint_M.v;
	if (`attributeExists jointVis Main`)
		connectAttr Main.jointVis FaceJoint_M.v;
	//some joints to still follow head
//	parent EyeJoint_R EyeJoint_L upperTeethJoint_M lowerTeethJoint_M $headJoint;
	createNode -n DeformationLayers -p FaceDeformationSystem transform;
	createNode -n TemplateLayer -p DeformationLayers transform;
	createNode -n FaceJointsLayer -p DeformationLayers transform;
	setAttr TemplateLayer.v 0;
	setAttr FaceJointsLayer.v 0;
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
//		if ($allFaceGeo[$i]==$geometry)
//			$layerSuffix="";
//		else
		$layerSuffix="_"+`substitute ":" $allFaceGeo[$i] "_"`;
		$asFaceBS="asFaceBS"+$layerSuffix;
		if ($allFaceGeo[$i]==$geometry)
			$asFaceBS="asFaceBS";
		$sc=`asGetSkinCluster $allFaceGeo[$i]`;

		duplicate -n ("TemplateLayer"+$layerSuffix) $allFaceGeo[$i];
		asLockAttr ("TemplateLayer"+$layerSuffix) 0 0 0 0;
		parent ("TemplateLayer"+$layerSuffix) TemplateLayer;
		sets -e -forceElement initialShadingGroup ("TemplateLayer"+$layerSuffix);
		$tempString=`listRelatives -c -type transform ("TemplateLayer"+$layerSuffix)`;//delete any child, to avoid double geo
		for ($y=0;$y<size($tempString);$y++)
			delete $tempString[$y];
		$tempString=`listRelatives -s -f ("TemplateLayer"+$layerSuffix)`; 
		for ($y=0;$y<size($tempString);$y++)
			if (`getAttr ($tempString[$y]+".intermediateObject")`)
				delete $tempString[$y];
		$tempString=`listRelatives -s -f ("TemplateLayer"+$layerSuffix)`; 
		for ($y=0;$y<size($tempString);$y++)
			$tempString2=`listConnections -s 0 -d 1 -p 1 -c 1 -type objectSet $tempString[$y]`;
				for ($z=0;$z<size($tempString2);$z=$z+2)
					if (`gmatch $tempString2[($z+1)] "*Area[.]*"`)
						disconnectAttr $tempString2[$z] $tempString2[($z+1)];
		duplicate -n ("FaceJointsLayer"+$layerSuffix) ("TemplateLayer"+$layerSuffix);
		parent ("FaceJointsLayer"+$layerSuffix) FaceJointsLayer;
		select `listConnections -s 1 -d 0 -type joint ($sc+".matrix")`;
		select -add ("FaceJointsLayer"+$layerSuffix);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ("FaceJointsLayer"+$layerSuffix+"SC");
		select $allFaceGeo[$i] ("FaceJointsLayer"+$layerSuffix);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

		//Ensure FaceJointsLayer only bound to FaceJoints (not head or neck joint)
		$skinClusterJoints=`listConnections ("FaceJointsLayer"+$layerSuffix+"SC.matrix")`;
		for ($y=0;$y<size($skinClusterJoints);$y++)
			setAttr ($skinClusterJoints[$y]+".lockInfluenceWeights") (`sets -im FaceAllSet $skinClusterJoints[$y]`);
		if (`objExists upperFaceJoint_M`)//upMidLo on separate layer
			for ($a=0;$a<size($upperMiddleLower);$a++)
				setAttr ($upperMiddleLower[$a]+"FaceJoint_M.liw") 0;
		skinCluster -e -dr 4 -lw false -wt 0 -ai FaceJoint_M ("FaceJointsLayer"+$layerSuffix+"SC");
		catchQuiet (`skinPercent -tv FaceJoint_M 1 ("FaceJointsLayer"+$layerSuffix+"SC") ("FaceJointsLayer"+$layerSuffix)`);
		if (`objExists upperFaceJoint_M`)
			for ($a=0;$a<size($upperMiddleLower);$a++)
				asRemoveInfluence ($upperMiddleLower[$a]+"Joint_M") ("FaceJointsLayer"+$layerSuffix+"SC");

		select $allFaceGeo[$i];
		asBlendShapeFrontOfChain $asFaceBS;

		select $allFaceGeo[$i];
		blendShape -e -tc 0 -t $allFaceGeo[$i] `getAttr -s ($asFaceBS+".w")` ("FaceJointsLayer"+$layerSuffix) 1 $asFaceBS;
		if ($layerSuffix!="")
			aliasAttr FaceJointsLayer ($asFaceBS+".w[0]");
//		setAttr ($asFaceBS+".FaceJointsLayer") 1;
		}
	//upMidLo as layer
	if (`objExists upperSideReverse_R`)
		asFaceCreateSkinLayer UpMidLo;
	}
else
	{
	select $geometry;
	asBlendShapeFrontOfChain asFaceBS;
	}

$tempString=`listRelatives -c -type transform ctrlBox`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -c -type transform $tempString[$i]`;
	if ($tempString2[0]!="")
		$objs[size($objs)]=$tempString2[0];
	}

if ($limitsStatus)
	setAttr ctrlBox.limits 0;

//BlendShape for face+eyeBrow+EyeLash+Extras, not eyeBall
select $geometry;
if ($eyeBrow!="") eval ("select -add "+$eyeBrow);
if ($eyeLash!="") eval ("select -add "+$eyeLash);
if ($extras!="") eval ("select -add "+$extras);
if (!$keepJoints) //BlendShape for Teeth & Tongue only for rig-type "BlendShape", not "Mixed"
	{
	if ($upperTeeth!="") eval ("select -add "+$upperTeeth);
	if ($lowerTeeth!="") eval ("select -add "+$lowerTeeth);
	if ($tongue!="") eval ("select -add "+$tongue);
	}
$geos=`ls -sl -o`;
for ($a=0;$a<size($geos);$a++)
	if (`objectType $geos[$a]`=="mesh")
		{
		$tempString=`listRelatives -p $geos[$a]`;
		$geos[$a]=$tempString[0];
		}
$geos=`stringArrayRemoveDuplicates $geos`;

asGoToBuildPose faceSetup;

//Disable any deltaMush
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="deltaMush" || `objectType $tempString[$y]`=="blendShape")
		{
		$cmd+="setAttr "+$tempString[$y]+".envelope "+`getAttr ($tempString[$y]+".envelope")`+";";
		setAttr ($tempString[$y]+".envelope") 0;
		}

select -cl;
if (`objExists asBlendShapes`)
	move -r 0 ($cheekPos[0]*-2.5) 0 `listRelatives -c asBlendShapes`;
else
	createNode -n asBlendShapes transform;

progressBar -e -st "Converting to blendShapes" -bp -ii 1 -min 0 -max (size($objs)+1) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

$start=0;
$end=size($objs);
//$start=0;
//$end=0;
for ($i=$start;$i<$end;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	$numChar=size($objs[$i]);
	$side=`substring $objs[$i] ($numChar-1) 99`;
	$sideLessObj=`substring $objs[$i] 1 ($numChar-2)`;

	clear $attrs;
	$attrs=`listAttr -k $objs[$i]`;
	$udAttrs=`listAttr -ud $objs[$i]`;

	for ($y=0;$y<size($attrs);$y++)
		{
		if ($attrs[$y]=="visibility" || `getAttr -l ($objs[$i]+"."+$attrs[$y])` || $attrs[$y]=="jaw"  || $attrs[$y]=="lip")
			continue;
		for ($z=0;$z<size($values);$z++)
			{
			if ($values[$z]==1)  $posNeg="Pos";
			if ($values[$z]==-1) $posNeg="Neg";
			$posOnlyAttr=0;
			clear $softLimits;
			if (`stringArrayCount $attrs[$y] $udAttrs`)
				if (`attributeQuery -n $objs[$i] -softMinExists $attrs[$y]`)
					{
					$softLimits=`attributeQuery -n $objs[$i] -softMin $attrs[$y]`;
					if ($softLimits[0]!=-10)
						$posOnlyAttr=1;
					}

			if ($posOnlyAttr)
				{
				if ($values[$z]==1)
					$posNeg="";
				if ($values[$z]==-1)
					continue;
				}

			$transformLimits=`transformLimits -q -ty $objs[$i]`;
			if ($attrs[$y]=="translateY" && $values[$z]==-1 && $transformLimits[0]==0)
				continue;
//removed to allow for more neg values e.g. ctrlLips_M.upperPress == -10
//			if ($attrs[$y]!="translateX" && $attrs[$y]!="translateY" && $attrs[$y]!="rotateX" && $attrs[$y]!="rotateY" && $objs[$i]!="ctrlMouth_M" && $values[$z]==-1)
//				continue;

			$sideFactor=1;
			if ($side=="_L")
				{
				$sideFactor=-1;
				$sideStepLeftNr++;
				$sideStepNr=$sideStepLeftNr;
				}
			else
				{
				$sideStepRightNr++;
				$sideStepNr=$sideStepRightNr;
				}

			$name=$sideLessObj+$attrs[$y]+$posNeg+$side;//non-spsified attrs e.g txPos_tyPos 

			if ($sideLessObj=="ctrlBrow")
				{
				if ($attrs[$y]=="translateX" && $values[$z]==1)  $name="brow_innerRaiser"+$side;
				if ($attrs[$y]=="translateX" && $values[$z]==-1) $name="brow_innerlower"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==1)  $name="brow_raiser"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==-1)  $name="brow_lower"+$side;
				if ($attrs[$y]=="squeeze" && $values[$z]==1)  $name="brow_squeeze"+$side;
				if ($attrs[$y]=="outerUpDown" && $values[$z]==1)  $name="brow_outerUpDown"+$side;
				}
			if ($sideLessObj=="ctrlCheek")
				{
				if ($attrs[$y]=="translateX" && $values[$z]==1)  $name="cheek_out"+$side;
				if ($attrs[$y]=="translateX" && $values[$z]==-1) $name="cheek_in"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==1)  $name="cheek_raiser"+$side;
				}
			if ($sideLessObj=="ctrlNose")
				{
				if ($attrs[$y]=="translateX" && $values[$z]==1)  $name="nose_wide"+$side;
				if ($attrs[$y]=="translateX" && $values[$z]==-1) $name="nose_narrow"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==1)  $name="nose_raiser"+$side;
				}
			if ($sideLessObj=="ctrlMouthCorner")
				{
				if ($attrs[$y]=="translateX" && $values[$z]==1)  $name="mouth_wide"+$side;
				if ($attrs[$y]=="translateX" && $values[$z]==-1) $name="mouth_narrow"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==1)  $name="mouth_raiser"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==-1) $name="mouth_lower"+$side;
				if ($attrs[$y]=="txPos_tyPos" && $values[$z]==1) $name="mouth_smileBulge"+$side;
				if ($attrs[$y]=="txPos_tyNeg" && $values[$z]==1) $name="mouth_frownBulge"+$side;
				}
			if ($sideLessObj=="ctrlEye")
				{
				if ($attrs[$y]=="iris" || $attrs[$y]=="pupil")
					continue;
				if (($attrs[$y]=="translateX" || $attrs[$y]=="translateY") && $keepJoints)
					continue;//FleshyEyes not coverted to BS when using "Mixed" rig-type
				if ($attrs[$y]=="translateX" && $values[$z]==1)  $name="eye_left"+$side;
				if ($attrs[$y]=="translateX" && $values[$z]==-1)  $name="eye_right"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==1)  $name="eye_up"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==-1)  $name="eye_down"+$side;
				if ($attrs[$y]=="blink" && $values[$z]==1)  $name="blink"+$side;
				if ($attrs[$y]=="squint" && $values[$z]==1)  $name="squint"+$side;
				}
			if ($objs[$i]=="ctrlLips_M")
				{
				if ($attrs[$y]=="translateX" && $values[$z]==1)  $name="lip_left"+$side;
				if ($attrs[$y]=="translateX" && $values[$z]==-1)  $name="lip_right"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==1)  $name="lip_up"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==-1)  $name="lip_down"+$side;
				if (`stringArrayCount $attrs[$y] $udAttrs`)
					$name="lip_"+$attrs[$y]+$posNeg+$side;
				}
			if ($objs[$i]=="ctrlMouth_M")
				{
				if ($attrs[$y]=="translateX" && $values[$z]==1)  $name="mouth_wide"+$side;
				if ($attrs[$y]=="translateX" && $values[$z]==-1) $name="mouth_narrow"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==1)  $name="mouth_close"+$side;
				if ($attrs[$y]=="translateY" && $values[$z]==-1) $name="mouth_open"+$side;
				if ($attrs[$y]!="translateX" && $attrs[$y]!="translateY")
					{
					if ($values[$z]==1) $inOut="In";
					if ($values[$z]==-1) $inOut="Out";
					$name="mouth_"+$attrs[$y]+$inOut+$side;
					}
				}
			if ($objs[$i]=="ctrlPhonemes_M" || $objs[$i]=="ctrlEmotions_M")
				$name=$attrs[$y]+$side;
			if ($objs[$i]=="ctrlARKit_M")
				$name=$attrs[$y];

			for ($a=0;$a<size($geos);$a++)
				{
				if ($a==0)
					$asFaceBS="asFaceBS";
				else
					$asFaceBS="asFaceBS_"+`substituteAllString $geos[$a] ":" "_"`;

				if (!`objExists $asFaceBS`)
					{
					select $geos[$a];
//					blendShape -n $asFaceBS -frontOfChain;
					asBlendShapeFrontOfChain $asFaceBS;
					}
				if ($attrs[$y]=="translateX" || $attrs[$y]=="translateY" || `asFaceIsBlendedAttr $objs[$i] $attrs[$y]`)
					$drivingValue=$values[$z];
				else if ($attrs[$y]=="rotateX" || $attrs[$y]=="rotateY")
					$drivingValue=30*$values[$z];
				else if ($values[$z]==1)
					$drivingValue=10;
				else if ($values[$z]==-1)
					$drivingValue=-10;

				if (`asFaceIsBlendedAttr $objs[$i] $attrs[$y]`)
					asSetBlendedAttribute $objs[$i] $attrs[$y] 1 0;
				else
					setAttr ($objs[$i]+"."+$attrs[$y]) $drivingValue;
				refresh;

				if (`objExists $name`)
					rename $name tempRenamingBlendShapeTarget;
//				duplicate -n $name $geos[$a];
				//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
				$tempString[0]=`createNode mesh`;
				$tempString=`listRelatives -p $tempString[0]`;
				rename $tempString[0] $name;
				connectAttr ($geos[$a]+".outMesh") ($name+".inMesh");
				sets -e -forceElement initialShadingGroup $name;
				refresh;
				disconnectAttr ($geos[$a]+".outMesh") ($name+".inMesh");

				parent $name asBlendShapes;
				blendShape -e -tc 0 -t $geos[$a] `getAttr -s ($asFaceBS+".w")` $name 1 $asFaceBS;
				if ($keepBSTarget)
					{
					$targetName=$name;
					if ($a>0)
						{
						$targetName=$name+"_"+`substituteAllString $geos[$a] ":" "_"`;
						rename $name $targetName;
						}
					if (`objExists tempRenamingBlendShapeTarget`)
						rename tempRenamingBlendShapeTarget $name;
					asLockAttr $targetName 0 0 0 0;
					move -r ($cheekPos[0]*2.5*$sideFactor*$sideStepNr) 0 0 $targetName;
					}

				if (`asFaceIsBlendedAttr $objs[$i] $attrs[$y]`)
					asSetBlendedAttribute $objs[$i] $attrs[$y] 0 0;
				else
					setAttr ($objs[$i]+"."+$attrs[$y]) 0;

				setDrivenKeyframe -itt linear -ott linear -dv 0 -v 0 -currentDriver ($objs[$i]+"."+$attrs[$y]) ($asFaceBS+"."+$name);
				setDrivenKeyframe -itt linear -ott linear -dv $drivingValue -v 1 -currentDriver ($objs[$i]+"."+$attrs[$y]) ($asFaceBS+"."+$name);
				setAttr ($asFaceBS+"_"+$name+".preInfinity") 4;
				setAttr ($asFaceBS+"_"+$name+".postInfinity") 4;
				if ($attrs[$y]=="translateX" || $attrs[$y]=="translateY" || `asFaceIsBlendedAttr $objs[$i] $attrs[$y]` || $softLimits[0]<0)
					{
					if ($values[$z]>0)
						setAttr ($asFaceBS+"_"+$name+".preInfinity") 1; // no neg weight when drive<0
					else
						setAttr ($asFaceBS+"_"+$name+".postInfinity") 0; // no neg weight when drive>0
					}

//				if ($attrs[$y]=="translateX" && `attributeExists txMixed $objs[$i]`) connectAttr -f ($objs[$i]+".txMixed") ($asFaceBS+"_"+$name+".input");
//				if ($attrs[$y]=="translateY" && `attributeExists tyMixed $objs[$i]`) connectAttr -f ($objs[$i]+".tyMixed") ($asFaceBS+"_"+$name+".input");
				if (`gmatch $objs[$i] "ctrlMouthCorner_*"`)
					connectAttr -f ("bwctrlMouthCorner"+$side+"_"+$attrs[$y]+".output") ($asFaceBS+"_"+$name+".input");

				if (!$keepBSTarget)
					delete $name;
				}
			}
		}
	}

if ($limitsStatus)
	setAttr ctrlBox.limits 1;


//reorderDeformers "asFaceBS" $skinCluster $geometry;

$keepSDKs={"SDKEye_*","SDKIris_*","SDKPupil_*"};

if ($keepJoints)
	{
	//new JawOpenSDK to drive tongue & lowerTeeth
	setAttr ctrlMouth_M.ty -1;
	if (`objExists lowerTeethFollow_M`)
		{
		$pos=`getAttr lowerTeethFollow_M.t`;
		$rot=`getAttr lowerTeethFollow_M.r`;
		if ($opm)
			{
			$tempString=`listRelatives -p lowerTeethFollow_M`;
			createNode -n tempMatrixTransform -p lowerTeethFollow_M transform;
			parent tempMatrixTransform $tempString[0];
			$pos=`getAttr tempMatrixTransform.t`;
			$rot=`getAttr tempMatrixTransform.r`;
			delete tempMatrixTransform;
			}
		}
	if (`objExists Tongue0Follow_M`)
		{
		$pos2=`getAttr Tongue0Follow_M.t`;
		$rot2=`getAttr Tongue0Follow_M.r`;
		if ($opm)
			{
			$tempString=`listRelatives -p Tongue0Follow_M`;
			createNode -n tempMatrixTransform -p Tongue0Follow_M transform;
			parent tempMatrixTransform $tempString[0];
			$pos2=`getAttr tempMatrixTransform.t`;
			$rot2=`getAttr tempMatrixTransform.r`;
			delete tempMatrixTransform;
			}
		}
	setAttr ctrlMouth_M.ty 0;
	dgdirty -a;
	refresh;

	$tempString=`ls -type blendWeighted "bwSDK*_*_*"`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$keep=0;
		if (!`sets -im FaceAllSet $tempString[$i]`) $keep=1;
		for ($y=0;$y<size($keepSDKs);$y++)
			if (`gmatch $tempString[$i] ("bw"+$keepSDKs[$y])`)
				$keep=1;
		if (!$keep) delete $tempString[$i];
		}

	$tempString=`ls -type animCurve "SDK*_*_*"`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$keep=0;
		if (!`sets -im FaceAllSet $tempString[$i]`) $keep=1;
		for ($y=0;$y<size($keepSDKs);$y++)
			if (`gmatch $tempString[$i] $keepSDKs[$y]`)
				$keep=1;
		if (!$keep) delete $tempString[$i];
		}

	//remove lipRoller & lipPucker
	$tempString=`ls "*LipJoint*_*RollPMA"`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im FaceAllSet $tempString[$i]`)
			delete $tempString[$i];

	//new JawOpenSDK to drive tongue & lowerTeeth
	if (`objExists SDKlowerTeeth_M` && !`gmatch $tongue ($geometry+"[.]*")`)
		{
		for ($z=1;$z<size($xyz);$z++)
			{
			setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd bwctrlMouth_M_translateY.output ("SDKlowerTeeth_M.t"+$xyz[$z]);
			setDrivenKeyframe -itt "linear" -ott "linear" -v $pos[$z] -dv -1 -cd bwctrlMouth_M_translateY.output ("SDKlowerTeeth_M.t"+$xyz[$z]);
			setAttr ("SDKlowerTeeth_M_translate"+$XYZ[$z]+".preInfinity") 4;
			setAttr ("SDKlowerTeeth_M_translate"+$XYZ[$z]+".postInfinity") 4;
			}
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd bwctrlMouth_M_translateY.output SDKlowerTeeth_M.rx;
		setDrivenKeyframe -itt "linear" -ott "linear" -v $rot[0] -dv -1 -cd bwctrlMouth_M_translateY.output SDKlowerTeeth_M.rx;
		setAttr ("SDKlowerTeeth_M_rotateX.preInfinity") 4;
		setAttr ("SDKlowerTeeth_M_rotateX.postInfinity") 4;
		}
	if (`objExists SDKTongue0_M` && !`gmatch $tongue ($geometry+"[.]*")`)
		{
		for ($z=0;$z<size($xyz)-1;$z++)
			{
			setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd bwctrlMouth_M_translateY.output ("SDKTongue0_M.t"+$xyz[$z]);
			setDrivenKeyframe -itt "linear" -ott "linear" -v $pos2[$z] -dv -1 -cd bwctrlMouth_M_translateY.output ("SDKTongue0_M.t"+$xyz[$z]);
			setAttr ("SDKTongue0_M_translate"+$XYZ[$z]+".preInfinity") 4;
			setAttr ("SDKTongue0_M_translate"+$XYZ[$z]+".postInfinity") 4;
			}
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd bwctrlMouth_M_translateY.output SDKTongue0_M.rz;
		setDrivenKeyframe -itt "linear" -ott "linear" -v $rot2[2] -dv -1 -cd bwctrlMouth_M_translateY.output SDKTongue0_M.rz;
		setAttr ("SDKTongue0_M_rotateZ.preInfinity") 4;
		setAttr ("SDKTongue0_M_rotateZ.postInfinity") 4;
		}

	//avoid double blink
	delete bwctrlEye_R_blink bwctrlEye_L_blink;
	}

if (!$keepJoints)
	{
	//skinweight to headJoint
	for ($i=$start;$i<$end;$i++)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$numChar=size($objs[$i]);
		$side=`substring $objs[$i] ($numChar-1) 99`;
		$sideLessObj=`substring $objs[$i] 1 ($numChar-2)`;

		for ($a=0;$a<size($geos);$a++)
			{
			if ($geos[$a]==$geometry)
				continue;
			$sc="";
			$historyNodes=`listHistory -pdo 1 -il 2 $geos[$a]`;
			for ($z=0;$z<size($historyNodes);$z++)
				if (`nodeType $historyNodes[$z]`=="skinCluster")
					$sc=$historyNodes[$z];

			catchQuiet (`skinPercent -tv $headJoint 1 $sc $geos[$a]`);
			select $geos[$a];
	//		removeUnusedInfluences;
			removeUnusedForSkin $sc 0;
			}
		}

	//remove joints
	$tempString=`listConnections ($skinCluster+".matrix")`;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($tempString[$i]+".liw") 1;
	setAttr ($headJoint+".lockInfluenceWeights") 0;
//	$keepingJoints={"EyeJoint_R","EyeJoint_L","Tongue0Joint_M","upperTeethJoint_M","lowerTeethJoint_M"};
	$keepingJoints={"EyeJoint_R","EyeJoint_L"};
	$tempString=`listRelatives -c -type joint FaceJoint_M`;
	for ($i=0;$i<size($tempString);$i++)
		if (!`stringArrayCount $tempString[$i] $keepingJoints`)
			delete $tempString[$i];
	skinPercent -tv $headJoint 1 $skinCluster $geometry;
	$tempString=`listConnections ($skinCluster+".matrix")`;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($tempString[$i]+".liw") 0;

	//remove controls
//	$keepControls={"upperTeethOffset_M","lowerTeethOffset_M","Tongue0Offset_M","JawOffset_M","JawFollow_M","JawStatic_M","EyeOffset_R","EyeOffset_L"};
	$keepControls={"EyeOffset_R","EyeOffset_L"};
	$tempString=`listRelatives -c -type transform SideReverse_R SideReverse_L SideReverse_M`;
	if (`objExists upperFace_M`)
		{
		$tempString2=`listRelatives -c -type transform upperSideReverse_R upperSideReverse_L upperSideReverse_M`;
		$tempString3=`listRelatives -c -type transform middleSideReverse_R middleSideReverse_L middleSideReverse_M`;
		$tempString4=`listRelatives -c -type transform lowerSideReverse_R lowerSideReverse_L lowerSideReverse_M`;
		$tempString=`stringArrayCatenate $tempString $tempString2`;
		$tempString=`stringArrayCatenate $tempString $tempString3`;
		$tempString=`stringArrayCatenate $tempString $tempString4`;
		setAttr ctrlBox.UpMidLoCtrlVis 0;
		}
	for ($i=0;$i<size($tempString);$i++)
		if (!`stringArrayCount $tempString[$i] $keepControls`)
			if (`objExists $tempString[$i]`)
				delete $tempString[$i];
//	setAttr -l 1 JawOffset_M.v 0;
	}

//Emotions to only drive new emotions BS targets, not mix of non-emo targets (except jaw-joint)
clear $tempString;
if (`objExists ctrlEmotions_M`)
	$tempString=`listConnections -s 0 -d 1 -type blendWeighted ctrlEmotions_M`;
if (`objExists ctrlARKit_M`)
	{
	$tempString2=`listConnections -s 0 -d 1 -type blendWeighted ctrlARKit_M`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		if (`gmatch $tempString2[$y] "bwctrlARKit_M_eyeLook*"`)
			continue;
		if ($tempString2[$y]=="bwctrlARKit_M_tongueOut")
			continue;
		$tempString[size($tempString)]=$tempString2[$y];
		}
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 0 -d 1 -type animCurve $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		if (`sets -im FaceAllSet $tempString2[$y]`)
			if (!`gmatch $tempString2[$y] "bwctrlMouth_M_translateY*"`)
				delete $tempString2[$y];
		}
	}

if (!$useSkinLayers)
	{
	$tempString=`listRelatives -c -type transform FaceDeformationSystem`;
	for ($i=0;$i<size($tempString);$i++)
		if ($tempString[$i]!="EyeSetup")
			delete $tempString[$i];
	}

if ($useSkinLayers)
	{
	//main skinCluster tp be bound to HeadJoint and no faceJoints
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		$layerSuffix="_"+`substitute ":" $allFaceGeo[$i] "_"`;
		$asFaceBS="asFaceBS"+$layerSuffix;
		if ($allFaceGeo[$i]==$geometry)
			$asFaceBS="asFaceBS";
		$sc=`asGetSkinCluster $allFaceGeo[$i]`;

		$tempString=`listConnections ($sc+".matrix")`;
		for ($y=0;$y<size($tempString);$y++)
			setAttr ($tempString[$y]+".liw") (!`sets -im FaceAllSet $tempString[$y]`);
		setAttr ($headJoint+".liw") 0;
		catchQuiet (`skinPercent -tv $headJoint 1 $sc $allFaceGeo[$i]`);
		removeUnusedForSkin $sc 0;

		setAttr ($asFaceBS+".FaceJointsLayer") 1;
		}

	//older versions used point+orient, newer used parent
	if (`objExists FaceDeformationFollowHead_pointConstraint1`)  delete FaceDeformationFollowHead_pointConstraint1;
	if (`objExists FaceDeformationFollowHead_orientConstraint1`) delete FaceDeformationFollowHead_orientConstraint1;
	if (`objExists FaceDeformationFollowHead_parentConstraint1`) delete FaceDeformationFollowHead_parentConstraint1;
	
	if (`isConnected MainAndHeadScaleMultiplyDivide.output FaceDeformationFollowHead.scale`)
		disconnectAttr MainAndHeadScaleMultiplyDivide.output FaceDeformationFollowHead.scale;

	//OnFacecontrolsLayered
	createNode -n FaceMotionSystemStatic -p FaceGroup transform;
	reorder -relative -1 FaceMotionSystemStatic;
	parent OnFacecontrols FaceMotionSystemStatic;
	createNode -n OnFacecontrolsLayered -p OnFacecontrols transform;
	parent OnFacecontrolsLayered ControlsSetup;
	parent ConstrainedSetup FaceMotionSystemStatic;
	createNode -n SideReverseLayered_R -p OnFacecontrolsLayered transform;
	createNode -n SideReverseLayered_L -p OnFacecontrolsLayered transform;
	createNode -n SideReverseLayered_M -p OnFacecontrolsLayered transform;
	setAttr SideReverseLayered_R.sx -1;

	//Non-Spherical eye ?
	$tempString={"EyeLattice2_R_parentConstraint1","EyeLattice2_R_scaleConstraint1","EyeLattice2_L_parentConstraint1","EyeLattice2_L_scaleConstraint1"};
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists $tempString[$i]`)
			delete $tempString[$i];
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) {$side="_R";$eyeGeoText=$rightEye;}
		else {$side="_L";$eyeGeoText=$leftEye;}

		if (!`objExists "squashEyeFfd1Set_R"`)
			continue;
		clear $eyeGeos;
		tokenize $eyeGeoText $tempString;
		for ($i=0;$i<size($tempString);$i++)
			if ($tempString[$i]!="" && !`gmatch $tempString[$i] "*[.]*"`)
				$eyeGeos[size($eyeGeos)]=$tempString[$i];
		for ($i=0;$i<size($eyeGeos);$i++)
			{
			sets -rm ("squashEyeFfd1Set"+$side) $eyeGeos[$i];
			sets -rm ("squashEyeFfd2Set"+$side) $eyeGeos[$i];
			sets -add ("squashEyeFfd1Set"+$side) ("FaceJointsLayer_"+$eyeGeos[$i]);
			reorderDeformers ("FaceJointsLayer_"+$eyeGeos[$i]+"SC") ("squashEyeFfd1"+$side) ("FaceJointsLayer_"+$eyeGeos[$i]);
			sets -add ("squashEyeFfd2Set"+$side) ("FaceJointsLayer_"+$eyeGeos[$i]);
			}
		}

	//upMidLo as layer
	if (`objExists upperSideReverse_R`)
		{
		parent EyeOffset_R EyeOffset_L EyeControls;
		for ($a=0;$a<size($upperMiddleLower);$a++)
			for ($b=0;$b<3;$b++)
				{
				if ($b==0) $side="_R";
				if ($b==1) $side="_L";
				if ($b==2) $side="_M";

				parent `listRelatives -c -type transform ($upperMiddleLower[$a]+"SideReverse"+$side)` ("SideReverse"+$side);
				delete ($upperMiddleLower[$a]+"SideReverse"+$side);
				}
		//UpMidLoLayer
		asShowLayer UpMidLo;
		$tempString=`listRelatives -c -type transform UpMidLoLayer`;
		for ($i=0;$i<size($tempString);$i++)
			{
			select upperFaceJoint_M middleFaceJoint_M lowerFaceJoint_M $tempString[$i];
			$tempString2=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString2[0] ($tempString[$i]+"SC");
			skinPercent -tv middleFaceJoint_M 1 ($tempString[$i]+"SC") $tempString[$i];
			}

		$posA=`xform -q -ws -t upperFace_M`;
		$upMidLoLayerGeometry="UpMidLoLayer_"+`substitute ":" $geometry "_"`;
		select  $upMidLoLayerGeometry;
		polySelectConstraint -m 3 -t 1 -d 3 -db $posA[1] 9999 -da 0 1 0 -dp 0 0 0;
		skinPercent -tv upperFaceJoint_M 1 ($upMidLoLayerGeometry+"SC");
		$posA=`xform -q -ws -t lowerFace_M`;
		polySelectConstraint -m 3 -t 1 -d 3 -db 0 $posA[1] -da 0 1 0 -dp 0 0 0;
		skinPercent -tv lowerFaceJoint_M 1 ($upMidLoLayerGeometry+"SC");
		polySelectConstraint -m 0;
		select $upMidLoLayerGeometry;
		asSmoothFlood upperFaceJoint_M middleFaceJoint_M 10;
		asSmoothFlood lowerFaceJoint_M middleFaceJoint_M 10;

		for ($i=0;$i<size($tempString);$i++)
			{
			if ($tempString[$i]==$upMidLoLayerGeometry)
				continue;
			select $upMidLoLayerGeometry $tempString[$i];
			copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
			}

		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) {$side="_R";$eyeGeoText=$rightEye;}
			else {$side="_L";$eyeGeoText=$leftEye;}

			if (!`objExists "squashEyeFfd1Set_R"`)
				continue;
			clear $eyeGeos;
			tokenize $eyeGeoText $tempString;
			for ($i=0;$i<size($tempString);$i++)
				if ($tempString[$i]!="" && !`gmatch $tempString[$i] "*[.]*"`)
					$eyeGeos[size($eyeGeos)]=$tempString[$i];
			for ($i=0;$i<size($eyeGeos);$i++)
				{
				$upMidLoLayerEye="UpMidLoLayer_"+`substitute ":" $eyeGeos[$i] "_"`;
				select $upMidLoLayerEye;
				skinPercent -tv upperFaceJoint_M 1 ($upMidLoLayerEye+"SC");
				}
			}

		asShowLayer Normal;
		}

	//tongue space re-orient, part1
	if (`objExists Tongue0`)
		{
		$ctrls={"Tongue0","Tongue1","Tongue2","Tongue3","lowerTeeth"};
		$side="_M";
		for ($a=0;$a<size($ctrls);$a++)
			{
			createNode -n ($ctrls[$a]+"OffsetLayered"+$side) -p ($ctrls[$a]+"Joint"+$side) transform;
			if ($a==0)
				{
				parent ($ctrls[$a]+"OffsetLayered"+$side) ("SideReverse"+$side);
				}
			else
				parent ($ctrls[$a]+"OffsetLayered"+$side) ($ctrls[$a-1]+"Layered"+$side);
			setAttr ($ctrls[$a]+"OffsetLayered"+$side+".s") -type float3 1 1 1;
			createNode -n ($ctrls[$a]+"Layered"+$side) -p ($ctrls[$a]+"OffsetLayered"+$side) transform;
			}
		parent lowerTeethOffsetLayered_M ("SideReverse"+$side);
		}

	$ctrls={"Eye","Iris","Pupil","Jaw","upperTeeth","lowerTeeth","Tongue0","Tongue1","Tongue2","Tongue3"};
	for ($a=0;$a<size($ctrls);$a++)
		{
		for ($b=0;$b<3;$b++)
			{
			if ($b==0) $side="_R";
			if ($b==1) $side="_L";
			if ($b==2) $side="_M";

			if (!`objExists ($ctrls[$a]+"Joint"+$side)`)
				continue;
			$tempString=`listRelatives -p ($ctrls[$a]+"Offset"+$side)`;
			$scaledCtrl=0;
			if (`gmatch $tempString[0] "SideReverse_*"`)
				{
				parent ($ctrls[$a]+"Offset"+$side) ("SideReverseLayered"+$side);
				$scaledCtrl=1;
				createNode -n ($ctrls[$a]+"ScaledMPD"+$side) multiplyDivide;
				setAttr ($ctrls[$a]+"ScaledMPD"+$side+".input2") -type float3 $ctrlScale $ctrlScale $ctrlScale;
				}
			if ($opm)
				asDisconnectOPMAttr ($ctrls[$a]+"Joint"+$side) 0;
			else
				{
				$tempString=`listConnections -s 1 -d 0 -type constraint ($ctrls[$a]+"Joint"+$side)`;
				if (size($tempString))
					delete $tempString;
				}

			$target=$ctrls[$a]+"Joint";
			if (`gmatch $ctrls[$a] "Tongue*"` || $ctrls[$a]=="lowerTeeth")
				$target=$ctrls[$a]+"Layered";

			for ($i=0;$i<size($trs);$i++)
				{
				createNode -n ($ctrls[$a]+$side+"_"+$trs[$i]) plusMinusAverage;
				if ($trs[$i]=="s")
					setAttr ($ctrls[$a]+$side+"_"+$trs[$i]+".operation") 3;
				$pos=`getAttr ($ctrls[$a]+"Joint"+$side+"."+$trs[$i])`;
				if ($opm)
					if ($ctrls[$a]=="lowerTeeth" || $ctrls[$a]=="Tongue0")
//						if ($trs[$i]=="t")
							{
							$tempString=`listRelatives -p ($ctrls[$a]+"Joint"+$side)`;
							createNode -n tempMatrixTransform -p ($ctrls[$a]+"Joint"+$side) transform;
							parent tempMatrixTransform $tempString[0];
							$pos=`getAttr ("tempMatrixTransform."+$trs[$i])`;
							delete tempMatrixTransform;
							}
				for ($z=0;$z<size($xyz);$z++)
					{
					setAttr ($ctrls[$a]+$side+"_"+$trs[$i]+".input3D[0].input3D"+$xyz[$z]) $pos[$z];
					connectAttr ($ctrls[$a]+$side+"."+$trs[$i]+$xyz[$z]) ($ctrls[$a]+$side+"_"+$trs[$i]+".input3D[1].input3D"+$xyz[$z]);
					//Changes, SDK not to be `just added`, needs separate xform, e.g Jaw-Open, will change what is Tx direction for tongue
					if ($ctrls[$a]=="lowerTeeth" || $ctrls[$a]=="Tongue0")
						{
						if (!`objExists ($ctrls[$a]+"SDKLayered"+$side)`)
							{
							createNode -n ($ctrls[$a]+"SDKLayered"+$side) -p ($ctrls[$a]+"OffsetLayered"+$side) transform;
							parent ($ctrls[$a]+"Layered"+$side) ($ctrls[$a]+"SDKLayered"+$side);
							}
						connectAttr ("SDK"+$ctrls[$a]+$side+"."+$trs[$i]+$xyz[$z]) ($ctrls[$a]+"SDKLayered"+$side+"."+$trs[$i]+$xyz[$z]);
						}
					else
						connectAttr ("SDK"+$ctrls[$a]+$side+"."+$trs[$i]+$xyz[$z]) ($ctrls[$a]+$side+"_"+$trs[$i]+".input3D[2].input3D"+$xyz[$z]);

					if (`objExists ($ctrls[$a]+"Aim"+$side)`)
						{
						if ($opm)
							{
							if ($i==0 && $z==0)
								{
								createNode -n ($ctrls[$a]+"AimDM"+$side) decomposeMatrix;
								setAttr ($ctrls[$a]+"AimDM"+$side+".inputRotateOrder") `getAttr ($ctrls[$a]+$side+".rotateOrder")`;
								connectAttr ($ctrls[$a]+"AimMM"+$side+".matrixSum") ($ctrls[$a]+"AimDM"+$side+".inputMatrix");
								}
							connectAttr ($ctrls[$a]+"AimDM"+$side+".output"+$trsLong[$i]+$XYZ[$z]) ($ctrls[$a]+$side+"_"+$trs[$i]+".input3D[3].input3D"+$xyz[$z]);
							connectAttr -f ($ctrls[$a]+"Offset"+$side+".worldInverseMatrix") ($ctrls[$a]+"JointMM"+$side+".matrixIn[1]");
							}
						else
							connectAttr ($ctrls[$a]+"Aim"+$side+"."+$trs[$i]+$xyz[$z]) ($ctrls[$a]+$side+"_"+$trs[$i]+".input3D[3].input3D"+$xyz[$z]);
						}
					if ($ctrls[$a]=="lowerTeeth" || $ctrls[$a]=="Tongue0")//follow jaw
						{
						if (!`objExists ($ctrls[$a]+"JawOffsetLayered"+$side)`)
							{
							createNode -n ($ctrls[$a]+"JawOffsetLayered"+$side) -p SideReverse_M transform;
							asAlign ($ctrls[$a]+"JawOffsetLayered"+$side) Jaw_M 1 1 0 0;
							createNode -n ($ctrls[$a]+"JawLayered"+$side) -p ($ctrls[$a]+"JawOffsetLayered"+$side) transform;
							connectAttr Jaw_M.t ($ctrls[$a]+"JawLayered"+$side+".t");
							connectAttr Jaw_M.r ($ctrls[$a]+"JawLayered"+$side+".r");
							parent ($ctrls[$a]+"OffsetLayered"+$side) ($ctrls[$a]+"JawLayered"+$side);
							}

						if ($opm)
							{
							if ($i==0 && $z==0)
								{
								createNode -n ($ctrls[$a]+"BMDM"+$side) decomposeMatrix;
								connectAttr ($ctrls[$a]+"BM"+$side+".outputMatrix") ($ctrls[$a]+"BMDM"+$side+".inputMatrix");
								asDisconnectOPMAttr ($ctrls[$a]+"Follow"+$side) 0;
								if ($ctrls[$a]=="lowerTeeth")
									{
									asDisconnectOPMAttr ($ctrls[$a]+"Joint"+$side) 1;
									}
								$m=`getAttr ($ctrls[$a]+"MMA_M.matrixIn[2]")`;
								$tempString=`listConnections -s 1 -d 0 -p 1 ($ctrls[$a]+"MMA_M.matrixIn[2]")`;
								disconnectAttr $tempString[0] ($ctrls[$a]+"MMA_M.matrixIn[2]");
								setAttr ($ctrls[$a]+"MMA_M.matrixIn[2]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
								}
							connectAttr ($ctrls[$a]+"BMDM"+$side+".output"+$trsLong[$i]+$XYZ[$z]) ($ctrls[$a]+"Follow"+$side+"."+$trs[$i]+$xyz[$z]);
							}
//						connectAttr ($ctrls[$a]+"Follow"+$side+"."+$trs[$i]+$xyz[$z]) ($ctrls[$a]+$side+"_"+$trs[$i]+".input3D[3].input3D"+$xyz[$z]);
						}
					connectAttr ($ctrls[$a]+$side+"_"+$trs[$i]+".output3D"+$xyz[$z]) ($target+$side+"."+$trs[$i]+$xyz[$z]);
					if ($scaledCtrl && $trs[$i]=="t")
						{
						setAttr ($ctrls[$a]+$side+"_"+$trs[$i]+".input3D[0].input3D"+$xyz[$z]) ($pos[$z]/$ctrlScale);
						connectAttr ($ctrls[$a]+$side+"_"+$trs[$i]+".output3D"+$xyz[$z]) ($ctrls[$a]+"ScaledMPD"+$side+".input1"+$XYZ[$z]);
						connectAttr -f ($ctrls[$a]+"ScaledMPD"+$side+".output"+$XYZ[$z]) ($target+$side+"."+$trs[$i]+$xyz[$z]);
						}
					}
				}
			if ($ctrls[$a]=="lowerTeeth")
				{
				if ($opm)
					delete `pointConstraint lowerTeeth_M lowerTeethJoint_M`;
				connectAttr -f lowerTeeth_M.scale lowerTeethJoint_M.scale;
				}
			}
		}

	//LipFollowHead setup change to local
	if (`objExists LipFollowHead_parentConstraint1`) delete LipFollowHead_parentConstraint1;
	if (`objExists LipFollowHead_scaleConstraint1`) delete LipFollowHead_scaleConstraint1;
	if (`isConnected MainAndHeadScaleMultiplyDivide.output LipFollowHead.scale`)
		disconnectAttr MainAndHeadScaleMultiplyDivide.output LipFollowHead.scale;
	if (`objExists LipFollowHeadMM_LipFollowHead`) delete LipFollowHeadMM_LipFollowHead;

	//JawFollow setup change to local
	$tempString=`listRelatives -c -type constraint JawFollow_R JawFollow_L JawFollow_M`;
	if (size($tempString))
		delete $tempString;
	parentConstraint -mo JawJoint_M JawFollow_R;scaleConstraint -mo JawJoint_M JawFollow_R;
	parentConstraint -mo JawJoint_M JawFollow_L;scaleConstraint -mo JawJoint_M JawFollow_L;
	parentConstraint -mo JawJoint_M JawFollow_M;scaleConstraint -mo JawJoint_M JawFollow_M;

	//tongue space re-orient, part1
	if (`objExists Tongue0`)
		{
		$ctrls={"Tongue0","Tongue1","Tongue2","Tongue3"};
		$side="_M";
		setAttr Tongue0ScaledMPD_M.input2 -type float3 1 1 1;
		if (size($lowerTeethObjs))
			{
			$ctrls[size($ctrls)]="lowerTeeth";
			setAttr lowerTeethScaledMPD_M.input2 -type float3 1 1 1;
			}
		for ($a=0;$a<size($ctrls);$a++)
			{
			setAttr ($ctrls[$a]+$side+"_t.input3D[0]") -type float3 0 0 0;
			setAttr ($ctrls[$a]+$side+"_r.input3D[0]") -type float3 0 0 0;
			pointConstraint -mo ($ctrls[$a]+"Layered"+$side) ($ctrls[$a]+"Joint"+$side);
			orientConstraint -mo ($ctrls[$a]+"Layered"+$side) ($ctrls[$a]+"Joint"+$side);
//			scaleConstraint -mo ($ctrls[$a]+"Layered"+$side) ($ctrls[$a]+"Joint"+$side);
			}
		}

	//SkinAttachCtrls
	createNode -n SkinAttachCtrls -p FaceDeformationSystem transform;
	setAttr SkinAttachCtrls.v 0;
	setAttr -l 1 SkinAttachCtrls.v;
	select `listRelatives -c -type joint FaceJoint_M`;
	select -d EyeLidJoints_M LipJoints_M;
	$tempString=`ls -sl`;
	select `listRelatives -ad -type joint LidJoints LipRibbonJoints`;
	select -d EyeRegionJoint_R EyeRegionJoint_L;
	$tempString2=`ls -sl`;
	$tempString=`stringArrayCatenate $tempString $tempString2`;
	$tempString=`stringArrayCatenate $tempString {"LipJoint_R","LipJoint_L","upperLip_M","lowerLip_M"}`;

	$tackOnCtrls={"EyeBrowRegion_R","EyeBrowRegion_L","EyeRegion_R","EyeRegion_L",
		"NoseRegion_M","LipRegion_M",
		"SmilePull_R","SmilePull_L",
		"upperLip_R","lowerLip_R","upperLip_L","lowerLip_L",
		"upperFace_M","middleFace_M","lowerFace_M"};
	for ($i=0;$i<size($tackOnCtrls);$i++)
		if (`objExists $tackOnCtrls[$i]`)
			$tempString[size($tempString)]=$tackOnCtrls[$i];

	$curveCmd="curve -d 1 -n AttacherCurve";
	clear $attachers;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="Tongue0Joint_M" || $tempString[$i]=="LipJoints_M" || $tempString[$i]=="JawJoint_M" || $tempString[$i]=="upperTeethJoint_M" || $tempString[$i]=="lowerTeethJoint_M")
			continue;
		if (`gmatch $tempString[$i] "EyeJoint_*"` || `gmatch $tempString[$i] "Tongue*Joint_M"`)
			continue;
		if ($tempString[$i]=="upperFaceJoint_M" || $tempString[$i]=="middleFaceJoint_M" || $tempString[$i]=="lowerFaceJoint_M")
			continue;
		tokenize $tempString[$i] "_" $tempString2;
		$sideLess=$tempString2[0];
		$jointName=$sideLess;
		$ctrlName=$sideLess;
		$ctrlName=`substitute "Joint" $ctrlName ""`;
		$ctrlName=`substitute "Ribbon" $ctrlName ""`;
		$side="_"+$tempString2[1];
//print ($i+" : "+$tempString[$i]+" : "+$ctrlName+"\n");

		createNode -n ($ctrlName+"Attacher"+$side) -p SkinAttachCtrls transform;
		if (`objExists $tempString[$i]`)//not the case for e.g LipJoint_R 
			$pos=`xform -q -ws -t $tempString[$i]`;
		if (`gmatch $tempString[$i] "EyeRegion_*"` || `gmatch $tempString[$i] "Eye_*"` || `gmatch $tempString[$i] "Iris_*"` || `gmatch $tempString[$i] "Pupil_*"`)
			$pos=`xform -q -ws -t ("innerLidJoint"+$side)`;
		if (`gmatch $tempString[$i] "*LipJoint_*"`) $pos=`xform -q -ws -t ($ctrlName+$side)`;
		if ($tempString[$i]=="upperLip_M") $pos=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
		if ($tempString[$i]=="lowerLip_M") $pos=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
		if ($tempString[$i]=="NoseRegion_M") $pos=`xform -q -ws -t NoseJoint_M`;
		if ($tempString[$i]=="LipRegion_M") $pos=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
		if ($tempString[$i]=="upperTeeth_M") $pos=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
		if ($tempString[$i]=="lowerTeeth_M") $pos=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
		if ($tempString[$i]=="Jaw_M") $pos=`xform -q -ws -t Jaw`;
		if ($tempString[$i]=="upperFace_M") $pos=`xform -q -ws -t EyeBrowCenterJoint_M`;
		if ($tempString[$i]=="middleFace_M") $pos=`xform -q -ws -t NoseJoint_M`;
		if ($tempString[$i]=="middleFace_M") $pos=`xform -q -ws -t NoseUnderJoint_M`;
		if (`gmatch $tempString[$i] "Tongue*_M"`) $pos=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$attachers[size($attachers)]=$ctrlName+"Attacher"+$side;

		$parent="SideReverseLayered"+$side;
//		if ($tempString[$i]=="Eye_R" || $tempString[$i]=="Eye_L") $parent="EyeControls";

		//create Attach_ xforms
		//v6 some already have Attach.e.g. upperLid2Attach
		if (`objExists ($ctrlName+"Attach"+$side)`)
			{
			$tempString2=`listRelatives -c -type constraint ($ctrlName+"Attach"+$side)`;
			if (size($tempString2))
				delete $tempString2;
			$tempString2=`listRelatives -c -type transform ($ctrlName+"Attach"+$side)`;
			$tempString3=`listRelatives -p ($ctrlName+"Attach"+$side)`;
			parent $tempString2 $tempString3[0];
			delete ($ctrlName+"Attach"+$side);
			if ($opm && `objExists ($ctrlName+"AttachMM"+$side)`)
				delete ($ctrlName+"AttachMM"+$side);
			}
		createNode -n ($ctrlName+"Attach"+$side) -p $parent transform;

		if ($opm)
			{
			asParentConstraint ($ctrlName+"Attacher"+$side) ($ctrlName+"Attach"+$side) "-includePickMatrix";
			setAttr ($ctrlName+"AttachPM"+$side+".useRotate") 0;
			setAttr ($ctrlName+"AttachPM"+$side+".useScale") 0;
			setAttr ($ctrlName+"AttachPM"+$side+".useShear") 0;
			}
		else
			pointConstraint ($ctrlName+"Attacher"+$side) ($ctrlName+"Attach"+$side);

		//create Offset_ xforms 
		rename ($ctrlName+"Offset"+$side) ($ctrlName+"OffsetLayered"+$side);
		createNode -n ($ctrlName+"Offset"+$side) -p ($ctrlName+"Attach"+$side) transform;
		delete `orientConstraint ($ctrlName+$side) ($ctrlName+"Offset"+$side)`;

		//create Subtract_ xforms 
		//v6 some already have Attach.e.g. upperLid2Attach
		if (`objExists ($ctrlName+"Subtract"+$side)`)
			{
			$tempString2=`listRelatives -c -type constraint ($ctrlName+"Subtract"+$side)`;
			if (size($tempString2))
				delete $tempString2;
			$tempString2=`listRelatives -c -type transform ($ctrlName+"Subtract"+$side)`;
			$tempString3=`listRelatives -p ($ctrlName+"Subtract"+$side)`;
			parent $tempString2 $tempString3[0];
			delete ($ctrlName+"Subtract"+$side);
			}
		createNode -n ($ctrlName+"Subtract"+$side) -p ($ctrlName+"Offset"+$side) transform;

		//`new` controller
		rename ($ctrlName+$side) ($ctrlName+"Layered"+$side);
		sets -rm "FaceControlSet" ($ctrlName+"Layered"+$side);
		createNode -n ($ctrlName+$side) -p ($ctrlName+"Subtract"+$side) transform;
		sets -add "FaceControlSet" ($ctrlName+$side);
		connectAttr ($ctrlName+$side+".t") ($ctrlName+"Layered"+$side+".t");
		connectAttr ($ctrlName+$side+".r") ($ctrlName+"Layered"+$side+".r");
		connectAttr ($ctrlName+$side+".s") ($ctrlName+"Layered"+$side+".s");
		$tempString2=`listRelatives -s ($ctrlName+"Layered"+$side)`;
		for ($y=0;$y<size($tempString2);$y++)
			{
			parent -add -s $tempString2[$y] ($ctrlName+$side);
			}
		parent -removeObject -s ($ctrlName+"Layered"+$side+"|"+$ctrlName+"Layered"+$side+"Shape");
		rename ($ctrlName+"Layered"+$side+"Shape") ($ctrlName+$side+"Shape");
		nodeCast -swapNames 1 ($ctrlName+"Layered"+$side) ($ctrlName+$side);//get the addedAttrs

		//Subtract_
		if ($tempString[$i]!="upperTeeth_M" && $tempString[$i]!="lowerTeeth_M" && $tempString[$i]!="Tongue0_M"
			&& $tempString[$i]!="upperFace_M" && $tempString[$i]!="middleFace_M" && $tempString[$i]!="lowerFace_M")
			{
			createNode -n ($ctrlName+"SubtractMultiplyDivide"+$side) multiplyDivide;
			setAttr -type float3 ($ctrlName+"SubtractMultiplyDivide"+$side+".input2") -1 -1 -1;
			connectAttr ($ctrlName+$side+".t") ($ctrlName+"SubtractMultiplyDivide"+$side+".input1");
			connectAttr ($ctrlName+"SubtractMultiplyDivide"+$side+".output") ($ctrlName+"Subtract"+$side+".t");
			}
		}
	eval ($curveCmd);
	$tempString=`listRelatives -s AttacherCurve`;
	rename $tempString[0] AttacherCurveShape;
	//AttacherCurve
	parent AttacherCurve SkinAttachCtrls;
	setAttr "AttacherCurveShape.dispGeometry" 0;
	for ($i=0;$i<size($attachers);$i++)
		{
		createNode -n ("AttacherCurvePoci"+$attachers[$i]) pointOnCurveInfo;
		connectAttr -f AttacherCurve.worldSpace[0] ("AttacherCurvePoci"+$attachers[$i]+".inputCurve");
		setAttr ("AttacherCurvePoci"+$attachers[$i]+".turnOnPercentage") 0;
		setAttr ("AttacherCurvePoci"+$attachers[$i]+".parameter") $i;
		connectAttr -f ("AttacherCurvePoci"+$attachers[$i]+".position") ($attachers[$i]+".t");
		}
	select AttacherCurve $geometry;
	asCreateWrap ("SkinAttachCtrlsWrap",0,0,1,0,0);//$threshold $maxDistance $exclusiveBind $autoWeightThreshold $falloffMode

	//$tackOnCtrls offset compensate
	for ($i=0;$i<size($tackOnCtrls);$i++)
		{
		if (!`objExists $tackOnCtrls[$i]`)
			continue;
		tokenize $tackOnCtrls[$i] "_" $tempString2;
		$sideLess=$tempString2[0];
		$side="_"+$tempString2[1];
		$b=1;
		if ($side=="_R") $b=-1;
		if ($tackOnCtrls[$i]=="Eye_R") $b=1;
		$factor=$ctrlScale;
		if (`gmatch $tackOnCtrls[$i] "Eye_*"`)
			$factor=1;

		$pos=`xform -q -ws -t ($sideLess+"OffsetLayered"+$side)`;
		$pos2=`xform -q -ws -t ($sideLess+"Attach"+$side)`;
		if ($opm)
			setAttr ($sideLess+"AttachMM"+$side+".matrixIn[2]") -type "matrix" 1 0 0 0 0 1 0 0 0 0 1 0 (($pos[0]-$pos2[0])/$factor*$b) (($pos[1]-$pos2[1])/$factor) (($pos[2]-$pos2[2])/$factor) 1;
		else
			setAttr ($sideLess+"Attach"+$side+"_pointConstraint1.offset") -type float3 (($pos[0]-$pos2[0])/$factor*$b) (($pos[1]-$pos2[1])/$factor) (($pos[2]-$pos2[2])/$factor);
		}

	//fix ctrlBox2 ctrls
	$ctrls={"EyeBrowRegion","EyeRegion","NoseRegion","LipRegion","upperFace","middleFace","lowerFace"};
	for ($a=0;$a<size($ctrls);$a++)
		{
		for ($b=0;$b<3;$b++)
			{
			if ($b==0) $side="_R";
			if ($b==1) $side="_L";
			if ($b==2) $side="_M";

			if (!`objExists ($ctrls[$a]+$side)`)
				continue;

			setAttr -l 1 ($ctrls[$a]+"Layered"+$side+".v") 0;
			if ($opm)
				connectAttr -f ($ctrls[$a]+$side+".worldMatrix") ($ctrls[$a]+"MM"+$side+"TGXform.matrixIn[0]");
			else
				{
				delete ($ctrls[$a]+$side+"TGXform_parentConstraint1") ($ctrls[$a]+$side+"TGXform_scaleConstraint1");
				parentConstraint ($ctrls[$a]+$side) ($ctrls[$a]+$side+"TGXform");
				scaleConstraint ($ctrls[$a]+$side) ($ctrls[$a]+$side+"TGXform");
				}
			}
		}

	//move constraints
	$tempString=`listRelatives -ad -type constraint FaceJoint_M`;
	if (size($tempString))
		parent $tempString DeformJointConstraints;

	//show Layers section
	asUpdateButtonEnables;
	}

//no longer use ctrlPhonemes_M->Multipliers, to avoid `double up`
if (`objExists ctrlPhonemes_M` && `objExists bwctrlPhonemes_M_lip`)
	{
	setAttr -l 1 -k 0 ctrlPhonemes_M.lip 0;
	setAttr -l 1 -k 0 ctrlPhonemes_M.jaw 1;
	setAttr -k 0 ctrlPhonemes_M.multipliers;
	}

if (!$keepBSTarget && `objExists asBlendShapes`)
	delete asBlendShapes;

if ($cmd!="") eval ($cmd);

//if eyes are part of main-mesh, then remove SDK from Arkit->eyeRot
if (`gmatch $rightEye ($geometry+"[.]*")` && `objExists ctrlARKit_M`)
	{
	delete `listConnections -s 0 -d 1 -type animCurve bwctrlARKit_M_eyeLookUpLeft bwctrlARKit_M_eyeLookDownLeft bwctrlARKit_M_eyeLookOutLeft bwctrlARKit_M_eyeLookInLeft`;
	delete `listConnections -s 0 -d 1 -type animCurve bwctrlARKit_M_eyeLookUpRight bwctrlARKit_M_eyeLookDownRight bwctrlARKit_M_eyeLookOutRight bwctrlARKit_M_eyeLookInRight`;
	}

//if tongue is part of main-mesh, then remove SDK from Jaw
if (`gmatch $tongue ($geometry+"[.]*")` && `objExists ctrlARKit_M`)
	delete `listConnections -scn 1 -s 1 -d 0 -type blendWeighted SDKJaw_M`;

for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$sc=`asGetSkinCluster $allFaceGeo[$i]`;
	catchQuiet (`skinPercent -normalize true $sc $allFaceGeo[$i]`);
	}

//update FaceAllSet
//was Removed, as this makes ReBuild with "Keep BlendShapes" to complex
//was Resored as ReBuild would not work with otherBS e.g. asFaceBS_model_brow_L
select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
select -d allBeforeConvertToBS;
sets -add FaceAllSet;
select -cl;
sets -clear allBeforeConvertToBS;
delete allBeforeConvertToBS;

//update buildPose
//Also update buildPose
select `sets -q FaceControlSet`;
$controlSetMembers=`ls -sl`;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k -shortNames $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

if ($autoKeyState) autoKeyframe -state 1;

select -cl;
dgdirty -a;//some skinClusters seem to need a kick to normalise
print ("// Converted DrivingSystems to BlendShapes.\n");
}

global proc asBSWizardStop ()
{
if (!`objExists asFaceBS`)
	error "No BlendShapes found on this rig, you need to run \"Convert to BlendShapes\" first.";
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
text -e -l "..." asBSWizardObjAttrText;
text -e -l "..." asBSWizardValueText;
button -e -en 1 asBSWizardButton;
button -e -en 0 asBSWizardHelpButton;
button -e -en 0 asBSWizardNextButton;
if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
}

global proc asBSWizard ()
{
asBSWizardStop;
button -e -en 0 asBSWizardButton;
button -e -en 1 asBSWizardNextButton;
button -e -en 1 asBSWizardHelpButton;
asGoToBuildPose faceSetup;
playbackOptions -min 1 -max 10 -ast 1 -aet 10;
asBSWizardNext;
}

global proc asBSWizardNext ()
{
int $limitsOn=`getAttr ctrlBox.limits`;
float $value;
float $keyXValues[],$keyYValues[];
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[],$tempString[],$tempString2[],$targets[];
string $target, $objAttr,$sdk,$xy;
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
//int $lastStep=$buffer[1];
int $lastStep;
int $step=$previousStep+1;

if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
if ($limitsOn)
	setAttr ctrlBox.limits 0;

$targets=`asBSGetTargets`;
$lastStep=size($targets);

$tempString=`listConnections -s 1 -d 0 ("asFaceBS."+$targets[$step-1])`;
$sdk=$tempString[0];
$tempString=`listConnections -s 1 -d 0 -p 1 $sdk`;
$objAttr=$tempString[0];
$keyXValues=`keyframe -q -fc $sdk`;
$keyYValues=`keyframe -q -vc $sdk`;
for ($i=0;$i<size($keyYValues);$i++)
	if ($keyYValues[$i]==1)
		{
		$value=$keyXValues[$i];
		}

if (`gmatch $objAttr "*tx*_ty*"`)//blendedAttrs, skipping this in Wizard
	{
	print ("Skipping blendedAttribute: \""+$objAttr+"\"\n");
	if ($limitsOn) setAttr ctrlBox.limits 1;
	text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
	asBSWizardNext;
	if ($limitsOn) setAttr ctrlBox.limits 1;
	return;
	}

if ($step==size($targets)+1)
	{
	print ("// All Shapes Complete.\n");
	asBSWizardStop;
	if (`window -q -ex asHelpImageWindow`)
		deleteUI asHelpImageWindow;
	if ($limitsOn) setAttr ctrlBox.limits 1;
	return;
	}

text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
button -e -c ("asHelpImage \"asBSWizardStep"+$objAttr+"_"+$value+"\"") asBSWizardHelpButton;
if (`window -q -ex asHelpImageWindow`)
	asHelpImage ("asBSWizardStep"+$objAttr+"_"+$value);

text -e -l $objAttr asBSWizardObjAttrText;
text -e -l $value asBSWizardValueText;

print ("// asFaceBS."+$targets[$step-1]+" ("+$step+"/"+$lastStep+")\n");

refresh;//eed this to force-detect that limits are swithced off, e.g. ctrlMouth_M.translateY -1;
eval ("setAttr "+$objAttr+" "+$value);

asBSAdjustTarget;
if ($limitsOn) setAttr ctrlBox.limits 1;
}

global proc asBSResetTarget ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $sourceObject,$asFaceBS;
string $tempString[];
if (!`objExists deleteThis`)
	error "Click create blendshape target first";
$tempString=`listRelatives deleteThis`;
//$tempString=`stringArrayRemove {"faceCombined","faceCombinedDefault","faceCombinedMirrorDriver"} $tempString`;
//$resetTargets[0]=$tempString[0];

for ($i=0;$i<size($tempString);$i++)
	{
	if (!`attributeExists sourceObject $tempString[$i]`)
		continue;
	$sourceObject=`getAttr ($tempString[$i]+".sourceObject")`;
	if ($sourceObject==$geometry)
		$asFaceBS="asFaceBS";
	else
		$asFaceBS="asFaceBS_"+`substituteAllString $sourceObject ":" "_"`;
	setAttr ($asFaceBS+".envelope") 0;
	select $sourceObject $tempString[$i];
	blendShape -n tempBS -frontOfChain -w 0 1;
	refresh;
	select $tempString[$i];
	DeleteHistory;
	setAttr ($asFaceBS+".envelope") 1;
	}

if (`objExists faceCombinedDefaultShape`)
	{
	connectAttr -f faceCombinedDefaultShape.outMesh faceCombinedMirrorDriverShape.inMesh;
	refresh;
	disconnectAttr faceCombinedDefaultShape.outMesh faceCombinedMirrorDriverShape.inMesh;
	}

select $sel;
}

global proc asBSExtractAll ()
{
string $tempString[];

if (`objExists asBlendShapes`) delete asBlendShapes;
createNode -n asBlendShapes transform;
asGoToBuildPose faceSetup;
asBSWizard;
for ($i=0;$i<999;$i++)
	{
	if (!`objExists deleteThis`)//finished
		break;
	for ($a=0;$a<99;$a++)
		{
		if ($a==0) $asFaceMirroWrap="asFaceMirroWrap";
		else $asFaceMirroWrap="asFaceMirroWrap"+$a;
		if (`objExists $asFaceMirroWrap`)
			{
			select `listConnections ($asFaceMirroWrap+".outputGeometry")`;
			DeleteHistory;
			}
		else
			break;
		}

	$tempString=`listRelatives -c deleteThis`;
	for ($y=0;$y<size($tempString);$y++)
		{
		select $tempString[$y];
		DeleteHistory;
		}
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString[$y] "*_L"`)
			setAttr ($tempString[$y]+".v") 1;
		if (`getAttr ($tempString[$y]+".v")`)
			parent $tempString[$y] asBlendShapes;
		if (`gmatch $tempString[$y] "*_M"` || `gmatch $tempString[$y] "*_M*"`)
			setAttr ($tempString[$y]+".tx") 0;
		setAttr ($tempString[$y]+".ty") (($i+1)*`getAttr FaceFitSkeleton.faceScale`);
		}

	asBSWizardNext;
	}

if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
print "// All targets extracted.\n";
}

global proc asBSDeltaMushAll ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $deltaMush;
string $tempString[];

asGoToBuildPose faceSetup;
select $geometry;
asApplyDeltaMush;
refresh;
//auto zero-weight for eyeLids & lip
if (`objExists eyeLidArea` && `objExists lipArea`)
	{
	$tempString=`listHistory $geometry`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="deltaMush")
			$deltaMush=$tempString[$y];
	select eyeLidArea;
	percent -v 0 $deltaMush;
	select lipArea;
	percent -v 0 $deltaMush;
	select -cl;
	}

if (`undoInfo -q -state`)
	{
	evalDeferred ("undoInfo -state 1;");
	undoInfo -state 0;
	}

createNode -n runningDeltaMushAllTargets transform;
asBSWizard;
refresh;
for ($i=0;$i<999;$i++)
	{
	if (!`objExists deleteThis`)//finished
		break;
	asBSWizardNext;
	}

$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="deltaMush")
		evalDeferred ("delete "+$tempString[$y]);
if (`objExists runningDeltaMushAllTargets`)
	delete runningDeltaMushAllTargets;

if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
}

global proc asBSAdjustTargetFromPopUpMenu (string $target)
{
float $driveValue;
float $floatChanges[];
string $tempString[],$tempString2[],$tempString3[];

asGoToBuildPose faceSetup;

$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$target)`;
if (!`objExists $tempString[0]`)
	error ("Failed to find connected SDK node for:asFaceBS."+$target);
$tempString2=`listConnections -scn 1 -s 1 -d 0 -type transform $tempString[0]`;
$tempString3=`listConnections -scn 1 -s 1 -d 0 -p 1 -type transform $tempString[0]`;
if (!`objExists $tempString2[0]`)
	error ("Failed to find connected driver for node:asFaceBS."+$tempString[0]);
$floatChanges=`keyframe -q -fc $tempString[0]`;
if ($floatChanges[0]<0)
	$driveValue=$floatChanges[0];
else
	$driveValue=$floatChanges[1];

evalEcho ("setAttr "+$tempString3[0]+" "+$driveValue);
refresh;
asBSAdjustTarget;
}

global proc asBSAdjustTarget ()
{
if (!`objExists asFaceBS`)
	error "No BlendShapes found on this rig, you need to run \"Convert to BlendShapes\" first.";
select asFaceBS;
int $targetNum,$numLetters;
int $inputTargetGroups[],$geoIsHalfSideOnly[];
float $targetWeights[],$bbMin[],$bbMax[];
float $targetWeightsSum=0;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $eyeBrow=`textField -q -tx asFaceEyebrowTextField`;
string $eyeLash=`textField -q -tx asFaceEyelashTextField`;
string $extras=`textField -q -tx asFaceExtrasTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
string $targetLeft,$mirrorSource,$side,$asFaceBS,$mirrorDriver,$leftBDriver,$target,$restorePoseCmd,$aliasAttrCmd;
//string $targets[]=`listAttr -m asFaceBS.weight`;
string $allBSs[]=`ls -type blendShape "asFaceBS*"`;
string $targets[]=`asBSGetTargets`;
string $raiserLower[]={"raiser","lower"};
string $blendedAttrs[]={"txPos_tyPos","txPos_tyNeg","txNeg_tyPos","txNeg_tyNeg","smile","frown","narrowSmile","narrowFrown"};
string $geos[],$faceBSGeos[],$halfSideGeos[],$tempString[];
//float $multiply=`floatFieldGrp -q -v1 asCreateTargetShapeMultiplier`;
float $multiply=1;
if (`objExists runningDeltaMushAllTargets`)
	$multiply=`floatFieldGrp -q -v1 asDeltaMushShapeMultiplier`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

$geos={$geometry};
for ($i=0;$i<size($allFaceGeo);$i++)
	if ($allFaceGeo[$i]!=$geometry)
		$geos[size($geos)]=$allFaceGeo[$i];

$tempString=`stringToStringArray ($eyeBrow+" "+$eyeLash+" "+$extras) " "`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		$faceBSGeos[size($faceBSGeos)]=$tempString[$i];

//$geoIsHalfSideOnly[] //objects that are only on one side e.g.model:brow_R
for ($i=0;$i<size($geos);$i++)
	{
	if (!`stringArrayCount $geos[$i] $faceBSGeos`)
		continue;
	$bbMin=`getAttr ($geos[$i]+".boundingBoxMin")`;
	$bbMax=`getAttr ($geos[$i]+".boundingBoxMax")`;
	if ($bbMin[0]>0 || $bbMax[0]<0)
		{
		$geoIsHalfSideOnly[$i]=1;
		$halfSideGeos[size($halfSideGeos)]=$geos[$i];
		}
	}

//asBSGetTargets skips _L targets, so check these as well
for ($i=0;$i<size($targets);$i++)
	if (`gmatch $targets[$i] "*_R"`)
		$targets[size($targets)]=`substitute "_R" $targets[$i] "_L"`;

//special case txPos_tyPos
for ($i=0;$i<size($targets);$i++)
	{
//	if (!`attributeExists convertedboxCtrlsToBlendShapes asFaceBS`)
//		continue;
	if (`getAttr ("asFaceBS."+$targets[$i])`!=1)
		continue;
	for ($y=0;$y<size($blendedAttrs);$y++)
		{
		if (`gmatch $targets[$i] ("*"+$blendedAttrs[$y]+"*")`)
			{
			//in this case, just set all other targets (that are sdk driving) to 0. Later restore the target values with dgdirty.
			for ($y=0;$y<size($targets);$y++)
				{
				if ($y==$i)
					continue;
				$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$targets[$i])`;
				if ($tempString[0]=="")
					continue;
				setAttr ("asFaceBS."+$targets[$y]) 0;
				}
			$restorePoseCmd="dgdirty -a;";
			}
		}
	}

for ($i=0;$i<size($targets);$i++)
	{
	$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$targets[$i])`;
	if ($tempString[0]=="")
		continue;
	$targetWeights[$i]=`getAttr ("asFaceBS."+$targets[$i])`;
	$targetWeightsSum+=$targetWeights[$i];
	if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
		$targetNum=$i;
	}
if ($targetWeightsSum>1.01 || $targetWeightsSum<0.99)
	{
	for ($i=0;$i<size($targets);$i++)
		{
		$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$targets[$i])`;
		if ($tempString[0]!="")
			if ($targetWeights[$i]>0.001 || $targetWeights[$i]<-0.001)
				print ("// asFaceBS."+$targets[$i]+" = "+$targetWeights[$i]+"\n");
		}
	select asFaceBS;
	AttributeEditor;
	error "Must have one target set to \"1\", and the rest set to \"0\"\n";
	}

if (`objExists deleteThis`)
	delete deleteThis;
createNode -n deleteThis transform;
float $cheekPos[]=`xform -q -ws -t JawPivot`;
string $targetName=$targets[$targetNum];
if (`objExists $targetName`)
	error ("Object "+$targetName+" exists");
if (!`attributeExists ($targetName+"_tweaked") FaceFitSkeleton`)
	addAttr -k 1 -dv 1 -ln ($targetName+"_tweaked") -at bool FaceFitSkeleton;
setAttr ("FaceFitSkeleton."+$targetName+"_tweaked") 1;

//make a combinedMesh for the $geoIsHalfSideOnly objects, to wrap to a combined mesh
if (`intArrayCount 1 $geoIsHalfSideOnly`)
	{
	if (`objExists faceCombined`)
		delete faceCombined;
	for ($i=0;$i<size($allBSs);$i++)
		setAttr ($allBSs[$i]+".envelope") 0;

	select $halfSideGeos;
	duplicate -rr;
	$tempString=`ls -sl`;
	if (size($tempString)>1)
		{
		polyUnite -ch 0 -mergeUVSets 1 -name faceCombinedDefault;
		delete $tempString;
		}
	else
		rename $tempString[0] faceCombinedDefault;

	for ($i=0;$i<size($allBSs);$i++)
		setAttr ($allBSs[$i]+".envelope") 1;

	select $halfSideGeos;
	duplicate -rr;
	$tempString=`ls -sl`;
	if (size($tempString)>1)
		{
		polyUnite -ch 0 -mergeUVSets 1 -name faceCombined;
		delete $tempString;
		}
	else
		rename $tempString[0] faceCombined;
	asLockAttr faceCombined 0 0 0 0;

	sets -e -forceElement initialShadingGroup faceCombined faceCombinedDefault;
	parent faceCombined faceCombinedDefault deleteThis;
	setAttr faceCombined.v 0;
	setAttr faceCombinedDefault.v 0;
	duplicate -n faceCombinedMirrorDriver faceCombined;
	move -r (`getAttr ctrlBoxOffset.tx`*2) 0 0 faceCombinedMirrorDriver;
	setAttr faceCombinedMirrorDriver.sx -1;
	move -r ($cheekPos[0]*2.5) 0 0 faceCombined;
	connectAttr faceCombined.outMesh faceCombinedMirrorDriver.inMesh;

	select faceCombinedDefault faceCombinedMirrorDriver;
	blendShape -n faceCombinedMirrorDriverBS -frontOfChain;
	}



for ($a=0;$a<size($geos);$a++)
	{
	if ($a==0)
		$asFaceBS="asFaceBS";
	else
		$asFaceBS="asFaceBS_"+`substituteAllString $geos[$a] ":" "_"`;
	if (!`objExists $asFaceBS`)
		continue;

	//update $inputTargetGroups & $targets & $targetNum, as this will vary between $geos
	$inputTargetGroups=`getAttr -mi ($asFaceBS+".inputTarget[0].inputTargetGroup")`;
	$targets=`listAttr -m ($asFaceBS+".weight")`;
	$targetWeightsSum=0;
	for ($i=0;$i<size($targets);$i++)
		{
		$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ($asFaceBS+"."+$targets[$i])`;
		if ($tempString[0]=="")
			continue;
		$targetWeights[$i]=`getAttr ($asFaceBS+"."+$targets[$i])`;
		$targetWeightsSum+=$targetWeights[$i];
		if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
			$targetNum=$i;
		}
	if ($targetWeightsSum<1)
		continue;
	if ($targets[$targetNum]!="")
		$target=$targets[$targetNum];
	//ARKit targets have no suffix
	if (!(`gmatch $target "*_R*"` || `gmatch $target "*_L*"` || `gmatch $target "*_M*"`))
		{
		aliasAttr ($target+"_M") ($asFaceBS+"."+$target);
		$aliasAttrCmd="aliasAttr "+$target+" "+$asFaceBS+"."+$target+"_M";
		$target=$target+"_M";
		}
	if ($a==0)
		$targetName=$target;
	else
		$targetName=$target+"_"+`substituteAllString $geos[$a] ":" "_"`;

	if (`gmatch $targetName "*_R*"`)
		{
		$targetLeft=`substitute "_R" $targetName "_L"`;
		//special case for Eyes, as they are not `mirroredBehaviour`
		if (`gmatch $targetName "ctrlEyetranslateXNeg_R*"`) $targetLeft=`substitute "Neg_" $targetLeft "Pos_"`;
		if (`gmatch $targetName "ctrlEyetranslateXPos_R*"`) $targetLeft=`substitute "Pos_" $targetLeft "Neg_"`;

		print ("$targetName="+$targetName+"   $targetLeft="+$targetLeft+"\n");
		if (!`attributeExists ($targetLeft+"_tweaked") FaceFitSkeleton`)
			addAttr -k 1 -dv 1 -ln ($targetLeft+"_tweaked") -at bool FaceFitSkeleton;
		setAttr ("FaceFitSkeleton."+$targetLeft+"_tweaked") 1;
		}
	//special case for FleshyEye, not to be `normal` symmetrical
	if (`gmatch $targetName "*eye_right_*"`) $targetLeft=`substitute "_right_" $targetLeft "_left_"`;
	if (`gmatch $targetName "*eye_left_*"`)  $targetLeft=`substitute "_left_"  $targetLeft "_right_"`;
	if ($multiply!=1)
		setAttr ($asFaceBS+".w["+$targetNum+"]") $multiply;

	setAttr ($skinCluster+".envelope") 0;

//	duplicate -n $targetName $geos[$a];
	//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
	$tempString[0]=`createNode mesh`;
	$tempString=`listRelatives -p $tempString[0]`;
	rename $tempString[0] $targetName;
	connectAttr ($geos[$a]+".outMesh") ($targetName+".inMesh");
	refresh;
	disconnectAttr ($geos[$a]+".outMesh") ($targetName+".inMesh");
	sets -e -forceElement initialShadingGroup $targetName;
	addAttr -ln sourceObject -dt "string" $targetName;
	setAttr -type "string" ($targetName+".sourceObject") $geos[$a];

	asLockAttr $targetName 0 0 0 0;
	setAttr ($skinCluster+".envelope") 1;
	parent $targetName deleteThis;
	select $targetName;
	$tempString=`listRelatives -f -s $targetName`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
//print ("connectAttr -f "+$targetName+".worldMesh[0] "+$asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$targetNum]+"].inputTargetItem[6000].inputGeomTarget;\n");
//	if (!`isConnected ($targetName+".worldMesh[0]") ($asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$targetNum]+"].inputTargetItem[6000].inputGeomTarget")`)
		connectAttr -f ($targetName+".worldMesh[0]") ($asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$targetNum]+"].inputTargetItem[6000].inputGeomTarget");
	refresh;//Maya2016 bug workaround
	move -r ($cheekPos[0]*2.5) 0 0 $targetName;

	if ($geoIsHalfSideOnly[$a])
		{
		select -r faceCombined $targetName;
		if (!`objExists faceCombinedWrap`)
			{
			$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
			rename $tempString[0] faceCombinedWrap;
			}
		else
			AddWrapInfluence;
		}
	
	if ($aliasAttrCmd!="")
		evalEcho ($aliasAttrCmd);


	if (`gmatch $targetName "*_R*"` && !`gmatch $targetName "*_M_*"`)
		{
		refresh;
//		$numLetters=size($targetName);
//		$targetLeft=`substring $targetName 1 ($numLetters-2)`+"_L";
//		$targetLeft=`substitute "_R" $targetName "_L"`;
		setAttr ($asFaceBS+".envelope") 0;
//		duplicate -n $targetLeft $geos[$a];
		//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
		$tempString[0]=`createNode mesh`;
		$tempString=`listRelatives -p $tempString[0]`;
		rename $tempString[0] $targetLeft;
		$mirrorSource=$geos[$a];

		connectAttr ($mirrorSource+".outMesh") ($targetLeft+".inMesh");
		refresh;
		disconnectAttr ($mirrorSource+".outMesh") ($targetLeft+".inMesh");
		sets -e -forceElement initialShadingGroup $targetLeft;

		asLockAttr $targetLeft 0 0 0 0;
		parent $targetLeft deleteThis;
		setAttr ($asFaceBS+".envelope") 1;
		move -r (`getAttr ctrlBoxOffset.tx`*2) 0 0 $targetLeft;
		$tempString=`listRelatives -f -s $targetLeft`;
		for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
		if (!$geoIsHalfSideOnly[$a])
			{
			duplicate -n ($targetLeft+"MirrorDriver") $targetLeft;
			setAttr ($targetLeft+"MirrorDriver.sx") -1;
			setAttr ($targetLeft+"MirrorDriver.v") 0;
			}

		if (`objExists faceCombinedMirrorDriverBS`)
			setAttr faceCombinedMirrorDriverBS.faceCombinedDefault 1;
		if ($geoIsHalfSideOnly[$a])
			select -r $targetLeft faceCombinedMirrorDriver;
		else
			select -r $targetLeft ($targetLeft+"MirrorDriver");

//		CreateWrap;
		doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		if (`objExists faceCombinedMirrorDriverBS`)
			setAttr faceCombinedMirrorDriverBS.faceCombinedDefault 0;

		if (!$geoIsHalfSideOnly[$a])
			connectAttr -f ($targetName+".outMesh") ($targetLeft+"MirrorDriver.inMesh");
	
		for ($i=0;$i<size($targets);$i++)
			if ($targets[$i]==$targetLeft || ($targets[$i]+"_"+`substituteAllString $geos[$a] ":" "_"`)==$targetLeft)
				connectAttr -f ($targetLeft+".worldMesh[0]") ($asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$i]+"].inputTargetItem[6000].inputGeomTarget");

		}

	if ($a==0)
		{
		floatSlider -e -en 1 asFaceBSFloatSlider;
		connectControl asFaceBSFloatSlider ("asFaceBS."+$targetName);
		}
	}

if ($restorePoseCmd!="")
	eval($restorePoseCmd);

select $targetName;
if (size($geos)>1)
	select deleteThis;
}
 
global proc string[] asBSGetTargets ()
{
string $targets[];
string $tempString[],$tempString2[];

$tempString=`listAttr -m asFaceBS.weight`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*_L"`)
		continue;
	if (`gmatch $tempString[$i] "weight*"`)
		continue;
	$tempString2=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$tempString[$i])`;
	if ($tempString2[0]=="")
		continue;
	$targets[size($targets)]=$tempString[$i];
	}

return $targets;
}

global proc asBSNewTarget ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSMirror;
$asDSMessage="Create New BlendShape";
$asDSAttrName="";
$asDSObjName="";
int $numChar;
string $side,$ctrlSide,$driverName,$asDSObjNameSideLess,$targetName;
string $tempString[],$geos[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
float $cheekPos[]=`xform -q -ws -t JawPivot`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

$geos={$geometry};
for ($i=0;$i<size($allFaceGeo);$i++)
	if ($allFaceGeo[$i]!=$geometry)
		$geos[size($geos)]=$allFaceGeo[$i];

if (!`objExists asFaceBS`)
	error "No BlendShapes found on this rig, you need to run \"Convert to BlendShapes\" first.";

if (!`asConfirmIfNotInBuildPose`)
	return;

string $dialogResult=`layoutDialog -t "Confirm" -ui asDsLayout`;
if ($dialogResult!="OK")
	return;
if ($asDSAttrName=="") $asDSAttrName="Untitled";
if ($asDSObjName=="") $asDSObjName="ctrlUntitled";
if (`objExists $asDSObjName`)
	{
	if (`gmatch $asDSObjName "*_R"`) $side="_R";
	else $side="_M";
	}
else
	{
	if ($asDSMirror) $side="_R";
	else $side="_M";
	}
if (`objExists $asDSAttrName`)
	error ("Object \""+$asDSAttrName+"\" Already Exists");

if (`objExists deleteThis`)
	delete deleteThis;

createNode -n deleteThis transform;
for ($a=0;$a<size($geos);$a++)
	{
	if ($a==0)
		$asFaceBS="asFaceBS";
	else
		$asFaceBS="asFaceBS_"+`substituteAllString $geos[$a] ":" "_"`;
	if (!`objExists $asFaceBS`)
		continue;

	if ($a==0)
		$targetName=$asDSAttrName;
	else
		$targetName=$asDSAttrName+"_"+`substituteAllString $geos[$a] ":" "_"`;

	//duplicate -n ($targetName+$side) $geometry;
	//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
	$tempString[0]=`createNode mesh`;
	$tempString=`listRelatives -p $tempString[0]`;
	rename $tempString[0] ($targetName+$side);
	connectAttr ($geos[$a]+".outMesh") ($targetName+$side+".inMesh");
	refresh;
	disconnectAttr ($geos[$a]+".outMesh") ($targetName+$side+".inMesh");
	sets -e -forceElement initialShadingGroup ($targetName+$side);

	asLockAttr ($targetName+$side) 0 0 0 0;
	parent ($targetName+$side) deleteThis;
	$tempString=`listRelatives -s ($targetName+$side)`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
	move -r ($cheekPos[0]*2.5) 0 0 ($targetName+$side);

	//Mirrored target
	if ($side=="_R")
	  {
	  refresh;
	  duplicate -n ($targetName+"_L") ($targetName+$side);
	  move -r ($cheekPos[0]*-5) 0 0 ($targetName+"_L");

	  duplicate -n ($targetName+"_LMirrorDriver") ($targetName+"_L");
	  setAttr ($targetName+"_LMirrorDriver.sx") -1;
	  setAttr ($targetName+"_LMirrorDriver.v") 0;

	  select -r ($targetName+"_L") ($targetName+"_LMirrorDriver");
		doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
	  connectAttr -f ($targetName+$side+".outMesh") ($targetName+"_LMirrorDriver.inMesh");
	  }


	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $ctrlSide="_R"; else $ctrlSide="_L";
		if ($side=="_M") $ctrlSide="_M";
		if ($side=="_M" && $b==-1) continue;

		$asDSObjNameSideLess=$asDSObjName;
		if (`gmatch $asDSObjName "*_R"` || `gmatch $asDSObjName "*_M"`)
			{
			$numChar=size($asDSObjName);
			$asDSObjNameSideLess=`substring $asDSObjNameSideLess 1 ($numChar-2)`;
			}
		$driverName=$asDSObjNameSideLess+$ctrlSide;

		if ($a==0)//addAttr and create ctrl if needed
			{
			if (!`objExists $driverName`)
				{
				$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
				rename $tempString[0] $driverName;
				parent $driverName ctrlBox;
				$tempString=`listRelatives -s $driverName`;
				setAttr ($tempString[0]+".overrideEnabled") 1;
				setAttr ($tempString[0]+".overrideColor") 13;
				xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $driverName;
				if ($ctrlSide!="_M") setAttr ($driverName+".tx") ($cheekPos[0]*0.2*$b);
				}

			if (!`attributeExists $asDSAttrName $driverName`)
				addAttr -k 1 -ln $asDSAttrName -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $driverName;
			}

		if ($a>0)
			{
			rename ($asDSAttrName+$ctrlSide) ("TEMP_"+$asDSAttrName+$ctrlSide);
			rename ($targetName+$ctrlSide) ($asDSAttrName+$ctrlSide);
			}
		blendShape -e -tc 0 -t $geos[$a] `getAttr -s ($asFaceBS+".w")` ($asDSAttrName+$ctrlSide) 1 $asFaceBS;
		if ($a>0)
			{
			rename ($asDSAttrName+$ctrlSide) ($targetName+$ctrlSide);
			rename ("TEMP_"+$asDSAttrName+$ctrlSide) ($asDSAttrName+$ctrlSide);
			}

		setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($driverName+"."+$asDSAttrName) ($asFaceBS+"."+$asDSAttrName+$ctrlSide);
		setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 10 -cd ($driverName+"."+$asDSAttrName) ($asFaceBS+"."+$asDSAttrName+$ctrlSide);
		selectKey -add -k -f 0 -f 10 ($asFaceBS+"_"+$asDSAttrName+$ctrlSide);
		setInfinity -pri cycleRelative -poi cycleRelative;

		string $setAttrCmdExtra="setAttr "+$driverName+"."+$asDSAttrName+" 0;";
		setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);
		}
	}

//delete targets, and re-extract, to get same values and behaviour as standardextracted target
delete deleteThis;
asGoToBuildPose faceSetup;
if ($ctrlSide=="_M")
	setAttr ($asDSObjNameSideLess+"_M."+$asDSAttrName) 10;
else
	setAttr ($asDSObjNameSideLess+"_R."+$asDSAttrName) 10;
dgdirty -a;
asBSAdjustTarget;
}

global proc asFaceConvertControlToSoftMod ()
{
int $b=1;
int $falloffMode=1;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
float $t[],$r[],$s[];
float $falloffRadius=1;
float $currentTime=`currentTime -q`;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $sel[]=`ls -sl`;
string $rootLevelObjects[]=`ls -as`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[0];
string $side="_"+$tempString[1];
//string $deformJoint=$fitJoint+"Joint"+$side;
string $falloffCurveString;
if ($side=="_L" && !$nonSymmetrical)
	error "must be Right side";
if ($side=="_R")
	$b=-1;

for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`gmatch $rootLevelObjects[$i] "convertedSoftModHandle_*"`)
		error "Already converted to SoftMod, now you can edit the softMod if you wish, then click \"done\" to convert back to controller";
if (!size($sel))
	error "Nothing selected, must select a control first";
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a face control";

currentTime -e 0;

$t=`getAttr ($sel[0]+".t")`;
$r=`getAttr ($sel[0]+".r")`;
$s=`getAttr ($sel[0]+".s")`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $sel[0];

if (`attributeExists falloffRadius $fitJoint`) $falloffRadius=`getAttr ($fitJoint+".falloffRadius")`;
else if (`attributeExists falloffRadius $sel[0]`) $falloffRadius=`getAttr ($sel[0]+".falloffRadius")`;
if (`attributeExists falloffMode $fitJoint`) $falloffMode=`getAttr ($fitJoint+".falloffMode")`;
if (`attributeExists falloffCurve $fitJoint`) $falloffCurveString=`getAttr ($fitJoint+".falloffCurve")`;

setAttr ($skinCluster+".envelope") 0;
float $pos[3]=`xform -q -ws -t $sel[0]`;

//select -r ClustersRegion;
select $geometry;
$tempString=`asDeformer softMod`;
string $softMod=`rename $tempString[0] ("convertedSoftMod_"+$sel[0])`;
string $softModHandle=`rename $tempString[1] ("convertedSoftModHandle_"+$sel[0])`;
$tempString=`listConnections ($softMod+".message")`;
rename $tempString[0] ("convertedSoftModSet_"+$sel[0]);
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
xform -piv ($pos[0]) $pos[1] $pos[2] $softModHandle;
//xform -ws -t ($t[0]*$ctrlScale*$b) ($t[1]*$ctrlScale) ($t[2]*$ctrlScale) -ro $r[0] ($r[1]*$b) ($r[2]*$b) -s $s[0] $s[1] $s[2] $softModHandle;

if (`attributeExists falloffRadius $fitJoint`) connectAttr ($softMod+".falloffRadius") ($fitJoint+".falloffRadius");
else if (`attributeExists falloffRadius $sel[0]`) connectAttr ($softMod+".falloffRadius") ($sel[0]+".falloffRadius");

if ($falloffCurveString!="")
	evalEcho (`substituteAllString $falloffCurveString "TempSoftMod" $softMod`);

parentConstraint -mo $sel[0] $softModHandle;
scaleConstraint -mo $sel[0] $softModHandle;
setAttr ($softModHandle+"_parentConstraint1.isHistoricallyInteresting") 0;
setAttr ($softModHandle+"_scaleConstraint1.isHistoricallyInteresting") 0;

if (!$nonSymmetrical)
	{
	setAttr ($sel[0]+".t") -type float3 $t[0] $t[1] $t[2] $sel[0];
	setAttr ($sel[0]+".r") -type float3 $r[0] $r[1] $r[2] $sel[0];
	setAttr ($sel[0]+".s") -type float3 $s[0] $s[1] $s[2] $sel[0];
	}

//make softMod affect ctrl, for easy access to softMod via channelBox
sets -add ("convertedSoftModSet_"+$sel[0]) ($sel[0]+".cv[0:999]");
percent -v 0 ("convertedSoftMod_"+$sel[0]) ($sel[0]+".cv[0:999]");
//direct control radius
if (!`attributeExists falloffRadius $sel[0]`)
	addAttr -k 1 -ln falloffRadius -at double -dv $falloffRadius $sel[0];
connectAttr ($sel[0]+".falloffRadius") ($softMod+".falloffRadius");

currentTime -e $currentTime;
select $sel;
}

global proc asFaceConvertSoftModBackToControl ()
{
global string $gSelect;
setToolTo $gSelect;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
float $currentTime=`currentTime -q`;
string $headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $name,$fitLoc,$side,$ctrl;
string $sel[]=`ls -sl`;
string $tempString[];

currentTime -e 0;
if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
	error "convertedSoftModHandle not selected";
tokenize $sel[0] "_" $tempString;
$name=$tempString[1];
$fitLoc=$name;
$side="_"+$tempString[2];
if ($nonSymmetrical && $side=="_L")
	$fitLoc=$tempString[1]+"Left";
$ctrl=$fitLoc+$side;
$falloffRadius=`getAttr ($fitLoc+".falloffRadius")`;

//Only take weights from $headJoint
asFaceLockWeights 1;
setAttr ($headJoint+".lockInfluenceWeights") 0;

SoftModLayerWeight $fitLoc $name 1 $side $falloffRadius 99;//$type irrelevant, as ctrl already exists
setAttr ($skinCluster+".envelope") 1;

if (`attributeExists falloffRadius $ctrl`)
	deleteAttr ($ctrl+".falloffRadius");

currentTime -e $currentTime;
select -cl;
}

global proc asUnlockAllInfluences (string $skinCluster)
{
string $tempString[]=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".liw") 0;
}

global proc asFaceOptimizeSimpleFaceJointCount ()
{
global string $gMainProgressBar;
int $jointNr;
float $values[];
string $tempString[],$tempString2[],$infs[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $upperLower,$side,$lidLip,$replaceJoint;


select lipArea lipFalloffArea eyeLidArea;
	$tempString=`ls -sl -fl`;
	select -cl;
	progressBar -e -st "OptimizeSimpleFaceJointCount" -bp -ii 1 -min 0 -max (size($tempString)) $gMainProgressBar;
	evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

//for ($a=1;$a<2;$a++)
//Every 2nd joint weighting on eyeLid does not provide nice results
for ($a=0;$a<1;$a++)
	{
	if ($a==0)
		{
		select lipArea lipFalloffArea;
		$lidLip="LipJoint";
		}
	if ($a==1)
		{
		select eyeLidArea;
		$lidLip="LidMain";
		}
	$tempString=`ls -sl -fl`;

	select -cl;
	for ($i=0;$i<size($tempString);$i++)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$i]`;
		$values=`skinPercent- ignoreBelow 0.001 -q -v $skinCluster $tempString[$i]`;
		for ($y=0;$y<size($infs);$y++)
			{
			if (!`gmatch $infs[$y] ("*"+$lidLip+"*")`)
				continue;
			if (`gmatch $infs[$y] "upper*"`)
				$upperLower="upper";
			else
				$upperLower="lower";

			tokenize $infs[$y] "_" $tempString2;
			$side="_"+$tempString2[1];
			$jointNr=`substitute ($upperLower+$lidLip) $tempString2[0] ""`;
			if ($jointNr==0)
				continue;
			if (($jointNr)%2)
				{
				if (($jointNr-1)==0 && $lidLip=="LipJoint")
					$side="_M";
				if (($jointNr-1)==0 && $lidLip=="LidMain" && $upperLower=="lower")
					continue;//lowerLidMain0 not skinned
				$replaceJoint=$upperLower+$lidLip+($jointNr-1)+$side;
				skinPercent -tv $infs[$y] 0 $skinCluster $tempString[$i];
				skinPercent -tv $replaceJoint $values[$y] $skinCluster $tempString[$i];
				}
			}
		}
	}
select $geometry;
removeUnusedInfluences;
}

global proc asFaceRetopoBase ()
{
if (!`objExists FaceFitSkeleton`)
	error "FaceFitSkeleton not found, The Face>Fit section must be completed first";
float $pos[];
string $tempString[];
string $headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
string $geometry=`textField -q -tx asFaceFaceTextField`;

if (`objExists faceCage`) delete faceCage;
string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asGeometry.ma";
file -i $asGeometryFile;
parent -w faceCage;
setAttr faceCage.v 1;
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

int $vtxs[]={0,1,2,3,4,5,6,7,8,9,
	10,11,12,13,
	14,16,17,18,20,21,
	22,23,
	24,25};
string $dests[]={"JawCurve.cv[3] ","Jaw","JawCorner","Throat","upperLipOuterCurve.cv[99]","lowerLipOuterCurve.cv[0]","JawPivot","Cheek","NoseCorner","NoseUnder",
	"CheekRaiser","upperLipOuterCurve.cv[0]","Nose",("lowerEyeLidOuterCurve.cv["+(`getAttr lowerEyeLidOuterCurve.spans`/2)+"]"),
	"lowerEyeLidOuterCurve.cv[0]","lowerEyeLidOuterCurve.cv[99]","EyeBrowMain3","EyeBrowMain0","EyeBrowMain6","EyeBrowOuterCurve.cv[99]",
	("upperEyeLidOuterCurve.cv["+(`getAttr upperEyeLidOuterCurve.spans`/2)+"]"),("EyeBrowOuterCurve.cv["+(`getAttr EyeBrowOuterCurve.spans`/2)+"]"),
	"EyeBrowOuterCurve.cv[0]","JawCurveTop.cv[3]"};
for ($i=0;$i<size($vtxs);$i++)
	{
	$pos=`xform -q -ws -t $dests[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] faceCage.vtx[$vtxs[$i]];
	}

$pos=`xform -q -ws -t faceCage.vtx[18]`; xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[19];

$posA=`xform -q -ws -t faceCage.vtx[12]`;
$posB=`xform -q -ws -t faceCage.vtx[19]`;
xform -ws -t 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) faceCage.vtx[15];

//cluster BeackHead
select -r faceCage.vtx[28:42] ;
$tempString=`newCluster " -envelope 1"`;
rename $tempString[0] backHeadCluster;
rename $tempString[1] backHeadClusterHandle;
$posA=`xform -q -ws -piv backHeadClusterHandle`;
$posB=`xform -q -ws -piv faceCage.vtx[33]`;
xform -piv 0 $posA[1] $posB[2];
setAttr -type float3 backHeadClusterHandleShape.origin 0 $posA[1] $posB[2];
$posA=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
$posB=`xform -q -ws -t JawCorner`;
$posC=`xform -q -ws -piv backHeadClusterHandle`;
move -r 0 ((($posA[1]+$posB[1])/2.0)-$posC[1]) 0 backHeadClusterHandle;
$posA=`xform -q -ws -t $headJoint`;
move -r 0 0 ($posA[2]-$posC[2]) backHeadClusterHandle;

//scale to match
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t faceCage.vtx[30]`;
$scaleX=$posA[0]/$posB[0];
$posA=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
$posB=`xform -q -ws -t JawCorner`;
$FaceFitHeight=$posA[1]-$posB[1];
$posA=`xform -q -ws -t faceCage.vtx[33]`;
$posB=`xform -q -ws -t faceCage.vtx[29]`;
$BackHeadHeight=$posA[1]-$posB[1];
$scaleY=$FaceFitHeight/$BackHeadHeight;
scale -r $scaleX $scaleY ($scaleX/1.5) backHeadClusterHandle;
//select faceCage;
//DeleteHistory;

//snap to surface
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
$posA=`xform -q -ws -t faceCage.vtx[14]`;
$posB=`xform -q -ws -t faceCage.vtx[12]`;
setAttr -type float3 closestSampler.inPosition 0 $posA[1] $posB[2];
$pos=`getAttr closestSampler.result.position`;
xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[15];

$posA=`xform -q -ws -t faceCage.vtx[15]`;
$posB=`xform -q -ws -t faceCage.vtx[12]`;
setAttr -type float3 closestSampler.inPosition 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0);
$pos=`getAttr closestSampler.result.position`;
xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[26];

$pos=`xform -q -ws -t faceCage.vtx[10]`;
setAttr -type float3 closestSampler.inPosition ($pos[0]/2.0) $pos[1] $pos[2];
$pos=`getAttr closestSampler.result.position`;
xform -ws -t $pos[0] $pos[1] $pos[2] faceCage.vtx[27];

delete closestSampler;
print "// Face SkinCage created.\n";
}

global proc asFaceRetopoSections ()
{
float $pos[];
string $tempString[];
string $geometry=`textField -q -tx asFaceFaceTextField`;

if (`objExists topologyConstruction`) delete topologyConstruction;
if (!`objExists asRed`) asFitModeEnsureShaders;
createNode -n topologyConstruction transform;
asLockAttr topologyConstruction 1 1 1 1;

for ($a=0;$a<2;$a++)
	{
	if ($a==0) $lidLip="EyeLid";
	if ($a==1) $lidLip="Lip";

	addAttr -k 1 -dv 3 -ln ($lidLip+"Degree") -at "enum" -en "Linear=1:Cubic=3" topologyConstruction;
	addAttr -k 1 -dv 8 -ln ($lidLip+"UNumber") -at long topologyConstruction;
	addAttr -k 1 -dv 2 -ln ($lidLip+"VNumber") -at long topologyConstruction;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
		for ($b=0;$b<3;$b++)
			{
			if ($b==0) $outerMain="Outer";
			if ($b==1) $outerMain="Main";
			if ($b==2) $outerMain="Inner";

			rebuildCurve -n ($upperLower+$lidLip+$outerMain+"Curve2") -ch 0 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 ($upperLower+$lidLip+$outerMain+"Curve");
			setAttr ($upperLower+$lidLip+$outerMain+"Curve2.v") 0;
			parent ($upperLower+$lidLip+$outerMain+"Curve2") topologyConstruction;
			}
		select ($upperLower+$lidLip+"OuterCurve2") ($upperLower+$lidLip+"MainCurve2") ($upperLower+$lidLip+"InnerCurve2");
		$tempString=`loft -n ($upperLower+$lidLip+"Surface") -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true`;
		setAttr ($upperLower+$lidLip+"Surface.v") 0;
		rename $tempString[1] ($upperLower+$lidLip+"Loft");
		connectAttr ("topologyConstruction."+$lidLip+"Degree") ($upperLower+$lidLip+"Loft.degree");

		$tempString=`nurbsToPoly -n ($upperLower+$lidLip) -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.1 -ft 0.01 -mel 0.001 -d 0.1 -ut 2 -un 8 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+$lidLip+"Surface")`;
		rename $tempString[1] ($upperLower+$lidLip+"NurbsTessellate");
		parent ($upperLower+$lidLip+"Surface") ($upperLower+$lidLip) topologyConstruction;

		connectAttr ("topologyConstruction."+$lidLip+"UNumber") ($upperLower+$lidLip+"NurbsTessellate.uNumber");
		connectAttr ("topologyConstruction."+$lidLip+"VNumber") ($upperLower+$lidLip+"NurbsTessellate.vNumber");
		sets -e -forceElement asRedSG ($upperLower+$lidLip);

		rename ($upperLower+$lidLip) ($upperLower+$lidLip+"_R");
		instance -n ($upperLower+$lidLip+"_L") ($upperLower+$lidLip+"_R");
		setAttr ($upperLower+$lidLip+"_L.scaleX") -1;
		}
	}

polyPlane -n NosePatch -w 1 -h 1 -sx 1 -sy 2 -ax 0 1 0 -cuv 2 -ch 0;
parent NosePatch topologyConstruction;
sets -e -forceElement asGreen2SG NosePatch;

$pos=`xform -q -ws -t NoseCorner`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[0:5];
$pos=`xform -q -ws -t NoseUnder`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[1];
$pos=`xform -q -ws -t Nose`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[3];

spaceLocator -n tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t Nose`; xform -ws -t $pos[0] $pos[1] $pos[2] tempGeoSnapLoc;
$posA=`xform -q -ws -t Nose`;
$posB=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
for ($i=0;$i<10;$i++)
	setAttr tempGeoSnapLoc.ty (($posA[1]+$posB[1])/2.0);
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[5];

$posA=`xform -q -ws -t Nose`;
$posB=`xform -q -ws -t NoseCorner`;
for ($i=0;$i<10;$i++)
	setAttr tempGeoSnapLoc.tx ($posB[0]/3.0);
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[4];
for ($i=0;$i<10;$i++)
	{
	setAttr tempGeoSnapLoc.ty (($pos[1]+$posB[1])/2.0);
	setAttr tempGeoSnapLoc.tx $posB[0];
	}
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[2];

rename NosePatch NosePatch_R;
instance -n NosePatch_L NosePatch_R;
setAttr NosePatch_R.scaleX -1;

delete tempGeoSnapLoc;
select topologyConstruction;
}

global proc asFaceDeleteSkinCage ()
{
delete faceCage;
}

global proc asEyeBallsChooseInput (string $textField)
{
string $sel[]=`ls -sl`;
string $txt=$sel[0];
if (size($sel)>1)
	for ($i=1;$i<size($sel);$i++)
		$txt+=" "+$sel[$i];
textField -e -tx $txt $textField;
asFaceUpdateInfo 0;
}

global proc asChooseInput (string $textField)
{
int $confirmed,$connectedToDeformer;
float $tempFloat[],$pos1[],$pos2[];
string $headJoint="Head_M";//Default name for auto-created HeadJoint, to match AdvSkel headJoint
string $skinCluster,$txt,$dialog,$m,$ffd,$sc;
string $sel[]=`ls -sl`;
string $restoreSel[]=$sel;
string $tempString[],$tempString2[],$tempString3[],$selGeos[];
string $reservedNames[]={"Eye_R","Eye_L","upperTeeth_M","lowerTeeth_M","Tongue0_M","Nose_M"};

asFaceUpgradeFaceFitCheck;

if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;

if ($textField=="asFaceMaskTextField")
	asCreateFaceFitMask;

if ($textField=="asFaceFaceTextField" || $textField=="asFaceAllHeadTextField")
	{
	for ($i=0;$i<size($sel);$i++)
		if (`gmatch $sel[$i] "*[.]*"`)
			error "Only select Object, not vertices, edges or faces";
	}

for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*|*"`)
		{
		select $sel[$i];
		error ("Selected object: \""+$sel[$i]+"\" does not have a unique name, rename to a unique name.");
		}

//reserved names
for ($i=0;$i<size($sel);$i++)
	for ($y=0;$y<size($reservedNames);$y++)
		if ($sel[$i]==$reservedNames[$y])
			{
			select $sel[$i];
			error ("Selected object: \""+$sel[$i]+"\" uses a name that AdvancedSkeleton needs to use, rename this object to another name.");
			}

if (`gmatch $textField "*Joint*"`)
	{
	if (`objectType $sel[0]`!="joint")
		error "A joint must be selected";
	$txt=$sel[0];
	}
else
	{
	//Include children
	select -cl;
	string $children[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			select -add `listRelatives -ad -f -type transform $sel[$i]`;
	string $addedSel[]=`ls -sl`;
	$sel=`stringArrayCatenate $sel $addedSel`;
	$sel=`stringArrayRemoveDuplicates $sel`;

	//Not include non-mesh || non-nurbs (unless choose joint)
	string $shapes[];
	for ($i=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] "*[.]*"`)
			$selGeos=$sel;
		else
			{
			$nodeType="";
			$shapes=`listRelatives -s -ni -f $sel[$i]`;
			if (size($shapes))
				$nodeType=`nodeType $shapes[0]`;
			if ($nodeType=="nurbsSurface" || $nodeType=="mesh")
				$selGeos[size($selGeos)]=$sel[$i];
			}
		}

	$txt=$selGeos[0];
	}
select $restoreSel;

if (size($selGeos)>1)
	for ($i=1;$i<size($selGeos);$i++)
		$txt+=" "+$selGeos[$i];

//Everything must have skinCluster
for ($i=0;$i<size($selGeos);$i++)
	{
	if ($textField=="asFaceHeadJointTextField" || $textField=="asFaceMaskTextField")
		continue;
	if (!`objExists FaceFitSkeletonShape`)
		error "Start with choosing Mask";
	$tempString=`listHistory -pdo 1 -il 2 $selGeos[$i]`;
	$skinCluster="";
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		{
		if ($dialog!="Create New SkinCluster")
			$dialog=`confirmDialog -t "Confirm"
			-m ("No SkinCluster found on this geometry:\n"+$selGeos[$i])
			-b "Create New SkinCluster" -db "Create New SkinCluster"
			-b "Cancel" -ds "Cancel"`;
		if ($dialog!="Create New SkinCluster")
			return;
		select -cl;
		if (!`objExists $headJoint`)
			{
			joint -n $headJoint;
			if (`objExists FaceFitSkeleton`)
				{
				$pos1=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
				$pos2=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
				xform -ws -t 0 ($pos1[1]+(($pos2[1]-$pos1[1])/3.0)) 0 $headJoint;
				}
			}
		textField -e -tx $headJoint asFaceHeadJointTextField;
		select $selGeos[$i] $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		select $selGeos[$i];
		}
	if ($textField=="asFaceFaceTextField")
		{
		textField -e -tx $skinCluster asFaceSkinClusterTextField;
		textField -e -tx $headJoint asFaceHeadJointTextField;
		}
	}

//If there is a Lattice on the Eye, this might be for non-spherical eyes
if (`gmatch $textField "asFace*EyeTextField"`)
	for ($i=0;$i<size($selGeos);$i++)
		{
		$tempString=`listHistory $selGeos[$i]`;
		$skinCluster="";
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`objectType $tempString[$y]`=="ffd")
				$ffd=$tempString[$y];
			if (`objectType $tempString[$y]`=="skinCluster")
				$skinCluster=$tempString[$y];
			}
		if ($ffd!="")
			{
			if ($dialog!="Detected Lattice")
				$dialog=`confirmDialog -t "Confirm"
				-m ("Lattice detected.\nUse this Lattice for non-spherical eyes ?")
				-b "Yes" -db "Yes"
				-b "No" -ds "No"`;
			if ($dialog=="Yes")
				{
				$tempString=`listAttr -ud $ffd`;
				for ($y=0;$y<size($tempString);$y++)
					if (`gmatch $tempString[$y] "asNonSphereLattice_*"`)
						deleteAttr ($ffd+"."+$tempString[$y]);
				if ($textField=="asFaceRightEyeTextField")
					addAttr -k 0 -ln asNonSphereLattice_R -at bool -dv true $ffd;
				if ($textField=="asFaceLeftEyeTextField")
					addAttr -k 0 -ln asNonSphereLattice_L -at bool -dv true $ffd;

				reorderDeformers $ffd $skinCluster $selGeos[$i];
				if (`getAttr ($ffd+".outsideLattice")`!=1)
					setAttr ($ffd+".outsideLattice") 1;
				}
			}
		}

textField -e -tx $txt $textField;
//optionVar -sv $textField $txt;
asFaceUpdateInfo 0;

// Extras allowed to be added After the Build
if ($textField=="asFaceExtrasTextField" && `objExists FaceMotionSystem`)
	asFaceExtras;
}

global proc asDisconnectOPMAttr (string $xform, int $reset)
{
float $m[];
string $tempString[];

if (!`attributeExists offsetParentMatrix $xform`)
	return;

$tempString=`listConnections -s 1 -d 0 -p 1 ($xform+".offsetParentMatrix")`;
if ($tempString[0]!="")
	disconnectAttr $tempString[0] ($xform+".offsetParentMatrix");

if ($reset)
	{
	createNode -n tempMatrixTransform transform;
	$m=`xform -q -os -m tempMatrixTransform`;
	delete tempMatrixTransform;
	setAttr ($xform+".offsetParentMatrix") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
	}
}

global proc asFaceAddIn (string $targets[], string $transform, int $mo)
{
string $trAddIn=$transform+"AddIn";
createNode -n $trAddIn transform;
string $tempString[]=`listRelatives -p $transform`;
parent $trAddIn $tempString[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $trAddIn;
string $cmd="parentConstraint";
if($mo)
	$cmd+=" -mo";
for ($i=0;$i<size($targets);$i++)
	$cmd+=" "+$targets[$i];
$cmd+=" "+$trAddIn;
eval $cmd;

string $trs[]={"t","r"};
for ($i=0;$i<size($trs);$i++)
	{
	createNode -n ($trAddIn+$trs[$i]+"plusMinusAverage") plusMinusAverage;
	if ($trs[$i]=="s")
		setAttr ($trAddIn+$trs[$i]+"plusMinusAverage.operation") 3;
	connectAttr ($trAddIn+"."+$trs[$i]+"x") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dx");
	connectAttr ($trAddIn+"."+$trs[$i]+"y") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dy");
	connectAttr ($trAddIn+"."+$trs[$i]+"z") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dz");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"x")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dx");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"y")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dy");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"z")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dz");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dx") ($transform+"."+$trs[$i]+"x");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dy") ($transform+"."+$trs[$i]+"y");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dz") ($transform+"."+$trs[$i]+"z");
	}
}

global proc asCreateFaceFitJoint (string $region, float $size, int $color)
{
string $sel[]=`ls -sl -fl`;
float $pos[3]=`xform -q -ws -t $sel[0]`;
float $centerErrorMargin=0.001;
if ($region=="mouthUpper" || $region=="mouthLower" || $region=="eyeBrow0"
	|| `gmatch $region "*Middle"` || $region=="noseTip" || $region=="noseLower")
	if ($pos[0]>$centerErrorMargin || $pos[0]<(-1*$centerErrorMargin))
		error ($region+" needs to be in the center, currently:"+$pos[0]+"\n");
int $jointNumber;
string $jointName;
for ($i=1;$i<99;$i++)
	{
	$jointNumber=$i;
	$jointName=$region+$jointNumber;
	if (!`objExists $jointName`)
		break;
	}
for ($i=0;$i<size($sel);$i++)
	{
	$jointName=$region;
	if (size($sel)>1)
		$jointName=$region+$jointNumber;
	$jointNumber++;
	$jointName=`asFaceCreateFitJoint $jointName $size $color`;
	$pos=`xform -q -ws -t $sel[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $jointName;
	}

if (`checkBox -q -ex ("asFaceFit"+$region)`)
	checkBox -e -v 1 -ed 1 ("asFaceFit"+$region);
hilite -r `ls -o $sel`; 
select $sel;
repeatLast -addCommand ("asCreateFaceFitJoint "+$region+" "+$size+" "+$color);

if (`gmatch $region "eyeBrow[0-9]"`)
	asAutoEyeBrowFalloff $region;
}

global proc asAutoEyeBrowFalloff (string $region)
{
float $posA[3],$posB[3];
float $mag;
int $nr=`substring $region 8 8`;
string $previousRegion="eyeBrow"+($nr-1);
if (!`objExists $previousRegion`)
	return;
$posA=`xform -q -ws -t $region`;
$posB=`xform -q -ws -t $previousRegion`;
$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
setAttr ($region+".falloffRadius") $mag;
float $previousRad=`getAttr ($previousRegion+".falloffRadius")`;
if ($mag>$previousRad || $previousRegion=="eyeBrow0")
	setAttr ($previousRegion+".falloffRadius") $mag;
}

global proc string asFaceCreateFitJoint (string $name, float $radius, int $color)
{
if (`objExists $name`)
	error ($name+" Already Exists");

if (!`objExists FaceFitFromSoftMods`)
	createNode -n FaceFitFromSoftMods -p FaceFitSkeleton transform;

select FaceFitFromSoftMods;
joint -n $name;
setAttr ($name+".overrideEnabled") 1;
setAttr ($name+".overrideColor") $color;
addAttr -k 1 -min 0 -dv $radius -ln "falloffRadius" -at double $name;
addAttr -k 1 -ln "falloffMode"  -at "enum" -en "volume:surface:" $name;
addAttr -k 1 -ln "interpolation"  -at "enum" -en "none:linear:smooth:spline:" $name;
if (`gmatch $name "lowerEye*"` || `gmatch $name "upperEye*"` || `gmatch $name "lowerLip*"` || `gmatch $name "upperLip*"`)
	;
else
	{
	setAttr ($name+".falloffMode") 1;
	setAttr ($name+".interpolation") 2;
	}
if (`gmatch $name "*Sculpt*"`)
	setAttr ($name+".falloffMode") 0;
return $name;
}

global proc asFaceUpdateInfo (int $read)//info between UI and FitSkeleton
{
if (!`columnLayout -q -ex asColumnLayout`)
	return;
int $vtxsFromLipToNose=3;
//int $vtxsFromLipCornerToNoseCorner=6;
int $stepBuild,$nextStep,$headerEn,$bodyEn,$m,$nonSymFace,$leftFaceFitting,$inputNr,$value,$optionNr;

int $disableSteps[];
string $text,$obj,$fitType,$savedFitType,$leftSuffix,$parent,$stepBuildText,$type,$ctrl,$optionEnums,$valueAsString,$asFaceFitMidText;
string $avaiableBuiltTypes[],$tempString[],$tempString2[],$tempString3[],$inputs[],$inputTypes[],$ctrls[];

//3-level recursive searching layots for textFields,etc ($ctrls)
$tempString=`layout -q -ca asFacePreColumnLayout`;
for ($a=0;$a<size($tempString);$a++)
	{
	if (!`layout -q -ex $tempString[$a]`)
		{
		$ctrls[size($ctrls)]=$tempString[$a];
		continue;
		}
	$tempString2=`layout -q -ca $tempString[$a]`;
	for ($b=0;$b<size($tempString2);$b++)
		{
		if (!`layout -q -ex $tempString2[$b]`)
			{
			$ctrls[size($ctrls)]=$tempString2[$b];
			continue;
			}
		$tempString3=`layout -q -ca $tempString2[$b]`;
		for ($c=0;$c<size($tempString3);$c++)
			{
			if (!`layout -q -ex $tempString3[$c]`)
				{
				$ctrls[size($ctrls)]=$tempString3[$c];
				continue;
				}
			}
		}
	}
for ($i=0;$i<size($ctrls);$i++)
	{
	if (`gmatch $ctrls[$i] "*TextField"`) $type="TextField";
	if (`gmatch $ctrls[$i] "*CheckBox"`) $type="CheckBox";
	if (`gmatch $ctrls[$i] "*OptionMenu"`) $type="OptionMenu";
	if (`gmatch $ctrls[$i] ("asFace*"+$type)`)
		{
		$tempString[0]=`substitute "asFace" $ctrls[$i] ""`;
		$tempString[0]=`substitute $type $tempString[0] ""`;
		$inputs[$inputNr]=$tempString[0];
		$inputTypes[$inputNr]=$type;
		$inputNr++;
		}
	}

//backwards compability 
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr -type FaceFitSkeleton.NonSym`=="string")
		deleteAttr FaceFitSkeleton.NonSym;

if ($read)
	{
	if (`attributeExists NonSym FaceFitSkeleton`)
		{
		if (`getAttr FaceFitSkeleton.NonSym`)
			$nonSymFace=1;
		if (`getAttr FaceFitSkeleton.NonSymSide`=="Left")
			{
			$leftSuffix="Left";
			$leftFaceFitting=1;
			}
		}

	columnLayout -e -m $nonSymFace asFaceNonSymColumnLayout;
	if ($nonSymFace)
		{
		if ($leftFaceFitting)
			frameLayout -e -l (" Fit                      (Left)") asFaceFitFrameLayout;
		else
			frameLayout -e -l (" Fit                      (Right)") asFaceFitFrameLayout;
		}
	else
		frameLayout -e -l " Fit" asFaceFitFrameLayout;
	}
	
for ($i=0;$i<size($inputs);$i++)
	{
//print ($i+" : "+$inputs[$i]+" : "+$inputTypes[$i]+"\n");
	$ctrl="asFace"+$inputs[$i]+$inputTypes[$i];
	if (!`control -q -ex $ctrl`)
		continue;
	if ($read)
		{
		$text="";
		$value=0;

		if ($inputTypes[$i]=="TextField")
			{
			if (`attributeExists $inputs[$i] FaceFitSkeleton`)
				$text=`getAttr ("FaceFitSkeleton."+$inputs[$i])`;
			textField -e -tx $text $ctrl;
			}
		if ($inputTypes[$i]=="CheckBox")
			{
			if (`attributeExists $inputs[$i] FaceFitSkeleton`)
				$value=`getAttr ("FaceFitSkeleton."+$inputs[$i])`;
			else
				$value=`checkBox -q -v $ctrl`;//allows for spesifying default to be On e.g. Phonemes & Emotions
			checkBox -e -v $value $ctrl;
			}
		if ($inputTypes[$i]=="OptionMenu")
			{
			optionMenu -e -sl 1 $ctrl;//default to first option
			if (`attributeExists $inputs[$i] FaceFitSkeleton`)
				{
				$valueAsString=`getAttr -asString ("FaceFitSkeleton."+$inputs[$i])`;
				optionMenu -e -v $valueAsString $ctrl;
				}
			}
		}
	else if (`objExists FaceFitSkeleton`)//FaceFitSkeleton must exists to setAttr, but not for `setGUi` as `setGUI` might be `clearning` e..g newScene
		{
		if (!`attributeExists $inputs[$i] FaceFitSkeleton`)
			{
			if ($inputTypes[$i]=="TextField") addAttr -ln $inputs[$i] -dt "string" FaceFitSkeleton;
			if ($inputTypes[$i]=="CheckBox") addAttr -ln $inputs[$i] -at bool FaceFitSkeleton;
			if ($inputTypes[$i]=="OptionMenu") addAttr -ln $inputs[$i] -at "enum" -en `asFaceOptionMenuItemsAsEnums $inputs[$i]` FaceFitSkeleton;
			}
		if ($inputTypes[$i]=="TextField") setAttr -type "string" ("FaceFitSkeleton."+$inputs[$i]) `textField -q -tx $ctrl`;
		if ($inputTypes[$i]=="CheckBox") setAttr ("FaceFitSkeleton."+$inputs[$i]) `checkBox -q -v $ctrl`;
		if ($inputTypes[$i]=="OptionMenu")
			{
			//more enums might have been added e.g. rigType mixed added, then we re-add the attr
			$optionNr=`optionMenu -q -sl $ctrl`;
			if (catchQuiet (`setAttr ("FaceFitSkeleton."+$inputs[$i]) ($optionNr-1)`))
				{
				deleteAttr ("FaceFitSkeleton."+$inputs[$i]);
				asFaceUpdateInfo $read;
				}
			}
		}
	}


//Update CheckBoxes
string $checkBoxes[]=`lsUI -type checkBox`;
for ($i=0;$i<size($checkBoxes);$i++)
	{
	if (!`checkBox -q -ex $checkBoxes[$i]`)
		continue;//yes, this seem to be the case when running upon Winwdow re-dock
	int $value=0;
	if (`gmatch $checkBoxes[$i] "asFaceFit*"`)
		{
		$obj=`substitute "asFaceFit" $checkBoxes[$i] "FaceFit"`+$leftSuffix;
		$asFaceFitMidText=`substitute asFaceFit $checkBoxes[$i] "asFaceFitText"`;
		if (`objExists $obj`)
			$value=1;
		checkBox -e -ed $value -v $value $checkBoxes[$i];

		//Not all checkBoxes to be used for Left side Fitting
		if (`text -q -ex $asFaceFitMidText`)
			if (`text -q -l $asFaceFitMidText`==1)
			 	{
				$parent=`checkBox -q -p $checkBoxes[$i]`;
				layout -e -en (!$leftFaceFitting) $parent;
				}
		}
	}

//BuildStep
if (`attributeExists buildStep FaceFitSkeleton`)
	$stepBuild=`getAttr FaceFitSkeleton.buildStep`;
$nextStep=$stepBuild+1;
for ($i=0;$i<99;$i++)
	{
	if (!`columnLayout -q -ex ("asStepBuildColumnLayout"+$i)`)
		break;
	$headerEn=0;
	$bodyEn=0;
	$m=0;

	if ($i>($nextStep-2))
		$m=1;
	//if build is complete, show no steps (to ensure showing correct even if we changed AS version, and new version has more steps)
	if (`objExists FaceAllSet` && !`objExists allBeforeFaceBuild` && $stepBuild!=0 && !`objExists prefix_FaceGroup`)
		$m=0;

	if (`text -q -ex ("stepBuild"+$i+"Text")`)
		{
		$stepBuildText=`text -q -l ("stepBuild"+$i+"Text")`;
		if (`gmatch $stepBuildText "*RebuildRestore"`)
			if (!`objExists prefix_FaceGroup`)
				$m=0;
		}

	if ($i==($nextStep-1))
			$bodyEn=1;
	if ($i==$nextStep)
			$headerEn=1;

	rowLayout -e -en $headerEn -m $m ("asStepBuildRowLayout"+$i);
	columnLayout -e -en $bodyEn -m $m ("asStepBuildColumnLayout"+$i);
	}

//vtxsFromLipToNose
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
if (`intField -q -ex lipFalloffOuterIntField`)
	intField -e -v $vtxsFromLipToNose lipFalloffOuterIntField;
}

global proc string asFaceOptionMenuItemsAsEnums (string $input)
{
string $return;
string $menuItems[]=`optionMenu -q -ill ("asFace"+$input+"OptionMenu")`;
for ($i=0;$i<size($menuItems);$i++)
	$return+=`menuItem -q -l $menuItems[$i]`+":";
return $return;
}

global proc SoftModLayerWeight (string $fitLoc, string $name, int $b, string $side, float $falloffRadius, int $type)
{
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $returnFromSoftModEdit;
int $vtxNrs[];
float $value,$distA,$distB;
float $ctrlPos[],$ctrlRot[],$ctrlSca[],$weights[];
float $pos[]=`xform -q -ws -t $fitLoc`;
float $smWeights[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $softModLayerVtx;
string $tempString[];

//create LayerMesh (weightBysoftmod ignores locked weights)
if (`objExists SoftModLayer`)
	delete SoftModLayer;
duplicate -n SoftModLayer templateLayer;
select $headJoint SoftModLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] SoftModSC;

//Create controller, or returning from SoftModEdit
if (`objExists ("convertedSoftModHandle_"+$name+$side)`)
	$returnFromSoftModEdit=1;

if (!$returnFromSoftModEdit)
	{
	asCreatePP $fitLoc $name $side $type 1 0 0;
	skinCluster -e -dr 4 -lw false -wt 0 -ai ($name+"Joint"+$side) $skinCluster;
	}
else
	{
	$ctrlPos=`getAttr ($name+$side+".t")`;
	$ctrlRot=`getAttr ($name+$side+".r")`;
	$ctrlSca=`getAttr ($name+$side+".s")`;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 ($name+$side);
	$pos=`xform -q -ws -t $fitLoc`;
	}	
skinCluster -e -dr 4 -lw false -wt 0 -ai ($name+"Joint"+$side) SoftModSC;

if ($returnFromSoftModEdit)
	{
	//Flood first, as the user might choose a smaller radius then original.
	//note the weight will go to headJoint (or any other unlocked weight)
	catchQuiet (`skinPercent -tv ($name+"Joint"+$side) 0 $skinCluster $geometry`);
	}

//slower, but more accurate
//asFaceSoftModToSkinWeights ("convertedSoftMod_"+$name+$side) ($name+"Joint"+$side) ($name+$side) $skinCluster $geometry;

//Faster but less accurate
if ($falloffRadius>0)
	asSkinWeightBySoftMod ($name+"Joint"+$side) SoftModLayer SoftModSC $falloffRadius 1;

if (`objExists asSkinWeightExludeSet`)
	{
	select `asobjSetCast asSkinWeightExludeSet {} SoftModLayer`;
	skinPercent -tv $headJoint 1 SoftModSC;
	}

select $geometry;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
polySelectConstraint -m 0;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	{
	$softModLayerVtx=`substitute $geometry $tempString[$i] "SoftModLayer"`;
//	$value=`skinPercent -t ($name+"Joint"+$side) -q -v SoftModSC $softModLayerVtx`;
//	catchQuiet (`skinPercent -tv ($name+"Joint"+$side) $value $skinCluster $tempString[$i]`);
//Faster, but does not obey lock weights
	$vtxNrs[size($vtxNrs)]=`asComponentToNr $tempString[$i]`;
	$weights[size($weights)]=`skinPercent -t ($name+"Joint"+$side) -q -v SoftModSC $softModLayerVtx`;
	}

asSkinWeightSet ($name+"Joint"+$side) $geometry $skinCluster $vtxNrs $weights;

if ($returnFromSoftModEdit)
	delete ("convertedSoftModHandle_"+$name+$side);

if (!`attributeExists falloffRadius $fitLoc`)
	addAttr -k 1 -ln falloffRadius -at double -dv 1 $fitLoc;
if (!`attributeExists falloffMode $fitLoc`)
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 $fitLoc;
if (!`attributeExists type $fitLoc`)
	addAttr -k 1 -ln "type" -at bool -dv 1 $fitLoc;
setAttr ($fitLoc+".falloffRadius") $falloffRadius;
setAttr ($fitLoc+".falloffMode") 1;

if ($returnFromSoftModEdit && !$nonSymmetrical)
	{
	setAttr ($name+$side+".t") -type float3 $ctrlPos[0] $ctrlPos[1] $ctrlPos[2];
	setAttr ($name+$side+".r") -type float3 $ctrlRot[0] $ctrlRot[1] $ctrlRot[2];
	setAttr ($name+$side+".s") -type float3 $ctrlSca[0] $ctrlSca[1] $ctrlSca[2];
	}
}

global proc asEyeLidAttachPP (string $name, string $side)
{
int $b=1;
int $opm=`asGetOpm`;
int $numLid;
float $u,$mag,$minDist;
float $pos[],$posA[],$posB[],$m[];
string $attachTo,$curve,$aimEnd,$innerAimEnd,$outerAimEnd;
string $upperLower="upper";
string $outerMain="Main";
string $leftSuffix="";

if ($side=="_R") $b=-1;
if ($side=="_L") $leftSuffix="Left";
if (`gmatch $name "*Outer"`) $outerMain="Outer";
if (`gmatch $name "lower*"`) $upperLower="lower";

if (!`gmatch $name "*Lid[0-9]*"`)
	parent ($name+"Offset"+$side) ("EyeRegion"+$side);

if (`objExists ($name+"JointOffset"+$side)`)
	parent ($name+"JointOffset"+$side) LidJoints;
else if (`objExists ($name+"Joint"+$side)`)
	{
	parent ($name+"Joint"+$side) LidJoints;
	if ($opm)
		{
		connectAttr -f LidJoints.worldInverseMatrix ($name+"JointMM"+$side+".matrixIn[2]");
		xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 ($name+"Joint"+$side);
		$m=`xform -q -os -m FaceGroup`;
		setAttr ($name+"JointMM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		}
	}
//using onFaceSpace
//parent -r ($name+"Joint"+$side) LidJoints;
//setAttr ($name+"JointMPD"+$side+".input2") -type float3 $b 1 1;

if ($outerMain=="Outer")
	return;

$curve=$upperLower+"EyeLid"+$outerMain+"Curve"+$leftSuffix;
$numLid=`getAttr ($curve+".spans")`+1;

$posA=`xform -q -ws -t ($name+$side)`;
$minDist=999;
for ($i=0;$i<$numLid;$i++)
	{
	$aimEnd=$upperLower+"LidMain"+$i+"AimEnd"+$side;
	if (!`objExists $aimEnd`)
		continue;
	$posB=`xform -q -ws -t $aimEnd`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag<$minDist)
		{
		$minDist=$mag;
		$attachTo=$aimEnd;
		}
	}

//parentConstraint -mo $attachTo ($name+"Attach"+$side);
if ($opm)
	{
	asParentConstraint $attachTo ($name+"Attach"+$side) "-includePickMatrix -mo";
	setAttr ($name+"AttachPM"+$side+".useRotate") 0;
	setAttr ($name+"AttachPM"+$side+".useScale") 0;
	setAttr ($name+"AttachPM"+$side+".useShear") 0;
	}
else
	pointConstraint -mo $attachTo ($name+"Attach"+$side);
}

global proc asCreatePP (string $trnPos, string $name, string $side, int $type, int $createJoint, int $bindSkin, int $createAttacher)
{
int $opm=`asGetOpm`;
int $localB=1;//localB will be -1 if `gmatch _R`
float $pos[]=`xform -q -ws -t $trnPos`;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $trs[]={"t","r","s"};

//nurbsSphere controller
asCreateFaceController $name $side $type;

if ($side=="_R")
	$localB=-1;
xform -ws -t $pos[0] $pos[1] $pos[2] ($name+"Offset"+$side);
xform -ws -t $pos[0] $pos[1] $pos[2] ($name+"Offset"+$side);

//Joint + Offset
if ($createJoint)
	{
	select -cl;
	createNode -n ($name+"JointOffset"+$side) transform;
	joint -n ($name+"Joint"+$side);
	parent ($name+"JointOffset"+$side) FaceJoint_M;
	setAttr ($name+"Joint"+$side+".segmentScaleCompensate") 0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($name+"JointOffset"+$side);

	asParentConstraint ($name+$side) ($name+"Joint"+$side) "-mo";
//	parentConstraint -mo ($name+$side) ($name+"Joint"+$side);
//	scaleConstraint -mo ($name+$side) ($name+"Joint"+$side);
	}
if ($bindSkin)
	{
	string $bindToSkinCluster=$skinCluster;
	skinCluster -e -ai ($name+"Joint"+$side) -lw false -wt 0 $skinCluster;
	}

select -cl;
refresh;

parent ($name+"Offset"+$side) ("SideReverse"+$side);
xform -os -ro 0 0 0 -s 1 1 1 ($name+"Offset"+$side);

if ($side!="_M")
	asFaceControlOrient ($name+$side);
asFacePlaceCtrlByProjection ($name+$side);

if ($createJoint)
	{
	parent ($name+"Joint"+$side) FaceJoint_M;

	if ($opm)
		{
		connectAttr -f FaceJoint_M.worldInverseMatrix ($name+"JointMM"+$side+".matrixIn[2]");
		xform -os -t 0 0 0 ($name+"Joint"+$side);
		}

	delete ($name+"JointOffset"+$side);
	if ($opm)
		{
		createNode -n tempMatrixTransform transform;
		parent tempMatrixTransform ($name+$side);
		xform -os -t 0 0 0 -ro 0 0 0 tempMatrixTransform;
		$m=`xform -q -os -m tempMatrixTransform`;
		delete tempMatrixTransform;
		setAttr ($name+"JointMM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		}
	else
		{
		delete ($name+"Joint"+$side+"_scaleConstraint1");
		setAttr ($name+"Joint"+$side+".s") -type float3 1 1 1;
		scaleConstraint -mo ($name+$side) ($name+"Joint"+$side);
		}
	}

//Subtracter and attacher
if ($createAttacher)
	{
	createNode -n ($name+"Attach"+$side) transform;
	parent -r ($name+"Attach"+$side) ($name+"Offset"+$side);
	parent ("SDK"+$name+$side) ($name+"Attach"+$side);

	createNode -n ($name+"PMA"+$side) plusMinusAverage;
	connectAttr ($name+$side+".t") ($name+"PMA"+$side+".input3D[0]");
	connectAttr ("SDK"+$name+$side+".t") ($name+"PMA"+$side+".input3D[1]");

	createNode -n ($name+"Subtract"+$side) -p ("SDK"+$name+$side) transform;
	createNode -n ($name+"SubtractMPD"+$side) multiplyDivide;
	setAttr ($name+"SubtractMPD"+$side+".input1") -type float3 -1 -1 -1;
	connectAttr ($name+"PMA"+$side+".output3D") ($name+"SubtractMPD"+$side+".input2");
	connectAttr ($name+"SubtractMPD"+$side+".output") ($name+"Subtract"+$side+".t");
	parent ($name+$side) ($name+"Subtract"+$side);
	}
if ($createAttacher && $createJoint)
	{
	//replace constraint of joint to connected
	if ($opm)
		{
		delete ($name+"JointMM"+$side);
		createNode -n tempMatrixTransform transform;
		$m=`xform -q -os -m tempMatrixTransform`;
		delete tempMatrixTransform;
		setAttr ($name+"Joint"+$side+".offsetParentMatrix") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		}
	else
		{
		delete ($name+"Joint"+$side+"_parentConstraint1");
		delete ($name+"Joint"+$side+"_scaleConstraint1");
		}

	createNode -n ($name+"JointOffset"+$side) -p ($name+"Offset"+$side) transform;
	if ($side=="_R")
		setAttr ($name+"JointOffset"+$side+".sx") -1;
	parent -w ($name+"JointOffset"+$side);
	if ($side=="_R")
		setAttr ($name+"JointOffset"+$side+".sx") (-1*`getAttr ($name+"JointOffset"+$side+".sx")`);
	parent -r ($name+"Joint"+$side) ($name+"JointOffset"+$side);
	setAttr ($name+"Joint"+$side+".r") -type float3 0 0 0;
/*
	if ($opm)
		{
		if (`objExists ($name+"JointMM"+$side)`)
			disconnectAttr FaceJoint_M.worldInverseMatrix ($name+"JointMM"+$side+".matrixIn[2]");
		setAttr ($name+"Joint"+$side+".t") -type float3 0 0 0;
		}
*/
//	for ($y=0;$y<size($trs)-1;$y++)//including rot make not nice lip `curve`.But Green EyeLid ctrl needs it. so manual remove for lip.Nah manual create for lip
	for ($y=0;$y<1;$y++)
		{
		createNode -n ($name+"JointPMA"+$trs[$y]+$side) plusMinusAverage;
		connectAttr ($name+$side+"."+$trs[$y]) ($name+"JointPMA"+$trs[$y]+$side+".input3D[0]");
		connectAttr ("SDK"+$name+$side+"."+$trs[$y]) ($name+"JointPMA"+$trs[$y]+$side+".input3D[1]");
		if (`objExists ($name+"Follow"+$side)`)
			connectAttr ($name+"Follow"+$side+"."+$trs[$y]) ($name+"JointPMA"+$trs[$y]+$side+".input3D[2]");

		connectAttr ($name+"JointPMA"+$trs[$y]+$side+".output3D") ($name+"Joint"+$side+"."+$trs[$y]);
		}
	}
}

global proc asSoftCluster (string $name, string $side, string $geometry, float $pos[], float $falloffRadius, int $falloffMode)
{
string $tempString[];

select $geometry;
$tempString=`asDeformer softMod`;
string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
$tempString=`listConnections ($softMod+".message")`;
rename $tempString[0] ($name+"SoftModSet");
setAttr -type float3 ($softModHandle+"Shape.origin") $pos[0] $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

select $geometry;
$tempString=`newCluster " -envelope 1"`;
rename $tempString[0] ($name+"Cluster"+$side);
rename $tempString[1] ($name+"ClusterHandle"+$side);
$tempString=`listRelatives -s ($name+"ClusterHandle"+$side)`;
rename $tempString[0] ($name+"ClusterHandleShape"+$side);
$tempString=`listConnections ($name+"Cluster"+$side+".message")`;
rename $tempString[0] ($name+"ClusterSet"+$side);
setAttr -type float3 ($name+"ClusterHandleShape"+$side+".origin") $pos[0] $pos[1] $pos[2];
xform -ws -piv $pos[0] $pos[1] $pos[2] ($name+"ClusterHandle"+$side);

}

global proc asFaceConnectAttr (string $source, string $dest)
{
int $b=1;
float $ctrlScale=`getAttr OnFacecontrols.sx`;
float $t[];
string $sourceName,$sourceSidem,$destName,$destSide;
string $tempString[];

tokenize $source "_" $tempString;
$sourceName=$tempString[0];
$sourceSide="_"+$tempString[1];
if ($sourceSide=="_R") $b=-1;

tokenize $dest "_" $tempString;
$destName=$tempString[0];
$destSide="_"+$tempString[1];

createNode -n ($destName+"PlusMinusAverage"+$destSide) plusMinusAverage;
$t=`getAttr ($dest+".t")`;
setAttr -type float3 ($destName+"PlusMinusAverage"+$destSide+".input3D[0]") $t[0] $t[1] $t[2];
connectAttr ($destName+"PlusMinusAverage"+$destSide+".output3D") ($dest+".t");

createNode -n ($destName+"DriveAddT"+$destSide) plusMinusAverage;
$t=`getAttr ($dest+".t")`;
connectAttr ($sourceName+$sourceSide+".t") ($destName+"DriveAdd"+$destSide+".input3D[0]");
if (`objExists ($sourceName+"Drive"+$sourceSide)`)
	connectAttr ($sourceName+"Drive"+$sourceSide+".t") ($destName+"DriveAdd"+$destSide+".input3D[1]");

createNode -n ($destName+$destSide+"MultiplyDivide") multiplyDivide;
setAttr -type float3 ($destName+$destSide+"MultiplyDivide.input1") ($ctrlScale*$b) $ctrlScale $ctrlScale;
connectAttr ($destName+"DriveAdd"+$destSide+".output3D") ($destName+$destSide+"MultiplyDivide.input2");
connectAttr ($destName+$destSide+"MultiplyDivide.output") ($destName+"PlusMinusAverage"+$destSide+".input3D[1]");
}

global proc asCreateFaceController (string $name, string $side, int $type)
{
int $color;
float $radius=0.2;
string $letter;
string $tempString[];

if ($type==1) $radius=0.15;//Red
if ($type==2 || $type==12) $radius=0.3;//Green
if ($type==3 || $type==13) $radius=0.15;//Blue

if ($type==1) {$letter="B";$color=13;}//Red
if ($type==2 || $type==12) {$letter="A";$color=14;}//Green
if ($type==3 || $type==13) {$letter="C";$color=6;}//Blue
if ($type==4) {$letter="Regions";$color=14;}//19//15//
if ($type==5) {$letter="Custom";$color=28;}

$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $radius -d 3 -ut 0 -s 8 -ch 0`;
rename $tempString[0] ($name+$side);

sets -add "FaceControlSet" ($name+$side);
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") $color;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ("SDK"+$name+$side) -p ($name+"Offset"+$side) transform;
parent ($name+$side) ("SDK"+$name+$side);

if ($type==4)
	{
	select -cl;
	joint -n ($name+"Joint"+$side);
	}

connectAttr ("ctrlBox."+$letter+"CtrlVis") ($name+$side+"Shape.overrideVisibility");
}

global proc asFacePlaceCtrlByProjection (string $ctrl)
{
int $numCv;
float $offset,$rad,$ry,$posZ;
float $maxZ=-999;
float $pos[],$dir[],$wScale[];
float $faceFitScale=`getAttr FaceFitSkeleton.faceScale`;
//string $geometry=`textField -q -tx asFaceFaceTextField`;
string $name,$side;
string $tempString[],$curves[];

tokenize $ctrl "_" $tempString;
$name=$tempString[0];
$side="_"+$tempString[1];
$ry=`getAttr ($name+"Offset"+$side+".ry")`;

$rad=deg_to_rad($ry);
$dir[0]=sin($rad);
$dir[1]=0;
$dir[2]=cos($rad);

if (`gmatch $ctrl "*_R"`)
	$dir[0]*=-1;

$tempString=`polyProjectCurve -ch true -direction $dir[0] $dir[1] $dir[2] -pointsOnEdges 0 -tolerance 0.01 $ctrl allHeadCombinedLayer`;
createNode -n cvPos -p $ctrl transform;
$curves=`listRelatives -c -type transform $tempString[0]`;
for ($i=0;$i<size($curves);$i++)
	{
	//get MaxTz for each cv
	$numCv=`asGetCurveNumCvs $curves[$i]`;
//	for ($y=0;$y<$numCv+1;$y++)
	for ($y=0;$y<$numCv;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] cvPos;
		$posZ=`getAttr cvPos.tz`;
		if ($posZ>$maxZ)
			$maxZ=$posZ;
		}
	}
delete cvPos;
delete $tempString[0];
//$pos=`xform -q -ws -t ($ctrl+".cv[0]")`;
$wScale=`xform -q -ws -s $ctrl`;
move -r -os -wd 0 0 ($maxZ*$wScale[0]) ($ctrl+".cv[0:99]");
}

global proc asFaceControlOrient (string $ctrl)
{
string $name,$side;
string $tempString[];
if (!`objExists FaceControlOrient`)
	return;

tokenize $ctrl "_" $tempString;
$name=$tempString[0];
$side="_"+$tempString[1];

delete `normalConstraint -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 FaceControlOrient ($name+"Offset"+$side)`;
}

global proc asFaceSoftModToSkinWeights (string $softMod, string $joint, string $ctrl, string $skinCluster, string $geometry)
{
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
float $falloffRadius;
float $onFaceCtrlScale=`getAttr OnFacecontrols.sx`;
float $pos[],$posA[],$posB[];
string $sel[]=`ls -sl`;
string $tempString[];

$pos=`xform -q -ws -t $joint`;
$falloffRadius=`getAttr ($softMod+".falloffRadius")`;
select $geometry;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl -fl`;
polySelectConstraint -m 0;
setAttr ($ctrl+".t") -type float3 0 0 0;
for ($i=0;$i<size($tempString);$i++)
	{
	setAttr ($ctrl+".ty") 0;
	$posA=`xform -q -ws -t $tempString[$i]`;
	setAttr ($ctrl+".ty") (1.0/$onFaceCtrlScale);
	$posB=`xform -q -ws -t $tempString[$i]`;
	catchQuiet (`skinPercent -tv $joint ($posB[1]-$posA[1]) $skinCluster $tempString[$i]`);
	}
setAttr ($ctrl+".t") -type float3 0 0 0;

if ($autoKeyState)
	autoKeyframe -state 1;
select $sel;
}

global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
setAttr ($softModHandle+".ty") 1;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
string $componentType="vtx";

string $deformMeshs[]=`ls -o $vtxs`;
$deformMeshs=`stringArrayRemoveDuplicates $deformMeshs`;
string $deformXforms[];
for ($i=0;$i<size($deformMeshs);$i++)
	{
	$tempString=`listRelatives -p $deformMeshs[$i]`;
	$deformXforms[$i]=$tempString[0];
	}
setAttr ($softMod+".envelope") 0;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshA"+$i) $deformMeshs[$i];
setAttr ($softMod+".envelope") 1;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshB"+$i) $deformMeshs[$i];
float $posA[3];
float $posB[3];
for ($i=0;$i<size($deformMeshs);$i++)
    {
		$componentType="vtx";
		if (`objectType $deformMeshs[$i]`=="lattice")
			$componentType="pt";
    string $historyNodes[]=`listHistory $deformMeshs[$i]`;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 1;
    percent -v 0 $cluster ($deformMeshs[$i]+"."+$componentType+"[0:999999]");
    for ($y=0;$y<size($vtxs);$y++)
        {
        if (!`gmatch $vtxs[$y] ($deformXforms[$i]+"[.]"+$componentType+"*")`)
            continue;
        tokenize $vtxs[$y] "." $tempString;
        $posA=`xform -q -ws -t ("tempMeshA"+$i+"."+$tempString[1])`;
        $posB=`xform -q -ws -t ("tempMeshB"+$i+"."+$tempString[1])`;
        percent -v ($posB[1]-$posA[1]) $cluster $vtxs[$y];
        }
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 0;
     }
for ($i=0;$i<size($deformMeshs);$i++)
	delete ("tempMeshA"+$i) ("tempMeshB"+$i);
clear $vtxs;
}

global proc string asFaceMirror ()
{
string $restoreCmd,$oppositeControl;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
string $mirrorAttrs[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
string $controls[]=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (!`gmatch $controls[$i] "*_L"`)
		continue;
	for ($attr in $mirrorAttrs)
		{
		if (`getAttr -l ($controls[$i]+"."+$attr)`)
			continue;
		$oppositeControl=`substitute "_L" $controls[$i] "_R"`;
		$multiply=1;
		if ($attr=="tx" || $attr=="ry" || $attr=="rz")
			$multiply=-1;
	
		$restoreCmd+="setAttr "+$controls[$i]+"."+$attr+" "+`getAttr ($controls[$i]+"."+$attr)`+";";
		setAttr ($controls[$i]+"."+$attr) (`getAttr ($oppositeControl+"."+$attr)`*$multiply);
		}
	}
if ($autoKeyState)
	$restoreCmd+="autoKeyframe -state 1;";
return $restoreCmd;
}

global proc asFaceMirrorControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
float $pos[]=`getAttr ($sel[0]+".t")`;
float $rot[]=`getAttr ($sel[0]+".r")`;
float $sca[]=`getAttr ($sel[0]+".s")`;
	asGoToBuildPose faceSetup;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	print "// Detected this controller to control a \"Cluster\", performing Mirror Cluster Weights\n";
	asFaceMirrorClusterWeight;
	}
else
	{
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	print "Detected this controller to control a \"Joint\", performing Mirror Skin Weights";
	}
setAttr -type float3 ($sel[0]+".t") $pos[0] $pos[1] $pos[2];
setAttr -type float3 ($sel[0]+".r") $rot[0] $rot[1] $rot[2];
setAttr -type float3 ($sel[0]+".s") $sca[0] $sca[1] $sca[2];
select $sel;
}

global proc asFaceMirrorClusterWeight ()
{
string $sel[]=`ls -sl`;
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a faceControl";
string $control=$sel[0];

string $restorePoseCmd;
int $multiply;
int $numVtxs[]=`polyEvaluate -v ClustersRegion`;
float $maxDist,$mag;
float $posA[3],$posB[3],$tempFloat[];
string $tempString[],$rightVtxs[];
string $cluster=`substitute "_R" $control "Cluster_R"`;
string $oppositeControl=`substitute "_R" $control "_L"`;
string $oppositeCluster=`substitute "_R" $cluster "_L"`;
if (!`gmatch $control "*_R"` || !`objExists $oppositeCluster`)
	return;
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$cluster+"Set";
string $oppositeClusterSet=`substitute "_R" $clusterSet "_L"`;
if (!`objExists $oppositeClusterSet`)
	return;

//Start off by pruning
setAttr -type float3 ($control+".t") 1 0 0;
cluster -e -pr $cluster;
setAttr -type float3 ($control+".t") 0 0 0;

//Mirror pose before doing left to ensure identical attachment
string $restoreCmd=`asFaceMirror`;

percent -v 0 $oppositeCluster ("ClustersRegion.vtx[0:"+$numVtxs[0]+"]");
select `sets -q ($cluster+"Set")`;
$rightVtxs=`ls -sl -fl`;
$posA=`xform -q -ws -t $control`;
$maxDist=0;
for ($i=0;$i<size($rightVtxs);$i++)
	{
	$posB=`xform -q -ws -t $rightVtxs[$i]`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>$maxDist)
		$maxDist=$mag;
	}
$maxDist=$maxDist+($maxDist/20.0);

select ClustersRegion;
sets -add ($oppositeCluster+"Set") ClustersRegion;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($posA[0]*-1) $posA[1] $posA[2];
string $vtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
//sets -add ($oppositeCluster+"Set") $vtxs;
string $closestSampler=`createNode -n closestSampler closestPointOnMesh`;
$tempString=`listRelatives -ni -s ClustersRegion`;
connectAttr -f ($tempString[0]+".outMesh") ($closestSampler+".inMesh");
connectAttr -f ("ClustersRegion.worldMatrix[0]") ($closestSampler+".inputMatrix");
int $closestOppositeVtxNr;
global string $gMainProgressBar;
progressBar -e -st ("Mirroring Cluster for: "+$control) -bp -ii 1 -min 0 -max `size($vtxs)` $gMainProgressBar;
for ($i=0;$i<size($vtxs);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		break;
	progressBar -e -s 1 $gMainProgressBar;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	setAttr -type float3 ($closestSampler+".inPosition") ($posB[0]*-1) $posB[1] $posB[2];
	$closestOppositeVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	$tempFloat=`percent -q -v $cluster ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`;

	if (!`sets -im $clusterSet ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`)
		$tempFloat[0]=0;

	percent -v $tempFloat[0] $oppositeCluster $vtxs[$i];
	}
progressBar -e -ep $gMainProgressBar;
setAttr -type float3 ($oppositeControl+".t") 1 1 1;
cluster -e -pr $oppositeCluster;
setAttr -type float3 ($oppositeControl+".t") 0 0 0;
delete $closestSampler;

eval ($restoreCmd);
}

global proc asHelpImage (string $region)
{
string $asScriptLocation=`asGetScriptLocation`;
if (`window -q -ex asHelpImageWindow`)
	deleteUI asHelpImageWindow;
window -t "AdvancedSkeleton Help" asHelpImageWindow;
scrollLayout -w 650 -h 10;

if (`gmatch $region "*asBSWizardStep*"`)
	$region="asBSWizard/"+$region;

formLayout asHelpFormLayout;
image -i ($asScriptLocation+"/AdvancedSkeletonFiles/div/images/help/"+$region+".jpg") asHelpImage;

formLayout -e
	-af asHelpImage "right" 0
	-af asHelpImage "left" 0
	-af asHelpImage "top" 0
	-af asHelpImage "bottom" 0
	asHelpFormLayout;

//Video Link
string $helpUrl;
string $buttonLabel="Open Video Link";
if ($region=="asDeformSkinCageSliders")
	$helpUrl="https://youtu.be/uMaKwxKXygw";
if ($region=="asFitLabels")
	$helpUrl="https://youtu.be/fyR2szfj3z0";
if ($region=="asFitAttributes")
	$helpUrl="https://youtu.be/WgJsDv1ZdVs";
if ($region=="asDeformSkinCageDWidth")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=153";
if ($region=="asDeformSubWrapCage" || $region=="asDeformSubWrapWrap")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=280";
if ($region=="asDeformSkinLoopsCreate" || $region=="asDeformSkinLoopsSelectAll"
	|| $region=="asDeformSkinLoopsBind" || $region=="asDeformSkinLoopsCutUp")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=151";
if ($region=="asMotionCaptureReadBvh" || $region=="asMotionCaptureConnect")
	{
	$helpUrl="https://sites.google.com/a/cgspeed.com/cgspeed/motion-capture/cmu-bvh-conversion";
	$buttonLabel="Open Link";
	}
if ($region=="asCorrectiveShapesCreate")
	$helpUrl="https://youtu.be/YOIyFB2nK90";
if ($region=="asCorrectiveShapesBake")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=327";
if ($region=="faceFitSkeletonNode")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=357";
if ($region=="asEditBlendShapesCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=663";
if ($region=="asTweakControllersCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=743";
if ($region=="asSelectorDesigner")
	$helpUrl="https://youtu.be/0dpLmKZbEJc";
if ($region=="fitFaceMouthSculpt")
	$helpUrl="https://youtu.be/punjwECuUJM?t=282";
if ($region=="asExportWonderStudio")
	{
	$helpUrl="https://wonderdynamics.com/";
	$buttonLabel="Open Link";
	}
if ($region=="asPoserDesigner")
	{
	$helpUrl="https://www.studiolibrary.com/";
	$buttonLabel="Open Link";
	}
if ($region=="asNameMatcher")
	$helpUrl="https://youtu.be/S_9Z3iE9QtM";
if ($region=="ControlOrientAxis")
	$helpUrl="https://youtu.be/gmjTmXhXPzs";
if ($region=="asFitAutoPlace")
	$helpUrl="https://youtu.be/mnYIlDxvQcI";
if ($region=="asOffsetParentMatrix")
	$helpUrl="https://youtu.be/iYTfh0PF-xo";



if ($helpUrl!="")
	{
	string $button=`button -w 200 -h 50 -l $buttonLabel -c ("showHelp -a \""+$helpUrl+"\"")`;
	formLayout -e
		-af $button "top" 715
		-af $button "left" 220
		asHelpFormLayout;
	if ($region=="asFitLabels" || $region=="asFitAttributes") formLayout -e -af $button "top" 40  asHelpFormLayout;
	}
showWindow;
window -e -h 808 asHelpImageWindow;
}

global proc asFaceCreateCtrlBox (string $name, float $x, float $y, int $half)
{
float $scale;
$tempString=`duplicate -rc ctrlBoxTemplate`;
rename $tempString[0] ("ctrlBox"+$name);
rename $tempString[1] ("ctrl"+$name);
setAttr -type float3 ("ctrlBox"+$name+".t") $x $y 0;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransYLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransYLimitEnable")`);

asEnsureOutputBlendWeighted ("ctrl"+$name+".tx");
asEnsureOutputBlendWeighted ("ctrl"+$name+".ty");

if ($half)
	{
	float $pos0[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[0]")`;
	float $pos2[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[2]")`;
	float $pos3[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[3]")`;
	if ($half==1)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[2]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos3[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[3]");
		transformLimits -tx -1 1 -ty 0 1 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	if ($half==2)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[1]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[0]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[4]");
		transformLimits -tx -1 1 -ty -1 0 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	}
}

global proc asRemoveInfluence (string $joint, string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
string $infJoints[]=`listConnections -s 1 -d 0 ($skinCluster+".matrix")`;
if (`stringArrayCount $joint $infJoints`)
	{
	skinCluster -e -ri $joint $skinCluster;
	//If no other influences, then remove skinCluster.
	if (size($infJoints)==1)
		delete $skinCluster;
	}
}

global proc asFaceSwitchSide (int $right)
{ 
//$right==2 = Off
if (!`objExists FaceFitSkeleton`)
	return;
int $vis;

if ($right==0)
	{
	setAttr "FaceFitSkeleton.NonSym" 1;
	setAttr -type "string" FaceFitSkeleton.NonSymSide "Left";
	}
if ($right==1)
	{
	setAttr "FaceFitSkeleton.NonSym" 1;
	setAttr -type "string" FaceFitSkeleton.NonSymSide "Right";
	}
if ($right==2)
	{
	setAttr "FaceFitSkeleton.NonSym" 0;
	setAttr -type "string" FaceFitSkeleton.NonSymSide "";
	}

string $tempString[]=`listRelatives -c -type transform FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*Left"`)
		$vis=!`clamp 0 1 $right`;
	else
		$vis=`clamp 0 1 $right`; 
	setAttr ($tempString[$i]+".v") $vis;
	}

asFaceUpdateInfo 1;
}

global proc asFaceShowBothSides ()
{
string $tempString[]=`listRelatives -c -type transform FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;
}

global proc string asFaceGetGeometry ()
{
string $faceFace=`textField -q -tx asFaceFaceTextField`;
string $tempString[]=`stringToStringArray $faceFace " "`;
$tempString=`ls -o $tempString[0]`;
$tempString=`listRelatives -p $tempString[0]`;
string $geometry=$tempString[0];
return $geometry;
}

global proc string[] asFaceGetAllHead ()
{
string $allHead[];
string $allHeadString=`textField -q -tx asFaceAllHeadTextField`;
string $tempString[];
tokenize $allHeadString $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!="")
		$allHead[size($allHead)]=$tempString[$i];
return $allHead;
}

global proc asFaceBuildFitStep (string $name, string $type, string $shadingGroup)
{
if ($type=="patch")
	asFaceBuildFitPatch $name $shadingGroup;
if ($type=="custom")
	eval ("asFaceBuildFit"+$name);
asFaceUpdateInfo 1;
}

global proc asBuildFitEyeBall ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $eyeGeoText=`textField -q -tx asFaceRightEyeTextField`;
string $dialog="OK";
string $leftSuffix;
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSymSide`=="Left")
		{
		$leftSuffix="Left";
		$eyeGeoText=`textField -q -tx asFaceLeftEyeTextField`;
		}
string $tempString[],$tempString2[],$eyeGeos[];
if ($eyeGeoText=="")
	error "No Eye Geometry choosen";
if (`objExists ("FitEyeBall"+$leftSuffix)`)
	error ("FitEyeBall"+$leftSuffix+" already exists");
int $hadBodyEye=0;
int $eyeVis;
float $pos[],$rot[];
if (`objExists Eye_R`)
	{
	if (!`objExists headTopology` && !`objExists asBatch`)
		$dialog=`confirmDialog -t "Confirm"
			-m "This will replace the Eyes from the Body-setup"
			-b "OK" -db "OK"
			-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	$hadBodyEye=1;
	string $skinClusters[]=`ls -type skinCluster`;
	for ($i=0;$i<size($skinClusters);$i++)
		{
		//rare case, the EyeEnd joints could be bound, )doing Jaw-end check&remove here too)
		if (`objExists EyeEnd_R`) asRemoveInfluence EyeEnd_R $skinClusters[$i];
		if (`objExists EyeEnd_L`) asRemoveInfluence EyeEnd_L $skinClusters[$i];
		if (`objExists JawEnd_M`) asRemoveInfluence JawEnd_M $skinClusters[$i];
		//First add Head as inf (if Eye is only inf), since having none inf`s breaks the skinCluster
		$tempString=`listConnections ($skinClusters[$i]+".matrix")`;
		if (size($tempString)==1 && `gmatch $tempString[0] "Eye_*"`) {
			skinCluster -e -ai $headJoint -lw false -wt 1 $skinClusters[$i];
			print ("skinCluster -e -ai "+$headJoint+" -lw false -wt 1 "+$skinClusters[$i]+";\n");
			}
		if (`objExists Eye_R`) asRemoveInfluence Eye_R $skinClusters[$i];
		if (`objExists Eye_L`) asRemoveInfluence Eye_L $skinClusters[$i];
		}
	$pos=`xform -q -ws -t Eye_R`;
	$rot=`xform -q -ws -ro Eye_R`;
	if (`objExists FKOffsetEye_R`) delete FKOffsetEye_R;
	if (`objExists FKOffsetEye_L`) delete FKOffsetEye_L;
	if (`objExists FKAimEye_R`) delete FKAimEye_R;
	if (`objExists FKAimEye_L`) delete FKAimEye_L;
	if (`objExists Eye_R`)delete Eye_R;
	if (`objExists Eye_L`) delete Eye_L;
	if (`objExists AimEye`) delete AimEye;
	if (`objExists Eye`) delete Eye;
	asRemoveUnusedfromBuildPose bodySetup;
	}
float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
asFitModeEnsureShaders;
spaceLocator -n ("FitEyeBall"+$leftSuffix);
addAttr -ln version -at double ("FitEyeBall"+$leftSuffix);
setAttr -l 1 ("FitEyeBall"+$leftSuffix+".version") `asGetScriptVersion`;
setAttr ("FitEyeBall"+$leftSuffix+".rotateOrder") 2;
setAttr -l 1 ("FitEyeBall"+$leftSuffix+".rz");
setAttr -type float3 ("FitEyeBall"+$leftSuffix+"Shape.localScale") 1.5 1.5 1.5;
createNode -n ("FaceFitEyeBall"+$leftSuffix) -p FaceFitSkeleton transform;
//setAttr ("FaceFitEyeBall"+$leftSuffix+".inheritsTransform") 0;
parent ("FitEyeBall"+$leftSuffix) ("FaceFitEyeBall"+$leftSuffix);
polySphere -n ("FitEyeSphere"+$leftSuffix) -r 0.5 -sx 8 -sy 8 -ax 0 1 0 -cuv 2 -ch 0;
setAttr ("FitEyeSphere"+$leftSuffix+".overrideEnabled") 1;
setAttr ("FitEyeSphere"+$leftSuffix+".overrideDisplayType") 2;
parent ("FitEyeSphere"+$leftSuffix) ("FitEyeBall"+$leftSuffix);
sets -e -forceElement asWhiteSG ("FitEyeSphere"+$leftSuffix);
sets -e -forceElement asBlackSG ("FitEyeSphere"+$leftSuffix+".f[56:63]");
setAttr -type float3 ("FitEyeSphere"+$leftSuffix+".r") 90 0 0;
setAttr -type float3 ("FitEyeBall"+$leftSuffix+".s") (0.025*$height) (0.025*$height) (0.025*$height);

if ($hadBodyEye)
	{
	//Removed since non-default Pri/Sec Axis options will orient incorrectly
//	xform -ro ($rot[2]-180) ($rot[1]-90) 0 ("FitEyeBall"+$leftSuffix);
	xform -ws -t $pos[0] $pos[1] $pos[2] ("FitEyeBall"+$leftSuffix);
	}
else
	{
	$pos=`xform -q -ws -t $headJoint`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("FitEyeBall"+$leftSuffix);
	setAttr -type float3 ("FitEyeBall"+$leftSuffix+".t") ($pos[1]/-50.0) ($pos[1]/15.0) ($pos[1]/15.0);
	}

//guestimate placement (and scale) based upon 1st selected geo
tokenize $eyeGeoText $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*[.]*"`)
		$eyeGeos[size($eyeGeos)]=$tempString[$i];
if (!size($eyeGeos) && `gmatch $eyeGeoText "*[.]*"`)//eye part of main mesh
	{
	select `ls -o $tempString[0]`;
	$tempString2=`duplicate`;
	rename $tempString2[0] asDuplicatedEye;
	select `asobjSetCast "" $tempString asDuplicatedEye`;
	asInvertSelection;
	delete;
	$eyeGeos[0]=$tempString[0]="asDuplicatedEye";
	}
if (size($eyeGeos))
	{
	if (!$eyeVis)
		setAttr ($tempString[0]+".v") 1;
	$tempString=`duplicate -n tempEye $eyeGeos[0]`;
	$tempString2=`listRelatives -p $tempString[0]`;
	if ($tempString2[0]!="")
		$tempString=`parent -w $tempString[0]`;
	select $tempString[0];
	$eyeVis=`getAttr ($tempString[0]+".v")`;
	CenterPivot;
	if (!$eyeVis)
		setAttr ($tempString[0]+".v") 0;
	float $pos[]=`xform -q -ws -piv $tempString[0]`;
	float $bb[]=`xform -q -ws -bb $tempString[0]`;
	delete $tempString[0];
	if ($pos[1]>0)
		{
		parent -w ("FitEyeBall"+$leftSuffix);
		if (!$hadBodyEye)
			xform -ws -t $pos[0] $pos[1] $pos[2] ("FitEyeBall"+$leftSuffix);
		xform -os -s ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ("FitEyeBall"+$leftSuffix);
		parent ("FitEyeBall"+$leftSuffix) ("FaceFitEyeBall"+$leftSuffix);
		}
	if (`objExists asDuplicatedEye`)
		delete asDuplicatedEye;
//	if ($leftSuffix=="Left")
//		setAttr ("FitEyeBall"+$leftSuffix+".tx") (`getAttr ("FitEyeBall"+$leftSuffix+".tx")`*-1);
	}

//Now lock FaceFitSkeleton, it is not to be changed once fitting started
asLockAttr FaceFitSkeleton 1 1 1 0;

asFaceUpdateInfo 1;
select ("FitEyeBall"+$leftSuffix);
print ("// FitEyeBall"+$leftSuffix+" created, place this to match the eye-ball of your character\n");
//checkBox -e -ed 1 -v 1 asFaceFitEyeBall;
}

global proc asFaceEnsureShaders ()
{
string $colors[]={"asFaceBlue","asFaceBrown","asFaceGreen","asFaceCyan","asFaceRed"};
float $rs[]={0.0,0.541,0.000,0.0,0.4};
float $gs[]={0.0,0.282,0.275,0.5,0};
float $bs[]={1.0,0.200,0.098,0.5,0};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".ambientColor") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".incandescence") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asFaceEnsureAdvancedBase ()
{
int $opm=`asGetOpm`;
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;

asFaceEnsureShaders;
string $sel[]=`ls -sl`;
if (!`objExists FaceGroup`)
	error "FaceGroup does not exists, must build a Fit-system first";
//float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
$maskString=`getAttr FaceFitSkeleton.Mask`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $tempString[];
if (!`objExists $headJoint`)
	error ("HeadJoint: \""+$headJoint+"\" Does not exists");
if (`objExists FaceMotionSystem`)
	setAttr FaceMotionSystem.v 1;
if (`objExists FaceMotionSystem`)
	return;

//top level nodes
createNode -n FaceMotionSystem -p FaceGroup transform;
asAlign FaceMotionSystem $headJoint 1 0 0 0;
createNode -n ControlsSetup -p FaceMotionSystem transform;
createNode -n ConstrainedSetup -p FaceMotionSystem transform;
createNode -n DeformJointConstraints -p ConstrainedSetup transform;
//	createNode -n FaceStatic -p ConstrainedSetup transform;
//setAttr ControlsSetup.s -type float3 ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
createNode -n FaceDeformationSystem -p FaceGroup transform;
setAttr -l 1 FaceDeformationSystem.v 0;
createNode -n FaceDeformationFollowHead -p FaceDeformationSystem transform;
asAlign FaceDeformationFollowHead $headJoint 1 0 0 0;
createNode -n JawSetup -p FaceDeformationFollowHead transform;

createNode -n JawFollowSideReverse_R -p JawSetup transform;
createNode -n JawFollowSideReverse_L -p JawSetup transform;
createNode -n JawFollowSideReverse_M -p JawSetup transform;
createNode -n JawFollow_R -p JawFollowSideReverse_R transform;
createNode -n JawFollow_L -p JawFollowSideReverse_L transform;
createNode -n JawFollow_M -p JawFollowSideReverse_M transform;
createNode -n JawStatic_M -p JawFollowSideReverse_M transform;
setAttr JawFollowSideReverse_R.sx -1;

createNode -n SideReverseSetup -p ConstrainedSetup transform;

createNode -n SideReverseSetup_M -p SideReverseSetup transform;
	createNode -n FaceStatic_M -p SideReverseSetup_M transform;
	createNode -n middleFaceStatic_M -p SideReverseSetup_M transform;
	createNode -n lowerFaceStatic_M -p SideReverseSetup_M transform;
createNode -n SideReverseSetup_R -p SideReverseSetup transform;
	createNode -n FaceStatic_R -p SideReverseSetup_R transform;
	createNode -n middleFaceStatic_R -p SideReverseSetup_R transform;
	createNode -n lowerFaceStatic_R -p SideReverseSetup_R transform;
createNode -n SideReverseSetup_L -p SideReverseSetup transform;
	createNode -n FaceStatic_L -p SideReverseSetup_L transform;
	createNode -n middleFaceStatic_L -p SideReverseSetup_L transform;
	createNode -n lowerFaceStatic_L -p SideReverseSetup_L transform;

setAttr SideReverseSetup_R.sx -1;

createNode -n Aimcontrols -p ControlsSetup transform;
createNode -n OnFacecontrols -p ControlsSetup transform;
	createNode -n SideReverse_R -p OnFacecontrols transform;
	createNode -n SideReverse_L -p OnFacecontrols transform;
	createNode -n SideReverse_M -p OnFacecontrols transform;
setAttr SideReverse_R.sx -1;
createNode -n Regionscontrols -p ControlsSetup transform;
createNode -n Customcontrols -p ControlsSetup transform;

createNode -n FaceBuildInProgress transform;
createNode -n FaceBuildInProgressHidden -p FaceBuildInProgress transform;
setAttr FaceBuildInProgressHidden.v 0;
createNode -n DeformationLayers -p FaceDeformationSystem transform;

//templateLayer
duplicate -n templateLayer $geometry;
asLockAttr templateLayer 0 0 0 0;
parent templateLayer DeformationLayers;
sets -e -forceElement initialShadingGroup templateLayer;
$tempString=`listRelatives -s -f templateLayer`; 
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
setAttr templateLayer.v 0;

//allHeadCombinedLayer
//asSelectFromTextField asFaceAllHeadTextField;//echos
eval ("select "+$allFaceGeoString);
duplicate -rr;
//parent -w;
$tempString=`ls -sl`;
if (size($tempString)>1)
	{
	polyUnite -ch 0 -mergeUVSets 1 -name allHeadCombinedLayer;
	delete $tempString;
	}
else
	rename $tempString[0] allHeadCombinedLayer;
parent allHeadCombinedLayer DeformationLayers;
sets -e -forceElement initialShadingGroup allHeadCombinedLayer;
$tempString=`listRelatives -s -f allHeadCombinedLayer`; 
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
setAttr allHeadCombinedLayer.v 0;

createNode -n MainAndHeadScaleMultiplyDivide multiplyDivide;
setAttr MainAndHeadScaleMultiplyDivide.input1 -type float3 1 1 1;
if (`objExists MainScaleMultiplyDivide`)
	connectAttr MainScaleMultiplyDivide.output MainAndHeadScaleMultiplyDivide.input1;
else if (`objExists Main`)//backwards compatability, for body rig older then 5.732
	connectAttr Main.s MainAndHeadScaleMultiplyDivide.input1;

//special case, MainScaleMultiplyDivide could exists, but body rig removed, leaving input at zero, cauing large values errors
if (`objExists MainScaleMultiplyDivide`)
	if (`getAttr -se MainScaleMultiplyDivide.input1X`)
		setAttr MainScaleMultiplyDivide.input1 -type float3 1 1 1;

connectAttr ($headJoint+".scale") MainAndHeadScaleMultiplyDivide.input2;


//v6.2825 modified from just asParentConstraint, to special case for !$opm, since scaleConstraint is incorrect with IK-Neck
if ($opm)
	{
	asParentConstraint $headJoint FaceMotionSystem "-mo";
	asParentConstraint $headJoint FaceDeformationFollowHead "-mo";
	}
else
	{
	parentConstraint -mo $headJoint FaceMotionSystem;
	parentConstraint -mo $headJoint FaceDeformationFollowHead;
	connectAttr MainAndHeadScaleMultiplyDivide.output FaceMotionSystem.s;
	connectAttr MainAndHeadScaleMultiplyDivide.output FaceDeformationFollowHead.s;
	}

//faceBuildPose
if (!`objExists faceBuildPose`)
	{
	createNode -n faceBuildPose dagPose;
	addAttr -ln udAttr -dt "string"  faceBuildPose;
	}

//Sets
select -cl;
sets -name FaceAllSet;
sets -name FaceControlSet;
sets -em -n FaceAreas;
if (`objExists "Sets"`)
	{
	sets -add "Sets" FaceAllSet;
	sets -add "Sets" FaceControlSet;
	sets -add "Sets" FaceAreas;
	}
sets -em -n FaceBuildingSets;
sets -add FaceAllSet FaceBuildingSets;
sets -add FaceBuildingSets allBeforeFaceBuild;

select $sel;
}

global proc asFaceAddMetaHumanControlPanel ()
{
float $s,$version,$mult;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $pos1[],$pos2[];
string $side,$UD,$upperLower;
string $asScriptLocation=`asGetScriptLocation`;
string $mhFile=$asScriptLocation+"/AdvancedSkeletonFiles/div/asMetaHuman.ma";
string $tempString[],$tempString2[],$drivingSystems[],$attrs[];
string $hideObjs[]={"ctrlBoxOffset","ctrlBox2Offset","EyeBrowRegion1_RShape","EyeBrowRegion1_LShape",
	"EyeRegion1_RShape","EyeRegion1_LShape","Eye1_RShape","Eye1_LShape","NoseRegion1_MShape","LipRegion1_MShape",
	"upperFace1_MShape","middleFace1_MShape","lowerFace1_MShape","upperTeeth1_MShape","lowerTeeth1_MShape",
	"Tongue11_MShape","Tongue21_MShape","Tongue31_MShape"};

if (!`file -q -ex $mhFile`)
	error ("File:\""+$mhFile+"\" not found");

asGoToBuildPose faceSetup;
refresh;

if (`objExists GRP_faceGUI`)
	{
	delete GRP_faceGUI MetaHumanControlPanelToggle;
	print ("// MetaHuman ControlPanel Removed.\n");
	return;
	}

if (`attributeExists version FaceGroup`)
	$version=`getAttr FaceGroup.version`;
if ($version<6.055)
	if (`confirmDialog -title "Confirm" -message 
		("AdvancedSkeleton FaceSetup version:"+$version+" detected.\n\n"
		+"It is recommneded to use this function on FaceRigs\n"
		+"that are built with version 6.055 ( or higher )\n")
	    -button "Continue Anyway" -button "Cancel" -defaultButton "Cancel"
	    -cancelButton "Cancel"`!="Continue Anyway")
		return;

if (!`objExists asGreen2SG` || !`objExists asBlackSG`)
	asFaceEnsureShaders;

circle -n MetaHumanControlPanelToggle -c 0 0 0 -nr 0 0 1 -sw 360 -r ($scale/30.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0;
rotate -r -p 0 0 0 -os 0 0 110 MetaHumanControlPanelToggle.cv[1] MetaHumanControlPanelToggle.cv[3] MetaHumanControlPanelToggle.cv[5] MetaHumanControlPanelToggle.cv[7];
rotate -r -p 0 0 0 -os 0 0 11.7 MetaHumanControlPanelToggle.cv[0:99];
setAttr MetaHumanControlPanelToggleShape.overrideEnabled 1;
setAttr MetaHumanControlPanelToggleShape.overrideColor 13;
$pos1=`xform -q -ws -t ctrlBoxShape.cv[3]`;
xform -ws -t ($pos1[0]*0.84) $pos1[1] $pos1[2] MetaHumanControlPanelToggle;
parent MetaHumanControlPanelToggle ControlsSetup;
asLockAttr MetaHumanControlPanelToggle 1 1 1 1;
addAttr -k 1 -ln MetaHumanControlPanelVis -at bool -dv 1 MetaHumanControlPanelToggle;
createNode -n MetaHumanControlPanelVisReverse reverse;
connectAttr MetaHumanControlPanelToggle.MetaHumanControlPanelVis MetaHumanControlPanelVisReverse.inputX;
for ($i=0;$i<size($hideObjs);$i++)
	if (`objExists ($hideObjs[$i])`)
		connectAttr MetaHumanControlPanelVisReverse.outputX ($hideObjs[$i]+".v");

file -i -rpr "asImport" $mhFile;
parent GRP_faceGUI ControlsSetup;
connectAttr MetaHumanControlPanelToggle.MetaHumanControlPanelVis GRP_faceGUI.v;
asAlign GRP_faceGUI ctrlBox 1 0 0 0;
asAlign FRM_faceGUI ctrlBox 1 0 0 0;
$pos1=`xform -q -ws -t ctrlBoxShape.cv[1]`;
$pos2=`xform -q -ws -t ctrlBoxShape.cv[3]`;
$s=($pos1[1]-$pos2[1])/32.0;
setAttr FRM_faceGUI.s -type float3 $s $s $s;
setAttr GRP_faceGUI.tx ($pos1[0]*1.1);
setAttr GRP_faceGUI.ty ($pos1[0]*-0.6);

if (`objExists CTRL_faceGUIShape`) delete CTRL_faceGUIShape;
if (`objExists GRP_neckSetupGUI`) delete GRP_neckSetupGUI;
if (`objExists FacialControls`) delete FacialControls;

$tempString=`listRelatives -ad -type mesh FRM_faceGUI`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`getAttr ($tempString[$i]+".overrideDisplayType")`==2)
		sets -e -forceElement asBlackSG $tempString[$i];
	else
		sets -e -forceElement asGreen2SG $tempString[$i];
	setAttr ($tempString[$i]+".isHistoricallyInteresting") 0;
	$tempString2=`listRelatives -p $tempString[$i]`;
	if (`gmatch $tempString2[0] "CTRL_*_*"` && `getAttr ($tempString[$i]+".overrideDisplayType")`!=2)
		sets -add FaceControlSet $tempString2[0];
	}

//asEnsureOutputBlendWeighted
$drivingSystems=`asDsGetDrivingSystems`;
for ($i=0;$i<size($drivingSystems);$i++)
	if (`gmatch $drivingSystems[$i] "CTRL_*_*"`)
		{
		$attrs=`asDsGetAttrs $drivingSystems[$i]`;
		for ($y=0;$y<size($attrs);$y++)
			{
			$tempString[0]=`asEnsureOutputBlendWeighted ($drivingSystems[$i]+"."+$attrs[$y])`;
			setAttr ($tempString[0]+".isHistoricallyInteresting") 0;
			}
		}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b== 1) $side="_R";
	if ($b==-1) $side="_L";

	asDsSdk ("CTRL"+$side+"_eye.tx") ("ctrlEye"+$side+".tx") 1 1;
	asDsSdk CTRL_C_eye.tx ("ctrlEye"+$side+".tx") 1 1;
	asDsSdk ("CTRL"+$side+"_eye.ty") ("ctrlEye"+$side+".ty") 1 1;
	asDsSdk CTRL_C_eye.ty ("ctrlEye"+$side+".ty") 1 1;

	asDsSdk ("CTRL"+$side+"_eye_pupil.ty") ("ctrlEye"+$side+".pupil") 1 5;
	asDsSdk ("CTRL"+$side+"_eye_blink.ty") ("ctrlEye"+$side+".blink") 1 10;

	asDsSdk ("CTRL"+$side+"_brow_raiseOut.ty")  ("ctrlBrow"+$side+".outerUpDown") 1 10;
	asDsSdk ("CTRL"+$side+"_brow_raiseIn.ty")  ("ctrlBrow"+$side+".tx") 1 1;
	asDsSdk ("CTRL"+$side+"_brow_lateral.ty")  ("ctrlBrow"+$side+".squeeze") 1 10;
	asDsSdk ("CTRL"+$side+"_brow_down.ty")  ("ctrlBrow"+$side+".tx") 1 -0.9;
	asDsSdk ("CTRL"+$side+"_brow_down.ty")  ("ctrlBrow"+$side+".ty") 1 -0.1;

	asDsSdk ("CTRL"+$side+"_eye_cheekRaise.ty")  ("ctrlEye"+$side+".squint") 1 10;

	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKlowerLid"+$side+".tx") 1 -0.3;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKlowerLid"+$side+".ty") 1 0.4;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKupperLid"+$side+".ty") 1 -0.15;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKlowerLidOuter"+$side+".tx") 1 -0.3;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKlowerLidOuter"+$side+".ty") 1 0.2;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKinnerLidOuter"+$side+".sx") 1 0.2;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKinnerLidOuter"+$side+".sy") 1 0.2;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKinnerLidOuter"+$side+".sz") 1 0.2;
	asDsSdk ("CTRL"+$side+"_eye_squintInner.ty")  ("SDKinnerLidOuter"+$side+".sz") 1 0.2;

	asDsSdk ("CTRL"+$side+"_mouth_suckBlow.ty")  ("ctrlCheek"+$side+".tx") 1 1;

	asDsSdk ("CTRL"+$side+"_nose.tx")  ("ctrlNose"+$side+".tx") 1 1;
	asDsSdk ("CTRL"+$side+"_nose.ty")  ("SDKEyeBrowInner"+$side+".ty") 1 -0.35;
	asDsSdk ("CTRL"+$side+"_nose.ty")  ("SDKEyeBrowInner"+$side+".ty") -1 0.01;
	setAttr ctrlNose_R.ty 1;
	$pos1=`getAttr SDKNoseCorner_R.t`;
	$pos2=`getAttr SDKNoseSide_R.t`;
	setAttr ctrlNose_R.ty 0;
	asDsSdk ("CTRL"+$side+"_nose.ty") ("SDKNoseCorner"+$side+".tx") 1 0.01;
	asDsSdk ("CTRL"+$side+"_nose.ty") ("SDKNoseCorner"+$side+".ty") 1 $pos1[1];
	asDsSdk ("CTRL"+$side+"_nose.ty") ("SDKNoseCorner"+$side+".tx") -1 ($pos1[1]*-0.2);
	asDsSdk ("CTRL"+$side+"_nose.ty") ("SDKNoseCorner"+$side+".ty") -1 ($pos1[1]*-0.2);
	asDsSdk ("CTRL"+$side+"_nose.ty") ("SDKNoseCorner"+$side+".ty") -1 ($pos1[1]*-0.2);
	asDsSdk ("CTRL"+$side+"_nose.ty") ("SDKNoseSide"+$side+".ty") 1 $pos2[1];
	asDsSdk ("CTRL"+$side+"_nose.ty") ("SDKNoseSide"+$side+".ty") -1 -0.01;

	asDsSdk ("CTRL"+$side+"_mouth_corner.tx")  ("SDKcornerLip"+$side+".tx") 1 0.5;
	asDsSdk ("CTRL"+$side+"_mouth_corner.ty")  ("SDKcornerLip"+$side+".ty") 1 0.5;

	$mult=1.0;
	asDsSdk ("CTRL"+$side+"_mouth_upperLipRaise.ty")  ("SDKupperLip"+$side+".tx") 1 (0.25*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_upperLipRaise.ty")  ("SDKupperLip"+$side+".ty") 1 (0.75*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_upperLipRaise.ty")  ("SDKNoseCorner"+$side+".tx") 1 (0.05*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_upperLipRaise.ty")  ("SDKNoseCorner"+$side+".ty") 1 (0.2*$mult);

	asDsSdk ("CTRL"+$side+"_mouth_sharpCornerPull.ty")  ("ctrlMouthCorner"+$side+".tx") 1 (0.5*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_sharpCornerPull.ty")  ("ctrlMouthCorner"+$side+".ty") 1 (0.75*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_cornerPull.ty")  ("ctrlMouthCorner"+$side+".ty") 1 (0.75*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_cornerPull.ty")  ("ctrlMouthCorner"+$side+".tx") 1 (0.75*$mult);

	asDsSdk ("CTRL"+$side+"_mouth_dimple.ty")  ("ctrlMouthCorner"+$side+".tx") 1 (0.75*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_dimple.ty")  ("ctrlMouthCorner"+$side+".ty") 1 (0.2*$mult);

	asDsSdk ("CTRL"+$side+"_mouth_cornerDepress.ty")  ("ctrlMouthCorner"+$side+".tx") 1 (0.2*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_cornerDepress.ty")  ("ctrlMouthCorner"+$side+".ty") 1 (-0.5*$mult);

	asDsSdk ("CTRL"+$side+"_mouth_stretch.ty")  ("ctrlMouthCorner"+$side+".tx") 1 (0.7*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_stretch.ty")  ("ctrlMouthCorner"+$side+".ty") 1 (-0.5*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_stretch.ty")  ("SDKlowerLip"+$side+".tx") 1 (0.5*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_stretch.ty")  ("SDKlowerLip"+$side+".ty") 1 (-0.3*$mult);

	asDsSdk ("CTRL"+$side+"_mouth_lowerLipDepress.ty")  ("SDKlowerLip"+$side+".tx") 1 (0.4*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_lowerLipDepress.ty")  ("SDKlowerLip"+$side+".ty") 1 (-0.8*$mult);

	asDsSdk ("CTRL"+$side+"_mouth_lowerLipDepress.ty")  ("SDKFrownBulge"+$side+".tx") 1 (0.05*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_lowerLipDepress.ty")  ("SDKFrownBulge"+$side+".ty") 1 (-0.12*$mult);
	asDsSdk ("CTRL"+$side+"_mouth_lowerLipDepress.ty")  ("SDKChinCrease_M.ty") 1 (-0.08*$mult);


	asDsSdk CTRL_C_mouth.tx  ("SDKCheek"+$side+".tx") 1 (-0.3*$b);
	asDsSdk CTRL_C_mouth.tx  ("SDKCheek"+$side+".tz") 1 (0.2*$b);
	asDsSdk CTRL_C_mouth.tx  ("ctrlMouthCorner"+$side+".tx") 1 (-0.25*$b);

	asDsSdk ("CTRL"+$side+"_mouth_lipSticky.ty")  ("Lip"+$side+".sticky") 1 10;

	asDsSdk ("CTRL"+$side+"_mouth_lipsPressU.ty")  ("ctrlMouthCorner"+$side+".ty") 1 0.1;
	asDsSdk ("CTRL"+$side+"_mouth_lipsPressU.ty")  ctrlLips_M.upperSqueeze 1 2;
	asDsSdk ("CTRL"+$side+"_mouth_lipsPressU.ty")  ctrlLips_M.lowerSqueeze 1 2;

	asDsSdk ("CTRL"+$side+"_mouth_lipsBlow.ty")  ("ctrlCheek"+$side+".tx") 1 1;

	for ($c=1;$c>-2;$c=$c-2)
		{
		if ($c== 1) {$UD="U";$upperLower="upper";}
		if ($c==-1) {$UD="D";$upperLower="lower";}

		asDsSdk ("CTRL"+$side+"_mouth_lipsTogether"+$UD+".ty")  ($upperLower+"Lip"+$side+".lipsTogether") 1 10; 
//		asDsSdk ("CTRL"+$side+"_mouth_purse"+$UD+".ty")  ($upperLower+"Lip"+$side+".lipsTogether") 1 10;
		asDsSdk ("CTRL"+$side+"_mouth_purse"+$UD+".ty") ("ctrlMouthCorner"+$side+".tx") 1 -0.2;

		asDsSdk ("CTRL"+$side+"_mouth_funnel"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Pucker") 1 5;
		asDsSdk ("CTRL"+$side+"_mouth_funnel"+$UD+".ty")  ("SDK"+$upperLower+"Lip_M.ty") 1 (0.1*$c);

//		asDsSdk ("CTRL"+$side+"_mouth_towards"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Roll") 1 5;
		asDsSdk ("CTRL"+$side+"_mouth_towards"+$UD+".ty")  ("SDK"+$upperLower+"Lip_M.ty") 1 (0.05*$c);
		asDsSdk ("CTRL"+$side+"_mouth_towards"+$UD+".ty")  ("SDKLipRegion_M.tz") 1 0.05;

		asDsSdk ("CTRL"+$side+"_mouth_lipBite"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Roll") 1 -4;
//		asDsSdk ("CTRL"+$side+"_mouth_lipBite"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Squeeze") 1 3;

		asDsSdk ("CTRL"+$side+"_mouth_tighten"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Press") 1 2;
		asDsSdk ("CTRL"+$side+"_mouth_tighten"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Squeeze") 1 2;
		asDsSdk ("CTRL"+$side+"_mouth_tighten"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Roll") 1 -1;
		asDsSdk ("CTRL"+$side+"_mouth_tighten"+$UD+".ty")  ("ctrlMouthCorner"+$side+".tx") 1 -0.1;

		asDsSdk ("CTRL"+$side+"_jaw_ChinRaise"+$UD+".ty")  ("SDK"+$upperLower+"Lip"+$side+".ty") 1 0.75;
		asDsSdk ("CTRL"+$side+"_jaw_ChinRaise"+$UD+".ty")  ("SDKLip"+$side+".ty") 1 0.1;

		asDsSdk ("CTRL"+$side+"_mouth_press"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Press") 1 2.5;
		asDsSdk ("CTRL"+$side+"_mouth_press"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Squeeze") 1 2.5;
		asDsSdk ("CTRL"+$side+"_mouth_press"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Roll") 1 -5;
		asDsSdk ("CTRL"+$side+"_mouth_press"+$UD+".ty")  ("SDK"+$upperLower+"Lip_M.ty") 1 (-0.15*$c);
		asDsSdk ("CTRL"+$side+"_mouth_press"+$UD+".ty")  SDKLipRegion_M.ty 1 0.1;
		asDsSdk ("CTRL"+$side+"_mouth_press"+$UD+".ty")  SDKNoseRegion_M.ty 1 -0.02;

		asDsSdk ("CTRL"+$side+"_mouth_thickness"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Press") 1 2.5;
		asDsSdk ("CTRL"+$side+"_mouth_thickness"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Squeeze") 1 2;
		asDsSdk ("CTRL"+$side+"_mouth_thickness"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Roll") 1 -2.5;

		asDsSdk ("CTRL"+$side+"_mouth_thicknessInward"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Squeeze") 1 2.5;
		asDsSdk ("CTRL"+$side+"_mouth_thicknessInward"+$UD+".ty")  ("SDK"+$upperLower+"Lip_M.ty") 1 (0.15*$c);

		asDsSdk ("CTRL"+$side+"_mouth_lipsRoll"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Roll") 1 -5;
//		asDsSdk ("CTRL"+$side+"_mouth_lipsRoll"+$UD+".ty")  ("ctrlLips_M."+$upperLower+"Squeeze") 1 3;

		asDsSdk ("CTRL"+$side+"_mouth_cornerSharpness"+$UD+".ty")  ("SDK"+$upperLower+"LipB"+$side+".ty") 1 (-0.3*$c);

		asDsSdk ("CTRL"+$side+"_mouth_pushPull"+$UD+".ty")  ("SDK"+$upperLower+"LipA"+$side+".tz") 1 0.3;
		asDsSdk ("CTRL"+$side+"_mouth_pushPull"+$UD+".ty")  ("SDKLip"+$side+".tz") 1 0.06;
		asDsSdk ("CTRL"+$side+"_mouth_pushPull"+$UD+".ty")  ("SDK"+$upperLower+"Lip_M.tz") 1 0.03;
		}

	asDsSdk ("CTRL"+$side+"_eye_faceScrunch.ty")  ("ctrlEye"+$side+".squint") 1 10;
	asDsSdk ("CTRL"+$side+"_eye_eyelidU.ty")  ("SDKupperLid"+$side+".ty") 1 -0.6;
	asDsSdk ("CTRL"+$side+"_eye_eyelidD.ty")  ("SDKlowerLid"+$side+".ty") 1 0.4;

	asDsSdk ("CTRL"+$side+"_nose_nasolabialDeepen.ty")  ("SDKSmileBulge"+$side+".tx") 1 0.2;
	asDsSdk ("CTRL"+$side+"_nose_nasolabialDeepen.ty")  ("SDKSmileBulge"+$side+".ty") 1 0.2;
	asDsSdk ("CTRL"+$side+"_nose_nasolabialDeepen.ty")  ("SDKNoseCorner"+$side+".tx") 1 0.2;
	asDsSdk ("CTRL"+$side+"_nose_nasolabialDeepen.ty")  ("SDKNoseCorner"+$side+".ty") 1 0.2;

	asDsSdk ("CTRL"+$side+"_mouth_lipsTowardsTeethU.ty")  ("Lip"+$side+".sticky") 1 5;
	asDsSdk ("CTRL"+$side+"_mouth_lipsTowardsTeethD.ty")  ("Lip"+$side+".sticky") 1 5;
	}
//asDsSdk CTRL_C_eye_parallelLook.ty  AimEye_M.sx 1 0;//AimEye_M does not have SDK node
asDsSdk CTRL_C_mouth.ty  SDKLipRegion_M.ty 1 0.3;
asDsSdk CTRL_C_mouth.ty  ctrlLips_M.upperSqueeze 1 1.5;
asDsSdk CTRL_C_mouth.ty  ctrlLips_M.lowerSqueeze -1 1.5;
asDsSdk CTRL_C_mouth.tx  ctrlLips_M.tx 1 1;
asDsSdk CTRL_C_jaw.tx  ctrlMouth_M.jawSide 1 -7.5;
asDsSdk CTRL_C_jaw.ty  ctrlMouth_M.ty 1 -1;
asDsSdk CTRL_C_jaw_fwdBack.ty  ctrlMouth_M.jawForward 1 -3;
//asDsSdk CTRL_C_jaw_openExtreme.ty  ctrlMouth_M.ty 1 -2.0;//does not work well, as in MH this is Multiplied by CTRL_C_jaw.ty
asDsSdk CTRL_C_tongue_inOut.ty  SDKTongue1_M.sx 1 0.4;
asDsSdk CTRL_C_tongue_inOut.ty  SDKTongue2_M.sx 1 0.4;
asDsSdk CTRL_C_tongue_inOut.ty  SDKTongue3_M.sx 1 0.4;
asDsSdk CTRL_C_tongue_wideNarrow.ty  SDKTongue1_M.sy 1 0.7;
asDsSdk CTRL_C_tongue_wideNarrow.ty  Tongue1_M.sz 1 1.2;
asDsSdk CTRL_C_tongue_press.ty  SDKTongue1_M.ty 1 0.5;
asDsSdk CTRL_C_tongue_thickThin.ty  SDKTongue0_M.sy 1 1.5;

for ($i=0;$i<4;$i++)
	{
	asDsSdk CTRL_C_tongue_move.ty  ("SDKTongue"+$i+"_M.rz") 1 10;
	asDsSdk CTRL_C_tongue_move.tx  ("SDKTongue"+$i+"_M.ry") 1 10;
	}
asDsSdk CTRL_C_tongue_bendTwist.ty  SDKTongue1_M.rz 1 25;
asDsSdk CTRL_C_tongue_bendTwist.ty  SDKTongue1_M.rz -1 25;
asDsSdk CTRL_C_tongue_bendTwist.ty  SDKTongue2_M.rz 1 25;
asDsSdk CTRL_C_tongue_bendTwist.ty  SDKTongue3_M.rz 1 25;
asDsSdk CTRL_C_tongue_bendTwist.tx  SDKTongue2_M.rx 1 -30;
asDsSdk CTRL_C_tongue_bendTwist.tx  SDKTongue3_M.rx 1 -50;
for ($i=2;$i<4;$i++)
	{
	asDsSdk CTRL_C_tongue_tipMove.ty  ("SDKTongue"+$i+"_M.rz") 1 25;
	asDsSdk CTRL_C_tongue_tipMove.tx  ("SDKTongue"+$i+"_M.ry") 1 15;
	}
asDsSdk CTRL_C_jaw_fwdBack.ty  ctrlMouth_M.jawForward 1 -0.5;
asDsSdk CTRL_C_mouth_lipShiftU.ty SDKupperLip_M.tx 1 0.5;
asDsSdk CTRL_C_mouth_lipShiftD.ty SDKlowerLip_M.tx 1 0.5;


for ($c=1;$c>-2;$c=$c-2)
	{
	if ($c== 1) {$UD="U";$upperLower="upper";}
	if ($c==-1) {$UD="D";$upperLower="lower";}

	asDsSdk ("CTRL_C_teeth_fwdBack"+$UD+".ty")  ("SDK"+$upperLower+"Teeth_M.tz") 1 -0.5;
	asDsSdk ("CTRL_C_teeth"+$UD+".ty")  ("SDK"+$upperLower+"Teeth_M.ty") 1 1;
	asDsSdk ("CTRL_C_teeth"+$UD+".tx")  ("SDK"+$upperLower+"Teeth_M.tx") 1 0.75;
	}

//MH has `non-linear attr mixing`, to avoid overshooting, apply limits
if (`attributeExists smileMaxValue ctrlMouthCorner_R`)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b== 1) $side="_R";
		if ($b==-1) $side="_L";

		setAttr ("ctrlMouthCorner"+$side+".smileMaxValue") 1;
		setAttr ("ctrlMouthCorner"+$side+".frownMaxValue") 1;
		setAttr ("ctrlMouthCorner"+$side+".narrowSmileMaxValue") 1;
		setAttr ("ctrlMouthCorner"+$side+".narrowFrownMaxValue") 1;
		}
	}

//no equivalent, so make it black
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b== 1) $side="_R";
	if ($b==-1) $side="_L";

	sets -e -forceElement asBlackSG ("CTRL"+$side+"_jaw_chinCompress");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_jaw_clench");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_mouth_stickyOuterU");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_mouth_stickyInnerU");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_mouth_stickyOuterD");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_mouth_stickyInnerD");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_neck_mastoidContract");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_neck_stretch");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_eyelashes_tweakerOut");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_eyelashes_tweakerIn");
	sets -e -forceElement asBlackSG ("CTRL"+$side+"_ear_up");
	}
sets -e -forceElement asBlackSG CTRL_C_mouth_stickyU;
sets -e -forceElement asBlackSG CTRL_C_mouth_stickyD;
sets -e -forceElement asBlackSG CTRL_neck_throatExhaleInhale;
sets -e -forceElement asBlackSG CTRL_neck_digastricUpDown;
sets -e -forceElement asBlackSG CTRL_neck_throatUpDown;
sets -e -forceElement asBlackSG CTRL_C_neck_swallow;
sets -e -forceElement asBlackSG CTRL_rigLogicSwitch;
sets -e -forceElement asBlackSG CTRL_lookAtSwitch;

asGoToBuildPose faceSetup;//again, because CTRL_R_nose_wrinkleUpper is saved as 1, but should be 0

print ("// MetaHuman ControlPanel Added.\n");
select -cl;
}


global proc asFaceDeltaMush ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[];

if (!`exists deltaMush`)
	error "DeltaMush not avaiable in this version of Maya";
if (`objExists asFaceDeltaMush`)
	error "asFaceDeltaMush already exists";

select $geometry;
//$tempString=`deltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1`;
$tempString=`asDeformer ("deltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1")`;
rename $tempString[0] asFaceDeltaMush;
$tempString=`listConnections asFaceDeltaMush.message`;
rename $tempString[0] asFaceDeltaMushSet;

asConnectDeltaMushScale;

//auto zero weight lip & lid, as this is a common issue to miss
if (`objExists eyeLidArea` && `objExists lipArea`)
	{
	select eyeLidArea lipArea;
	asFaceDeltaMushZeroWeight;
	print "// Automatically zero weighting eyeLid and lip.\n";
	}

select $geometry;
print "// DeltaMush applied\n";
}

global proc asFaceDeltaMushZeroWeight ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $historyNodes[];

if (`objExists asFaceDeltaMush`)
	{
	evalEcho "percent -v 0 asFaceDeltaMush";
	return;
	}
$historyNodes=`listHistory -pdo 1 -il 2 $geometry`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="deltaMush")
		evalEcho ("percent -v 0 "+$historyNodes[$i]);
}

global proc asAdvancedSquash ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`getAttr FaceFitSkeleton.faceScale`/3.0;
float $value,$min,$max;
float $pos[3],$pos2[3];
string $name;
string $tempString[],$tempString2[],$allFaceGeo[],$historyNodes[],$infs[];
string $allFaceGeoString=`textField -q -tx asFaceAllHeadTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
string $allBefore[]=`ls`;
string $faceControlSetMembers[]=`sets -q FaceControlSet`;

select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
sets -n allBeforeSquashBuild;
select -cl;

//squashHead
waitCursor -st 1;
float $squashTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
float $squashBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $BaseToTopY=$squashTopPos[1]-$squashBasePos[1];

createNode -n SquashSetup -p FaceDeformationSystem transform;
$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
rename $tempString[0] squashTop_M;
setAttr squashTop_MShape.overrideEnabled 1;
setAttr squashTop_MShape.overrideColor 13;
createNode -n squashTopOffset transform;
parent squashTop_M squashTopOffset;
xform -ws -t 0 $squashTopPos[1] 0 squashTopOffset;
xform -ws -s ($scale/0.75) ($scale/5.0) ($scale/5.0) squashTop_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashTop_M;
sets -add "FaceControlSet" squashTop_M;
duplicate -n SquashControls squashTopOffset;
rename SquashControls|squashTop_M squashBase_M;
xform -ws -t 0 $squashBasePos[1] 0 SquashControls;
duplicate -n squashMiddleOffset squashTopOffset;
rename squashMiddleOffset|squashTop_M squashMiddle_M;
xform -ws -t 0 (($squashBasePos[1]+$squashTopPos[1])/2) 0 squashMiddleOffset;
scale -r 1.5 1 1 squashMiddle_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashMiddle_M;
parent squashTopOffset squashMiddleOffset squashBase_M;

addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 squashTop_M;
createNode -n squashTopVolumeUC unitConversion;
setAttr squashTopVolumeUC.conversionFactor 0.1;
connectAttr squashTop_M.volume squashTopVolumeUC.input;

setAttr -l 1 -k 0 squashTop_M.rx;setAttr -l 1 -k 0 squashTop_M.ry;setAttr -l 1 -k 0 squashTop_M.rz;
setAttr -l 1 -k 0 squashTop_M.sx;setAttr -l 1 -k 0 squashTop_M.sy;setAttr -l 1 -k 0 squashTop_M.sz;
setAttr -l 1 -k 0 squashTop_M.v;
setAttr -l 1 -k 0 squashMiddle_M.rx;setAttr -l 1 -k 0 squashMiddle_M.ry;setAttr -l 1 -k 0 squashMiddle_M.rz;
setAttr -l 1 -k 0 squashMiddle_M.sx;setAttr -l 1 -k 0 squashMiddle_M.sy;setAttr -l 1 -k 0 squashMiddle_M.sz;
setAttr -l 1 -k 0 squashMiddle_M.v;
setAttr -l 1 -k 0 squashBase_M.sx;setAttr -l 1 -k 0 squashBase_M.sy;setAttr -l 1 -k 0 squashBase_M.sz;
setAttr -l 1 -k 0 squashBase_M.v;

select $allFaceGeo;
//Do not include wrapped on`s or wired on`s  (e.g eyebrows)
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$historyNodes=`listHistory -f 0 -pruneDagObjects 1 -lv 4 $allFaceGeo[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="wrap" || `objectType $historyNodes[$y]`=="wire")
			select -d $allFaceGeo[$i];
	}

//include ctrls
$tempString2=`listRelatives -ad -type nurbsCurve -type nurbsSurface OnFacecontrols`;
for ($i=0;$i<size($tempString2);$i++)
	{
	//not the ctrlBox2 shapes
//	if (`gmatch $tempString2[$i] "*1_RShape"`)
	$tempString=`listConnections ($tempString2[$i]+".create")`;
	if (`gmatch $tempString[0] "*_*TG"`)
		continue;
	select -add $tempString2[$i];
	}

//$tempString=`lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2`;
$tempString=`asDeformer ("lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2")`;
rename $tempString[0] squashFfd;
rename $tempString[1] squashFfdLattice;
rename $tempString[2] squashFfdBase;
$tempString=`listConnections squashFfd.message`;
rename $tempString[0] squashFfdSet;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdLattice;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdBase;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdLattice;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdBase;
scale -r 1.25 1.25 1.25 squashFfdLattice;
scale -r 1.25 1.25 1.25 squashFfdBase;
setAttr "squashFfd.outsideLattice" 1;
parent squashFfdBase squashBase_M;
createNode -n squashXup transform;
setAttr -type float3 squashXup.r 90 0 90;
select squashXup;
$pos=`xform -q -ws -t squashFfdLattice.pt[0][1][1]`;
joint -n squashIKX0 -p 0 $pos[1] 0;
select squashXup;
for ($i=1;$i<10;$i++)
    {
    $pos=`xform -q -ws -t squashFfdLattice.pt[0][$i][1]`;
    joint -n ("squashIKX"+$i) -p 0 $pos[1] 0;
    }
setAttr squashIKX1.segmentScaleCompensate 0;
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj squashIKX1 -ee squashIKX9`;
rename $tempString[1] squashIKEffector;
rename $tempString[2] squashIKECurve;
for ($i=0;$i<5;$i++)
    {
    select -r squashIKECurve.cv[$i];
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ("squashIKCluster"+$i);
    rename $tempString[1] ("squashIKClusterHandle"+$i);
    }  
select -cl;
for ($i=0;$i<10;$i++)
    select -add ("squashIKX"+$i);
select -add squashFfdLattice;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] squashIKSC;

skinPercent -tv squashIKX0 1 squashIKSC squashFfdLattice.pt[0:1][0:1][0:1];
skinPercent -tv squashIKX2 1 squashIKSC squashFfdLattice.pt[0:1][2][0] squashFfdLattice.pt[0:1][2][1];
skinPercent -tv squashIKX3 1 squashIKSC squashFfdLattice.pt[0:1][3][0] squashFfdLattice.pt[0:1][3][1];
skinPercent -tv squashIKX4 1 squashIKSC squashFfdLattice.pt[0:1][4][0] squashFfdLattice.pt[0:1][4][1];
skinPercent -tv squashIKX5 1 squashIKSC squashFfdLattice.pt[0:1][5][0] squashFfdLattice.pt[0:1][5][1];
skinPercent -tv squashIKX6 1 squashIKSC squashFfdLattice.pt[0:1][6][0] squashFfdLattice.pt[0:1][6][1];
skinPercent -tv squashIKX7 1 squashIKSC squashFfdLattice.pt[0:1][7][0] squashFfdLattice.pt[0:1][7][1];
skinPercent -tv squashIKX8 1 squashIKSC squashFfdLattice.pt[0:1][8][0] squashFfdLattice.pt[0:1][8][1];
skinPercent -tv squashIKX9 1 squashIKSC squashFfdLattice.pt[0:1][9:10][0:1];

delete `pointConstraint squashIKClusterHandle4 squashIKClusterHandle3`;
parent squashIKClusterHandle3 squashIKClusterHandle4;
move -r 0 ($scale*-0.1) 0 ;

parent squashIKClusterHandle4 squashTop_M;
parent squashIKClusterHandle2 squashMiddle_M;
parent squashIKClusterHandle0 squashIKClusterHandle1 squashIKX0 squashBase_M;

createNode -n squashIKCurveInfo curveInfo;
connectAttr squashIKECurveShape.worldSpace[0] squashIKCurveInfo.inputCurve;


createNode -n squashIKCurveInfoNormalize multiplyDivide;
setAttr squashIKCurveInfoNormalize.operation 2;
connectAttr squashIKCurveInfo.arcLength squashIKCurveInfoNormalize.input1X;
setAttr squashIKCurveInfoNormalize.input2X `getAttr squashIKCurveInfoNormalize.input1X`;
createNode -n squashIKScale multiplyDivide;

//scale-compansate Main ctrl
createNode -n squashIKCurveInfoMainScale multiplyDivide;
setAttr squashIKCurveInfoMainScale.operation 2;
connectAttr squashIKCurveInfoNormalize.outputX squashIKCurveInfoMainScale.input1X;
if (`objExists MainScaleMultiplyDivide`) // maight be `bodyLess` faceSetup
	connectAttr MainScaleMultiplyDivide.outputY  squashIKCurveInfoMainScale.input2X;

connectAttr squashIKCurveInfoMainScale.outputX squashIKScale.input1X;
createNode -n squashIKStretch multiplyDivide;
connectAttr squashIKScale.outputX squashIKStretch.input2X;
setAttr squashIKStretch.input1X `getAttr squashIKX2.tx`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr ($headJoint+".sx") squashIKScale.input2X;
setAttr "squashIKScale.operation" 2;
for ($i=1;$i<10;$i++)
    connectAttr squashIKStretch.outputX ("squashIKX"+$i+".tx");
createNode -n squashVolume1Over multiplyDivide;
connectAttr squashIKScale.outputX squashVolume1Over.input2X;
setAttr "squashVolume1Over.input1X" 1;
setAttr "squashVolume1Over.operation" 2;
createNode -n squashVolumePow multiplyDivide;
connectAttr squashVolume1Over.outputX squashVolumePow.input1X;
setAttr "squashVolumePow.operation" 3;
setAttr "squashVolumePow.input2X" 0.5;
createNode -n squashBlendTwo blendTwoAttr;
setAttr squashBlendTwo.input[0] 1;
connectAttr squashVolumePow.outputX squashBlendTwo.input[1];
connectAttr squashTopVolumeUC.output squashBlendTwo.attributesBlender;
for ($i=2;$i<9;$i++)
    {
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sy");
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sz");
    }
    
parent squashFfdLattice squashIKECurve squashIKHandle SquashSetup;
//parent squashIKX1 $headJoint;
parent squashIKX1 FaceMotionSystem;
parent SquashControls FaceMotionSystem;
parentConstraint -mo $headJoint SquashControls;
//scaleConstraint $headJoint SquashControls;
//connectAttr MainAndHeadScaleMultiplyDivide.output SquashControls.s;
delete squashXup;

setAttr -l 1 squashIKX1.v 0;
setAttr -l 1 squashFfdBase.v 0;
setAttr -l 1 squashIKHandle.v 0;
setAttr -l 1 squashIKX0.v 0;
for ($i=0;$i<5;$i++)
    setAttr -l 1 ("squashIKClusterHandle"+$i+".v") 0;

/*//removed in v 5.910, since FaceDeformationSystem is now `always` hidden
addAttr -k 0 -ln curveVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.curveVis;
connectAttr squashTop_M.curveVis squashIKECurve.v;
addAttr -k 0 -ln LatticeVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.LatticeVis;
connectAttr squashTop_M.LatticeVis squashFfdLattice.v;
*/

//include on-face nurbsCurveControllers (yellow ones)
select -cl;
for ($i=0;$i<size($faceControlSetMembers);$i++)
	{
	$tempString=`ls -l $faceControlSetMembers[$i]`;
	if (`gmatch $tempString[0] "*|ctrlBox|*"` || `gmatch $faceControlSetMembers[$i] "AimEye_*"`)
		continue;
	$tempString=`listRelatives -s $faceControlSetMembers[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`getAttr ($tempString[0]+".overrideColor")`!=17)
		continue;
	sets -add squashFfdSet $tempString[0];
	}


//update buildPose
string $controls[]={"squashTop_M","squashMiddle_M","squashBase_M"};
string $setAttrCmd;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listAttr -k -shortNames $controls[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controls[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controls[$i]+"."+$tempString[$y]+" "+`getAttr ($controls[$i]+"."+$tempString[$y])`+";";
	}
string $existingCmd=`getAttr faceBuildPose.udAttr`;
setAttr -type "string" faceBuildPose.udAttr ($existingCmd+$setAttrCmd);

connectAttr ctrlBox.SquashCtrlVis squashTop_MShape.overrideVisibility;
connectAttr ctrlBox.SquashCtrlVis squashMiddle_MShape.overrideVisibility;
connectAttr ctrlBox.SquashCtrlVis squashBase_MShape.overrideVisibility;

//Squashset
select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
select -d allBeforeSquashBuild;
sets -n SquashSet;
sets -add FaceAllSet SquashSet;
sets -clear allBeforeSquashBuild;
delete allBeforeSquashBuild;

waitCursor -st 0;
select squashTop_M;
}

global proc asDeleteHeadSquash ()
{
if (!`objExists SquashSet`)
	return;
if (`objExists squashIKCurveInfo`)
	delete squashIKCurveInfo;//delete this first to avoid Error: No valid NURBS curve
select SquashSet;
delete;
}

global proc asOptimizeSquash ()
{
global string $gMainProgressBar;
string $tempString[],$tempString2[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $tempInt[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInt[0];

if (!`objExists SquashSetup`)
	error "SquashSetup not found, Create HeadSquash first.";

if (!`attributeExists optimizedSquash SquashSetup`)
	addAttr -k 0 -ln optimizedSquash -at bool -dv true SquashSetup;

string $allHeadJoints[]=`listRelatives -ad -type joint $headJoint`;
$tempString=`listRelatives -ad -type joint FaceDeformationSystem`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections ($tempString[$i]+".worldMatrix")`;
	if ($tempString2[0]==$skinCluster)
		$allHeadJoints=`stringArrayCatenate $allHeadJoints $tempString`;
	}
if (`objExists EyeRegion_R`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_R";
if (`objExists EyeRegion_L`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_L";
$allHeadJoints[size($allHeadJoints)]=$headJoint;
select -cl;
progressBar -e -st "Optimizing" -bp -ii 1 -min 0 -max $numVtx $gMainProgressBar;
for ($i=0;$i<$numVtx;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;return;}

	string $vtx=$geometry+".vtx["+$i+"]";
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
	int $headVtx=0;
	for ($y=0;$y<size($infs);$y++)
		{
		if (`stringArrayCount $infs[$y] $allHeadJoints`)
			{
			$headVtx=1;
			break;
			}
		}
	if (!$headVtx)
		select -add $vtx;
	}
$tempString=`ls -sl`;
if (size($tempString))
	{
	sets -rm squashFfdSet `ls -sl`;
	asInvertSelection;
	}
progressBar -e -ep $gMainProgressBar;
print ("// Optimize complete, now only these selected vtx`s are affected by Squash\n");
}

global proc asAddToHeadSquash ()
{
sets -add squashFfdSet `ls -sl`;
print ("// Added selected object to be included in HeadSquash deformation\n");
}

global proc asWrinkleCurves ()
{
int $foreHeadAreaMeshVis;
float $scale,$offsetDist,$width,$depth;
float $bbMin[],$bbMax[],$pos[],$posA[],$posB[],$posC[],$eyeBallPos[],$eyeBrowCenterPos[];
float $foreHeadAreaBBMin[],$foreHeadAreaBBMax[];
string $mesh,$dialogResult,$shader,$shaderRestoreCmd,$curveCmd,$SG,$duplicatedSG,$shaderRestoreCmd,$existingBumpMapConnectedNode;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[],$tempString2[],$tempString3[],$curves[];

asVersionRequirementCheck face 5.750;
$scale=`getAttr FaceFitSkeleton.faceScale`;
asWmEnsureWrinkleMapNode;

if (`objExists WrinkleCurves`)
	$tempString=`listRelatives -c WrinkleCurves`;
if (size($tempString))
	{
	$dialogResult=`confirmDialog -t "Confirm"
	-m "Wrinkles already exists, this will delete the existing Wrinkle setup"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
	if ($dialogResult!="OK")
		return;
	//restore shader-assignment if shader was duplicated
	$shaderRestoreCmd=`getAttr WrinkleMap.shaderRestoreCmd`;
	if (`objExists FaceWrinkleSet`)
		$tempString=`sets -q FaceWrinkleSet`;
	if (`objExists FaceWrinkleRenderingSet`)
		$tempString2=`sets -q FaceWrinkleRenderingSet`;
	$tempString=`stringArrayCatenate $tempString $tempString2`;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists $tempString[$i]`)
				delete $tempString[$i];
	$tempString=`listAttr -ud ctrlBox`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "wrinkle*"`)
			deleteAttr ("ctrlBox."+$tempString[$i]);
	if (`objExists WrinkleMap`)
		delete WrinkleMap;
	asGoToBuildPose faceSetup;
	if ($shaderRestoreCmd!="")
		evalEcho $shaderRestoreCmd;

	print ("// Wrinkles removed\n");
	return;
	}

asGoToBuildPose faceSetup;
refresh;
$tempString=`listRelatives -s -ni $geometry`;
$mesh=$tempString[0];
$tempString=`listConnections -s 0 -d 1 -type shadingEngine ($mesh+".instObjGroups[0]")`;
if ($tempString[0]=="")
	{//perFaceAssigned
	$tempString=`listConnections -s 1 -d 0 -type shadingEngine ($mesh+".instObjGroups[0].objectGroups")`;
	if (size($tempString)==1)
		{
		$SG=$tempString[0];
		$tempString=`listConnections -s 1 -d 0 ($SG+".surfaceShader")`;
		$shader=$tempString[0];
		}
	if (size($tempString)>1)
		{
		createNode -n shaderChooserDialog transform;
		addAttr -ln shader -dt "string" shaderChooserDialog;
		$dialogResult=`layoutDialog -t "Confirm" -ui asWmLayout`;
		if ($dialogResult!="OK")
			{
			delete shaderChooserDialog;
			return;
			}
		$shader=`getAttr shaderChooserDialog.shader`;
		$tempString=`listConnections -s 0 -d 1 ($shader+".outColor")`;
		$SG=$tempString[0];
		delete shaderChooserDialog;
		}
	}
else
	{
	$SG=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 ($SG+".surfaceShader")`;
	$shader=$tempString[0];
	}
setAttr -type "string" WrinkleMap.shader $shader;

if (!`attributeExists normalCamera $shader`)
	error ("No \"normalCamera\" attribute found on shader:\""+$shader+"\", therefore unable to apply bumpMap to the shader");
if ($SG=="initialShadingGroup")
	error "initialShadingGroup used as shader, unable to proceed, please make a new shader for the face first";

$tempString=`listConnections -s 1 -d 0 ($SG+".dagSetMembers")`;
$tempString=`stringArrayRemoveDuplicates $tempString`;
if (size($tempString)>1)
	{
	$dialogResult=`confirmDialog -t "Confirm"
	-m ("Multiple objects are using the face-shader.\n"
		+"Continuing will create a duplicate shader,\nto be used for the non-face-objects.")
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
	if ($dialogResult!="OK")
		{
		delete asWrinkleMapBuilding;
		return;
		}
	select -ne $SG;
	$tempString2=`duplicate`;
	$duplicatedSG=$tempString2[0];
	delete $tempString2;
	select -ne $SG;
	hyperShade -duplicate;
	//duplicated shader needs to be added to FaceWrinkleSet
	setAttr -type "string" WrinkleMap.duplicatedSG $duplicatedSG;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]==$geometry)
			continue;
		print ("sets -e -forceElement "+$duplicatedSG+" "+$tempString[$i]+";\n");
		$tempString2=`listRelatives -ni -s $tempString[$i]`;
		$tempString3=`listConnections -c 1 -p 1 -s 0 -d 1 $tempString2[0]`;
		for ($y=0;$y<size($tempString3);$y=$y+2)
			{
			if (`gmatch $tempString3[$y+1] ($SG+"*")`)
				{
				disconnectAttr $tempString3[$y] $tempString3[$y+1];
				print (" disconnectAttr "+$tempString3[$y]+" -> "+$tempString3[$y+1]+"\n");
				}
			}
		sets -e -forceElement $duplicatedSG $tempString[$i];
		$shaderRestoreCmd+="sets -e -forceElement "+$SG+" "+$tempString[$i]+";";
		}
	setAttr -type "string" WrinkleMap.shaderRestoreCmd $shaderRestoreCmd;
	}

if (`objExists bump2dWrinkle`) delete bump2dWrinkle;
$tempString=`listConnections -s 1 -d 0 ($shader+".normalCamera")`;
$existingBumpMapConnectedNode=$tempString[0];
if ($existingBumpMapConnectedNode!="")
	{
	$dialogResult=`confirmDialog -t "Confirm"
	-m ("Existing BumpMap exists for the Shader.\n"
		+"Continue to create \"Layered BumpMap\" ?\n\n"
		+"Note:\nViewport will only show WrinkleBumpMap,\nbut rendring will use both BumpMap Layers")
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
	if ($dialogResult!="OK")
		{
		delete asWrinkleMapBuilding;
		return;
		}
	}

spaceLocator -n tempLoc;

if (!`objExists WrinkleCurves`)
	createNode -n WrinkleCurves -p WrinkleMap transform;

$foreHeadAreaMeshVis=`getAttr ForeHeadAreaMesh.v`;
if (!$foreHeadAreaMeshVis) setAttr ForeHeadAreaMesh.v 1;
$foreHeadAreaBBMin=`getAttr ForeHeadAreaMesh.boundingBoxMin`;
$foreHeadAreaBBMax=`getAttr ForeHeadAreaMesh.boundingBoxMax`;
if (!$foreHeadAreaMeshVis) setAttr ForeHeadAreaMesh.v 0;

//ForeHeadWrinkles
createNode -n ForeHeadWrinkles -p WrinkleCurves transform;
$posA=`xform -q -ws -t EyeBrowInner_R`;
$posB=`xform -q -ws -t EyeBrowOuter_R`;
$posC=`xform -q -ws -t EyeBrowCenter_M`;
//$bbMax=`getAttr ForeHeadAreaMeshExtrude.boundingBoxMax`;
xform -ws -t $posC[0] (($posC[1]+$foreHeadAreaBBMax[1])/2.0) $posC[2] tempLoc;
delete `geometryConstraint ForeHeadAreaMesh tempLoc`;
spaceLocator -n tempLoc2;
pointConstraint tempLoc EyeBrowCenter_M tempLoc2;
$pos=`xform -q -ws -t tempLoc2`;
delete tempLoc2;
$curveCmd="curve -d 1 -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$offsetDist=$pos[1]-$posC[1];
$curveCmd+=" -p "+$posA[0]+" "+($posA[1]+$offsetDist)+" "+$posA[2];

for ($i=1;$i<3;$i++)
	{
	if (!`objExists ("EyeBrowMid"+$i+"_R")`)
		continue;
	$pos=`xform -q -ws -t ("EyeBrowMid"+$i+"_R")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] tempLoc;
	delete `geometryConstraint ForeHeadAreaMesh tempLoc`;
	move -r 0 $offsetDist 0 tempLoc;
	delete `geometryConstraint ForeHeadAreaMesh tempLoc`;
	$pos=`xform -q -ws -t tempLoc`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}

xform -ws -t $posB[0] $posB[1] $posB[2] tempLoc;
move -r ($offsetDist*-1) ($offsetDist*0.5) ($offsetDist*-1) tempLoc;
delete `geometryConstraint ForeHeadAreaMesh tempLoc`;
$pos=`xform -q -ws -t tempLoc`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] ForeHeadWrinkle1;
parent ForeHeadWrinkle1 ForeHeadWrinkles;
asWmAddAttrs ForeHeadWrinkle1 10 10;

$bbMin=`getAttr ForeHeadWrinkleShape1.boundingBoxMin`;
$bbMax=`getAttr ForeHeadWrinkleShape1.boundingBoxMax`;
$eyeBrowCenterPos={($bbMin[0]+$bbMax[0])/2.0,($bbMin[1]+$bbMax[1])/2.0,($bbMin[2]+$bbMax[2])/2.0};
//$bbMax=`getAttr ForeHeadAreaMeshExtrude.boundingBoxMax`;
$eyeBallPos=`xform -q -ws -t FitEyeBall`;
//move -a $eyeBrowCenterPos[0] $eyeBallPos[1] $posA[2] ForeHeadWrinkle1.scalePivot ForeHeadWrinkle1.rotatePivot ;
$maxScale=($foreHeadAreaBBMax[1]-$eyeBallPos[1]) / ($posA[1]-$eyeBallPos[1]);

for ($i=1;$i<5;$i++)
	{
	if ($i!=1) duplicate -n ("ForeHeadWrinkle"+$i) ForeHeadWrinkle1;
//	$value=1+(($offsetDist*0.75)*$i);
//	setAttr ("ForeHeadWrinkle"+$i+".s") -type float3 1 $value 1;
	if ($i>1)
		move -r 0 ($offsetDist*0.70*($i-1)) 0 ("ForeHeadWrinkle"+$i+".cv[0:99]");
	if ($i==1) {$width=20;$depth=10;}
	if ($i==2) {$width=15;$depth=5;}
	if ($i==3) {$width=10;$depth=7;}
	if ($i==4) {$width=5;$depth=1;}
	setAttr ("ForeHeadWrinkle"+$i+".depth") $depth;	
	setAttr ("ForeHeadWrinkle"+$i+".width") $width;	
	}

//FrownWrinkles
createNode -n FrownWrinkles -p WrinkleCurves transform;
$posA=`xform -q -ws -t EyeBrowInner_R`;
$posB=`xform -q -ws -t ForeHeadWrinkle1.cv[0]`;
$posC=`xform -q -ws -t EyeBrowCenter_M`;

$curveCmd="curve -d 1 -p "+($posA[0]/2.8)+" "+($posB[1]-($offsetDist*0.70))+" "+$posA[2];
$curveCmd+=" -p "+($posA[0]/2.5)+" "+($posB[1]-($offsetDist*1.7))+" "+$posA[2];
$curveCmd+=" -p "+($posA[0]/1.0)+" "+($posB[1]-($offsetDist*2.2))+" "+$posA[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] FrownWrinkle1;
parent FrownWrinkle1 FrownWrinkles;
asWmAddAttrs FrownWrinkle1 7 12;

//CrowsFeetWrinkles
createNode -n CrowsFeetWrinkles -p WrinkleCurves transform;
//$bbMin=`getAttr ForeHeadAreaMeshExtrude.boundingBoxMin`;
//$bbMax=`getAttr ForeHeadAreaMeshExtrude.boundingBoxMax`;
$numCv=`asGetCurveNumCvs upperEyeLidMainCurve`;
$posA=`xform -q -ws -t ("upperEyeLidMainCurve.cv["+($numCv-1)+"]")`;
$posB={$foreHeadAreaBBMin[0],$posA[1],$foreHeadAreaBBMin[2]};
xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) tempLoc;
delete `geometryConstraint $mesh tempLoc`;
$posB=`xform -q -ws -t tempLoc`;
$value=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
$curveCmd="curve -d 1 -p "+$posA[0]+" "+$posA[1]+" "+$posA[2];
$curveCmd+=" -p "+$posB[0]+" "+$posB[1]+" "+$posB[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] CrowsFeetWrinkle2;
parent CrowsFeetWrinkle2 CrowsFeetWrinkles;
asWmAddAttrs CrowsFeetWrinkle2 6 6;

$posA=`xform -q -ws -t ("upperEyeLidMainCurve.cv["+($numCv-2)+"]")`;
$curveCmd="curve -d 1 -p "+$posA[0]+" "+$posA[1]+" "+$posA[2];
$curveCmd+=" -p "+$posB[0]+" "+($posB[1]+($scale/20.0))+" "+$posB[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] CrowsFeetWrinkle1;
parent CrowsFeetWrinkle1 CrowsFeetWrinkles;
asWmAddAttrs CrowsFeetWrinkle1 4 4;

$numCv=`asGetCurveNumCvs lowerEyeLidMainCurve`;
$posA=`xform -q -ws -t ("lowerEyeLidMainCurve.cv["+($numCv-2)+"]")`;
$curveCmd="curve -d 1 -p "+$posA[0]+" "+$posA[1]+" "+$posA[2];
$curveCmd+=" -p "+$posB[0]+" "+($posB[1]-($scale/20.0))+" "+$posB[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] CrowsFeetWrinkle3;
parent CrowsFeetWrinkle3 CrowsFeetWrinkles;
asWmAddAttrs CrowsFeetWrinkle3 4 4;

//BunnyLinesWrinkles
createNode -n BunnyLinesWrinkles -p WrinkleCurves transform;
$posA=`xform -q -ws -t innerLid_R`;

$curveCmd="curve -d 1 -p "+$posA[0]+" "+$posA[1]+" "+$posA[2];
xform -ws -t 0 $posA[1] $posA[2] tempLoc;
pointConstraint innerLid_R innerLid_L Nose_M NoseCorner_R tempLoc;
setAttr tempLoc_pointConstraint1.NoseCorner_RW3 0;
setAttr tempLoc_pointConstraint1.Nose_MW2 0.5;
setAttr tempLoc_pointConstraint1.innerLid_LW1 0.5;
$posB=`xform -q -ws -t tempLoc`;
$curveCmd+=" -p "+$posB[0]+" "+$posB[1]+" "+$posB[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] BunnyLinesWrinkle1;

$curveCmd="curve -d 1 -p "+$posA[0]+" "+($posA[1]-($scale/80.0))+" "+$posA[2];
setAttr tempLoc_pointConstraint1.NoseCorner_RW3 1;
setAttr tempLoc_pointConstraint1.Nose_MW2 1;
setAttr tempLoc_pointConstraint1.innerLid_LW1 0;
$posB=`xform -q -ws -t tempLoc`;
$curveCmd+=" -p "+$posB[0]+" "+$posB[1]+" "+$posB[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] BunnyLinesWrinkle3;

delete tempLoc_pointConstraint1;

duplicate -n BunnyLinesWrinkle2 BunnyLinesWrinkle3;
select BunnyLinesWrinkle1 BunnyLinesWrinkle2;
blendShape -n tempBs -frontOfChain -w 0 0.5;
select BunnyLinesWrinkle2;
DeleteHistory;
reorder -relative -1 BunnyLinesWrinkle2 ;

for ($i=1;$i<4;$i++)
	{
	reverseCurve -ch 0 -rpo 1 ("BunnyLinesWrinkle"+$i);
	parent ("BunnyLinesWrinkle"+$i) BunnyLinesWrinkles;
	}
asWmAddAttrs BunnyLinesWrinkle1 1 1;
asWmAddAttrs BunnyLinesWrinkle2 3 3;
asWmAddAttrs BunnyLinesWrinkle3 3 3;

//asWmAddAttrs BunnyLinesWrinkle3 3 3;

//SmileLineWrinkles
createNode -n SmileLineWrinkles -p WrinkleCurves transform;
pointConstraint -w 0.5 NoseCorner_R tempLoc;
pointConstraint -w 0.25 innerLid_R tempLoc;
pointConstraint -w 0.25 Nose_M tempLoc;
delete tempLoc_pointConstraint1;
delete `geometryConstraint $mesh tempLoc`;
$pos=`xform -q -ws -t tempLoc`;
$curveCmd="curve -d 1 -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
pointConstraint -w 0.7 Lip_R tempLoc;
pointConstraint -w 0.3 Cheek_R tempLoc;
delete `geometryConstraint $mesh tempLoc`;
$pos=`xform -q -ws -t tempLoc`;
$curveCmd+=" -p "+$pos[0]+" "+($pos[1]+($scale/20.0))+" "+$pos[2];
$curveCmd+=" -p "+$pos[0]+" "+($pos[1]-($scale/20.0))+" "+$pos[2];
$pos=`xform -q -ws -t Lip_R`;
$curveCmd+=" -p "+$pos[0]+" "+($pos[1]-($scale/10.0))+" "+$pos[2];
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] SmileLineWrinkle1;
parent SmileLineWrinkle1 SmileLineWrinkles;
asWmAddAttrs SmileLineWrinkle1 10 10;

$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
//delete tempLoc;

//ReBuild, geostick and pushout curves
//spaceLocator -n tempLoc;
$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -c -type transform $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		$curves[size($curves)]=$tempString2[$y];
	}

for ($i=0;$i<size($curves);$i++)
	{
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 3 -d 3 -tol 0.00155 $curves[$i];
	$crossingXaxis=0;
	for ($y=0;$y<6;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempLoc;
		delete `geometryConstraint $mesh tempLoc`;
		$pos=`xform -q -ws -t tempLoc`;
		if ($pos[0]>0)
			{//avoid crossing X axis
			$crossingXaxis=1;
			xform -ws -t 0 $pos[1] $pos[2] tempLoc;
			delete `geometryConstraint $mesh tempLoc`;
			$pos=`xform -q -ws -t tempLoc`;
			}
		if ($y==1 && $crossingXaxis)
			{//avoid steep-angle-joint (L/R)
			$posA=`xform -q -ws -t ($curves[$i]+".cv[0]")`;
			xform -ws -t $pos[0] $posA[1] $pos[2] tempLoc;
			delete `geometryConstraint $mesh tempLoc`;
			$pos=`xform -q -ws -t tempLoc`;
			}
		xform -ws -t $pos[0] $pos[1] $pos[2] ($curves[$i]+".cv["+$y+"]");
//		scale -r -p $headJointPos[0] $headJointPos[1] $headJointPos[2] 1.015 1.015 1.015 ($curves[$i]+".cv["+$y+"]");
		}
	}
delete tempLoc;

asWmEdit All Curves;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
}

global proc asWrinkleMap ()
{
int $numUvs,$uvSetNr,$nr,$numCv,$layerNr,$rigTypeInt;
float $maxV,$minV,$value,$tx,$driverRightValue;
float $bbMin[],$bbMax[],$pos[],$driverValues[];
string $mesh,$existingBumpMapConnectedNode,$side,$InnerOuter,$wrinkleGroup,$side,$uc,$shader,$duplicatedSG;
string $secDriverObj,$secDriverAttr;
string $ip=`asWmImagePath`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $allBefore[]=`ls`;
string $tempString[],$tempString2[],$tempString3[],$curves[],$sections[],$drivers[],$secDrivers[];
string $outUvAttrs[]={"outUv","outVertexUvOne","outVertexUvTwo","outVertexUvThree","outVertexCameraOne"};
string $inUvAttrs[] ={"uvCoord","vertexUvOne","vertexUvTwo","vertexUvThree","vertexCameraOne"};
string $XYZ[]={"X","Y","Z"};

if (!`objExists WrinkleCurves`)
	error "WrinkleCurves not found, you must run \"Create Wrinkle Curves\" first.";

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;

setAttr  WrinkleMap.modifier `getModifiers`;
if (`objExists FaceWrinkleSet`)
	{
	asWrinkleCurves;//let asWrinkleCurves do the removal
	return;
	}

if (`attributeExists RigType FaceFitSkeleton`)
	$rigTypeInt=`getAttr FaceFitSkeleton.RigType`;
$tempString=`listRelatives -s -ni $geometry`;
$mesh=$tempString[0];

asWmEditCancel;//ensure scale 1 for WrinkleCurves
$shader=`getAttr WrinkleMap.shader`;
createNode -n asWrinkleMapBuilding transform;

addAttr -k 1 -ln wrinkleMapMultiply -dv 1 ctrlBox;
setAttr -k 0 -cb 1 ctrlBox.wrinkleMapMultiply;
addAttr -k 1 -ln wrinkleMapOffset ctrlBox;
setAttr -k 0 -cb 1 ctrlBox.wrinkleMapOffset;

asWmUVUpdate;

//uvChooser
if (!`objExists uvChooserFaceWrinkles`)
	createNode -n uvChooserFaceWrinkles uvChooser;
for ($i=0;$i<`getAttr -s ($mesh+".uvSet")`;$i++)
	{
	$tempString[0]=`getAttr ($mesh+".uvSet["+$i+"].uvSetName")`;
	if ($tempString[0]=="uvFaceWrinkles")
		$uvSetNr=$i;
	}
connectAttr -f ($mesh+".uvSet["+$uvSetNr+"].uvSetName") uvChooserFaceWrinkles.uvSets[0];

if ($existingBumpMapConnectedNode!="")
	disconnectAttr ($existingBumpMapConnectedNode+".outNormal") ($shader+".normalCamera");
shadingNode -asTexture -n fileFaceWrinkles file;
defaultNavigation -ce -source fileFaceWrinkles -destination ($shader+".normalCamera");
$tempString=`listConnections -s 1 -d 0 ($shader+".normalCamera")`;
rename $tempString[0] bump2dWrinkle;
for ($a=0;$a<size($outUvAttrs);$a++)
	connectAttr ("uvChooserFaceWrinkles."+$outUvAttrs[$a]) ("fileFaceWrinkles."+$inUvAttrs[$a]);

if ($existingBumpMapConnectedNode!="")
	connectAttr ($existingBumpMapConnectedNode+".outNormal") bump2dWrinkle.normalCamera;

//Masks
shadingNode -asUtility -n multDoubleLinearFaceWrinkles1 multDoubleLinear;
connectAttr ctrlBox.wrinkleMapMultiply multDoubleLinearFaceWrinkles1.input1;
setAttr multDoubleLinearFaceWrinkles1.input2 0.5;//normalize 0.5 to default muliplier value of 1
shadingNode -asUtility -n multDoubleLinearFaceWrinkles2 multDoubleLinear;
connectAttr multDoubleLinearFaceWrinkles1.output multDoubleLinearFaceWrinkles2.input2;
shadingNode -asUtility -n plusMinusAverageFaceWrinkles plusMinusAverage;
connectAttr multDoubleLinearFaceWrinkles2.output plusMinusAverageFaceWrinkles.input1D[0];
connectAttr ctrlBox.wrinkleMapOffset plusMinusAverageFaceWrinkles.input1D[1];
connectAttr plusMinusAverageFaceWrinkles.output1D bump2dWrinkle.bumpDepth;

shadingNode -asTexture -n WrinkleMasksLayeredTexture layeredTexture;
setAttr WrinkleMasksLayeredTexture.alphaIsLuminance 1;
connectAttr WrinkleMasksLayeredTexture.outAlpha multDoubleLinearFaceWrinkles2.input1;
$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b== 1) $side="_R";
		if ($b==-1) $side="_L";

		$wrinkleGroup=`substitute "Wrinkles" $tempString[$i] ""`;
		clear $drivers;
		clear $driverValues;
		clear $secDrivers;
		if ($wrinkleGroup=="ForeHead") 		{$drivers[0]="ctrlBrow"+$side+".ty";$driverValues[0]=1;$driverValues[1]=1;$secDrivers[0]="EyeBrowOuter"+$side+".ty";$secDrivers[1]="EyeBrowInner"+$side+".ty";}
		if ($wrinkleGroup=="Frown") 			{$drivers[0]="ctrlBrow"+$side+".squeeze";$driverValues[0]=10;$secDrivers[0]="EyeBrowInner"+$side+".tx";}
		if ($wrinkleGroup=="CrowsFeet") 	{$drivers[0]="ctrlEye"+$side+".squint";$driverValues[0]=10;}
		if ($wrinkleGroup=="BunnyLines") 	{$drivers[0]="ctrlNose"+$side+".ty";$driverValues[0]=1;$secDrivers[0]="NoseCorner"+$side+".ty";}
		if ($wrinkleGroup=="SmileLine") 	{$drivers[0]="ctrlMouthCorner"+$side+".txPos_tyPos";$driverValues[0]=1;$secDrivers[0]="Lip"+$side+".tx";$secDrivers[1]="Lip"+$side+".ty";}

		clear $sections;
		$sections={""};
		if ($wrinkleGroup=="ForeHead") $sections={"U1","U2"};
		if ($wrinkleGroup=="SmileLine") $sections={"U1","U2"};

		if (!`attributeExists driver ($wrinkleGroup+"Wrinkles")`)
			{
			addAttr -k 1 -ln driver -dt "string" ($wrinkleGroup+"Wrinkles");
			setAttr -type "string" ($wrinkleGroup+"Wrinkles.driver") $drivers[0];
			addAttr -k 1 -ln multiply -dv 1 -min 0 -max 2 ($wrinkleGroup+"Wrinkles");
			setAttr -k 0 -cb 1 ($wrinkleGroup+"Wrinkles.multiply");
			addAttr -k 1 -ln offset -dv 0 ($wrinkleGroup+"Wrinkles");
			setAttr -k 0 -cb 1 ($wrinkleGroup+"Wrinkles.offset");
			addAttr -k 1 -ln start -dv 0.25 -min 0 -max 1 ($wrinkleGroup+"Wrinkles");
			setAttr -k 0 -cb 1 ($wrinkleGroup+"Wrinkles.start");
			}
		if ($rigTypeInt!=1)//Not BlendShapes only
			{
			if (!`objExists WrinkleDrivers`)
				{
				createNode -n WrinkleDrivers -p WrinkleMap transform;
				parentConstraint -mo FaceMotionSystem WrinkleDrivers;
				for ($y=0;$y<size($XYZ);$y++)
					connectAttr ("FaceMotionSystem.scale"+$XYZ[$y]) ("WrinkleDrivers.scale"+$XYZ[$y]);
				}
			for ($y=0;$y<size($secDrivers);$y++)
				{
				tokenize $secDrivers[$y] "[.]" $tempString2;
				$secDriverObj=$tempString2[0];
				$secDriverAttr=$tempString2[1];
				createNode -n ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side) -p WrinkleDrivers transform;
				createNode -n ($wrinkleGroup+"Driver"+($y+1)+$side) -p ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side) transform;			
				asAlign ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side) $secDriverObj 1 1 0 0;
				$drivers[$y]=($wrinkleGroup+"Driver"+($y+1)+$side+"."+$secDriverAttr);
				if ($wrinkleGroup=="SmileLine")
					{//45 degree offset driving to separate smile/frown
//					setAttr ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side+".rotateOrder") 2;
//					setAttr ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side+".rz") -45;
					rotate -r -os 0 0 45 ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side); 
					//swap x/y
//					rotate -r -os -fo 0 180 -90 ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side);
					rotate -r -os -180 0 0 ($wrinkleGroup+"Driver"+($y+1)+"Offset"+$side);
					}
				if ($side=="_R")
					{
					asWmEdit $wrinkleGroup "Test";
					$pos=`xform -q -ws -t $secDriverObj`;
					asWmEditCancel;
					xform -ws -t $pos[0] $pos[1] $pos[2] ($wrinkleGroup+"Driver"+($y+1)+$side);
					$driverValues[$y]=`getAttr ($wrinkleGroup+"Driver"+($y+1)+$side+"."+$secDriverAttr)`;
					if ($wrinkleGroup=="SmileLine" && $y==1)
						$driverValues[$y]=$driverValues[$y-1];
					setAttr ($wrinkleGroup+"Driver"+($y+1)+$side+"."+$secDriverAttr) 0;
					$driverRightValue=$driverValues[$y];
					}
				else
					$driverValues[$y]=$driverRightValue;

				if ($driverValues[$y]==0) $driverValues[$y]=0.1;//avoid Division by zero
				pointConstraint $secDriverObj ($wrinkleGroup+"Driver"+($y+1)+$side);
				}
			}

		asLockAttr $tempString[$i] 1 1 1 0;

		for ($y=0;$y<size($sections);$y++)
			{
			if ($side=="_R")
				{
				addAttr -ln ("sections"+$y) -dt "string" ($wrinkleGroup+"Wrinkles");
				setAttr -type "string" ($wrinkleGroup+"Wrinkles.sections"+$y) $sections[$y];
				}
			setAttr ("WrinkleMasksLayeredTexture.inputs["+$layerNr+"].color") -type double3 0 0 0;
			setAttr ("WrinkleMasksLayeredTexture.inputs["+$layerNr+"].blendMode") 4;//Add
			shadingNode -asTexture -n ("fileWrinkle"+$wrinkleGroup+$sections[$y]+$side) file;
			for ($a=0;$a<size($outUvAttrs);$a++)
				connectAttr ("uvChooserFaceWrinkles."+$outUvAttrs[$a]) ("fileWrinkle"+$wrinkleGroup+$sections[$y]+$side+"."+$inUvAttrs[$a]);
			connectAttr -f ("fileWrinkle"+$wrinkleGroup+$sections[$y]+$side+".outColor") ("WrinkleMasksLayeredTexture.inputs["+$layerNr+"].color");

			createNode -n ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side) setRange;
			setAttr ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".maxX") 1;
			setAttr ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".oldMaxX") 1;

			createNode -n ("srWrinkleMultiplyUC"+$wrinkleGroup+$sections[$y]+$side) unitConversion;
			setAttr ("srWrinkleMultiplyUC"+$wrinkleGroup+$sections[$y]+$side+".conversionFactor") 0.5;
			connectAttr ($wrinkleGroup+"Wrinkles.multiply") ("srWrinkleMultiplyUC"+$wrinkleGroup+$sections[$y]+$side+".input");

			connectAttr ("srWrinkleMultiplyUC"+$wrinkleGroup+$sections[$y]+$side+".output") ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".maxX");
			connectAttr ($wrinkleGroup+"Wrinkles.start") ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".oldMinX");
			connectAttr ($wrinkleGroup+"Wrinkles.offset") ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".minX");

			if ($driverValues[$y]==1)
				connectAttr $drivers[$y] ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".value.valueX");
			else
				{
				$uc=`substitute "[.]" $drivers[$y] "_"`;
				if (`objExists $uc`) delete $uc;
				createNode -n $uc unitConversion;
				setAttr ($uc+".conversionFactor") (1.0/$driverValues[$y]);
				connectAttr $drivers[$y] ($uc+".input");
				connectAttr ($uc+".output") ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".value.valueX");
				}

			//sdk as direct connection does not continuous-update in M2022
			setDrivenKeyframe -itt Spline -ott Spline -dv 0 -v 0 -currentDriver ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".outValueX") ("WrinkleMasksLayeredTexture.inputs["+$layerNr+"].alpha");
			setDrivenKeyframe -itt Flat   -ott Flat   -dv 1 -v 1 -currentDriver ("srWrinkle"+$wrinkleGroup+$sections[$y]+$side+".outValueX") ("WrinkleMasksLayeredTexture.inputs["+$layerNr+"].alpha");

			$layerNr++;
			}
		}
	}

asWmBake;
delete asWrinkleMapBuilding;

//Wrinkleset
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;
select $allAfter;
select -d $allSame;
sets -name FaceWrinkleSet;
if (`objExists "Sets"`)
sets -add "Sets" FaceWrinkleSet;
select -cl;

$duplicatedSG=`getAttr -asString WrinkleMap.duplicatedSG`;
if ($duplicatedSG!="")
	if (`objExists $duplicatedSG`)
		sets -add FaceWrinkleSet $duplicatedSG;

$tempString=`sets -q FaceWrinkleSet`;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*[.]*"`)
	setAttr ($tempString[$i]+".isHistoricallyInteresting") 0;

select ctrlBox;
print ("// WrinkleMap created\n");
}

global proc asWmBake ()
{
global string $gMainProgressBar;
int $mapWidth=`getAttr WrinkleMap.mapWidth`;
int $mapHeight=`getAttr WrinkleMap.mapHeight`;
int $maskWidth=`getAttr WrinkleMap.maskWidth`;
int $maskHeight=`getAttr WrinkleMap.maskHeight`;
int $modifier=`getAttr WrinkleMap.modifier`;
int $nr,$numCv,$crossingXaxis;
float $u,$v,$value,$depth,$width,$offsetA,$offsetB,$centerPos;
float $scale=`getAttr FaceFitSkeleton.faceScale`;
float $pos[],$posA[],$posB[],$bbMin[],$bbMax[],$normals[],$uvValues[],$eyeBrowInnerUV[];
string $polyPlane,$wrinkleGroup,$wrinklesMesh,$wrinkleDepthShader,$wrinkleDepthShaderSG,$randString,$currentUVSet;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $headJointPos[]=`xform -q -ws -t $headJoint`;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $ip=`getAttr WrinkleMap.imagePath`;
string $ext=`getAttr -asString WrinkleMap.format`;
string $imConvertCmd=`asGetImConvertCmd`;
string $defultUVset="map1";
string $allBefore[],$tempString[],$tempString2[],$curves[],$sections[];

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating WrinkleMaps" -bp -ii 1 -min 0 -max 10 $gMainProgressBar;

if (`objExists WrinkleRendering`)
	{
	$tempString=`sets -q FaceWrinkleRenderingSet`;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists $tempString[$i]`)
				delete $tempString[$i];
	}
$allBefore=`ls`;

$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -c -type transform $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		$curves[size($curves)]=$tempString2[$y];
	}

$tempString=`listRelatives -s -ni $geometry`;
$mesh=$tempString[0];
if (`objExists WrinkleRendering`)
	delete WrinkleRendering;

$tempString=`polyUVSet -q -currentUVSet $mesh`;
$currentUVSet=$tempString[0];
polyUVSet -currentUVSet -uvSet uvFaceWrinkles $mesh;

asFaceFitReSelect EyeBrowInner_R "";
ConvertSelectionToUVs;
$eyeBrowInnerUV=`polyEditUV -q`;

createNode -n WrinkleRendering transform;
createNode -n WrinkleRenderingPlanes -p WrinkleRendering transform;
createNode -n WrinkleRenderingCurves -p WrinkleRendering transform;
createNode -n WrinkleRenderingMasks -p WrinkleRendering transform;
createNode -n WrinkleRenderingMeshes -p WrinkleRendering transform;
//createNode -n WrinkleRenderingMasks -p WrinkleRendering transform;
if (!`file -q -ex $ip`)
	sysFile -md $ip;

polyPlane -n WrinkleFacePlane1 -w 0.5 -h 1 -sx 1 -sy 1 -ax 0 1 0 -cuv 2 -ch 0;
polyProjection -ch 0 -type Planar -ibd on -md y WrinkleFacePlane1.f[0:8];
parent WrinkleFacePlane1 WrinkleRenderingPlanes;
setAttr WrinkleFacePlane1.t -type float3 0.25 0 0.5;
setAttr WrinkleFacePlane1.v 0;
duplicate -n WrinkleFacePlane2 WrinkleFacePlane1;

duplicate -n WrinkleFacePlane3 WrinkleFacePlane2;
setAttr WrinkleFacePlane3.tx 0.5;
setAttr WrinkleFacePlane3.sx 2;

polyPlane -n WrinkleFacePlane4 -w 1 -h 1 -sx 1 -sy 1 -ax 0 1 0 -cuv 2 -ch 0;
setAttr WrinkleFacePlane4.t -type float3 0 -0.0125 0.5;
setAttr WrinkleFacePlane4.rz 90;
setAttr WrinkleFacePlane4.sx 0.025;
setAttr WrinkleFacePlane4.v 0;
parent WrinkleFacePlane4 WrinkleRenderingPlanes;

$tempString=`polyUVSet -q -allUVSets $geometry`;
if (!`stringArrayCount "map1" $tempString`)
	$defultUVset=$tempString[0];

duplicate -n tempMainGeometry $geometry;
polyCopyUV -uvSetNameInput "" -uvSetName $defultUVset  -ch 1 tempMainGeometry;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f tempMainGeometry.outMesh closestSampler.inMesh;

for ($i=0;$i<size($curves);$i++)
	{
	$numCv=`asGetCurveNumCvs $curves[$i]`;
	duplicate -n ($curves[$i]+"OnPlane") $curves[$i];
	parent ($curves[$i]+"OnPlane") WrinkleRenderingCurves;
	xform -ws -piv 0 0 0 ($curves[$i]+"OnPlane");
	for ($y=0;$y<$numCv;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$u=`getAttr closestSampler.parameterU`;
		$v=`getAttr closestSampler.parameterV`;
		xform -ws -t $u 0 (1-$v) ($curves[$i]+"OnPlane.cv["+$y+"]");
		}
	}
delete tempMainGeometry;

for ($i=0;$i<size($curves);$i++)
	{
	$depth=10;
	$width=10;
	$centerPos=0.5;
	if (`attributeExists depth $curves[$i]`)  $depth=`getAttr ($curves[$i]+".depth")`;
	if (`attributeExists width  $curves[$i]`) $width=`getAttr ($curves[$i]+".width")`;

	$offsetA=$width* 0.001;
	$offsetB=$width*-0.001;
	if ($curves[$i]=="SmileLineWrinkle1")
		{//special case, custom ramp for SmileLine to have a `one-way-bump`
		$offsetB=$width*-0.025;
		$centerPos=0.1;
		}

	$tempString=`offsetCurve -n ($curves[$i]+"OnPlaneOffsetA") -ch 1 -rn false -cb 2 -st true -cl true -cr 0 -d $offsetA -tol 0.01 -sd 5 -ugn true -nr 0 90 0 ($curves[$i]+"OnPlane")`;
	rename $tempString[1] ($curves[$i]+"OffsetCurveA");
	$tempString=`offsetCurve -n ($curves[$i]+"OnPlaneOffsetB") -ch 1 -rn false -cb 2 -st true -cl true -cr 0 -d $offsetB -tol 0.01 -sd 5 -ugn true -nr 0 90 0 ($curves[$i]+"OnPlane")`;
	rename $tempString[1] ($curves[$i]+"OffsetCurveB");
	if ($curves[$i]=="SmileLineWrinkle1")
		{//ensure SmileLineOffset not exceed borders
		$bbMin=`getAttr ($curves[$i]+"OnPlaneOffsetB.boundingBoxMin")`;
		if ($bbMin[0]<0.03)
			for ($y=1;$y<20;$y++)
				{
				setAttr SmileLineWrinkle1OffsetCurveB.distance ($offsetB+(0.01*$y));
				$bbMin=`getAttr ($curves[$i]+"OnPlaneOffsetB.boundingBoxMin")`;
				if ($bbMin[0]>0.03)
					break;
				}
		$offsetB=`getAttr SmileLineWrinkle1OffsetCurveB.distance`;
		}
	addAttr -k 0 -ln offsetA -at double -dv $offsetA ($curves[$i]+"OnPlane");
	addAttr -k 0 -ln offsetB -at double -dv $offsetB ($curves[$i]+"OnPlane");
	select ($curves[$i]+"OnPlaneOffsetA") ($curves[$i]+"OnPlane") ($curves[$i]+"OnPlaneOffsetB");
	//not include offsetCurves that crosses center
	$bbMin=`getAttr ($curves[$i]+"OnPlaneOffsetA.boundingBoxMin")`;
	if ($bbMin[0]>0.5)
		select -d ($curves[$i]+"OnPlaneOffsetA");
//	loft -n ($curves[$i]+"Loft") -ch 1 -u 1 -c 0 -ar 0 -d 3 -ss 1 -rn 0 -po 0 -rsn true;
	loft -n ($curves[$i]+"Loft") -ch 0 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true;
	parent ($curves[$i]+"OnPlaneOffsetA") ($curves[$i]+"OnPlaneOffsetB") WrinkleRenderingCurves;
	nurbsToPoly -n ($curves[$i]+"Mesh") -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 20 -vt 1 -vn 21 -uch 0 -ucr 0 -cht 0.01 -es 0 -ntr 0 -mrt 0 -uss 1 ($curves[$i]+"Loft");
	parent ($curves[$i]+"Mesh") WrinkleRenderingMeshes;
	$normals=`polyNormalPerVertex -q -normalY ($curves[$i]+"Mesh.vtx[0]")`;
	if ($normals[0]<0)
		polyNormal -ch 0 -normalMode 0 -userNormalMode 0 ($curves[$i]+"Mesh");
	delete ($curves[$i]+"OnPlaneOffsetA") ($curves[$i]+"OnPlaneOffsetB") ($curves[$i]+"Loft");
	select ($curves[$i]+"Mesh");
	DeleteHistory;

	//ramp
	$wrinkleDepthShader=`shadingNode -asShader -n ($curves[$i]+"WrinkleDepthShader") surfaceShader`;
	$tempString[0]=`sets -renderable true -noSurfaceShader true -empty -name ($curves[$i]+"WrinkleDepthShaderSG")`;
	$wrinkleDepthShaderSG=$tempString[0];
	connectAttr -f ($wrinkleDepthShader+".outColor") ($wrinkleDepthShaderSG+".surfaceShader");
	shadingNode -asTexture -n ($curves[$i]+"WrinkleDepthRamp1") ramp;//(fade in/out)
	$tempString[0]=`shadingNode -asUtility -n ($curves[$i]+"WrinkleDepthRampPlace2dTexture") place2dTexture`;
	connectAttr ($tempString[0]+".outUV") ($curves[$i]+"WrinkleDepthRamp1.uv");
	connectAttr ($tempString[0]+".outUvFilterSize") ($curves[$i]+"WrinkleDepthRamp1.uvFilterSize");
	connectAttr ($curves[$i]+"WrinkleDepthRamp1.outColor") ($wrinkleDepthShader+".outColor");
	setAttr ($curves[$i]+"WrinkleDepthRamp1.type") 0;
	setAttr ($curves[$i]+"WrinkleDepthRamp1.interpolation") 4;
	setAttr ($curves[$i]+"WrinkleDepthRamp1.colorEntryList[0].color") -type double3 0 0 0;
	setAttr ($curves[$i]+"WrinkleDepthRamp1.colorEntryList[1].position") $centerPos;
	setAttr ($curves[$i]+"WrinkleDepthRamp1.colorEntryList[1].color") -type double3 1 1 1;
	setAttr ($curves[$i]+"WrinkleDepthRamp1.colorEntryList[2].position") 1;
	setAttr ($curves[$i]+"WrinkleDepthRamp1.colorEntryList[2].color") -type double3 0 0 0;

	shadingNode -asTexture -n ($curves[$i]+"WrinkleDepthRamp2") ramp;//(ends)
	$tempString[0]=`shadingNode -asUtility -n ($curves[$i]+"WrinkleDepthRampPlace2dTexture") place2dTexture`;
	connectAttr ($tempString[0]+".outUV") ($curves[$i]+"WrinkleDepthRamp2.uv");
	connectAttr ($tempString[0]+".outUvFilterSize") ($curves[$i]+"WrinkleDepthRamp2.uvFilterSize");
	setAttr ($curves[$i]+"WrinkleDepthRamp2.type") 1;
	setAttr ($curves[$i]+"WrinkleDepthRamp2.interpolation") 4;
	setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[0].color") -type double3 0 0 0;
	setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[1].position") 0.25;
	setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[1].color") -type double3 ($depth*0.1) ($depth*0.1) ($depth*0.1);
	setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[2].position") 0.75;
	if (`gmatch $curves[$i] "CrowsFeetWrinkle*"`)
		setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[2].color") -type double3 ($depth*0.05) ($depth*0.05) ($depth*0.05);
	else
		setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[2].color") -type double3 ($depth*0.1) ($depth*0.1) ($depth*0.1);
	setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[3].position") 1;
	setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[3].color") -type double3 0 0 0;
	connectAttr ($curves[$i]+"WrinkleDepthRamp2.outColor") ($curves[$i]+"WrinkleDepthRamp1.colorEntryList[1].color");
	if (`gmatch $curves[$i] "ForeHeadWrinkle*"`)//do not fade towards center
		setAttr ($curves[$i]+"WrinkleDepthRamp2.colorEntryList[0].color") -type double3 ($depth*0.1) ($depth*0.1) ($depth*0.1);

	sets -e -forceElement $wrinkleDepthShaderSG ($curves[$i]+"Mesh");
	}

select `listRelatives -c WrinkleRenderingMeshes`;
parent -w;
polyUnite -ch 0 -mergeUVSets 1 -name WrinklesMesh;
parent WrinklesMesh WrinkleRenderingMeshes;

//Generate masks
duplicate -n WrinkleFacePlane3 WrinkleFacePlane2;
setAttr WrinkleFacePlane3.tx 0.5;
setAttr WrinkleFacePlane3.sx 2;
$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	{
	$wrinkleGroup=`substitute "Wrinkles" $tempString[$i] ""`;
	clear $sections;
	for ($y=0;$y<2;$y++)
		if (`attributeExists ("sections"+$y) $tempString[$i]`)
			$sections[$y]=`getAttr -asString ($tempString[$i]+".sections"+$y)`;

	$offsetA= 0.01;
	$offsetB=-0.01;
	$tempString2=`ls ($wrinkleGroup+"Wrinkle*OnPlane")`;
	if (size($tempString2)==0)
		continue;
	if (size($tempString2)==1)
		{
		if (`attributeExists offsetA $tempString2[0]`)
			{
			$offsetA=`getAttr ($tempString2[0]+".offsetA")`;
			$offsetB=`getAttr ($tempString2[0]+".offsetB")`;
			}
		offsetCurve -n WrinkleOffsetCurve1 -ch 1 -rn false -cb 2 -st true -cl true -cr 0 -d $offsetA -tol 0.01 -sd 5 -ugn true -nr 0 90 0 $tempString2[0];
		offsetCurve -n WrinkleOffsetCurve2 -ch 1 -rn false -cb 2 -st true -cl true -cr 0 -d $offsetB -tol 0.01 -sd 5 -ugn true -nr 0 90 0 $tempString2[0];
//		loft -n ($wrinkleGroup+"WrinkleMaskSurface") -ch 0 -u 1 -c 0 -ar 0 -d 3 -ss 1 -rn 0 -po 0 -rsn true WrinkleOffsetCurve1 WrinkleOffsetCurve2;
		loft -n ($wrinkleGroup+"WrinkleMaskSurface") -ch 0 -u 1 -c 0 -ar 0 -d 1 -ss 1 -rn 0 -po 0 -rsn true WrinkleOffsetCurve1 WrinkleOffsetCurve2;
		delete WrinkleOffsetCurve1 WrinkleOffsetCurve2;
		}
	else
		{
		select $tempString2;
		loft -n ($wrinkleGroup+"WrinkleMaskSurface") -ch 0 -u 1 -c 0 -ar 0 -d 3 -ss 1 -rn 0 -po 0 -rsn true;
		}
	extendSurface -ch 0 -em 0 -et 0 -d 0.02 -jn 1 -rpo 1 -es 2 -ed 2 ($wrinkleGroup+"WrinkleMaskSurface");
	if ($wrinkleGroup=="ForeHead")
		{//special case, Forehead blends across X-axis
		$pos=`xform -q -ws -t ForeHeadWrinkleMaskSurface.cv[0][0]`;
		move -r ((1-$eyeBrowInnerUV[0])-$pos[0]) 0 0 ForeHeadWrinkleMaskSurface.cv[0][0:99];
		}
	nurbsToPoly -n ($wrinkleGroup+"WrinkleMask") -mnd 1 -ch 0 -f 1 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($wrinkleGroup+"WrinkleMaskSurface");
	delete ($wrinkleGroup+"WrinkleMaskSurface");
	parent ($wrinkleGroup+"WrinkleMask") WrinkleRenderingMasks;

	for ($y=0;$y<size($sections);$y++)
		{
		if (size($sections)>1)
			duplicate -n ($wrinkleGroup+$sections[$y]+"WrinkleMask") ($wrinkleGroup+"WrinkleMask");

		for ($z=0;$z<6;$z++)
			{//avoiding shader-caching issue
			$nr=`rand 26`;
			$randString+=`asNrToLetter $nr`;
			}

		shadingNode -asShader -n ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskShader") surfaceShader;
		$tempString[0]=`sets -renderable true -noSurfaceShader true -empty -name ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskShaderSG")`;
		rename $tempString[0] ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskShaderSG");
		connectAttr -f ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskShader.outColor") ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskShaderSG.surfaceShader");
		shadingNode -asTexture -n ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp") ramp;
		$tempString[0]=`shadingNode -asUtility -n ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRampPlace2dTexture") place2dTexture`;
		connectAttr ($tempString[0]+".outUV") ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.uv");
		connectAttr ($tempString[0]+".outUvFilterSize") ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.uvFilterSize");
		connectAttr ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.outColor") ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskShader.outTransparency");

		shadingNode -asTexture -n ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp") ramp;
		$tempString[0]=`shadingNode -asUtility -n ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRampPlace2dTexture") place2dTexture`;
		connectAttr ($tempString[0]+".outUV") ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.uv");
		connectAttr ($tempString[0]+".outUvFilterSize") ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.uvFilterSize");
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.interpolation") 4;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[0].color") -type double3 0 0 0;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[1].color") -type double3 0 0 0;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[1].position") 1.0;
		connectAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.outColor") ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.colorEntryList[0].color");

		setAttr ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.type") 5;
		setAttr ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.colorEntryList[1].color") -type double3 1 1 1;
		setAttr ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.colorEntryList[0].position") 0.9;
		setAttr ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.colorEntryList[1].position") 1.0;

		sets -e -forceElement ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskShaderSG") ($wrinkleGroup+$sections[$y]+"WrinkleMask");

		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[0].color") -type double3 0 0 0;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[1].color") -type double3 0 0 0;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.invert") 0;
		if ($wrinkleGroup=="SmileLine") setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.invert") 1;
		else setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.invert") 0;
		if (size($sections)>1)
			{//$sections blending
			if ($sections[0]=="U1") setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.type") 1;
			if ($sections[0]=="V1") setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.type") 0;
			if ($y==0) setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[0].color") -type double3 1 1 1;
			if ($y==1) setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[1].color") -type double3 1 1 1;
			}

		if ($wrinkleGroup=="ForeHead" && $sections[$y]=="U2")
		{//special case fading towards center
//		select ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp");
//		removeMultiInstance -break true ($randString+$wrinkleGroup+$sections[$y]+"WrinkleMaskRamp.colorEntryList[1]");
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[0].color") -type double3 1 1 1;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[1].color") -type double3 1 1 1;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[2].position") 0.25;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[2].color") -type double3 0 0 0;
		//determine nearestParameterU, with closestPointOnMesh

		if (`objExists closestSampler`) delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		connectAttr -f ForeHeadU1WrinkleMask.outMesh closestSampler.inMesh;
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $eyeBrowInnerUV[0] 0 (1-$eyeBrowInnerUV[1]);
		$u=`getAttr closestSampler.parameterU`;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[2].position") $u;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.interpolation") 1;
		setAttr closestSampler.inPositionX 0.5;
		$u=`getAttr closestSampler.parameterU`;
		delete closestSampler;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[3].position") $u;
		setAttr ($wrinkleGroup+$sections[$y]+"WrinkleSectionsMaskRamp.colorEntryList[3].color") -type double3 0.5 0.5 0.5;
		}

		if (!`objExists SkipBaker`)
			{
			progressBar -e -s 1 $gMainProgressBar;
			surfaceSampler -filename ($ip+"/"+$wrinkleGroup+$sections[$y]+"Mask_R") -fileFormat $ext -target WrinkleFacePlane3 -uvSet map1 -searchOffset 0 -maxSearchDistance 0 -searchCage "" -source ($wrinkleGroup+$sections[$y]+"WrinkleMask") -mapOutput alpha -mapWidth $maskWidth -mapHeight $maskHeight -max 1 -mapSpace tangent -mapMaterials 1 -shadows 1 -superSampling 1 -filterType 0 -filterSize 3 -overscan 1 -searchMethod 0 -useGeometryNormals 1 -ignoreMirroredFaces 0 -flipU 0 -flipV 0;
			system ($imConvertCmd+" "+$ip+"/"+$wrinkleGroup+$sections[$y]+"Mask_R."+$ext+" -flop "+$ip+"/"+$wrinkleGroup+$sections[$y]+"Mask_L."+$ext);
			}

		setAttr -type "string" ("fileWrinkle"+$wrinkleGroup+$sections[$y]+"_R.fileTextureName") ($ip+"/"+$wrinkleGroup+$sections[$y]+"Mask_R."+$ext);
		setAttr -type "string" ("fileWrinkle"+$wrinkleGroup+$sections[$y]+"_L.fileTextureName") ($ip+"/"+$wrinkleGroup+$sections[$y]+"Mask_L."+$ext);
		}
	if (size($sections)>1)
		delete ($wrinkleGroup+"WrinkleMask");
	}

if (!`objExists SkipBaker`)
	{
	surfaceSampler -filename ($ip+"/sampleddiffuseRGB") -fileFormat $ext -target WrinkleFacePlane2 -uvSet map1 -searchOffset 0 -maxSearchDistance 0 -searchCage "" -source WrinklesMesh -mapOutput diffuseRGB -mapWidth ($mapWidth/2) -mapHeight $mapHeight -max 1 -mapSpace tangent -mapMaterials 0 -shadows 1 -superSampling 1 -filterType 0 -filterSize 3 -overscan 1 -searchMethod 0 -useGeometryNormals 1 -ignoreMirroredFaces 0 -flipU 0 -flipV 0;
	system ($imConvertCmd+" "+$ip+"/sampleddiffuseRGB."+$ext+" -flop "+$ip+"/sampleddiffuseRGBFlipped."+$ext);
	system ($imConvertCmd+" "+$ip+"/sampleddiffuseRGB."+$ext+" "+$ip+"/sampleddiffuseRGBFlipped."+$ext+" +append "+$ip+"/bump."+$ext);
	sysFile -del ($ip+"/sampleddiffuseRGB."+$ext);
	sysFile -del ($ip+"/sampleddiffuseRGBFlipped."+$ext);
	//include a uvSnapshot
	if (!`file -q -ex ($ip+"/uvSnapshot."+$ext)`)
		{
		select $mesh;
		uvSnapshot -o -ff $ext -xr $mapWidth -yr $mapHeight -aa -r 255 -g 255 -b 255 -n ($ip+"/uvSnapshot."+$ext) -uMin 0 -uMax 1 -vMin 0 -vMax 1;
		}
	}
setAttr -type "string" fileFaceWrinkles.fileTextureName ($ip+"/bump."+$ext);

setAttr WrinkleFacePlane2.v 0;
setAttr WrinkleFacePlane3.v 0;
setAttr WrinkleRenderingMasks.v 0;
setAttr WrinkleMap.modifier 0;
polyUVSet -currentUVSet -uvSet $currentUVSet $mesh;

string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;
select $allAfter;
select -d $allSame;
select `ls -sl -o`;
sets -name FaceWrinkleRenderingSet;
if (`objExists "Sets"`)
sets -add "Sets" FaceWrinkleRenderingSet;
select -cl;

//Align WrinkleRendering to face
setAttr WrinkleRendering.rx 90;
setAttr WrinkleRendering.s -type float3 ($scale*0.75) ($scale*0.75) ($scale*0.75);
$pos=`xform -q -ws -t ctrlBox`;
setAttr WrinkleRendering.t -type float3 ($pos[0]*-1.5) ($pos[1]+($scale*0.35)) $pos[2];
setAttr WrinkleRenderingPlanes.ty ($scale*-0.005);

if ($modifier!=4)
	{
	delete WrinkleRendering;
	$tempString=`sets -q FaceWrinkleRenderingSet`;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists $tempString[$i]`)
				delete $tempString[$i];
	}
}

global proc asWmEdit (string $wrinkle, string $element)
{
int $allVis;
float $value=10;
string $driver;
string $tempString[],$wrinkleGroups[];

if (!`objExists WrinkleCurves`)
	error "WrinkleCurves not found, you must run \"Create WrinkleMap\" first.";

$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	$wrinkleGroups[$i]=`substitute "Wrinkles" $tempString[$i] ""`;

if ($element=="Curves" && !`objExists asWrinkleMapBuilding`)
	{
	if (`headsUpDisplay -q -ex HUDEDSMode`)
		headsUpDisplay -e -rem HUDEDSMode;
	headsUpDisplay -s 2 -b 0 -bs "medium" -l ("Editing WrinkleMap:  "+$wrinkle+"  ("+$element+")") -lfs "large" HUDEDSMode;
	displayColor headsUpDisplayLabels 16;
	}

if ($element!="Mask" && !`objExists WmEditRecursing`)
	asGoToBuildPose faceSetup;

if ($wrinkle=="All")
	{
	createNode -n WmEditRecursing transform;
	select -cl;
	for ($i=0;$i<size($wrinkleGroups);$i++)
		asWmEdit $wrinkleGroups[$i] $element;
	delete WmEditRecursing;
	return;
	}
else if (!`objExists WmEditRecursing`)
	select -cl;

if ($wrinkle=="All" && $element=="Curves")
	$allVis=1;

if ($element=="Curves")
	{
	setAttr WrinkleCurves.s -type float3 1.015 1 1.015;//to make curves more easily editable
	if (!`objExists WmEditRecursing`)
		for ($i=0;$i<size($wrinkleGroups);$i++)
			setAttr ($wrinkleGroups[$i]+"Wrinkles.v") 0;
	setAttr ($wrinkle+"Wrinkles.v") 1;
	select -add `listRelatives -c -type transform ($wrinkle+"Wrinkles")`;
	}
if ($element=="Mask")
	{
	select -add ($wrinkle+"Wrinkles");
	}
if ($element=="Test")
	{
	if (!`attributeExists driver ($wrinkle+"Wrinkles")`)
		error "WrinkleCurve-driver not found, you must run \"Create WrinkleMap\" first.";
	$driver=`getAttr ($wrinkle+"Wrinkles.driver")`;
	if (`gmatch $driver "*[.]t[x-y]*"`)
		$value=1;
	if ($driver=="ctrlMouthCorner_R.txPos_tyPos")
		{
		setAttr ctrlMouthCorner_R.tx 1;
		setAttr ctrlMouthCorner_R.ty 1;
		}
	else
		eval ("setAttr "+$driver+" "+$value);
	}
if ($element=="Curves" && !`objExists asWrinkleMapBuilding`)
	rowLayout -e -en 1 asWmEditApplyCancelRowLayout;

if (!`objExists asWrinkleMapBuilding`)
	print ("// Editing wrinkle: \""+$wrinkle+"\"\n");
}

global proc asWmEditApply ()
{
string $tempString[];

if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
asGoToBuildPose faceSetup;
//connectAttr -f fileFaceWrinkles.outAlpha bump2dWrinkle.bumpValue;
//connectAttr -f plusMinusAverageFaceWrinkles.output1D bump2dWrinkle.bumpDepth;
$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
setAttr WrinkleCurves.s -type float3 1 1 1;
refresh;
setAttr  WrinkleMap.modifier `getModifiers`;
asWmBake;
rowLayout -e -en 0 asWmEditApplyCancelRowLayout;

select -cl;
print ("// Applied wrinkle edit.\n");
}

global proc asWmEditCancel ()
{
string $tempString[];

if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
asGoToBuildPose faceSetup;
//connectAttr -f fileFaceWrinkles.outAlpha bump2dWrinkle.bumpValue;
//connectAttr -f plusMinusAverageFaceWrinkles.output1D bump2dWrinkle.bumpDepth;
if (`objExists WrinkleCurves`)
	$tempString=`listRelatives -c WrinkleCurves`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
rowLayout -e -en 0 asWmEditApplyCancelRowLayout;
if (`objExists WrinkleCurves`)
	setAttr WrinkleCurves.s -type float3 1 1 1;

if (!`objExists asWrinkleMapBuilding`)
	print ("// Cancelled wrinkle edit.\n");
}

global proc string asWmImagePath ()
{
asWmEnsureWrinkleMapNode;
string $ip=`getAttr WrinkleMap.imagePath`;
return $ip;
}

global proc string asWmLongestExistingImagePath ()
{
string $ip=`asWmImagePath`;
string $testPath,$longestExistingIp;
string $tempString[];

tokenize $ip "/" $tempString;
$testPath=$tempString[0];
for ($i=1;$i<size($tempString)+1;$i++)
	{
	if (`file -q -ex $testPath`)
		$longestExistingIp=$testPath;
	else
		break;
	$testPath+="/"+$tempString[$i];
	}

return $longestExistingIp;
}

global proc asWmSetFolder ()
{
string $ip=`asWmImagePath`;
string $longestExistingIp=`asWmLongestExistingImagePath`;
string $result[]=`fileDialog2 -fm 3 -cap folder -okc Set -startingDirectory $longestExistingIp`;
if ($result[0]=="")
	return;

asWmEnsureWrinkleMapNode;
setAttr -type "string" WrinkleMap.imagePath $result[0];
print ("// run \"Apply\", to re-create the maps at this new folder.\n");
rowLayout -e -en 1 asWmEditApplyCancelRowLayout;

print ("// Changed Folder to : "+$result[0]+" \n");
}

global proc asWmOpenFolder ()
{
string $ip=`asWmImagePath`;
string $longestExistingIp=`asWmLongestExistingImagePath`;

print ("// Opening : "+$ip+"\n");
if (`about -win`)
	system ("explorer "+`substituteAllString $longestExistingIp "/" "\\"`);
else if (`about -max`)
	system ("open "+$longestExistingIp);
}

global proc asWmEnsureWrinkleMapNode ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $headJointPos[]=`xform -q -ws -t $headJoint`;
string $imagesPath=`workspace -q -active`+"/"+`workspace -q -fileRuleEntry "images"`;
string $sceneName=`file -q -sn`;
string $basename=`basenameEx $sceneName`;
if ($basename=="")
	$basename="Untitled";
string $ip=$imagesPath+"/WrinkleMaps/"+$basename;
string $sel[]=`ls -sl`;

if (`objExists WrinkleMap`)
	return;

createNode -n WrinkleMap -p FaceGroup transform;
asLockAttr WrinkleMap 1 1 1 0;
addAttr -ln imagePath -dt "string" WrinkleMap;
setAttr -type "string" WrinkleMap.imagePath $ip;
addAttr -ln shader -dt "string" WrinkleMap;
addAttr -ln shaderRestoreCmd -dt "string" WrinkleMap;
addAttr -ln duplicatedSG -dt "string" WrinkleMap;
xform -ws -t $headJointPos[0] $headJointPos[1] $headJointPos[2] WrinkleMap;
addAttr -k 1 -ln mapWidth -at long -dv 1024 WrinkleMap;
addAttr -k 1 -ln mapHeight -at long -dv 1024 WrinkleMap;
addAttr -k 1 -ln maskWidth -at long -dv 512 WrinkleMap;
addAttr -k 1 -ln maskHeight -at long -dv 512 WrinkleMap;
addAttr -k 1 -ln "format" -at "enum" -en "png:tga" WrinkleMap;
addAttr -k 0 -ln modifier -at long -dv 0 WrinkleMap;
select $sel;
}

global proc asWmSettings ()
{
string $tempString[];
asWmEnsureWrinkleMapNode;
select WrinkleMap;
if (`objExists WrinkleCurves`)
	$tempString=`listRelatives -c WrinkleCurves`;
if (size($tempString))
	{
	print ("// Change attributes to change settings and run \"Apply\", to re-create the maps.\n");
	rowLayout -e -en 1 asWmEditApplyCancelRowLayout;
	}
else
	print ("// Change attributes to change settings.\n");
}

global proc asWmView (string $layer)
{
int $result;
string $soloNode;
string $windows[];

if ($layer!="Normal" && !`objExists WrinkleCurves`)
	error "WrinkleCurves not found, you must run \"Create WrinkleMap\" first.";

if ($layer=="Normal")
	{
	soloMaterial -unsolo;
	return;
	}

if ($layer=="Bump") $soloNode="bump2dWrinkle";
if ($layer=="Masks") $soloNode="WrinkleMasksLayeredTexture";
if ($layer=="BumpFile") $soloNode="fileFaceWrinkles";

$result=catchQuiet (`soloMaterial -node $soloNode`);
if ($result)
	{
	nodeEditorWindow;
	$windows=`lsUI -type window`;
	for ($i=0;$i<size($windows);$i++)
		if (`gmatch $windows[$i] "nodeEditor*Window"`)
			{
			evalDeferred ("deleteUI "+$windows[$i]);
			evalDeferred -lp ("soloMaterial -node "+$soloNode+";");
			break;
			}
	}

}

global proc asWmUVUpdate ()
{
global string $gSelect;
global string $gMainProgressBar;
int $nr,$foreHeadAreaMeshVis;
int $isBuilding=`objExists asWrinkleMapBuilding`;
int $tempInt[];
float $loBound,$hiBound,$boundHeight,$min,$startTime;
float $pos[],$bbMin[],$bbMax[],$vals[],$uvs[],$uvValues[],$uvValues2[];
float $foreHeadAreaBBMin[],$foreHeadAreaBBMax[];
string $mesh,$geoIntShape,$geoNoIntShape;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $geo=$geometry;
string $tempString[],$tempString2[],$historyNodes[];

if (!$isBuilding && !`objExists WrinkleCurves`)
	error "WrinkleCurves not found, you must run \"Create WrinkleMap\" first.";

if (!$isBuilding)
	if (`confirmDialog -t "Confirm" -m "Re-project UV at current Face-Pose ?" -b "OK" -db "OK" -b "Cancel" -ds "Cancel"`!="OK")
		return;

$foreHeadAreaMeshVis=`getAttr ForeHeadAreaMesh.v`;
if (!$foreHeadAreaMeshVis) setAttr ForeHeadAreaMesh.v 1;
$foreHeadAreaBBMin=`getAttr ForeHeadAreaMesh.boundingBoxMin`;
$foreHeadAreaBBMax=`getAttr ForeHeadAreaMesh.boundingBoxMax`;
if (!$foreHeadAreaMeshVis) setAttr ForeHeadAreaMesh.v 0;

$tempString=`listRelatives -s -ni $geometry`;
$geoNoIntShape=$tempString[0];
$tempString=`listRelatives -s $geometry`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		{
		$tempString2=`listConnections -s 1 -d 0 ($tempString[$i]+".inMesh")`;
		if (!size($tempString2))
			{
			$geoIntShape=$tempString[$i];
			break;
			}
		}
if ($geoIntShape=="") error "Failed to find intermediateShape";

if (!$isBuilding)
	{
	if (`objExists tempUVObject`) delete tempUVObject;
	duplicate -n tempUVObject $geometry;
	$tempString=`listRelatives -s -f tempUVObject`;
	for ($w=0;$w<size($tempString);$w++)
		if (`getAttr ($tempString[$w]+".intermediateObject")`)
			delete $tempString[$w];
	$geo="tempUVObject";
	select tempUVObject;
	polyUVSet -rename -uvSet "uvFaceWrinkles" -newUVSet "uvFaceWrinklesOld";
	}

$tempString=`listRelatives -s -ni $geo`;
$mesh=$tempString[0];
$tempString=`polyUVSet -q -currentUVSet $mesh`;
$currentUVSet=$tempString[0];

$tempString=`polyProjection -ch 1 -type Cylindrical -ibd $isBuilding -cm on -uvSetName uvFaceWrinkles -sf on ($geo+".f[0:99999]")`;
namespace -set ":";//polyProjection seems to set nameSpace in some versions of Maya
rename $tempString[0] polyProjFaceWrinkles;
setAttr polyProjFaceWrinkles.projectionHorizontalSweep 360;
polyUVSet -currentUVSet -uvSet uvFaceWrinkles $mesh;
//wizard fails, so check
$tempString=`polyUVSet -q  -currentUVSet $mesh`;
if ($tempString[0]!="uvFaceWrinkles")
	error ("UV assignment failed.");
select -cl;

//optimize UV by squeezing non-used areas - V
asFaceFitReSelect Jaw_R "";
if (!$isBuilding)
	{
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString $geo`;
	}
$tempString=`ls -sl -fl`;
$pos=`xform -q -ws -t $tempString[0]`;
select $geo;
polySelectConstraint -m 3 -t 1 -d 3 -db $pos[1] 999 -da 0 1 0 -dp 0 0 0;
polySelectConstraint -m 0;
$tempString=`ls -sl`;
asInvertSelection;
ConvertSelectionToUVs;
polyEditUV -pu 0 -pv 0 -su 1 -sv 0.01;

//$bbMax=`getAttr ForeHeadAreaMeshExtrude.boundingBoxMax`;
select $geo;
polySelectConstraint -m 3 -t 1 -d 3 -db $foreHeadAreaBBMax[1] 999 -da 0 1 0 -dp 0 0 0;
polySelectConstraint -m 0;
$tempString2=`ls -sl`;
ConvertSelectionToUVs;
polyEditUV -pu 0 -pv 1 -su 1 -sv 0.01;

select $tempString;
select -d $tempString2;
ConvertSelectionToUVs;

texLatticeDeformContext -edit -latticeRows 2 -latticeColumns 2 -envelope 1 -ubr 1 texLatticeDeformCtx;
setToolTo texLatticeDeformSuperContext;
$vals=`getAttr texLattice1.boundingBoxSup`;
$loBound=$vals[0];
$vals=`getAttr texLattice1.boundingBoxInf`;
$hiBound=$vals[0];
$boundHeight=$hiBound-$loBound;
setToolTo $gSelect;
polyEditUV -u 0 -v (0.5-(($loBound+$hiBound)/2.0));//move down
polyEditUV -pu 0.5 -pv 0.5 -su 1 -sv (1.0/$boundHeight);//scale up

//optimize UV by squeezing non-used areas - U
asFaceFitReSelect ForeHead_R "";
if (!$isBuilding)
	{
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString $geo`;
	}
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[0]<$min)
		{
		$min=$pos[0];
		$nr=$i;
		}
	}
select $tempString[$nr];
ConvertSelectionToUVs;
$uvs=`polyEditUV -q`;

$tempInt=`polyEvaluate -uvcoord $geo`;
$numUvs=$tempInt[0];
for ($i=0;$i<$numUvs;$i++)
	{
	$uvValues=`polyEditUV -q ($geo+".map["+$i+"]")`;
	if ($uvValues[0]<$uvs[0])
		select -add ($geo+".map["+$i+"]");
	}
polyEditUV -pu 0 -pv 0.5 -su 0.01 -sv 1;
select -cl;
for ($i=0;$i<$numUvs;$i++)
	{
	$uvValues=`polyEditUV -q ($geo+".map["+$i+"]")`;
	if ($uvValues[0]>(1-$uvs[0]))
		select -add ($geo+".map["+$i+"]");
	}
polyEditUV -pu 1 -pv 0.5 -su 0.01 -sv 1;
select -cl;
for ($i=0;$i<$numUvs;$i++)
	{
	$uvValues=`polyEditUV -q ($geo+".map["+$i+"]")`;
	if ($uvValues[0]>0.1 && $uvValues[0]<0.9)
		select -add ($geo+".map["+$i+"]");
	}
polyEditUV -pu 0.5 -pv 0.5 -su (0.5/(0.5-$uvs[0])) -sv 1;

polyUVSet -currentUVSet -uvSet $currentUVSet $mesh;
select -cl;

if (!$isBuilding)
	{
	$startTime = `timerX`;
	polyUVSet -currentUVSet -uvSet "uvFaceWrinkles" $geo;
	polyUVSet -currentUVSet -uvSet "uvFaceWrinkles" $geometry;
	evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
	progressBar -e -st "Updating UVs" -bp -ii 1 -min 0 -max $numUvs $gMainProgressBar;
	for ($i=0;$i<$numUvs;$i++)
		{
		progressBar -e -s 1 $gMainProgressBar;
		$uvValues=`polyEditUV -q ($geo+".map["+$i+"]")`;
		if ($uvValues[0]<0.1 || $uvValues[0]>0.9 || $uvValues[1]<0.1 || $uvValues[1]>0.9)
			continue;
		$uvValues2=`polyEditUV -q ($geometry+".map["+$i+"]")`;
		if ($uvValues[0]==$uvValues2[0] && $uvValues[1]==$uvValues2[1])
			continue;
		polyEditUV -r 0 -u $uvValues[0] -v $uvValues[1] ($geometry+".map["+$i+"]");
		}
	delete tempUVObject;
	select -cl;
	print ("// UV projections updated in "+`timerX -startTime $startTime`+" seconds.\n");
	}
}

global proc asWmAddAttrs (string $wrinkle, float $depth, float $width)
{
addAttr -k 1 -ln depth -at double -dv $depth $wrinkle;
addAttr -k 1 -ln width -at double -dv $width $wrinkle;
}


//-- ASFace Procedures Ends Here --//

global proc string asGetLatestLocalScriptLocation ()
{
string $scriptLocation=`asGetScriptLocation`;
string $latestLocalScriptLocation=$scriptLocation;
string $tempString[];
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	tokenize $scriptLocation "/" $tempString;
	$latestLocalScriptLocation="";
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="AdvancedSkeletonFiles")
			break;
		else
			{
			if ($i>0 || `gmatch $scriptLocation "/*"`)
				$latestLocalScriptLocation+="/";
			$latestLocalScriptLocation+=$tempString[$i];
			}
		}
	}
return $latestLocalScriptLocation;
}

global proc string asGetLatestLocalVersionAsString ()
{
string $latestLocalVersion=`asGetScriptVersionAsString`;
string $scriptLocation=`asGetScriptLocation`;
string $tempString[];
string $latestLocalASFile;
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	$latestLocalASFile=`asGetLatestLocalScriptLocation`+"/AdvancedSkeleton.mel";
	$latestLocalVersion=`asGetScriptVersionFromFile $latestLocalASFile`;
	}
return $latestLocalVersion;
}

global proc asDownloadDemoUpdates ()
{
int $fileId,$replacedLine;
string $scriptLocation=`asGetScriptLocation`;
string $curl=$scriptLocation+"/AdvancedSkeletonFiles/bin/curl.e";
string $zip=$scriptLocation+"/AdvancedSkeletonFiles/bin/7za.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
string $tempString[],$oldFilesList[],$exampleFolders[];
string $cmd,$name,$unzipFolder,$downloadedFile,$zipFileUrl,$file,$exampleFile,$nextLine,$demoVersionsText,$onlineVersion;
string $exampleFilesFolder=$scriptLocation+"/AdvancedSkeletonFiles/exampleFiles";
string $downloadsFolder=$exampleFilesFolder+"/downloads";
string $demoVersionsTextFile=$downloadsFolder+"/DemoVersions.txt";
if (!`file -q -ex $downloadsFolder`)
	sysFile -md $downloadsFolder;

for ($i=0;$i<99;$i++)
	{
	if (!`checkBox -q -ex ("asDemoUpdateCheckBox"+$i)`)
		break;
	if (!`checkBox -q -v ("asDemoUpdateCheckBox"+$i)`)
		continue;
	$name=`text -q -l ("asDemoUpdateFileText"+$i)`;
	$onlineVersion=`text -q -l ("asDemoUpdateFileOnlineVersion"+$i)`;
	$downloadedFile=$downloadsFolder+"/"+$name+".7z";
	$unzipFolder=$downloadsFolder+"/"+$name;
	$zipFileUrl="https://www.advancedskeleton.com/download/AdvancedSkeletonExamples/"+$name+".7z";
	if (!`file -q -ex $unzipFolder`)
		sysFile -md $unzipFolder;

	//download
	if (`about -mac` || `about -linux`)
		{
		$cmd="\"curl -o "+$downloadedFile+" "+$zipFileUrl+"\"";
		evalEcho ("system("+$cmd+")");
		}
	else
		{
		$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -o \""+$downloadedFile+"\" "+$zipFileUrl;
		system ($cmd);
		}

	//confirm download
	if (`file -q -ex $downloadedFile`)
		print ("// Downloaded sucessfully:"+$downloadedFile+";\n");
	else
		error ("// Download failed, could not find:"+$downloadedFile+";\n");

	//unzip (with -y for overwrite)
	if (`about -mac` || `about -linux`)
	  $cmd="unzip "+$downloadedFile+" -d "+$unzipFolder;
	else
		$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x -y \""+$downloadedFile+"\" -o\""+$unzipFolder+"\"";
	print ("// Starting Unzip:"+$cmd+";\n");
	system($cmd);
	
	//confirm unzip
	if (`file -q -ex ($unzipFolder+"/"+$name+".mb")`)
		print ("// Unzipped sucessfully:"+$unzipFolder+"/"+$name+".mb;\n");
	else
		error ("// Unzipp failed, could not find:"+$unzipFolder+"/"+$name+".mb;\n");

	//remove old file
	if (`file -q -ex ($exampleFilesFolder+"/"+$name)`)
		{
		$oldFilesList=`getFileList -fld ($exampleFilesFolder+"/"+$name+"/")`;
		for ($file in $oldFilesList)
			sysFile -del ($exampleFilesFolder+"/"+$name+"/"+$file);
		sysFile -red ($exampleFilesFolder+"/"+$name);
		}

//	//Move (by rename) downloadedFolder to exampleFolder
//	sysFile -ren ($exampleFilesFolder+"/"+$name) $unzipFolder;

	//Delete $downloadedFile
	sysFile -del $downloadedFile;

	//Update DemoVersions.txt
	$demoVersionsText="";
	$replacedLine=0;
	$fileId=`fopen $demoVersionsTextFile "r"`;
	$nextLine=`fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$nextLine=`strip $nextLine`;
		tokenize $nextLine $tempString;
		if ($tempString[0]==$name)
			{
			$demoVersionsText=$demoVersionsText+`substitute $tempString[1] $nextLine $onlineVersion`+"\r\n";
			$replacedLine=1;
			}
		else if ($nextLine!="")
			$demoVersionsText=$demoVersionsText+$nextLine+"\r\n";
		$nextLine=`fgetline $fileId`;
		}
	fclose $fileId;
	if (!$replacedLine)
		$demoVersionsText=$demoVersionsText+$name+" "+$onlineVersion+"\r\n";
	$fileId=`fopen $demoVersionsTextFile "w"`;
	fprint $fileId $demoVersionsText;
	fclose $fileId;

	//populate Demo optionMenu
	$tempString=`optionMenu -q -ill asDemoOptionMenu`;
	for ($y=0;$y<size($tempString);$y++)
		deleteUI $tempString[$y];
	setParent -menu asDemoOptionMenu;
	$exampleFolders=`getFileList -fld ($exampleFilesFolder+"/downloads/")`;
	for ($y=0;$y<size($exampleFolders);$y++)
		{
		string $exampleFile=$exampleFilesFolder+"/downloads/"+$exampleFolders[$y]+"/"+$exampleFolders[$y]+".mb";
		if (`file -q -ex $exampleFile`)
			menuItem -l $exampleFolders[$y];
		}

	//disable RowLayout
	rowLayout -e -en 0 ("asDemoUpdateRowLayout"+$i);
	text -e -bgc 0 1 0 ("asDemoUpdateFileOnlineVersion"+$i);
	text -e -l $onlineVersion ("asDemoUpdateFileLocalVersion"+$i);
	checkBox -e -v 0 ("asDemoUpdateCheckBox"+$i);
	}
print "// Download of selected files complete.\n";
}

global proc asCheckForDemoUpdates ()
{
int $x,$y,$needUpdate,$fileId;
string $scriptLocation=`asGetScriptLocation`;
string $onlineVersionsText,$localVersionsText,$localVersionInfo;
string $onlineVersionsFile="https://www.advancedskeleton.com/download/AdvancedSkeletonExamples/DemoVersions.txt";
string $downloadsFolder=$scriptLocation+"/AdvancedSkeletonFiles/exampleFiles/downloads";
string $localVersionsFile=$downloadsFolder+"/DemoVersions.txt";
string $curl=$scriptLocation+"/AdvancedSkeletonFiles/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
string $tempString[],$localFiles[],$localVersions[],$onlineFiles[],$onlineVersions[];
print ("// Checking online for demo updates at www.advancedskeleton.com\n");
waitCursor -st 1;

$onlineVersionsText=`system ("\""+$curl+"\" -k -s "+$onlineVersionsFile)`;

if (!`gmatch $onlineVersionsText "*chubby*"`)
	print ("Failed to access \""+$onlineVersionsFile+"\"");

if (!`file -q -ex $downloadsFolder`)
	sysFile -md $downloadsFolder;

if (!`file -q -ex $localVersionsFile`)
	{
	$fileId=`fopen $localVersionsFile "w"`;
	fclose $fileId;
	}
$localVersionsText="";
$fileId=`fopen $localVersionsFile "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	$localVersionsText=$localVersionsText+$nextLine;
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

$x=0;
tokenize $localVersionsText $tempString;
for ($i=0;$i<size($tempString);$i=$i+2)
	{
	$localFiles[$x]=$tempString[$i];
	$localVersions[$x]=$tempString[$i+1];
	$x++;
	}

$x=0;
tokenize $onlineVersionsText $tempString;
for ($i=0;$i<size($tempString);$i=$i+2)
	{
	$onlineFiles[$x]=$tempString[$i];
	$onlineVersions[$x]=$tempString[$i+1];
	$x++;
	}

if (`window -q -ex asDemoUpdates`)
	deleteUI asDemoUpdates;
window -t Updates asDemoUpdates;
columnLayout;
rowLayout -nc 4 -cw4 80 50 60 40;
	text -l " File:";
	text -l " Online:";
	text -l " Local:";
	text -l " Update:";
	setParent..;
separator -h 5 -st none;
for ($i=0;$i<size($onlineFiles);$i++)
	{
	$needUpdate=0;
	$localVersionInfo="n/a";
	for ($y=0;$y<size($localFiles);$y++)
		if ($localFiles[$y]==$onlineFiles[$i])
			$localVersionInfo=$localVersions[$y];
	if ($localVersionInfo!=$onlineVersions[$i])
		$needUpdate=1;

	rowLayout -en $needUpdate -nc 4 -cw4 80 50 50 50 ("asDemoUpdateRowLayout"+$i);
	text -l $onlineFiles[$i] ("asDemoUpdateFileText"+$i);
	if ($needUpdate)
		text -bgc 1 0 0 -l $onlineVersions[$i] ("asDemoUpdateFileOnlineVersion"+$i);
	else
		text -l $onlineVersions[$i] ("asDemoUpdateFileOnlineVersion"+$i);
	text -l $localVersionInfo ("asDemoUpdateFileLocalVersion"+$i);
	checkBox -v $needUpdate -l "" ("asDemoUpdateCheckBox"+$i);
	setParent..;
	}
separator -h 15 -st none;
button -l "  Download selected files  " -c asDownloadDemoUpdates;
showWindow;
waitCursor -st 0;
}

global proc asCheckForUpdates ()
{
string $curl=`asGetScriptLocation`+"/AdvancedSkeletonFiles/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
text -e -en 0 -l "x.xxx" asUpdateFoundVersion;
checkBox -e -v 0 asBetaCheckBox;
button -e -en 0 asUpdateVersionButton;
waitCursor -st 1;
int $modifier=`getModifiers`;
float $versions[];
string $versionsText;

if ($modifier==13)
	{
	print ("// Checking online for new BETA version at www.advancedskeleton.com\n");
	checkBox -e -v 1 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://www.advancedskeleton.com/download/AdvancedSkeletonBeta/latestBetaVersion.txt")`;
	}
else
	{
	print ("// Checking online for new version at www.advancedskeleton.com\n");
	checkBox -e -v 0 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s https://www.advancedskeleton.com/download/AdvancedSkeleton/latestVersion.txt")`;
	}
if (!`gmatch $versionsText "[0-9]*"`)
	{
	print ("// returned:\""+$versionsText+"\"\n");
	error "Unable to connect to update server \"https://www.advancedskeleton.com\", you might not be connected to internet, or blocked by firewall";
	}
string $latestVersionAsString=$versionsText;
float $latestVersion=$versionsText;

string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
float $latestInstalledVersion=`asGetScriptVersionFromFile ($sLoc+"/AdvancedSkeleton.mel")`;
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton.mel")`;

if ($latestVersion>$latestInstalledVersion)
	{
	text -e -en 1 -l $latestVersionAsString asUpdateFoundVersion;
	button -e -en 1 asUpdateVersionButton;
	print ("// New version found, click Update, to update to the new version\n");
	}
else
	print ("// Latest version("+$latestVersionAsString+"), is not greater than your latest installed version("+$latestInstalledVersionAsString+")\n");
waitCursor -st 0;
}

global proc string asGetLatestInstalledVersionScriptLocation ()
{
string $sLoc=`asGetScriptLocation`;
string $ts[];
int $numTok=`tokenize $sLoc "/" $ts`;
if ($ts[size($ts)-2]=="oldVersions")
	$sLoc=`substitute ("/"+$ts[$numTok-3]+"/"+$ts[$numTok-2]+"/"+$ts[$numTok-1]) $sLoc ""`;
return $sLoc;
}

global proc asUpdateVersion ()
{
//First check if download is from Autodesk store,
//since the C:\ProgramData\Autodesk\ApplicationPlugins folder probably does not have overwrite priveleges
//Testing by attempting to rename eula.txt file
int $fileId;
int $isReadOnly=0;
string $dialog;
string $fDet,$cmd,$changePriviligeFolder;
string $asScriptLocation=`asGetScriptLocation`;
string $eulaFile=$asScriptLocation+"/eula.txt";
string $eula2File=$asScriptLocation+"/eula2.txt";
string $tmpDir=`asGetTempDirectory`;
string $batFile=$tmpDir+"AdvancedSkeleton_changeFolderPriviliges.bat";
if (`file -q -ex $eulaFile` && `about -win`)
	{
	sysFile -rename $eula2File $eulaFile;
	if (!`file -q -ex $eulaFile`)
		sysFile -rename $eulaFile $eula2File;
	else
		{
		$isReadOnly=1;
		sysFile -del $eula2File;
		}
	}
if ($isReadOnly)
	{
	$changePriviligeFolder=$asScriptLocation;
	if (`gmatch $asScriptLocation "C:/ProgramData/Autodesk/ApplicationPlugins/AdvancedSkeleton*"`)
		$changePriviligeFolder="C:/ProgramData/Autodesk/ApplicationPlugins/AdvancedSkeleton";
	$dialog=`confirmDialog -t "Confirm"
	-m ("Detected Read-Only AdvancedSkeleton files,\nClick OK to attemp to modify the priviliges for this folder:\n"+$changePriviligeFolder)
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		error ("Unable to Update, as the files are Read-Only.\nThis is common if you downloaded AdvancedSkeleton from the Autodesk store.\n"
			+"You can try to manually add Write-priviliges to this folder:\n"+$changePriviligeFolder);
	$fDet="icacls "+$changePriviligeFolder+" /grant Everyone:(OI)(CI)F";
	$fileId=`fopen $batFile "w"`;
	fprint $fileId ($fDet);
	fclose $fileId;
	$cmd="powershell -Command \"Start-Process '"+$batFile+"' -Verb runAs\"";
	system ($cmd);
	}

waitCursor -st 1;
string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton.mel")`;
string $curl=$sLoc+"/AdvancedSkeletonFiles/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeletonFiles/bin/7za.e";
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
string $newVersionFolder=$sLoc+"/AdvancedSkeletonFiles/newVersions/AdvancedSkeleton_v"+$newVersionAsString;
if (!`file -q -ex $newVersionFolder`)
	sysFile -md $newVersionFolder;
//download
string $newVersionZipFile=$newVersionFolder+"/AdvancedSkeleton.zip";
string $zipFileUrl="https://www.advancedskeleton.com/download/AdvancedSkeleton/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton.zip";
if (`checkBox -q -v asBetaCheckBox`)
	$zipFileUrl="https://www.advancedskeleton.com/download/AdvancedSkeletonBeta/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton.zip";
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -o "+$newVersionZipFile+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -o \""+$newVersionZipFile+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+";\n");
	system ($cmd);
	}
//confirm download
if (`file -q -ex $newVersionZipFile`)
	print ("// Downloaded sucessfully:"+$newVersionZipFile+";\n");
else
	error ("// Download failed, could not find:"+$newVersionZipFile+";\n");
//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$newVersionZipFile+" -d "+$newVersionFolder;
else
	$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x \""+$newVersionZipFile+"\" -o\""+$newVersionFolder+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton.mel")`)
	print ("// Unzipped sucessfully:"+$newVersionFolder+"/AdvancedSkeleton.mel;\n");
else
	error ("// Unzipp failed, could not find:"+$newVersionFolder+"/AdvancedSkeleton.mel;\n");
//remove zip file
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton.zip")`)
	sysFile -del ($newVersionFolder+"/AdvancedSkeleton.zip");
//backup $latestInstalledVersion version
string $oldVersionsFolder=$sLoc+"/AdvancedSkeletonFiles/oldVersions/AdvancedSkeleton_v"+$latestInstalledVersionAsString;
print ("// Backing up old version: asCopyFilesInFolder \""+$oldVersionsFolder+"\" \""+$sLoc+"\";\n");
sysFile -md ($oldVersionsFolder+"/AdvancedSkeletonFiles");
asCopyFilesInFolder ($oldVersionsFolder+"/AdvancedSkeletonFiles") ($sLoc+"/AdvancedSkeletonFiles");
sysFile -cp ($oldVersionsFolder+"/AdvancedSkeleton.mel") ($sLoc+"/AdvancedSkeleton.mel");
//replace with new version
print ("// Replacing current version with the downloaded version: asCopyFilesInFolder \""+$sLoc+"\" \""+$newVersionFolder+";\n");
asCopyFilesInFolder $sLoc $newVersionFolder;
waitCursor -st 0;
print ("// Updated from "+$latestInstalledVersionAsString+" to "+$newVersionAsString+"\n");
//Re-start
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
optionVar -iv asHaveRanThisVersion 0;
evalDeferred -lp ("source \""+$sLoc+"/AdvancedSkeleton.mel\";AdvancedSkeleton;");
}

global proc asVersionHistory ()
{
global string $gMainProgressBar;

string $versionHistoryFileUrl="https://www.advancedskeleton.com/download/AdvancedSkeleton/versionHistory.txt";
if (`getModifiers`==13)
	$versionHistoryFileUrl="https://www.advancedskeleton.com/download/AdvancedSkeletonBeta/betaVersionHistory.txt";
string $curl=`asGetScriptLocation`+"/AdvancedSkeletonFiles/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
print ("// Downloading version information from:"+$versionHistoryFileUrl+"\n");
progressBar -e -st "Downloading version information" -bp -ii 1 -min 0 -max 1 $gMainProgressBar;
string $versionHistoryText=`system ("\""+$curl+"\" -k -s "+$versionHistoryFileUrl)`;

if (`window -q -ex asVersionHistory`)
	deleteUI asVersionHistory;
window asVersionHistory;
formLayout asVersionHistoryFormLayout;
scrollField -text $versionHistoryText asVersionHistoryScrollField;
formLayout -e 
	-af asVersionHistoryScrollField "left" 0
	-af asVersionHistoryScrollField "right" 0
	-af asVersionHistoryScrollField "top" 0
	-af asVersionHistoryScrollField "bottom" 0
	asVersionHistoryFormLayout;
showWindow;
}

global proc asCopyFilesInFolder (string $destFolder, string $sourceFolder)
{
global string $gMainProgressBar;
if (`gmatch $destFolder"*/exampleFiles/*"`)
	return;//dont include downloaded exampleFiles
if (`gmatch $destFolder"*forced-aligner*"`)
	return;//dont include forced-aligners
if (`gmatch $destFolder"*download*"`)
	return;//dont include download folders (eg. AdvancedSkeletonFiles\bin\download used for forced-aligner)
if (!`file -q -ex $destFolder`)
    sysFile -md $destFolder;
string $fileList[]=`getFileList -fld ($sourceFolder+"/")`;
if (`size($fileList)`==0)
	return;
progressBar -e -st "Copy files" -bp -ii 1 -min 0 -max (size($fileList)) $gMainProgressBar;
for ($i=0;$i<size($fileList);$i++)
    {
		progressBar -e -s 1 $gMainProgressBar;
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
    if ($fileList[$i]=="incrementalSave" || $fileList[$i]=="downloads" || $fileList[$i]=="distributes"
    	|| `gmatch $fileList[$i] "[.]*"` || `gmatch $fileList[$i] "*[.]psd"` || `gmatch $fileList[$i] "*[.]pyc"`
  		|| $fileList[$i]=="newVersions" || $fileList[$i]=="oldVersions" || $fileList[$i]=="asReleaser.mel"
  		|| $fileList[$i]=="montreal-forced-aligner")
        continue;
    if (`filetest -d ($sourceFolder+"/"+$fileList[$i])`)
			asCopyFilesInFolder ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i]);
    else
			if (!`sysFile -cp ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i])` && `about -win`)
				{
				error ("Failed to copy file ("+$destFolder+"/"+$fileList[$i]+")\n"
					+"Possibly privileges issue. This is common if you downloaded AdvancedSkeleton from the Autodesk store\n"
					+"Follow the steps in the URL below, then redo the updates\n"
					+"https://www.advancedskeleton.com/download/AdvancedSkeleton4/changePrivilegesHelp.jpg\n");
				progressBar -e -ep $gMainProgressBar;
				return;
				}
    }
progressBar -e -ep $gMainProgressBar;
}

global proc asDockWindow (int $dock)
{
int $asDock=`optionVar -q asDock`;
optionVar -iv asDock $dock;
removeAsWorkspaceControl;
if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	deleteUI -control AdvancedSkeletonDockControl;
AdvancedSkeleton;
}

global proc asDockWindowChangeFloatingState ()
{
optionVar -iv asDock (!`dockControl -q -ex AdvancedSkeletonDockControl`);
}

global proc asCreateWorkspaceControl ()
{
//First we ensure runTimeCommand
string $asScriptLocation=`asGetScriptLocation`;
if (`runTimeCommand -ex AdvancedSkeletonWorkspaceController`) //update, since $asScriptLocation can change.
	runTimeCommand -e -annotation "Run AdvancedSkeleton as WorkSpace controller" -category "User"
		-command ("if (!`exists AdvancedSkeleton`) evalEcho (\"source \\\""+$asScriptLocation+"/AdvancedSkeleton.mel\\\"\");AdvancedSkeleton;")
		AdvancedSkeletonWorkspaceController;
else
	runTimeCommand -annotation "Run AdvancedSkeleton as WorkSpace controller" -category "User"
		-command ("if (!`exists AdvancedSkeleton`) evalEcho (\"source \\\""+$asScriptLocation+"/AdvancedSkeleton.mel\\\"\");AdvancedSkeleton;")
		AdvancedSkeletonWorkspaceController;

if (`workspaceControl -ex asWorkspaceControl`)
	{
	print ("Already a Workspace Controller, click \"UnDock\" to detach.\n");
	return;//since removing it, then re-building it, appears to cause crashes.
	}

if (`exists dockControl`)
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;

workspaceControl -initialWidth 288 -minimumWidth 288 -retain 0 -dockToControl ToolBox left -label AdvancedSkeleton -uiScript AdvancedSkeletonWorkspaceController asWorkspaceControl;
}

global proc removeAsWorkspaceControl ()
{
if (!`exists workspaceControl`)
	return;//Maya version < 2017
if (`workspaceControl -ex asWorkspaceControl`)
	workspaceControl -e -close asWorkspaceControl;
if (`workspaceControlState -exists asWorkspaceControl`)
	workspaceControlState -remove asWorkspaceControl;
}

global proc string asGetImConvertCmd ()
{
//appears that imconvert is magick from Maya2022
string $imConvertCmd="imconvert";
string $mayaLocation=`getenv "MAYA_LOCATION"`;
if (`file -q -ex ($mayaLocation+"/bin/magick.exe")` || `file -q -ex ($mayaLocation+"/bin/magick")`)
	$imConvertCmd="magick";
return $imConvertCmd;
}

global proc asFitSkeletonImport ()
{
string $dialog;
string $tempString[];
string $upAxisDirection=`upAxis -q -ax`;

if (`objExists FitSkeleton`)
	{
	$tempString=`listRelatives -ad -type joint FitSkeleton`;
	if (size($tempString))
		$dialog=`confirmDialog -t "Confirm"
			-m "FitSkeleton already exists"
			-b "Replace"
			-b "Merge"
			-b "Cancel"
			-db "Replace" -ds "Cancel"`;
	else
		$dialog="Replace";
	if ($dialog!="Replace" && $dialog!="Merge")
		return;
	}
int $merge=0;
if ($dialog=="Merge") $merge=1;

float $existingScale[];
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
string $removeExistingObjs[]={"FitSkeleton","FitSkeletonVisualizers","cylinders","boxes","locators","directions",
	"asRedSG","asRed2SG","asGreenSG","asGreen2SG","asBlueSG","asBlue2SG","asBlackSG","asWhiteSG","asBonesSG",
	"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asBlack","asWhite","asBones"};
if (!$merge)
	for ($i=0;$i<size($removeExistingObjs);$i++)
		if (`objExists $removeExistingObjs[$i]`)
			delete $removeExistingObjs[$i];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeletonFiles/fitSkeletons/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asFitFiles`;
if (`attributeExists fitSkeletonFile FitSkeletonOverride`)
	$FitSkeletonFile=`getAttr FitSkeletonOverride.fitSkeletonFile`;
if (`file -q -ex $FitSkeletonFile`)
	{
	if ($merge)
		{
		if (`namespace -ex "Merge"`)
			namespace -rm "Merge";
		file -import -ra true -ns "Merge" -options "v=0" $FitSkeletonFile;
		asFitSkeletonMerge;
		}
	else
		file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
	}
if ($existingScale[0]!=0)
	setAttr -type float3 FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
if (`objExists Group|Main` && !`objExists Group|Main|FitSkeleton` && `objExists FitSkeleton`)
	parent FitSkeleton Group|Main;
if (`objExists FitSkeleton`)
	{
	if (!`attributeExists fitSkeletonTemplate  FitSkeleton`) addAttr -ln fitSkeletonTemplate -dt "string" FitSkeleton;
	$tempString[0]=`optionMenu -q -v asFitFiles`;
	setAttr -type "string" FitSkeleton.fitSkeletonTemplate `basenameEx $tempString[0]`;
	if ($upAxisDirection=="z")
		asSceneUpAxisFlip FitSkeleton z;
	}
asEnsureFitSkeletonAttributes;
if ($upAxisDirection=="z")
	checkBox -e -v 1 asBodyZUpAxisCheckBox;
//v 5.812 had asSaveBodyInput commented out, however 5.813 we add it back, but with saving of pri/sec axis removed from proc and renamed to asSavePrepInput
asSavePrepInput;
asUpdateButtonEnables;
asImportMatcherScan;
}

global proc asFitSkeletonMerge ()
{
int $lockCenterJoints=`getAttr FitSkeleton.lockCenterJoints`;
string $tempString[],$tempString2[],$tempString3[];
string $counterPart,$counterPartParent;
setAttr FitSkeleton.lockCenterJoints 0;

string $dialog=`confirmDialog -t "Confirm"
		-m "Joints with same names ?"
		-b "Keep existing"
		-b "Keep imported"
		-b "Keep both by renaming imported"
		-db "Keep existing"`;
int $keepExisting=0;
int $keepImported=0;
int $keepBoth=0;
if ($dialog=="Keep existing") $keepExisting=1;
if ($dialog=="Keep imported") $keepImported=1;
if ($dialog=="Keep both by renaming imported") $keepBoth=1;

//$keepExisting
if ($keepExisting || $keepImported)
	{
	if ($keepExisting) $tempString=`listRelatives -ad -type joint Merge:FitSkeleton`;
	if ($keepImported) $tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (!`objExists $tempString[$i]`)
			continue;
		if ($keepExisting) $counterPart=`substitute "Merge:" $tempString[$i] ""`;
		if ($keepImported) $counterPart="Merge:"+$tempString[$i];
		if (`objExists $counterPart`)
			{
			delete $tempString[$i];
			continue;
			}
		$tempString2=`listRelatives -p $tempString[$i]`;
		if ($tempString2[0]=="")
			continue;
		if ($keepExisting) $counterPartParent=`substitute "Merge:" $tempString2[0] ""`;
		if ($keepImported) $counterPartParent="Merge:"+$tempString2[0];
		if (`objExists $counterPartParent`)
			parent $tempString[$i] $counterPartParent;
		}
	}

$tempString=`listRelatives -c -type joint Merge:FitSkeleton`;
if (size($tempString))
	parent $tempString FitSkeleton;

if (`objExists Merge:FitSkeleton`)
	{
	//Unlock
	$tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		setAttr -l 0 ($tempString[$i]+".tx");setAttr -l 0 ($tempString[$i]+".ty");setAttr -l 0 ($tempString[$i]+".tz");
		setAttr -l 0 ($tempString[$i]+".rx");setAttr -l 0 ($tempString[$i]+".ry");setAttr -l 0 ($tempString[$i]+".rz");
		}

	//Keep imported DrivingSystems
	if (!`attributeExists drivingSystem FitSkeleton`)
		addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
	$tempString=`listAttr -ud -m Merge:FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "drivingSystem*"`)
			{
			$tempString2=`listConnections -s 1 -d 0 -p 1 ("Merge:FitSkeleton."+$tempString[$i])`;
			if ($tempString2[0]!="")
				{
				connectAttr -na $tempString2[0] FitSkeleton.drivingSystem;
				disconnectAttr -na $tempString2[0] -na Merge:FitSkeleton.drivingSystem;
				}
			$tempString2=`listConnections -s 0 -d 1 -p 1 ("Merge:FitSkeleton."+$tempString[$i])`;
			if ($tempString2[0]!="")
				{
				tokenize $tempString[$i] "[" $tempString3;
				if (!`attributeExists $tempString3[0] FitSkeleton`)
					addAttr -k 0 -ln $tempString3[0] -at bool -dv true -multi FitSkeleton;
				connectAttr -f ("FitSkeleton."+$tempString[$i]) $tempString2[0];
				}
			}
	delete Merge:FitSkeleton;
	}

//rename Merge:*
while (size(`ls "Merge:*"`))
	{
	$tempString=`ls "Merge:*"`;
	tokenize $tempString[0] ":" $tempString2;
	string $newName=$tempString2[1];
	if (`objExists $tempString2[1]`)
	for ($i=1;$i<99;$i++)
		{
		$newName=$tempString2[1]+$i;
		if (!`objExists $newName`)
			break;
		}
	rename $tempString[0] $newName;
	}

if ($lockCenterJoints)
	setAttr FitSkeleton.lockCenterJoints 1;
namespace -rm "Merge";
}

global proc asFitSkeletonLimbsImport ()
{
string $dialog,$name;
string $tempString[],$tempString2[],$tempString3[];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeletonFiles/fitSkeletonsLimbs/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asLimbFiles`;
float $existingScale[3]={1,1,1};

if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if (`objExists Group|FitSkeleton` && `objExists |FitSkeleton`)
	rename |FitSkeleton AdvancedSkeleton_FitSkeleton;
if (`objExists AdvancedSkeleton_FitSkeleton` && `objExists FitSkeleton`)
	{
	setAttr -type float3 AdvancedSkeleton_FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
	$tempString=`listRelatives -f -c -type transform AdvancedSkeleton_FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		tokenize $tempString[$i] "|" $tempString2;
		string $shortName=$tempString2[size($tempString2)-1];
		$tempString2=`ls -l $shortName`;
			{
			if (size($tempString2)>1)
				$dialog=`confirmDialog -t "Confirm"
				-m ($shortName+" already exist")
				-b "Replace" -db "Replace"
				-b "Merge" -ds "Merge"`;
			if ($dialog=="Replace")
				{
				for ($y=0;$y<size($tempString2);$y++)
					if ($tempString2[$y]!=$tempString[$i])
						{
						$tempString3=`listRelatives -p $tempString2[$y]`;
						delete $tempString2[$y];
						if ($tempString3[0]!="")
							parent $tempString[$i] $tempString3[0];
						else
							parent $tempString[$i] FitSkeleton;
						}
				}
			else if (`objExists Root`)
				parent $tempString[$i] Root;
			else
				parent $tempString[$i] FitSkeleton;
			}
		}
	//delete imported drivingSystem SDK`s, if existing SDK with the same name exists, to avoid double up
	$tempString=`ls -type animCurveUA "AdvancedSkeleton_*"`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$name=`substitute "AdvancedSkeleton_" $tempString[$i] ""`;
		if (`objExists $name`)
			delete $tempString[$i];
		}

	//Transfer SDK`s to FitSkeleton;
	if (`attributeExists drivingSystem AdvancedSkeleton_FitSkeleton`)
		{
		$tempString=`listConnections AdvancedSkeleton_FitSkeleton.drivingSystem`;
		if (!`attributeExists drivingSystem FitSkeleton`)
			addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
		for ($i=0;$i<size($tempString);$i++)
			connectAttr -na ($tempString[$i]+".drivingSystemOut") FitSkeleton.drivingSystem;
		string $uAs[]=`listAttr -ud AdvancedSkeleton_FitSkeleton`;
		for ($i=0;$i<size($uAs);$i++)
			{
			if (!`gmatch $uAs[$i] "drivingSystem_*"`)
				continue;
			if (!`attributeExists $uAs[$i] FitSkeleton`)
				addAttr -k 0 -ln $uAs[$i] -at bool -dv true -multi FitSkeleton;
			$tempString=`listConnections -p 1 ("AdvancedSkeleton_FitSkeleton."+$uAs[$i])`;
			for ($y=0;$y<size($tempString);$y++)
				connectAttr -f ("FitSkeleton."+$uAs[$i]+"["+$y+"]") $tempString[$y];
			}
		}
	delete AdvancedSkeleton_FitSkeleton;
	}
asEnsureFitSkeletonAttributes;
asUpdateButtonEnables;
}

global proc asFitSkeletonExport ()
{
string $selJoints[]=`ls -sl -type joint `;
string $selJointsLongName[]=`ls -l -sl -type joint `;
int $fitSkeletonVisLocked=`getAttr -l FitSkeleton.v`;
string $tempString[],$tempString2[],$drivingSystems[],$previousFitSkeletonChildren[],$previousSelJointParents[];
string $asScriptLocation=`asGetScriptLocation`;
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeletonFiles/fitSkeletons/";

//Limb only, first check, to determine destinationDir
int $limbOnly=0;
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		$limbOnly=1;
	}
if ($limbOnly)
	$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeletonFiles/fitSkeletonsLimbs/";
string $return[] = `fileDialog2 -fileFilter "*.ma" -dialogStyle 2 -dir $fitSkeletonsDir`;
string $file=$return[0];
if ($file=="")
	return;

$tempString=`listRelatives -p FitSkeleton`;
string $currentParent=$tempString[0];
if ($fitSkeletonVisLocked)
	setAttr -l 0 FitSkeleton.v;
setAttr FitSkeleton.v 1;
if (`objExists $currentParent`)
	parent -w FitSkeleton;
$tempString=`listConnections -s 0 -d 1 -type animCurve`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 1 -d 0 -type transform $tempString[$i]`;
	if ($tempString2[0]!="" && $tempString2[0]!="FitSkeleton")
		if (!`stringArrayCount $tempString2[0] $drivingSystems`)
			$drivingSystems[size($drivingSystems)]=$tempString2[0];
	}

//Limb only ?
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		{
		if (!`objExists previousFitSkeletonChildren`)
			{
			createNode -n previousFitSkeletonChildren transform;
			$previousFitSkeletonChildren=`listRelatives -c -type joint FitSkeleton`;
			parent $previousFitSkeletonChildren previousFitSkeletonChildren;
			}
		$tempString=`listRelatives -p $selJoints[$i]`;
		$previousSelJointParents[$i]=$tempString[0];
		parent $selJoints[$i] FitSkeleton;
		}
	}

select FitSkeleton;
if (size($drivingSystems))
	delete $drivingSystems;
file -force -options "v=0;" -typ "mayaAscii" -es $file;
if (size($drivingSystems))
	undo;

if (`objExists $currentParent`)
	parent FitSkeleton $currentParent;
if ($fitSkeletonVisLocked)
	setAttr -l 1 FitSkeleton.v;

//Limb only ? (restore)
for ($i=0;$i<size($selJoints);$i++)
	if ($previousSelJointParents[$i]!="")
		parent $selJoints[$i] $previousSelJointParents[$i];
if (`objExists previousFitSkeletonChildren`)
	{
	parent `listRelatives -c previousFitSkeletonChildren` FitSkeleton;
	delete previousFitSkeletonChildren;
	}

print ("// FitSkeleton exported to: \""+$file+"\"\n");
}

global proc asImportMatcherScan ()
{
int $externalSkelDetected;
string $fitSkeletonTemplate,$dialog,$externalSkelDetectedJoint,$nameMatcherTemplate,$skinCluster,$obj;
string $joints[],$tempString[],$tempString2[];
string $sel[]=`ls -sl`;

if (`attributeExists fitSkeletonTemplate FitSkeleton`)
	$fitSkeletonTemplate=`getAttr FitSkeleton.fitSkeletonTemplate`;

if (`objExists FitSkeletonNameMatcherImporting`)
	return;
if (!`gmatch $fitSkeletonTemplate "biped*"`)
	return;

select `ls -type joint`;
select -d -hi FitSkeleton;
$joints=`ls -sl`;
for ($i=0;$i<size($joints);$i++)
	{
	if (`gmatch $joints[$i] "*DHIbody:*"`)//MetaHuman Has DeformJoint+ControlJoint, avoid choosing DeformJoint
		continue;
	if (`gmatch $joints[$i] "*Hip*"` || `gmatch $joints[$i] "*hip*"` || `gmatch $joints[$i] "*pelvis*"`)
		{
		$externalSkelDetectedJoint=$joints[$i];
		$externalSkelDetected=1;
		break;
		}
	}

select $sel;
if ($externalSkelDetected)
	{
	$dialog=`confirmDialog -t "Align ?"
		-m "External skeleton detected.\n\nAlign joints with this skeleton ?"
		-b "Yes" -db "Yes"
		-b "No" -ds "No"`;
	if ($dialog!="Yes")
		return;

	print "// External skeleton detected, starting \"NameMatcher\" to align skeletons.\n";
	asNameMatcherUI;
	select $externalSkelDetectedJoint;
	asMoCapMatcherNameSpaceDetect;
	if (!`asNameMatcherCheckAndAutoRigFit`)
		return;
	addAttr -k 0 -ln alignedWithExternalSkeleton -at bool -dv 1 FitSkeleton;
	addAttr -k 0 -ln externalSkelDetectedJoint -dt "string" FitSkeleton;
	setAttr -type "string" FitSkeleton.externalSkelDetectedJoint $externalSkelDetectedJoint;
	refresh;

	if (`optionMenu -q -ex asMappingUIFiles`)
		$nameMatcherTemplate=`optionMenu -q -v asMappingUIFiles`;
	if ($nameMatcherTemplate!="MetaHuman" && $nameMatcherTemplate!="Unreal5")
		{
		$dialog=`confirmDialog -t "Straighten ?"
			-m "Straighten Arms and Legs ?"
			-b "Yes" -db "Yes"
			-b "No" -ds "No"`;
		if ($dialog=="Yes")
			{
			asFitStraightPoleVector Leg;
			asFitStraightPoleVector Arm;
			refresh;
			}
		}

	$dialog=`confirmDialog -t "Build ?"
		-m "Proceed to Build AdvancedSkeleton and attach ?"
		-b "Yes" -db "Yes"
		-b "No" -ds "No"`;
	if ($dialog!="Yes")
		{
		if (`window -q -ex asMappingUI`)
  	  deleteUI asMappingUI;
		return;
		}

	asReBuildAdvancedSkeleton;

	asMappingUIFunction CreateBSControl;

	//Constraint
	asMappingUIFunction AutoRigConstraint;
	if (`window -q -ex asMappingUI`)
    deleteUI asMappingUI;

	//autoFace ?
	asNameMatcherAutoFaceFitting;
	}
}

global proc asNameMatcherAutoFaceFitting ()
{
int $tempInt[];
int $knownVtxCounts[]={14164,24049};
float $pos[];
string $side,$dialog,$sourceApp,$sourceAppFullName,$faceObj,$teethObj,$leftRight,$sc;
string $faces[],$edges[],$vtxs[],$allHead[],$extras[],$tempString[],$tempString2[];
string $faceObjs[]={"CC_Base_Body","head_lod0_mesh"};
string $teethObjs[]={"CC_Base_Teeth","teeth_lod0_mesh"};
string $sourceApps[]={"CC4","MH"};
string $sourceAppFullNames[]={"CharacterCreator4","MetaHuman"};

for ($i=0;$i<size($faceObjs);$i++)
	{
	if (!`objExists $faceObjs[$i]`)
		continue;
	$tempInt=`polyEvaluate -v $faceObjs[$i]`;
	if ($tempInt[0]==$knownVtxCounts[$i])
		{
		$sourceApp=$sourceApps[$i];
		$sourceAppFullName=$sourceAppFullNames[$i];
		$faceObj=$faceObjs[$i];
		$teethObj=$teethObjs[$i];
		}
	}

if ($sourceApp=="")
	return;

if (`confirmDialog -t "Face ?" -m ($sourceAppFullName+" Mesh detected.\nApply FaceFitting?") -b "Yes" -db "Yes" -b "No" -ds "No"`!="Yes")
	return;

//First Mask
if ($sourceApp=="CC4")
	$faces={"0","3:6","9:10","13:29","32:34","37:45","50:51","54:55","64","97:98","125","131:132","140:143","155:158","231:232",
	"234","236","245:256","268:934","936:941","944:951","955:956","959","969:1029","1034:1042","1423:1463","1479:1482","1488:1501",
	"1503:1531","1543:1667","1787:1896","1899:1906","1941","1943:2038","2053","2056:2059","2062:2063","2066:2082","2085:2087",
	"2090:2098","2103:2104","2107:2108","2117","2150:2151","2178","2184:2185","2193:2196","2208:2211","2284:2285","2287","2289",
	"2298:2309","2321:2984","2986","2990:2994","2999:3002","3004","3008:3009","3012","3022:3082","3087:3095","3476:3516","3532:3535",
	"3541:3554","3556:3584","3596:3720","3840:3949","3952:3959","3994","3996:4091","4106:4157","13446:14045"};

if ($sourceApp=="MH")
	$faces={"0:164","166:167","169:2537","2554:3241","4594:4945","5126:5208","5211:5212","5215:5224","5249:5252",
	"5257:5266","5272","5275:5279","5362:5373","5472:5659","5667:6124","6126:6127","6140:6291","6328:6335",
	"6344:6451","6512:8491","8494:8495","8511:8739","8741:8742","8928","8931","8961:8962","8965:8971","9103:9104",
	"9175:9214","9231","9234","9291","9294:9295","9298:9299","9302","9304:9305","9307:9308","9310","9312",
	"9315:9316","9319:9320","9322:9323","9325:9438","9441:9624","9626:9627","9630:9656","9659:9668","9670:10314",
	"10478:10509","10558","10563:10564","10566","10569:10570","10573","10575:10576","10579:10580","10583:10584",
	"10587:10588","10591:10592","10598:10741","12001:12165","12168:14538","14555:15242","16595:16946","17127:17209",
	"17211:17212","17214:17225","17227:17228","17250:17253","17258:17266","17269","17273:17274","17277:17280",
	"17363:17374","17473:17660","17668:18127","18141:18292","18329:18336","18345:18452","18513:20495","20510",
	"20513:20740","20743:20744","20929:20930","20963:20972","21103:21105","21176:21215","21232:21233","21292:21293",
	"21296:21297","21300:21301","21305:21306","21309:21312","21315:21316","21319:21320","21323:21324","21326:21439",
	"21441:21442","21444:21629","21632:21669","21671:22315","22479:22510","22559","22565:22568","22571:22572",
	"22577:22578","22581:22582","22585:22586","22589:22590","22593:22594","22599:22742","22750"};

select -cl; for ($i=0;$i<size($faces);$i++) select -add ($faceObj+".f["+$faces[$i]+"]");
asChooseInput asFaceMaskTextField;

select -r $faceObj;
asChooseInput asFaceFaceTextField;

//Then HeadJoint, and detect&remove MHMaceSetup
if ($sourceApp=="CC4")
	select CC_Base_Head;
if ($sourceApp=="MH")
	select DHIhead:head;
asChooseInput asFaceHeadJointTextField;

if ($sourceApp=="MH" && `objExists DHIhead:FACIAL_C_FacialRoot`)
	{
	if (`confirmDialog -t "Face ?" -m "MetaHuman FaceRig detected.\nThis must be deleted before adding Face-Fitting" -b "OK" -b "Cancel"`!="OK")
		return;
	print "// Removing MetaHuman FaceRig,\n";
	asFaceLockWeights 1;
	setAttr DHIhead:head.liw 0;
	$tempString=`listRelatives -ad -type joint DHIhead:FACIAL_C_FacialRoot`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`attributeExists liw $tempString[$i]`)
			setAttr ($tempString[$i]+".liw") 0;
		}
	$tempString=`ls -ni -type mesh`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$sc=`findRelatedSkinCluster $tempString[$i]`;
		if ($sc=="")
			continue;
		$tempString2=`listConnections -type joint $sc`;
		if (!`stringArrayCount "DHIhead:head" $tempString2`)
			skinCluster -e -lw false -wt 0 -ai DHIhead:head $sc;
		catchQuiet (`skinPercent -tv DHIhead:head 1 $sc $tempString[$i]`);
		}
	asFaceLockWeights 0;
	delete DHIhead:FACIAL_C_FacialRoot;
	if (`objExists headRig_grp`)
		delete headRig_grp;
	}

if ($sourceApp=="CC4")
	$allHead={"CC_Base_Body","CC_Base_Teeth","CC_Base_Tongue"};
if ($sourceApp=="MH")
	$allHead={"head_lod0_mesh","teeth_lod0_mesh","saliva_lod0_mesh"};
select -cl;
for ($i=0;$i<size($allHead);$i++)
	if (`objExists $allHead[$i]`)
		select -add $allHead[$i];
asChooseInput asFaceAllHeadTextField;
if ($sourceApp=="CC4") select CC_Base_Eye.f[0:319];
if ($sourceApp=="MH") select eyeRight_lod0_mesh;
asChooseInput asFaceRightEyeTextField;
if ($sourceApp=="CC4") select CC_Base_Eye.f[320:639];
if ($sourceApp=="MH") select eyeLeft_lod0_mesh;
asChooseInput asFaceLeftEyeTextField;
if ($sourceApp=="CC4")
	$faces={"0:1180"};
if ($sourceApp=="MH")
	$faces={"74:239","242:254","259:260","262:524","527:528","532:533","536:537","544:547","550:974","978:979","1342:1343","1347","1455",
	"1956","1971:1983","2005:2009","2031:2068","2106:2113","2206:2371","2374:2386","2391:2392","2394:2656","2659:2660","2664:2665",
	"2668:2669","2676:2679","2682:3106","3110:3111","3474:3475","3479","3587","4088","4103:4115","4137:4141","4163:4200","4238:4245",
	"4274:4287"};
select -cl; for ($i=0;$i<size($faces);$i++) select -add ($teethObj+".f["+$faces[$i]+"]");
asChooseInput asFaceUpperTeethTextField;
if ($sourceApp=="CC4")
	$faces={"1181:2420"};
if ($sourceApp=="MH")
	$faces={"0:73","240:241","525:526","529:531","534:535","541:543","982:1148","1162:1172","1182","1186:1341","1344:1346","1348:1454",
		"1456:1955","1957:1969","1984:2004","2010:2030","2069:2105","2114:2205","2372:2373","2657:2658","2661:2663","2666:2667","2673:2675",
		"3114:3280","3285","3294:3304","3319:3473","3476:3478","3480:3586","3588:4087","4089:4101","4116:4136","4142:4162","4201:4237",
		"4246:4273"};
select -cl; for ($i=0;$i<size($faces);$i++) select -add ($teethObj+".f["+$faces[$i]+"]");
asChooseInput asFaceLowerTeethTextField;

if ($sourceApp=="CC4")
	select CC_Base_Tongue;
if ($sourceApp=="MH")
	{
	$faces={"982:1045","1049:1081","1085:1088","1090:1091","1094","1096:1100","1106:1112","1114:1177","2011:2022","2025:2027","3114:3177",
	"3181:3213","3217:3220","3222:3223","3226","3228:3232","3238:3244","3246:3309","4143:4154","4157:4159"};
	select -cl; for ($i=0;$i<size($faces);$i++) select -add ($teethObj+".f["+$faces[$i]+"]");
	}
asChooseInput asFaceTongueTextField;

if (`objExists Eyebrows`)
	{
	select Eyebrows;
	asChooseInput asFaceEyebrowTextField;
	}
if ($sourceApp=="CC4")
	{
	$faces={"13446:14045"};
	select -cl; for ($i=0;$i<size($faces);$i++) select -add ($faceObj+".f["+$faces[$i]+"]");
	}
if ($sourceApp=="MH")
	select eyelashes_lod0_mesh;
asChooseInput asFaceEyelashTextField;

$extras={"Sideburns_Stubble","Circle_Sparse","Mustache_Sparse","Soul_Patch_Sparse","Classic_short",
	"CC_Base_TearLine","Kevin_Brow","Camila_Brow","Eyebrows"};
select -cl;
for ($i=0;$i<size($extras);$i++)
	if (`objExists $extras[$i]`)
		select -add $extras[$i];
asChooseInput asFaceExtrasTextField;

checkBox -e -v 1  asFaceNonSymCheckBox;
asFaceUpdateInfo 0;
asFaceUpdateInfo 1;

//Fit
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftRight="Right";asFaceSwitchSide 1;}
	else {$side="_L";$leftRight="Left";asFaceSwitchSide 0;}

	createNode -n asBatch transform;
	asCreateFaceFit EyeBall "" 0 0 1 "";
	delete asBatch;

	if ($sourceApp=="CC4" && $side=="_R") $edges={"669","672","1171","1173","1178","1183","1188","1404","1412","1416","1419","1545","1555","1605","1627","1647","1661","1673","1687",
		"1719","1731","1812","1858","1872","1894","1905"};
	if ($sourceApp=="MH" && $side=="_R") $edges={"5341","5349","5357","5359","5363","5371","5379","5381","5424","5426","5434","5436","5454","5456","5458","5461","5474","5476","5617",
		"5625","5628","5635","5639","5647","5650","5657","5680","5684","5739","5747","5755","5757","5763","5765:5766","5769","6029","6031","6600","6602","9988","9991","10030","10033",
		"10242","10245","11816","11819","12306","12310","12340","12343:12344","12350","12352","12358","12360","12407","12411","12431","12435","12494","12496","12502","12504","12512",
		"12514","12520","12522","12527","12529","12533","12535"};
	if ($sourceApp=="CC4" && $side=="_L") $edges={"4881","4884","5374","5378","5379","5388","5389","5607","5615","5618","5621","5747","5755","5808","5829","5849","5863","5874","5888",
		"5919","5931","6011","6056","6072","6094","6104"};
	if ($sourceApp=="MH" && $side=="_L") $edges={"29433","29437","29448","29450","29455","29459","29470","29472","29514","29516","29526","29528","29546","29548","29553","29560",
		"29566","29568","29705","29709","29717","29720","29727","29731","29739","29742","29774","29782","29827","29831","29842","29844","29852","29854","29859","29864","30123","30125",
		"30691","30693","34077","34080","34123","34130","34331","34334","35903","35906","36388","36396","36419","36422","36426","36432","36434","36438","36440","36483","36487","36507",
		"36511","36573","36575","36581","36583","36589","36591","36599","36601","36605","36607","36611","36613"};
	select -cl; for ($i=0;$i<size($edges);$i++) select -add ($faceObj+".e["+$edges[$i]+"]");
	asCreateFaceFit EyeLid "Outer" 1 1 0 "";

	if ($sourceApp=="CC4" && $side=="_R") $edges={"1359","1363","1365","1367","1369","1370","1374","1378","1379","1382","1384","1386","1612","1635","1694","1700","1703","1705","1723",
		"1735","1784","1789","1863","1868","1899","1902"};
	if ($sourceApp=="MH" && $side=="_R") $edges={"5786","5790","5816","5818","5865","5871","5875","5883","5957","5959:5960","5964","5980","5982","6053","6055","6063","6069","6115",
		"6123","6126","6131","6246","6248","6382","6384","6435","6437","6451","6453","6504","6506","6516","6518","6632","6639","6646","6649","6733","6735:6736","6740","6756","6758",
		"6826","6829","10006","10011","10267","10273","10288","10291","10322","10325","10366","10371","11728","11731","11776","11779"};
	if ($sourceApp=="CC4" && $side=="_L") $edges={"5562","5565","5567","5569","5571","5572","5576","5579","5582","5583","5585","5589","5812","5835","5896","5900","5904","5906","5924",
		"5936","5984","5985","6061","6067","6098","6101"};
	if ($sourceApp=="MH" && $side=="_L") $edges={"29880","29888","29904","29906","29953","29957","29963","29967","30044","30046","30054","30062","30068","30070","30147","30149",
		"30151","30155","30203","30207","30215","30218","30335","30337","30476","30478","30522","30524","30538","30540","30593","30595","30604","30606","30721","30724","30739","30746",
		"30821","30823","30830","30838","30844","30846","30919","30924","34095","34098","34355","34359","34381","34384","34415","34418","34455","34458","35819","35822","35863","35866"};		
	select -cl; for ($i=0;$i<size($edges);$i++) select -add ($faceObj+".e["+$edges[$i]+"]");
	asCreateFaceFit EyeLid "Main" 1 1 0 "";

	if ($sourceApp=="CC4" && $side=="_R") $edges={"1156","1159","1165","1167","1181","1191","1195","1198","1200","1203","1206","1210","1616","1637","1697","1707","1709","1710","1726",
		"1738","1814","1829","1921","1923","1924","1926"};
	if ($sourceApp=="MH" && $side=="_R") $edges={"5831","5837","5841","5849","6190","6194","6202","6206","6224","6227","6251","6257","6261","6268","6272","6275","6335","6341","6346",
		"6349","6364","6367","6374","6377","6470","6473","6478","6482","6679","6685","6690","6693","6699","6706","6771","6776","6779","6786","6903","6908","6920","6926","6943","6945",
		"10024","10028","10056","10060","10340","10345","10360","10362","10378","10382","11723:11724","11760","11766","11832","11834"};
	if ($sourceApp=="CC4" && $side=="_L") $edges={"5359","5361","5364","5369","5382","5392","5395","5399","5402","5405","5409","5411","5817","5837","5897","5907","5909","5911","5926",
		"5938","6013","6027",
		"6121","6122","6124","6125"};
	if ($sourceApp=="MH" && $side=="_L") $edges={"29923","29927","29933","29937","30280","30288","30292","30300","30314","30321","30343","30347","30352","30355","30361","30366","30427",
		"30431","30436","30443","30453","30460","30463","30468","30559","30564","30568","30576","30771","30775","30780","30787","30791","30794","30863","30866","30871","30874","30995",
		"30998","31013","31015","31034","31040","34117","34119","34149","34151","34432","34433","34449","34453","34471","34473","35811","35816","35851","35853","35919","35923"};
	select -cl; for ($i=0;$i<size($edges);$i++) select -add ($faceObj+".e["+$edges[$i]+"]");
	asCreateFaceFit EyeLid "Inner" 1 1 0 "";

	if ($side=="_R")
		{
		if ($sourceApp=="CC4") $edges={"875","879","986","1060","1067","1071","1079","1082","1087","1102","1109","1113","1115","1116","1122","1151","1154","1223","1226","1932","5083",
			"5089","5191","5264","5270","5276","5280","5284","5290","5306","5312","5315","5316","5320","5324","5354","5356","5426","5428","6129"};
		if ($sourceApp=="MH") $edges={"3","11","14","21","25","31","32","36","46","53","59","61","71","73","86","88","90","93","102","109","116","118","120","123","133","135","142",
			"147","151","157","161","169","173","181","184","189","196","198","200","203","211","213","221","223","231","233","241","243","249","251","257","259","267","269","279","281",
			"24167","24171","24179","24182","24189","24193","24202","24210","24211","24214","24229","24231","24241","24243","24250","24252","24259","24266","24267","24270","24282","24284",
			"24289","24294","24303","24305","24307","24310","24315","24318","24323","24327","24335","24339","24347","24350","24360","24362","24367","24372","24378","24380","24387","24389",
			"24394","24396","24402","24404","24415","24417","24424","24426","24434","24436","24440","24442"};

		select -cl; for ($i=0;$i<size($edges);$i++) select -add ($faceObj+".e["+$edges[$i]+"]");
		if ($sourceApp=="CC4") $vtxs={"9316","12039","9961"};
		if ($sourceApp=="MH") $vtxs={"37","2878","2910"};
		for ($i=0;$i<size($vtxs);$i++) select -add ($faceObj+".vtx["+$vtxs[$i]+"]");
		asCreateFaceFit Lip "Outer" 1 1 0 "";

		if ($sourceApp=="CC4") $edges={"662","666","690","695","700","756","761","793","797","818","832","834","892","1283","1288","1310","1326","1333","1357","3208","4872","4875","4902",
			"4904","4911","4968","4970","5006","5009","5025","5040","5042","5101","5487","5488","5513","5529","5536","5558","7397"};
		if ($sourceApp=="MH") $edges={"748","751","759","762","805","808","878","880","973","977","1020","1026","1029","1033","1035","1041","1044","1049","1051","1057","1059","1065","1067",
			"1073","1129","1132","1169","1172","1209","1212","1249","1252","1314","1320","1357","1360","1397","1400","1437","1440","1988","1994:1995","2000","2039","2044","2126","2128",
			"2189","2194","2688","2693","2695","2699","2702","2704","2707","2711","2713","2717","2719","2723","2725","2729","2731","2735","2737","2741","2743","2747","2749","2753","2755",
			"2759","2762","2764","2767","2771","2773","2777","2780:2781","2977","2981","24901","24908","24910","24915","24956","24961","25031","25037","25127","25129","25174","25178","25184",
			"25186","25189","25191","25198","25201","25205","25207","25213","25215","25221","25223","25280","25285","25320","25325","25360","25365","25400","25405","25468","25472","25508",
			"25513","25548","25553","25580","25584","26123","26125","26132","26135","26176","26179","26260","26264","26326","26329","26813","26815","26819","26821","26824","26828","26831",
			"26833","26837","26839","26843","26845","26849","26851","26855","26857","26861","26863","26867","26869","26873","26875","26879","26881","26884","26888","26891","26893","26897",
			"26899","26902","26905","27100","27102"};
		select -cl; for ($i=0;$i<size($edges);$i++) select -add ($faceObj+".e["+$edges[$i]+"]");
		if ($sourceApp=="CC4") $vtxs={"9809","11838","13005"};
		if ($sourceApp=="MH") $vtxs={"12415","12742","12240"};
		for ($i=0;$i<size($vtxs);$i++) select -add ($faceObj+".vtx["+$vtxs[$i]+"]");
		asCreateFaceFit Lip "Main" 1 1 0 "";

		if ($sourceApp=="CC4") $edges={"3787","3791","3793","3795","3799","3801","3803","3806","3807","3810","3813","3814","3815","3818","3820","3823","3827","3829","3841","3842","7941",
			"7943","7945","7947","7948","7951","7954","7956","7960","7962","7963","7965","7968","7969","7970","7972","7978","7979","7990","7992"};
		if ($sourceApp=="MH") $edges={"767","771","779","782","812","819","885","892","965","971","1445","1449","1457","1460","1467","1470","1477","1480","1487","1490","1497","1500",
			"1507","1510","1517","1520","1527","1530","1537","1540","1546","1554","1559","1562","1569","1572","1579","1582","1675","1681","2004","2012","2015","2021","2049","2052","2118",
			"2120","2784","2791","2794","2800","2802","2808","2810","2816","2818","2824","2826","2832","2834","2840","2842","2848","2850","2856","2858","2864","2866","2872","2874","2880:2881",
			"2886","2890","2896","2898","2904","2953","2956","2989","2993","3130","3132","24919","24927","24931","24938","24966","24969","25040","25043","25119","25121","25587","25595","25599",
			"25606","25608","25615","25619","25626","25629","25636","25639","25646","25649","25656","25659","25666","25669","25676","25679","25686","25690","25694","25701","25708","25711","25718",
			"25720","25726","25816","25818","26140","26144","26152","26154","26183","26190","26252","26258","26907","26910","26917","26919","26925","26927","26933","26935","26941","26943","26949",
			"26951","26957","26959","26965","26967","26973","26975","26981","26983","26989","26991","26997","26999","27006","27009","27013","27015","27021:27022","27072","27077","27112","27114",
			"27239","27243"};
		select -cl; for ($i=0;$i<size($edges);$i++) select -add ($faceObj+".e["+$edges[$i]+"]");
		if ($sourceApp=="CC4") $vtxs={"11168","11343","13274"};
		if ($sourceApp=="MH") $vtxs={"12459","12787","12246"};
		for ($i=0;$i<size($vtxs);$i++) select -add ($faceObj+".vtx["+$vtxs[$i]+"]");
		asCreateFaceFit Lip "Inner" 1 1 0 "";
		}

	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[9881];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[11936];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[2068];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[5139];
	asCreateFaceFit EyeBrowInner  "" 0 0 1 "asGreenSG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[10289];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12363];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[2069];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[10073];
	asCreateFaceFit EyeBrowOuter  "" 0 0 1 "asRedSG";
	if ($side=="_R")
		{
		if ($sourceApp=="CC4") select CC_Base_Body.vtx[12415];
		if ($sourceApp=="MH")  select head_lod0_mesh.vtx[2945];
		asCreateFaceFit EyeBrowCenter "" 0 0 1 "asBlueSG";
		}

	if ($sourceApp=="CC4")
		{
		if ($side=="_R") select CC_Base_Body.vtx[10049]; if ($side=="_L") select CC_Base_Body.vtx[12108]; asCreateFaceFit EyeBrowMid1   "" 0 0 1 "asRedSG";
		if ($side=="_R") select CC_Base_Body.vtx[10054]; if ($side=="_L") select CC_Base_Body.vtx[12114]; asCreateFaceFit EyeBrowMid2   "" 0 0 1 "asRedSG";
		}

	if ($sourceApp=="CC4" && $side=="_R") $vtxs={"9315","9309","9526"};
	if ($sourceApp=="CC4" && $side=="_L") $vtxs={"9315","9309","11561"};
	if ($sourceApp=="MH"  && $side=="_R") $vtxs={"2940","14923","16557"};
	if ($sourceApp=="MH"  && $side=="_L") $vtxs={"2940","8943","16557"};
	select -cl; for ($i=0;$i<size($vtxs);$i++) select -add ($faceObj+".vtx["+$vtxs[$i]+"]");
	asCreateFaceFit ForeHead "" 0 0 0 "";

	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[10492];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12576];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[14886];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[8908];
	asCreateFaceFit JawPivot "" 0 0 1 "asBlue2SG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[10423];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12507];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[16491];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[10486];
	asCreateFaceFit JawCorner "" 0 0 1 "asBlue2SG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[10446];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12530];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[2293];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[5364];
	asCreateFaceFit JawLine "" 0 0 1 "asBlue2SG";

	if ($side=="_R")
		{
		createNode -n asBatch transform;
		if ($sourceApp=="CC4") select CC_Base_Body.vtx[9313];
		if ($sourceApp=="MH")  select head_lod0_mesh.vtx[2975];
		asCreateFaceFit Jaw "" 0 0 1 "asBlue2SG";
		delete asBatch;
		if ($sourceApp=="CC4") select CC_Base_Body.vtx[13380];
		if ($sourceApp=="MH")  select head_lod0_mesh.vtx[17095];
		asCreateFaceFit Nose "" 0 0 1 "asBlueSG";
		if ($sourceApp=="CC4") select CC_Base_Body.vtx[12490];
		if ($sourceApp=="MH")  select head_lod0_mesh.vtx[2968];
		asCreateFaceFit ChinCrease "" 0 0 1 "asBlueSG";
		if ($sourceApp=="CC4") select CC_Base_Body.vtx[11622];
		if ($sourceApp=="MH")  select head_lod0_mesh.vtx[2982];
		asCreateFaceFit Throat "" 0 0 1 "asBlue2SG";
		if ($sourceApp=="CC4") select CC_Base_Body.vtx[11333];
		if ($sourceApp=="MH")  select head_lod0_mesh.vtx[17113];
		asCreateFaceFit NoseUnder "" 0 0 1 "asBlueSG";
		if ($sourceApp=="CC4") select CC_Base_Body.vtx[14116];
		if ($sourceApp=="MH")  select head_lod0_mesh.vtx[13475];
		asCreateFaceFit NoseBridge "" 0 0 1 "asBlueSG";
		}

	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[14126];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[14150];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[20151];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[23164];
	asCreateFaceFit Cheek "" 0 0 1 "asBlue2SG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[10453];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12538];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[2234];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[5305];
	asCreateFaceFit CheekBone "" 0 0 1 "asBlue2SG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[9733];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[11773];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[13213];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[7238];
	asCreateFaceFit SmileBulge "" 0 0 1 "asBlueSG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[10405];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12487];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[13362];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[3717];
	asCreateFaceFit FrownBulge "" 0 0 1 "asBlueSG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[9971];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12475];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[18556];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[21569];
	asCreateFaceFit NoseCorner "" 0 0 1 "asRedSG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[10079];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12138];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.vtx[19591];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[22604];
	asCreateFaceFit NoseSide "" 0 0 1 "asBlueSG";
	if ($sourceApp=="CC4" && $side=="_R") select CC_Base_Body.vtx[9821];
	if ($sourceApp=="CC4" && $side=="_L") select CC_Base_Body.vtx[12283];
	if ($sourceApp=="MH"  && $side=="_R") select head_lod0_mesh.e[12287];
	if ($sourceApp=="MH"  && $side=="_L") select head_lod0_mesh.vtx[4745];
	asCreateFaceFit Nostril "" 0 0 1 "asBlueSG";

	if ($sourceApp=="CC4" && $side=="_R") $edges={"338","359","370","372","391","410","421","422"};
	if ($sourceApp=="CC4" && $side=="_L") $edges={"978","999","1010","1012","1031","1050","1061","1062"};
	if ($sourceApp=="MH") $edges={"66","70","73","76","79","82","85","88","91","94","97","100","103",
		"106","109","112","115","118","121","124","127","130","133","136","139","142","145","148","151","154","157","159"};
	select -cl;
	for ($i=0;$i<size($edges);$i++)
		{
		if ($sourceApp=="CC4") select -add ("CC_Base_Eye.e["+$edges[$i]+"]");
		else select -add ("eye"+$leftRight+"_lod0_mesh.e["+$edges[$i]+"]");
		}
	asCreateFaceFit Pupil "" 0 0 0 "asRedSG";

	if ($sourceApp=="CC4" && $side=="_R") $edges={"320","324","332","344","347","355","362","366","378","381","388","394","397","404","414","415"};
	if ($sourceApp=="CC4" && $side=="_L") $edges={"960","964","972","984","987","995","1002","1006","1018","1021","1028","1034","1037","1044","1054","1055"};
	if ($sourceApp=="MH") $edges={"737","740","742","744","746","748","750","752","754","756","758","760","762","764","766","768","770","772","774","776",
		"778","780","782","784","786","788","790","792","794","796","798:799"};
	select -cl;
	for ($i=0;$i<size($edges);$i++)
		{
		if ($sourceApp=="CC4") select -add ("CC_Base_Eye.e["+$edges[$i]+"]");
		else select -add ("eye"+$leftRight+"_lod0_mesh.e["+$edges[$i]+"]");
		}
	asCreateFaceFit Iris "" 0 0 0 "asGreenSG";
	}

asFaceSwitchSide 1;
asFaceShowBothSides;

asCreateFaceFit Tongue "" 0 0 0 "asBlueSG";
if ($sourceApp=="CC4") $pos=`xform -q -ws -t CC_Base_Tongue.vtx[46]`;
if ($sourceApp=="MH")  $pos=`xform -q -ws -t teeth_lod0_mesh.vtx[1284]`;
xform -ws -t 0 $pos[1] $pos[2] Tongue0;
if ($sourceApp=="CC4") $pos=`xform -q -ws -t CC_Base_Tongue.vtx[40]`;
if ($sourceApp=="MH")  {$pos=`xform -q -ws -t teeth_lod0_mesh.vtx[1281]`;$pos[1]-=0.9;}
xform -ws -t 0 $pos[1] $pos[2] Tongue1;
if ($sourceApp=="CC4") $pos=`xform -q -ws -t CC_Base_Tongue.vtx[32]`;
if ($sourceApp=="MH")  {$pos=`xform -q -ws -t teeth_lod0_mesh.vtx[1278]`;$pos[1]-=0.9;}
xform -ws -t 0 $pos[1] $pos[2] Tongue2;
if ($sourceApp=="CC4") $pos=`xform -q -ws -t CC_Base_Tongue.vtx[18]`;
if ($sourceApp=="MH")  {$pos=`xform -q -ws -t teeth_lod0_mesh.vtx[1275]`;$pos[1]-=0.5;}
xform -ws -t 0 $pos[1] $pos[2] Tongue3;
if ($sourceApp=="CC4") $pos=`xform -q -ws -t CC_Base_Tongue.vtx[164]`;
if ($sourceApp=="MH")  $pos=`xform -q -ws -t teeth_lod0_mesh.vtx[1076]`;
xform -ws -t 0 $pos[1] $pos[2] Tongue4;

refresh;
if (`confirmDialog -t "Build ?"
	-m "Proceed to Build Face ?"
	-b "Yes" -db "Yes"
	-b "No" -ds "No"`=="Yes")
		asBuildAdvancedFace;
}

global proc asSceneUpAxisFlip (string $transform, string $toAxis)
{
int $locked[];
string $xyz[]={"x","y","z",""};

for ($z=0;$z<size($xyz);$z++)
	{
	$locked[$z]=`getAttr -l ($transform+".r"+$xyz[$z])`;
	if ($locked[$z])
		setAttr -l 0 ($transform+".r"+$xyz[$z]);
	}
if ($toAxis=="z")
	setAttr ($transform+".r") -type float3 90 0 0;
if ($toAxis=="y")
	setAttr ($transform+".r") -type float3 0 0 0;
for ($z=0;$z<size($xyz);$z++)
	if ($locked[$z])
		setAttr -l 1 ($transform+".r"+$xyz[$z]);

setUpAxis $toAxis;
}

global proc asFitAutoScale ()
{
string $sel[]=`ls -sl`;

createNode -n asFitAutoScale transform;
select $sel;
asFitAutoPlace;
print "// FitSkeleton scaled to geometry.\n";
}

global proc asFitAutoPlace ()
{
int $modifier=`getModifiers`;
int $numHits,$numAgentHits,$numPreviousHits,$hasStraightenArm,$closestVtxIndex,$maxNumFaces,$numCV;
int $hasHitCrotch,$hitCrotchNr,$hasHitArmPit,$hasHitNeck,$hasHitHead,$hasHitAnkle,$hasHitShoulder,$hasHitThumbTip,$hasHitArmTip,$hasNCloth;
int $hasHitThumbBranch,$cc,$dd;
int $numAgentProjectedCurves,$wristDetectByShrink,$wristDetectByGuess,$numFitJoints,$minXupdatedThisRound;
int $firstFourFingerHit,$fourFingerHit,$nearestCurveNr,$checkingCurveNr,$numShrink,$hitNumShrinkMany;
int $fitAutoScale=`objExists asFitAutoScale`;
int $circleNormalAxis[],$tempInts[];
float $bbMinX,$bbMinY,$bbMinZ;
float $bbMaxX,$bbMaxY,$bbMaxZ,$maxX,$maxY,$maxZ,$minX,$minX2;
float $scale,$newScale,$scanTy,$xStep,$yStep,$zStep,$xDir,$yDir,$zDir,$width,$maxWidth,$previousWidth,$zWidth,$zWidthMax,$tyAtMaxZ,$a,$b,$ankleCurveRy;
float $crotchWidth,$armPitWidth,$scanCurveTx,$agenCurveTx,$curveStepDist,$nearestCurveStepDist,$fingerDetectPopDist,$fingerLenght,$thumbTipTx,$maxFingerWidth;
float $bbZ,$bbCenterX,$rz,$rad,$startTime,$startTime,$ry,$angleFactor,$firstNonFingerSplitTx,$diam,$averageDiam;
float $bbZMax=-999;
float $camOrbitStep=0.2;
float $pos[],$posA[],$posB[],$bb[],$bb2[],$bbMin[],$bbMax[],$tempBBox[],$tempFloatA[],$tempFloatB[],$dir[],$posXs[],$posYs[],$posZs[],$tra[],$rot[],$rot1[],$rot2[];
float $prevBB[];
string $skin=`textField -q -tx asBodySkinTextField`;
string $all=`textField -q -tx asBodyAllTextField`;
string $rightEye=`textField -q -tx asBodyRightEyeTextField`;
string $leftEye=`textField -q -tx asBodyLeftEyeTextField`;
string $checkingCurve,$nearestCurve,$projectOn,$side,$upperLower,$fitSkeletonTemplate,$find,$combinedSkin,$projectedCurve,$projectedCurveShape;
string $thumbCurve,$curveCmd,$maxNumFacesShell,$closestToBaseVtx;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[],$tempString6[];
string $projectedCurves[],$agentProjectedCurves[],$eyeGeos[],$armVtxs[],$previousSel[],$fingerVtxs[],$endEdges[];
string $sel[]=`ls -sl`;
string $zxy[]={"z","x","yArmStraight","yElbowStraight","y","zLoft","yLoft"};
//string $zxy[]={"yLoft"};
string $skinObjects[]=`stringToStringArray $skin " "`;
string $allObjects[]=`stringToStringArray $all " "`;
string $skinAndAllObjects[]=`stringArrayCatenate $skinObjects $allObjects`;
$skinAndAllObjects=`stringArrayRemoveDuplicates $skinAndAllObjects`;
string $fingers[]={"Index","Middle","Ring","Pinky"};

if (`objExists AutoPlacing`)
	{
	asFitDeleteGuides;
	return;
	}

if ($fitAutoScale)
	delete asFitAutoScale;

if (!`objExists FitSkeleton`)
	error "FitSkeleton does not exists, you must first import a FitSkeleton.";
if (`attributeExists fitSkeletonTemplate FitSkeleton`)
	$fitSkeletonTemplate=`getAttr FitSkeleton.fitSkeletonTemplate`;

if ($skin=="")
	error "To use AutoPlace, you must first choose Skin geometry in the \"Body>Pre\" section.";

for ($i=0;$i<size($skinObjects);$i++)
	{
	if (!`objExists $skinObjects[$i]`)
		error ("Choosen Skin object\""+$skinObjects[$i]+"\" does not exist.");
	createNode -n asSkipModelSymmetryCheck transform;
	select $skinObjects[$i];
	asModelChecker;
	}

$numFitJoints=size(`listRelatives -ad -type joint FitSkeleton`);
if ($numFitJoints==0)
	{
	select $sel;
	print ("// No FitJoints found, Import a FitSkeleton first.\n");
	return;
	}

if (`objExists AutoPlacing`)
	delete AutoPlacing;
$startTime = `timerX`;
createNode -n AutoPlacing transform;
currentTime 1;

catchQuiet (`setAttr Root.v 0`);

createNode -n asFitOrbitA -p AutoPlacing transform;
createNode -n asFitOrbitB -p persp transform;
parent asFitOrbitB asFitOrbitA;
createNode -n asFitScanCurves -p AutoPlacing transform;
createNode -n asFitHandles -p AutoPlacing transform;
createNode -n asFitProjections -p AutoPlacing transform;
//createNode -n asFitProjectionsTemp -p asFitProjections transform;
createNode -n asFitPivots -p AutoPlacing transform;
createNode -n asFitPivotsFingers -p asFitPivots transform;
createNode -n asFitAnchors -p AutoPlacing transform;
createNode -n asFitConstraints -p AutoPlacing transform;
createNode -n asFitCombinedSkins -p AutoPlacing transform;
createNode -n asFitCombinedLofts -p AutoPlacing transform;
createNode -n asFitAutoPlaceJoints -p AutoPlacing transform;
createNode -n asFitNCloth -p AutoPlacing transform;

$tra=`xform -q -ws -t persp`;
$rot=`xform -q -ws -ro persp`;
xform -ws -t  $tra[0] $tra[1] $tra[2] asFitOrbitB;
evalDeferred ("xform -ws -t "+$tra[0]+" "+$tra[1]+" "+$tra[2]+" -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" persp");

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;

for ($i=0;$i<size($skinAndAllObjects);$i++)
	catchQuiet (`setAttr ($skinAndAllObjects[$i]+".v") 0`);

//duplicate SkinObjects, and remove `other` polyShells e.g. fingerNail shells
for ($i=0;$i<size($skinObjects);$i++)
	{
	duplicate -n ("CombinedSkin"+$i) $skinObjects[$i];
	parent ("CombinedSkin"+$i) AutoPlacing;
	}

//Merge all SkinObjects
select CombinedSkin0;
if (size($skinObjects)>1)
	{
	for ($i=1;$i<size($skinObjects);$i++)
		select -add ("CombinedSkin"+$i);
	polyUnite -ch 0 -mergeUVSets 0 -name TempCombinedSkin;
	parent TempCombinedSkin AutoPlacing;
	//If the object already had construction history. the source xforms are left
	if (`objExists CombinedSkin`) delete CombinedSkin;
	for ($i=1;$i<size($skinObjects);$i++)
		if (`objExists ("CombinedSkin"+$i)`) delete ("CombinedSkin"+$i);
	rename TempCombinedSkin CombinedSkin;
	}
else
	rename CombinedSkin0 CombinedSkin;

$tempString=`listRelatives -p CombinedSkin`;
parent CombinedSkin asFitCombinedSkins;
setAttr CombinedSkin.v 1;
setAttr CombinedSkin.overrideEnabled 1;
setAttr CombinedSkin.overrideDisplayType 2;

$bbMin=`getAttr CombinedSkin.boundingBoxMin`;
$bbMax=`getAttr CombinedSkin.boundingBoxMax`;
$bbMinX=$bbMin[0];
$bbMinY=$bbMin[1];
$bbMinZ=$bbMin[2];
$bbMaxX=$bbMax[0];
$bbMaxY=$bbMax[1];
$bbMaxZ=$bbMax[2];

addAttr -k 0 -ln bbMinZ -at double -dv $bbMinZ AutoPlacing;
addAttr -k 0 -ln bbMaxZ -at double -dv $bbMaxZ AutoPlacing;
addAttr -k 0 -ln bbMaxY -at double -dv $bbMaxY AutoPlacing;
addAttr -k 0 -ln bbMinX -at double -dv $bbMinX AutoPlacing;
addAttr -k 0 -ln fingerWidth -at double -dv 1 AutoPlacing;

duplicate -n CombinedSkinUpper_M CombinedSkin;
duplicate -n CombinedSkinLower_M CombinedSkin;
select CombinedSkinUpper_M CombinedSkinLower_M;
//refresh;
catchQuiet (`setAttr CombinedSkinUpper_M.v 0`);
catchQuiet (`setAttr CombinedSkinLower_M.v 0`);

//$fitSkeletonBB=`xform -q -ws -bb FitSkeleton`;
$scale=`getAttr FitSkeleton.sy`;
$tempString=`listRelatives -ad -type joint -fullPath FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[1]>$maxY)
		$maxY=$pos[1];
	}
if (size($tempString)==0) $maxY=17.176;
if ($maxY<0.1) $maxY=0.1;

$newScale=($bbMaxY/$maxY)*$scale;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	$posXs[$i]=$pos[0];
	$posYs[$i]=$pos[1];
	$posZs[$i]=$pos[2];
	}
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	xform -ws -t ($posXs[$i]*$newScale) ($posYs[$i]*$newScale) ($posZs[$i]*$newScale) $tempString[$i];
	if (`attributeExists fat $tempString[$i]`)
	setAttr ($tempString[$i]+".fat") (`getAttr ($tempString[$i]+".fat")`*$newScale);
	}

setAttr FitSkeleton.s -type float3 1 1 1;
//$pos=`xform -q -ws -t FitSkeletonShape.cv[3]`;
$bb=`getAttr FitSkeletonShape.boundingBoxMax`;
$scale=($bbMaxY/5.5)/$bb[0];
scale -r -p 0 0 0 $scale $scale $scale FitSkeletonShape.cv[0:99];

jointDisplayScale ($bbMaxY/100.0);

if ($fitAutoScale)
	{
	asFitDeleteGuides;
	catchQuiet (`select $sel`);
	return;
	}

$tempString[0]=`curve -d 1 -p $bbMinX 0 0 -p $bbMaxX 0 0`;
rename $tempString[0] asFitScanCurve;
setAttr asFitScanCurveShape.overrideEnabled 1;
setAttr asFitScanCurveShape.overrideColor 14;
//setAttr asFitScanCurveShape.dispGeometry 0;
parent asFitScanCurve asFitScanCurves;

for ($z=0;$z<size($zxy);$z++)
	{
	if (!$numFitJoints)
		break;

	$bbMinZ=`getAttr AutoPlacing.bbMinZ`;
	$bbMaxZ=`getAttr AutoPlacing.bbMaxZ`;
	$bbMaxY=`getAttr AutoPlacing.bbMaxY`;
	$bbMinX=`getAttr AutoPlacing.bbMinX`;

	$maxWidth=$zWidthMax=0;
//	setAttr asFitScanCurveShape.overrideColor (13+$z);
	if (`gmatch $zxy[$z] "z*"`)
		{
		setAttr asFitScanCurve.t -type float3 0 0 $bbMaxZ;
		setAttr asFitScanCurve.r -type float3 0 0 0;
		$circleNormalAxis={0,1,0};
		}
	if ($zxy[$z]=="x")
		{
		setAttr asFitScanCurve.t -type float3 $bbMinX 0 0;
		setAttr asFitScanCurve.r -type float3 0 -90 0;
		$circleNormalAxis={0,0,1};
		}
	if (`gmatch $zxy[$z] "y*"`)
		{
		setAttr asFitScanCurve.t -type float3 $bbMinX $bbMaxY 0;
		setAttr asFitScanCurve.r -type float3 0 -90 0;
		$circleNormalAxis={1,0,0};
		}
	for ($i=0;$i<100;$i++)
		{
		asFitAutoOrbit $camOrbitStep;
		if (`gmatch $zxy[$z] "z*"`)
			{$xStep=0;$yStep=$bbMaxY/100.0;$zStep=0;$xDir=0;$yDir=0;$zDir=1;}
		if ($zxy[$z]=="x")
			{$xStep=0;$yStep=$bbMaxY/100.0;$zStep=0;$xDir=1;$yDir=0;$zDir=0;}
		if (`gmatch $zxy[$z] "y*"`)
			{$xStep=0;$yStep=0;$zStep=$bbMinX/50.0;$xDir=0;$yDir=1;$zDir=0;}
		if ($i==99) {$xStep*=0.9;$yStep*=0.9;$zStep*=0.9;}//avoid overshoot
		move -r -os -wd $xStep $yStep $zStep asFitScanCurve;
		if (`objExists asFitScanPolyProjectionCurves`)
			delete asFitScanPolyProjectionCurves;
		if (($zxy[$z]=="y" || $zxy[$z]=="yElbowStraight") && `objExists CombinedSkinUpper_R`)
			$projectOn="CombinedSkinUpper_R";
		else
			$projectOn="CombinedSkin";
		$tempString=`polyProjectCurve -ch true -direction $xDir $yDir $zDir -pointsOnEdges 0 -curveSamples 50 -automatic 1 asFitScanCurve $projectOn`;
		rename $tempString[0] asFitScanPolyProjectionCurves;
		parent asFitScanPolyProjectionCurves asFitScanCurves;

		refresh;
		$projectedCurves=`listRelatives -c -type transform asFitScanPolyProjectionCurves`;
		$numPreviousHits=$numHits;
		$numHits=size(`listRelatives -c $projectedCurves`);
		$projectedCenterCurve=`asGetProjectedCurve asFitScanPolyProjectionCurves "center"`;
		$previousWidth=$width;
		$bbMin=`getAttr ($projectedCenterCurve+".boundingBoxMin")`;
		$bbMax=`getAttr ($projectedCenterCurve+".boundingBoxMax")`;
		if (`gmatch $zxy[$z] "z*"`) $width=$bbMax[0]-$bbMin[0];
		if ($zxy[$z]=="x") $width=$bbMax[2]-$bbMin[2];
		if (`gmatch $zxy[$z] "y*"`) $width=$bbMax[2]-$bbMin[2];
		if ($width>$maxWidth)
			$maxWidth=$width;
		$zWidth=$bbMax[2]-$bbMin[2];
		if ($zWidth>$zWidthMax)
			{
			$tyAtMaxZ=`getAttr asFitScanCurve.ty`;
			$zWidthMax=$zWidth;
			}
		$bbCenterX=($bbMin[0]+$bbMax[0])/2.0;

		//checks
		if ($zxy[$z]=="zLoft" && !$fourFingerHit)
			{
			asFitDeleteGuides;
			print ("// Unable to detect \""+$fitSkeletonTemplate+"\" form.\n");
			return;
			}

		//Loft
		if (`gmatch $zxy[$z] "*Loft"`)
			{
			if ($zxy[$z]=="zLoft" && $i<$hitCrotchNr)
				{$find="right";$combinedSkin="CombinedSkinLower_R";}
			else if ($zxy[$z]=="yLoft")
				{$find="widest";$combinedSkin="CombinedSkinUpper_M";}
			else
				{$find="widest";$combinedSkin="CombinedSkin";}
			if ($i==0)
				createNode -n ("asFitLoftCurves"+$zxy[$z]) -p AutoPlacing transform;
			asSaveProjection ("Loft"+$zxy[$z]+$i) $zxy[$z] $combinedSkin $find 0;
			
			$tempString=`listRelatives -c ("asFitProjectionLoft"+$zxy[$z]+$i)`;
			$projectedCurve=`asGetProjectedCurve ("asFitProjectionLoft"+$zxy[$z]+$i) $find`;
//print ("$projectedCurve="+$projectedCurve+"\n");
//if ($zxy[$z]=="yLoft" && $i==4) a;
			for ($x=0;$x<size($tempString);$x++)
				if ($tempString[$x]!=$projectedCurve)
					delete $tempString[$x];
			$tempString=`listRelatives -c ("asFitProjectionLoft"+$zxy[$z]+$i)`;
			$tempFloatA=`getAttr ($tempString[0]+".boundingBoxMin")`;
			$tempFloatB=`getAttr ($tempString[0]+".boundingBoxMax")`;
			$tempString2=`circle -c 0 0 0 -nr $circleNormalAxis[0] $circleNormalAxis[1] $circleNormalAxis[2] -sw 360 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
			rename $tempString2[0] ("asFitProjectionLoftCurve"+$zxy[$z]+$i);
			parent ("asFitProjectionLoftCurve"+$zxy[$z]+$i) ("asFitLoftCurves"+$zxy[$z]);
			xform -ws -t (($tempFloatA[0]+$tempFloatB[0])/2.0) (($tempFloatA[1]+$tempFloatB[1])/2.0) (($tempFloatA[2]+$tempFloatB[2])/2.0) ("asFitProjectionLoftCurve"+$zxy[$z]+$i);
			setAttr ("asFitProjectionLoftCurve"+$zxy[$z]+$i+".s") -type float3 (($tempFloatB[0]-$tempFloatA[0])/2.0) (($tempFloatB[1]-$tempFloatA[1])/2.0) (($tempFloatB[2]-$tempFloatA[2])/2.0);
			if ($i==0)
				{
				duplicate -n ("asFitProjectionLoftCurve"+$zxy[$z]+"a") ("asFitProjectionLoftCurve"+$zxy[$z]+$i);
				move -r 0 ($yStep*-1) 0 ("asFitProjectionLoftCurve"+$zxy[$z]+"a");
				reorder -relative -1 ("asFitProjectionLoftCurve"+$zxy[$z]+"a");
				}
			if ($i==99 || ($zxy[$z]=="yLoft" && $i==50))
				asFitAutoPlaceLoft $zxy[$z];
			if ($zxy[$z]=="yLoft" && $i==50)
				break;
			}

		//Crotch
		if ($zxy[$z]=="z" && $hasHitCrotch==0 && abs($bbCenterX)<0.01)
			{
			asSaveProjection Crotch $zxy[$z] CombinedSkin "center" 0;
			$tempFloatA=`getAttr ($projectedCenterCurve+".boundingBoxMin")`;
			$tempFloatB=`getAttr ($projectedCenterCurve+".boundingBoxMax")`;
			$crotchWidth=$tempFloatB[0]-$tempFloatA[0];
			//Root
			move -r -os -wd 0 ($crotchWidth/4.0) 0 asFitScanCurve;
			asSaveProjection Root $zxy[$z] CombinedSkinLower_M "center" 1;

			move -r -os -wd 0 ($crotchWidth/-8.0) 0 asFitScanCurve;
			asSaveProjection Hip $zxy[$z] CombinedSkinLower_M "center" 1;			

			setAttr asFitScanCurve.ty `getAttr asFitScanCurveCrotch.ty`;
			$hasHitCrotch=1;
			$hitCrotchNr=$i;
			//non-biped uses Root only
			if (!`gmatch $fitSkeletonTemplate "biped*"`)
				{$z=99;break;}
			}

		//ArmPit
		if ($zxy[$z]=="z" && $hasHitCrotch==1 && $i>($hitCrotchNr+5) && $hasHitArmPit==0)
			if ($width>($previousWidth*1.5) || ($numHits==1 && $numPreviousHits>1))//got >1.5x wider, or multiHit > singleHit (armsDown)
				{
				move -r -os -wd 0 ($bbMaxY/-100.0) 0 asFitScanCurve;
				asSaveProjection ArmPit $zxy[$z] CombinedSkin "center" 0;
				$tempString[0]=`asGetProjectedCurve asFitProjectionArmPit "center"`;
				$tempFloatA=`getAttr ($tempString[0]+".boundingBoxMin")`;
				$tempFloatB=`getAttr ($tempString[0]+".boundingBoxMax")`;
				$armPitWidth=$tempFloatB[0]-$tempFloatA[0];

				$a=`getAttr asFitScanCurveRoot.ty`;
				$b=`getAttr asFitScanCurveArmPit.ty`;
				setAttr asFitScanCurve.ty ($b-(($b-$a)/4.0));
				asSaveProjection Chest $zxy[$z] CombinedSkinLower_M "center" 1;

				$b=`getAttr asFitScanCurveChest.ty`;
				setAttr asFitScanCurve.ty ($b-(($b-$a)/2.0));
				asSaveProjection Spine1 $zxy[$z] CombinedSkinLower_M "center" 1;

				setAttr asFitScanCurve.ty `getAttr asFitScanCurveArmPit.ty`;
				$hasHitArmPit=1;
				}

		//Neck
		if ($zxy[$z]=="z" && $hasHitNeck==0 && $hasHitArmPit==1 && $width<$armPitWidth)
			{
			asSaveProjection Neck $zxy[$z] CombinedSkin "center" 1;
			$hasHitNeck=1;
			}

		//Head
		if ($zxy[$z]=="z" && $hasHitNeck==1 && $hasHitHead==0)
			{
			$a=`getAttr asFitScanCurveNeck.ty`;
			$b=$a+($bbMaxY-$a)/5.0;
			if (`getAttr asFitScanCurve.ty`>$b)
				{
				asSaveProjection Head $zxy[$z] CombinedSkin "center" 1;
				$hasHitHead=1;
				}
			}

		//Ankle
		if ($zxy[$z]=="x" && $hasHitAnkle==0 && $i>2 && $width<($maxWidth/2.0) && $width>($previousWidth*0.9) && $numHits==2)
			{
			move -r -os -wd 0 ($bbMaxY/-100.0) 0 asFitScanCurve;
			asSaveProjection Ankle $zxy[$z] CombinedSkinLower_M "right" 1;
			setAttr asFitScanCurve.ty ((`getAttr asFitScanCurveCrotch.ty`+`getAttr asFitScanCurveAnkle.ty`)/2.0);
			//Knee
			asSaveProjection Knee $zxy[$z] CombinedSkinLower_M "right" 1;
			setAttr asFitScanCurve.ty `getAttr asFitScanCurveAnkle.ty` 1;
			move -r -os -wd 0 ($bbMaxY/-100.0) 0 asFitScanCurve;
			//Toes (maxZ before Ankle)
			setAttr asFitScanCurve.ty $tyAtMaxZ;
			asSaveProjection Toes $zxy[$z] CombinedSkinLower_M "right" 1;
			setAttr asFitScanCurve.ty `getAttr asFitScanCurveAnkle.ty`;

			//Ankle orientation
			$projectedCurve=`asGetProjectedCurve asFitProjectionToes "right"`;
			duplicate -n AnkleRotSampler $projectedCurve;
			parent AnkleRotSampler AutoPlacing;
//			$tempString=`listRelatives -s AnkleRotSampler`;
//			$projectedCurveShape=$tempString[0];
			asLockAttr AnkleRotSampler 1 0 1 1;
			select AnkleRotSampler;
			CenterPivot;
			for ($i=0;$i<90;$i++)
				{
				$pos=`xform -q -ws -piv AnkleRotSampler`;
				rotate -r -p $pos[0] $pos[1] $pos[2] -os -fo 0 1 0 AnkleRotSampler.cv[0:999];
			//	refresh;
				$bb=`xform -q -ws -bb AnkleRotSampler`;
				$previousWidth=$width;
				$width=$bb[3]-$bb[0];
				if ($i>0 && $width>$previousWidth)
					{
					setAttr AnkleRotSampler.ry (($i+1)*-1);
					break;
					}
				}
//			setAttr Ankle.rx (`getAttr AnkleRotSampler.ry`*-1);
//			xform -ws -ro (90-`getAttr AnkleRotSampler.ry`) 0 -90 Ankle;
			$ankleCurveRy=`getAttr AnkleRotSampler.ry`;

			//FootSideOuter FootSideInner ToesEnd Heel
			setAttr AnkleRotSampler.ry 0;
			createNode -n tempXform1 -p AnkleRotSampler transform;
			duplicate -n tempXform2 tempXform1;
			duplicate -n tempXform3 tempXform1;
			duplicate -n tempXform4 tempXform1;
			duplicate -n tempXform5 tempXform1;
			duplicate -n tempXform6 tempXform1;
			$bbMin=`getAttr AnkleRotSamplerShape.boundingBoxMin`;
			$bbMax=`getAttr AnkleRotSamplerShape.boundingBoxMax`;
			xform -ws -t (($bbMin[0]+$bbMax[0])/2.0) (($bbMin[1]+$bbMax[1])/2.0) $bbMin[2] tempXform1;
			xform -ws -t (($bbMin[0]+$bbMax[0])/2.0) (($bbMin[1]+$bbMax[1])/2.0) $bbMax[2] tempXform2;
			xform -ws -t $bbMin[0] (($bbMin[1]+$bbMax[1])/2.0) (($bbMin[2]+$bbMax[2])/2.0) tempXform4;
			xform -ws -t $bbMax[0] (($bbMin[1]+$bbMax[1])/2.0) (($bbMin[2]+$bbMax[2])/2.0) tempXform5;
			xform -ws -t (($bbMin[0]+$bbMax[0])/2.0) (($bbMin[1]+$bbMax[1])/2.0) $bbMax[2] tempXform6;
			pointConstraint -w 0.25 tempXform1 tempXform3;
			pointConstraint -w 0.75 tempXform2 tempXform3;
			parent tempXform4 tempXform5 tempXform6 tempXform3;
			setAttr tempXform4.tz 0;
			setAttr tempXform5.tz 0;
			setAttr AnkleRotSampler.ry $ankleCurveRy;
			parent tempXform3 asFitPivotToes;
//			pointConstraint -w 1.0 asFitPivotOffsetToes Toes;//find the offset
			setAttr asFitHandleToes.offsetZ `getAttr tempXform3.tz`;
			if (`objExists FootSideOuter`)
				{
				asFitAnchor FootSideOuter;
				$pos=`xform -q -ws -t tempXform4`;
				xform -ws -t $pos[0] 0 $pos[2] asFitAnchorFootSideOuter;
				}
			if (`objExists FootSideInner`)
				{
				asFitAnchor FootSideInner;
				$pos=`xform -q -ws -t tempXform5`;
				xform -ws -t $pos[0] 0 $pos[2] asFitAnchorFootSideInner;
				}
			if (`objExists ToesEnd`)
				{
				asFitAnchor ToesEnd;
				$pos=`xform -q -ws -t tempXform6`;
				xform -ws -t $pos[0] 0 $pos[2] asFitAnchorToesEnd;
				}
			if (`objExists Heel`)
				{
				asFitAnchor Heel;
				$pos=`xform -q -ws -t tempXform1`;
				xform -ws -t $pos[0] 0 $pos[2] asFitAnchorHeel;
				}
//			setAttr ToesEnd.tz 0;
			delete tempXform1 tempXform2 tempXform3 tempXform4 tempXform5 tempXform6;

			//re-orient asFitPivotToes
			setAttr asFitPivotOrientToes.ry $ankleCurveRy;

			$hasHitAnkle=1;
			}

		//ArmTip
		if ($zxy[$z]=="yArmStraight" && $hasHitArmTip==0)
			{
			asSaveProjection ArmTip $zxy[$z] CombinedSkin "0" 0;
			$hasHitArmTip=1;
			}

		//Shoulder
		if ($zxy[$z]=="yArmStraight" && $hasHitShoulder==0 && `getAttr asFitScanCurve.tx`>($armPitWidth*-0.5) && `objExists asFitPivotArmPit`)
			{
			asSaveProjection Shoulder $zxy[$z] CombinedSkin "closestToasFitPivotArmPit" 1;

			//BodyCut
			if (!$hasStraightenArm && `objExists asFitPivotArmPit` && `objExists asFitPivotNeck` && `objExists asFitPivotShoulder`)
				{
				$camOrbitStep*=-1;
				catchQuiet (`setAttr CombinedSkin.v 0`);
				catchQuiet (`setAttr CombinedSkinLower_M.v 0`);
				catchQuiet (`setAttr CombinedSkinUpper_M.v 1`);
				select CombinedSkinUpper_M;
				polySelectConstraint -m 3 -t 1 -d 3 -db 0 ($bbMaxY/10.0) -da 0 1 0 -dp 0 0 0;
				polySelectConstraint -m 0;
				
				for ($a=0;$a<999;$a++)
					{
					$numVtxsA=size(`ls -sl -fl`);
					polySelectConstraint -pp 1 -t 0x0001;
					$numVtxsB=size(`ls -sl -fl`);
					if ($numVtxsB==$numVtxsA)
						break;
					$tempBBox=`xform -q -bb`;
					if ($tempBBox[4]>`getAttr asFitPivotArmPit.ty`)
						break;
					}
				ConvertSelectionToFaces;
				$tempString=`ls -sl`;
				delete;
				select `asobjSetCast "" $tempString CombinedSkinLower_M`;
				asInvertSelection;
				delete;

				//separate head
				duplicate -n CombinedSkinHead_M CombinedSkinUpper_M;
				connectAttr -f CombinedSkinUpper_M.outMesh closestSampler.inMesh;
				$pos=`xform -q -ws -t asFitHandleNeck`;
				select CombinedSkinHead_M;
				polySelectConstraint -m 3 -t 1 -d 3 -db 0 $pos[1] -da 0 1 0 -dp 0 0 0;
				polySelectConstraint -m 0;
				ConvertSelectionToFaces;
				$tempString=`ls -sl`;
				delete;
				select `asobjSetCast "" $tempString CombinedSkinUpper_M`;
				asInvertSelection;
				delete;

				//find $armVtxs
				$pos=`xform -q -ws -t asFitPivotOffsetArmTip`;
				setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
				$closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
				select ("CombinedSkinUpper_M.vtx["+$closestVtxIndex+"]");
				for ($a=0;$a<999;$a++)
					{
					$numVtxsA=size(`ls -sl -fl`);
					polySelectConstraint -pp 1 -t 0x0001;
					$numVtxsB=size(`ls -sl -fl`);
					if ($numVtxsB==$numVtxsA)
						{
						//`out of grow` before reach, attempt Shell-leap. e.g wrist geo ended, leap to sleeve
						//separate shell to obj, wrap-def (exl-bind), grow maxDist until `bite`
						asPolyGrowPastShell;
						$numVtxsB=size(`ls -sl -fl`);
						if ($numVtxsB==$numVtxsA)
							break;
						}
					$tempBBox=`xform -q -bb`;
					if (($tempBBox[4]>((`getAttr asFitPivotArmPit.ty`+`getAttr asFitPivotNeck.ty`)/2.0)) && $tempBBox[3]>`getAttr asFitPivotShoulder.tx`)
						break;
					}
				$armVtxs=`ls -sl -fl`;
				select asFitAutoPlaceJoints;
				joint -n asFitShoulderStraightBase;
				joint -n asFitShoulderStraight;
				setAttr asFitShoulderStraightBase.v 0;

				$posA=`xform -q -ws -t asFitPivotArmPit`;
				$posB=`xform -q -ws -t asFitPivotNeck`;
				$posC=`xform -q -ws -t asFitPivotShoulder`;
				xform -ws -t $posC[0] (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) asFitShoulderStraight;
				select asFitShoulderStraight asFitShoulderStraightBase CombinedSkinUpper_M;
				$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
				rename $tempString[0] CombinedSkinUpperSC_M;
				skinPercent -tv asFitShoulderStraightBase 1 CombinedSkinUpperSC_M CombinedSkinUpper_M;
				skinPercent -tv asFitShoulderStraight 1 CombinedSkinUpperSC_M $armVtxs;
				select CombinedSkinUpper_M;
				deltaMush -n asFitDeltaMush -smoothingIterations 30 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1;
				refresh;//ensure to store bindPose in deltaMush
				createNode -n tempXform1 -p AutoPlacing transform;
				pointConstraint asFitShoulderStraight tempXform1;
				aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "scene" asFitPivotArmTip tempXform1;
				if (`getAttr tempXform1.rz`>10)
					setAttr asFitShoulderStraight.rz (`getAttr tempXform1.rz`*-1);
				$rz=`getAttr asFitShoulderStraight.rz`;
				delete tempXform1;

				$posA=`xform -q -ws -t asFitPivotArmTip`;
				delete asFitProjectionArmTip asFitScanCurveArmTip;
				xform -ws -t $posA[0] $posA[1] $posA[2] asFitPivotArmTip;

//				delete asFitProjectionShoulder asFitScanCurveShoulder;
				$hasHitArmTip=0;
				$bbMin=`getAttr "CombinedSkinUpper_M.boundingBoxMin"`;
				$bbMinX=$bbMin[0];
				//update AutoPlacing.bbMinX
				setAttr AutoPlacing.bbMinX $bbMinX;

				//split Left/Right
				for ($b=1;$b>-2;$b=$b-2)
					{
					if ($b==1) $side="_R";
					else $side="_L";

					for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
						{
						if ($upperLowerFactor==1) $upperLower="Upper";
						else $upperLower="Lower";

						duplicate -n ("CombinedSkin"+$upperLower+$side) ("CombinedSkin"+$upperLower+"_M");
						select ("CombinedSkin"+$upperLower+"_M") ("CombinedSkin"+$upperLower+$side);
						blendShape -n ("CombinedSkin"+$upperLower+"BS"+$side) -frontOfChain -w 0 1;
						select ("CombinedSkin"+$upperLower+$side);
						refresh;
						polySelectConstraint -m 3 -t 0x0008 -d 3 -db 0 ($bbMinX*-1) -da 1 0 0 -dp $bbMinX 0 0;
						if ($side=="_R")
						asInvertSelection;
						delete;
						polySelectConstraint -m 0;
						catchQuiet (`setAttr ("CombinedSkin"+$upperLower+$side+".v") 0`);
						}
					}

				//Re-Do Shoulder to project on CombinedSkinUpper_R
				asUpdateProjection Shoulder $zxy[$z] CombinedSkinUpper_R "closestToasFitPivotArmPit" 1;
				$hasStraightenArm=1;
				}

			$hasHitShoulder=1;
			break;//change  $zxy[$z]="yArmStraight" to $zxy[$z]="y"
			}

		if ($zxy[$z]=="yElbowStraight" && $numPreviousHits>1 && $numHits==1 && `getAttr asFitScanCurve.tx`<($bbMinX/2.0))
			$firstNonFingerSplitTx=`getAttr asFitScanCurve.tx`;

		if ($zxy[$z]=="y" && !`objExists asFitElbowStraight`)
			{
			$scanCurveTx=`getAttr asFitScanCurve.tx`;

			//start by go to FirstNonFingerSplit
			setAttr asFitScanCurve.tx $firstNonFingerSplitTx;
			asSaveProjection FirstNonFingerSplit $zxy[$z] CombinedSkinUpper_M "0" 0;

			//Wrist
			setAttr asFitScanCurve.tx ($firstNonFingerSplitTx-(($bbMinX-$firstNonFingerSplitTx)/2.5));
			asSaveProjection Wrist $zxy[$z] CombinedSkinUpper_M "0" 1;

			//Elbow
			setAttr asFitScanCurve.tx ((`getAttr asFitHandleShoulder.tx`+$firstNonFingerSplitTx)/2.0);
			asSaveProjection Elbow $zxy[$z] CombinedSkinUpper_M "0" 1;
			setAttr asFitScanCurve.tx $firstNonFingerSplitTx;
			$pos=`xform -q -ws -t asFitPivotElbow`;
			select -r asFitShoulderStraight;
			joint -n asFitElbowStraight;
			xform -ws -t $pos[0] $pos[1] $pos[2] asFitElbowStraight;
			$rz=`getAttr asFitShoulderStraight.rz`;
			setAttr asFitShoulderStraight.rz 0;
			skinCluster -e -lw false -wt 0 -ai asFitElbowStraight CombinedSkinUpperSC_M;
			setAttr asFitShoulderStraight.rz $rz;
			select CombinedSkinUpper_M;
			polySelectConstraint -m 3 -t 1 -d 3 -db 0 999 -da 1 0 0 -dp (-999+$pos[0]) 0 0;
			skinPercent -tv asFitElbowStraight 1 CombinedSkinUpperSC_M `ls -sl`;
			polySelectConstraint -m 0;

			//Straighten Elbow so asFitPivotMiddleFinger4 is `directly down X`
			spaceLocator -n tempLoc1;
			parent tempLoc1 AutoPlacing;
			$posA=`xform -q -ws -t asFitPivotFirstNonFingerSplit`;
			$posB=`xform -q -ws -t asFitElbowStraight`;
			xform -ws -t $posA[0] $posA[1] $posA[2] tempLoc1;
			parentConstraint -mo asFitElbowStraight asFitPivotsFingers;
			aimConstraint -mo -weight 1 -aimVector 0 -1 0 -upVector -1 0 0 -worldUpType "scene" tempLoc1 asFitElbowStraight;
			refresh;
			xform -ws -t $posA[0] $posA[1] $posB[2] tempLoc1;
			refresh;
			delete asFitElbowStraight_aimConstraint1 tempLoc1;

			setAttr asFitScanCurve.tx $scanCurveTx;
			}

		//$fourFingerHit
		if ($zxy[$z]=="y" && $fourFingerHit==0 && $numHits==4)
			{
			$scanCurveTx=`getAttr asFitScanCurve.tx`;
			$fingerDetectPopDist=$zStep/-4;

			//Keep scanning, and find pos that is Half way to Non-4Hit
			for ($a=1;$a<199;$a++)
				{
				duplicate -n asFitScanCurveAgent asFitScanCurve;
				move -r -os -wd 0 0 (($zStep/10.0)*$a) asFitScanCurveAgent;//Move forward to check
				$tempString=`polyProjectCurve -ch true -direction $xDir $yDir $zDir -pointsOnEdges 0 -curveSamples 50 -automatic 1 asFitScanCurveAgent $projectOn`;
				rename $tempString[0] asFitScanPolyProjectionCurvesAgent;
//					refresh;//needed for correct $numAgentHits count
				$numAgentHits=size(`listRelatives -c asFitScanPolyProjectionCurvesAgent`);
				$agenCurveTx=`getAttr asFitScanCurveAgent.tx`;
				delete asFitScanCurveAgent asFitScanPolyProjectionCurvesAgent;
				if ($numAgentHits!=4)
					break;
				}
//			setAttr asFitScanCurve.tx (($scanCurveTx+$agenCurveTx)/2.0);removed as it jumped to include thumb
			//re-project as the projected curves might be `outdated`
			delete asFitScanPolyProjectionCurves;
			$tempString=`polyProjectCurve -ch true -direction $xDir $yDir $zDir -pointsOnEdges 0 -curveSamples 50 -automatic 1 asFitScanCurve CombinedSkinUpper_M`;
			rename $tempString[0] asFitScanPolyProjectionCurves;
			parent asFitScanPolyProjectionCurves asFitScanCurves;

			for ($y=0;$y<size($fingers);$y++)
				{
				$checkingCurve="polyProjectionCurve1_"+($y+1);
				$checkingCurveNr=$y;
				$bbMin=`getAttr ($checkingCurve+".boundingBoxMin")`;
				$bbMax=`getAttr ($checkingCurve+".boundingBoxMax")`;
				if (($bbMax[2]-$bbMin[2])>$maxFingerWidth)
					$maxFingerWidth=$bbMax[2]-$bbMin[2];
				$posA[0]=($bbMin[0]+$bbMax[0])/2.0;$posA[1]=($bbMin[1]+$bbMax[1])/2.0;$posA[2]=($bbMin[2]+$bbMax[2])/2.0;
				setAttr closestSampler.inPosition $posA[0] $posA[1] $posA[2];
				$closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
				select ("CombinedSkinUpper_M.vtx["+$closestVtxIndex+"]");
				//grow outwards, until tip, detrmin how many `growth`, and redo that many (minus 1) to find a resonable end vtx(s)
				for ($a=0;$a<199;$a++)
					{
					$bb=`xform -q -ws -bb`;
					polySelectConstraint -pp 1 -t 0x0001;
					$bb2=`xform -q -ws -bb`;
					if (!($bb2[0]<$bb[0]))
						{
						$tempString=`ls -sl -fl`;
						$minX2=999;
						for ($cc=0;$cc<size($tempString);$cc++)
							{
							$pos=`xform -q -ws -t $tempString[$cc]`;
							if ($pos[0]<$minX2)
								{
								$minX2=$pos[0];
								select $tempString[$cc];
								}
							}
						break;
						}
					}
				$tempString=`ls -sl -fl`;
				$pos=`xform -q -ws -t`;
				createNode -n ("asFitPivot"+$fingers[$y]+"Finger4") -p asFitPivotsFingers transform;
				xform -ws -t $pos[0] $pos[1] $pos[2] ("asFitPivot"+$fingers[$y]+"Finger4");
				select $tempString;

				//fingerTip vtx(s) selected here
				//then grow `in-wards` until knuckle
				$curveCmd="curve -d 1 -n FingerCurve"+$fingers[$y];
				$numCV=0;
				for ($a=0;$a<199;$a++)
					{
					$tempString3=`ls -sl -fl`;
					polySelectConstraint -pp 1 -t 0x0001;
					$tempString4=`ls -sl -fl`;
					select -d $tempString3;
					$tempString5=`ls -sl -fl`;
					$bb=`xform -q -ws -bb`;

//					$diam=(($bb[4]-$bb[1])+($bb[5]-$bb[2]))/2.0;
					$diam=($bb[5]-$bb[2])/2.0;
					if ($a==4)
						$averageDiam=$diam;
//					print ($a+" : "+$diam+"\n");
					if ($a>3 && $diam>$averageDiam*2.0)
								{
								createNode -n ("asFitPivot"+$fingers[$y]+"Finger1") -p asFitPivotsFingers transform;
								xform -ws -t (($prevBB[0]+$prevBB[3])/2.0) (($prevBB[1]+$prevBB[4])/2.0) (($prevBB[2]+$prevBB[5])/2.0) ("asFitPivot"+$fingers[$y]+"Finger1");
								$a=199;
								}
					else
						$curveCmd+=" -p "+(($bb[0]+$bb[3])/2.0)+" "+(($bb[1]+$bb[4])/2.0)+" "+(($bb[2]+$bb[5])/2.0);
					$prevBB=$bb;
					$numCV++;
					select $tempString4;
					}
				eval ($curveCmd);
				parent ("FingerCurve"+$fingers[$y]) asFitPivotsFingers;
				}
			setAttr AutoPlacing.fingerWidth $maxFingerWidth;
			$fourFingerHit=1;
			}

		//nCloth-fingers
		if ($fourFingerHit && !$hasNCloth)
			{
			createNode -n fingersConverge -p asFitPivots transform;
			pointConstraint asFitPivotNeck fingersConverge;
			for ($y=0;$y<size($fingers);$y++)
				pointConstraint ("asFitPivot"+$fingers[$y]+"Finger1") fingersConverge;
			clear $tempString2;
			for ($y=0;$y<size($fingers);$y++)
				{
				$posA=`xform -q -ws -t ("asFitPivot"+$fingers[$y]+"Finger1")`;
				setAttr closestSampler.inPosition $posA[0] $posA[1] $posA[2];
				$closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
				$closestToBaseVtx="CombinedSkin"+$fingers[$y]+"_R.vtx["+$closestVtxIndex+"]";
				$posA=`xform -q -ws -t ("asFitPivot"+$fingers[$y]+"Finger4")`;
				setAttr closestSampler.inPosition $posA[0] $posA[1] $posA[2];
				$closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
				duplicate -n ("CombinedSkin"+$fingers[$y]+"_R") CombinedSkinUpper_M;
				parent ("CombinedSkin"+$fingers[$y]+"_R") asFitNCloth;
				select ("CombinedSkin"+$fingers[$y]+"_R.vtx["+$closestVtxIndex+"]");
				for ($b=0;$b<99;$b++)
					{
					polySelectConstraint -pp 1 -t 0x0001;
					$tempString=`ls -sl -fl`;
					if (`stringArrayCount $closestToBaseVtx $tempString`)
						break;
					$previousSel=`ls -sl`;
					}
				$fingerVtxs=`ls -sl`;
				select -d $previousSel;
				sets -n tempSet;
				select $fingerVtxs;
				ConvertSelectionToContainedFaces;
				$tempString=`ls -sl`;
				asInvertSelection;
				delete;
				select `asobjSetCast "" $tempString CombinedSkinUpper_M`;
				$tempString=`ls -sl`;
				$tempString2=`stringArrayCatenate $tempString $tempString2`;
				//nCloth
				select ("CombinedSkin"+$fingers[$y]+"_R");
				$tempString=`createNCloth 0`;
				$tempString=`listRelatives -p $tempString[0]`;
				rename $tempString[0] ("nCloth"+$fingers[$y]);
				parent ("nCloth"+$fingers[$y]) asFitNCloth;
				select `asobjSetCast tempSet {} ("CombinedSkin"+$fingers[$y]+"_R")`;
				$tempString=`createNConstraint transform 0`;
				$tempString=`listRelatives -p $tempString[0]`;
				parent $tempString[0] asFitNCloth;
				delete tempSet;
				setAttr ("nCloth"+$fingers[$y]+".collide") 0;
				setAttr ("nCloth"+$fingers[$y]+".selfCollide") 0;
				setAttr ("nCloth"+$fingers[$y]+".stretchResistance") 40;
				setAttr ("nCloth"+$fingers[$y]+".compressionResistance") 20;
				setAttr ("nCloth"+$fingers[$y]+".bendResistance") 0.2;
				setAttr ("nCloth"+$fingers[$y]+".bendAngleDropoff") 0.6;
				setAttr ("nCloth"+$fingers[$y]+".pointMass") 0.15;
				setAttr ("nCloth"+$fingers[$y]+".tangentialDrag") 0.4;
				setAttr ("nCloth"+$fingers[$y]+".damp") 2;
				setAttr ("nCloth"+$fingers[$y]+".ignoreSolverGravity") 1;
				delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "scene" ("asFitPivot"+$fingers[$y]+"Finger1") fingersConverge`;
				$ry=`getAttr fingersConverge.ry`;
				$angleFactor=sin(deg_to_rad($ry));
				setAttr ("nCloth"+$fingers[$y]+".localForce") -type float3 (-98*(1-$angleFactor)) 0 (98*$angleFactor);
				}
//			select $tempString2;
//			delete;
			$tempString=`ls -type nucleus`;
			rename $tempString[0] asFitNucleus;
			parent asFitNucleus asFitNCloth;
			setAttr asFitNucleus.spaceScale (1.0/$bbMaxY*160);

			select  CombinedSkinUpper_M CombinedSkinIndex_R;
			$tempString=`doWrapArgList "7" { "1","0","0.1", "1", "0", "0", "1", "0" }`;
			//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
			rename $tempString[0] CombinedSkinUpperWrap_M;
			for ($y=1;$y<size($fingers);$y++)
				{
				select  CombinedSkinUpper_M ("CombinedSkin"+$fingers[$y]+"_R");
				AddWrapInfluence;
				}
			setAttr asFitNCloth.v 0;
			for ($i=0;$i<40;$i++)
				{
				asFitAutoOrbit $camOrbitStep;
				currentTime 2;
				currentTime 3;
				}

			setAttr asFitDeltaMush.envelope	0;
			duplicate -n fingerStraight CombinedSkinUpper_M;
			delete CombinedSkinUpperWrap_M asFitNCloth;
			setAttr asFitDeltaMush.envelope	1;
			select asFitShoulderStraightBase asFitShoulderStraight asFitElbowStraight fingerStraight;
			newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
			select CombinedSkinUpper_M fingerStraight;
			copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
//			$rz=`getAttr asFitShoulderStraight.rz`;
			$rot1=`getAttr asFitShoulderStraight.r`;
			$rot2=`getAttr asFitElbowStraight.r`;
			setAttr asFitShoulderStraight.r -type float3 0 0 0;
			setAttr asFitElbowStraight.r -type float3 0 0 0;
			select fingerStraight CombinedSkinUpper_M;
			blendShape -n straightenBS -frontOfChain -origin world -w 0 1;
			setAttr asFitShoulderStraight.r -type float3 $rot1[0] $rot1[1] $rot1[2];
			setAttr asFitElbowStraight.r -type float3 $rot2[0] $rot2[1] $rot2[2];
			delete fingerStraight;
			$hasNCloth=1;
			//$fourFingerHit Reset, for re-run
			delete `listRelatives -c asFitPivotsFingers`;
			$fourFingerHit=0;
			$bbMin=`getAttr CombinedSkinUpper_M.boundingBoxMin`;
			$bbMinX=$bbMin[0];
			setAttr AutoPlacing.bbMinX $bbMinX;
			setAttr asFitScanCurve.t -type float3 $bbMinX $bbMaxY 0;
			$i=0;
			}

		//thumb (reverse from wrist detection)
		if (`objExists asFitPivotWrist` && !$hasHitThumbBranch && $hasNCloth) 
			{
			$scanCurveTx=`getAttr asFitScanCurve.tx`;
			setAttr asFitScanCurve.tx `getAttr asFitScanCurveWrist.tx`;
			delete asFitScanPolyProjectionCurves;
			$tempString=`polyProjectCurve -ch true -direction $xDir $yDir $zDir -pointsOnEdges 0 -curveSamples 50 -automatic 1 asFitScanCurve $projectOn`;
			rename $tempString[0] asFitScanPolyProjectionCurves;
			parent asFitScanPolyProjectionCurves asFitScanCurves;
			for ($r=0;$r<199;$r++)
				{
				move -r -os -wd 0 0 (($zStep/10.0)*-1) asFitScanCurve;
				refresh;
				if (size(`listRelatives -c asFitScanPolyProjectionCurves`)>1)
					break;
				}

			$tempString=`listRelatives -c -type transform asFitScanPolyProjectionCurves`;
			createNode -n angledSamplerOffset -p AutoPlacing transform;
			createNode -n angledSampler -p angledSamplerOffset transform;
			xform -ws -t 0 $bbMaxY $bbMinZ angledSamplerOffset;
			setAttr angledSamplerOffset.rx 35;
			for ($t=0;$t<size($tempString);$t++)
				{
				for ($r=0;$r<`getAttr ($tempString[$t]+".spans")`;$r++)
					{
					$pos=`xform -q -ws -t ($tempString[$t]+".cv["+$r+"]")`;
					xform -ws -t $pos[0] $pos[1] $pos[2] angledSampler;
					$posB=`getAttr angledSampler.t`;
					if ($posB[2]>$maxZ)
						{
						$maxZ=$posB[2];
						$posA=$pos;
						$thumbCurve=$tempString[$t];
						}
					}
				}
			setAttr closestSampler.inPosition $posA[0] $posA[1] $posA[2];
			$closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
			select ("CombinedSkinUpper_M.vtx["+$closestVtxIndex+"]");
			for ($t=0;$t<20;$t++)//20loops of growing should be enought to find the tip of the Thumb
				{
				$tempString=`ls -sl -fl`;
				$minXupdatedThisRound=0;
				for ($r=0;$r<size($tempString);$r++)
					{
					$pos=`xform -q -ws -t $tempString[$r]`;
					if ($pos[0]<$minX)
						{
						$posA=$pos;
						$minX=$pos[0];
						$minXupdatedThisRound=1;
						}
					}
				if (!$minXupdatedThisRound)
					break;
				polySelectConstraint -pp 1 -t 0x0001;
				}
			$tempString=`ls -sl -fl`;

			createNode -n asFitPivotThumbFinger4 -p asFitPivotsFingers transform;
			xform -ws -t $posA[0] $posA[1] $posA[2] asFitPivotThumbFinger4;

			//asFitPivotThumbFinger1 pos from wrist and ThumbBranch
			$bbMin=`getAttr asFitProjectionWrist_0.boundingBoxMin`;
			$bbMax=`getAttr asFitProjectionWrist_0.boundingBoxMax`;
			$posA={$bbMin[0],($bbMin[1]+$bbMax[1])/2.0,$bbMax[2]};

			$bbMin=`getAttr ($thumbCurve+".boundingBoxMin")`;
			$bbMax=`getAttr ($thumbCurve+".boundingBoxMax")`;
			$posB={$bbMin[0],($bbMin[1]+$bbMax[1])/2.0,$bbMin[2]};

			createNode -n asFitPivotThumbFinger1 -p asFitPivotsFingers transform;
			xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) asFitPivotThumbFinger1 angledSamplerOffset;

			//then re-find $posA in a `Space` more closly oriented to Thumb
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 asFitPivotThumbFinger4 angledSamplerOffset;
			for ($r=0;$r<size($tempString);$r++)
				{
				$pos=`xform -q -ws -t $tempString[$r]`;
				xform -ws -t $pos[0] $pos[1] $pos[2] angledSampler;
				$posA=`getAttr angledSampler.t`;
				if ($posA[0]>$maxX)
					{
					$posB=$pos;
					$maxX=$posA[0];
					}
				}
			xform -ws -t $posB[0] $posB[1] $posB[2] asFitPivotThumbFinger4;

			delete angledSamplerOffset;
			setAttr asFitScanCurve.tx $scanCurveTx;
			$hasHitThumbBranch=1;
			}
		}
	}

//refine wrist based on finder-lenght
if (`objExists asFitPivotMiddleFinger1` && `objExists asFitPivotMiddleFinger4`)
	{
	$posA=`xform -q -ws -t asFitPivotMiddleFinger1`;
	$posB=`xform -q -ws -t asFitPivotMiddleFinger4`;
	setAttr asFitHandleWrist.tx ($posA[0]-($posB[0]-$posA[0]));
	}

//guestimate eye placement (and scale) based upon 1st selected geo
$eyeGeoText=$rightEye;
tokenize $eyeGeoText $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!="" && !`gmatch $tempString[$i] "*[.]*"`)
		$eyeGeos[size($eyeGeos)]=$tempString[$i];
if (!size($eyeGeos) && `gmatch $eyeGeoText "*[.]*"`)//eye part of main mesh
	{
	select `ls -o $tempString[0]`;
	$tempString2=`duplicate`;
	rename $tempString2[0] asDuplicatedEye;
	select `asobjSetCast "" $tempString asDuplicatedEye`;
	asInvertSelection;
	delete;
	$eyeGeos[0]=$tempString[0]="asDuplicatedEye";
	}
if (size($eyeGeos))
	{
	$tempString=`duplicate -n tempEye $eyeGeos[0]`;
	$tempString2=`listRelatives -p $tempString[0]`;
	if ($tempString2[0]!="")
		$tempString=`parent -w $tempString[0]`;
	setAttr ($tempString[0]+".v") 1;
	select $tempString[0];
	CenterPivot;
	$pos=`xform -q -ws -piv $tempString[0]`;
	$bb=`xform -q -ws -bb $tempString[0]`;
	delete $tempString[0];
	createNode -n asFitPivotEye -p asFitPivots transform;
	xform -ws -t $pos[0] $pos[1] $pos[2] asFitPivotEye;
	addAttr -k 0 -ln radius -at double -dv (($bb[5]-$bb[2])/2.0) asFitPivotEye;

	if (`objExists asDuplicatedEye`)
		delete asDuplicatedEye;
	}

catchQuiet (`setAttr CombinedSkinLower_M.v 1`);

//lock handle attrs
$tempString=`listRelatives -ad -type transform asFitHandles`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`attributeExists "xyz" $tempString[$i]`)
		continue;
	asLockAttr $tempString[$i] 1 1 1 1;
	if (`getAttr -asString ($tempString[$i]+".xyz")`=="x")
		{
		setAttr -k 1 -l 0 ($tempString[$i]+".ty");
		setAttr -k 1 -l 0 ($tempString[$i]+".rx	");
		}
	if (`getAttr -asString ($tempString[$i]+".xyz")`=="y")
		{
		setAttr -k 1 -l 0 ($tempString[$i]+".tx");
		setAttr -k 1 -l 0 ($tempString[$i]+".ry");
		}
	}

delete asFitScanCurve asFitScanPolyProjectionCurves;
//asFitModeManualUpdate (autoOrient) to run with no constraints
if (`objExists closestSampler`) delete closestSampler;
asFitAutoPlaceFromScanCurves;
asFitAutoPlaceSetFat;
delete `listRelatives -c asFitConstraints`;
asFitModeManualUpdate;

//if ($modifier==4)
	asFitAutoPlaceFromScanCurves;//re-apply constraints

catchQuiet (`setAttr Root.v 1`);

asFitStraightPoleVector Leg;
asFitStraightPoleVector Arm;

asUpdateButtonEnables;

select -cl;
print ("// autoPlace completed in "+`timerX -startTime $startTime`+" seconds.\n");
}

global proc asFitAutoOrbit (float $camOrbitStep)
{
int $modifier=`getModifiers`;
if ($modifier!=4)
	return;
rotate -r 0 $camOrbitStep 0 asFitOrbitA;
float $tra[]=`xform -q -ws -t  asFitOrbitB`;
float $rot[]=`xform -q -ws -ro asFitOrbitB`;
xform -ws -t $tra[0] $tra[1] $tra[2] -ro $rot[0] $rot[1] $rot[2] persp;
}

global proc asFitAutoPlaceFromScanCurves ()
{
int $centerCurveNr;
float $bbMaxY=`getAttr AutoPlacing.bbMaxY`;
float $newScale,$width,$offset;
float $pos[],$posA[],$posB[],$posC[],$bbMin[],$bbMax[],$bb[],$posXs[],$posYs[],$posZs[];
string $projectedCenterCurve;
string $sel[]=`ls -sl`;
string $fingers[]={"Index","Middle","Ring","Pinky","Thumb"};
string $tempString[];
string $detectors[]={"Crotch","Root","ArmPit","Neck","Head","Ankle","Knee","Toes","ArmTip","Shoulder","Wrist","Elbow"}; 
for ($y=0;$y<size($fingers);$y++)
	{
	$detectors[size($detectors)]=$fingers[$y]+"Finger1";
	$detectors[size($detectors)]=$fingers[$y]+"Finger4";
	}

//Root
if (`objExists asFitPivotRoot` && `objExists Root`)
	{
	//Root to do a `asFitAutoPlaceHierarchy` first
	$posA=`xform -q -ws -t asFitPivotRoot`;
	$posB=`xform -q -ws -t Root`;
	if ($posB[1]==0)
		$newScale=1;//avoid divition by zero
	else
		$newScale=$posA[1]/$posB[1];
	$tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		$posXs[$i]=$pos[0];
		$posYs[$i]=$pos[1];
		$posZs[$i]=$pos[2];
		}
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		xform -ws -t ($posXs[$i]*$newScale) ($posYs[$i]*$newScale) ($posZs[$i]*$newScale) $tempString[$i];
		if (`attributeExists fat $tempString[$i]`)
			setAttr ($tempString[$i]+".fat") (`getAttr ($tempString[$i]+".fat")`*$newScale);
		}

	pointConstraint -skip x asFitPivotOffsetRoot Root;
	}

//Hip
if (`objExists asFitPivotHip` && `objExists Hip` && `objExists asFitPivotAnkle`)
	{
	$pos=`xform -q -ws -t asFitPivotHip`;
	$projectedCenterCurve=`asGetProjectedCurve asFitProjectionHip "center"`;
	$bbMin=`getAttr ($projectedCenterCurve+".boundingBoxMin")`;
	$bbMax=`getAttr ($projectedCenterCurve+".boundingBoxMax")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] Hip;
	pointConstraint asFitPivotOffsetHip Hip;
	}

//Knee
if (`objExists asFitPivotKnee` && `objExists Knee`)
	pointConstraint asFitPivotOffsetKnee Knee;

//Ankle
if (`objExists asFitPivotAnkle` && `objExists Ankle`)
	pointConstraint asFitPivotOffsetAnkle Ankle;

//Toes
if (`objExists asFitPivotToes` && `objExists Toes`)
	pointConstraint asFitPivotOffsetToes Toes;

//Toes
if (`objExists asFitPivotToes` && `objExists Toes`)
	pointConstraint asFitPivotOffsetToes Toes;

//Heel (Anchor)
if (`objExists asFitAnchorHeel` && `objExists Heel`)
	pointConstraint asFitAnchorHeel Heel;

//asFitAnchorFootSideOuter (Anchor)
if (`objExists asFitAnchorFootSideOuter` && `objExists FootSideOuter`)
	pointConstraint asFitAnchorFootSideOuter FootSideOuter;

//asFitAnchorFootSideInner (Anchor)
if (`objExists asFitAnchorFootSideInner` && `objExists FootSideInner`)
	pointConstraint asFitAnchorFootSideInner FootSideInner;

//asFitAnchorToesEnd (Anchor)
if (`objExists asFitAnchorToesEnd` && `objExists ToesEnd`)
	pointConstraint asFitAnchorToesEnd ToesEnd;

//Spine1
if (`objExists asFitPivotRoot` && `objExists asFitPivotSpine1` && `objExists Spine1`)
	pointConstraint -skip z asFitPivotOffsetSpine1 Spine1;

//Chest
if (`objExists asFitPivotRoot` && `objExists asFitPivotChest` && `objExists Chest`)
	pointConstraint -skip z asFitPivotOffsetChest Chest;

//Neck
if (`objExists asFitPivotNeck` && `objExists Neck`)
	pointConstraint -skip z -w 1.0 asFitPivotOffsetNeck Neck;

//Head
if (`objExists asFitPivotHead` && `objExists Head`)
	{
	delete `pointConstraint -skip z -w 1.0 asFitPivotOffsetHead Head`;
	$posA=`xform -q -ws -t asFitPivotOffsetHead`;
	$posB=`xform -q -ws -t asFitPivotOffsetNeck`;
	xform -ws -t 0 $posA[1] $posB[2] Head;
	pointConstraint -skip z -w 1.0 asFitPivotOffsetHead Head;
	
	if (`objExists HeadEnd`)
		xform -ws -t 0 $bbMaxY $posA[2] HeadEnd;
	if (`objExists Jaw`)
		xform -ws -t 0 ($posA[1]+(($bbMaxY-$posA[1])/5.0)) ($posA[2]+(`getAttr AutoPlacing.bbMaxY`/50.0)) Jaw;
	if (`objExists JawEnd`)
		setAttr JawEnd.tx (($bbMaxY-$posA[1])/3.0);
	}

//Eye
if (`objExists asFitPivotHead` && `objExists Eye`)
	if (`objExists asFitPivotEye`)
		{
		pointConstraint -w 1.0 asFitPivotEye Eye;
		if (`objExists EyeEnd`)
			setAttr EyeEnd.tx `getAttr asFitPivotEye.radius`;
		}
	else
		{
		$posA=`xform -q -ws -t asFitPivotHead`;
		$posB=`xform -q -ws -t asFitPivotNeck`;
		xform -ws -t (($bbMaxY-$posA[1])/-5.0) ($posA[1]+(($bbMaxY-$posA[1])/2.0)) ($posA[2]+(`getAttr AutoPlacing.bbMaxY`/15.0)) Eye;
		if (`objExists EyeEnd`)
			setAttr EyeEnd.tx (($bbMaxY-$posA[1])/10.0);
		}

//Scapula
if (`objExists asFitPivotOffsetShoulder` && `objExists Scapula`)
	{
	//Scapula as part of Shoulder
	if (`objExists asFitPivotOffsetScapula1`)
		delete asFitPivotOffsetScapula1;
	duplicate -n asFitPivotOffsetScapula1 asFitPivotOffsetShoulder;
	duplicate -n asFitPivotOffsetScapula2 asFitPivotOffsetShoulder;
	parent asFitPivotOffsetScapula2 asFitPivotOffsetScapula1;
	pointConstraint -skip x asFitPivotOffsetShoulder asFitPivotOffsetScapula1;
	pointConstraint -skip y -skip z -w 0.33 asFitPivotOffsetShoulder asFitPivotOffsetScapula2;
	pointConstraint -skip y -skip z -w 0.67 asFitPivots asFitPivotOffsetScapula2;

	pointConstraint -w 1.0 asFitPivotOffsetScapula2 Scapula;
	}

//Shoulder
if (`objExists asFitPivotShoulder` && `objExists Shoulder`)
	pointConstraint -w 1.0 asFitPivotOffsetShoulder Shoulder;

//Wrist
if (`objExists asFitPivotWrist` && `objExists Wrist`)
	pointConstraint -w 1.0 asFitPivotOffsetWrist Wrist;

//Elbow
if (`objExists asFitPivotElbow` && `objExists Elbow`)
	pointConstraint -w 1.0 asFitPivotOffsetElbow Elbow;

//Fingers
$offset=0;
if (`objExists asFitPivotIndexFinger1` && `objExists asFitPivotMiddleFinger1`)
	{
	$posA=`xform -q -ws -t asFitPivotIndexFinger1`;
	$posB=`xform -q -ws -t asFitPivotMiddleFinger1`;
	$offset=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`/2.0;
	}
for ($y=0;$y<size($fingers);$y++)
	{
	if (!`objExists ("asFitPivot"+$fingers[$y]+"Finger1")` || !`objExists ($fingers[$y]+"Finger1")`)
		continue;
	//offset
	if (`objExists ("asFitPivot"+$fingers[$y]+"Finger1OffsetA")`)
		delete ("asFitPivot"+$fingers[$y]+"Finger1OffsetA");
	createNode -n ("asFitPivot"+$fingers[$y]+"Finger1OffsetA") -p ("asFitPivot"+$fingers[$y]+"Finger1") transform;
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 Elbow ("asFitPivot"+$fingers[$y]+"Finger1OffsetA")`;
	createNode -n ("asFitPivot"+$fingers[$y]+"Finger1OffsetB") -p ("asFitPivot"+$fingers[$y]+"Finger1OffsetA") transform;
	if ($fingers[$y]!="Thumb")
		setAttr ("asFitPivot"+$fingers[$y]+"Finger1OffsetB.tx") $offset;
	pointConstraint -w 1.0 ("asFitPivot"+$fingers[$y]+"Finger1OffsetB") ($fingers[$y]+"Finger1");

	pointConstraint -w 0.60 ($fingers[$y]+"Finger1") ($fingers[$y]+"Finger2");
	pointConstraint -w 0.40 ("asFitPivot"+$fingers[$y]+"Finger4") ($fingers[$y]+"Finger2");
	pointConstraint -w 0.30 ($fingers[$y]+"Finger1") ($fingers[$y]+"Finger3");
	pointConstraint -w 0.70 ("asFitPivot"+$fingers[$y]+"Finger4") ($fingers[$y]+"Finger3");
	pointConstraint -w 1.0 ("asFitPivot"+$fingers[$y]+"Finger4") ($fingers[$y]+"Finger4");

	if (`objExists ("FingerCurve"+$fingers[$y])`)
		{
		for ($z=2;$z<5;$z++)
			{
			delete ($fingers[$y]+"Finger"+$z+"_pointConstraint1");
			delete `geometryConstraint ("FingerCurve"+$fingers[$y]) ($fingers[$y]+"Finger"+$z)`;
			}
		}
	//straighten last segment
	setAttr ($fingers[$y]+"Finger3.jo") -type float3 0 0 0;
	}


//Cup
if (`objExists asFitPivotPinkyFinger1` && `objExists asFitPivotWrist` && `objExists Cup`)
	{
	pointConstraint -w 0.1 asFitPivotPinkyFinger1 Cup;
	pointConstraint -w 0.9 asFitPivotWrist Cup;
	}

/*
//Thumb
if (`objExists asFitPivotThumbFinger1OffsetA`)
	delete asFitPivotThumbFinger1OffsetA;
createNode -n asFitPivotThumbFinger1OffsetA -p asFitPivotThumbFinger4 transform;
$bb=`xform -q -ws -bb asFitProjectionThumbFinger4`;
xform -ws -t $bb[0] $bb[1] $bb[5] asFitPivotThumbFinger1OffsetA;
pointConstraint -w 0.5 asFitPivotWrist ThumbFinger1;
pointConstraint -w 0.5 asFitPivotThumbFinger1OffsetA ThumbFinger1;

pointConstraint -w 0.25 asFitPivotWrist ThumbFinger2;
pointConstraint -w 0.75 asFitPivotThumbFinger4 ThumbFinger2;
pointConstraint -w 0.1 asFitPivotWrist ThumbFinger3;
pointConstraint -w 0.9 asFitPivotThumbFinger4 ThumbFinger3;

pointConstraint -w 1.0 asFitPivotThumbFinger1OffsetA ThumbFinger4;
*/

//reparent constraints
$tempString=`listRelatives -ad -type constraint FitSkeleton`;
if (size($tempString))
	parent $tempString asFitConstraints;

select $sel;
}

global proc asFitAutoPlaceSetFat ()
{
int $wasHidden;
float $fatFront,$fatWidth;
float $fingerWidth=`getAttr AutoPlacing.fingerWidth`;
float $pos[];
string $projectedCurve,$xyz;
string $tempString[],$fitJoints[];
string $fingers[]={"Index","Middle","Ring","Pinky","Thumb"};

if (!`objExists FitSkeleton`)
	return;

asEnsureAllFitJointAttrs;

for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists fat $fitJoints[$i]`)
		continue;
	$projectedCurve="";
	if (`objExists ("asFitProjection"+$fitJoints[$i])`)
		$projectedCurve="asFitProjection"+$fitJoints[$i];
	if ($projectedCurve=="")
		continue;
	if (`getAttr ($projectedCurve+".v")`==0)
		{
		$wasHidden=1;
		setAttr ($projectedCurve+".v") 1;
		refresh;
		}
	$bbMin=`getAttr ($projectedCurve+".boundingBoxMin")`;
	$bbMax=`getAttr ($projectedCurve+".boundingBoxMax")`;
	if ($wasHidden)
		setAttr ($projectedCurve+".v") 0;
	$xyz=`getAttr -asString ("asFitHandle"+$fitJoints[$i]+".xyz")`;
	if ($xyz=="x") {$fatFront=(($bbMax[2]-$bbMin[2])/2.0);$fatWidth=(($bbMax[0]-$bbMin[0])/2.0);}
	if ($xyz=="y") {$fatFront=(($bbMax[2]-$bbMin[2])/2.0);$fatWidth=(($bbMax[1]-$bbMin[1])/2.0);}
	//special cases
	if ($fitJoints[$i]=="Toes")
		{
		$pos=`xform -q -ws -t Toes`;
		$fatFront=$pos[1]/2.0;
		}
	if ($fitJoints[$i]=="Shoulder" && `objExists Scapula`) asFitAutoPlaceSetFatAttrs Scapula 1 $fatFront $fatWidth;
	if ($fitJoints[$i]=="Toes" && `objExists ToesEnd`) asFitAutoPlaceSetFatAttrs ToesEnd 1 $fatFront $fatWidth;
	if ($fitJoints[$i]=="Head" && `objExists HeadEnd`) asFitAutoPlaceSetFatAttrs HeadEnd 1 $fatFront $fatWidth;
	if ($fitJoints[$i]=="Head" && `objExists Jaw`) asFitAutoPlaceSetFatAttrs Jaw 1 ($fatFront/10.0) ($fatWidth/2.0);
	if ($fitJoints[$i]=="Head" && `objExists JawEnd`) asFitAutoPlaceSetFatAttrs JawEnd 1 ($fatFront/10.0) ($fatWidth/2.0);

	setAttr ($fitJoints[$i]+".fat") 1;
	setAttr ($fitJoints[$i]+".fatFront") $fatFront;
	setAttr ($fitJoints[$i]+".fatWidth") $fatWidth;
	}

for ($y=0;$y<size($fingers);$y++)
	for ($i=1;$i<5;$i++)
		if (`objExists ($fingers[$y]+"Finger"+$i)`)
			{
			setAttr ($fingers[$y]+"Finger"+$i+".fat") 1;
			setAttr ($fingers[$y]+"Finger"+$i+".fatFront") ($fingerWidth/2.0);
			setAttr ($fingers[$y]+"Finger"+$i+".fatWidth") ($fingerWidth/2.0);
			}
}

global proc asFitAutoPlaceSetFatAttrs (string $fitJoint, float $fat, float $fatFront, float $fatWidth)
{
setAttr ($fitJoint+".fat") $fat;
setAttr ($fitJoint+".fatFront") $fatFront;
setAttr ($fitJoint+".fatWidth") $fatWidth;
}

global proc asFitAutoPlaceLoft (string $zxy)
{
int $maxCvNr;
float $bbMinX=`getAttr AutoPlacing.bbMinX`;
float $pos[],$fitPivotOrientRot[],$offsets[];
string $skin;
string $reps[]={"Toes","Ankle","Knee","Hip","Root","Chest","Spine1","Neck","Head"};
string $tempString[],$tempString2[];

if ($zxy=="zLoft") $reps={"Toes","Ankle","Knee","Hip","Root","Chest","Spine1","Neck","Head"};
if ($zxy=="yLoft") $reps={"Wrist","Elbow","Shoulder"};

//trim zLoft to skip fingers and chest
if ($zxy=="yLoft")
	{
	delete asFitProjectionLoftCurveyLofta;
	for ($i=0;$i<51;$i++)
		{
		$pos=`getAttr ("asFitProjectionLoftCurveyLoft"+$i+".t")`;
		if (($pos[0]<`getAttr asFitHandleWrist.tx`) || ($pos[0]>(`getAttr asFitHandleShoulder.tx`*1.5)))
			delete ("asFitProjectionLoftCurveyLoft"+$i);
		}
	}

select `listRelatives -c ("asFitLoftCurves"+$zxy)`;
loft -n ("asFitLoftSurface"+$zxy) -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true;
//extend zLoft to fingers and chest
if ($zxy=="yLoft")
	{
	$maxCvNr=`getAttr asFitLoftSurfaceyLoft.spansV`+2;
	$pos=`xform -q -ws -t asFitLoftSurfaceyLoft.cv[0][0]`;
	move -r -os -wd ($bbMinX-$pos[0]) 0 0 asFitLoftSurfaceyLoft.cv[0:7][0:1];
	$pos=`xform -q -ws -t asFitLoftSurfaceyLoft.cv[0][$maxCvNr]`;
	move -r -os -wd ($pos[0]*-1) 0 0 asFitLoftSurfaceyLoft.cv[0:7][($maxCvNr-1):$maxCvNr];
	}
parent ("asFitLoftSurface"+$zxy) asFitCombinedLofts;
delete ("asFitLoftCurves"+$zxy);
setAttr ("asFitLoftSurface"+$zxy+".v") 0;
nurbsToPoly -n ("asFitLoft"+$zxy) -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ("asFitLoftSurface"+$zxy);
parent ("asFitLoft"+$zxy) asFitCombinedLofts;
setAttr ("asFitLoft"+$zxy+".v") 0;

duplicate -n ("asFitLoft"+$zxy+"_R") ("asFitLoft"+$zxy);
select ("asFitLoft"+$zxy+"_R");
polySelectConstraint -m 3 -t 1 -d 3 -db 0 999 -da 1 0 0 -dp 999 0 0;
$tempString=`ls -sl -fl`;
polySelectConstraint -m 0;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	xform -ws -t 0 $pos[1] $pos[2] $tempString[$i];
	}

delete `ls ("asFitProjectionLoft"+$zxy+"*")` `ls ("asFitScanCurveLoft"+$zxy+"*")`;
delete `ls ("asFitHandleLoft"+$zxy+"*")` `ls ("asFitPivotLoft"+$zxy+"*")`;
delete ("asFitLoftSurface"+$zxy);

for ($i=0;$i<size($reps);$i++)
	{
	if (!`objExists ("asFitProjection"+$reps[$i])`)
		continue;
	$skin="asFitLoft"+$zxy;
	if ($reps[$i]=="Hip" || $reps[$i]=="Knee" || $reps[$i]=="Ankle" || $reps[$i]=="Toes")
		$skin="asFitLoft"+$zxy+"_R";

	asAlign asFitScanCurve ("asFitScanCurve"+$reps[$i]) 1 1 0 0;

	//keep info
	$offsets={0,0,0};
	if (`attributeExists "offsetX" ("asFitHandle"+$reps[$i])`)
		{
		$offsets[0]=`getAttr ("asFitHandle"+$reps[$i]+".offsetX")`;
		$offsets[1]=`getAttr ("asFitHandle"+$reps[$i]+".offsetY")`;
		$offsets[2]=`getAttr ("asFitHandle"+$reps[$i]+".offsetZ")`;
		}
	$fitPivotOrientRot=`getAttr ("asFitPivotOrient"+$reps[$i]+".r")`;

	delete ("asFitHandle"+$reps[$i]) ("asFitPivot"+$reps[$i]);
	rename ("asFitScanCurve"+$reps[$i]) ("asFitScanCurve"+$reps[$i]+"Contour");
	rename ("asFitProjection"+$reps[$i]) ("asFitProjection"+$reps[$i]+"Contour");
	$tempString=`listRelatives -c ("asFitProjection"+$reps[$i]+"Contour")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		tokenize $tempString[$y] "_" $tempString2;
		rename $tempString[$y] ($tempString2[0]+"Contour_"+$tempString2[1]);
		}
		

	asSaveProjection $reps[$i] $zxy $skin "0" 1;

	setAttr ("asFitProjection"+$reps[$i]+".v") 0;
	parentConstraint -mo ("asFitHandle"+$reps[$i]) ("asFitScanCurve"+$reps[$i]+"Contour");

	//restore info
	setAttr ("asFitHandle"+$reps[$i]+".offsetX") $offsets[0];
	setAttr ("asFitHandle"+$reps[$i]+".offsetY") $offsets[1];
	setAttr ("asFitHandle"+$reps[$i]+".offsetZ") $offsets[2];
	setAttr ("asFitPivotOrient"+$reps[$i]+".r") $fitPivotOrientRot[0] $fitPivotOrientRot[1] $fitPivotOrientRot[2];

//	parent ("asFitHandle"+$reps[$i]+"OnLoft") ("asFitHandle"+$reps[$i]);
	}

//Head pos update, offset to match Z pos of Neck (assuing straight neck)
if ($zxy=="zLoft" && `objExists asFitPivotNeck` && `objExists asFitPivotHead`)
	{
	$posA=`xform -q -ws -t asFitPivotNeck`;
	$posB=`xform -q -ws -t asFitPivotHead`;
	setAttr asFitHandleHead.offsetZ ($posA[2]-$posB[2]);
	}
}


global proc asFitDeleteGuides ()
{
float $rz;
float $pos[];
string $curveCmd;
string $skin=`textField -q -tx asBodySkinTextField`;
string $all=`textField -q -tx asBodyAllTextField`;
string $sel[]=`ls -sl`;
string $skinObjects[]=`stringToStringArray $skin " "`;
string $allObjects[]=`stringToStringArray $all " "`;
string $skinAndAllObjects[]=`stringArrayCatenate $skinObjects $allObjects`;
string $fingers[]={"Index","Middle","Ring","Pinky"};

if (!`objExists AutoPlacing`)
	return;

//un-straighten fingers
if (`objExists straightenBS`)
	{
	for ($y=0;$y<size($fingers);$y++)
		{
		$curveCmd="curve -d 1 -n FingerSimpleCurve"+$fingers[$y];
		for ($i=1;$i<5;$i++)
			{
			if (!`objExists ($fingers[$y]+"Finger"+$i)`)
				continue;
			$pos=`xform -q -ws -t ($fingers[$y]+"Finger"+$i)`;
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			if (`objExists ($fingers[$y]+"Finger"+$i+"_pointConstraint1")`)
				delete ($fingers[$y]+"Finger"+$i+"_pointConstraint1");
			}
		eval ($curveCmd);
		parent ("FingerSimpleCurve"+$fingers[$y]) asFitPivotsFingers;
		select ("FingerSimpleCurve"+$fingers[$y]) CombinedSkinUpper_M;
		$tempString=`doWrapArgList "7" { "1","0","0.1", "1", "0", "1", "1", "0" }`;
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		setAttr straightenBS.fingerStraight 0;
		for ($i=1;$i<5;$i++)
			{
			if (!`objExists ($fingers[$y]+"Finger"+$i)`)
				continue;
			$pos=`xform -q -ws -t ("FingerSimpleCurve"+$fingers[$y]+".cv["+($i-1)+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($fingers[$y]+"Finger"+$i);
			}
		setAttr straightenBS.fingerStraight 1;
		}
	asFitModeUpdateJoints Wrist 1;
	}

if (`objExists asFitShoulderStraight`)
	{
	$rz=`getAttr asFitShoulderStraight.rz`;
	parent -w asFitShoulderStraight;
	}
delete AutoPlacing;
for ($i=0;$i<size($skinAndAllObjects);$i++)
	catchQuiet (`setAttr ($skinAndAllObjects[$i]+".v") 1`);
if (`objExists asFitShoulderStraight` && `objExists Shoulder`)
		{
		parentConstraint -mo asFitShoulderStraight Shoulder;
		setAttr asFitShoulderStraight.r -type float3 0 0 0;
		delete Shoulder_parentConstraint1;
		if (`objExists asFitElbowStraight`)
			{
			parentConstraint -mo asFitElbowStraight Elbow;
			setAttr asFitElbowStraight.r -type float3 0 0 0;
			delete Elbow_parentConstraint1;
			}
		delete asFitShoulderStraight;
		makeIdentity -a 1 -t 0 -r 1 -s 0 Shoulder;
		}
if (`objExists FitSkeletonVisualizers`)
	delete FitSkeletonVisualizers;
catchQuiet (`setAttr Root.v 1`);
asUpdateButtonEnables;
catchQuiet (`select $sel`);
}

global proc asFitAnchor (string $joint)
{
float $bbMaxY=`getAttr AutoPlacing.bbMaxY`;

spaceLocator -n ("asFitAnchor"+$joint);
parent ("asFitAnchor"+$joint) asFitAnchors;
setAttr ("asFitAnchor"+$joint+"Shape.overrideEnabled") 1;
setAttr ("asFitAnchor"+$joint+"Shape.overrideColor") 14;
setAttr ("asFitAnchor"+$joint+"Shape.localScale") -type float3 ($bbMaxY/100.0) ($bbMaxY/100.0) ($bbMaxY/100.0);
//$pos=`xform -q -ws -t $joint`;
//xform -ws -t $pos[0] $pos[1] $pos[2] ("asFitAnchor"+$joint);
//pointConstraint ("asFitAnchor"+$joint) $joint;
}

global proc string asGetProjectedCurve (string $projectedCurvesGrp, string $find)
{
int $span,$centerCurveNr,$rightCurveNr,$frontCurveNr,$widestCurveNr,$findInt,$wasHidden;
float $bbCenterX,$bbCenterXABS,$bbCenterXMin,$bbCenterXABSMin,$dist,$minDist;
float $bbCenterZ,$bbCenterZMax,$width,$widthMax,$centerCurveWidth;
float $bbMin[],$bbMax[],$posA[],$posB[];
string $projectedCurve,$closestTo;
string $widthAxis="x";
string $projectedCurves[];

//guesstimating $widthAxis
if (`getAttr ($projectedCurvesGrp+".v")`==0)
	{
	setAttr ($projectedCurvesGrp+".v") 1;
	$wasHidden=1;
	}
$bbMin=`getAttr ($projectedCurvesGrp+".boundingBoxMin")`;
$bbMax=`getAttr ($projectedCurvesGrp+".boundingBoxMax")`;
if ($wasHidden)
	setAttr ($projectedCurvesGrp+".v") 0;
if (($bbMax[2]-$bbMin[2])>($bbMax[0]-$bbMin[0])) $widthAxis="z";
//print ("$widthAxis="+$widthAxis+" "+$projectedCurvesGrp+"\n");

$projectedCurves=`listRelatives -c -type transform $projectedCurvesGrp`;
$bbCenterXMin=$bbCenterXABSMin=999;
$bbCenterZMax=-999;
for ($i=0;$i<size($projectedCurves);$i++)
	{
	$spans=`getAttr ($projectedCurves[$i]+".spans")`;
	if ($spans==0)
		continue;
	$bbMin=`getAttr ($projectedCurves[$i]+".boundingBoxMin")`;
	$bbMax=`getAttr ($projectedCurves[$i]+".boundingBoxMax")`;
	$bbCenterX=($bbMin[0]+$bbMax[0])/2.0;
	$bbCenterZ=($bbMin[2]+$bbMax[2])/2.0;
	$bbCenterXABS=abs($bbCenterX);
	if ($widthAxis=="x") $width=$bbMax[0]-$bbMin[0];
	if ($widthAxis=="y") $width=$bbMax[1]-$bbMin[1];
	if ($widthAxis=="z") $width=$bbMax[2]-$bbMin[2];

	if ($bbCenterXABS<$bbCenterXABSMin && $width>$centerCurveWidth)
		{
		$bbCenterXABSMin=$bbCenterXABS;
		$centerCurveNr=$i;
		$centerCurveWidth=$width;
		}
	if ($bbCenterX<$bbCenterXMin)
		{
		$bbCenterXMin=$bbCenterX;
		$rightCurveNr=$i;
		}
	if ($bbCenterZ>$bbCenterZMax)
		{
		$bbCenterZMax=$bbCenterZ;
		$frontCurveNr=$i;
		}
	if ($width>$widthMax)
		{
		$widthMax=$width;
		$widestCurveNr=$i;
		}
	}

if (`gmatch $find "[0-9]"`)
	{
	$findInt=$find;
	$projectedCurve=$projectedCurves[$findInt];
	}
if ($find=="center") $projectedCurve=$projectedCurves[$centerCurveNr];
if ($find=="right")  $projectedCurve=$projectedCurves[$rightCurveNr];
if ($find=="front")  $projectedCurve=$projectedCurves[$frontCurveNr];
if ($find=="widest") $projectedCurve=$projectedCurves[$widestCurveNr];
if (`gmatch $find "closestTo*"`)
	{
	$closestTo=`substitute "closestTo" $find""`;
//	$closestToPivot=`substitute "asFitProjection" $closestTo "asFitPivot"`;
	$posA=`xform -q -ws -t $closestTo`;
	$minDist=999;
	for ($i=0;$i<size($projectedCurves);$i++)
		{
		$bbMin=`getAttr ($projectedCurves[$i]+".boundingBoxMin")`;
		$bbMax=`getAttr ($projectedCurves[$i]+".boundingBoxMax")`;
		$posB[0]=($bbMin[0]+$bbMax[0])/2.0;$posB[1]=($bbMin[1]+$bbMax[1])/2.0;$posB[2]=($bbMin[2]+$bbMax[2])/2.0;
		$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($dist<$minDist)
			{
			$minDist=$dist;
			$projectedCurve=$projectedCurves[$i];
			}
		}
	}

return $projectedCurve;
}

global proc float asGetProjectedCurveWidthMin (string $projectedCurve)
{
float $width;
float $pos[],$bbMin[],$bbMax[];

if (`objExists tempWidthMessure`) delete tempWidthMessure;
createNode -n tempWidthMessure transform;
createNode -n tempWidthMessure2 -p tempWidthMessure transform;
$bbMin=`getAttr ($projectedCurve+".boundingBoxMin")`;
$bbMax=`getAttr ($projectedCurve+".boundingBoxMax")`;
xform -ws -t (($bbMin[0]+$bbMax[0])/2.0) (($bbMin[1]+$bbMax[1])/2.0) (($bbMin[2]+$bbMax[2])/2.0) tempWidthMessure;
geometryConstraint -weight 1 $projectedCurve tempWidthMessure2;
$pos=`getAttr tempWidthMessure2.t`;
$width=`mag <<$pos[0],$pos[1],$pos[2]>>`*2;

if (`objExists tempWidthMessure`) delete tempWidthMessure;
return $width;
}

global proc asUpdateProjection (string $name, string $zxy, string $skin, string $find, int $keepHistory)
{
//for when we need to re-do a `asSaveProjection`, for e.g. newly existing $skin such as "CombinedSkinUpper_R"
float $pos[]=`getAttr asFitScanCurve.t`;
float $rot[]=`getAttr asFitScanCurve.r`;
float $pos2[]=`getAttr ("asFitScanCurve"+$name+".t")`;
float $rot2[]=`getAttr ("asFitScanCurve"+$name+".r")`;

setAttr asFitScanCurve.t -type float3 $pos2[0] $pos2[1] $pos2[2];
setAttr asFitScanCurve.r -type float3 $rot2[0] $rot2[1] $rot2[2];

delete ("asFitScanCurve"+$name) ("asFitHandle"+$name) ("asFitProjection"+$name) ("asFitPivot"+$name);

asSaveProjection $name $zxy $skin $find $keepHistory;

setAttr asFitScanCurve.t -type float3 $pos[0] $pos[1] $pos[2];
setAttr asFitScanCurve.r -type float3 $rot[0] $rot[1] $rot[2];
}

global proc asSaveProjection (string $name, string $zxy, string $skin, string $find, int $keepHistory)
{
int $widthAxisNr;
float $bbMinZ=`getAttr AutoPlacing.bbMinZ`;
float $bbMaxZ=`getAttr AutoPlacing.bbMaxZ`;
float $bbMinX=`getAttr AutoPlacing.bbMinX`;
float $xDir,$yDir,$zDir,$width;
float $bbMin[],$bbMax[],$pos[];
string $projectedCurve;
string $tempString[];

if (`gmatch $zxy "z*"`)
	{$xDir=0;$yDir=0;$zDir=1;}
if ($zxy=="x")
	{$xDir=1;$yDir=0;$zDir=0;}
if (`gmatch $zxy "y*"`)
	{$xDir=0;$yDir=1;$zDir=0;}

duplicate -n ("asFitScanCurve"+$name) asFitScanCurve;

//Override front-projections to side-projections (z to x)
if (`gmatch $zxy "z*"`)
	{
	$xDir=1;$yDir=0;$zDir=0;
	$pos=`xform -q -ws -t asFitScanCurve`;
	setAttr ("asFitScanCurve"+$name+".t") -type float3 $bbMinX $pos[1] (($bbMinZ+$bbMaxZ)/2.0);
	setAttr ("asFitScanCurve"+$name+".ry") -90;
	$zxy="x";
	}

setAttr ("asFitScanCurve"+$name+".v") 0;
setAttr ("asFitScanCurve"+$name+"Shape.dispGeometry") 1;

$tempString=`polyProjectCurve -ch true -direction $xDir $yDir $zDir -pointsOnEdges 0 -curveSamples 50 -automatic 1 ("asFitScanCurve"+$name) $skin`;
rename $tempString[0] ("asFitProjection"+$name);
rename $tempString[1] ("polyProjectCurve"+$name);
parent ("asFitProjection"+$name) asFitProjections;

$pos=`xform -q -ws -t ("asFitScanCurve"+$name)`;
$rot=`getAttr ("asFitScanCurve"+$name+".r")`;
$tempString[0]=`curve -d 1 -p 0 0 0 -p 0 0 0 -k 0 -k 1`; 
rename $tempString[0] ("asFitHandle"+$name);
parent ("asFitHandle"+$name) asFitHandles;
setAttr ("asFitHandle"+$name+".overrideEnabled") 1;
setAttr ("asFitHandle"+$name+".overrideColor") 14;
addAttr -k 0 -ln "xyz" -at "enum" -en "x:y:z:" ("asFitHandle"+$name);
addAttr -k 1 -ln offsetX -at double ("asFitHandle"+$name);
addAttr -k 1 -ln offsetY -at double ("asFitHandle"+$name);
addAttr -k 1 -ln offsetZ -at double ("asFitHandle"+$name);
if (`gmatch $zxy "z*"`)
	{
	xform -ws -t $pos[0] $pos[1] 0 ("asFitHandle"+$name);
	xform -ws -piv $pos[0] $pos[1] $pos[2] ("asFitHandle"+$name);
	setAttr ("asFitHandle"+$name+".xyz") 2;
	}
if ($zxy=="x")
	{
	xform -ws -t 0 $pos[1] $pos[2] ("asFitHandle"+$name);
	setAttr ("asFitHandle"+$name+".controlPoints[1].xValue") `getAttr ("asFitScanCurve"+$name+".tx")`;
	xform -piv `getAttr ("asFitScanCurve"+$name+".tx")` 0 0 ("asFitHandle"+$name);
	setAttr ("asFitHandle"+$name+".xyz") 0;
	}
if (`gmatch $zxy "y*"`)
	{
	xform -ws -t $pos[0] 0 0 ("asFitHandle"+$name);
	setAttr ("asFitHandle"+$name+".controlPoints[1].yValue") `getAttr ("asFitScanCurve"+$name+".ty")`;
	xform -ws -piv $pos[0] $pos[1] 0 ("asFitHandle"+$name);
	setAttr ("asFitHandle"+$name+".overrideColor") 13;
	setAttr ("asFitHandle"+$name+".xyz") 1;
	}

parentConstraint -mo ("asFitHandle"+$name) ("asFitScanCurve"+$name);

setAttr ("asFitProjection"+$name+".overrideEnabled") 1;
setAttr ("asFitProjection"+$name+".overrideColor") 17;

$tempString=`listRelatives -c -type transform ("asFitProjection"+$name)`;
for ($i=0;$i<size($tempString);$i++)
	{
	rename $tempString[$i] ("asFitProjection"+$name+"_"+$i);
	asLockAttr ("asFitProjection"+$name+"_"+$i) 1 1 1 0;
	}

$projectedCurve=`asGetProjectedCurve ("asFitProjection"+$name) $find`;

createNode -n ("asFitPivot"+$name) -p asFitPivots transform;
createNode -n ("asFitPivotOrient"+$name) -p ("asFitPivot"+$name) transform;
createNode -n ("asFitPivotOffset"+$name) -p ("asFitPivotOrient"+$name) transform;
connectAttr ("asFitHandle"+$name+".r") ("asFitPivot"+$name+".r");
connectAttr ("asFitHandle"+$name+".offsetX") ("asFitPivotOffset"+$name+".tx");
connectAttr ("asFitHandle"+$name+".offsetY") ("asFitPivotOffset"+$name+".ty");
connectAttr ("asFitHandle"+$name+".offsetZ") ("asFitPivotOffset"+$name+".tz");

createNode -n ("asFitPivot"+$name+"PMA1") plusMinusAverage;
setAttr ("asFitPivot"+$name+"PMA1.operation") 3;
connectAttr ($projectedCurve+".boundingBoxMin") ("asFitPivot"+$name+"PMA1.input3D[0]");
connectAttr ($projectedCurve+".boundingBoxMax") ("asFitPivot"+$name+"PMA1.input3D[1]");
connectAttr ("asFitPivot"+$name+"PMA1.output3D") ("asFitPivot"+$name+".t");

//connect Pivot
if (`gmatch $zxy "z*"` || $zxy=="x")
	connectAttr -f ("asFitScanCurve"+$name+".ty") ("asFitPivot"+$name+".ty");//keeps ty from dropping to zero upon projection error

//connect Handle
if ($zxy=="x")
	connectAttr  ($projectedCurve+".boundingBoxMinX") ("asFitHandle"+$name+".controlPoints[0].xValue");
if (`gmatch $zxy "z*"`)
	connectAttr  ($projectedCurve+".boundingBoxMaxZ") ("asFitHandle"+$name+".controlPoints[0].zValue");
if (`gmatch $zxy "y*"`)
	connectAttr  ($projectedCurve+".boundingBoxMaxY") ("asFitHandle"+$name+".controlPoints[0].yValue");

if (!$keepHistory)
	{
	setAttr ("asFitProjection"+$name+".v") 0;
	setAttr ("asFitHandle"+$name+".v") 0;
	}
}

global proc asFitStraightPoleVector (string $limb)
{
int $flipped;
int $useHandles=`objExists asFitHandleHip`;
float $lenght1,$lenght2,$lenghtRatio,$stepValue,$maxY;
float $pos[],$pos2[];
string $startJoint="Hip";
string $middleJoint="Knee";
string $endJoint="Ankle";
if ($limb=="Arm")
	{
	$startJoint="Shoulder";
	$middleJoint="Elbow";
	$endJoint="Wrist";
	}
string $reqObjs[]={$startJoint,$middleJoint,$endJoint};
string $sel[]=`ls -sl`;
string $tempString[];

for ($i=0;$i<size($reqObjs);$i++)
	if (!`objExists $reqObjs[$i]`)
		{
		warning ("Required object for straightening:"+$reqObjs[$i]+" not found, skipping.");
		return;
		}
//		error ("Required object:"+$reqObjs[$i]+" not found");

$tempString=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[1]>$maxY)
		$maxY=$pos[1];
	}

if (`objExists tempXforms`) delete tempXform;
createNode -n tempXforms transform;
for ($i=1;$i<5;$i++)
	{
	if (`objExists ("tempXform"+$i)`)
		delete ("tempXform"+$i);
	createNode -n tempXform1 -p tempXforms transform;
	}
parent tempXform4 tempXform1;

asAlign tempXform1 $endJoint 1 0 0 0;
asAlign tempXform2 $middleJoint 1 0 0 0;
asAlign tempXform3 $middleJoint 1 0 0 0;
move -r -ls -wd 0 0 ($maxY/10.0) tempXform3;
aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject tempXform3 tempXform2 tempXform1;
delete `pointConstraint $startJoint tempXform4`;
if ($limb=="Arm")
	setAttr tempXform4.ty ($maxY/100.0);
if ($limb=="Leg")
	setAttr tempXform4.ty ($maxY/-100.0);
setAttr tempXform4.tz 0;
$pos=`xform -q -ws -t tempXform4`;
$pos2=`xform -q -ws -t $startJoint`;
if ($useHandles)
	{
	if ($limb=="Leg")
		setAttr ("asFitHandle"+$startJoint+".offsetX") (($pos[0]-$pos2[0])+`getAttr ("asFitHandle"+$startJoint+".offsetX")`);
	if ($limb=="Arm")
		setAttr ("asFitHandle"+$startJoint+".offsetY") (($pos[1]-$pos2[1])+`getAttr ("asFitHandle"+$startJoint+".offsetY")`);
	if (($limb=="Arm" && $pos[2]>$pos2[2]) || ($limb=="Leg" && $pos[2]<$pos2[2]))
		setAttr ("asFitHandle"+$startJoint+".offsetZ") (($pos[2]-$pos2[2])+`getAttr ("asFitHandle"+$startJoint+".offsetZ")`);
	print ("// Straightened "+$limb+" by applying Offset values to asFitHandle"+$startJoint+"\n");
	}
else
	{
	move -a -pcp $pos[0] $pos[1] $pos[2] $startJoint;
	print ("// Straightened "+$limb+" by moving "+$startJoint+"\n");
	}

delete tempXforms;
select $sel;
}

global proc asPolyGrowPastShell ()
{
float $bbMin[],$bbMax[];
float $bbMinX;
float $width;
string $obj;
string $sel[]=`ls -sl`;
string $tempString[],$additionalSelection[];

$tempString=`ls -sl -o`;
$tempString=`listRelatives -p $tempString[0]`;
$obj=$tempString[0];
duplicate -n tempPolyGrowPastShell1 $obj;
duplicate -n tempPolyGrowPastShell2 $obj;
select `asobjSetCast "" $sel tempPolyGrowPastShell1`;
ConvertSelectionToFaces;
delete;
select `asobjSetCast "" $sel tempPolyGrowPastShell2`;
ConvertSelectionToFaces;
asInvertSelection;
delete;
select tempPolyGrowPastShell1 tempPolyGrowPastShell2;
$tempString=`doWrapArgList "7" { "1","0","0.001", "2", "1", "0", "1", "0" }`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
rename $tempString[0] tempPolyGrowPastShellWrap;
$bbMin=`getAttr tempPolyGrowPastShell1.boundingBoxMin`;
$bbMax=`getAttr tempPolyGrowPastShell1.boundingBoxMax`;
$width=$bbMax[0]-$bbMin[0];
move -r ($width*-2) 0 0 tempPolyGrowPastShell2;
setAttr tempPolyGrowPastShellWrap.maxDistance $width;

for ($i=0;$i<10;$i++)
	{
//print ("$i="+$i+"  "+`getAttr tempPolyGrowPastShellWrap.maxDistance`+"\n");
	setAttr tempPolyGrowPastShellWrap.maxDistance (`getAttr tempPolyGrowPastShellWrap.maxDistance`/10.0);
	$bbMinX=`getAttr tempPolyGrowPastShell1.boundingBoxMinX`;
	if ($bbMin[0]<=$bbMinX)
		{
		for ($y=0;$y<100;$y++)
			{
//print ("$y="+$y+"  "+`getAttr tempPolyGrowPastShellWrap.maxDistance`+"\n");
			setAttr tempPolyGrowPastShellWrap.maxDistance (`getAttr tempPolyGrowPastShellWrap.maxDistance`*1.05);
			$bbMinX=`getAttr tempPolyGrowPastShell1.boundingBoxMinX`;
			if ($bbMin[0]>$bbMinX)
				{
//				setAttr tempPolyGrowPastShellWrap.maxDistance (`getAttr tempPolyGrowPastShellWrap.maxDistance`/1.05);
				select tempPolyGrowPastShell1;
				polySelectConstraint -m 3 -t 1 -d 3 -db 0 999 -da 1 0 0 -dp (999+$bbMin[0]) 0 0;
				$tempString=`ls -sl`;
				polySelectConstraint -m 0;
				select $tempString;
				asInvertSelection;
				$tempString=`ls -sl`; 
				$additionalSelection=`asobjSetCast "" $tempString $obj`;
				break;
				}
			}
		break;
		}
	}
delete tempPolyGrowPastShell1 tempPolyGrowPastShell2 tempPolyGrowPastShellWrap;
select $sel;
if ($additionalSelection[0]=="")
	print ("asPolyGrowPastShell failed\n");
else
	select -add $additionalSelection;
}

global proc asOpenDemoFile ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeletonFiles/exampleFiles/downloads/";
string $exampleFolder=`optionMenu -q -v asDemoOptionMenu`;
string $exampleFile=$exampleFoldersDir+$exampleFolder+"/"+$exampleFolder+".mb";
string $tempString[];

print ("// Opening:\""+$exampleFile+"\"\n");
if (`file -q -ex $exampleFile`)
	{
	if (`saveChanges ""`)
		file -f -o $exampleFile;
	}
else
	warning ("Not Found:"+$exampleFile);
}

global proc asFitChangeLimbType ()
{
string $limbType=`optionMenu -q -v asLimbType`;
if ($limbType=="Spine" || $limbType=="Neck" || $limbType=="Tail")
	checkBox -e -v 1 asLimbMiddle;
else
	checkBox -e -v 0 asLimbMiddle;
}

global proc asFitTglRLA ()
{
if (!`objExists Visualizers`)
	return;
string $tempString[];
string $visualizers[]=`listRelatives -ad -type transform Visualizers`;
int $onOff,$setOnOff;
for ($i=0;$i<size($visualizers);$i++)
	{
	$tempString=`listRelatives -s $visualizers[$i]`;
	if ($tempString[0]!="" || !`gmatch $visualizers[$i] "*Aim"`)
		continue;
	if (!$setOnOff)
		{
		$onOff=!`getAttr ($visualizers[$i]+".displayLocalAxis")`;
		$setOnOff=1;
		}
	setAttr ($visualizers[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asJointsVisibility (int $onOff)
{
string $tempString[];

if (`attributeExists jointVis Main`)
	evalEcho ("setAttr Main.jointVis "+$onOff+";");

if (`objExists root`)
	catchQuiet (`setAttr root.v $onOff`);

//backwards compatability, old rigs might have FitJoints .drawStyle `stuck` at 2 (None)
if (`objExists FitSkeleton` && $onOff)
	{
	$tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".drawStyle")`==2)
			setAttr ($tempString[$i]+".drawStyle") 0;
	}
}

global proc asDisplayRigRLA (int $onOff)
{
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".displayLocalAxis") $onOff;
}

global proc asSetIsHistoricallyInteresting (string $controlSet)
{
string $controlSetMembers[]=`sets -q $controlSet`;
string $historyNodes[];
string $allSet="AllSet";
if ($controlSet=="FaceControlSet")
	$allSet="FaceAllSet";

for ($i=0;$i<size($controlSetMembers);$i++)
	{
	//history
	$historyNodes=`listHistory -future 0 -leaf 0 -il 1 -pdo 1 $controlSetMembers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		{
		if (!`sets -im $allSet $historyNodes[$y]`)
			continue;
		if (`getAttr ($historyNodes[$y]+".isHistoricallyInteresting")`)
			{
			setAttr ($historyNodes[$y]+".isHistoricallyInteresting") 0;
			}
		}
	//future
	$historyNodes=`listHistory -future 1 -leaf 0 -il 1 -pdo 1 $controlSetMembers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		{
		if (!`sets -im $allSet $historyNodes[$y]`)
			continue;
		if (`getAttr ($historyNodes[$y]+".isHistoricallyInteresting")`)
			{
			setAttr ($historyNodes[$y]+".isHistoricallyInteresting") 0;
			}
		}
	//shapes
	$historyNodes=`listRelatives -s $controlSetMembers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		{
		if (!`sets -im $allSet $historyNodes[$y]`)
			continue;
		if (`getAttr ($historyNodes[$y]+".isHistoricallyInteresting")`)
			{
			setAttr ($historyNodes[$y]+".isHistoricallyInteresting") 0;
			}
		}
	}
}

global proc asCreateFitSkeleton ()
{
if (`objExists FitSkeleton`)
	delete FitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FitSkeleton;
setAttr FitSkeletonShape.overrideEnabled 1;
setAttr FitSkeletonShape.overrideColor 29;
scale -r -p 0 0 0 2 2 2 FitSkeleton.cv[0:7];
setAttr -k 0 -l 1 FitSkeleton.tx;setAttr -k 0 -l 1 FitSkeleton.ty;setAttr -k 0 -l 1 FitSkeleton.tz;
setAttr -k 0 -l 1 FitSkeleton.rx;setAttr -k 0 -l 1 FitSkeleton.ry;setAttr -k 0 -l 1 FitSkeleton.rz;
asEnsureFitSkeletonAttributes;
string $upAxisDirection=`upAxis -q -ax`;
if ($upAxisDirection=="z")
	asSceneUpAxisFlip FitSkeleton z;
select FitSkeleton;
}

global proc asEnsureFitSkeletonAttributes ()
{
if (!`objExists FitSkeleton`)
	return;
float $gap=0.75;
if (`optionVar -ex asFitSkeletonGap`)
	$gap=`optionVar -q asFitSkeletonGap`;

if (!`attributeExists visGeo FitSkeleton`)
	addAttr -k 1 -ln visGeo -at bool -dv 0 FitSkeleton;
if (!`attributeExists visGeoType FitSkeleton`)
	addAttr -k 1 -ln visGeoType -at "enum" -en "cylinders:boxes:spheres:bones" FitSkeleton;
if (!`attributeExists visCylinders FitSkeleton`)
	addAttr -k 0 -ln visCylinders -at bool FitSkeleton;
if (!`attributeExists visBoxes FitSkeleton`)
	addAttr -k 0 -ln visBoxes -at bool FitSkeleton;
if (!`attributeExists visSpheres FitSkeleton`)
	addAttr -k 0 -ln visSpheres -at bool FitSkeleton;
if (!`attributeExists visBones FitSkeleton`)
	addAttr -k 0 -ln visBones -at bool FitSkeleton;
if (!`attributeExists lockCenterJoints FitSkeleton`)
	addAttr -k 1 -ln lockCenterJoints -dv 1 -at bool FitSkeleton;
if (!`attributeExists visGap FitSkeleton`)
	addAttr -k 1 -ln visGap -at double -dv $gap -min 0 -max 1 FitSkeleton;

if (!`attributeExists visPoleVector FitSkeleton`)
	addAttr -k 1 -ln visPoleVector -at bool -dv 0 FitSkeleton;
if (!`attributeExists visJointOrient FitSkeleton`)
	addAttr -k 1 -ln visJointOrient -at bool -dv 0 FitSkeleton;
if (!`attributeExists visJointAxis FitSkeleton`)
	addAttr -k 1 -ln visJointAxis -at bool -dv 0 FitSkeleton;

if (!`attributeExists objectsSkin FitSkeleton`) 			addAttr -ln objectsSkin -dt "string" FitSkeleton;
if (!`attributeExists objectsAll FitSkeleton`)  			addAttr -ln objectsAll  -dt "string" FitSkeleton;
if (!`attributeExists objectsRightEye FitSkeleton`)   addAttr -ln objectsRightEye  -dt "string" FitSkeleton;
if (!`attributeExists objectsLeftEye FitSkeleton`)    addAttr -ln objectsLeftEye  -dt "string" FitSkeleton;
if (!`attributeExists gameEngine FitSkeleton`)  			addAttr -ln gameEngine  -at bool FitSkeleton;
if (!`attributeExists zUpAxis FitSkeleton`)  					addAttr -ln zUpAxis  -at bool FitSkeleton;
//if (!`attributeExists mirTrans FitSkeleton`)  				addAttr -ln mirTrans  -at bool FitSkeleton;
//if (!`attributeExists primaryAxis FitSkeleton`) 			addAttr -ln primaryAxis -at "enum" -en "X:Y:Z:-X:-Y:-Z:" -dv 0 FitSkeleton;
//if (!`attributeExists secondaryAxis FitSkeleton`) 		addAttr -ln secondaryAxis -at "enum" -en "X:Y:Z:-X:-Y:-Z:" -dv 1 FitSkeleton;
//if (!`attributeExists worldmatch FitSkeleton`) 				addAttr -ln worldmatch  -at bool FitSkeleton;
if (!`attributeExists useOffsetParentMatrix FitSkeleton`)
	{
	addAttr -ln useOffsetParentMatrix -at bool FitSkeleton;
//removed as checkBox could be ON, but opening a rig that does not yet have the attr
//	if (`checkBox -q -ex asBodyOffsetParentMatrixCheckBox`)
//		if (`checkBox -q -v asBodyOffsetParentMatrixCheckBox`)
//			setAttr FitSkeleton.useOffsetParentMatrix 1;
	}

if (!`attributeExists preRebuildScript FitSkeleton`)
	addAttr -ln preRebuildScript -dt "string" FitSkeleton;
if (!`attributeExists postRebuildScript FitSkeleton`)
	addAttr -ln postRebuildScript -dt "string" FitSkeleton;
}

global proc asEnsureFitBaseStruct ()
{
if (!`objExists FitSkeletonVisualizers`)
	createNode -n FitSkeletonVisualizers transform;
if (!`objExists Aims`)
	createNode -n Aims -p FitSkeletonVisualizers transform;
if (!`objExists Systems`)
	createNode -n Systems -p FitSkeletonVisualizers transform;
}

global proc asStraightEndLoc (string $loc, float $lenght)
{
//maintain the `direction` with the end loc
string $parent;
float $pos[]=`getAttr ($loc+".t")`;
$tempString=`listConnections -s 0 -d 1 ($loc+".message")`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		{
		if (`attributeExists "child" $tempString[$i]`)
			if (`isConnected ($loc+".message") ($tempString[$i]+".child")`)
				$parent=$tempString[$i];
		if (`attributeExists "otherChildren" $tempString[$i]`)
			for ($y=0;$y<`getAttr -s ($tempString[$i]+".otherChildren")`;$y++)
				if (`isConnected ($loc+".message") ($tempString[$i]+".otherChildren["+$y+"]")`)
					$parent=$tempString[$i];
		}

if ($parent!="")
	{
	float $pos2[]=`getAttr ($parent+".t")`;
	float $parentLenght=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if ($lenght==0)
		$lenght=$parentLenght;
	float $lenghtMuliplier=1;
	if ($lenght!=0)
		$lenghtMuliplier=$parentLenght*1/$lenght;
	if (`objExists ($loc+"End")`)
		{
		if (!`getAttr -l ($loc+"End.tx")`)
			setAttr ($loc+"End.tx") ($pos[0]+($pos[0]-$pos2[0])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.ty")`)
			setAttr ($loc+"End.ty") ($pos[1]+($pos[1]-$pos2[1])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.tz")`)
			setAttr ($loc+"End.tz") ($pos[2]+($pos[2]-$pos2[2])/$lenghtMuliplier);
		}
	}
}

global proc asSettingsColorsChoose (string $type)
{
int $previousColorManagementOptionVar=`optionVar -q colorManagementColorPickerColorMgtEnabled`;
int $cancelled;
float $values[];
string $button="asSettingsColors"+$type+"Button";
string $cmd,$guiType;
string $guiNames[];

optionVar -iv colorManagementColorPickerColorMgtEnabled 0;

$values=`button -q -bgc $button`;
colorEditor -rgb $values[0]  $values[1] $values[2];
if (`colorEditor -query -result`)
	$values=`colorEditor -query -rgb`;
else
	$cancelled=1;
if ($previousColorManagementOptionVar)
	optionVar -iv colorManagementColorPickerColorMgtEnabled 1;
if ($cancelled)
	return;
button -e -bgc $values[0] $values[1] $values[2] $button;

optionVar -clearArray ("asSettingsUseCustomColors"+$type);
for ($i=0;$i<3;$i++)
	optionVar -floatValueAppend ("asSettingsUseCustomColors"+$type) $values[$i];

asSettingsColorsRefresh;
}

global proc string[] asGetUiElements (string $type, string $topLayout)
{
string $elements[],$subElements[],$uiChildren[];

$uiChildren=`layout -q -ca $topLayout`;
for ($i=0;$i<size($uiChildren);$i++)
		{
		if ($type=="button" && `gmatch $uiChildren[$i] "*asSettingsColors*"`)//skip the ColorDefinitionButton
			continue;
		if ($uiChildren[$i]=="")//skip the ColorDefinitionButton
			continue;
		if (`layout -q -ex $uiChildren[$i]`)
			{
			$subElements=`asGetUiElements $type $uiChildren[$i]`;
			$elements=`stringArrayCatenate $elements $subElements`;
			}
		else if (`eval ($type+" -q -ex "+$uiChildren[$i])`)
			$elements[size($elements)]=$uiChildren[$i];
		}
return $elements;
}

global proc string[] asGetSettingsColorTypes ()
{
string $types[],$tempString[];

//find $types[], BackGround, Buttons, etc
$tempString=`columnLayout -q -ca asSettingsColorsColumnLayout`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "asSettingsColors*RowLayout"`)
		{
		$tempString2[0]=`substitute "asSettingsColors" $tempString[$i] ""`;
		$tempString2[0]=`substitute "RowLayout" $tempString2[0] ""`;
		$types[size($types)]=$tempString2[0];
		}

return $types;
}

global proc asSettingsColorsReset ()
{
string $types[]=`asGetSettingsColorTypes`;

optionVar -iv asSettingsUseCustomColors 0;
for ($i=0;$i<size($types);$i++)
	{
	optionVar -rm ("asSettingsUseCustomColors"+$types[$i]);
	if (`optionVar -ex ("asSettingsUseCustomColors"+$types[$i]+"Fade")`)
		optionVar -rm ("asSettingsUseCustomColors"+$types[$i]+"Fade");
	}

AdvancedSkeleton;
}

global proc asSettingsColorsRefresh ()
{
int $isFirst,$numLev,$inLevCount;
int $useCustomColors=`checkBox -q -v asSettingsUseCustomColorsCheckBox`;
int $lev2IsFirst[];
float $step;
float $c[],$cStart[],$cFade[];
string $button,$fadeButton,$cmd;
string $elements[],$buttons[],$dropDowns[],$checkBoxes[],$tempString[],$tempString2[],$tempString3[];
string $lev1FrameLayouts[],$lev1FrameChildren[];
string $lev2FrameLayouts[],$lev2FrameChildren[];
string $types[]=`asGetSettingsColorTypes`;

if (!$useCustomColors)
	{
	AdvancedSkeleton;
	return;
	}

//find various Gui Elements
$buttons=`asGetUiElements button asColumnLayout`;
$dropDowns=`asGetUiElements optionMenu asColumnLayout`;
$checkBoxes=`asGetUiElements checkBox asColumnLayout`;
$lev1FrameLayouts=`layout -q -ca asColumnLayout`;
for ($i=0;$i<size($lev1FrameLayouts);$i++)
	{
	$tempString=`layout -q -ca $lev1FrameLayouts[$i]`;
	$tempString2=`layout -q -ca $tempString[0]`;
	$isFirst=1;
	for ($y=0;$y<size($tempString2);$y++)
		if (`frameLayout -q -ex $tempString2[$y]`)
			{
			$lev2IsFirst[size($lev2FrameLayouts)]=$isFirst;
			$lev2FrameLayouts[size($lev2FrameLayouts)]=$tempString2[$y];
			$isFirst=0;
			}
	}

for ($i=0;$i<size($types);$i++)
	{
	$button="asSettingsColors"+$types[$i]+"Button";
	$fadeButton="asSettingsColors"+$types[$i]+"FadeButton";
	$c=`button -q -bgc $button`;
	$cFade=`button -q -bgc $fadeButton`;
	$cStart=$c;
	$inLevCount=1;
	clear $elements;
	if ($types[$i]=="Background")
		$elements={"asFormLayout"};
	if ($types[$i]=="Level1")
		$elements=$lev1FrameLayouts;
	if ($types[$i]=="Level2")
		$elements=$lev2FrameLayouts;
	if ($types[$i]=="Buttons")
		$elements=$buttons;
	if ($types[$i]=="DropDowns")
		$elements=$dropDowns;
	if ($types[$i]=="CheckBoxes")
		$elements=$checkBoxes;

	for ($y=0;$y<size($elements);$y++)
		{
		//fade
		if (`gmatch $types[$i] "Level*"`)
			{
			$numLev=12;
			if ($types[$i]=="Level2")
				{
				$tempString[0]=`layout -q -p $elements[$y]`;
				$tempString=`layout -q -ca $tempString[0]`;
				$numLev=size($tempString);
				if ($lev2IsFirst[$y])
					$inLevCount=1;
				}
			if ($cFade[0]!=$cStart[0] || $cFade[1]!=$cStart[1] || $cFade[2]!=$cStart[2])
				for ($z=0;$z<3;$z++)
					{
					$step=(($cFade[$z]-$cStart[$z])/$numLev);
					$c[$z]=$cStart[$z]+($step*$inLevCount);
					}
			}

		if ($types[$i]=="Buttons") $cmd="button -e ";
		else if ($types[$i]=="DropDowns") $cmd="optionMenu -e ";
		else if ($types[$i]=="CheckBoxes") $cmd="checkBox -e ";
		else $cmd="layout -e ";
		$cmd+="-bgc "+$c[0]+" "+$c[1]+" "+$c[2];
		$cmd+=" "+$elements[$y];
		eval ($cmd);
		$inLevCount++;

		//include firstChild of layout
		if (`gmatch $types[$i] "Level*"`)
			{
			$tempString=`layout -q -ca $elements[$y]`;
			if (`layout -q -ex $tempString[0]`)
					layout -e -bgc $c[0] $c[1] $c[2] $tempString[0];
			}
		}
	}
}

global proc asUpdateButtonEnables ()
{
if (!`columnLayout -q -ex asColumnLayout`)
	return;
global string $asBodyPreSkin;
global string $asBodyPreAll;
global string $asBodyPreRightEye;
global string $asBodyPreLeftEye;
int $asBodyPreGameEngine=`optionVar -q asBodyPreGameEngine`;
int $asBodyPreZUpAxis=`optionVar -q asBodyPreZUpAxis`;
int $asBodyPreOPM=`optionVar -q asBodyPreOPM`;
int $opm=`asGetOpm`;
int $faceGameEngine,$rigTypeInt,$displayPoleVector,$displayJointOrient,$displayJointAxis,$lockCenterJoints,$hasCorrectiveShapes;
int $showSkinLayersFrameLayout,$showTweaksFrameLayout,$bodyGameEngine,$faceMultiSkinClusters,$zUpAxis,$fitSkeletonVisible,$faceFitSkeletonVisible,$hasDefinedSkin;
int $hasBodySetup=`objExists "Group"`;
int $hasFaceSetup=`objExists FaceMotionSystem`;
int $hasVisualizers=`objExists FitSkeletonVisualizers`;
int $hasGeometryVisualizers=`objExists FitSkeletonVisualizers` && `objExists Aims`;
int $showDelteAdvButton,$showDelteAdvFaceButton,$showAutoPlaceTweaks,$csm,$ccm,$cm,$dsm,$hcs,$hcc,$hc,$hd;
//$csm=CorrectiveShapesMode $ccm=CorrectiveSoftModsMode, $cm=Corrective*Mode,$hcs=HasCorrectiveShapes, $hcc=HasCorrectiveShapes
//$hc= HasCorrective*, $dsm=DrivingSystemMode, $hd=HasDrivingSystems

if (`objExists FitSkeleton`) if (`getAttr FitSkeleton.v`) $fitSkeletonVisible=1;
if (`objExists FaceFitSkeleton`) if (`getAttr FaceFitSkeleton.v`) $faceFitSkeletonVisible=1;
if ($hasBodySetup && $fitSkeletonVisible)
	$showDelteAdvButton=1;
if ($hasFaceSetup && $faceFitSkeletonVisible)
	$showDelteAdvFaceButton=1;
string $buildLabel,$skin,$all,$rightEye,$leftEye,$layer,$autoPlaceButtonLabel,$cmd,$includeAsString,$FaceRigTypeInUi;
string $tempString[];
string $rootLevelObjects[]=`ls -as`;
string $drivingSystems[]=`asDsGetDrivingSystems`;

for ($i=0;$i<size($rootLevelObjects);$i++)
	{
	if (`attributeExists DrivingSystems $rootLevelObjects[$i]`) {$dsm=1;break;}//DrivingSystemsMode
	if (`attributeExists CorrectiveShapes $rootLevelObjects[$i]`) {$csm=1;break;}//CorrectiveShapesMode
	if (`attributeExists CorrectiveSoftMods $rootLevelObjects[$i]`) {$ccm=1;break;}//CorrectiveSoftModsMode
	}
if (size($drivingSystems))
	$hd=1;
//if (size(`ls -type animCurve "asDSEdit_*"`)) asDSEdit_* animCurves might not exists
//	$dsm=1;
$tempString=`ls -recursive 1 -type blendShape "*Corrective*"`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`attributeExists CorrectiveShapes $tempString[$i]`) {$hcs=1;break;}//HasCorrectiveShapes
	if (`attributeExists CorrectiveSoftMods $tempString[$i]`) {$hcc=1;break;}//HasCorrectiveShapes
	}
if (`optionMenu -q -ex asFaceRigTypeOptionMenu`)
	$FaceRigTypeInUi=`optionMenu -q -v asFaceRigTypeOptionMenu`;
if (`attributeExists RigType FaceFitSkeleton`)
	$rigTypeInt=`getAttr FaceFitSkeleton.RigType`;
if (`attributeExists GameEngine FaceFitSkeleton`)
	$faceGameEngine=`getAttr FaceFitSkeleton.GameEngine`;
if (`attributeExists MultiSkinClusters FaceFitSkeleton`)
	$faceMultiSkinClusters=`getAttr FaceFitSkeleton.MultiSkinClusters`;

if (`attributeExists objectsSkin FitSkeleton`) $skin=`getAttr FitSkeleton.objectsSkin`;
if (`attributeExists objectsAll FitSkeleton`) $all=`getAttr FitSkeleton.objectsAll`;
if (`attributeExists objectsRightEye FitSkeleton`) $rightEye=`getAttr FitSkeleton.objectsRightEye`;
if (`attributeExists objectsLeftEye FitSkeleton`) $leftEye=`getAttr FitSkeleton.objectsLeftEye`;
if (`attributeExists visPoleVector FitSkeleton`) $displayPoleVector=`getAttr FitSkeleton.visPoleVector`;
if (`attributeExists visJointOrient FitSkeleton`) $displayJointOrient=`getAttr FitSkeleton.visJointOrient`;
if (`attributeExists visJointAxis FitSkeleton`) $displayJointAxis =`getAttr FitSkeleton.visJointAxis`;
if (`attributeExists lockCenterJoints FitSkeleton`) $lockCenterJoints=`getAttr FitSkeleton.lockCenterJoints`;
if (`attributeExists gameEngine FitSkeleton`) $bodyGameEngine=`getAttr FitSkeleton.gameEngine`;
if (`attributeExists zUpAxis FitSkeleton`) $zUpAxis=`getAttr FitSkeleton.zUpAxis`;

//prior to FitSkeleton exits
if (!`objExists FitSkeleton`)
	{
	$bodyGameEngine=$asBodyPreGameEngine;
	$zUpAxis=$asBodyPreZUpAxis;
	$opm=$asBodyPreOPM;
	$skin=$asBodyPreSkin;
	$all=$asBodyPreAll;
	$rightEye=$asBodyPreRightEye;
	$leftEye=$asBodyPreLeftEye;
	}

//OPM overrides
if ($opm)
	{
//	$bodyGameEngine=0;
	$zUpAxis=0;
//	if (`attributeExists gameEngine FitSkeleton`) setAttr FitSkeleton.gameEngine 0;
	if (`attributeExists zUpAxis FitSkeleton`) setAttr FitSkeleton.zUpAxis 0;
	}

//Body
textField -e -tx $skin asBodySkinTextField;
textField -e -tx $all asBodyAllTextField;
textField -e -tx $rightEye asBodyRightEyeTextField;
textField -e -tx $leftEye asBodyLeftEyeTextField;
//checkBox -e -en (!$opm) -v $bodyGameEngine asBodyGameEngineCheckBox;
checkBox -e -en (!$opm) -v $zUpAxis asBodyZUpAxisCheckBox;
checkBox -e -v $opm asBodyOffsetParentMatrixCheckBox;
checkBox -e -v $hasGeometryVisualizers asVisGeo;
optionMenu -e -en $hasVisualizers asVisGeoType;
floatSliderGrp -e -en $hasVisualizers asVisGap;
checkBox -e -v $displayPoleVector asVisPoleVector;
checkBox -e -v $displayJointOrient asVisJointOrient;
checkBox -e -v $displayJointAxis asVisJointAxis;

if ($skin!="")
	$hasDefinedSkin=1;

text -e -m $hasDefinedSkin  asFitAutoPlaceText;
rowLayout -e -m $hasDefinedSkin asFitAutoPlaceRowLayout;

button -e -m $showDelteAdvButton asDelteAdvButton;
checkBox -e -m $hasBodySetup asKeepAllCheckBox;
if (!$hasBodySetup)
	columnLayout -e -m 0 asBodyKeepColumnLayout;

button -e -m $hasBodySetup asToggleFitSkeletonButton;
$buildLabel="Build AdvancedSkeleton";
$autoPlaceButtonLabel="autoPlace";
if ($hasBodySetup)
	$buildLabel="ReBuild AdvancedSkeleton";
if (`objExists AutoPlacing`)
	{
	$autoPlaceButtonLabel="delete guides";
	$showAutoPlaceTweaks=1;
	}
button -e -l $buildLabel asBuildAdvancedSkeletonButton;
button -e -l $autoPlaceButtonLabel asFitAutoPlaceButton;
columnLayout -e -m $showAutoPlaceTweaks asFitAutoPlaceTweaksColumnLayout;

frameLayout -e -en (!$bodyGameEngine) asBodyDeformDeltaMushFrameLayout;
frameLayout -e -en (!$bodyGameEngine) asBodyDeform3FrameLayout;
frameLayout -e -en (!$bodyGameEngine) asBodySquashControlFrameLayout;
columnLayout -e -en (!$bodyGameEngine) ("asBodyCustomControlsNonGameEngineCompatiblesColumnLayout");

//Face-include
columnLayout -e -en (`asFaceIncludeAboveEyes`) asFaceFitAboveEyeColumnLayout;
columnLayout -e -en (`asFaceIncludeBelowEyes`) asFaceFitBelowEyeColumnLayout1;
columnLayout -e -en (`asFaceIncludeBelowEyes`) asFaceFitBelowEyeColumnLayout2;


//Face (Face-Fit section done in "asFaceUpdateInfo")
button -e -m $showDelteAdvFaceButton asDelteAdvFaceButton;
checkBox -e -m $hasFaceSetup asFaceKeepAllCheckBox;
if (!$hasFaceSetup)
	columnLayout -e -m 0 asFaceKeepColumnLayout;
button -e -m $hasFaceSetup asToggleFitFaceButton;
$buildLabel="Build AdvancedFace";
if ($hasFaceSetup)
	$buildLabel="ReBuild AdvancedFace";
button -e -m 1 -l $buildLabel asBuildAdvancedFaceButton;
if (`objExists FaceBuildInProgress`)
	{
	checkBox -e -m 0 asFaceKeepAllCheckBox;
	columnLayout -e -m 0 asFaceKeepColumnLayout;
	button -e -m 0 asBuildAdvancedFaceButton;
	button -e -m 0 asDelteAdvFaceButton;
	}

//DeformationLayers
if ($rigTypeInt==2 && $faceGameEngine==0) $showSkinLayersFrameLayout=1;
frameLayout -e -m $showSkinLayersFrameLayout asFaceSkinLayersFrameLayout;
if ($showSkinLayersFrameLayout && `objExists DeformationLayers`)
	{
	$tempString=`layout -q -ca asFaceSkinLayersColumnLayout`;
	for ($i=0;$i<size($tempString);$i++)
		deleteUI $tempString[$i];
	$tempString=`listRelatives -c -type transform DeformationLayers`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$layer=`substitute "Layer" $tempString[$i] ""`;
		if ($layer=="template" || $layer=="Template" || $layer=="allHeadCombined")
			continue;
		setParent asFaceSkinLayersColumnLayout;
		button -w 100 -l $layer -c ("asShowLayer "+$layer);
		}
	}

//Pose
if ($dsm) $hd=0;//Edit not avaiable during *Mode
columnLayout -e -en (!$dsm) asDrivingSystemsCreateColumnLayout;
columnLayout -e -en $hd asDrivingSystemsEditColumnLayout;
columnLayout -e -en $dsm asDrivingSystemsApplyColumnLayout;

columnLayout -e -en (!$csm) ("asCorrectiveShapesCreateColumnLayout");
columnLayout -e -en $csm ("asCorrectiveShapesApplyCancelColumnLayout");
columnLayout -e -en $hcs ("asCorrectiveShapesEditColumnLayout");

//WrinkleMap
if (`objExists fileFaceWrinkles` && `objExists bump2dWrinkle`)
	if (!`isConnected fileFaceWrinkles.outAlpha bump2dWrinkle.bumpValue`)
		rowLayout -e -en 1 asWmEditApplyCancelRowLayout;

if (`attributeExists GameEngine FaceFitSkeleton`)
	$faceGameEngine=`getAttr FaceFitSkeleton.GameEngine`;
columnLayout -e -m $faceGameEngine asFaceAdvancedinputGameEngineColumnLayout;
frameLayout -e -en (!$faceGameEngine) asFaceDeltaMushFrameLayout;
frameLayout -e -en (!$faceGameEngine) asFaceSquashFrameLayout;
columnLayout -e -en (!$faceGameEngine) ("asFaceCustomControlsNonGameEngineCompatiblesColumnLayout");
menuItem -e -en (!$faceGameEngine && !$faceMultiSkinClusters) asFaceRigTypeMixedMenuItem;// (&& !$opm) removed since Now OPM+Mixed works
menuItem -e -en (!$faceMultiSkinClusters) asFaceRigTypeBlendShapesMenuItem;
if ($faceGameEngine && $FaceRigTypeInUi=="Mixed") {optionMenu  -e -sl 1 asFaceRigTypeOptionMenu;asFaceUpdateInfo 0;}
//Now OPM+Mixed works if ($opm && $FaceRigTypeInUi=="Mixed") {optionMenu  -e -sl 1 asFaceRigTypeOptionMenu;asFaceUpdateInfo 0;}
if ($faceGameEngine && $faceMultiSkinClusters) {checkBox -e -v 0 asFaceMultiSkinClustersCheckBox;asFaceUpdateInfo 0;}
if ($faceMultiSkinClusters && $FaceRigTypeInUi!="Joints") {optionMenu  -e -sl 1 asFaceRigTypeOptionMenu;asFaceUpdateInfo 0;}

if ($rigTypeInt==0 || $rigTypeInt==2) $showTweaksFrameLayout=1;
frameLayout -e -en $showTweaksFrameLayout asFaceTweaksFrameLayout;

text -e -m $hasFaceSetup asBodyText;
text -e -m $hasFaceSetup asFaceText;
button -e -m $hasFaceSetup asGoToBuildPoseFaceButton;
}

global proc asSceneOpened ()
{
//global int $asBodyPreGameEngine;
global string $asBodyPreSkin;
global string $asBodyPreAll;
global string $asBodyPreRightEye;
global string $asBodyPreLeftEye;
global string $gSelect;
global int $asFitModeScriptJobNr4;

if (`currentCtx`=="softModContext")
	setToolTo $gSelect;

$asFitModeScriptJobNr4=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;
asOffFitMode;

//$asBodyPreGameEngine=0;
$asBodyPreSkin="";
$asBodyPreAll="";
$asBodyPreRightEye="";
$asBodyPreLeftEye="";
asEnsureFitSkeletonAttributes;
asUpdateButtonEnables;
asFaceUpdateInfo 1;
asUpdateHud;
}

global proc asUpdateHud ()
{
if (`headsUpDisplay -q -ex HUDFitMode`) headsUpDisplay -rem HUDFitMode;
if (`headsUpDisplay -q -ex HUDEDSMode`) headsUpDisplay -rem HUDEDSMode;
if (`headsUpDisplay -q -ex HUDCSMMode`) headsUpDisplay -rem HUDCSMMode;
}

global proc asOffFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr2[];
global int $asFitModeScriptJobNr3;
if (`headsUpDisplay -q -ex HUDFitMode`)
	headsUpDisplay -rem HUDFitMode;

if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr1;
	$asFitModeScriptJobNr1=0;
	}
if (`scriptJob -ex $asFitModeScriptJobNr3` && $asFitModeScriptJobNr3!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr3;
	$asFitModeScriptJobNr3=0;
	}
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
}

global proc asToggleFitFace ()
{
int $fitFaceVis=`getAttr FaceFitSkeleton.v`;
setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v (!$fitFaceVis);
catchQuiet (`setAttr FaceMotionSystem.v $fitFaceVis`);
asUpdateButtonEnables;
}

global proc asCopyAttrProperties (string $sourceObjAttr, string $destObjAttr)
{
float $temp[];
string $tempString[];
tokenize $sourceObjAttr "[.]" $tempString;
string $sourceObj=$tempString[0];
string $sourceAttr=$tempString[1];
tokenize $destObjAttr "[.]" $tempString;
string $destObj=$tempString[0];
string $destAttr=$tempString[1];
if (`attributeQuery -node $sourceObj -minExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -min $sourceAttr`;
	addAttr -e -min $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -maxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -max $sourceAttr`;
	addAttr -e -max $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMinExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMin $sourceAttr`;
	addAttr -e -softMinValue $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMaxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMax $sourceAttr`;
	addAttr -e -softMaxValue $temp[0] $destObjAttr;
	}
}

global proc asFitModeEnsureShaders ()
{
string $colors[]={"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asWhite","asBlack","asBones"};
float $rs[]={1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.78};
float $gs[]={0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , 0.76};
float $bs[]={0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 1.0 , 1.0 , 0.0 , 0.72};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asCreateSamplerMesh (string $sourceObj)
{
//make a copy of the geometry, so we can freeze transforms and get correct sampler-results
string $tempString[];
duplicate -n samplerMesh $sourceObj;
$tempString=`listRelatives -f -ni -s samplerMesh`;
rename $tempString[0] samplerMeshShape;
asLockAttr samplerMesh 0 0 0 0;
$tempString=`listRelatives -p samplerMesh`;
if ($tempString[0]!="")
	parent -w samplerMesh;
$tempString=`listRelatives -s -f samplerMesh`;
for ($w=0;$w<size($tempString);$w++)
	if (`getAttr ($tempString[$w]+".intermediateObject")`)
		delete $tempString[$w];
makeIdentity -a 1 -t 1 -r 1 -s 1 samplerMesh;
}

global proc asSelectDeformJoints ()
{
string $sel[]=`ls -sl`;
if (`objExists "DeformSet"`)
	select `sets -q "DeformSet"`;
//Deselect end-joints
string $tempString[];
string $deformJoints[]=`ls -sl`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Slider[0-9]"`)
		continue;
	}
for ($i=0;$i<size($deformJoints);$i++)
	if ($deformJoints[$i]=="Eye_R" || $deformJoints[$i]=="Eye_L" || $deformJoints[$i]=="Jaw_M")
		select -d $deformJoints[$i];
select -add $sel;
}

global proc asSetSmoothBindOptions ()
{
optionVar
-iv "multipleBindPosesOpt" 1
-iv "bindMethod" 1
-iv "bindTo" 2
-iv "skinMethod" 1
-iv "removeUnusedInfluences" 0
-iv "colorizeSkeleton" 0
-fv "maxInfl" 3
-iv "normalizeWeights" 2
-iv "obeyMaxInfl" 0;
SmoothBindSkinOptions;
}

global proc asOpenSelector ()
{
evalEcho ("source \""+`asGetScriptLocation`+"/AdvancedSkeletonFiles/Selector/biped.mel\"");
}

global proc asCreateTempNodes ()
{
createNode -n TempNodes transform;
string $tempNodes[]={"FKScapula_R","FKScapula_L","FKAnkle_L","FKAnkle_R","FKChest_M","FKElbow_L","FKElbow_R","FKHead_M","FKHip_L","FKHip_R","FKIndexFinger1_L","FKIndexFinger1_R","FKIndexFinger2_L","FKIndexFinger2_R","FKIndexFinger3_L","FKIndexFinger3_R","FKKnee_L","FKKnee_R","FKMiddleFinger1_L","FKMiddleFinger1_R","FKMiddleFinger2_L","FKMiddleFinger2_R","FKMiddleFinger3_L","FKMiddleFinger3_R","FKNeck_M","FKPinkyFinger1_L","FKPinkyFinger1_R","FKPinkyFinger2_L","FKPinkyFinger2_R","FKPinkyFinger3_L","FKPinkyFinger3_R","FKRingFinger1_L","FKRingFinger1_R","FKRingFinger2_L","FKRingFinger2_R","FKRingFinger3_L","FKRingFinger3_R","FKRoot_M","FKShoulder_L","FKShoulder_R","FKSpine1_M","FKThumbFinger1_L","FKThumbFinger1_R","FKThumbFinger2_L","FKThumbFinger2_R","FKThumbFinger3_L","FKThumbFinger3_R","FKToes_L","FKToes_R","FKWrist_L","FKWrist_R"};
for ($i=0;$i<size($tempNodes);$i++)
	createNode -n $tempNodes[$i] -p TempNodes transform;
select `listRelatives -ad TempNodes`;
}

global proc asFitSkeletonFromEdgeLoops ()
{
global string $gMove;
setToolTo $gMove;
float $pos[];
string $loc;
string $skinLoopSets[]=`sets -q SkinLoops`;
for ($i=0;$i<size($skinLoopSets);$i++)
	{
	$loc=`substitute "SkinLoops_" $skinLoopSets[$i] ""`;
	$loc=`substitute "_R" $loc ""`;
	$loc=`substitute "_M" $loc ""`;
	if (!`objExists $loc`)
		continue;
	select $skinLoopSets[$i];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $loc;
	}
select -cl;
}

global proc asCreateSkinLoop (int $mirroring)
{
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
string $fkControl=$sel[size($sel)-1];
string $deformJoint;
if (`objExists DeformSet` && `sets -im DeformSet $fkControl`)
	$deformJoint=$fkControl;
else
	{
	$deformJoint=`substitute "FK" $fkControl ""`;
	if (!`gmatch $fkControl "FK*"`)
		error "No FK control selected";
	}
float $pos[];
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
//float $mirrorTolerance=0.001*$scale;

int $neighboursInLoop;
string $mirrorFkControl;
string $tempString[],$tempString2[],$tempString3[],$mirrorVtxs[];

//validate complete loop
select -d $fkControl;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	select $tempString[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $tempString[$i];
	$tempString2=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString2);$y++)
		if (`stringArrayCount $tempString2[$y] $tempString`)
			$neighboursInLoop++;
	if ($neighboursInLoop!=2)
		{
		select $tempString[$i];
		if ($mirroring)
			error ("Not a complete loop, on mirrored side");
		else
			error ("Not a complete loop");
		}
	}

if (`objExists ("SkinLoops_"+$deformJoint)`)
	delete ("SkinLoops_"+$deformJoint);

if (!`objExists SkinLoops`)
	sets -em -name SkinLoops;
select $sel;
select -d $fkControl;
sets -name ("SkinLoops_"+$deformJoint);
sets -add  SkinLoops ("SkinLoops_"+$deformJoint);

if (`checkBox -q -v asCreateSkinLoopCheckBox` && !`gmatch $deformJoint "*_M"` && !$mirroring)
	{
	select ("SkinLoops_"+$deformJoint);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	$tempString2=`ls -sl -o`;
	$tempString3=`listRelatives -p $tempString2[0]`;
	if (`objExists closestSampler`) delete closestSampler;
	if (`objExists samplerMesh`) delete samplerMesh;
	asCreateSamplerMesh $tempString3[0];
	createNode -n closestSampler closestPointOnMesh;
	connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
	
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		int $closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
		$mirrorVtxs[size($mirrorVtxs)]=$tempString2[0]+".vtx["+$closestVtxIndex+"]";
		}
	select $mirrorVtxs;
	ConvertSelectionToContainedEdges;
	if (`gmatch $deformJoint "*_R"`) $mirrorFkControl=`substitute "_R" $fkControl "_L"`;
	if (`gmatch $deformJoint "*_L"`) $mirrorFkControl=`substitute "_L" $fkControl "_R"`;
	select -add $mirrorFkControl;
	asCreateSkinLoop 1;
	}
if (`objExists closestSampler`) delete closestSampler;
if (`objExists samplerMesh`) delete samplerMesh;
print ("// SkinLoops_"+$deformJoint+" Created\n");
select $sel;
}

global proc asSelectAllSkinLoops ()
{
select SkinLoops;
select -add `ls -sl -o`;
}

global proc asCreateCutUp ()
{
int $numChar;
string $name,$joint,$mesh,$control,$nrSuffix;
string $sel[]=`ls -sl`;
string $tempString[];
string $deformJoints[]=`listRelatives -ad -type joint DeformationSystem`;

if (!`asConfirmIfNotInBuildPose`)
	return;

if (!`objExists CutUp`)
	{
	createDisplayLayer -e -name CutUp;
	setAttr CutUp.color 29;
	setAttr CutUp.displayType 2;
	}
if (!`objExists CutUpGeometry`)
	createNode -n CutUpGeometry -p Geometry transform;

select $sel;
asCreateControlMeshes;

for ($i=0;$i<size($deformJoints);$i++)
	for ($y=0;$y<99;$y++)
		{
		$mesh="";
		$nrSuffix="";
		if ($y>0)
			$nrSuffix=$y;
		if (`objExists ("FK"+$deformJoints[$i]+"MeshCtrl"+$nrSuffix)`)
			$mesh="FK"+$deformJoints[$i]+"MeshCtrl"+$nrSuffix;
		if (`objExists ($deformJoints[$i]+"MeshCtrl"+$nrSuffix)`)
			$mesh=$deformJoints[$i]+"MeshCtrl"+$nrSuffix;
		$tempString[0]=`substitute "Joint_" $deformJoints[$i] "_"`;
		if (`objExists ($tempString[0]+"MeshCtrl"+$nrSuffix)`)
			$mesh=$tempString[0]+"MeshCtrl"+$nrSuffix;
		if ($mesh=="")
			break;

		editDisplayLayerMembers -noRecurse CutUp $mesh;
		select $mesh;
		DeleteHistory;
		$joint=$deformJoints[$i];
	/*
		while (`gmatch $joint "*[0-9]"`)
			{//strip numbers of the end
			$numChar=size($joint);
			$joint=`substring $joint 1 ($numChar-1)`;
			}
	*/
		$name=$joint+"CutUp"+$nrSuffix;
		$tempString=`listRelatives -p $mesh`;
		$control=$tempString[0];
		createNode -n $name -p CutUpGeometry transform;
		parent -add -s $mesh $name;
		parent -rm -s ($control+"|"+$mesh);
		rename $mesh ($name+"Shape");
		if (!`objExists $joint`)
			error ("Could not find joint:\""+$joint+"\"");
		asParentConstraint $joint $name "";
		}

select -cl;
print ("// Cut up Created\n");
}

global proc asDeleteCutUp ()
{
if (!`objExists CutUp`)
	return;
string $tempString[]=`listConnections CutUp.drawInfo`;
if (size($tempString))
	delete $tempString;
delete CutUp;
if (`objExists CutUpGeometry`)
	delete CutUpGeometry;
print ("// Cut up Deleted\n");
}

global proc asBindSkinLoops (int $createCutUp)
{
source removeUnusedInfluences;
global string $gMove;
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]*"`)
		error ("Selection is not a object:"+$sel[$i]);
int $tempInt[],$twistJoints[];
int $haveSkinCluster,$numVtxs,$foundDownSideVtx,$loopAffectsCut;
float $circumference,$radius,$ratio;
float $pos[],$posA[],$posB[],$values[];
string $tempString[],$tempString2[],$deformJoints[],$parentJoints[],$childJoints[],$historyNodes[],$skinClusterJoints[],$infs[];
string $allJointChildren[],$edgeLoopVtxs[],$allEdgeLoopVtxs[],$allNonPartEdgeLoopVtxs[],$neighbourVtxs[];
string $skinCluster,$weightTo,$cutName,$twistJoint;
string $skinLoopSets[]=`sets -q SkinLoops`;
$skinLoopSets=`sort $skinLoopSets`;

createNode -n CutUpWIP transform;
sets -em -n SkinLoopWeighted;
if ($createCutUp && !`objExists CutUp`)
	{
	createDisplayLayer -e -name CutUp;
	setAttr CutUp.color 29;
	setAttr CutUp.displayType 2;
	}
if (!`objExists CutUpGeometry`)
	createNode -n CutUpGeometry -p Geometry transform;

string $skinLoopObjects[];
select SkinLoops;
$tempString=`ls -sl -o`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	if (!`stringArrayCount $tempString2[0] $skinLoopObjects`)
		$skinLoopObjects[size($skinLoopObjects)]=$tempString2[0];
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (!`stringArrayCount $sel[$i] $skinLoopObjects`)
		{
		print ("// SkinLoops not defined for \""+$sel[$i]+"\", skipping this\n");
		continue;
		}
	if ($createCutUp)
		{//temp geo, to maintain weights on original
		duplicate -n ($sel[$i]+"CutUp") $sel[$i];
		$tempString=`listRelatives -s ($sel[$i]+"CutUp")`;
		for ($w=0;$w<size($tempString);$w++)
			if (`getAttr ($tempString[$w]+".intermediateObject")`)
				delete $tempString[$w];
		$sel[$i]=$sel[$i]+"CutUp";
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			$tempString=`duplicate $skinLoopSets[$y]`;
			rename $tempString[0] ($skinLoopSets[$y]+"CutUp");

			select $skinLoopSets[$y];
			$tempString=`ls -sl -fl`;
			for ($t=0;$t<size($tempString);$t++)
				if (`gmatch $tempString[$t] ($sel[$i]+"[.]*")`)
					{
					sets -add ($skinLoopSets[$y]+"CutUp") $tempString[$t];
					sets -rm $skinLoopSets[$y] $tempString[$t];
					}
			}

		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			rename $skinLoopSets[$y] ($skinLoopSets[$y]+"Temp");
			rename ($skinLoopSets[$y]+"CutUp") $skinLoopSets[$y];
			}
		}
	$haveSkinCluster=0;
	$tempInt=`polyEvaluate -v $sel[$i]`;
	$numVtxs=$tempInt[0];
	if (!$createCutUp)
		$historyNodes=`listHistory $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if ($haveSkinCluster)
		skinPercent -tv Root_M 1 $skinCluster $sel[$i];
	else
		{
		select Root_M $sel[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		$skinClusterJoints=`listConnections ($skinCluster+".matrix")`;
		$deformJoints[$y]=`substitute "SkinLoops_" $skinLoopSets[$y] ""`;
		$parentJoints[$y]=$childJoints[$y]="";
		$twistJoints[$y]=0;

		$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$parentJoints[$y]=$tempString[0];
		$tempString=`listRelatives -c -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$childJoints[$y]=$tempString[0];
		if (!`stringArrayCount $deformJoints[$y] $skinClusterJoints`)
			{
			skinCluster -e -lw false -wt 0 -ai $deformJoints[$y] $skinCluster;
			$skinClusterJoints[size($skinClusterJoints)]=$deformJoints[$y];
			}
		if ($parentJoints[$y]!="")
			if (!`stringArrayCount $parentJoints[$y] $skinClusterJoints`)
				{
				skinCluster -e -lw false -wt 0 -ai $parentJoints[$y] $skinCluster;
				$skinClusterJoints[size($skinClusterJoints)]=$parentJoints[$y];
				}
		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		refresh;
		skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
		sets -add SkinLoopWeighted `ls -sl`;
		}
	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl`;
	select ($sel[$i]+".vtx[0:"+$numVtxs+"]");
	select -d $loopVtxs;
	$nonLoopVtx=`ls -sl -fl`;
	refresh;
	weightHammerVerts;

	//another round of hammer, just near loops, to improve chance of finding $DownSideVtx
	select $loopVtxs;
	GrowPolygonSelectionRegion;
	select -d $loopVtxs;
	weightHammerVerts;

	select SkinLoops;
	ConvertSelectionToVertices;
	$allEdgeLoopVtxs=`ls -sl`;

	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		if (!`gmatch $skinLoopSets[$y] "*Part[0-9]_*"`)
			select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	$allNonPartEdgeLoopVtxs=`ls -sl`;

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		$edgeLoopVtxs=`ls -sl -fl`;
		select $edgeLoopVtxs[0];
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $allEdgeLoopVtxs;
		$neighbourVtxs=`ls -sl -fl`;

		$allJointChildren=`listRelatives -ad -type joint $deformJoints[$y]`;
		for ($z=0;$z<size($neighbourVtxs);$z++)
			{
			if (`sets -im SkinLoopWeighted $neighbourVtxs[$z]`)
				continue;
			$foundDownSideVtx=0;
			select $neighbourVtxs[$z];
			$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $neighbourVtxs[$z]`;
			for ($q=0;$q<size($infs);$q++)
				{//size($infs)==1 means EndPiece
				if (`stringArrayCount $infs[$q] $allJointChildren` || size($infs)==1)
					{
					$cutName=$deformJoints[$y]+"_"+$infs[$q]+"_Cut";
					$foundDownSideVtx=1;
					break;
					}
				}
			if (`objExists ($cutName+"WIP")` || `objExists ($infs[$q]+"_"+$deformJoints[$y]+"_CutWIP")`)
				continue;
			if ($foundDownSideVtx)
				{
				$numSel=0;
				$previousNumSel=-1;
				for ($q=0;$q<100;$q++)
					{
					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
//					select -d $allNonPartEdgeLoopVtxs;
					select -d $allEdgeLoopVtxs;
					$numSel=size(`ls -sl -fl`);
					if ($numSel==$previousNumSel)
						break;
					$previousNumSel=$numSel;
					if ($skinLoopSets[$y]!="SkinLoops_Root_M")
						$z=99;//dont need to check the other $neighbourVtxs
					}
				refresh;

				$tempString=`ls -sl -fl`;
				createNode -n ($cutName+"WIP") -p CutUpWIP transform;
				select $tempString;
				if (!$createCutUp)
					{
					if (!$twistJoints[$y])
						skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
					if ($twistJoints[$y]==2)// Only works with TwistJoints==2 For Now.
						{
						tokenize $deformJoints[$y] "_" $tempString2;
						for ($w=1;$w<$twistJoints[$y]+1;$w++)
							{
							$twistJoint=$tempString2[0]+"Part"+$w+"_"+$tempString2[1];
							if (!`stringArrayCount $twistJoint $skinClusterJoints`)
								{
								skinCluster -e -lw false -wt 0 -ai $twistJoint $skinCluster;
								$skinClusterJoints[size($skinClusterJoints)]=$twistJoint;
								}
							}
						for ($w=0;$w<size($tempString);$w++)
							{
							$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $tempString[$w]`;
							$values=`skinPercent -ignoreBelow 0.0000001 -q -v $skinCluster $tempString[$w]`;
							$tempString2=`listRelatives -ad -type joint $infs[0]`;
							if (`stringArrayCount $infs[1] $tempString2`)
								$ratio=$values[0];
							else
								$ratio=$values[1];
							tokenize $deformJoints[$y] "_" $tempString2;
							skinPercent -tv ($tempString2[0]+"Part1_"+$tempString2[1]) $ratio 
													-tv ($tempString2[0]+"Part2_"+$tempString2[1]) (1-$ratio)
													$skinCluster $tempString[$w];
							}
						}
					select $tempString;
					sets -add SkinLoopWeighted `ls -sl`;
					}
				if ($createCutUp)
					{
					ConvertSelectionToFaces;
					$tempString=`ls -sl`;
					if (`objExists $cutName`)
						delete $cutName;
					duplicate -n ($cutName+"WS") $sel[$i];
					asLockAttr ($cutName+"WS") 0 0 0 0;
					$tempString2=`listRelatives -s ($cutName+"WS")`;
					for ($w=0;$w<size($tempString2);$w++)
						if (`getAttr ($tempString2[$w]+".intermediateObject")`)
							delete $tempString2[$w];					

						//transform to joint-space
					duplicate -n $cutName ($cutName+"WS");
					parent -r $cutName $deformJoints[$y];
					parent -w $cutName;
					select ($cutName+"WS") $cutName;
					blendShape -frontOfChain -origin world -w 0 1;
					select $cutName;
					DeleteHistory;
					delete ($cutName+"WS");

//					parent $cutName $deformJoints[$y];
					parent $cutName CutUpGeometry;

					editDisplayLayerMembers -noRecurse CutUp $cutName;
					select -cl;
					for ($q=0;$q<size($tempString);$q++)
						select -add `substitute $sel[$i] $tempString[$q] $cutName`;
					asInvertSelection;
					delete;
					select $cutName;
					CenterPivot;
					//cap
					for ($r=0;$r<size($skinLoopSets);$r++)
						{
						select $skinLoopSets[$r];
						$tempString=`ls -sl -o`;
						$loopAffectsCut=0;
						for ($t=0;$t<size($tempString);$t++)
							{
							$tempString2=`listRelatives -p $tempString[$t]`;
							if ($tempString2[0]==$cutName)
								{
								$loopAffectsCut=1;
								break;
								}
							}
						if (!$loopAffectsCut)
							continue;
						select -d ($sel[$i]+".e[0:99999]");
						//get radius of loop
						$circumference=0;
						$tempString=`ls -sl -fl`;
						for ($t=0;$t<size($tempString);$t++)
							{
							select $tempString[$t];
							ConvertSelectionToVertices;
							$tempString2=`ls -sl -fl`;
							$posA=`xform -q -ws -t $tempString2[0]`;
							$posB=`xform -q -ws -t $tempString2[1]`;
							$circumference+=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
							}
						$radius=($circumference/3.14)/2.0;
						select $skinLoopSets[$r];
						select -d ($sel[$i]+".e[0:99999]");
						$tempString=`polyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -pvx 1.927402496 -pvy 3.865962148 -pvz 0.184265554 -divisions 1 -twist 0 -taper 1 -offset 0 -thickness 0 -smoothingAngle 30`;
						$extrudedSel=`ls -sl`;
						setToolTo $gMove;
						$pos=`manipMoveContext -q -position "Move"`;
						scale -r -p $pos[0] $pos[1] $pos[2] 0.25 0.25 0.25;
						$posB=`xform -q -ws -piv $cutName`;
						spaceLocator -n tempLoc1;
						xform -ws -t $posB[0] $posB[1] $posB[1] tempLoc1;
						spaceLocator -n tempLoc2;
						xform -ws -t $pos[0] $pos[1] $pos[1] tempLoc2;	
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempLoc2 tempLoc1;
						parent $cutName tempLoc1;
						select $extrudedSel;
						move -r -ls -wd ($radius*0.5) 0 0;
						parent $cutName CutUpGeometry;
						parentConstraint -mo $deformJoints[$y] $cutName;
						scaleConstraint $deformJoints[$y] $cutName;
						delete tempLoc1 tempLoc2;
						select $cutName;
						DeleteHistory;
						sets -rm $skinLoopSets[$r] ($cutName+".e[0:99999]");
						}
					}
				}
			}
		}

	if (!$createCutUp)
		{
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			//Check that skinLoops comes from this object
			$tempString=`sets -q $skinLoopSets[$y]`;
			if (!size($tempString))
				continue;
			tokenize $tempString[0] "[.]" $tempString;
			if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
			if ($tempString[0]!=$sel[$i])
				continue;
			if (`gmatch $deformJoints[$y] "*Part[0-9]_*"`)//skip 50 weight of partial joint
				continue;

			select $skinLoopSets[$y];
			ConvertSelectionToVertices;
			$tempString2=`ls -sl`;
			$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
			if (size($tempString))
				skinPercent -tv $deformJoints[$y] 0.5 -tv $tempString[0] 0.5 $skinCluster `ls -sl`;
			GrowPolygonSelectionRegion;
//			select -d $tempString2;
			select -d $loopVtxs;
			if (size(`ls -sl`))
				weightHammerVerts;
			}
		}
	if ($createCutUp)
		{
		delete $sel[$i];
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			if (`objExists $skinLoopSets[$y]`)
				delete $skinLoopSets[$y];
			rename ($skinLoopSets[$y]+"Temp") $skinLoopSets[$y];
			}
		}

	if (!$createCutUp)
		{
		select $sel[$i];
		removeUnusedInfluences;
		}
	}


delete CutUpWIP SkinLoopWeighted;
select -cl;
catchQuiet (`select $sel`);
if ($createCutUp)
	print "// SkinLoop CutUp completed.\n";
else
	print "// SkinLoop Bind completed.\n";
}

global proc asCopySkinLoopWeights ()
{
string $sel[]=`ls -sl`;

if (!`objExists SkinLoops`)
	error "SkinLoops not created";

int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster,$sourceSC;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

select SkinLoops;
select `ls -sl -o`;
$tempString=`ls -sl`;
string $source=$tempString[0];
$tempString=`ls -sl -showType $source`;
if ($tempString[1]=="mesh")
	{
	$tempString=`listRelatives -p $source`;
	$source=$tempString[0];
	}
$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$sourceSC=$history[$y];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r  $source;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc string asStripSystemLetter (string $system)
{
string $systemNoLetter=$system;
int $numLetters=size($system);
if (`gmatch $system "*[A-Z]"`)
	$systemNoLetter=`substring $system 1 ($numLetters-1)`;
return $systemNoLetter;
}

global proc int asConfirmIfNotInBuildPose () //OPM ?
{
if (!`objExists DeformSet`)
	return 1;
int $proceed=1;
int $maxTextLines=35;
int $numNonDef;
int $opm=`asGetOpm`;
float $checkValues[];
string $m,$ctrl;
string $controls[],$checkAttr[];
string $deformJointsList[]=`sets -q DeformSet`;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

//if buildPose.udAttr is missing, then "Go to Build Pose, and Proceed" would Error, so skip as we might be running a auto-cleanup-before-build
if (!`attributeExists udAttr buildPose`)
	return 1;

if ($opm)//zero xform-values and Offsets within matrix, so check ctrls instead of deform-joints
	{
	$checkAttr={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
	$checkValues={0,0,0,0,0,0,1,1,1};
	if (`objExists ControlSet`)
		$controls=`sets -q ControlSet`;
	for ($i=0;$i<size($controls);$i++)
		{
		$ctrl=$controls[$i];
		for ($y=0;$y<size($checkAttr);$y++)
			{
			if (!`getAttr -settable ($ctrl+"."+$checkAttr[$y])`)
				continue;
			$value=`getAttr ($ctrl+"."+$checkAttr[$y])`;
			if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
				{
				$m+=$ctrl+"."+$checkAttr[$y]+" = "+$value+"\n";
				$numNonDef++;
				}
			if ($numNonDef>$maxTextLines)
				{
				$m+="...And more..\n\n";
				$y=999;
				$i=999;
				}
			}

		}
	}
else
	{
	$checkAttr={"rx","ry","rz","sx","sy","sz"};
	$checkValues={0,0,0,1,1,1};
	for ($i=0;$i<size($deformJointsList);$i++)
		{
		if (`attributeExists partialJoint $deformJointsList[$i]`)
			continue;
		for ($y=0;$y<size($checkAttr);$y++)
			{
			$value=`getAttr ($deformJointsList[$i]+"."+$checkAttr[$y])`;
			if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
				{
				$m+=$deformJointsList[$i]+"."+$checkAttr[$y]+" = "+$value+"\n";
				$numNonDef++;
				}
			if ($numNonDef>$maxTextLines)
				{
				$m+="...And more..\n\n";
				$y=999;
				$i=999;
				}
			}
		}
	//Also check Main
	for ($i=0;$i<9;$i++)
		{
		if ($i==0) $ctrl="Main";
		else $ctrl="MainExtra"+$i;
		if (!`objExists $ctrl`)
			break;
		for ($y=0;$y<size($trs);$y++)
			{
			if ($y==2) $defaultValue=1;
			else $defaultValue=0;
			for ($z=0;$z<size($xyz);$z++)
				{
				$value=`getAttr ($ctrl+"."+$trs[$y]+$xyz[$z])`;
				if ($value!=$defaultValue)
					$m+=$ctrl+"."+$trs[$y]+$xyz[$z]+" = "+$value+"\n";
				}
			}
		}
	}

if ($m!="")
	{
	$m+="It is reccomended that you Go to Build Pose";
	string $dialog=`confirmDialog -t "Not in Build Pose"
		-m $m
		-b "Go to Build Pose, and Proceed"
		-b "Just Proceed"
		-b "Cancel"
		-ds "Cancel" -db "Cancel"`;
	if ($dialog=="Go to Build Pose, and Proceed")
		{
		asGoToBuildPose bodySetup;
		refresh;
		}
	if ($dialog=="Go to Build Pose, and Proceed")
		$proceed=1;
	else if ($dialog=="Just Proceed")
		$proceed=2;
	else
		$proceed=0;
	}
return $proceed;
}

global proc int asGetCurveNumCvs (string $curve)
{
int $form,$spans,$degrees,$numCv;
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;
return $numCv;
}

global proc float asgetCharHeight ()
{
float $height;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
return $height;
}

global proc asSetMoCapWSOrient (float $x, float $y, float $z, string $transform, string $nameSpace)
{
string $tempString[];

if (!`objExists $transform`)
	return;
if (`objExists tempXform`) delete tempXform;
createNode -n tempXform transform;
orientConstraint $transform tempXform;
asSetOrientOffsetFromAxis tempXform_orientConstraint1 $transform ($nameSpace+"Main");
delete tempXform_orientConstraint1;
$tempString=`orientConstraint -mo tempXform $transform`;
xform -ws -ro $x $y $z tempXform;
delete $tempString[0];
delete tempXform;
}

global proc asSetOrientOffsetFromAxis (string $constraint, string $joint, string $FitSkeletonOrMain)
{
float $NegPriYAdd,$NegSecXAdd,$NegSecXAdd;
float $NegPriMult=1;
string $priAxis=`asGetAxis primary   $joint $FitSkeletonOrMain 0`;
string $secAxis=`asGetAxis secondary $joint $FitSkeletonOrMain 0`;
string $attr="offset";

if (`objectType $constraint`=="parentConstraint")
	$attr="target[0].targetOffsetRotate";

if (`gmatch $priAxis "-*"`) {$NegPriMult=-1;$NegPriYAdd=180;}
if (`gmatch $secAxis "-*"`) $NegSecXAdd=180;//re-added

if (`gmatch $priAxis "*X"` && `gmatch $secAxis "*Y"`) setAttr -type float3 ($constraint+"."+$attr) $NegSecXAdd $NegPriYAdd   0;
if (`gmatch $priAxis "*X"` && `gmatch $secAxis "*Z"`) setAttr -type float3 ($constraint+"."+$attr)  ($NegSecXAdd+(90*$NegPriMult)) $NegPriYAdd   0;
if (`gmatch $priAxis "*Y"` && `gmatch $secAxis "*Z"`) setAttr -type float3 ($constraint+"."+$attr)  ($NegSecXAdd+(90*$NegPriMult)) $NegPriYAdd  90;
if (`gmatch $priAxis "*Y"` && `gmatch $secAxis "*X"`) setAttr -type float3 ($constraint+"."+$attr) ($NegSecXAdd+(180*$NegPriMult)) $NegPriYAdd  90;
if (`gmatch $priAxis "*Z"` && `gmatch $secAxis "*X"`) setAttr -type float3 ($constraint+"."+$attr) ($NegSecXAdd+(-90*$NegPriMult)) ($NegPriYAdd-90)   0;
if (`gmatch $priAxis "*Z"` && `gmatch $secAxis "*Y"`) setAttr -type float3 ($constraint+"."+$attr) $NegSecXAdd ($NegPriYAdd-90)   0;
}

global proc asCreateSkeleton ()
{
float $secNrml[3];
string $fitSkeletonTemplate;
string $secAxis;

if (`objExists SkeletonGeometry`)
	error "SkeletonGeometry already exists";

if (`attributeExists fitSkeletonTemplate FitSkeleton`)
	$fitSkeletonTemplate=`getAttr FitSkeleton.fitSkeletonTemplate`;

createNode -n SkeletonGeometry -p Geometry transform;
createDisplayLayer -e -name PolySkeleton;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asGeometry.ma";
file -i $asGeometryFile;

int $numChar,$hasBone,$b;
int $vs[];
float $dist,$dist2,$dist3;
float $pos[],$pos2[],$pos3[],$scale[];
string $newBone;
string $tempString[],$joints[],$children[];
string $deformJointsList[]=`sets -q "DeformSet"`;
string $copyBones[]={"Pelvis","Cranium","SpineVertebras","Mandible","Femur","Tibia","Fibula",
	"Calcaneus","Talus","Metatarsals","Phalanxs","Ribs","Humerus","Scapula","Clavicle","Ulna","Radius","CarpalA","CarpalB","Eye"};
string $joint,$side,$childJoint,$parentJoint,$sourceBone;

for ($i=0;$i<size($copyBones);$i++)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $side="_M";
		if ($a==1) $side="_L";
		if ($a==2) $side="_R";
		$b=1;
		if ($side=="_L") $b=-1;
//		$joint=$copyBones[$i]+$side;
		if ($copyBones[$i]=="Pelvis") $joint="Root"+$side;
		if ($copyBones[$i]=="SpineVertebras") $joint="Root"+$side;
		if ($copyBones[$i]=="Cranium") $joint="Head"+$side;
		if ($copyBones[$i]=="Mandible") $joint="Jaw"+$side;
		if ($copyBones[$i]=="Femur") $joint="Hip"+$side;
		if ($copyBones[$i]=="Tibia") $joint="Knee"+$side;
		if ($copyBones[$i]=="Fibula") $joint="Knee"+$side;
		if ($copyBones[$i]=="Calcaneus") $joint="Ankle"+$side;
		if ($copyBones[$i]=="Talus") $joint="Ankle"+$side;
		if ($copyBones[$i]=="Metatarsals") $joint="Toes"+$side;
		if ($copyBones[$i]=="Phalanxs") $joint="Toes"+$side;
		if ($copyBones[$i]=="Ribs") $joint="Chest"+$side;
		if ($copyBones[$i]=="Humerus") $joint="Shoulder"+$side;
		if ($copyBones[$i]=="Scapula") $joint="Scapula"+$side;
		if ($copyBones[$i]=="Clavicle") $joint="Scapula"+$side;
		if ($copyBones[$i]=="Ulna") $joint="Elbow"+$side;
		if ($copyBones[$i]=="Radius") $joint="Elbow"+$side;
		if ($copyBones[$i]=="CarpalA") $joint="Wrist"+$side;
		if ($copyBones[$i]=="CarpalB") $joint="Wrist"+$side;
		if ($copyBones[$i]=="Eye") $joint="Eye"+$side;

		if ($fitSkeletonTemplate=="horse" || $fitSkeletonTemplate=="cat")
			{
			if ($copyBones[$i]=="Clavicle") $joint="";
			if ($copyBones[$i]=="CarpalA") $joint="";
			if ($copyBones[$i]=="CarpalB") $joint="";
			if ($copyBones[$i]=="Calcaneus") $joint="";
			if ($copyBones[$i]=="Talus") $joint="";
			if ($copyBones[$i]=="Metatarsals") $joint="";
			if ($copyBones[$i]=="Phalanxs") $joint="";
			}

		if (!`objExists $joint` || !`objExists ($copyBones[$i]+"Bone")`)
			continue;
		if (`objectType $joint`!="joint")
			continue;

		//fitSkeletonTemplate spesific bones
		if ($fitSkeletonTemplate!="" && `objExists ($fitSkeletonTemplate+$copyBones[$i]+"Bone")`)
			{
			delete ($copyBones[$i]+"Bone");
			rename ($fitSkeletonTemplate+$copyBones[$i]+"Bone") ($copyBones[$i]+"Bone");
			$tempString=`listRelatives -ad -type transform ($copyBones[$i]+"Bone")`;
			for ($y=0;$y<size($tempString);$y++)
				if (`gmatch $tempString[$y] ("*"+$fitSkeletonTemplate+"*")`)
					rename $tempString[$y] (`substitute $fitSkeletonTemplate $tempString[$y] ""`);
			}

		duplicate -n ($copyBones[$i]+"Bone"+$side) ($copyBones[$i]+"Bone");
		parent ($copyBones[$i]+"Bone"+$side) SkeletonGeometry;

		$tempString=`parentConstraint $joint ($copyBones[$i]+"Bone"+$side)`;
		asSetOrientOffsetFromAxis $tempString[0] $joint Main;
		delete $tempString[0];

		setAttr ($copyBones[$i]+"Bone"+$side+".v") 1;
//		sets -e -forceElement asBonesSG ($copyBones[$i]+"Bone"+$side);
		editDisplayLayerMembers -noRecurse PolySkeleton ($copyBones[$i]+"Bone"+$side);
		$childJoint=`asRlaChild $joint`;
		if ($copyBones[$i]=="SpineVertebras")
			{
			if (`objExists Head_M`) $childJoint="CraniumBone"+$side+"|CraniumBoneNeck";
			else if (`objExists Neck_M`) $childJoint="Neck_M";
			else if (`objExists Neck0_M`) $childJoint="Neck0_M";
			else if (`objExists Chest_M`) $childJoint="Chest_M";
			}
		if (($copyBones[$i]=="Cranium" || $copyBones[$i]=="Mandible")  && `objExists HeadEnd_M`) $childJoint="HeadEnd_M";
		if ($copyBones[$i]=="Femur"  && `objExists ("Knee"+$side)`) $childJoint="Knee"+$side;
		if (($copyBones[$i]=="Tibia" || $copyBones[$i]=="Fibula")  && `objExists ("Ankle"+$side)`) $childJoint="Ankle"+$side;
		if ($copyBones[$i]=="Humerus"  && `objExists ("Elbow"+$side)`) $childJoint="Elbow"+$side;
		if (($copyBones[$i]=="Ulna" || $copyBones[$i]=="Radius")  && `objExists ("Wrist"+$side)`) $childJoint="Wrist"+$side;
		if (($copyBones[$i]=="CarpalA"  || $copyBones[$i]=="CarpalB") && `objExists ("MiddleFinger1"+$side)`) $childJoint="MiddleFinger1"+$side;
		if ($childJoint!="")
			{
			$pos=`xform -q -ws -t $joint`;
			$pos2=`xform -q -ws -t $childJoint`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			$scale[0]=$dist;
			if (`attributeExists "fatFront" $joint`)
				{
				$scale[1]=`getAttr ($joint+".fat")`*`getAttr ($joint+".fatFront")`;
				$scale[2]=`getAttr ($joint+".fat")`*`getAttr ($joint+".fatWidth")`;
				}
			else
				$scale[1]=$scale[2]=$scale[0];
			xform -os -a -s $scale[0] $scale[1] $scale[2] ($copyBones[$i]+"Bone"+$side);
			}
		if ($side=="_L")
			{
			$pos=`xform -q -ws -t $joint`;
			scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($copyBones[$i]+"Bone"+$side);
			}

		//Spine / neck
		if ($copyBones[$i]=="SpineVertebras")
			{
			if (`objExists Root_M` && `objExists $childJoint`)
				{
				$secAxis=`asGetAxis secondary Root_M Main 0`;
				$secNrml=`asAxisToVector $secAxis`;
				delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector $secNrml[0] $secNrml[1] $secNrml[2] -worldUpObject Root_M $childJoint SpineVertebrasBone_M`;
				}
			$scale[0]=`getAttr SpineVertebrasBone_M.sx`;
			setAttr -type float3 SpineVertebrasBone_M.s $scale[0] $scale[0] $scale[0];
			//Coccyx
			select ("SpineVertebrasBone"+$side+"Shape");
			$tempString=`asDeformer softMod`;
			rename $tempString[0] FixSoftMod;
			rename $tempString[1] FixSoftModHandle;
			$pos=`xform -q -ws -t ("SpineVertebrasBone"+$side+"|SpineVertebrasCoccyx")`;
			$pos2=`xform -q -ws -t ("Root"+$side)`;
			$pos3=`xform -q -ws -t PelvisBone_M|PelvisBoneFemur`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
			setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
			xform -piv $pos2[0] $pos2[1] $pos2[2] FixSoftModHandle;
			setAttr FixSoftMod.falloffRadius $dist;
			setAttr FixSoftMod.falloffMode 0;
			$scale[0]=`mag<<$pos2[0]-$pos3[0],$pos2[1]-$pos3[1],$pos2[2]-$pos3[2]>>`/$dist;
			setAttr -type float3 FixSoftModHandle.s $scale[0] $scale[0] $scale[0];
			select ("SpineVertebrasBone"+$side+"Shape");
			DeleteHistory;
			//Run-through Chest joint
			if (`objExists Root_M` && `objExists Chest_M`)
				{
				select ("SpineVertebrasBone"+$side+"Shape");
				$tempString=`asDeformer softMod`;
				rename $tempString[0] FixSoftMod;
				rename $tempString[1] FixSoftModHandle;
				$pos=`xform -q -ws -t Root_M`;
				$pos2=`xform -q -ws -t Chest_M`;
				$pos3=`xform -q -ws -t Head_M`;
				$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
				$dist2=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
				$dist3=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
				if (`objExists tempLoc`) delete tempLoc;
				spaceLocator -n tempLoc;
				createNode -n tempMotionPath motionPath;
				setAttr tempMotionPath.fractionMode 1;
				connectAttr SpineVertebrasBone_M|SpineVertebrasCurve.worldSpace tempMotionPath.geometryPath;
				connectAttr tempMotionPath.allCoordinates tempLoc.t;
				setAttr tempMotionPath.uValue ($dist/$dist2);
				$pos=`xform -q -ws -t tempLoc`;
				delete tempLoc tempMotionPath;
				setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
				setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
				xform -piv $pos[0] $pos[1] $pos[2] FixSoftModHandle;
				setAttr FixSoftMod.falloffRadius ($dist3/2.0);
				setAttr FixSoftMod.falloffMode 0;
				delete `pointConstraint Chest_M FixSoftModHandle`;
				select ("SpineVertebrasBone"+$side+"Shape");
				DeleteHistory;
				}
			}

		//Scapula
		if ($copyBones[$i]=="Scapula" && `objExists ("HumerusBone"+$side)` && `objExists RibsBone_M`)
			if ($fitSkeletonTemplate!="horse" && $fitSkeletonTemplate!="cat")
				{
				$dist=`getAttr ("HumerusBone"+$side+".sx")`;
				setAttr -type float3 ("ScapulaBone"+$side+".s") $dist $dist $dist;

				duplicate -n ("ScapulaBone"+$side+"_Copy") ("ScapulaBone"+$side);
				parent -w ("ScapulaBone"+$side+"_Copy");
				catchQuiet (`makeIdentity -a 1 -t 1 -r 1 -s 1 ("ScapulaBone"+$side+"_Copy")`);

				select ("ScapulaBone"+$side+"_CopyShape");
				$tempString=`asDeformer softMod`;
				rename $tempString[0] FixSoftMod;
				rename $tempString[1] FixSoftModHandle;
				$pos=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneLoc1")`;
				$pos2=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneLoc2")`;
				$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
				setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
				setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
				xform -piv $pos[0] $pos[1] $pos[2] FixSoftModHandle;
				setAttr FixSoftMod.falloffRadius $dist;
				setAttr FixSoftMod.falloffMode 0;
				setAttr FixSoftMod.falloffInY 0;
				$pos3=`xform -q -ws -t ("RibsBone_M|RibsBoneLoc1")`;
				move -r 0 0 (($pos3[2]-$pos[2])*1.2) FixSoftModHandle;
				select ("ScapulaBone"+$side+"_CopyShape") ("ScapulaBone"+$side+"Shape");
				blendShape -n TempBS -w 0 1;
				setAttr TempBS.origin 0;
				select ("ScapulaBone"+$side);
				DeleteHistory;
				delete ("ScapulaBone"+$side+"_Copy");
				}

		//Clavicle
		if ($copyBones[$i]=="Clavicle" && `objExists ("ScapulaBone"+$side)` && `objExists RibsBone_M`)
			{
			$secAxis=`asGetAxis secondary Chest_M Main 0`;
			$secNrml=`asAxisToVector $secAxis`;
			$pos=`xform -q -ws -t ("RibsBone_M|RibsBoneClavicle")`;
			xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ("ClavicleBone"+$side);
			$pos2=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneClavicle")`;
			$pos2[0]=$pos2[0]*$b;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			$scale[0]=$dist*$b;
			xform -os -a -s $scale[0] $scale[0] $scale[0] ($copyBones[$i]+"Bone"+$side);
			delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($b) 0 0 -upVector 0 $b 0 -worldUpType "objectrotation" -worldUpVector $secNrml[0] $secNrml[1] $secNrml[2] -worldUpObject Chest_M ("ScapulaBone"+$side+"|ScapulaBoneClavicle") ($copyBones[$i]+"Bone"+$side)`;
			}

		//PelvisBone
		if ($copyBones[$i]=="Pelvis")
			{
			xform -ws -ro 0 0 0 PelvisBone_M;
			$tempString=`listRelatives -type joint -c Root_M`;
			for ($y=0;$y<size($tempString);$y++)
				if (`gmatch $tempString[$y] "*_R"`)
					{
					$pos=`xform -q -ws -t $tempString[$y]`;
					xform -ws -t 0 $pos[1] $pos[2] PelvisBone_M;
					$pos2=`xform -q -ws -t PelvisBone_M|PelvisBoneFemur`;
					xform -r -s ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) PelvisBone_M;
					$scale[0]=`getAttr PelvisBone_M.sx`;
					setAttr -type float3 PelvisBone_M.s $scale[0] $scale[0] $scale[0];
					}
			}

		//Cranium
		if ($copyBones[$i]=="Cranium" && `objExists Eye_R`)
			{
			$pos=`xform -q -ws -t Eye_R`;
			$pos2=`xform -q -ws -t ("CraniumBone"+$side+"|CraniumBoneEye")`;
			scale -r ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) CraniumBone_M;
			$scale[0]=`getAttr CraniumBone_M.sz`;
			setAttr -type float3 CraniumBone_M.s $scale[0] $scale[0] $scale[0];
			$pos2=`xform -q -ws -t ("CraniumBone"+$side+"|CraniumBoneEye")`;
			move -r 0 ($pos[1]-$pos2[1]) 0 CraniumBone_M;
			}

		//Mandible
		if ($copyBones[$i]=="Mandible" && `objExists CraniumBone_M`)
			{
			asAlign MandibleBone_M CraniumBone_M 1 1 0 0;
			$scale=`getAttr CraniumBone_M.s`;
			setAttr -type float3 MandibleBone_M.s $scale[0] $scale[0] $scale[0];
			}

		//Ankle
		if ($copyBones[$i]=="Calcaneus" && `objExists Toes` && `objExists Ankle` && `objExists Heel`)
			{
			$pos=`xform -q -ws -t ("Ankle"+$side)`;
			$pos2=`xform -q -ws -t ("CalcaneusBone"+$side+"|CalcaneusBoneLoc1")`;
			$dist=($pos[1]/($pos[1]-$pos2[1]))*0.95;
			scale -r $dist 1 $dist ("CalcaneusBone"+$side);
			$pos2=`xform -q -ws -t ("CalcaneusBone"+$side+"|CalcaneusBoneLoc2")`;
			$pos3=`xform -q -ws -t Heel`;
			$dist=(($pos[2]-$pos3[2])/($pos[2]-$pos2[2]))*0.9;
			scale -r 1 $dist 1 ("CalcaneusBone"+$side);
			setAttr ("CalcaneusBone"+$side+".sz") `getAttr ("CalcaneusBone"+$side+".sy")`;
			}
		if ($copyBones[$i]=="Talus")
			{
			$scale[0]=`getAttr ("CalcaneusBone"+$side+".sy")`;
			setAttr -type float3 ("TalusBone"+$side+".s") $scale[0] $scale[0] $scale[0];
			}

		//Metatarsals
		if (($copyBones[$i]=="Metatarsals" || $copyBones[$i]=="Phalanxs") && `objExists Toes` && `objExists Ankle`)
			{
			$scale[0]=`getAttr ("TalusBone"+$side+".sx")`;
	//		$scale[0]=(`getAttr ("Ankle"+$side+".fat")`*`getAttr ("Ankle"+$side+".fatWidth")`)/1.5*$b;
			setAttr ($copyBones[$i]+"Bone"+$side+".sy") $scale[0];
			setAttr ($copyBones[$i]+"Bone"+$side+".sz") $scale[0];
			}
		if ($copyBones[$i]=="Metatarsals" && `objExists Toes` && `objExists Ankle`)
			{
			select ("MetatarsalsBone"+$side+"Shape");
			$tempString=`lattice  -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
	//		setAttr ($tempString[0]+".outsideLattice") 1;
			parent $tempString[1] $tempString[2] ("MetatarsalsBone"+$side+"|MetatarsalsBoneLattice");
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $tempString[1] $tempString[2];
			$pos=`xform -q -ws -t ("MetatarsalsBone"+$side+"|MetatarsalsBoneToes")`;
			$pos2=`xform -q -ws -t ("TalusBone"+$side+"|TalusBoneToes")`;

			select -r ($tempString[1]+".pt[0][0:1][0]") ($tempString[1]+".pt[0][0:1][1]");
			move -r ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]);
			select ("MetatarsalsBone"+$side);
			DeleteHistory;
			}

		//Bind: Bind-to Bones - selection
		select ($copyBones[$i]+"Bone"+$side) $joint;
		$childJoint=`asRlaChild $joint`;
		while (`gmatch $childJoint "*Part[0-9]*"`)
			{
			select -add $childJoint;
			$tempString=`listRelatives -c -type joint $childJoint`;
			$childJoint=$tempString[0];
			}

		//Bind: Bind-to Bones - tweaks
		if ($copyBones[$i]=="SpineVertebras" && `objExists Chest_M`)
			{
			select Chest_M;
			if (`objExists Head_M`)
				select `listRelatives -p Head_M`;
			for ($y=0;$y<99;$y++)
				{
				$tempString=`listRelatives -p`;
				select -add $tempString;
				if (`stringArrayCount "Root_M" $tempString`)
				 break;
				}
			}
		if ($copyBones[$i]=="Metatarsals") {select -r `listRelatives -p $joint`;select -d $joint;}

		//Bind
		select -add ($copyBones[$i]+"Bone"+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($copyBones[$i]+"BoneSC"+$side);

		//Bind: tweak - Carpal (wrist)
		if ($copyBones[$i]=="CarpalA")
			{
			skinCluster -e  -dr 4 -ai `listRelatives -p ("Wrist"+$side)` ("CarpalABoneSC"+$side);
			select -r ("CarpalABone"+$side);
			skinPercent -tv ("Wrist"+$side) 0.5 ("CarpalABoneSC"+$side);
			}
		//Bind: tweak - Jaw_M (with FaceSetup)
		if ($copyBones[$i]=="Mandible")
			{
			$tempString=`listRelatives -p $joint`;
			if ($tempString[0]=="FaceJoint_M")
				{
				select ($copyBones[$i]+"Bone"+$side);
				$tempString=`cluster -n ($copyBones[$i]+"BoneCluster"+$side) -envelope 1`;
				parent ($copyBones[$i]+"BoneCluster"+$side+"Handle") ($copyBones[$i]+"Bone"+$side);
				setAttr ($copyBones[$i]+"BoneCluster"+$side+"Handle.v") 0;
				parentConstraint -mo Head_M ($copyBones[$i]+"BoneCluster"+$side+"Handle");
				scaleConstraint Head_M ($copyBones[$i]+"BoneCluster"+$side+"Handle");
				}
			}
		}

//Fingers (Phalanges & Metacarpal)
$sourceBone="PhalangesBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (!`gmatch $deformJointsList[$i] "*Finger*"`)
		continue;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint=="")
		continue;
	if ($fitSkeletonTemplate=="horse" || $fitSkeletonTemplate=="cat")
		continue;

	$numChar=size($deformJointsList[$i]);
	$newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	$tempString=`parentConstraint $deformJointsList[$i] ($newBone+$side)`;
	asSetOrientOffsetFromAxis $tempString[0] $deformJointsList[$i] Main;
	delete $tempString[0];	
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $childJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatFront")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatWidth")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`gmatch $deformJointsList[$i] "*_L"`)
		{
		$pos=`xform -q -ws -t $deformJointsList[$i]`;
		scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($newBone+$side+".vtx[0:9999]");
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($newBone+$side);
		}
	select $deformJointsList[$i] ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//MetaCarpals
$sourceBone="MetacarpalBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (!`gmatch $deformJointsList[$i] "*Finger1*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*ThumbFinger1*"`)
		continue;
	$tempString=`listRelatives -p $deformJointsList[$i]`;
	$parentJoint=$tempString[0];

	$numChar=size($deformJointsList[$i]);
	string $jointName=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	$newBone=$jointName+"MetacarpalBone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	string $loc="CarpalBBone"+$side+"|CarpalBone"+$jointName;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	$tempString=`parentConstraint $parentJoint ($newBone+$side)`;
	asSetOrientOffsetFromAxis $tempString[0] $parentJoint Main;
	delete $tempString[0];
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	$secAxis=`asGetAxis secondary $deformJointsList[$i] Main 0`;
	$secNrml=`asAxisToVector $secAxis`;
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector $secNrml[0] $secNrml[1] $secNrml[2] -worldUpObject $parentJoint $deformJointsList[$i] ($newBone+$side)`;
	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $parentJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if (`objExists $loc`)
		{// allow space for CarpalBone
		$pos3=`xform -q -ws -t $loc`;
		$dist=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
		}
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatFront")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatWidth")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`objExists $loc`)
		{
		move -r -os -wd `mag<<$pos2[0]-$pos3[0],$pos2[1]-$pos3[1],$pos2[2]-$pos3[2]>>` 0 0 ($newBone+$side+".vtx[0:9999]");
		}
	select $parentJoint ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//Generic
$sourceBone="GenericBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$hasBone=0;
	$tempString=`listConnections -s 0 -d 1 ($deformJointsList[$i]+".worldMatrix")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "*BoneSC_*"`)
			$hasBone=1;
	if ($hasBone)
		continue;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint=="")
		continue;

	$numChar=size($deformJointsList[$i]);
	$newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	$tempString=`parentConstraint $deformJointsList[$i] ($newBone+$side)`;
	asSetOrientOffsetFromAxis $tempString[0] $deformJointsList[$i] Main;
	delete $tempString[0];
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $childJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$scale[0]=$dist;
	if (`attributeExists fatFront $deformJointsList[$i]`)
		$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatFront")`;
	if (`attributeExists fatWidth $deformJointsList[$i]`)
		$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatWidth")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`gmatch $deformJointsList[$i] "*_L"`)
		{
		$pos=`xform -q -ws -t $deformJointsList[$i]`;
		scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($newBone+$side+".vtx[0:9999]");
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($newBone+$side);
		}
	select $deformJointsList[$i] ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//horseCoffinBone
if ($fitSkeletonTemplate=="horse")
	{
	for ($i=0;$i<size($deformJointsList);$i++)
		{
		$numChar=size($deformJointsList[$i]);
		$newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
		$sourceBone="horseCoffinBone";
		$side=`substring $deformJointsList[$i] ($numChar-1) 99`;

		if ((`gmatch $deformJointsList[$i] "Fingers*"` || `gmatch $deformJointsList[$i] "Toes*"`) && `objExists ($newBone+$side)`)
			{
			$pos=`xform -q -ws -t $deformJointsList[$i]`;
			scale -r -p $pos[0] $pos[1] $pos[2] 1 2 2 ($newBone+$side+".vtx[0:9999]");
			}

		if (!(`gmatch $deformJointsList[$i] "*Fingers3_*"` || `gmatch $deformJointsList[$i] "*Toes3_*"`))
			continue;

		if (`objExists ($newBone+$side)`) delete ($newBone+$side);
		duplicate -n ($newBone+$side) $sourceBone;
		parent ($newBone+$side) SkeletonGeometry;
		delete `pointConstraint $deformJointsList[$i] ($newBone+$side) `;
		setAttr ($newBone+$side+".v") 1;
		editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);

		$scale[0]=$scale[1]=$scale[2]=`getAttr ($newBone+$side+".ty")`;
		setAttr ($newBone+$side+".ty") 0;
		xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);

		select $deformJointsList[$i] ($newBone+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($newBone+"BoneSC"+$side);
		}
	}
if ($fitSkeletonTemplate=="cat")
	{
	if (`objExists Toes1Bone_R`) delete Toes1Bone_R;
	if (`objExists Toes1Bone_L`) delete Toes1Bone_L;
	}

$tempString=`listRelatives -f -ad -type locator -type nurbsCurve SkeletonGeometry`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		delete `listRelatives -f -p $tempString[$i]`;

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

//asMirrorGeometry Skeleton 0;

print ("// Skeleton created\n");
select -cl;
}

global proc asDeleteSkeleton ()
{
string $deleteObjs[]={"SkeletonGeometry","PolySkeleton","Skeleton_Geometry","Mannequin_Geometry","SkinCage_Geometry","Skeleton","tempAimAt"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateFromFitGeometry (string $geo)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
if (!`asConfirmIfNotInBuildPose`)
	return;
string $geoLongName="Boxes";
if ($geo=="Cyl")
	$geoLongName="Cylinders";
if ($geo=="Bone")
	$geoLongName="Skeleton";
string $sourceGeo=$geo;
if (`getModifiers`==4)
	$sourceGeo="Cyl";
if (`objExists ($geoLongName+"Geometry")`)
	error ("\""+$geoLongName+"Geometry\" Alread exists");
if (`objExists ("Poly"+$geoLongName)`)
	error ("\"Poly"+$geoLongName+"\" Alread exists");
createNode -n ($geoLongName+"Geometry") -p Geometry transform;
connectAttr -f MainScaleMultiplyDivide.output ($geoLongName+"Geometry.scale");
createDisplayLayer -e -name ("Poly"+$geoLongName);
setAttr ("Poly"+$geoLongName+".color") 14;
if ($geo=="Bone")
	setAttr ("Poly"+$geoLongName+".color") 21;

float $scale=`asGetScale`;
float $sideTreshold=0.01*$scale;
float $visGap=`getAttr FitSkeleton.visGap`;
float $pos[],$rot[];
if (`objExists asMirror`)
	delete asMirror;
//checkBox -e -v 1 asVisGeo;
int $visGeo=`getAttr FitSkeleton.visGeo`;
int $opm=`asGetOpm`;
setAttr FitSkeleton.visGeo 1;
asFitGeometry;
setAttr FitSkeleton.visGeo $visGeo;
setAttr FitSkeleton.visGap 1;
	dgdirty -a;
refresh;
setAttr FitSkeletonVisualizers.v 0;
refresh;

string $joint;
string $aimsAD[]=`listRelatives -ad -type transform Aims`;
for ($i=$y=0;$i<size($aimsAD);$i++)
	if (`gmatch $aimsAD[$i] ("*"+$sourceGeo+"*")`)
		{
		$joint=`substitute $sourceGeo $aimsAD[$i] ""`;
		string $side="_M";
		$pos=`xform -q -ws -t $aimsAD[$i]`;

		if ($pos[0]<$sideTreshold*-1)
			$side="_R";
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==-1 && $side=="_M") continue;
			if ($b==-1 && $side=="_R") $side="_L";

			if (!`objExists ($joint+$side)`)//could be `noMirror`
				continue;

			duplicate -n ($aimsAD[$i]+$side) $aimsAD[$i];
			editDisplayLayerMembers -noRecurse ("Poly"+$geoLongName) ($aimsAD[$i]+$side);
			setAttr ($aimsAD[$i]+$side+".v") 1;
			createNode -n asMirror transform;
			parent ($aimsAD[$i]+$side) asMirror;
			if ($side=="_L")
				{
				setAttr asMirror.sx -1;
				polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($aimsAD[$i]+$side);
//				setAttr ($aimsAD[$i]+$side+".sz") (`getAttr ($aimsAD[$i]+$side+".sz")`*-1);
				}
			parent -w ($aimsAD[$i]+$side);
			delete asMirror;
			createNode -n ($aimsAD[$i]+"ParentConstraint"+$side) -p ($geoLongName+"Geometry") transform;
//			asAlign ($aimsAD[$i]+"ParentConstraint"+$side) ($aimsAD[$i]+$side) 1 1 0 0;//shears
			delete `parentConstraint ($aimsAD[$i]+$side) ($aimsAD[$i]+"ParentConstraint"+$side)`;

			if (`objExists ($joint+"Part1_M")` && $geo=="Bone" && `objExists ($joint+"Bone_M")`) //Bind Spine and Neck Geo
				{
				select ($joint+"_M");
				for ($z=1;$z<99;$z++)
					if (`objExists ($joint+"Part"+$z+"_M")`) select -add ($joint+"Part"+$z+"_M");
					else break;
				select -add ($joint+"Bone_M");
				newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
				}
			else
				{
				if ($opm)
					asParentConstraint ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side) "";
				else
					{
	//				parentConstraint -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
					pointConstraint ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
					orientConstraint ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
	//				scaleConstraint  -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
					connectAttr ($joint+$side+".s") ($aimsAD[$i]+"ParentConstraint"+$side+".s");
					}
				}

			parent ($aimsAD[$i]+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
			

			setAttr ($aimsAD[$i]+$side+"Shape.overrideEnabled") 0;
			asLockAttr ($aimsAD[$i]+$side) 1 1 0 0;
//			if ($geo=="Box")
//				asMirrorGeometry Boxes 0; // slower, but looks better
//			refresh;
			}
		}
setAttr FitSkeleton.visGap $visGap;
delete FitSkeletonVisualizers;
if (!$visGeo)
	asUpdateButtonEnables;//ensure the checkBox is back off
}

global proc asCreateMuscular ()
{
int $form,$spans,$degrees,$numCv,$numChar,$skinningMethod,$numCurves;
string $tempString[],$tempString2[],$muscles[],$curves[],$mirrorCurves[],$transforms[],$newTransforms[];
string $skinCluster,$attach,$newTransform,$mirrorMuscle,$nurbs,$mirrorNurbs,$loft,$mirrorLoft,$sc;
string $cmd;
float $values[],$pos[];

if (!`objExists SkeletonGeometry`)
	error "Create Skeleton Geometry first";
asFitModeEnsureShaders;
if (`objExists MuscularGeometry`)
	error "MuscularGeometry already exists";

string $asMuscularFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asMuscular.ma";
file -i $asMuscularFile;
parent MuscularGeometry Geometry;
$muscles=`listRelatives -c Muscular_Muscles`;
createDisplayLayer -e -name NurbsMuscles;
editDisplayLayerMembers -noRecurse NurbsMuscles MuscularGeometry;

//Attach curves to bones by wrap
for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$attach=`getAttr ($curves[$y]+".attach")`;
		select $curves[$y] ("Muscular_"+$attach);
		$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		rename $tempString[0] ($curves[$y]+"TempWrap");	
		}
	}

//match bones by worldspace BS
$tempString=`listRelatives -c Muscular_SkeletonGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -ni -s $tempString[$i]`;
	if (`objectType $tempString2[0]`!="mesh")
		continue;
	$muscularBone=$tempString[$i];
	$bone=`substitute "Muscular_" $muscularBone ""`;
	if (!`objExists $bone`)
		continue;

	//scale bone, to get the muscle-attachment-offset
	setAttr -l 0 ($muscularBone+".sx");
	setAttr -l 0 ($muscularBone+".sy");
	setAttr -l 0 ($muscularBone+".sz");
	setAttr ($muscularBone+".sx") `getAttr ($bone+".sx")`;
	setAttr ($muscularBone+".sy") `getAttr ($bone+".sy")`;
	setAttr ($muscularBone+".sz") `getAttr ($bone+".sz")`;


	select $bone $muscularBone;
	select `listRelatives -ni -s`;
	blendShape -n ($muscularBone+"BS") -w 0 1;
	setAttr ($muscularBone+"BS.origin") 0;
	}

//Special case, Muscular_ExternalOblique_R
for ($i=1;$i<5;$i++)
	{
	select -r ("Muscular_ExternalObliqueALT1_curve"+$i+"_R") ("Muscular_ExternalOblique_curve"+$i+"_R");
	blendShape -n ("Muscular_ExternalOblique_curve"+$i+"_RTempBS") -w 0 1;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[7]") 0;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[6]") 0.2;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[8]") 0.2;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[5]") 0.4;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[9]") 0.4;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[4]") 0.6;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[10]") 0.6;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[3]") 0.8;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[11]") 0.8;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[2]") 1;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[0]") 1;
	}

//Delete-Wrap-History, but retain `shape`
for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$numCv=`asGetCurveNumCvs $curves[$y]`;
		$cmd="";
		for ($cv=0;$cv<$numCv;$cv++)
			{
			$pos=`xform -q -ws -t ($curves[$y]+".cv["+$cv+"]")`;
			$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$curves[$y]+".cv["+$cv+"];";
			}
		delete ($curves[$y]+"TempWrap");
		if (`gmatch $curves[$y] ("*ALT*")`)
			continue;
		if (`gmatch $curves[$y] ("Muscular_ExternalOblique_curve[0-9]_R")` && `objExists ($curves[$y]+"TempBS")`)
			delete ($curves[$y]+"TempBS");
		eval ($cmd);
		}
	}
delete Muscular_SkeletonGeometry;
for ($i=0;$i<size($muscles);$i++)
	if (`gmatch $muscles[$i] "*ALT*"`)
		{
		delete $muscles[$i];
		$muscles=`stringArrayRemove {$muscles[$i]} $muscles`;
		}

for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$tempString=`listRelatives -s $curves[$y]`;
		$curveShape=$tempString[0];
		$tempString=`listConnections ($curveShape+".create")`;
		$skinCluster=$tempString[0];
		if ($skinCluster=="")
			continue;
		$skinningMethod=`getAttr ($skinCluster+".skinningMethod")`;
		$numCv=`asGetCurveNumCvs $curves[$y]`;
		$transforms=`skinPercent -ib 0 -q -t $skinCluster ($curves[$y]+".cv[0:99]")`;
		clear $newTransforms;
		$cmd="";
		for ($z=0;$z<size($transforms);$z++)
			{
			$newTransform=`substitute "Muscular_" $transforms[$z] ""`;
			if (!`objExists $newTransform`)//pickWalk -d up, until we find a match
				{
				select $transforms[$z];
				while (!`objExists $newTransform`)
					{
					pickWalk -d up;
					$tempString=`ls -sl`;
					$newTransform=`substitute "Muscular_" $tempString[0] ""`;
					}
				}
			$newTransforms[size($newTransforms)]=$newTransform;
			for ($cv=0;$cv<$numCv;$cv++)
				{
				$values=`skinPercent -ib 0 -q -v $skinCluster ($curves[$y]+".cv["+$cv+"]")`;
				$cmd+="skinPercent -tv "+$newTransform+" "+$values[$z]+" "+$curves[$y]+"SC "+$curves[$y]+".cv["+$cv+"];\n";
				}
			}
		delete $skinCluster;
		select $curves[$y];
		select -add $newTransforms;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($curves[$y]+"SC");
		setAttr ($curves[$y]+"SC.skinningMethod") $skinningMethod;
		eval $cmd;
		}

	//Mirror
	$numChar=size($muscles[$i]);
	$mirrorMuscle=`substring $muscles[$i] 1 ($numChar-2)`+"_L";
	$nurbs=`substring $muscles[$i] 1 ($numChar-2)`+"_loft_R";
	$mirrorNurbs=`substring $muscles[$i] 1 ($numChar-2)`+"_loft_L";
	if (!`objExists $nurbs`)
		continue;

	duplicate -n $mirrorMuscle $muscles[$i];
	setAttr ($mirrorMuscle+".sx") -1;
	$curves=`listRelatives -c $mirrorMuscle`;
	$tempString=`listRelatives -f -c $mirrorMuscle`;
	for ($y=0;$y<size($curves);$y++)
		{
		$numChar=size($curves[$y]);
		$mirrorCurves[$y]=`substring $curves[$y] 1 ($numChar-2)`+"_L";
		rename $tempString[$y] $mirrorCurves[$y];
		asLockAttr $mirrorCurves[$y] 0 0 0 0;
		}
	makeIdentity -a 1 -t 1 -r 1 -s 1 $mirrorMuscle;
	for ($y=0;$y<size($curves);$y++)
		{
		$tempString=`listConnections ($curves[$y]+".create")`;
		$sc=$tempString[0];
		$tempString=`listConnections -s 1 -d 0 ($sc+".matrix")`;
		select -cl;
		for ($z=0;$z<size($tempString);$z++)
			{
			$numChar=size($tempString[$z]);
			if (`gmatch $tempString[$z] "*_R"`)
				select -add (`substring $tempString[$z] 1 ($numChar-2)`+"_L");
			else
				select -add $tempString[$z];
			}
		select -add $mirrorCurves[$y];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($mirrorCurves[$y]+"SC");
		select $curves[$y] $mirrorCurves[$y];
		copySkinWeights -ss $sc -ds ($mirrorCurves[$y]+"SC") -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}

	duplicate -n $mirrorNurbs $nurbs;
	$tempString=`listConnections ($nurbs+".create")`;
	$loft=$tempString[0];
	$tempString=`duplicate $loft`;
	$mirrorLoft=$tempString[0];
	connectAttr ($mirrorLoft+".outputSurface") ($mirrorNurbs+".create");
	$tempString=`listConnections ($loft+".inputCurve")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$numChar=size($tempString[$y]);
		connectAttr (`substring $curves[$y] 1 ($numChar-2)`+"_L.worldSpace[0]") ($mirrorLoft+".inputCurve["+$y+"]");
		}
	//reverse
	$numCurves=`getAttr -s ($loft+".reverse")`;
	for ($y=0;$y<$numCurves;$y++)
		setAttr ($mirrorLoft+".reverse["+$y+"]") (!`getAttr ($loft+".reverse["+$y+"]")`);
	}
delete Muscular_Root_M;
select -cl;
print ("// Muscles created\n");
}

global proc asDeleteMuscular ()
{
string $deleteObjs[]={"MuscularGeometry","Muscular_SkeletonGeometry","Muscular_Root_M","NurbsMuscles"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreatePolyBoxes ()
{
int $numCha;
string $childLabel,$toes,$heel,$joint,$side,$fitJoint,$parentBox,$fitSkeletonTemplate;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[];

if (`objExists BoxesGeometry`)
	error ("BoxesGeometry Alread exists");

if (`attributeExists fitSkeletonTemplate FitSkeleton`)
	$fitSkeletonTemplate=`getAttr FitSkeleton.fitSkeletonTemplate`;

createNode -n asCreatePolyBoxes transform;
asCreateFromFitGeometry Box;
delete asCreatePolyBoxes;
if (!`objExists BoxesGeometry`)
	return;//was cancelled by `not in  buildPose`

//Special Boxes, Angle & Wrist
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$joint=$deformJointsList[$i];
	$numChar=size($joint);
	$fitJoint=`substring $joint 1 ($numChar-2)`;
	$side=`substring $joint ($numChar-1) $numChar`;

	if (`gmatch $joint "*Ankle*"` || `gmatch $joint "*Toes*"`)
		if (`objExists ($fitJoint+"Box"+$side)`)
			if (`gmatch $fitSkeletonTemplate "biped*"`)
				asDropLowerVtxsToFloor $fitJoint $side;
	}

asMirrorGeometry Boxes 0;

//changing shader to default shader, as this has faster playback
sets -e -forceElement initialShadingGroup BoxesGeometry;

print "// PolyBoxes created\n";
select -cl;
}

global proc asDeletePolyBoxes ()
{
if (`objExists "BoxesGeometry"`)
	delete "BoxesGeometry";
if (`objExists "PolyBoxes"`)
	delete "PolyBoxes";
}

global proc asDropLowerVtxsToFloor (string $fitJoint, string $side)
{
int $maxYVtxNr;
float $maxY,$dist,$maxDist,$boxHeight;
float $pos[],$heelPos[];
string $upAxisDirection=`upAxis -q -ax`;
string $maxYVtx,$maxDistVtx,$childLabel,$toes,$heel,$absSecAxis;
string $sel[];
string $box=$fitJoint+"Box"+$side;

if ($upAxisDirection=="z")
	asSceneUpAxisFlip Group y;

select -r ($box+".vtx[0:99]");
$sel=`ls -sl -fl`;

//first find the 2 vtxs closes to heel
if (`gmatch $fitJoint "*Ankle*"`)
	{
	$tempString=`listRelatives -c $fitJoint`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$childLabel=`asLabel $tempString[$y]`;
		if (`gmatch $childLabel "*Toes*"`)
			$toes=$tempString[$y];
		if (`gmatch $childLabel "*Heel*"`)
			$heel=$tempString[$y];
		}
	if (`objExists $heel`)
		{
		$heelPos=`xform -q -ws -t $heel`;
		select -r ($box+".vtx[0:99]");
		$sel=`ls -sl -fl`;
		while (size($sel)>2)
			{
			$maxDist=-9999;
			for ($y=0;$y<size($sel);$y++)
				{
				$pos=`xform -q -ws -t $sel[$y]`;
				$dist=`mag<<$pos[0]-$heelPos[0],$pos[1]-$heelPos[1],$pos[2]-$heelPos[2]>>`;
				if ($dist>$maxDist)
					{
					$maxDist=$dist;
					$maxDistVtx=$sel[$y];
					}
				}
			select -d $maxDistVtx;
			$sel=`ls -sl -fl`;
			}
		$posA=`xform -q -ws -t $sel[0]`;
		$posB=`xform -q -ws -t $sel[1]`;
		move -r ($heelPos[0]-($posA[0]+$posB[0])/2.0) ($heelPos[1]-($posA[1]+$posB[1])/2.0) ($heelPos[2]-($posA[2]+$posB[2])/2.0);
		}
	}

//select 4 lowest vtxs
$absSecAxis=`asGetAxis secondary ($fitJoint+$side) Main 1`;
$boxHeight=`getAttr ($box+".scale"+$absSecAxis)`;
//scale up `height` first, to ensure correct detection of `4 lowest vtxs`
setAttr ($box+".scale"+$absSecAxis) 10;
select -r ($box+".vtx[0:99]");
$sel=`ls -sl -fl`;
while (size($sel)>4)
	{
	$maxY=-9999;
	for ($y=0;$y<size($sel);$y++)
		{
		$pos=`xform -q -ws -t $sel[$y]`;
		if ($pos[1]>$maxY)
			{
			$maxY=$pos[1];
			$maxYVtx=$sel[$y];
			}
		}
	select -d $maxYVtx;
	$sel=`ls -sl -fl`;
	}
setAttr ($box+".scale"+$absSecAxis) $boxHeight;

//drop to ground-plane
for ($y=0;$y<size($sel);$y++)
	{
	$pos=`xform -q -ws -t $sel[$y]`;
	xform -ws -t $pos[0] 0  $pos[2] $sel[$y];
	}

if ($upAxisDirection=="z")
	asSceneUpAxisFlip Group z;
}

global proc asCreateBoolean ()
{
global string $gMainProgressBar;
int $vs[];
string $tempString[],$tempString2[],$boxes[];
string $dupObj,$dupBox,$joint,$puppet,$restoreVisCmd;
string $objs[]=`ls -sl`;

if (size($objs)<1)
	error "No Objects Selected !";

string $dialog=`confirmDialog -t "Boolean"
	-m "Attempt to Boolean selected geometry with PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	refresh;
	}

if (!`objExists "BoxesGeometry"`)
	error "No BoxesGeometry in scene !";
$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}

if (!`objExists Bool`)
	{
	createDisplayLayer -e -name Bool;
	setAttr Bool.color 21;
	setAttr Bool.displayType 2;
	}
if (!`objExists BoolGeometry`)
	createNode -n BoolGeometry -p Geometry transform;
dgdirty -a;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating Booleans" -bp -ii 1 -min 0 -max (size($objs)) $gMainProgressBar;
for ($i=0;$i<size($objs);$i++)
	{
	$restoreVisCmd+="setAttr "+$objs[$i]+".v "+`getAttr ($objs[$i]+".v")`+";";
	setAttr ($objs[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($objs);$i++)
	{
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
		$joint=`substitute "Box" $boxes[$y] ""`;
		tokenize $joint "_" $tempString;
		if (`objExists ($tempString[0]+"Bool"+"_"+$tempString[1])`)
			warning ("Object \""+$tempString[0]+"Bool"+"_"+$tempString[1]+"\" Already exists...\n");
		$bool=`createNode -n ($tempString[0]+"Bool"+"_"+$tempString[1]) transform`;
		delete $bool;
		$dupObj=$objs[$i]+"_"+$boxes[$y];
		duplicate -n $dupObj $objs[$i];
		$tempString=`listRelatives -p $dupObj`;
		if ($tempString[0]!="")
			parent -w $dupObj;
		setAttr ($dupObj+".v") 0;
		$dupBox=$objs[$i]+"_"+$boxes[$y]+"Box";
		duplicate -n $dupBox $boxes[$y];
		asLockAttr $dupBox 0 0 0 0;
		parent -w $dupBox;
		select -r $dupObj $dupBox;
		refresh;
		$tempString=`polyBoolOp -n $dupObj -op 3 -ch 0 $dupObj $dupBox`;
		if (`objExists $dupObj`) delete $dupObj;
		if (`objExists $dupBox`) delete $dupBox;
		rename $tempString[0] ($bool+"WS");

		//transform to joint-space
		duplicate -n $bool ($bool+"WS");
		parent -r $bool $joint;
		parent -w $bool;
		select ($bool+"WS") $bool;
		blendShape -frontOfChain -origin world -w 0 1;
		select $bool;
		DeleteHistory;
		delete ($bool+"WS");

		$vs=`polyEvaluate -v $bool`;
		if (!$vs[0])
			delete  $bool;
		else
			{
//			parent $bool $joint;
			parent $bool BoolGeometry;
			parentConstraint $joint $bool;
			scaleConstraint $joint $bool;
			editDisplayLayerMembers -noRecurse Bool $bool;
			}
		}
	}
eval ($restoreVisCmd);
progressBar -e -ep $gMainProgressBar;

print ("// Boolean created\n");
select -cl;
}

global proc asDeleteBoolean ()
{
string $all[]=`ls -r 1 -type transform "*Bool_*"`;
$all[size($all)]="Bool";
$all[size($all)]="BoolGeometry";
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
}

global proc asCreateWarp ()
{
global string $gMainProgressBar;
int $sideFactor,$isEndJoint,$divisions;
int $tempInt[];
float $pos[],$facePos[],$temp[];
string $restoreVisCmd;
string $tempString[],$tempString2[],$boxes[];
string $sel[]=`ls -sl`;
string $wrapBox,$SG;
string $multiSGs[];

if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
string $dialog=`confirmDialog -t "Warp"
	-m "Attempt to Warp selected geometry to PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
if (!`objExists Warp`)
	{
	createDisplayLayer -e -name Warp;
	setAttr Warp.color 28;
	setAttr Warp.displayType 2;
	}
if (!`objExists WarpGeometry`)
	createNode -n WarpGeometry -p Geometry transform;

if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
createNode -n closestSampler closestPointOnMesh;

$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	$restoreVisCmd+="setAttr "+$sel[$i]+".v "+`getAttr ($sel[$i]+".v")`+";";
	setAttr ($sel[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	string $meshNode=$tempString[0];
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	if ($tempString[0]!="")
		$SG=$tempString[0];
	else
		{
		//faceAssigned shaders
		for ($y=0;$y<`getAttr -s ($meshNode+".instObjGroups.objectGroups")`;$y++)
			{
			if($y==0)
				{
				//temp copy of mesh, so we can freeze xforms
				$tempString=`duplicate -n tempMesh $sel[$i]`;
				setAttr -l 0 tempMesh.tx;setAttr -l 0 tempMesh.ty;setAttr -l 0 tempMesh.tz;
				setAttr -l 0 tempMesh.rx;setAttr -l 0 tempMesh.ry;setAttr -l 0 tempMesh.rz;
				setAttr -l 0 tempMesh.sx;setAttr -l 0 tempMesh.sy;setAttr -l 0 tempMesh.sz;
				setAttr -l 0 tempMesh.v 0;
				catchQuiet (`parent -w tempMesh`);
				makeIdentity -a 1 -t 1 -r 1 -s 1 tempMesh;
				connectAttr -f tempMesh.outMesh closestSampler.inMesh;
				}
			$tempString=`listConnections -type shadingEngine ($meshNode+".instObjGroups.objectGroups["+$y+"].objectGrpColor")`;
			if ($tempString[0]!="")
				$multiSGs[size($multiSGs)]=$tempString[0];
			}
		}
	progressBar -e -st ("Creating Warps for:"+$sel[$i]) -bp -ii 1 -min 0 -max (size($boxes)) $gMainProgressBar;
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;return;}
		progressBar -e -s 1 $gMainProgressBar;
		if (`gmatch $boxes[$y] "*_L_*"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		$joint=`substitute "Box" $boxes[$y] ""`;
		tokenize $boxes[$y] "_" $tempString;
		for ($z=1;$z<99;$z++)
			if (!`objExists ($tempString[0]+"Warp"+$z+"_"+$tempString[1])`)
				break;
		$warpBox=$tempString[0]+"Warp"+$z+"_"+$tempString[1];
		$isEndJoint=0;
		$tempString=`listRelatives -type joint -c $joint`;
		if (!size($tempString))
			$isEndJoint=1;
		else if (!`sets -im DeformSet $tempString[0]`)
			$isEndJoint=1;			
		duplicate -n $warpBox $boxes[$y];
		setAttr -k 1 -l 0 ($warpBox+".tx");setAttr -k 1 -l 0 ($warpBox+".ty");setAttr -k 1 -l 0 ($warpBox+".tz");
		setAttr -k 1 -l 0 ($warpBox+".rx");setAttr -k 1 -l 0 ($warpBox+".ry");setAttr -k 1 -l 0 ($warpBox+".rz");
//		parent $warpBox	$joint;
		parent $warpBox	WarpGeometry;
		parentConstraint $joint $warpBox;
		scaleConstraint $joint $warpBox;
		$divisions=2;
		if ($joint=="Head_M")
			$divisions=4;
		catch (`polySmooth -mth 0 -dv $divisions -bnr 1 -c 1 -kb 1 -ksb 1 -khe 1 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $warpBox`);
		scale -r -ocp 1 0.7 0.7 ($warpBox+".e[0:15]");
		scale -r -ocp 1 0.9 0.9 ($warpBox+".vtx[34:50]") ($warpBox+".vtx[52]") ($warpBox+".vtx[54]") ($warpBox+".vtx[56]") ($warpBox+".vtx[58]") ($warpBox+".vtx[60]") ($warpBox+".vtx[62]") ($warpBox+".vtx[64]") ($warpBox+".vtx[74:89]");
		select $sel[$i];
		select -add $warpBox;
		transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

		select $warpBox;
		DeleteHistory;

		//Very small "Area" is probably failed warpBox
		$temp=`polyEvaluate -a $warpBox`;
		if ($temp[0]<1.0)	
			{
			delete $warpBox;
			continue;
			}

		//round ends
		if (size($multiSGs))
			{
			$tempInt=`polyEvaluate -f $warpBox`;
			for ($z=0;$z<$tempInt[0];$z++)
				{
				if (`progressBar -q -ic $gMainProgressBar`)
					{progressBar -e -ep $gMainProgressBar;return;}
				$pos=`xform -q -ws -t ($warpBox+".f["+$z+"]")`;
				$facePos[0]=$facePos[1]=$facePos[2]=0;
				for ($a=0;$a<size($pos);$a=$a+3)
					{$facePos[0]+=$pos[$a];$facePos[1]+=$pos[$a+1];$facePos[2]+=$pos[$a+2];}
				$facePos[0]/=(size($pos)/3);$facePos[1]/=(size($pos)/3);$facePos[2]/=(size($pos)/3);
				setAttr closestSampler.inPosition $facePos[0] $facePos[1] $facePos[2];
				int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
				for ($a=0;$a<size($multiSGs);$a++)
					if (`sets -im $multiSGs[$a] ($sel[$i]+".f["+$closestFaceIndex+"]")`)
						sets -e -forceElement $multiSGs[$a] ($warpBox+".f["+$z+"]");
				}

			}
		else
			{
			$tempString=`listRelatives -ni -s $warpBox`;
			sets -e -forceElement $SG $tempString[0];
			}

		editDisplayLayerMembers -noRecurse Warp $warpBox;
		refresh;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
progressBar -e -ep $gMainProgressBar;
eval ($restoreVisCmd);

print ("// Warp created\n");
select -cl;
}

global proc asDeleteWarp ()
{
string $all[]=`ls -r 1 -type transform "*Warp*_*"`;
$all[size($all)]="Warp";
$all[size($all)]="WarpGeometry";
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
}

global proc asCreateBoxSkin ()
{
int $autoCreatingPolyBoxes;
int $numVtxs[];
float $values[];
float $value;
string $tempString[],$tempString2[],$tempString3[],$infs[],$controls[];
string $joint,$restorePoseCmd;

if (!`objExists BoxesGeometry`)
	{
	//	error "No PolyBoxes found, You must run Create PolyBoxes first";
	print "// No PolyBoxes found, auto-creating PolyBoxes before creating BoxSkin.\n";
	$autoCreatingPolyBoxes=1;
	asCreatePolyBoxes;
	}
	

asDeleteBoxSkin;
createDisplayLayer -e -name BoxSkin;
setAttr BoxSkin.color 3;
setAttr BoxSkin.displayType 2;
createNode -n BoxSkinGeometry -p Geometry transform;
setAttr PolyBoxes.v 0;

//Scale boxes a down, to improve on accuracy of CopySkinWeights (avoiding overlapping vertices)
$tempString=`listRelatives -ad -type mesh BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	catchQuiet (`scale -r 0.95 1 1 $tempString2[0]`);
	}

$tempString=`listRelatives -c BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -c $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		$tempString3=`listRelatives -s $tempString2[$y]`;
		if ($tempString3[0]=="")
			continue;
		$joint=`substitute "Box_" $tempString2[$y] "_"`;
		$tempString3=`duplicate $tempString2[$y]`;
		rename $tempString3[0] ($tempString2[$y]+"BoxSkin");
		asLockAttr ($tempString2[$y]+"BoxSkin") 0 0 0 0;
		parent ($tempString2[$y]+"BoxSkin") BoxSkinGeometry;
		editDisplayLayerMembers -noRecurse BoxSkin ($tempString2[$y]+"BoxSkin");
		select $joint ($tempString2[$y]+"BoxSkin");
		$tempString3=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString3[0] ($tempString2[$y]+"SkinCluster");
		refresh;
		}
	}
select `listRelatives -c BoxSkinGeometry`;
$tempString=`duplicate`;
polyUnite -ch 0 -mergeUVSets 0 -name BoxSkinMesh;
delete $tempString;
editDisplayLayerMembers -noRecurse BoxSkin BoxSkinMesh;
select BoxSkinMesh;
select -add DeformSet;
$tempString3=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString3[0] BoxSkinMeshSkinCluster;
select `listRelatives -c BoxSkinGeometry` BoxSkinMesh;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

delete `listRelatives -c BoxSkinGeometry`;
parent BoxSkinMesh BoxSkinGeometry;

//Restore original Box Scales
$tempString=`listRelatives -ad -type mesh BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	catchQuiet (`scale -r 1.052632 1 1 $tempString2[0]`);
	}

if ($autoCreatingPolyBoxes)
	asDeletePolyBoxes;

print "// BoxSkin created\n";
select -cl;
}

global proc asDeleteBoxSkin ()
{
string $deleteObjs[]={"BoxSkin","BoxSkinGeometry","BoxSkinMesh"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateMannequin ()
{
int $sideFactor,$numChar;
float $charHeight=`asgetCharHeight`;
float $temp[],$temp2[],$temp3[];
vector $childVec;
string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asGeometry.ma";
string $side,$fitJoint,$childLabel,$heel;
string $skipJoints[]={"Spine[0-9]*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*"};
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];

if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists MannequinGeometry`)
	error "MannequinGeometry already exists";
createNode -n MannequinGeometry transform;
parent MannequinGeometry "Geometry";

if (!`objExists Mannequin`)
	{
	createDisplayLayer -e -name Mannequin;
	setAttr Mannequin.color 24;
	setAttr Mannequin.displayType 2;
	editDisplayLayerMembers -noRecurse Mannequin  MannequinGeometry;
	}

file -i $asGeometryFile;
setAttr Mannequin_Geometry.v 0;
setAttr Skeleton_Geometry.v 0;

$tempString=`listRelatives -c -type transform Mannequin_Geometry`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;

for ($i=0;$i<size($deformJointsList);$i++)
	{
	$numChar=size($deformJointsList[$i]);
	$side=`substring $deformJointsList[$i] ($numChar-1) $numChar`;
	$fitJoint=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if (`gmatch $deformJointsList[$i] "Wrist_*"`)
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "MiddleFinger1_*"`)
				$childJoint=$children[$y];
	if ($childJoint=="")
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	int $skipMe=0;

	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}
	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	//spine
	if ($deformJointsList[$i]=="Root_M" || `gmatch $deformJointsList[$i] "*Spine[0-9]*"` || `gmatch $deformJointsList[$i] "*Chest*"` || `gmatch $deformJointsList[$i] "*Head_*"`)
		{
		if (`gmatch $deformJointsList[$i] "Head_*"`)
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Head`;
		else
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Root`;
		$poly=$tempString[0];
		$tempString=`parentConstraint $deformJointsList[$i] $poly`;
		asSetOrientOffsetFromAxis $tempString[0] $deformJointsList[$i] Main;
		delete $tempString[0];
		parent $poly MannequinGeometry;
		xform -os -s ($lenght/1) ($charHeight/10) ($charHeight/10) $poly;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}

	for ($y=0;$y<size($skipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $skipJoints[$y]`)
			$skipMe=1;
	if ($skipMe) continue;
//	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
//		continue;
	if (`gmatch $deformJointsList[$i] "*Ankle*"` || `gmatch $deformJointsList[$i] "Toes*"` && $childJoint!="")
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Foot`;
		$poly=$tempString[0];
		createNode -n tempXform transform;
		delete `pointConstraint $deformJointsList[$i] $childJoint tempXform`;

		//For Ankle, also move and scale to include Heel
		if (`gmatch $deformJointsList[$i] "*Ankle*"`)
			{
			$tempString=`listRelatives -c $fitJoint`;
			for ($y=0;$y<size($tempString);$y++)
				{
				$childLabel=`asLabel $tempString[$y]`;
				if (`gmatch $childLabel "*Heel*"`)
					$heel=$tempString[$y];
				}
			if (`objExists $heel`)
				{
				createNode -n tempXform2 transform;
				$temp3=`xform -q -ws -t $heel`;
				xform -ws -t ($temp3[0]*$sideFactor) $temp3[1] $temp3[2] tempXform2;
				$temp3=`xform -q -ws -t tempXform2`;
				delete `pointConstraint tempXform2 $childJoint tempXform`;
				delete tempXform2;
				$lenght = `mag<<$temp2[0]-$temp3[0],$temp2[1]-$temp3[1],$temp2[2]-$temp3[2]>>`;
				$lenght*=0.87;//slight shrink to make heel match heelposition
				}
			}

		$temp3=`xform -q -ws -t tempXform`;
		xform -ws -t $temp3[0] 0 $temp3[2] $poly;
		xform -os -s ($lenght/1) ($lenght/1) ($lenght/1) $poly;
		parent $poly MannequinGeometry;
		xform -ws -t $temp2[0] 0 $temp2[2] tempXform;
		delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempXform $poly`;
		delete tempXform;

		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	else
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Limb") Mannequin_Limb`;
		$poly=$tempString[0];
		xform -os -s ($lenght) ($lenght/2) ($lenght/2) $poly;
		if (`gmatch $deformJointsList[$i] "Wrist*"`)
			setAttr ($poly+".sy") (`getAttr ($poly+".sy")`*3);
		if (`gmatch $deformJointsList[$i] "Toes*"`)
			setAttr ($poly+".sz") (`getAttr ($poly+".sz")`*3);
		if (`gmatch $deformJointsList[$i] "*Finger*"`)
			xform -os -s $lenght ($charHeight/70) ($charHeight/70) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($lenght*1.1) ($charHeight/10) ($charHeight/10) $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`)
			{
			setAttr ($poly+".sx") (`getAttr ($poly+".sx")`*-1);
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $poly;
			}
//		parentConstraint $deformJointsList[$i] $poly;
		$tempString=`parentConstraint $deformJointsList[$i] $poly`;
		asSetOrientOffsetFromAxis $tempString[0] $deformJointsList[$i] Main;
		delete $tempString[0];
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($poly+"Shape.opposite") 0;
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Sphere`;
	$poly=$tempString[0];
	xform -os -s ($lenght/2) ($lenght/2) ($lenght/2) $poly;
	if (`gmatch $deformJointsList[$i] "*Finger*"`)
		xform -os -s ($charHeight/50) ($charHeight/50) ($charHeight/50) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "Wrist*"`)
		xform -os -s ($charHeight/20) ($charHeight/20) ($charHeight/20) $poly;
	if (`gmatch $deformJointsList[$i] "Shoulder_*"` || `gmatch $deformJointsList[$i] "Hip_*"`)
		xform -os -s ($charHeight/7) ($charHeight/7) ($charHeight/7) $poly;

//	parentConstraint $deformJointsList[$i] $poly;
	$tempString=`parentConstraint $deformJointsList[$i] $poly`;
	asSetOrientOffsetFromAxis $tempString[0] $deformJointsList[$i] Main;
	delete $tempString[0];
	parent $poly MannequinGeometry;
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//	scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	refresh;
	}
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

if (`objExists shaderMannequin`) delete shaderMannequin;
if (`objExists shaderMannequinSG`) delete shaderMannequinSG;
shadingNode -n shaderMannequin -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name shaderMannequinSG;
connectAttr -f shaderMannequin.outColor shaderMannequinSG.surfaceShader;
setAttr -type float3 shaderMannequin.color 0.78 0.63 0.42;
setAttr shaderMannequin.ambientColor -type double3 0.53 0.42 0.25;

sets -e -forceElement shaderMannequinSG MannequinGeometry;


print ("// Mannequin created\n");
select -cl;
}

global proc asDeleteMannequin ()
{
string $deleteObjs[]={"MannequinGeometry","Mannequin_Geometry","Mannequin","wood","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateRetopo ()
{
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 object";
if (!`objExists skinCage`)
	error "SkinCage not found, this must be created first. This is in the \"Deform(option2)\" section.";
if (`objExists retopo`)
	error "object \"retopo\" already exists, Choose \"delete retopo\", before creating a new one";

string $cage="skinCage";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}

if (`objExists retopo`) delete retopo;
select -cl;
createDisplayLayer -e -name "Retopo" -number 1 -nr;
setAttr Retopo.v 1;setAttr Retopo.color 5;
//setAttr Retopo.displayType 2;
duplicate -n retopo $cage;
$tempString=`listConnections -p 1 -s 1 -d 0 retopo.drawOverride`;
if (size($tempString))
	disconnectAttr $tempString[0] retopo.drawOverride;
editDisplayLayerMembers -noRecurse Retopo retopo;
if (`objExists Geometry`) parent retopo Geometry;

addAttr -ln hiResMesh -dt "string" retopo;
setAttr -type "string" retopo.hiResMesh $sel[0];
select $sel[0] retopo;

int $centerVtx[]=`asGetRetopoCenterVtxs`;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 1 ;
select retopo;
DeleteHistory;
polyNormalPerVertex -ufn true retopo;
polySoftEdge -angle 180 -ch 0 retopo;
asRestoreRetopoCenterVtx $centerVtx;
select retopo;
}

global proc asDeleteRetopo ()
{
string $deleteObjs[]={"retopo","Retopo","retopoHeadEdgeFinder"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asUpdateRetopo ()
{
string $sel[]=`ls -sl`;
if (!`gmatch $sel[0] "retopo*"`)
	error "\"retopo\" not selected, Select the entire \"retopo\" object, or vertices on the \"retopo\" object";
string $hiResMesh=`getAttr retopo.hiResMesh`;
if (!`objExists $hiResMesh`)
	error "Could not find HiResMesh, check the name in this attribute \"retopo.hiResMesh\"";
int $centerVtx[]=`asGetRetopoCenterVtxs`;
select $hiResMesh $sel;
transferAttributes -transferPositions 1 -transferNormals 1 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 1 ;
asRestoreRetopoCenterVtx $centerVtx;
select retopo;
DeleteHistory;
select $sel;
}

global proc asMirrorRetopo (int $L2R)
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "SkinCage not found, this must be created first. This is in the \"Deform(option2)\" section.";
string $cage="skinCage";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
int $oppositeVtxNr;
int $numVtxs[]=`polyEvaluate -v $cage`;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($cage+".outMesh") closestSampler.inMesh;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ($cage+".vtx["+$i+"]")`;
	if ($pos[0]<$centerTolerance && $pos[0]>($centerTolerance*-1))
		continue;//Todo:should snap to center
	if ($L2R && $pos[0]<0) continue;
	if (!$L2R && $pos[0]>0) continue;
	setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
	$oppositeVtxNr=`getAttr closestSampler.closestVertexIndex`;
	$pos=`xform -q -ws -t ("retopo.vtx["+$i+"]")`;
	xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ("retopo.vtx["+$oppositeVtxNr+"]");
	}
delete closestSampler;
select $sel;
}

global proc int[] asGetRetopoCenterVtxs ()
{
int $centerVtx[];
int $numVtxs[]=`polyEvaluate -v retopo`;
float $pos[];
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;

for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ("retopo.vtx["+$i+"]")`;
	if ($pos[0]<$centerTolerance && $pos[0]>($centerTolerance*-1))
		$centerVtx[size($centerVtx)]=$i;
	}
return $centerVtx;
}

global proc asRestoreRetopoCenterVtx (int $centerVtx[])
{
float $pos[];
for ($i=0;$i<size($centerVtx);$i++)
	{
	$pos=`xform -q -ws -t ("retopo.vtx["+$centerVtx[$i]+"]")`;
	xform -ws -t 0 $pos[1] $pos[2] ("retopo.vtx["+$centerVtx[$i]+"]");
	}
}

global proc asNormalMapRetopo ()
{
string $hiResMesh=`getAttr retopo.hiResMesh`;

performSurfaceSampling 1;
surfaceSamplingAddTargets( "retopo", true );
surfaceSamplingAddSource( $hiResMesh, true );
int $arraySize = `optionVar -q "surfaceSamplingOutputArraySize"`;
if ($arraySize<3)
	addMapUIFrame 0;
surfaceSamplingChangeXResolutionDragCmd 2048 0;
}

global proc asBindRetopo ()
{
int $numVtxsCage[],$numVtxsRetopo[];
string $tempString[];
string $cage="skinCage";
if (`objExists retopoSC`) error "retopoSC already exists. Try to UnBind first, before doing a nwe Bind";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}
duplicate -n skinCage2 skinCage;
parent -w skinCage2;
select skinCage2;
asSelectDeformJoints;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
select skinCage skinCage2;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select retopo;
asSelectDeformJoints;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] retopoSC;
select skinCage2 retopo;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//re-copyWeights, if topology match, with meshes aligned, for imroved results
$numVtxsCage=`polyEvaluate -v skinCage2`;
$numVtxsRetopo=`polyEvaluate -v retopo`;
if ($numVtxsCage[0]==$numVtxsRetopo[0])
	{
	select skinCage2 retopo;
	blendShape -n TempBS -w 0 1;
	select skinCage2 retopo;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	delete TempBS;
	}

delete skinCage2;
}

global proc asUnBindRetopo ()
{
select retopo;
DeleteHistory;
}

global proc asCreateFaceRetopo ()
{
int $vtxNr,$twistCurves;
float $dist,$minDist,$scaleY;
float $pos[],$pos2[],$rot[];
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyDir=$asScriptLocation+"/AdvancedSkeletonFiles/div/headTopology/";
string $file,$prePosCmd,$restoreExistingLocPosCmd,$locator;
string $faces[],$retopoHeadFaces[],$retopoHeadVtxs[],$bodyHeadConnectionVtxs[],$headBodyConnectionVtxs[],$locators[],$neckLocs[],$tempString[],$tempString2[];
string $deleteObjs[]={"closestSampler","retopoHeadEdgeFinder"};

if (`objExists FKJaw_M`) if (!`asFaceRemoveBodyJaw`) return;

if (!`objExists Neck_M_middleCurve`) error "SkinCage Neck Curve curve not found, unable to proceed";
if (`objExists FaceGroup`) error "FaceGroup already exists, unable to proceed";
if (`objExists headTopology`)
	{
	if (`objExists guidesGroup`)
		{
		$tempString=`listRelatives -ad -type transform guidesGroup`;
		for ($i=0;$i<size($tempString);$i++)
			{
			if (!`gmatch $tempString[$i] "*Loc[0-9]*"`) continue;
			$pos=`xform -q -ws -t $tempString[$i]`;
			$restoreExistingLocPosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$tempString[$i]+";";
			}
		}
	asDeleteFaceRetopo 0;
	}

for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
select -cl;

string $curves[]={"Neck_M_middleCurve","Head_M_middleCurve","HeadEnd_M_middleCurve"};
if (`attributeExists inbetweenJoints Neck`)
	$twistCurves=`getAttr Neck.inbetweenJoints`;
if (`attributeExists twistJoints Neck`)
	$twistCurves=`getAttr Neck.twistJoints`;
for ($i=1;$i<$twistCurves+1;$i++)
	$curves[size($curves)]=("Neck_M_twistCurve"+$i);

for ($i=0;$i<size($curves);$i++)
	for ($y=0;$y<5;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSampler.closestVertexIndex`;
		select -add ("skinCage.vtx["+$vtxNr+"]");
		}
ConvertSelectionToContainedFaces;

$faces=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($faces);$i++)
	select -add `substitute "skinCage" $faces[$i] "retopo"`;
$retopoHeadFaces=`ls -sl -fl`;

if (`objExists SkinSub`) //tmp resolve smoothProxyFaces via material
	{
	shadingNode -n tempShader -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name tempShaderSG;
	setAttr tempShader.color -type double3 0 0 0; 
	connectAttr -f tempShader.outColor tempShaderSG.surfaceShader;
	duplicate -n tempSkinCage skinCage;
	parent -w tempSkinCage;
	select -cl;
	for ($i=0;$i<size($faces);$i++)
		select -add `substitute "skinCage" $faces[$i] "tempSkinCage"`;
	sets -e -forceElement tempShaderSG;
//	polySmooth  -mth 0 -sdt 2 -ovb 1 -ofb 3 -ofc 0 -ost 1 -ocr 0 -dv 1 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 tempSkinCage;
	polySmooth  -mth 0 -dv 1 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 tempSkinCage;
	$tempString=`sets -q tempShaderSG`;
	clear $retopoHeadFaces;
	for ($i=0;$i<size($tempString);$i++)
		$retopoHeadFaces[size($retopoHeadFaces)]=`substitute "tempSkinCage" $tempString[$i] "retopo"`;
	delete tempSkinCage tempShader tempShaderSG;
	}
select $retopoHeadFaces;
ConvertSelectionToVertices;
$retopoHeadVtxs=`ls -sl -fl`;
duplicate -n retopoHeadEdgeFinder retopo;
$retopoHeadVtxs=`asobjSetCast "" $retopoHeadVtxs retopoHeadEdgeFinder`;

select retopo;
cluster -n retopoCluster -envelope 1;
delete $retopoHeadFaces;
delete retopoCluster;
$tempString=`listConnections -s 1 -d 0 retopoShape.inMesh`;
rename $tempString[0] retopoHeadDeleteComponent;

//import mayaFile
$file=$headTopologyDir+`optionMenu -q -v asCreateFaceRetopoOptionMenu`;
file -i -rdn -mergeNamespacesOnClash false -rpr "guides" $file;
setAttr FaceGroup.v 0;
parent headTopology Geometry;
parent FaceGroup Group;
createNode -n FaceFitRetopoAttach -p FaceGroup transform;
setAttr headTopology.v 0;

//attached faceFitCurves to headTopology
$tempString=`listRelatives -ad -type nurbsCurve FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="TongueCurveShape") continue;
	if (`gmatch $tempString[$i] "*CurveShape"`)
		{
		select $tempString[$i] headTopology;
		$tempString2=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		rename $tempString2[0] ($tempString[$i]+"TempWrap");
		$tempString2=`listConnections ($tempString[$i]+"TempWrap.basePoints[0]")`;
		parent $tempString2[0] FaceFitRetopoAttach;
		}
	}
//attached faceFit Locators to headTopology
$tempString=`listRelatives -ad -type locator FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	$locator=$tempString2[0];
	$pos=`getAttr ($tempString[$i]+".worldPosition")`;
	curve -n ($tempString[$i]+"TempWrapCurve") -d 1 -p $pos[0] $pos[1] $pos[2] -p $pos[0] $pos[1] $pos[2] -k 0 -k 1;
	setAttr ($tempString[$i]+"TempWrapCurve.inheritsTransform") 0;
	$tempString2=`listRelatives -p $locator`;
	parent ($tempString[$i]+"TempWrapCurve") FaceFitRetopoAttach;
	geometryConstraint -weight 1 ($tempString[$i]+"TempWrapCurve")  $locator;

	select ($tempString[$i]+"TempWrapCurve") headTopology;
	$tempString2=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
	rename $tempString2[0] ($tempString[$i]+"TempWrap");
	$tempString2=`listConnections ($tempString[$i]+"TempWrap.basePoints[0]")`;
	parent $tempString2[0] FaceFitRetopoAttach;
	}

//place at head
float $neckPos[]=`xform -q -ws -t Neck_M_middleProfileShape.cv[0]`;
float $headEndPos[]=`xform -q -ws -t HeadEnd_M`;
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) FaceFitSkeleton;
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) headTopology.vtx[0:9999];
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) guidesGroup;
move -r 0 $neckPos[1] 0 FaceFitSkeleton;
move -r 0 $neckPos[1] 0 headTopology.vtx[0:9999];
move -r 0 $neckPos[1] 0 guidesGroup;

//store current locator positions
$tempString=`listRelatives -ad -type transform guidesGroup`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Loc[0-9]*"`) $locators[size($locators)]=$tempString[$i];
for ($i=0;$i<size($locators);$i++)
	{
	$pos=`xform -q -ws -t $locators[$i]`;
	$prePosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$locators[$i]+";";
	}
addAttr -ln prePosCmd -dt "string" guidesGroup;
setAttr -type "string" guidesGroup.prePosCmd $prePosCmd;

//restore $restoreExistingLocPosCmd, if locators were already existing
tokenize $restoreExistingLocPosCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	catchQuiet (`evalEcho($tempString[$i])`);

//find bodyHeadConnectionVtxs
connectAttr -f retopo.outMesh closestSampler.inMesh;
for ($i=0;$i<size($retopoHeadVtxs);$i++)
	{
	$pos=`xform -q -ws -t $retopoHeadVtxs[$i]`;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$vtxNr=`getAttr closestSampler.closestVertexIndex`;
	$pos2=`xform -q -ws -t ("retopo.vtx["+$vtxNr+"]")`;
	if (`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`<0.001)
		$bodyHeadConnectionVtxs[size($bodyHeadConnectionVtxs)]=("retopo.vtx["+$vtxNr+"]");
	if (!`attributeExists bodyHeadConnectionVtxs retopo`)
		addAttr -ln bodyHeadConnectionVtxs -dt "string" retopo;
	setAttr -type "string" retopo.bodyHeadConnectionVtxs `stringArrayToString $bodyHeadConnectionVtxs " "`;
	}
//find  headBodyConnectionVtxs
if (!`attributeExists headBodyConnectionVtxs retopo`)
	addAttr -ln headBodyConnectionVtxs -dt "string" retopo;
connectAttr -f headTopology.outMesh closestSampler.inMesh;
$pos=`xform -q -ws -t HeadProfileSideLoc6`;
setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$vtxNr=`getAttr closestSampler.closestVertexIndex`;
select ("headTopology.vtx["+$vtxNr+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
int $minNumEdgesInLoop=999;
for ($i=0;$i<size($edges);$i++)
	{
	select $edges[$i];
	SelectEdgeLoopSp;
	$tempString=`ls -sl -fl`;
	if (size($tempString)<$minNumEdgesInLoop)
		{
		$minNumEdgesInLoop=size($tempString);
		ConvertSelectionToVertices;
		$headBodyConnectionVtxs=`ls -sl -fl`;
		setAttr -type "string" retopo.headBodyConnectionVtxs `stringArrayToString $headBodyConnectionVtxs " "`;
		}
	}
//place neckLocs to nearest $bodyHeadConnectionVtxs
for ($i=0;$i<size($locators);$i++)
	if (`getAttr ($locators[$i]+".overrideColor")`==24)
		$neckLocs[size($neckLocs)]=$locators[$i];
for ($i=0;$i<size($neckLocs);$i++)
	{
	$pos=`xform -q -ws -t $neckLocs[$i]`;
	$minDist=999;
	for ($y=0;$y<size($bodyHeadConnectionVtxs);$y++)
		{
		$pos2=`xform -q -ws -t $bodyHeadConnectionVtxs[$y]`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		if ($dist<$minDist)
			{
			$minDist=$dist;
			xform -ws -t $pos2[0] $pos2[1] $pos2[2] $neckLocs[$i];
			}
		}
	}

delete retopoHeadEdgeFinder;
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
asFaceUpdateInfo 1;
print "// Now move the Locators, to match the head/face of your model.\n";
select -cl;
}

global proc asDeleteFaceRetopo (int $keepNewRetopo)
{
string $deleteObjs[]={"headTopology","retopoHeadDeleteComponent","retopoHeadJoint","guidesGroup","MainCurves","ProfileCurves"};
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
$deleteObjs=`ls "guides_*"`;
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
if (`objExists guidesRN`)
	{
	lockNode -l 0 guidesRN;
	delete guidesRN;
	}
if (!$keepNewRetopo)
	{
	if (`objExists headTopologyGeometry`) delete headTopologyGeometry;
	if (`objExists FaceGroup`) delete FaceGroup;
	}
if (!$keepNewRetopo && `objExists bodyTopology`)
	{
	delete retopo;
	setAttr bodyTopology.v 1;
	rename bodyTopology retopo;
	}
asFaceUpdateInfo 1;
}

global proc asMatchGuidesFaceRetopo ()
{
int $numVtxs[]=`polyEvaluate -v headTopology`;
float $pos[];
string $tempString[],$locators[],$curves[],$mirrorCurves[],$nonAverageVtxs[],$centerXvtxs[];
string $hiResMesh=`getAttr retopo.hiResMesh`;
string $restoreLocPosCmd;
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headBodyConnectionVtxs[]=`stringToStringArray $tempString[0] " "`;
if (`objExists retopoHeadJoint`)
	error "Match guides has already been executed. You can scrube the timeline from 0 to 10, to see the alignment";
if (!`objExists headTopology`)
	error "headTopology object not found, click \"Geometry: Create\" first";

$tempString=`listRelatives -ad -type transform guidesGroup`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*Loc[0-9]*"`) $locators[size($locators)]=$tempString[$i];
	if (`gmatch $tempString[$i] "*Curve*"`) $curves[size($curves)]=$tempString[$i];
	}

for ($i=0;$i<size($locators);$i++)
	{
	if (!`gmatch $locators[$i] "*Loc[0-9]*"`) continue;
	$pos=`xform -q -ws -t $locators[$i]`;
	$restoreLocPosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$locators[$i]+";";
	}

eval (`getAttr guidesGroup.prePosCmd`);

for ($i=0;$i<size($curves);$i++)
	{
	if ($curves[$i]=="HeadProfileSideCurve" || $curves[$i]=="noseProfileCurve") continue;
	duplicate -n ($curves[$i]+"mirror") $curves[$i];
	$mirrorCurves[size($mirrorCurves)]=$curves[$i]+"mirror";
	asLockAttr ($curves[$i]+"mirror") 1 1 0 0;
	setAttr ($curves[$i]+"mirror.sx") -1;
	connectAttr -f ($curves[$i]+".worldSpace[0]") ($curves[$i]+"mirror.create");
	}

//duplicate -n headTopologyOrig headTopology;
//setAttr headTopologyOrig.v 0;

for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ("headTopology.vtx["+$i+"]")`;
	if ($pos[0]<0.001 && $pos[0]>-0.001)
		$centerXvtxs[size($centerXvtxs)]="headTopology.vtx["+$i+"]";
	}

select FaceGroup;
joint -n retopoHeadJoint;
select headTopology retopoHeadJoint;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] headTopologySC;
setAttr headTopologySC.useComponents 1;

select headTopology $curves $mirrorCurves;
skinClusterInfluence 1 "-ug -dr 4 -ps 0 -ns 100";

eval ($restoreLocPosCmd);

asAlignBodyFaceRetopo;

clear $tempString;
asSelectCurveVtx upperLipMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx upperLipMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx lowerLipMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx lowerLipMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx eyeLidMainCurve;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx eyeLidMainCurvemirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx EyeBrowMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx EyeBrowMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
if (`objExists EarCurve`)
	{asSelectCurveVtx EarCurve;select -add $tempString;$tempString=`ls -sl`;}
asSelectCurveVtx noseProfileCurve;select -add $tempString;$tempString=`ls -sl`;
GrowPolygonSelectionRegion;$tempString=`ls -sl`;
$nonAverageVtxs=`stringArrayCatenate $nonAverageVtxs $tempString`;

select headTopology.vtx[0:9999];
select -d $headBodyConnectionVtxs;
select -d $nonAverageVtxs;
$tempString=`ls -sl`;
select $hiResMesh $tempString;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;
select $tempString;
polyAverageVertex -i 10;
select $hiResMesh $tempString;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

for ($i=0;$i<size($centerXvtxs);$i++)
	{
	$pos=`xform -q -ws -t $centerXvtxs[$i]`;
	xform -ws -t 0 $pos[1] $pos[2] $centerXvtxs[$i];
	}

setAttr headTopology.v 1;
select -cl;
}

global proc asShrinkWrapFaceRetopo ()
{
string $tempString[];
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headVtxs[]=`stringToStringArray $tempString[0] " "`;

select headTopology;
ConvertSelectionToVertices;
select -d $headVtxs;
polyAverageVertex -i 10 -ch 1;

}

global proc asAlignBodyFaceRetopo ()
{
float $mag,$minMag;
float $posA[],$posB[];
string $nearestVtx;
string $sel[]=`ls -sl`;
string $tempString[];

$tempString[0]=`getAttr retopo.bodyHeadConnectionVtxs`;
string $bodyVtxs[]=`stringToStringArray $tempString[0] " "`;
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headVtxs[]=`stringToStringArray $tempString[0] " "`;

for ($i=0;$i<size($headVtxs);$i++)
	{
	$posA=`xform -q -ws -t $headVtxs[$i]`;
	$minMag=99999;
	for ($y=0;$y<size($bodyVtxs);$y++)
		{
		$posB=`xform -q -ws -t $bodyVtxs[$y]`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($mag<$minMag)
			{
			$minMag=$mag;
			$nearestVtx=$bodyVtxs[$y];
			}
		}
	$posB=`xform -q -ws -t $nearestVtx`;
	xform -ws -t $posB[0] $posB[1] $posB[2] $headVtxs[$i];
	}
}

global proc asConnectBodyFaceRetopo ()
{
int $form,$spans,$degrees,$numCv;
float $posA[];
string $sel[]=`ls -sl`;
string $tempString[];
string $restoreCrvsCmd;

//`detach` wrapped-on FaceFitSkeleton
$tempString=`listRelatives -ad -type nurbsCurve FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*CurveShape"`)
		{
		$form=`getAttr ($tempString[$i]+".form")`;
		$spans=`getAttr ($tempString[$i]+".spans")`;
		$degrees=`getAttr ($tempString[$i]+".degree")`;
		if ($form==2) $numCv=$spans;
		else $numCv=$spans+$degrees;
		for ($y=0;$y<$numCv;$y++)
			{
			$posA=`xform -q -ws -t ($tempString[$i]+".cv["+$y+"]")`;
			$restoreCrvsCmd+="xform -ws -t "+$posA[0]+" "+$posA[1]+" "+$posA[2]+" "+$tempString[$i]+".cv["+$y+"];";
			}
		}
setAttr FaceGroup.v 1;
refresh;
setAttr FaceGroup.v 0;
delete FaceFitRetopoAttach;
evalEcho ($restoreCrvsCmd);

rename retopo bodyTopology;
duplicate -n headTopologyForMerge headTopology;
duplicate -n bodyTopologyForMerge bodyTopology;
setAttr headTopology.v 0;
setAttr bodyTopology.v 0;

polyUnite -ch 0 -mergeUVSets 0 -name retopo bodyTopologyForMerge headTopologyForMerge;
addAttr -ln hiResMesh -dt "string" retopo;
setAttr -type "string" retopo.hiResMesh `getAttr bodyTopology.hiResMesh`;
delete headTopologyForMerge bodyTopologyForMerge;
//parent headTopology Geometry;
parent retopo Geometry;
editDisplayLayerMembers -noRecurse Retopo retopo;

polyMergeVertex -d 0.0001 -am 1 -ch 0 retopo;
select headTopology;
DeleteHistory;

asDeleteFaceRetopo 1;

if (`objExists retopoSC`)
	{
	rename retopoSC bodyTopologySC;
	select retopo;
	asSelectDeformJoints;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] retopoSC;
	select bodyTopology retopo;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
delete bodyTopology;

catchQuiet (`select $sel`);
}

global proc asCreateEyesFaceRetopo ()
{
float $pos[],$rot[];
float $eyeSize;
float $height=`getAttr "Main.height"`;
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyEyeBallDir=$asScriptLocation+"/AdvancedSkeletonFiles/div/headTopologyEyeBall/";
string $file,$side;

if (`objExists headTopologyEyes`)
	{
	select headTopologyEyes;
	error "headTopologyEyes already exists";
	}
createNode -n headTopologyEyes -p Geometry transform;
$file=$headTopologyEyeBallDir+`optionMenu -q -v asCreateFaceRetopoEyeBallOptionMenu`;
file -i $file;
parent eyeball headTopologyEyes;

$rot=`xform -q -ws -ro Eye_R`;
xform -r -ro $rot[0] ($rot[1]-90) 0 eyeball.vtx[0:999];
$pos=`xform -q -ws -t Eye_R`;
move -r $pos[0] $pos[1] $pos[2] eyeball.vtx[0:999];

$eyeSize=$height/30.0;
scale -r -p $pos[0] $pos[1] $pos[2] $eyeSize $eyeSize $eyeSize eyeball.vtx[0:999];

rename eyeball eyeball_R;
duplicate -n eyeball_L eyeball_R;
scale -r -p 0 0 0 -1 1 1 eyeball_L.vtx[0:999];
polyNormal -normalMode 0 -userNormalMode 0 -ch 0 eyeball_L;

asLockAttr headTopologyEyes 1 1 1 1;
addAttr -k 1 -ln "size" -at double -dv 1 headTopologyEyes;

$side="_R";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$side="_L";}
	select ("eyeball"+$side);
	$tempString=`newCluster " -envelope 1"`;
	rename $tempString[0] ("eyeballCluster"+$side);
	rename $tempString[1] ("eyeballClusterHandle"+$side);
	setAttr ("eyeballClusterHandle"+$side+".v") 0;
	parent ("eyeballClusterHandle"+$side) headTopologyEyes;
	connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sx");connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sy");connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sz");
//	select ("eyeball"+$side);
//	asChooseInput ("asFaceEye"+$side+"TextField");
	}

//asBuildFitEyeBall;
print "//Eyes created, ajust the scale with the size attribute.\n";
select headTopologyEyes;
}

global proc asBindEyesFaceRetopo ()
{
string $side="_R";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$side="_L";}
	select ("eyeball"+$side);
	DeleteHistory;
	select Head_M ("eyeball"+$side);
	newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	}
print "//Eyes skinned to eye-joints.\n";
select -cl;
}

global proc asCreateTeethFaceRetopo ()
{
float $pos[];
float $height=`getAttr "Main.height"`;
if (`objExists headTopologyTeeth`)
	{
	select teethLocator;
	error "headTopologyTeeth already exists";
	}
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyTeethDir=$asScriptLocation+"/AdvancedSkeletonFiles/div/headTopologyTeeth/";
string $file=$headTopologyTeethDir+`optionMenu -q -v asCreateFaceRetopoTeethOptionMenu`;
file -i $file;
parent headTopologyTeeth Geometry;

$pos=`xform -q -ws -t Head_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] -s ($height/20.0) ($height/20.0) ($height/20.0) teethLocator;
$pos=`xform -q -ws -t Eye_R`;
setAttr teethLocator.tz $pos[2];

select teethLocator;
}

global proc asBindTeethFaceRetopo ()
{
select upperTeeth lowerTeeth tongue;
DeleteHistory;
delete teethLocator teethClusterHandle;

select upperTeeth lowerTeeth tongue Head_M;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

select -cl;
print "// Bind teeth complete.\n";
}

global proc asFaceRigPrepRetopo ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[];
string $newSelectionString;

setAttr FaceGroup.v 1;

//Pre section
select retopo;
asChooseInput asFaceFaceTextField;
select retopo;
string $optionalAllHeadObjs[]={"eyeball_R","eyeball_L","upperTeeth","lowerTeeth","tongue"};
for ($i=0;$i<size($optionalAllHeadObjs);$i++)
	if (`objExists $optionalAllHeadObjs[$i]`)
		select -add $optionalAllHeadObjs[$i];
asChooseInput asFaceAllHeadTextField;
if (`objExists eyeball_R`) {select eyeball_R;asChooseInput asFaceRightEyeTextField;}
if (`objExists eyeball_L`) {select eyeball_L;asChooseInput asFaceLeftEyeTextField;}
if (`objExists upperTeeth`) {select upperTeeth;asChooseInput asFaceUpperTeethTextField;}
if (`objExists lowerTeeth`) {select lowerTeeth;asChooseInput asFaceLowerTeethTextField;}
if (`objExists tongue`) {select tongue;asChooseInput asFaceTongueTextField;}


//Fit section
if (`objExists eyeball_R`)
	asBuildFitEyeBall;
if (`objExists tongue`)
	{
	asCreateFaceFit Tongue "" 0 0 0 asGreenSG;
	$posA=`xform -q -ws -t tongue.vtx[111]`;xform -ws -t 0 $posA[1] $posA[2] Tongue0;
	$posA=`xform -q -ws -t tongue.vtx[35]`; xform -ws -t 0 $posA[1] $posA[2] Tongue1;
	$posA=`xform -q -ws -t tongue.vtx[198]`;xform -ws -t 0 $posA[1] $posA[2] Tongue2;
	$posA=`xform -q -ws -t tongue.vtx[64]`; xform -ws -t 0 $posA[1] $posA[2] Tongue3;
	$posA=`xform -q -ws -t tongue.vtx[167]`;xform -ws -t 0 $posA[1] $posA[2] Tongue4;
	}

asFaceFitJawCurves;

catchQuiet (`select $sel`);
}

global proc asSelectMatchingComponents (string $destMesh)
{
int $edgeSelection=0;
float $pos[];

string $sel[]=`ls -sl`;
if (`gmatch $sel[0] "*.e[[]*"`) $edgeSelection=1;
if (`objExists closestSampler`) delete closestSampler;
if ($edgeSelection)
	ConvertSelectionToVertices;
string $vtxs[]=`ls -sl -fl`;

createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($destMesh+".outMesh") closestSampler.inMesh;
select -cl;
for ($i=0;$i<size($vtxs);$i++)
	{
	$pos=`xform -q -ws -t $vtxs[$i]`;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	select -add ("retopo.vtx["+`getAttr closestSampler.closestVertexIndex`+"]");
	}
if ($edgeSelection)
	ConvertSelectionToContainedEdges;
if (`objExists closestSampler`) delete closestSampler;
}

global proc asHidePolyBoxes (int $onOff)
{
if (!`objExists "BoxesGeometry"`)
	error "BoxesGeometry does not exists !\n";
setAttr -l 0 "BoxesGeometry.v";
setAttr -l ($onOff) "BoxesGeometry.v" (!$onOff);
if (!$onOff)
	setAttr -l ($onOff) "BoxesGeometry.v";
}

global proc asMirrorGeometry (string $geometry, int $L2R)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
int $vs[];
float $scale[3],$pos[3];
string $box,$matchBox;
string $allPCs[]=`listRelatives -type transform -c ($geometry+"Geometry")`;
for ($i=0;$i<size($allPCs);$i++)
	{
	$box=`substitute "ParentConstraint" $allPCs[$i] ""`;
	if ($L2R)
		$matchBox=`substitute "_L" $box "_R"`;
	else
		$matchBox=`substitute "_R" $box "_L"`;

	if ($box==$matchBox || `gmatch $box "*_M"`)
		continue;

	if (!`objExists $matchBox`)
		continue;

	$scale=`getAttr ($box+".scale")`;
	if (!`getAttr -l ($matchBox+".scaleX")`)
		setAttr -type float3 ($matchBox+".scale") $scale[0] $scale[1] $scale[2];
	$vs=`polyEvaluate -v $box`;
	for ($y=0;$y<$vs[0];$y++)
		{
		$pos=`xform -q -ws -t ($box+".vtx["+$y+"]")`;
		xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchBox+".vtx["+$y+"]");
		}
	}
}

global proc asMirrorControlCurves (int $L2R, string $set)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
string $controlObjects[]=`sets -q $set`;
string $shapes[],$tempString[],$tempString2[];
string $oppositeShape,$oppositeControlObject;
float $pos[],$rot[],$sca[];
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	if ($shapes[0]=="")
		continue;
	$objType=`objectType $shapes[0]`;
	if ($objType!="nurbsCurve" && $objType!="nurbsSurface")
		continue;

	if ($L2R)
		{
		if (!`gmatch $shapes[0] "*_L*"`)
			continue;
		}
	else
		{
		if (!`gmatch $shapes[0] "*_R*"`)
			continue;
		}

	if ($set=="FaceControlSet" && `gmatch $shapes[0] "ctrl*"`)//not to mirror joystick ctrls
		continue;

	if ($L2R)
		{
		$oppositeShape=`substitute "_L" $shapes[0] "_R"`;
		$oppositeControlObject=`substitute "_L" $controlObjects[$i] "_R"`;
		}
	else
		{
		$oppositeShape=`substitute "_R" $shapes[0] "_L"`;
		$oppositeControlObject=`substitute "_R" $controlObjects[$i] "_L"`;
		}

	if (!`objExists $oppositeShape`)
		continue;

	if ($objType=="nurbsSurface")
		{
		select ($shapes[0]+".cv[0:999][0:999]");
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			//Correct if its not the Shape object returned by `ls`;
			tokenize $tempString[$y] "." $tempString2;
			if (`objectType $tempString2[0]`=="transform")
				$tempString[$y]=$shapes[0]+"."+$tempString2[1];

			$pos=`xform -q -ws -t $tempString[$y]`;
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] `substitute $shapes[0] $tempString[$y] $oppositeShape`;
			}
		if (`attributeExists softModControl $controlObjects[$i]` || `attributeExists clusterControl $controlObjects[$i]`)
			reverseSurface -d 0 -ch 0 -rpo 1 $oppositeShape;
		continue;
		}

	if ($set=="SkinCageCurvesSet")
		{//skinCurves could have been ajusted by changing the Xform, needs update to create correct SlideJoints
		$pos=`xform -q -ws -t $controlObjects[$i]`;
//		$rot=`getAttr ($controlObjects[$i]+".r")`;//unsure how to resolve rot
		$sca=`getAttr ($controlObjects[$i]+".s")`;
		xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] $oppositeControlObject;
		setAttr ($oppositeControlObject+".s") -type float3 $sca[0] $sca[1] $sca[2];
		}

	$form=`getAttr ($shapes[0]+".form")`;
	$spans=`getAttr ($shapes[0]+".spans")`;
	$degrees=`getAttr ($shapes[0]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;

	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($shapes[0]+".cv["+$y+"]")`;
		if ($y==0)	$z=2;
		if ($y==1)	$z=3;
		if ($y==2)	$z=0;
		if ($y==3)	$z=1;
		if ($y==4)	$z=2;
		if ($set=="SkinCageCurvesSet")
			{
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$z+"]");
			if ($y==2)
				xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv[4]");
			}
		else
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$y+"]");
		}

	//Mirror slideJoints
	if ($set=="SkinCageCurvesSet")
		{
		string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $controlObjects[$i]`;
		int $haveSliderJoint[4];
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
				$haveSliderJoint[$y]=1;
			else
				$haveSliderJoint[$y]=0;
		if ($haveSliderJoint[0] || $haveSliderJoint[1] || $haveSliderJoint[2] || $haveSliderJoint[3])
			{
			select $oppositeControlObject;
			asCreateSliders;
			//mirror .slide values
			for ($y=0;$y<4;$y++)
				{
				string $sliderJoint=$skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y;
				string $oppositeSliderJoint;
				if ($L2R) $oppositeSliderJoint=`substitute "_L" $sliderJoint "_R"`;
				else $oppositeSliderJoint=`substitute "_R" $sliderJoint "_L"`;
				if ($y==0) $oppositeSliderJoint=`substitute "0" $oppositeSliderJoint "2"`;
				if ($y==1) $oppositeSliderJoint=`substitute "1" $oppositeSliderJoint "3"`;
				if ($y==2) $oppositeSliderJoint=`substitute "2" $oppositeSliderJoint "0"`;
				if ($y==3) $oppositeSliderJoint=`substitute "3" $oppositeSliderJoint "1"`;
				if (`objExists $sliderJoint` && `objExists $oppositeSliderJoint`)
					setAttr ($oppositeSliderJoint+".slide") `getAttr ($sliderJoint+".slide")`;
				}
			}
		else // sliders might have been deleted, this should also mirror
			{
			string $oppositeSkinCurveSliderInfo[]=`asSkinCurveSliderInfo $oppositeControlObject`;
			int $oppositeHaveSliderJoint[4];
			for ($y=0;$y<4;$y++)
				if (`objExists ($oppositeSkinCurveSliderInfo[0]+"_"+$oppositeSkinCurveSliderInfo[1]+"Slider"+$y)`)
					$oppositeHaveSliderJoint[$y]=1;
			if ($oppositeHaveSliderJoint[0] || $oppositeHaveSliderJoint[1] || $oppositeHaveSliderJoint[2] || $oppositeHaveSliderJoint[3])
				{
				select $oppositeControlObject;
				asDeleteSliders;
				}
			}
		}
	}

//include faceCurves, if exists
if ($set=="ControlSet" && `objExists FaceControlSet`)
	asMirrorControlCurves $L2R FaceControlSet;

select $sel;
}

global proc asControllerGalleryImport ()
{
float $charHeight=`asgetCharHeight`;
float $factor=$charHeight/20.0;
float $pos[];
string $controllerGalleryFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asGallery.ma";
string $tempString[];

if (!`file -q -ex $controllerGalleryFile`)
	error ("Not found:"+$controllerGalleryFile);
if (`objExists deleteThis`)
	delete deleteThis;
file -i $controllerGalleryFile;

//place
if (!`objExists "Main"`)
	return;
//setAttr ControllerGallery.s -type float3 ($charHeight/20.0) ($charHeight/20.0) ($charHeight/20.0);
$tempString=`listRelatives -c ControllerGallery`;
for ($i=0;$i<size($tempString);$i++)
	{
	select $tempString[$i];
	selectCurveCV("all");
	$pos=`xform -q -ws -t $tempString[$i]`;
	scale -r -p $pos[0] $pos[1] $pos[2] $factor $factor $factor;
	xform -ws -t ($pos[0]*$factor) ($pos[1]*$factor) ($pos[2]*$factor) $tempString[$i];
	}
setAttr ControllerGallery.tx ($charHeight/-1.5);
select ControllerGallery;
print "// Controller Gallery imported.\n";
}

global proc asScaleControlCurves ()
{
//scale selected if any control curves are selected, otherwice scale all
global string $gMove;
float $pos[];
float $scale=`floatField -q -v ScaleCCFloatField`;
if ((`getModifiers`/4) %  2)
	$scale=1/$scale;
string $controlObjects[],$faceControlSetMembers[],$shapes[];
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`sets -im ControlSet $sel[$i]` || `sets -im FaceControlSet $sel[$i]`)
		$controlObjects[size($controlObjects)]=$sel[$i];
if (!size($controlObjects))
	{
	$controlObjects=`sets -q "ControlSet"`;
	//include faceCurves, if exists
	if (`objExists FaceControlSet`)
		{
		$faceControlSetMembers=`sets -q FaceControlSet`;
		$controlObjects=`stringArrayCatenate $controlObjects $faceControlSetMembers`;
		}
	}
string $controlCurves[];
string $tempString[];
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	for ($y=0;$y<size($shapes);$y++)
		{
		if (`objectType $shapes[$y]`!="nurbsCurve")
			continue;
		select ($shapes[$y]+".cv[0:99999]");
		refresh;
		setToolTo $gMove;
		$pos=`manipMoveContext -q -position "Move"`;
		scale -r -p $pos[0] $pos[1] $pos[2] $scale $scale $scale;
		}
	}
select $sel;
}

global proc string[] asSkinCurveSliderInfo (string $skinCurve)
{
string $info[];//[0]=$deformJoint [1]=start/middle/end [2]=restoreWeightsToJoint
string $childJoint;
string $tempString[];
tokenize $skinCurve "_" $tempString;
string $deformJoint=$tempString[0]+"_"+$tempString[1];
$info[0]=$deformJoint;
if (`gmatch $skinCurve "*_middleProfile"`)
	$info[1]="middle";
if (`gmatch $skinCurve "*_startProfile"`)
	$info[1]="start";
if (`gmatch $skinCurve "*_endProfile"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile1"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile[2-9]"`)
	{
	//First some traversing to find the childJoint
	$tempString=`listRelatives -c -type joint $deformJoint`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists ("FK"+$tempString[$i])` && !`gmatch $tempString[$i] "*Slider*"`) $childJoint=$tempString[$i];
		if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
		}
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -c -type joint $childJoint`;
		$childJoint="";
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`gmatch $tempString[$i] "*Slider*"`)
				continue;
			if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
			if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
			}
		}
	//Then see if it`s the lastTwister
	int $stringLenght=`size $skinCurve`;
	int $twistNr=`substring $skinCurve $stringLenght $stringLenght`;
	string $nextTwistProfile=`substring $skinCurve 1 ($stringLenght-1)`+($twistNr+1);
	if (!`objExists $nextTwistProfile` && `objExists $childJoint`)
		{
		$info[0]=$childJoint;
		$info[1]="start";
		}
	}

//[2]=restoreWeightsToJoint
if (`gmatch $skinCurve "*_twistProfile1"`)
	{
	tokenize $skinCurve "_" $tempString;
	string $twistJoint=$tempString[0]+"Part1_"+$tempString[1];
	if (`objExists $twistJoint`)
		$info[2]=$twistJoint;
	else
		$info[2]=$info[0];
	}
else
	{
	$tempString=`listRelatives -p $info[0]`;
	if (`gmatch $skinCurve "*_endProfile"`)
		$info[2]=$info[0];
	else
		$info[2]=$tempString[0];
	}
return $info;
}

global proc asConvertSoftModToCustomControl (string $type, int $face)
{
global string $gSelect;
global string $gMainProgressBar;
int $b=1;
int $mirror,$middle,$local,$partialParent,$haveSkinCluster,$numChar,$firstInBoxHit;
int $numVtxs[];
float $mag,$falloffRadius,$falloffMode,$weight,$maxWeight,$scale,$u,$V,$minDist,$squashDistance,$tol;
float $pos[],$vtxCurrentPos[],$vtxOriginPos[],$softModPos1[],$softModPos2[],$bb[],$s[],$ssBB[],$tPos[];
float $falloffCurvePoss[],$falloffCurveVals[],$falloffCurveInterps[],$currentTrans[],$tempFloatA[],$tempFloatB[],$tempFloatC[],$m[];
string $parent,$parentJoint,$softModHandle,$dialogResult,$restorePoseCmd,$facePrefix,$squashSelection;
string $sel[]=`ls -sl`;
string $selXforms[]=`ls -sl -type transform`;
string $side="_R";
setToolTo $gSelect;
string $name,$softMod,$mesh,$skinCluster,$choosenSkinCluster,$originalSkinCluster,$nearestJoint,$buildPoseCmd,$newCtrlBuildPoseCmd,$maxWeightVts,$myIntersector;
string $tempString[],$tempString2[],$tempString3[],$historyNodes[],$deformJoints[],$vtxs[],$historyNodes[],$attrs[];
string $requiredObj[]={"|Group","MotionSystem","DeformationSystem"};
string $TR[]={"T","R"};

if ($face)
	$facePrefix="Face";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*oftMod*Handle*"`)
		$softModHandle=$sel[$i];
if ($softModHandle=="")
	error "SoftMod must be selected";

if (!$face)
	for ($obj in $requiredObj)
		if (!`objExists $obj`)
			error ("Object:\""+$obj+"\" does not exists, a Rig is required");

if (!`objExists CustomControlMirrorSoftModHandle`)
	{
	if (`objExists CreatingCustomControl`)
		delete CreatingCustomControl;
	createNode -n CreatingCustomControl transform;
	addAttr -ln type -dt "string" CreatingCustomControl;
	setAttr -type "string" CreatingCustomControl.type $type;
	addAttr -ln name -dt "string" CreatingCustomControl;
	addAttr -ln parent -dt "string" CreatingCustomControl;
	addAttr -ln softModHandle -dt "string" CreatingCustomControl;
	setAttr -type "string" CreatingCustomControl.softModHandle $softModHandle;
	addAttr -ln face -at bool -dv $face CreatingCustomControl;
	addAttr -ln mirror -at bool -dv 1 CreatingCustomControl;
	addAttr -ln middle -at bool -dv 1 CreatingCustomControl;
	addAttr -ln local -at bool -dv 1 CreatingCustomControl;
	addAttr -ln partialParent -at bool -dv 1 CreatingCustomControl;
	addAttr -ln skinCluster -dt "string" CreatingCustomControl;
	select $sel;
	if (`layoutDialog -t "Confirm" -ui asCCLayout`!="OK")
		{
		delete CreatingCustomControl;
		if (`objExists asTempSoftModHandle`) delete asTempSoftModHandle;
		return;
		}
	}

setAttr -type float3 ($softModHandle+".t") 0 0 0;
$softModPos1=`xform -q -ws -piv $softModHandle`;

//CustomControls commons
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*oftMod*Handle*"`)
		$softModHandle=$sel[$i];
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
$type=`getAttr CreatingCustomControl.type`;
$name=`getAttr CreatingCustomControl.name`;
$mirror=`getAttr CreatingCustomControl.mirror`;

$middle=`getAttr CreatingCustomControl.middle`;
$local=`getAttr CreatingCustomControl.local`;
$partialParent=`getAttr CreatingCustomControl.partialParent`;
$parent=`getAttr CreatingCustomControl.parent`;
$choosenSkinCluster=`getAttr CreatingCustomControl.skinCluster`;
if (`objExists CustomControlMirrorSoftModHandle` && `gmatch $parent "*_R"`)
	{
	$numChar=size($parent);
	$parent=`substring $parent 1 ($numChar-2)`+"_L";
	}
asValidateName $name;

if ($type=="Squash" && !$middle && `gmatch $parent "*_M"`)//squash with _M parent forced to $middle
	$middle=1;

if ($type=="Squash") $local=1;//Squash always local, for the "bend" attribute to work by enable ty & tz (tx always stretch-axis)

//asEnsureCustomSystemGroup;
if (!`objExists ($facePrefix+"CustomSystem")`)
	{
	createNode -n ($facePrefix+"CustomSystem") transform;
	if (`objExists ($facePrefix+"MotionSystem")`)
		parent ($facePrefix+"CustomSystem") ($facePrefix+"MotionSystem");

	if ($face)
		connectAttr ctrlBox.CustomCtrlVis ($facePrefix+"CustomSystem.v");		
	if (!$face && `objExists Main`)
		{
		if (!`attributeExists customVis Main`)	
			{
			addAttr -k 1 -ln customVis -at bool -dv 1 Main;
			setAttr -k 0 -cb 1 Main.customVis;
			}
		connectAttr Main.customVis CustomSystem.v;
		if (`objExists MainScaleMultiplyDivide`)
			if (!`isConnected MainScaleMultiplyDivide.output CustomSystem.s`)
				connectAttr MainScaleMultiplyDivide.output CustomSystem.s;
		}
	}

//SoftMod attach point `could` be elsewhere when rig is in buildPose, find the new location, using UV ($softModPos2)
$historyNodes=`listHistory -f 1 -pdo 0 -il 2 $softMod`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="mesh")
		{
		$tempString=`listRelatives -p $historyNodes[$i]`;
		$mesh=$tempString[0];
		break;
		}

if ($type=="Skin")
	{
//	$skinCluster=`asGetSkinCluster $mesh`;
	if ($choosenSkinCluster=="")//Maya version < 2024
		$choosenSkinCluster=`asGetSkinCluster $mesh`;
	$skinCluster=$choosenSkinCluster;
	if ($skinCluster=="")
		{
		if (`objExists CreatingCustomControl`)
			delete CreatingCustomControl;
		error ("No SkinCluster found on this object :"+$mesh);
		}
	}

duplicate -n TempUVAttachMesh $mesh;
catchQuiet (`parent -w TempUVAttachMesh`);
$tempString=`listRelatives -f -s TempUVAttachMesh`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
select TempUVAttachMesh;
polyAutoProjection -ch 0 -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0;
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f TempUVAttachMesh.outMesh closestSampler.inMesh;
connectAttr -f TempUVAttachMesh.worldMatrix[0] closestSampler.inputMatrix;
setAttr closestSampler.inPosition $softModPos1[0] $softModPos1[1] $softModPos1[2];
$u=`getAttr closestSampler.parameterU`;
$v=`getAttr closestSampler.parameterV`;
delete closestSampler;
if (`objExists tempXform`) delete tempXform;
createNode -n tempXform transform;
select TempUVAttachMesh tempXform;
doCreatePointOnPolyConstraintArgList 1 { "0","0","0","1","","1" };
setAttr tempXform_pointOnPolyConstraint1.TempUVAttachMeshU0 $u;
setAttr tempXform_pointOnPolyConstraint1.TempUVAttachMeshV0 $v;
if ($face)
	asGoToBuildPose faceSetup;
else
	asGoToBuildPose bodySetup;
select $mesh TempUVAttachMesh;
blendShape -frontOfChain -w 0 1;
$softModPos2=`xform -q -ws -t tempXform`;
delete tempXform TempUVAttachMesh;

//update softMod to buildPose
xform -piv $softModPos2[0] $softModPos2[1] $softModPos2[2] $softModHandle;
setAttr ($softModHandle+".origin") -type float3 $softModPos2[0] $softModPos2[1] $softModPos2[2];
setAttr ($softMod+".falloffCenter") -type float3 $softModPos2[0] $softModPos2[1] $softModPos2[2];
$softModPos2=`xform -q -ws -piv $softModHandle`;

//softMod info
$falloffRadius=`getAttr ($softMod+".falloffRadius")`;
$falloffMode=`getAttr ($softMod+".falloffMode")`;
for ($i=0;$i<`getAttr -s ($softMod+".falloffCurve")`;$i++)
	{
	$falloffCurvePoss[$i]=`getAttr ($softMod+".falloffCurve["+$i+"].falloffCurve_Position")`;
	$falloffCurveVals[$i]=`getAttr ($softMod+".falloffCurve["+$i+"].falloffCurve_FloatValue")`;
	$falloffCurveInterps[$i]=`getAttr ($softMod+".falloffCurve["+$i+"].falloffCurve_Interp")`;
	}
$scale=$falloffRadius/4.0;
$tempString=`listConnections -type mesh ($softMod+".outputGeometry")`;
$mesh=$tempString[0];
if ($softModPos2[0]>0)
	{
	$side="_L";
	$b=-1;
	}
if ($middle)
	{
	$softModPos2[0]=0;
	setAttr ($softModHandle+".originX") 0;
	setAttr ($softMod+".falloffCenterX") 0;
	$side="_M";
	$b=1;
	}

//$parentJoint=$parent+$side;
if ($partialParent)
	{
	tokenize $parent "_" $tempString;
	$partialJoint=$tempString[0]+"Partial_"+$tempString[1];
	$tempString=`listRelatives -c -type joint $parent`;
	if ($tempString[0]=="")//still not exists, probably end-joint
		warning "50% as parent does not apply for End-Joints, Skipping.";
	else if (`gmatch $parent "*Part[0-9]*"`)
		warning "50% as parent does not apply for Partial-Joints, Skipping.";
	else
		{
		if (!`objExists $partialJoint`)
			{
			createNode -n asBatch transform;
			$restorePoseCmd=`asGetRestorePoseCmd`;
			asGoToBuildPose bodySetup;
			select $parent;
			asCreatePartialJoints;
			eval($restorePoseCmd);
			delete asBatch;
			}
		$parent=$partialJoint;
		}
	}

//Type SKIN
if ($type=="Skin")
	{
	//create DeformationsJoints
	select -cl;
	joint -n ($name+"Joint"+$side);
	parent ($name+"Joint"+$side) $parent;
	setAttr ($name+"Joint"+$side+".segmentScaleCompensate") 0;
	addAttr -ln "skinControlJoint" -at bool -dv 1 ($name+"Joint"+$side);
	xform -ws -t $softModPos2[0] $softModPos2[1] $softModPos2[2] ($name+"Joint"+$side);
	if ($local)
		{
		delete `orientConstraint $parent ($name+"Joint"+$side)`;
		makeIdentity -apply 1 -t 0 -r 1 -s 0 ($name+"Joint"+$side);
		}

	//create FK controls
	if (!`objExists ("ParentConstraintTo"+$parent)`)
		createNode -n ("ParentConstraintTo"+$parent) -p ($facePrefix+"CustomSystem") transform;
	createNode -n ("Offset"+$name+$side) transform;
	$tempString[0]=`curve -d 1 -p -0.5 0.5 0.5 -p -0.5 0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5
		-p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5 -p -0.5 -0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5
		-p 0.5 -0.5 -0.5 -p 0.5 -0.5 0.5 -p 0.5 0.5 0.5`;
	rename $tempString[0] ($name+$side);
	addAttr -ln "skinControl" -at bool -dv 1 ($name+$side);
	addAttr -ln "localOrient" -at bool -dv $local ($name+$side);
	xform -ws -s $scale $scale $scale ($name+$side+".cv[0:17]");
	setAttr ($name+$side+"Shape.isHistoricallyInteresting") 0;
	parent ($name+$side) ("Offset"+$name+$side);
	createNode -n ("X"+$name+$side) -p ($name+$side) transform;
	pointConstraint ($parent) ("ParentConstraintTo"+$parent);
	orientConstraint ($parent) ("ParentConstraintTo"+$parent);
	asAlign ("Offset"+$name+$side) ($name+"Joint"+$side) 1 0 0 0;
	if ($local)
		asAlign ("Offset"+$name+$side) ($name+"Joint"+$side) 0 1 0 0;
	parent ("Offset"+$name+$side) ("ParentConstraintTo"+$parent);
	if ($local && !$middle && `gmatch $parent "*_M"` && $side=="_R")
		{//Allowing for mirrored behaviour, even if Parent is "_M"
		createNode -n tempXForm transform;
		setAttr tempXForm.sx -1;
		parent tempXForm ("ParentConstraintTo"+$parent);
		$s=`getAttr tempXForm.s`;
		delete tempXForm;
		if ($face)
			setAttr ("Offset"+$name+$side+".s") -type float3 $s[0] $s[1] $s[2];
		else
			rotate -r -eu 180 180 0 ("Offset"+$name+$side);
		}

	setAttr ($name+$side+"Shape.overrideEnabled") 1;
	setAttr ($name+$side+"Shape.overrideColor") 17;
//	if ($choosenSkinCluster!=$originalSkinCluster)
		{
		parentConstraint ("X"+$name+$side) ($name+"Joint"+$side);
		if (!$face)
			parent ($name+"Joint"+$side+"_parentConstraint1") ConstraintSystem;
		connectAttr ($name+$side+".s") ($name+"Joint"+$side+".s");
		}
	//sets -add AllSet ("FK"+$name+$side) ("FK"+$name+$side+"Shape") ("FKExtra"+$name+$side) ("FKOffset"+$name+$side) ("FKParentConstraintTo"+$parent);
	//sets -add AllSet ($name+$side) ($name+"End"+$side);
	if (!$face)
		sets -add DeformSet ($name+"Joint"+$side);
	sets -add ($facePrefix+"ControlSet") ($name+$side);

	//add to $skinCluster
	//$tempString=`listConnections -s 0 -d 1 -type mesh $softMod`;
	//$mesh=$tempString[0];
	//imporved method to find Mesh, as ConvertSoftModToLayerdSkinClusters may have multiple SofMods
	$historyNodes=`listHistory -f 1 -pdo 0 -il 2 $softMod`;
	for ($i=0;$i<size($historyNodes);$i++)
		if (`objectType $historyNodes[$i]`=="mesh")
			{
			$tempString=`listRelatives -p $historyNodes[$i]`;
			$mesh=$tempString[0];
			break;
			}

	$originalSkinCluster=`findRelatedSkinCluster $mesh`;//must use findRelatedSkinCluster and not asGetSkinCluster

	if ($choosenSkinCluster=="*new")
		{
		if (!`objExists ExtraSkinClustersBaseJoint_M`)
			{
			createNode -n ExtraSkinClustersBaseJoint_M -p DeformationSystem joint;
			setAttr ExtraSkinClustersBaseJoint_M.drawStyle 2;
			setAttr -l 1 ExtraSkinClustersBaseJoint_M.inheritsTransform 0;
			if (`attributeExists jointVis Main`)
				connectAttr Main.jointVis ExtraSkinClustersBaseJoint_M.v;
			}
		select ExtraSkinClustersBaseJoint_M $mesh;
		$tempString=`skinCluster -multi 1`;
		reorderDeformers $originalSkinCluster $tempString[0] $mesh;
		$skinCluster=$tempString[0];
		//set SkinClusterOption to *This SC, as a MirrorRun should use same
		setAttr -type "string" CreatingCustomControl.skinCluster $skinCluster;
		}

	if ($choosenSkinCluster!=$originalSkinCluster)
		{
		delete ($name+"Joint"+$side+"_parentConstraint1");
		disconnectAttr ($name+$side+".s") ($name+"Joint"+$side+".s");

		createNode -n ($name+"JointOffset"+$side) -p ($name+"Joint"+$side) transform;
		parent ($name+"JointOffset"+$side) ExtraSkinClustersBaseJoint_M;
		parent ($name+"Joint"+$side) ($name+"JointOffset"+$side);
		createNode -n ($name+"JointMM"+$side) multMatrix;
		connectAttr ($name+$side+".worldMatrix") ($name+"JointMM"+$side+".matrixIn[0]");
		connectAttr ("Offset"+$name+$side+".worldInverseMatrix") ($name+"JointMM"+$side+".matrixIn[1]");
		connectAttr ($name+"JointMM"+$side+".matrixSum") ($name+"Joint"+$side+".offsetParentMatrix");;
		}

	skinCluster -e -lw false -wt 0 -ai ($name+"Joint"+$side) $skinCluster;

	createNode -n convertingSoftMod transform;
	addAttr -ln softMod -dt "string" convertingSoftMod;
	setAttr -type "string" convertingSoftMod.softMod $softMod;

	//weighting
	asSkinWeightBySoftMod ($name+"Joint"+$side) $mesh $skinCluster $falloffRadius $falloffMode;
	delete convertingSoftMod;
	}


//Type CLUSTER
if ($type=="Cluster")
	{
	//create control
	if (!`objExists asClusterControlShader`)
		{
		shadingNode -n asClusterControlShader -asShader lambert;
		sets -renderable true -noSurfaceShader true -empty -name asClusterControlShaderSG;
		connectAttr -f asClusterControlShader.outColor asClusterControlShaderSG.surfaceShader;
		setAttr -type float3 asClusterControlShader.color 1 0 0;
		}
	$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/1.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
	rename $tempString[0] ($name+$side);
	addAttr -ln "localOrient" -at bool -dv $local ($name+$side);
	addAttr -ln "clusterControl" -at bool -dv 1 ($name+$side);
	sets -e -forceElement asClusterControlShaderSG ($name+$side);
	//sets -add "ControlSet" ($name+$side);
	setAttr ($name+$side+"Shape.overrideEnabled") 1;
	setAttr ($name+$side+"Shape.overrideColor") 13;
	asSetRenderable ($name+$side+"Shape") 0;
	createNode -n ("ClusterControlGrp"+$name+$side) -p ($facePrefix+"CustomSystem") transform;
	setAttr -l 1 ("ClusterControlGrp"+$name+$side+".inheritsTransform") 0;
	createNode -n ("Attach"+$name+$side) transform;
	parent ("Attach"+$name+$side) ("ClusterControlGrp"+$name+$side);
	createNode -n ("Offset"+$name+$side) transform;
	createNode -n ("Subtract"+$name+$side) transform;
	parent ($name+$side) ("Subtract"+$name+$side);
	parent ("Subtract"+$name+$side) ("Offset"+$name+$side);
	parent ("Offset"+$name+$side) ("Attach"+$name+$side);
//	createNode -n ("X"+$name+$side) -p ($name+$side) transform;

	if ($face && `objExists MainAndHeadScaleMultiplyDivide`)
		connectAttr MainAndHeadScaleMultiplyDivide.output ("Attach"+$name+$side+".s");
	else if (!$face && `objExists MainScaleMultiplyDivide`)
		connectAttr MainScaleMultiplyDivide.output ("Attach"+$name+$side+".s");

	if (!$local)
		parent -w ("Offset"+$name+$side);
	orientConstraint $parent ("Attach"+$name+$side);
	if (!$local)
		parent ("Offset"+$name+$side) ("Attach"+$name+$side);

	//avoid double Xform
	createNode -n ("PlusMinusAverage"+$name+$side) plusMinusAverage;
	setAttr ("PlusMinusAverage"+$name+$side+".operation") 2;
	connectAttr -f ($name+$side+".t") ("PlusMinusAverage"+$name+$side+".input3D[0]");
	connectAttr -f ($name+$side+".t") ("PlusMinusAverage"+$name+$side+".input3D[1]");
	disconnectAttr ($name+$side+".t") ("PlusMinusAverage"+$name+$side+".input3D[0]");
	parent -w ("Offset"+$name+$side);
	connectAttr -f ("PlusMinusAverage"+$name+$side+".output3D") ("Subtract"+$name+$side+".t");
	xform -ws -t $softModPos2[0] $softModPos2[1] $softModPos2[2] ("Offset"+$name+$side); 

	//create cluster
	select $mesh;
	//$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
	$tempString=`asDeformer cluster`;
	rename $tempString[0] ("Cluster"+$name+$side);
	rename $tempString[1] ("Cluster"+$name+$side+"Handle");
	$tempString=`listConnections ("Cluster"+$name+$side+".message")`;
	rename $tempString[0] ("ClusterSet"+$name+$side);

	setAttr -type float3 ("Cluster"+$name+$side+"HandleShape.origin") $softModPos2[0] $softModPos2[1] $softModPos2[2];
	xform -piv $softModPos2[0] $softModPos2[1] $softModPos2[2] ("Cluster"+$name+$side+"Handle");
	parent ("Cluster"+$name+$side+"Handle") ("ClusterControlGrp"+$name+$side);
	setAttr -l 1 ("Cluster"+$name+$side+"Handle.v") 0;


	for ($i=0;$i<size($TR);$i++)
		{
		createNode -n ("MM"+$TR[$i]+$name+$side) multMatrix;
		createNode -n ("DM"+$TR[$i]+$name+$side) decomposeMatrix;
		connectAttr ($name+$side+".matrix") ("MM"+$TR[$i]+$name+$side+".matrixIn["+$i+"]");
		connectAttr ("MM"+$TR[$i]+$name+$side+".matrixSum") ("DM"+$TR[$i]+$name+$side+".inputMatrix");
		connectAttr ($name+$side+".rotateOrder") ("DM"+$TR[$i]+$name+$side+".inputRotateOrder");
		}

//	connectAttr -f ("DMT"+$name+$side+".outputTranslate") ("PlusMinusAverage"+$name+$side+".input3D[1]");
	connectAttr ("DMT"+$name+$side+".outputTranslate") ("Cluster"+$name+$side+"Handle.t");
	connectAttr ("DMT"+$name+$side+".outputScale") ("Cluster"+$name+$side+"Handle.s");
	connectAttr ("DMR"+$name+$side+".outputRotate") ("Cluster"+$name+$side+"Handle.r");

	createNode -n tempMatrixXform transform;
	asAlign tempMatrixXform ($name+$side) 0 1 0 0;
	$m=`xform -q -os -m tempMatrixXform`;
	setAttr ("MMT"+$name+$side+".matrixIn[1]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
	setAttr ("MMR"+$name+$side+".matrixIn[2]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
	$m=`getAttr tempMatrixXform.inverseMatrix`;
	setAttr ("MMR"+$name+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
	delete tempMatrixXform;

	//set clusterWeights
	select $mesh;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $softModPos2[0] $softModPos2[1] $softModPos2[2];
	$vtxs=`ls -sl -fl`;
	polySelectConstraint -m 0;
	//$mag=`mag<<$currentPos[0]-$softModPos2[0],$currentPos[1]-$softModPos2[1],$currentPos[2]-$softModPos2[2]>>`;
	//speed up by disable other deformers
	$historyNodes=`listHistory -pdo 1 -il 2 $mesh`;
	for ($i=0;$i<size($historyNodes);$i++)
		setAttr ($historyNodes[$i]+".nodeState") 1;
	setAttr ($softMod+".nodeState") 0;
	percent -v 0 ("Cluster"+$name+$side) ($mesh+".vtx[0:99999]");
	progressBar -e -st ("Converting SoftMod ("+$side+")") -bp -ii 1 -min 0 -max (size($vtxs)) $gMainProgressBar;
	evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
	for ($y=0;$y<size($vtxs);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{
			print "// Cancelled.\n";
			delete ("Offset"+$name+$side) ("Attach"+$name+$side) ("Cluster"+$name+$side+"Handle");
			select $softModHandle;
			return;
			}
		progressBar -e -s 1 $gMainProgressBar;
		setAttr -type float3 ($softModHandle+".t") 0 1 0;
		$vtxCurrentPos=`xform -q -ws -t $vtxs[$y]`;
		setAttr -type float3 ($softModHandle+".t") 0 0 0;
		$vtxOriginPos=`xform -q -ws -t $vtxs[$y]`;
	//	$vtxMag=`mag<<$vtxCurrentPos[0]-$vtxOriginPos[0],$vtxCurrentPos[1]-$vtxOriginPos[1],$vtxCurrentPos[2]-$vtxOriginPos[2]>>`;
	//	$weight=$vtxMag/1.0;
		$weight=($vtxCurrentPos[1]-$vtxOriginPos[1])/1.0;
		percent -v $weight ("Cluster"+$name+$side) $vtxs[$y];
		if ($weight>$maxWeight)
			{
			$maxWeightVts=$vtxs[$y];
			$maxWeight=$weight;
			}
		}
	for ($i=0;$i<size($historyNodes);$i++)
		setAttr ($historyNodes[$i]+".nodeState") 0;
	progressBar -e -ep $gMainProgressBar;

	//Attach to the vert that will have the highest weight, via CurveFromMeshEdge;
	select $maxWeightVts;
	ConvertSelectionToEdges;
	$tempString=`ls -sl -fl`;
	select $tempString[0];
	$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
	rename $tempString[0] ("Curve"+$name+$side);
	rename $tempString[1] ("CurveFromMeshEdge"+$name+$side);
	parent ("Curve"+$name+$side) ("ClusterControlGrp"+$name+$side);
	setAttr -l 1 ("Curve"+$name+$side+".v") 0;
	createNode -n ("PointOnCurveInfo"+$name+$side) pointOnCurveInfo;
	setAttr ("PointOnCurveInfo"+$name+$side+".turnOnPercentage") 1;
	connectAttr -f ("Curve"+$name+$side+"Shape.worldSpace[0]") ("PointOnCurveInfo"+$name+$side+".inputCurve");
	connectAttr -f ("PointOnCurveInfo"+$name+$side+".position") ("Attach"+$name+$side+".t");
	//determine PointOnCurveInfo.parameter
	$tempFloatA=`xform -q -ws -t $maxWeightVts`;
	$tempFloatB=`getAttr ("PointOnCurveInfo"+$name+$side+".position")`;
	$magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
	setAttr ("PointOnCurveInfo"+$name+$side+".parameter") 1;
	$tempFloatC=`getAttr ("PointOnCurveInfo"+$name+$side+".position")`;
	$magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
	if ($magAB<$magAC)
		setAttr ("PointOnCurveInfo"+$name+$side+".parameter") 0;
	parent ("Offset"+$name+$side) ("Attach"+$name+$side);

	//reorderDeformers
	$historyNodes=`listHistory -pdo 1 $mesh`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if ($haveSkinCluster)
		catch (`reorderDeformers $skinCluster ("Cluster"+$name+$side) $mesh`);

	//update buildPose
	$newCtrlBuildPoseCmd="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+$side+";";
	if ($face)
		{
		if (!`attributeExists udExtraAttr faceBuildPose`) addAttr -ln udExtraAttr -dt "string" faceBuildPose;
		$buildPoseCmd=`getAttr faceBuildPose.udExtraAttr`;
		setAttr -type "string" faceBuildPose.udExtraAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
		sets -add FaceControlSet ($name+$side);
		}
	else
		{
		if (!`attributeExists udExtraAttr buildPose`) addAttr -ln udExtraAttr -dt "string" buildPose;
		$buildPoseCmd=`getAttr buildPose.udExtraAttr`;
		setAttr -type "string" buildPose.udExtraAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
		sets -add ControlSet ($name+$side);
		}
	}


//Type SOFTMOD
if ($type=="SoftMod")
	{
	//create control
	if (!`objExists asSoftModControlShader`)
		{
		shadingNode -n asSoftModControlShader -asShader lambert;
		sets -renderable true -noSurfaceShader true -empty -name asSoftModControlShaderSG;
		connectAttr -f asSoftModControlShader.outColor asSoftModControlShaderSG.surfaceShader;
		setAttr -type float3 asSoftModControlShader.color 0 1 0;
		}
	$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/1.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
	rename $tempString[0] ($name+$side);
	addAttr -ln "localOrient" -at bool -dv $local ($name+$side);
	addAttr -ln "softModControl" -at bool -dv 1 ($name+$side);
	sets -e -forceElement asSoftModControlShaderSG ($name+$side);
	//sets -add "ControlSet" ($name+$side);
	setAttr ($name+$side+"Shape.overrideEnabled") 1;
	setAttr ($name+$side+"Shape.overrideColor") 14;
	asSetRenderable ($name+$side+"Shape") 0;
	createNode -n ($name+"Attach"+$side) transform;
	parent ($name+"Attach"+$side) ($facePrefix+"CustomSystem");

	//createsoftMod
	select $mesh;
	$tempString=`asDeformer softMod`;
	rename $tempString[0] ($name+"SoftMod"+$side);
	rename $tempString[1] ($name+"SoftModModHandle"+$side);
	$tempString=`listConnections ($name+"SoftMod"+$side+".message")`;
	rename $tempString[0] ($name+"SoftModSet"+$side);
	setAttr -type float3 ($name+"SoftModModHandle"+$side+".origin") $softModPos2[0] $softModPos2[1] $softModPos2[2];
	setAttr ($name+"SoftMod"+$side+".falloffCenter") $softModPos2[0] $softModPos2[1] $softModPos2[2];
	xform -piv $softModPos2[0] $softModPos2[1] $softModPos2[2] ($name+"SoftModModHandle"+$side);
	if (!`objExists CustomControlMirrorSoftModHandle`)
		nodePreset -save $softMod "asSoftMod";
	nodePreset -load ($name+"SoftMod"+$side) "asSoftMod";
	if (`objExists CustomControlMirrorSoftModHandle`)
		setAttr ($name+"SoftMod"+$side+".falloffCenterX") (`getAttr ($name+"SoftMod"+$side+".falloffCenterX")`*-1);

	$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
	rename $tempString[0] ($name+"Base"+$side);
	addAttr -ln "localOrient" -at bool -dv $local ($name+"Base"+$side);
	scale -r -p 0 0 0 ($scale/0.4) ($scale/0.4) ($scale/0.4) ($name+"Base"+$side+"Shape.cv[0:4]");
	setAttr ($name+"Base"+$side+"Shape.overrideEnabled") 1;
	setAttr ($name+"Base"+$side+"Shape.overrideColor") 17;
	parent ($name+"Base"+$side) ($name+"Attach"+$side);
	parent ($name+$side) ($name+"Base"+$side);

	spaceLocator -n ($name+"BaseLocator"+$side);
	parent ($name+"BaseLocator"+$side) ($name+"Base"+$side);
	setAttr -l 1 ($name+"BaseLocator"+$side+".v") 0;
	setAttr -l 1 ($name+"SoftModModHandle"+$side+".v") 0;
	connectAttr ($name+"BaseLocator"+$side+"Shape.worldPosition[0]") ($name+"SoftMod"+$side+".falloffCenter");

	xform -ws -t $softModPos2[0] $softModPos2[1] $softModPos2[2] ($name+"Attach"+$side);
// removing in v 6.212 as local was not attaching correctly when rotating Main, replace by a pre-align
	if ($local)
		delete `orientConstraint $parent ($name+"Attach"+$side)`;
/*
	if ($local)
		{
		pointConstraint -mo $parent ($name+"Attach"+$side);
		orientConstraint $parent ($name+"Attach"+$side);
		}
	else
*/
		parentConstraint -mo $parent ($name+"Attach"+$side);
	scaleConstraint $parent ($name+"Attach"+$side);

	disconnectAttr ($name+"SoftModModHandle"+$side+"Shape.softModTransforms[0]") ($name+"SoftMod"+$side+".softModXforms");
	disconnectAttr ($name+"SoftModModHandle"+$side+".worldMatrix[0]") ($name+"SoftMod"+$side+".matrix");
	delete ($name+"SoftModModHandle"+$side);

	//non-zero matrix, to avoid SoftMod reuse, when adding more then 1 softMod
	connectAttr ($name+"Attach"+$side+".worldMatrix[0]") ($name+"SoftMod"+$side+".matrix");

	connectAttr ($name+"Base"+$side+".worldInverseMatrix[0]") ($name+"SoftMod"+$side+".postMatrix");
	connectAttr ($name+"Base"+$side+".worldMatrix[0]") ($name+"SoftMod"+$side+".preMatrix");

	createNode -n ($name+"SoftModMultMatrix"+$side) multMatrix;
	connectAttr ($name+$side+".worldMatrix[0]") ($name+"SoftModMultMatrix"+$side+".matrixIn[0]");
	connectAttr ($name+$side+".parentInverseMatrix[0]") ($name+"SoftModMultMatrix"+$side+".matrixIn[1]");
	connectAttr ($name+"SoftModMultMatrix"+$side+".matrixSum") ($name+"SoftMod"+$side+".softModXforms.weightedMatrix");

	//falloffRadius
	addAttr -k 1 -ln falloffRadius -at double -dv 1 ($name+$side);
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv $falloffMode ($name+$side);
	connectAttr ($name+$side+".falloffMode") ($name+"SoftMod"+$side+".falloffMode");

	createNode -n ($name+"MainScaleForSoftModMPD1"+$side) multiplyDivide;
	connectAttr ($name+$side+".falloffRadius") ($name+"MainScaleForSoftModMPD1"+$side+".input1.input1X");
	setAttr ($name+"MainScaleForSoftModMPD1"+$side+".input2.input2X") $falloffRadius;
	//	connectAttr ($name+"MainScaleForSoftModMPD"+$side+".outputX") ($name+"SoftMod"+$side+".falloffRadius");

	createNode -n ($name+"MainScaleForSoftModMPD2"+$side) multiplyDivide;
	connectAttr ($name+"MainScaleForSoftModMPD1"+$side+".outputX") ($name+"MainScaleForSoftModMPD2"+$side+".input1.input1X");
	connectAttr ($name+"Attach"+$side+".sx") ($name+"MainScaleForSoftModMPD2"+$side+".input2.input2X");

	connectAttr ($name+"MainScaleForSoftModMPD2"+$side+".outputX") ($name+"SoftMod"+$side+".falloffRadius");
	}

//Type SQUASH
if ($type=="Squash")
	{
	$squashSelection=`getAttr ($softMod+".selection")`;

	$tempFloatA=`getAttr ($softMod+".boundingBoxMin")`;
	$tempFloatB=`getAttr ($softMod+".boundingBoxMax")`;
	$ssBB={$tempFloatA[0],$tempFloatB[0],$tempFloatA[1],$tempFloatB[1],$tempFloatA[2],$tempFloatB[2]};

	//create control
	if (!`objExists asSquashControlShader`)
		{
		shadingNode -n asSquashControlShader -asShader lambert;
		sets -renderable true -noSurfaceShader true -empty -name asSquashControlShaderSG;
		connectAttr -f asSquashControlShader.outColor asSquashControlShaderSG.surfaceShader;
		setAttr -type float3 asSquashControlShader.color 1 1 0;
		}
	$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
	rename $tempString[0] ($name+$side);
	setAttr ($name+$side+"Shape.overrideEnabled") 1;
	setAttr ($name+$side+"Shape.overrideColor") 13;
	addAttr -ln "localOrient" -at bool -dv $local ($name+$side);
	addAttr -ln "SquashControl" -at bool -dv 1 ($name+$side);
//	asLockAttr ($name+$side) 0 1 1 0;
	createNode -n ($name+"Attach"+$side) transform;
	parent ($name+"Attach"+$side) ($facePrefix+"CustomSystem");

	$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
	rename $tempString[0] ($name+"Base"+$side);
	addAttr -ln "localOrient" -at bool -dv $local ($name+"Base"+$side);
	scale -r -p 0 0 0 ($scale/0.4) ($scale/0.4) ($scale/0.4) ($name+"Base"+$side+"Shape.cv[0:4]");
	setAttr ($name+"Base"+$side+"Shape.overrideEnabled") 1;
	setAttr ($name+"Base"+$side+"Shape.overrideColor") 17;

	asCreateSquashDeformSetup $name $side $b $local $parent $softMod $squashSelection $softModPos2;
	}

addAttr -ln "parent" -dt "string" ($name+$side);
setAttr -type "string" ($name+$side+".parent") $parent;

//update buildPose
$newCtrlBuildPoseCmd="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+$side+";";
$attrs=`listAttr -ud -k ($name+$side)`;
for ($i=0;$i<size($attrs);$i++)
	$newCtrlBuildPoseCmd+="setAttr "+$name+$side+"."+$attrs[$i]+" "+`getAttr ($name+$side+"."+$attrs[$i])`+";";
if (`objExists ($name+"Base"+$side)`)
	$newCtrlBuildPoseCmd+="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+"Base"+$side+";";
if ($face)
	{
	if (!`attributeExists udExtraAttr faceBuildPose`) addAttr -ln udExtraAttr -dt "string" faceBuildPose;
	$buildPoseCmd=`getAttr faceBuildPose.udExtraAttr`;
	setAttr -type "string" faceBuildPose.udExtraAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
	sets -add FaceControlSet ($name+$side);
	if (`objExists ($name+"Base"+$side)`) sets -add FaceControlSet ($name+"Base"+$side);
	}
else
	{
	if (!`attributeExists udExtraAttr buildPose`) addAttr -ln udExtraAttr -dt "string" buildPose;
	$buildPoseCmd=`getAttr buildPose.udExtraAttr`;
	setAttr -type "string" buildPose.udExtraAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
	sets -add ControlSet ($name+$side);
	if (`objExists ($name+"Base"+$side)`) sets -add ControlSet ($name+"Base"+$side);
	}

delete $softModHandle;
//xform -ws -t  $softModPos2[0] $softModPos2[1] $softModPos2[2] ($name+$side);

if ($mirror && !`objExists CustomControlMirrorSoftModHandle` && $side=="_R")
	{
	//If not same mesh on other side. e.g. shoes, then find Left mesh
	$bb=`xform -q -bb $mesh`;
	if ($bb[3]<($softModPos1[0]*-1))
		{
		$minDist=999;
		$tempString=`ls -ni -l -type mesh`;
		if (`objExists closestSampler`) delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		setAttr closestSampler.inPosition ($softModPos1[0]*-1) $softModPos1[1] $softModPos1[2];
		for ($i=0;$i<size($tempString);$i++)
			{
			connectAttr -f ($tempString[$i]+".outMesh") closestSampler.inMesh;
			connectAttr -f ($tempString[$i]+".worldMatrix[0]") closestSampler.inputMatrix;
			$pos=`getAttr closestSampler.position`;
			$dist=`mag<<($softModPos1[0]*-1)-$pos[0],$softModPos1[1]-$pos[1],$softModPos1[2]-$pos[2]>>`;
			if ($dist<$minDist)
				{
				$minDist=$dist;
				$tempString2=`listRelatives -p $tempString[$i]`;
				$mesh=$tempString2[0];
				}
			}
		}
	if (`objExists closestSampler`) delete closestSampler;
	select $mesh;
	$tempString=`asDeformer softMod`;
	rename $tempString[0] CustomControlMirrorSoftMod;
	rename $tempString[1] CustomControlMirrorSoftModHandle;
	setAttr -type float3 CustomControlMirrorSoftModHandle.origin ($softModPos2[0]*-1) $softModPos2[1] $softModPos2[2];
	setAttr CustomControlMirrorSoftMod.falloffCenter ($softModPos2[0]*-1) $softModPos2[1] $softModPos2[2];
//	setAttr -l 1 CustomControlMirrorSoftMod.falloffCenterX;
	xform -piv ($softModPos2[0]*-1) $softModPos2[1] $softModPos2[2] CustomControlMirrorSoftModHandle;
	setAttr CustomControlMirrorSoftMod.falloffMode $falloffMode;
	setAttr CustomControlMirrorSoftMod.falloffRadius $falloffRadius;
	//use same Falloff Curve
	for ($i=0;$i<size($falloffCurvePoss);$i++)
		{
		setAttr ("CustomControlMirrorSoftMod.falloffCurve["+$i+"].falloffCurve_Position") $falloffCurvePoss[$i];
		setAttr ("CustomControlMirrorSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue") $falloffCurveVals[$i];
		setAttr ("CustomControlMirrorSoftMod.falloffCurve["+$i+"].falloffCurve_Interp") $falloffCurveInterps[$i];
		}
	select CustomControlMirrorSoftModHandle;
//	select -add `substitute "_R" $parent "_L"`;
	if ($type=="Squash")
		{
		addAttr -k 0 -ln squashDistance -at double -dv $squashDistance CustomControlMirrorSoftMod;
		//detect mirror vtxs, by all vtx within mirrored bb
		//expand BB slightly to ensure include of `mirrored vtxs`
		$tol=$falloffRadius/10.0;
		$ssBB[0]-=$tol;$ssBB[1]-=$tol;$ssBB[2]-=$tol;$ssBB[3]+=$tol;$ssBB[4]+=$tol;$ssBB[5]+=$tol;
		select `ls -ni -l -type mesh`;
		polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($ssBB[3]-$ssBB[0])/2.0) -da 1 0 0 -dp ((($ssBB[3]+$ssBB[0])/2.0)*-1) 0 0;
		$tempString=`ls -sl -fl`;
		polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($ssBB[4]-$ssBB[1])/2.0) -da 0 1 0 -dp 0 (($ssBB[4]+$ssBB[1])/2.0) 0;
		$tempString2=`ls -sl -fl`;
		polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($ssBB[5]-$ssBB[2])/2.0) -da 0 0 1 -dp 0 0 (($ssBB[5]+$ssBB[2])/2.0);
		$tempString3=`ls -sl -fl`;
		polySelectConstraint -m 0;

		$myIntersector = `stringArrayIntersector`;
		stringArrayIntersector -edit -intersect $tempString $myIntersector;
		stringArrayIntersector -edit -intersect $tempString2 $myIntersector;
		stringArrayIntersector -edit -intersect $tempString3 $myIntersector;
		select `stringArrayIntersector -query $myIntersector`;
		asCreateSquashController;
		}
	else
		asConvertSoftModToCustomControl $type $face;
	}

if (`objExists CreatingCustomControl`)
	delete CreatingCustomControl;
select ($name+$side);
print ("// SkinControl \""+$name+$side+"\" created\n");
}

global proc asDeleteSquashController ()
{
string $side,$sideLess,$attach;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[];

for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`ls -l $sel[$i]`;
	if (!`gmatch $tempString[0] "*CustomSystem|*"`)
		continue;
	tokenize $sel[$i] "_" $tempString2;
	$sideLess=$tempString2[0];
	$side="_"+$tempString2[1];
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==-1)
			{
			if ($side=="_R") $side="_L";
			else if ($side=="_L") $side="_R";
			else continue;
			if (!`objExists ($sideLess+$side)`)
				continue;
			}
		$attach=$sideLess+"Attach"+$side;
		if (!`objExists $attach`)
			continue;
		delete $attach;
		}
	}
asUpdatePoseAttributes;
}

global proc asValidateName (string $name)
{
if (`gmatch $name "*_*"`)
	error "illegal character (Underscore) found in the name, choose a name with no underscore";
if (`gmatch $name "[0-9]*"`)
	error "illegal name, name can not start with a number";
}

global proc string asCustomControlNameFromNearestJoint (string $nearestJoint, string $type, string $customControlside)
{
string $sideLess,$side,$name;
string $tempString[];

tokenize $nearestJoint "_" $tempString;
$sideLess=$tempString[0];
$side="_"+$tempString[1];

for ($i=1;$i<99;$i++)
	{
	$name=$type+$i+$sideLess;
	if (!`objExists ($name+$customControlside)`)
		break;
	}
return $name;
}

global proc asPaintClusterControlWeights ()
{
global string $artSelectObject;
string $side,$sideLess,$clusterHandle,$cluster,$clusterSet;
string $tempString[];
string $sel[]=`ls -sl`;

if ($sel[0]=="") error "Select Control first";
tokenize $sel[0] "_" $tempString;
$sideLess=$tempString[0];
$side="_"+$tempString[1];
$clusterHandle=$sideLess+"Cluster"+$side+"Handle";
if (!`objExists $clusterHandle`)
	error ("No ClusterHandle found (\""+$clusterHandle+"\"), selected object is not a Cluster-Control");

$tempString=`listConnections ($clusterHandle+".worldMatrix")`;
$cluster=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
$clusterSet=$tempString[0];
select $clusterSet;
select `ls -sl -o`;

artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$cluster+".weights\")");
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$cluster+".weights\")");
toolPropertyWindow;
}

global proc asMirrorClusterControlWeights ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $mirrorCuster,$mirrorVtx,$object,$clusterHandle,$cluster,$clusterSet,$sideLess,$side;
float $tempFloat[],$pos[];

if ($sel[0]=="")
	error "Select Control first";
if (!`attributeExists clusterControl $sel[0]`)
	error ("Selected object \""+$sel[0]+"\" does not appear to be a Cluster Control, it does not have the required \"clusterControl\" attribute.");
if (`gmatch $sel[0] "*_M"`)
	error "\"Middle\" Controllers can not be mirrored, instead use the mirror option in the Paint Weights Tool.";

tokenize $sel[0] "_" $tempString;
$sideLess=$tempString[0];
$side="_"+$tempString[1];
$clusterHandle=$sideLess+"Cluster"+$side+"Handle";

$tempString=`listConnections ($clusterHandle+".worldMatrix")`;
$cluster=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
$clusterSet=$tempString[0];
select $clusterSet;
$tempString=`ls -sl -fl`;
select `ls -sl -o`;
$tempString2=`ls -sl`;
$tempString2=`listRelatives -p $tempString2[0]`;
$object=$tempString2[0];

if (`gmatch $cluster "*_R"`)
	$mirrorCuster=`substitute "_R" $cluster "_L"`;
else
	$mirrorCuster=`substitute "_L" $cluster "_R"`;

percent -v 0 $mirrorCuster $object;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr ($object+".outMesh") closestSampler.inMesh;
//connectAttr -f ($object+".matrix") closestSampler.inputMatrix;\\Creates incorrect results, so just rely on Mesh have frozen xforms

progressBar -e -st "Mirroring" -bp -ii 1 -min 0 -max (size($tempString)) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
for ($i=0;$i<size($tempString);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
	progressBar -e -s 1 $gMainProgressBar;
	$tempFloat=`percent -q -v $cluster $tempString[$i]`;
	$pos=`xform -q -ws -t $tempString[$i]`;
	if (`gmatch $cluster "*_R"` && $pos[0]>-0.001)
		continue;
	if (`gmatch $cluster "*_L"` && $pos[0]<0.001)
		continue;
	setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
	$mirrorVtx=$object+".vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	percent -v $tempFloat[0] $mirrorCuster $mirrorVtx;
	}
progressBar -e -ep $gMainProgressBar;
delete closestSampler;
select $sel;
}

global proc asAddSoftModInfluencedObject ()
{
string $set,$joint,$sc;
string $tempString[],$tempString2[],$objectsToAdd[];
string $sel[]=`ls -sl`;

if (size($sel)<2)
	error "Select the controller, AND the object that should be influenced";

for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] "_" $tempString;
	if (size($tempString)>1)
		{
		if (`objExists ($tempString[0]+"SoftModSet_"+$tempString[1])`)
			{
			$set=$tempString[0]+"SoftModSet_"+$tempString[1];
			continue;
			}
		else if (`objExists ($tempString[0]+"ClusterSet_"+$tempString[1])`)
			{
			$set=$tempString[0]+"ClusterSet_"+$tempString[1];
			continue;
			}
		else if (`objExists ($tempString[0]+"Joint_"+$tempString[1])`)
			{
			$joint=$tempString[0]+"Joint_"+$tempString[1];
			continue;
			}
		}
	$objectsToAdd[size($objectsToAdd)]=$sel[$i];
	}

if ($set=="" && $joint=="")
	error "No DeformerSet or Joint found, selected object is not a valid Custom-Control";

for ($i=0;$i<size($objectsToAdd);$i++)
	{
	print ("// Adding object \""+$objectsToAdd[$i]+"\".\n");
	if ($set!="")
		{
		sets -add $set $objectsToAdd[$i];
		}
	if ($joint!="")
		{
		$sc=`asGetSkinCluster $objectsToAdd[$i]`;
		if ($sc=="")
			{
			select $joint $objectsToAdd[$i];
			newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
			}
		else
			skinCluster -e -lw false -wt 0 -ai $joint $sc;
		}
	}
}

global proc asDeleteCustomControl ()
{
int $controlDeleted,$isFace,$isSkinControl,$isClusterControl,$isSoftmodControl;
string $joint,$cluster,$softMod,$side,$sideLess;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[];

if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $sel[0]`)
		$isFace=1;

for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`ls -l $sel[$i]`;
	if (!`gmatch $tempString[0] "*CustomSystem|*"`)
		continue;
	tokenize $sel[$i] "_" $tempString2;
	$sideLess=$tempString2[0];
	$side="_"+$tempString2[1];
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==-1)
			{
			if ($side=="_R") $side="_L";
			else if ($side=="_L") $side="_R";
			else continue;
			if (!`objExists ($sideLess+$side)`)
				continue;
			}

		$joint=$sideLess+"Joint"+$side;
		$cluster=$sideLess+"Cluster"+$side;
		$softMod=$sideLess+"SoftMod"+$side;
		if (`objExists $joint`) $isSkinControl=1;
		if (`objExists $cluster`) $isClusterControl=1;
		if (`objExists $softMod`) $isSoftmodControl=1;

		$tempString=`ls -l ($sideLess+$side)`;
		tokenize $tempString[0] "|" $tempString2;
		for ($y=0;$y<size($tempString2);$y++)
			if ($tempString2[$y]=="CustomSystem")
				{
				if ($isSkinControl)
					delete $tempString2[$y+2];
				if ($isClusterControl || $isSoftmodControl)
					delete $tempString2[$y+1];
				}

		if ($isSkinControl) delete $joint;

		}

	$controlDeleted=1;
	}

if ($controlDeleted)
	{
	if ($isFace)
		asRemoveUnusedfromBuildPose faceSetup;
	else
		asRemoveUnusedfromBuildPose bodySetup;
	print "// Custom control Deleted.\n";
	}
else
	print "// No Custom control selected.\n";
}

global proc asCreateSquashController ()
{
float $falloffRadius;
float $bb[]={999,999,999,-999,-999,-999};
float $bb2[];
string $softMod="asTempSoftMod";
string $softModHandle="asTempSoftModHandle";
string $tempString[];
string $sel[]=`ls -sl`;
string $requiredObj[]={"|Group","MotionSystem","DeformationSystem"};

for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists, a Rig is required");

if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists CustomControlMirrorSoftModHandle`)
	{
	$softMod="CustomControlMirrorSoftMod";
	$softModHandle="CustomControlMirrorSoftModHandle";
	}

for ($i=0;$i<size($sel);$i++)
	{
	$bb2=`xform -q -ws -bb $sel[$i]`;
	if ($bb2[0]<$bb[0]) $bb[0]=$bb2[0];
	if ($bb2[1]<$bb[1]) $bb[1]=$bb2[1];
	if ($bb2[2]<$bb[2]) $bb[2]=$bb2[2];
	if ($bb2[3]>$bb[3]) $bb[3]=$bb2[3];
	if ($bb2[4]>$bb[4]) $bb[4]=$bb2[4];
	if ($bb2[5]>$bb[5]) $bb[5]=$bb2[5];
	}

$falloffRadius=(($bb[3]-$bb[0])+($bb[4]-$bb[1])+($bb[5]-$bb[2]))/3.0; //bb average
if (`objExists CustomControlMirrorSoftModHandle`)
	select CustomControlMirrorSoftModHandle;
else
	{
	$tempString=`asDeformer softMod`;
	rename $tempString[0] asTempSoftMod;
	rename $tempString[1] asTempSoftModHandle;
	}
setAttr ($softMod+".falloffRadius") $falloffRadius;
addAttr -ln selection -dt "string" $softMod;
setAttr -type "string" ($softMod+".selection") `stringArrayToString $sel " "`;

addAttr -ln boundingBoxMin -dt float3 $softMod;
addAttr -ln boundingBoxMax -dt float3 $softMod;
setAttr ($softMod+".boundingBoxMin") -type float3 $bb[0] $bb[2] $bb[4];
setAttr ($softMod+".boundingBoxMax") -type float3 $bb[1] $bb[3] $bb[5];

asConvertSoftModToCustomControl Squash 0;
}

global proc asCreateSquashDeformSetup (string $name, string $side, int $b, int $local,string $parent, string $softMod, string $squashSelection, float $softModPos2[])
{
global string $gMove;
global string $gSelect;
int $oneJointProp;
float $s,$squashDistance,$dist;
float $pos2[],$posA[],$posB[];
float $pos[]=`xform -q -ws -t $parent`;
float $outAngles[];
string $tempString[];

$tempString=`listRelatives -ad -type joint DeformationSystem`;
if (size($tempString)==1)
	$oneJointProp=1;

if ($local)
	{
	createNode -n tempTransform1 -p $parent transform;
	parent -w tempTransform1;
	orientConstraint -mo tempTransform1 Main;
	setAttr tempTransform1.r -type float3 0 0 (90*$b);
	}

eval ("select "+$squashSelection);
//Note: this issues Warnings on the "Mirror-Run"
$tempString=`asDeformer ("lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2")`;
rename $tempString[0] ($name+"Ffd"+$side);
rename $tempString[1] ($name+"FfdLattice"+$side);
rename $tempString[2] ($name+"FfdBase"+$side);
$tempString=`listConnections -s 0 -d 1 -type objectSet ($name+"Ffd"+$side+".message")`;
rename $tempString[0] ($name+"FfdSet"+$side);
setAttr ($name+"Ffd"+$side+".outsideLattice") 1;
setAttr ($name+"Ffd"+$side+".local") 0;

if ($local)
	{
	parent ($name+"FfdLattice"+$side) ($name+"FfdBase"+$side) Main;
	delete tempTransform1;
	setAttr Main.r -type float3 0 0 0;
	parent -w ($name+"FfdLattice"+$side) ($name+"FfdBase"+$side);
	}

$squashDistance=`getAttr ($name+"FfdLattice"+$side+".sy")`;
scale -r -p 0 0 0 ($squashDistance/5.0) ($squashDistance/5.0) ($squashDistance/5.0) ($name+$side+".cv[0:99]");
addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 ($name+$side);
setAttr ($name+$side+".rotateOrder") 1;//so rotY can drive lattice twist

//addAttr -k 1 -ln squashLimit -at double -min 0 -dv 2 ($name+$side);
//addAttr -k 1 -ln stretchLimit -at double -min 0 -dv 2 ($name+$side);
addAttr -k 1 -ln squash -at bool -dv 1 ($name+$side);
addAttr -k 1 -ln stretch -at bool -dv 1 ($name+$side);
addAttr -k 1 -ln bend -at bool -dv 1 ($name+$side);

//place Attach
if ($oneJointProp)//oneJoint prob has Base at bottom of object instead of at $parent-pivot
	{
	select -r ($name+"FfdLattice"+$side+".pt[0:1][0][0]") ($name+"FfdLattice"+$side+".pt[0:1][0][1]");
	setToolTo $gMove;
	$pos2=`manipMoveContext -q -position "Move"`;
	setToolTo $gSelect;
	}
else
	$pos2=`xform -q -ws -t $parent`;
xform -ws -t $pos2[0] $pos2[1] $pos2[2] ($name+"Attach"+$side);
delete `orientConstraint $parent ($name+"Attach"+$side)`;

//Group
createNode -n ($name+"WS"+$side) -p ($name+"Attach"+$side) transform;
setAttr -l 1 ($name+"WS"+$side+".inheritsTransform") 0;

//Offset
createNode -n ($name+"Offset"+$side) transform;
parent ($name+$side) ($name+"Offset"+$side);
if ($local)
	{
	delete `orientConstraint $parent ($name+"Offset"+$side)`;
	delete `orientConstraint -offset 0 0 (-90*$b) $parent ($name+"FfdLattice"+$side)`;
	delete `orientConstraint -offset 0 0 (-90*$b) $parent ($name+"FfdBase"+$side)`;
	}

//parent
parent -r ($name+"Base"+$side) ($name+"Attach"+$side);
parent ($name+"FfdLattice"+$side) ($name+"WS"+$side);
parent ($name+"FfdBase"+$side) ($name+"Base"+$side);

//Attach Attach
parentConstraint -mo $parent ($name+"Attach"+$side);
scaleConstraint $parent ($name+"Attach"+$side);

//place Offset
select -r ($name+"FfdLattice"+$side+".pt[0:1][10][0]") ($name+"FfdLattice"+$side+".pt[0:1][10][1]");
setToolTo $gMove;
$pos2=`manipMoveContext -q -position "Move"`;
setToolTo $gSelect;
xform -ws -t $pos2[0] $pos2[1] $pos2[2] ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Base"+$side);

$posA=`xform -q -ws -t ($name+"FfdLattice"+$side+".pt[0][0][0]")`;
$posB=`xform -q -ws -t ($name+"FfdLattice"+$side+".pt[0][1][0]")`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

//IKX
select ($name+"Base"+$side);
for ($i=0;$i<11;$i++)
	{
	joint -n ($name+"IKX"+$i+$side);
	if ($i>0)
		setAttr ($name+"IKX"+$i+$side+".tx") ($dist*$b);
	}

//SplineIK
//setAttr ($name+"IKX1"+$side+".segmentScaleCompensate") 0;
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj ($name+"IKX0"+$side) -ee ($name+"IKX10"+$side)`;
rename $tempString[0] ($name+"IKHandle"+$side);
rename $tempString[1] ($name+"IKEffector"+$side);
rename $tempString[2] ($name+"IKCurve"+$side);
parent ($name+"IKHandle"+$side) ($name+"IKCurve"+$side) ($name+"WS"+$side);
setAttr -l 1 ($name+"IKHandle"+$side+".v") 0;
for ($i=0;$i<5;$i++)
    {
    select -r ($name+"IKCurve"+$side+".cv["+$i+"]");
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ($name+"IKCluster"+$i+$side);
    rename $tempString[1] ($name+"IKClusterHandle"+$i+$side);
    setAttr -l 1 ($name+"IKClusterHandle"+$i+$side+".v") 0;
    }
select -cl;
for ($i=0;$i<11;$i++)
    select -add ($name+"IKX"+$i+$side);
select -add ($name+"FfdLattice"+$side);
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] ($name+"IKSC"+$side);

for ($i=0;$i<11;$i++)
	skinPercent -tv ($name+"IKX"+$i+$side) 1 ($name+"IKSC"+$side) ($name+"FfdLattice"+$side+".pt[0:1]["+$i+"][0]") ($name+"FfdLattice"+$side+".pt[0:1]["+$i+"][1]");

pointConstraint -w 0.95 ($name+"IKClusterHandle4"+$side)  ($name+"IKClusterHandle3"+$side);
pointConstraint -w 0.05 ($name+"IKClusterHandle2"+$side)  ($name+"IKClusterHandle3"+$side);

delete ($name+"IKClusterHandle3"+$side+"_pointConstraint1");
parent ($name+"IKClusterHandle3"+$side) ($name+"IKClusterHandle4"+$side);

//parent ($name+"IKClusterHandle4"+$side) ($name+$side);
parent ($name+"IKClusterHandle0"+$side) ($name+"IKClusterHandle1"+$side) ($name+"Base"+$side);

createNode -n ($name+"IKClusterHandle4Offset"+$side) -p ($name+"Offset"+$side) transform;
parent ($name+"IKClusterHandle4"+$side) ($name+"IKClusterHandle4Offset"+$side);
createNode -n ($name+"BendMPDT"+$side) multiplyDivide;
connectAttr ($name+$side+".ty") ($name+"BendMPDT"+$side+".input1Y");
connectAttr ($name+$side+".tz") ($name+"BendMPDT"+$side+".input1Z");
connectAttr ($name+$side+".bend") ($name+"BendMPDT"+$side+".input2Y");
connectAttr ($name+$side+".bend") ($name+"BendMPDT"+$side+".input2Z");
connectAttr ($name+"BendMPDT"+$side+".outputY") ($name+"IKClusterHandle4Offset"+$side+".ty");
connectAttr ($name+"BendMPDT"+$side+".outputZ") ($name+"IKClusterHandle4Offset"+$side+".tz");
connectAttr ($name+$side+".tx") ($name+"IKClusterHandle4Offset"+$side+".tx");

createNode -n ($name+"BendMPDR"+$side) multiplyDivide;
connectAttr ($name+$side+".rx") ($name+"BendMPDR"+$side+".input1X");
connectAttr ($name+$side+".ry") ($name+"BendMPDR"+$side+".input1Y");
connectAttr ($name+$side+".rz") ($name+"BendMPDR"+$side+".input1Z");
connectAttr ($name+$side+".bend") ($name+"BendMPDR"+$side+".input2X");
connectAttr ($name+$side+".bend") ($name+"BendMPDR"+$side+".input2Y");
connectAttr ($name+$side+".bend") ($name+"BendMPDR"+$side+".input2Z");
connectAttr ($name+"BendMPDR"+$side+".outputX") ($name+"IKClusterHandle4Offset"+$side+".rx");
connectAttr ($name+"BendMPDR"+$side+".outputY") ($name+"IKClusterHandle4Offset"+$side+".ry");
connectAttr ($name+"BendMPDR"+$side+".outputZ") ($name+"IKClusterHandle4Offset"+$side+".rz");

//Handle2
parent ($name+"IKClusterHandle2"+$side) ($name+"WS"+$side);
parentConstraint -mo ($name+"IKClusterHandle4"+$side) ($name+"IKClusterHandle0"+$side) ($name+"IKClusterHandle2"+$side);
createNode -n ($name+"IKCurveInfo"+$side) curveInfo;
connectAttr ($name+"IKCurve"+$side+".worldSpace[0]") ($name+"IKCurveInfo"+$side+".inputCurve");

createNode -n ($name+"IKCurveInfoNormalize"+$side) multiplyDivide;
setAttr ($name+"IKCurveInfoNormalize"+$side+".operation") 2;
connectAttr ($name+"IKCurveInfo"+$side+".arcLength") ($name+"IKCurveInfoNormalize"+$side+".input1X");
setAttr ($name+"IKCurveInfoNormalize"+$side+".input2X") `getAttr ($name+"IKCurveInfoNormalize"+$side+".input1X")`;
createNode -n ($name+"IKScale"+$side) multiplyDivide;

connectAttr ($name+"BendMPDR"+$side+".outputX") ($name+"IKHandle"+$side+".twist");
if ($side=="_L")
	{
	createNode -n ($name+"IKTwistReverse"+$side) multiplyDivide;
	connectAttr ($name+$side+".rx") ($name+"IKTwistReverse"+$side+".input1X");
	setAttr ($name+"IKTwistReverse"+$side+".input2X") -1;
	connectAttr -f ($name+"IKTwistReverse"+$side+".outputX") ($name+"IKHandle"+$side+".twist");
	}

//scale-compansate Main ctrl
createNode -n ($name+"IKCurveInfoMainScale"+$side) multiplyDivide;
setAttr ($name+"IKCurveInfoMainScale"+$side+".operation") 2;
connectAttr ($name+"IKCurveInfoNormalize"+$side+".outputX") ($name+"IKCurveInfoMainScale"+$side+".input1X");
//connectAttr  ($name+"LimitsClamp"+$side+".outputR") ($name+"IKCurveInfoMainScale"+$side+".input1X");
if (`objExists MainScaleMultiplyDivide`) // maight be `bodyLess` faceSetup
	connectAttr MainScaleMultiplyDivide.outputY ($name+"IKCurveInfoMainScale"+$side+".input2X");

//scale-compansate Base ctrl
createNode -n ($name+"IKCurveInfoBaseScale"+$side) multiplyDivide;
setAttr ($name+"IKCurveInfoBaseScale"+$side+".operation") 2;
connectAttr ($name+"IKCurveInfoMainScale"+$side+".outputX") ($name+"IKCurveInfoBaseScale"+$side+".input1X");
connectAttr ($name+"Base"+$side+".sx") ($name+"IKCurveInfoBaseScale"+$side+".input2X");

connectAttr ($name+"IKCurveInfoBaseScale"+$side+".outputX") ($name+"IKScale"+$side+".input1X");
createNode -n ($name+"IKStretch"+$side) multiplyDivide;
//connectAttr ($name+"IKScale"+$side+".outputX") ($name+"IKStretch"+$side+".input2X");
setAttr ($name+"IKStretch"+$side+".input1X") `getAttr ($name+"IKX2"+$side+".tx")`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr ($parent+".sx") ($name+"IKScale"+$side+".input2X");
setAttr ($name+"IKScale"+$side+".operation") 2;
for ($i=1;$i<11;$i++)
    connectAttr ($name+"IKStretch"+$side+".outputX") ($name+"IKX"+$i+$side+".tx");



//squash & stretch limits
createNode -n ($name+"LimitsClamp"+$side) clamp;
//connectAttr ($name+"IKCurveInfoNormalize"+$side+".outputX") ($name+"LimitsClamp"+$side+".inputR");
connectAttr ($name+"IKScale"+$side+".outputX") ($name+"LimitsClamp"+$side+".inputR");

createNode -n ($name+"SquashCondition"+$side) condition;
createNode -n ($name+"StretchCondition"+$side) condition;
connectAttr ($name+$side+".stretch") ($name+"StretchCondition"+$side+".firstTerm");
connectAttr ($name+$side+".squash") ($name+"SquashCondition"+$side+".firstTerm");
setAttr ($name+"StretchCondition"+$side+".colorIfTrueR") 1;//needs base scale comp
setAttr ($name+"SquashCondition"+$side+".colorIfTrueR") 1;//needs base scale comp
setAttr ($name+"StretchCondition"+$side+".colorIfFalseR") 999;
setAttr ($name+"SquashCondition"+$side+".colorIfFalseR") 0;
connectAttr ($name+"StretchCondition"+$side+".outColorR") ($name+"LimitsClamp"+$side+".maxR");
connectAttr ($name+"SquashCondition"+$side+".outColorR") ($name+"LimitsClamp"+$side+".minR");



createNode -n ($name+"squashVolume1Over"+$side) multiplyDivide;
//connectAttr ($name+"IKScale"+$side+".outputX") ($name+"squashVolume1Over"+$side+".input2X");
connectAttr ($name+"LimitsClamp"+$side+".outputR") ($name+"squashVolume1Over"+$side+".input2X");
connectAttr ($name+"LimitsClamp"+$side+".outputR") ($name+"IKStretch"+$side+".input2X");
setAttr ($name+"squashVolume1Over"+$side+".input1X") 1;
setAttr ($name+"squashVolume1Over"+$side+".operation") 2;

createNode -n ($name+"TopVolumeUC"+$side) unitConversion;
setAttr ($name+"TopVolumeUC"+$side+".conversionFactor") 0.1;
connectAttr ($name+$side+".volume") ($name+"TopVolumeUC"+$side+".input");

for ($i=1;$i<10;$i++)
  {
	createNode -n ($name+"squashVolumePow"+$i+$side) multiplyDivide;
	connectAttr ($name+"squashVolume1Over"+$side+".outputX") ($name+"squashVolumePow"+$i+$side+".input1X");
	setAttr ($name+"squashVolumePow"+$i+$side+".operation") 3;
	setAttr ($name+"squashVolumePow"+$i+$side+".input2X") 0.5;
	createNode -n ($name+"BlendTwo"+$i+$side) blendTwoAttr;
	setAttr ($name+"BlendTwo"+$i+$side+".input[0]") 1;
	connectAttr ($name+"squashVolumePow"+$i+$side+".outputX") ($name+"BlendTwo"+$i+$side+".input[1]");
	connectAttr ($name+"TopVolumeUC"+$side+".output") ($name+"BlendTwo"+$i+$side+".attributesBlender");

  connectAttr ($name+"BlendTwo"+$i+$side+".output") ($name+"IKX"+$i+$side+".sy");
  connectAttr ($name+"BlendTwo"+$i+$side+".output") ($name+"IKX"+$i+$side+".sz");
  }

setAttr ($name+"squashVolumePow1"+$side+".input2X") 0.600;
setAttr ($name+"squashVolumePow2"+$side+".input2X") 0.730;
setAttr ($name+"squashVolumePow3"+$side+".input2X") 0.820;
setAttr ($name+"squashVolumePow4"+$side+".input2X") 0.860;
setAttr ($name+"squashVolumePow5"+$side+".input2X") 0.87;
setAttr ($name+"squashVolumePow6"+$side+".input2X") 0.860;
setAttr ($name+"squashVolumePow7"+$side+".input2X") 0.820;
setAttr ($name+"squashVolumePow8"+$side+".input2X") 0.730;
setAttr ($name+"squashVolumePow9"+$side+".input2X") 0.600;

setAttr -l 1 ($name+"IKX0"+$side+".v") 0;

addAttr -k 0 -ln latticeVis -at bool -dv false ($name+$side);
setAttr -e -channelBox true ($name+$side+".latticeVis") ;
connectAttr ($name+$side+".latticeVis") ($name+"FfdLattice"+$side+".v");
addAttr -k 0 -ln curveVis -at bool -dv false ($name+$side);
setAttr -e -channelBox true ($name+$side+".curveVis") ;
setAttr -e -channelBox true ($name+$side+".curveVis") ;
connectAttr ($name+$side+".curveVis") ($name+"IKCurve"+$side+".v");
addAttr -k 1 -ln outsideLattice -at "enum" -en "Inside:All:Falloff" -dv 1 ($name+$side);
connectAttr ($name+$side+".outsideLattice") ($name+"Ffd"+$side+".outsideLattice");

}

global proc asDeleteMotionSystem ()
{
int $hasFaceSetup=`objExists FaceJoint_M`;
string $tempString[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z",""};
string $DeformationSystemNodes[]=`listRelatives -ad -type transform "DeformationSystem"`;

if (!`objExists MotionSystem`)
	error "MotionSystem not found";
if (`objExists AngleSystem`)
	parent AngleSystem Main;

if (`attributeExists jointVis Main`)
	setAttr Main.jointVis 1;

if ($hasFaceSetup)
	{
	$tempString=`listRelatives -p FaceJoint_M`;
	parent -w FaceJoint_M;
	$DeformationSystemNodes=`listRelatives -ad -type transform "DeformationSystem"`;
	parent FaceJoint_M $tempString[0];
	}

for ($x=0;$x<size($DeformationSystemNodes);$x++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$plug=$DeformationSystemNodes[$x]+"."+$trs[$y]+$xyz[$z];
			$tempString=`listConnections -s 1 -d 0 -p 1 $plug`;
			for ($i=0;$i<size($tempString);$i++)
				disconnectAttr $tempString[$i] $plug;
			}
if (`objExists MainScaleMultiplyDivide`)
	delete MainScaleMultiplyDivide;
delete MotionSystem;
if (`objExists MainAndHeadScaleMultiplyDivide`)
	setAttr MainAndHeadScaleMultiplyDivide.input1 -type float3 1 1 1;


print "// MotionSystem deleted.\n";
}

global proc asCreateHumanIK ()
{
string $checkForObjs[]={"Character1_Reference","Character1"};

for ($i=0;$i<size($checkForObjs);$i++)
	if (`objExists $checkForObjs[$i]`)
		delete $checkForObjs[$i];

HIKCharacterControlsTool;
//hikCreateSkeleton;
evalDeferred asConnectHumanIK;
hikCreateDefinition;
}


global proc asConnectHumanIK ()
{
int $ctrlButton;
if ((`getModifiers`/4) %  2) $ctrlButton=1;
float $pos[];
string $dest;
string $hiks[],$ads[];
string $sides[]={"Right","Left"};
string $ss[]={"_R","_L"};
string $xyz[]={"x","y","z"};
string $deformJoints[]=`listRelatives -ad -type joint DeformationSystem`;

$hiks[size($hiks)]="Hips"; $ads[size($ads)]="Root_M";
if (`objExists "RootPart1_M"`)
	{
	$hiks[size($hiks)]="Spine"; $ads[size($ads)]="RootPart1_M";
	$hiks[size($hiks)]="Spine1"; $ads[size($ads)]="RootPart2_M";
	$hiks[size($hiks)]="Spine2"; $ads[size($ads)]="Spine1_M";
	$hiks[size($hiks)]="Spine3"; $ads[size($ads)]="Spine1Part1_M";
	$hiks[size($hiks)]="Spine4"; $ads[size($ads)]="Spine1Part2_M";
	$hiks[size($hiks)]="Spine5"; $ads[size($ads)]="Chest_M";
	}
else//bipedGame
	{
	$hiks[size($hiks)]="Spine"; $ads[size($ads)]="Spine1_M";
	for ($i=2;$i<99;$i++)
		if (`objExists ("Spine"+$i+"_M")`)
			{$hiks[size($hiks)]="Spine"+($i-1); $ads[size($ads)]="Spine"+$i+"_M";}
		else
			break;
	$hiks[size($hiks)]="Spine"+($i-1); $ads[size($ads)]="Chest_M";
//	$hiks[size($hiks)]="Spine"; $ads[size($ads)]="Spine1_M";
//	$hiks[size($hiks)]="Spine1"; $ads[size($ads)]="Spine2_M";
//	$hiks[size($hiks)]="Spine2"; $ads[size($ads)]="Chest_M";
	}
//$hiks[size($hiks)]="Neck"; $ads[size($ads)]="Neck_M";
//$hiks[size($hiks)]="Head"; $ads[size($ads)]="Head_M";
//special case, for Head+Neck, it will be the controller that is constrained, not the DeformJoint.
//as the will make the Eye+Jaw follow, And give correct NeckJoints
$hiks[size($hiks)]="Neck"; $ads[size($ads)]="FKNeck_M";
$hiks[size($hiks)]="Head"; $ads[size($ads)]="FKHead_M";

for ($i=0;$i<size($sides);$i++)
	{
	$hiks[size($hiks)]=$sides[$i]+"UpLeg"; $ads[size($ads)]="Hip"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"Leg"; $ads[size($ads)]="Knee"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"Foot"; $ads[size($ads)]="Ankle"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"ToeBase"; $ads[size($ads)]="Toes"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"Shoulder"; $ads[size($ads)]="Scapula"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"Arm"; $ads[size($ads)]="Shoulder"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"ForeArm"; $ads[size($ads)]="Elbow"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"Hand"; $ads[size($ads)]="Wrist"+$ss[$i];

	$hiks[size($hiks)]=$sides[$i]+"HandThumb1"; $ads[size($ads)]="ThumbFinger1"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandThumb2"; $ads[size($ads)]="ThumbFinger2"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandThumb3"; $ads[size($ads)]="ThumbFinger3"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandThumb4"; $ads[size($ads)]="ThumbFinger4"+$ss[$i];

	$hiks[size($hiks)]=$sides[$i]+"HandIndex1"; $ads[size($ads)]="IndexFinger1"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandIndex2"; $ads[size($ads)]="IndexFinger2"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandIndex3"; $ads[size($ads)]="IndexFinger3"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandIndex4"; $ads[size($ads)]="IndexFinger4"+$ss[$i];	

	$hiks[size($hiks)]=$sides[$i]+"HandMiddle1"; $ads[size($ads)]="MiddleFinger1"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandMiddle2"; $ads[size($ads)]="MiddleFinger2"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandMiddle3"; $ads[size($ads)]="MiddleFinger3"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandMiddle4"; $ads[size($ads)]="MiddleFinger4"+$ss[$i];

	$hiks[size($hiks)]=$sides[$i]+"HandRing1"; $ads[size($ads)]="RingFinger1"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandRing2"; $ads[size($ads)]="RingFinger2"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandRing3"; $ads[size($ads)]="RingFinger3"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandRing4"; $ads[size($ads)]="RingFinger4"+$ss[$i];

	$hiks[size($hiks)]=$sides[$i]+"HandPinky1"; $ads[size($ads)]="PinkyFinger1"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandPinky2"; $ads[size($ads)]="PinkyFinger2"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandPinky3"; $ads[size($ads)]="PinkyFinger3"+$ss[$i];
	$hiks[size($hiks)]=$sides[$i]+"HandPinky4"; $ads[size($ads)]="PinkyFinger4"+$ss[$i];

	for ($y=1;$y<6;$y++)
		{
		$hiks[size($hiks)]="Leaf"+$sides[$i]+"ArmRoll"+$y; $ads[size($ads)]="ShoulderPart"+$y+$ss[$i];
		$hiks[size($hiks)]="Leaf"+$sides[$i]+"ForeArmRoll"+$y; $ads[size($ads)]="ElbowPart"+$y+$ss[$i];
		$hiks[size($hiks)]="Leaf"+$sides[$i]+"UpLegRoll"+$y; $ads[size($ads)]="HipPart"+$y+$ss[$i];
		$hiks[size($hiks)]="Leaf"+$sides[$i]+"LegRoll"+$y; $ads[size($ads)]="KneePart"+$y+$ss[$i];
		}
	}

for ($i=0;$i<size($hiks);$i++)
	{
	$dest=$ads[$i];

	if (!`objExists $dest`)
		continue;
	if (!`attributeExists Character $dest`)
		addAttr -shortName ch -longName "Character" -attributeType message $dest;
//print ("connectAttr -f "+$dest+".Character Character1."+$hiks[$i]+";\n");
	connectAttr -f ($dest+".Character") ("Character1."+$hiks[$i]);
	}

if ($ctrlButton)
	{
	print "// Ctrl button detected, skipping hikCreateControlRig;\n";
	return;
	}

hikCreateControlRig;
if (`objExists asCreatingHumanIKAdvancedSkeleton`)
	delete asCreatingHumanIKAdvancedSkeleton;

//special case, for Head+Neck, so unhide these
catchQuiet (`setAttr FKHead_M.v 1`);
catchQuiet (`setAttr FKNeck_M.v 1`);

if (`objExists MotionSystem`)
	{
	print "AdvancedSkeleton MotionSystem exists, hiding this now.\n";
	setAttr MotionSystem.v 0;
	}
if (`objExists DeformationSystem`)
	{
	setAttr DeformationSystem.v 0;
	//hikCreateControlRig sets Joints.drawStyle to None, so we will set it back to default
	for ($i=0;$i<size($deformJoints);$i++)
		if (`getAttr ($deformJoints[$i]+".drawStyle")`==2)
			setAttr ($deformJoints[$i]+".drawStyle") 0;
	}
}

global proc asDeleteHumanIK ()
{
string $tempString[];

if (`objExists Character1_Reference`) delete Character1_Reference;
if (`objExists Character1_Ctrl_Reference`) delete Character1_Ctrl_Reference;
string $all[]=`ls`;
for ($i=0;$i<size($all);$i++)
	{
	$tempString=`ls -showType $all[$i]`;
	if (`gmatch $tempString[1] "HIK*"`)
		{
		delete $tempString[0];
		}
	}

if (`objExists MotionSystem`)
	{
	print "AdvancedSkeleton MotionSystem still exists, displaying this now.\n";
	setAttr MotionSystem.v 1;
	asGoToBuildPose bodySetup;
	}
if (`objExists DeformationSystem`)
	setAttr DeformationSystem.v 1;

print "// asHIKCharacterNode deleted.\n";
}

global proc asBakeHumanIK ()
{
int $autoKeyframe=`autoKeyframe -q -state`;
float $currentTime=`currentTime -q`;
string $side;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $fingers[]={"Thumb","Pinky","Ring","Middle","Cup","Index"};
string $tempString[],$tempString2[],$tempString3[],$ctrls[],$midCtrls[],$sideCtrls[];

duplicate -n prefix_Root_M Root_M;
$tempString=`listRelatives -ad -f prefix_Root_M`;
$tempString2=`listRelatives -ad prefix_Root_M`;
for ($i=0;$i<size($tempString);$i++)
	{
	rename $tempString[$i] ("prefix_"+$tempString2[$i]);
	parentConstraint $tempString2[$i] ("prefix_"+$tempString2[$i]);
	}
parent -w prefix_Root_M;
parentConstraint Root_M prefix_Root_M;

select prefix_Root_M;
select -add `listRelatives -ad -type joint`;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false;

asDeleteHumanIK;
currentTime -1;
autoKeyframe -state 1;
select Root_M;
select -add `listRelatives -ad -type joint`;
$tempString=`ls -sl`;
for ($i=0;$i<size($tempString);$i++)
	{
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			setAttr ("prefix_"+$tempString[$i]+"."+$trs[$y]+$xyz[$z]) `getAttr ($tempString[$i]+"."+$trs[$y]+$xyz[$z])`;
	}
parentConstraint -mo prefix_Root_M RootX_M;
catchQuiet (`parentConstraint prefix_Spine1_M FKSpine1_M`);
catchQuiet (`parentConstraint prefix_Spine2_M FKSpine2_M`);
catchQuiet (`parentConstraint prefix_Chest_M FKChest_M`);
catchQuiet (`parentConstraint prefix_Neck_M FKNeck_M`);
catchQuiet (`parentConstraint prefix_Head_M FKHead_M`);
catchQuiet (`parentConstraint -mo prefix_Spine1_M IKSpine1_M`);
catchQuiet (`parentConstraint -mo prefix_Chest_M IKSpine3_M`);
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	catchQuiet (`parentConstraint ("prefix_Scapula"+$side) ("FKScapula"+$side)`);
	catchQuiet (`parentConstraint ("prefix_Shoulder"+$side) ("FKShoulder"+$side)`);
	catchQuiet (`parentConstraint ("prefix_Elbow"+$side) ("FKElbow"+$side)`);
	catchQuiet (`parentConstraint ("prefix_Wrist"+$side) ("FKWrist"+$side)`);
	catchQuiet (`parentConstraint ("prefix_Hip"+$side) ("FKHip"+$side)`);
	catchQuiet (`parentConstraint ("prefix_Knee"+$side) ("FKKnee"+$side)`);
	catchQuiet (`parentConstraint ("prefix_Ankle"+$side) ("FKAnkle"+$side)`);
	catchQuiet (`parentConstraint ("prefix_Toes"+$side) ("FKToes"+$side)`);
	catchQuiet (`parentConstraint -mo ("prefix_Wrist"+$side) ("IKArm"+$side)`);
	catchQuiet (`pointConstraint ("prefix_Elbow"+$side) ("PoleArm"+$side)`);
	catchQuiet (`parentConstraint -mo ("prefix_Ankle"+$side) ("IKLeg"+$side)`);
	catchQuiet (`pointConstraint ("prefix_Knee"+$side) ("PoleLeg"+$side)`);

	for ($y=0;$y<size($fingers);$y++)
		for ($i=1;$i<4;$i++)
			catchQuiet (`parentConstraint ("prefix_"+$fingers[$y]+"Finger"+$i+$side) ("FK"+$fingers[$y]+"Finger"+$i+$side)`);
	}

$midCtrls={"RootX","FKSpine1","FKSpine2","FKChest","FKNeck","FKHead","IKSpine1","IKSpine3"};
$sideCtrls={"FKScapula","FKShoulder","FKElbow","FKWrist","FKHip","FKKnee","FKAnkle","FKToes","IKArm","PoleArm","IKLeg","PoleLeg"};
for ($y=0;$y<size($fingers);$y++)
	for ($i=1;$i<4;$i++)
		$sideCtrls[size($sideCtrls)]="FK"+$fingers[$y]+"Finger"+$i;

for ($i=0;$i<size($midCtrls);$i++)
	if (`objExists ($midCtrls[$i]+"_M")`)
		$ctrls[size($ctrls)]=$midCtrls[$i]+"_M";

for ($i=0;$i<size($sideCtrls);$i++)
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

		if (`objExists ($sideCtrls[$i]+$side)`)
			$ctrls[size($ctrls)]=($sideCtrls[$i]+$side);
		}

select $ctrls;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false;

currentTime $currentTime;
delete prefix_Root_M;
autoKeyframe -state $autoKeyframe;
select -cl;
print "// HumanIK baked to AdvancedSkeleton MotionSystem.\n";
}

global proc asCreateUnrealJoints ()
{
int $opm=`asGetOpm`;
string $root="UnrealRoot";
if (`objExists root`)
	{
	print "// Root Motion Joint Detected, using this as Unreal Root Joint.\n";
	$root="root";
	}

asDeleteUnrealJoints;
//asUnrealRootBehaviour 1;

if ($root=="UnrealRoot")
	{
	select DeformationSystem;
	joint -n UnrealRoot;
	parent Root_M UnrealRoot;
	if (!$opm)
		{
		parentConstraint Main UnrealRoot;
		parent UnrealRoot_parentConstraint1 ConstraintSystem;
		connectAttr MainScaleMultiplyDivide.output UnrealRoot.s;
		}
	}
select $root;
joint -n ik_foot_root;
joint -n ik_foot_l;
select ik_foot_root;
joint -n ik_foot_r;
select $root;
joint -n ik_hand_root;
joint -n ik_hand_gun;
joint -n ik_hand_l;
select ik_hand_gun;
joint -n ik_hand_r;
if (`objExists Wrist_R`) asAlign ik_hand_gun Wrist_R 1 0 0 0;
if (`objExists Wrist_L`) asAlign ik_hand_l Wrist_L 1 0 0 0;
if (`objExists Ankle_R`) asAlign ik_foot_r Ankle_R 1 0 0 0;
if (`objExists Ankle_L`) asAlign ik_foot_l Ankle_L 1 0 0 0;

select -cl;
print ("// Unreal Joints created\n");
}

global proc asDeleteUnrealJoints ()
{
int $numDeleted;
string $tempString[];
string $deleteObjs[]={"UnrealRoot","UnrealRoot_parentConstraint1","ik_foot_root","ik_hand_root"};

if (`objExists UnrealRoot`)
	{
	$tempString=`listRelatives -c UnrealRoot`;
	if (size($tempString))
		parent $tempString DeformationSystem;
	}
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		{
		delete $obj;
		$numDeleted++;
		}

select -cl;
if ($numDeleted)
	print ("// Unreal Joints deleted\n");
}

global proc asCreateUnrealMannequinReadThis ()
{
if (`window -q -ex asCreateUnrealMannequinReadThisWindow`)
	deleteUI asCreateUnrealMannequinReadThisWindow;
window -t "Warning" asCreateUnrealMannequinReadThisWindow;
columnLayout;
separator -h 15 -st none;
text -l ("Warning:\n"
+"Creating UnrealMannequinJoints & Transfer Skinning\n"
+"Results in a Rig that is no longer AdvancedSkeleton compatible\n"
+"This means the rig can no longer be \"ReBuilt\",\n"
+"and many AdvancedSkeleton function will no longer work\n"
+"\n"
+"Main scale values will also be set to match height of Mannequin.\n"
+"and the Model will be duplicated and parented under Geometry at Root-levels.\n"
+"\n"
+"If you wish to export to Unreal, and use Mannequin Blueprints\n"
+"then you should instead use the \"Mannequin export\" function\n"
+"\n"
+"( \"Mannequin export\" is found in the \"Export\" section )\n"
+"\n");
showWindow;
}

global proc asCreateUnrealMannequinJoints ()
{
if (`objExists "|root"`)
	error "|root already exists, MannequinJoints can not be created.";
createNode -n asManualCreatingUnrealMannequinJoints transform; 
asExportMannequin;
}

global proc asDeleteUnrealMannequinJoints ()
{
if (`objExists "|root"`) delete "|root";
if (`objExists "|Geometry"`) delete "|Geometry";
if (`objExists Geometry_original`)
	{
	rename Geometry_original Geometry;
	setAttr Geometry.v 1;
	}
catchQuiet (`setAttr Main.scale -type float3 1 1 1`);
}

global proc asUnrealMannequinTransferSkin ()
{
asMannequinTransferSkin;
//hide original geo
rename Group|Geometry Geometry_original;
setAttr Geometry_original.v 0;
}

global proc asExportMannequin ()
{
global string $unrealMannequinJoints;
global int $unrealMannequinScale;
global string $asFbxExportedFile;
int $ctrlButton;
if ((`getModifiers`/4) %  2) $ctrlButton=1;
int $constrainedToUnrealSkeleton,$numSpineJoints;
int $manualCreatingUnrealMannequinJoints=`objExists asManualCreatingUnrealMannequinJoints`;
int $moCapLibraryCreatingUnrealMannequinJoints=`objExists asMoCapMatcherCreatingUnrealMannequinJoints`;
float $mainScale,$scale,$distA,$distB,$minDist;
float $pos[],$pos2[],$pos3[],$spineFactors[];
string $parent,$nearestJoint,$SIDE,$side,$unrealSkeletonName,$mesh,$obj,$dupObj,$topNode;
string $destJoints[]={"root","spine_01","spine_02","spine_03","neck_01","head"};
string $requiredObj[]={"Root_M","Hip_R","Knee_R","Ankle_R"};
string $sideDestJoints[],$tempString[],$tempString2[],$tempString3[],$tempString4[],$notConstrainedJoints[],$afterAS[],$importedAs[],$mannequinJoints[];
string $beforeAs[],$asSpineJoints[],$manuallyAddedJointsList[],$deformJointsList[];
string $deleteObjs[]={"|root","|Geometry","Mannequin","Manny","Quinn","asMannequinExporting"};

if (`objExists asManualCreatingUnrealMannequinJoints`)
	delete asManualCreatingUnrealMannequinJoints;
if (`objExists asMoCapMatcherCreatingUnrealMannequinJoints`)
	delete asMoCapMatcherCreatingUnrealMannequinJoints;

if (!`objExists DeformSet`)
	error "\"DeformSet\" not found, unable to continue";

if (!`asConfirmIfNotInBuildPose`)
	return;

if ($moCapLibraryCreatingUnrealMannequinJoints)
	$unrealMannequinScale=0;
else
	if (`layoutDialog -t "Mannequin" -ui asUMJLayout`!="OK")
		return;

$deformJointsList=`sets -q "DeformSet"`;

//special case aloowing to include `manually added joint`
if (`objExists manuallyAddedJoints`)
	{
	$manuallyAddedJointsList=`sets -q manuallyAddedJoints`;
	$deformJointsList=`stringArrayCatenate $deformJointsList $manuallyAddedJointsList`;
	}

for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
$beforeAs=`ls -as`;

if (`objExists DeformationSystem|root`)
	error "Joint \"root\" found, root-motion-joint is already included in Mannequin-skeleton. Remove \"root\" before proceeding.";

if ($unrealMannequinJoints=="Mannequin (UE4)") $unrealSkeletonName="SK_Mannequin_Skeleton";
if ($unrealMannequinJoints=="Manny (UE5)") $unrealSkeletonName="SK_Mannequin";
if ($unrealMannequinJoints=="Quinn (UE5)") $unrealSkeletonName="SK_Mannequin";

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$SIDE="_R";$side="_r";}
	if ($b==-1) {$SIDE="_L";$side="_l";}
	$sideDestJoints={("clavicle"+$side),("upperarm"+$side),("upperarm_twist_01"+$side),("lowerarm"+$side),("lowerarm_twist_01"+$side),("hand"+$side),
		("index_01"+$side),("index_02"+$side),("index_03"+$side),
		("middle_01"+$side),("middle_02"+$side),("middle_03"+$side),
		("ring_01"+$side),("ring_02"+$side),("ring_03"+$side),
		("pinky_01"+$side),("pinky_02"+$side),("pinky_03"+$side),
		("thumb_01"+$side),("thumb_02"+$side),("thumb_03"+$side),
		("thigh"+$side),("thigh_twist_01"+$side),("calf"+$side),("calf_twist_01"+$side),("foot"+$side),("ball"+$side)};
	}
$destJoints=`stringArrayCatenate $destJoints $sideDestJoints`;
for ($i=0;$i<size($destJoints);$i++)
	if (`objExists $destJoints[$i]`)
		{
		select $destJoints[$i];
		error ("A object with the name \""+$destJoints[$i]+"\" already exists, rename this to another name first.");
		}

for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists, Rig must be a human-like character with standard legs");

string $unrealFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asUnreal.ma";
if (!`file -q -ex $unrealFile`)
	error ("Not found:"+$unrealFile);
file -i $unrealFile;

$afterAS=`ls -as`;
select $afterAS;
select -d $beforeAs;
$importedAs=`ls -sl`;
tokenize $unrealMannequinJoints $tempString;
$topNode=$tempString[0];
if (!`objExists $topNode`)
	error ("Unreal character rig:\""+$topNode+"\" not found in file:\""+$unrealFile+"\"");
$mannequinJoints=`listRelatives -ad -type joint $topNode`;
parent -w `listRelatives -f -c $topNode`;
delete $importedAs;

//Overall scale $unrealMannequinScale
if (`objExists HeadEnd_M`)
	$pos=`xform -q -ws -t HeadEnd_M`;
else
	$pos=`xform -q -ws -t Head_M`;
$distA=$pos[1];
$pos2=`xform -q -ws -t head`;
$distB=$pos2[1]*1.085;//est headEnd
$mainScale=$distB/$distA;
if ($unrealMannequinScale)
	setAttr Main.s -type float3 $mainScale $mainScale $mainScale;
else//else scale down Mannequin, so that un-constrained end-joint are propotional distance
	{
	setAttr ($mannequinJoints[size($mannequinJoints)-1]+".s") -type float3 (1.0/$mainScale) (1.0/$mainScale) (1.0/$mainScale);
	makeIdentity -a 1 -t 0 -r 0 -s 1 $mannequinJoints[size($mannequinJoints)-1];
	}

//default to No segmentScaleCompensate (makeIdentity has forced-on all), asUnrealJointConstrain to match per joint
for ($i=0;$i<size($mannequinJoints);$i++)
	setAttr ($mannequinJoints[$i]+".segmentScaleCompensate") 0;

//asUnrealJointConstrain Main root {0,1} {0.0, 0.0, 0.0};
//asUnrealJointConstrain Root_M pelvis {0,1} {0.0, 0.0, 0.0};
asUnrealJointConstrain Root_M pelvis {0,0} {180.0, 0.0, 0.0};

if ($unrealMannequinScale)
	{
	createNode -n unrealMannequinSkeletonScaleToMatch multiplyDivide;
	setAttr unrealMannequinSkeletonScaleToMatch.operation 2;
	connectAttr DeformationSystem.scale unrealMannequinSkeletonScaleToMatch.input1;
	setAttr unrealMannequinSkeletonScaleToMatch.input2 -type float3 $mainScale $mainScale $mainScale;
	connectAttr unrealMannequinSkeletonScaleToMatch.output root.scale;
	}
else
	connectAttr DeformationSystem.scale root.scale;

//Spine, evenly distribute first
for ($i=1;$i<99;$i++)
	if (!`objExists ("spine_0"+$i)`)
		break;
$numSpineJoints=$i-1;
$pos=`xform -q -ws -t pelvis`;
$pos2=`xform -q -ws -t ("spine_0"+$numSpineJoints)`;
$distA=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
for ($i=1;$i<$numSpineJoints;$i++)
	{
	$pos3=`xform -q -ws -t ("spine_0"+$i)`;
	$distB=`mag<<$pos[0]-$pos3[0],$pos[1]-$pos3[1],$pos[2]-$pos3[2]>>`;
	$spineFactors[$i]=$distB/$distA;
	}
for ($i=1;$i<$numSpineJoints;$i++)
	{
	pointConstraint -w $spineFactors[$i] Chest_M ("spine_0"+$i);
	pointConstraint -w (1-$spineFactors[$i]) Root_M ("spine_0"+$i);
	delete ("spine_0"+$i+"_pointConstraint1");
	}
//Spine, then snap to nearest
$parent="Chest_M";
while ($parent!="Root_M")
	{
	$asSpineJoints[size($asSpineJoints)]=$parent;
	$tempString=`listRelatives -p $parent`;
	$parent=$tempString[0];
	}
for ($i=1;$i<$numSpineJoints;$i++)
	{
	$pos=`xform -q -ws -t ("spine_0"+$i)`;
	$minDist=999;
	for ($y=0;$y<size($asSpineJoints);$y++)
		{
		$pos2=`xform -q -ws -t $asSpineJoints[$y]`;
		$distA=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		if ($distA<$minDist)
			{
			$nearestJoint=$asSpineJoints[$y];
			$minDist=$distA;
			}
		}
	asUnrealJointConstrain $nearestJoint ("spine_0"+$i) {0,0} {180.0, 0.0, 0.0};
	}

asUnrealJointConstrain Chest_M ("spine_0"+$numSpineJoints) {0,0} {180.0, 0.0, 0.0};

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$SIDE="_R";$side="_r";}
	if ($b==-1) {$SIDE="_L";$side="_l";}

	asUnrealJointConstrain ("Scapula"+$SIDE) ("clavicle"+$side) {0,0} {180.0, 0.0, 180.0};
	asUnrealJointConstrain ("Shoulder"+$SIDE) ("upperarm"+$side) {0,0} {180.0, 0.0, 180.0};
	asUnrealJointConstrain ("ShoulderPart1"+$SIDE) ("upperarm_twist_01"+$side) {0,0} {0.0, -180.0, 0.0};
	asUnrealJointConstrain ("ShoulderPart2"+$SIDE) ("upperarm_twist_02"+$side) {0,0} {0.0, -180.0, 0.0};
	asUnrealJointConstrain ("Elbow"+$SIDE) ("lowerarm"+$side) {0,0} {180.0, 0.0, 180.0};
	asUnrealJointConstrain ("ElbowPart2"+$SIDE) ("lowerarm_twist_01"+$side) {0,0} {0.0, -180.0, 0.0};//note unreal swapped order
	asUnrealJointConstrain ("ElbowPart1"+$SIDE) ("lowerarm_twist_02"+$side) {0,0} {0.0, -180.0, 0.0};
	asUnrealJointConstrain ("Wrist"+$SIDE) ("hand"+$side) {0,0} {90.0, 0.0, 180.0};

	//MetaCarpal (in case UE5 FitTemplate was used)
	asUnrealJointConstrain ("PinkyFinger0"+$SIDE)  ("pinky_metacarpal"+$side) {0,0} {90.0, 0.0, 180.0};
	asUnrealJointConstrain ("RingFinger0"+$SIDE)  ("ring_metacarpal"+$side) {0,0} {90.0, 0.0, 180.0};
	asUnrealJointConstrain ("MiddleFinger0"+$SIDE)  ("middle_metacarpal"+$side) {0,0} {90.0, 0.0, 180.0};
	asUnrealJointConstrain ("IndexFinger0"+$SIDE)  ("index_metacarpal"+$side) {0,0} {90.0, 0.0, 180.0};

	for ($i=1;$i<4;$i++)
		{
		asUnrealJointConstrain ("PinkyFinger"+$i+$SIDE)  ("pinky_0"+$i+$side) {0,0} {90.0, 0.0, 180.0};
		asUnrealJointConstrain ("RingFinger"+$i+$SIDE)  ("ring_0"+$i+$side) {0,0} {90.0, 0.0, 180.0};
		asUnrealJointConstrain ("MiddleFinger"+$i+$SIDE)  ("middle_0"+$i+$side) {0,0} {90.0, 0.0, 180.0};
		asUnrealJointConstrain ("IndexFinger"+$i+$SIDE)  ("index_0"+$i+$side) {0,0} {90.0, 0.0, 180.0};
		asUnrealJointConstrain ("ThumbFinger"+$i+$SIDE)  ("thumb_0"+$i+$side) {0,0} {90.0, 0.0, 180.0};
		}
	asUnrealJointConstrain ("Hip"+$SIDE) ("thigh"+$side) {0,0} {0.0, 0.0, 0.0};
	asUnrealJointConstrain ("HipPart1"+$SIDE) ("thigh_twist_01"+$side) {0,0} {0.0, 0.0, 0.0};
	asUnrealJointConstrain ("HipPart2"+$SIDE) ("thigh_twist_02"+$side) {0,0} {0.0, 0.0, 0.0};
	asUnrealJointConstrain ("Knee"+$SIDE) ("calf"+$side) {0,0} {0.0, 0.0, 0.0};
	asUnrealJointConstrain ("KneePart2"+$SIDE) ("calf_twist_01"+$side) {0,0} {0.0, 0.0, 0.0};//note unreal swapped order
	asUnrealJointConstrain ("KneePart1"+$SIDE) ("calf_twist_02"+$side) {0,0} {0.0, 0.0, 0.0};
	asUnrealJointConstrain ("Ankle"+$SIDE) ("foot"+$side) {0,0} {0.0, 0.0, 0.0};
	asUnrealJointConstrain ("Toes"+$SIDE) ("ball"+$side) {0,1} {0.0, 0.0, 0.0};
	}
asUnrealJointConstrain Neck_M neck_01 {0,0} {180.0, 0.0, 0.0};
asUnrealJointConstrain NeckPart1_M neck_02 {0,0} {180.0, 0.0, 0.0};
asUnrealJointConstrain Head_M head {0,0} {180.0, 0.0, 0.0};

//asUnrealJointConstrain Main ik_foot_root {0,1} {0.0, 0.0, 0.0};
//asUnrealJointConstrain Main ik_hand_root {0,1} {0.0, 0.0, 0.0};
asUnrealJointConstrain hand_r ik_hand_gun {0,1} {0.0, 0.0, 0.0};
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$SIDE="_R";$side="_r";}
	if ($b==-1) {$SIDE="_L";$side="_l";}

	asUnrealJointConstrain ("foot"+$side) ("ik_foot"+$side) {0,1} {0.0, 0.0, 0.0};
	asUnrealJointConstrain ("hand"+$side) ("ik_hand"+$side) {0,1} {0.0, 0.0, 0.0};
	}

//custom joints
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"` || `gmatch $deformJointsList[$i] "*Cup_*"`)
		continue;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	if (!size($tempString) && !`gmatch $deformJointsList[$i] "*Slider*"`)
		{
		//skip only if HaveNoConnections, it could be a Used EndJoint
		$tempString=`listConnections -s 1 - d 0 $deformJointsList[$i]`;
		if (!size($tempString) || $tempString[0]==$deformJointsList[$i])//possibly just inverseScale to parent connection
			continue;
		}
	$constrainedToUnrealSkeleton=0;
	$tempString=`listConnections -s 0 -d 1 -type constraint $deformJointsList[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`ls -l $tempString[$y]`;
		if (`gmatch $tempString2[0] "|root|*"`)
			{
			$constrainedToUnrealSkeleton=1;
			break;
			}
		}
	if (!$constrainedToUnrealSkeleton)
		$notConstrainedJoints[size($notConstrainedJoints)]=$deformJointsList[$i];
	}

for ($i=0;$i<size($notConstrainedJoints);$i++)
	{
	duplicate -n ("unreal"+$notConstrainedJoints[$i]) $notConstrainedJoints[$i];
	sets -rm DeformSet ("unreal"+$notConstrainedJoints[$i]);
	sets -rm AllSet ("unreal"+$notConstrainedJoints[$i]);
	parent -w ("unreal"+$notConstrainedJoints[$i]);
	$tempString=`listRelatives -c -f ("unreal"+$notConstrainedJoints[$i])`;
	if (size($tempString))
		delete $tempString;
	$tempString=`listRelatives -p ("unreal"+$notConstrainedJoints[$i])`;
	$tempString2=`listRelatives -p ("unreal"+$notConstrainedJoints[$i])`;
	if (`gmatch $tempString2[0] "transform*"`)
		{
		makeIdentity -a 1 -t 1 -r 1 -s 1 $tempString2[0];
		parent -w ("unreal"+$notConstrainedJoints[$i]);
		delete $tempString2[0];
		}

	}

for ($i=0;$i<size($notConstrainedJoints);$i++)
	{
	$tempString=`listRelatives -p $notConstrainedJoints[$i]`;
	if (`objExists ("unreal"+$tempString[0])`)
		parent ("unreal"+$notConstrainedJoints[$i]) ("unreal"+$tempString[0]);
	else
		{
		$tempString=`listConnections -s 0 -d 1 -type constraint $tempString[0]`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$tempString2=`ls -l $tempString[$y]`;
			if (`gmatch $tempString2[0] "|root|*"`)
				{
				$tempString3=`listConnections -s 0 -d 1 -type joint $tempString[$y]`;
				parent ("unreal"+$notConstrainedJoints[$i]) $tempString3[0];
				break;
				}
			}
		}
//	parentConstraint -mo $notConstrainedJoints[$i] ("unreal"+$notConstrainedJoints[$i]);
	asUnrealJointConstrain $notConstrainedJoints[$i] ("unreal"+$notConstrainedJoints[$i]) {0,0} {0.0, 0.0, 0.0};
	}

//FaceJoints
if (`objExists FaceJoint_M`)
	{
	duplicate -n unrealFaceJoint_M FaceJoint_M;
	$tempString=`listRelatives -ad -f unrealFaceJoint_M`;
	$tempString2=`listRelatives -ad unrealFaceJoint_M`;
	for ($i=0;$i<size($tempString);$i++)
		rename $tempString[$i] ("unreal"+$tempString2[$i]);
	parent unrealFaceJoint_M head;
	$tempString=`listRelatives -p unrealFaceJoint_M`;
	if (`gmatch $tempString[0] "transform*"`)
		{
		makeIdentity -a 1 -t 1 -r 1 -s 1 $tempString[0];
		parent unrealFaceJoint_M head;
		delete $tempString[0];
		}
	$tempString=`listRelatives -ad FaceJoint_M`;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists ("unreal"+$tempString[$i])`)
			{
			parentConstraint $tempString[$i] ("unreal"+$tempString[$i]);
			scaleConstraint $tempString[$i] ("unreal"+$tempString[$i]);
			}
	}

if ($manualCreatingUnrealMannequinJoints)
	{
	print ("// Unreal Mannequin Skeleton Created.\n");
	return;
	}

asMannequinTransferSkin;

if (!$ctrlButton)
	createNode -n asMannequinExporting transform;
select root |Geometry;
asExportFbxBrowser "";
if ($unrealMannequinScale)
	setAttr Main.s -type float3 1 1 1;
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
print ("// Unreal Mannequin exported. When importing to Unreal, set Skeleton to:\""+$unrealSkeletonName+"\""+"\n");

//include Modular ControlRig script
if (`file -q -ex $asFbxExportedFile`)
	sysFile -cp `substitute "[.]fbx" $asFbxExportedFile "_ModularControlRig.py"` (`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/as2mr/5.4.py");
}

global proc asMannequinTransferSkin ()
{
//creates duplicate geometry for skinning.
int $xformNr;
string $tempString[],$tempString2[],$historyNodes[];
string $mesh,$obj,$dupObj,$sc;

//transformGeometry skinClusters
createNode -n unrealMannequinSkinTransferSetup transform;
createNode -n uemTransformGeometryXform -p unrealMannequinSkinTransferSetup transform;
createNode -n Geometry transform;
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	{
	$sc=$tempString[$i];
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $sc`)
			continue;
	$tempString2=`listHistory -pdo 0 -il 2 -f 1 $sc`;
	$mesh="";
	for ($y=0;$y<size($tempString2);$y++)
		if (`objectType $tempString2[$y]`=="mesh")
			$mesh=$tempString2[$y];
	if ($mesh=="")
		continue;
	if (`getAttr ($mesh+".intermediateObject")`)
		{
		print ("// Skipping geometry:\""+$mesh+"\", since it is intermediateObject.\n");
		continue;
		}
	$tempString2=`listRelatives -p $mesh`;
	$obj=$tempString2[0];
	$tempString2=`duplicate $obj`;
	$dupObj=$tempString2[0];
	//duplicated object could name-clash, ensure unique name
	$tempString2=`ls $dupObj`;
	if (size($tempString2)>1)
		{
		$tempString3=`listRelatives -p $obj`;
		rename ($tempString3[0]+"|"+$dupObj) ("unreal"+$dupObj);
		$dupObj="unreal"+$dupObj;
		}
	//remove intermediateObject shapes
	$tempString2=`listRelatives -f -s $dupObj`;
	for ($y=0;$y<size($tempString2);$y++)
		if (`getAttr ($tempString2[$y]+".intermediateObject")`)
			delete $tempString2[$y];
	parent $dupObj |Geometry;

	//SkinCluster
//	$tempString2=`listConnections ($sc+".matrix")`;
//	select $dupObj $tempString2;
	select $dupObj root pelvis `listRelatives -ad -type joint pelvis`;
	$tempString2=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString2[0] ("uemTransformSC"+$xformNr);
	select $obj $dupObj;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

	//TransformGeometry
	if (`objExists ("uemTransformGeometry"+$xformNr)`)
		delete ("uemTransformGeometry"+$xformNr);
	createNode -n ("uemTransformGeometry"+$xformNr) transformGeometry;
	connectAttr uemTransformGeometryXform.matrix ("uemTransformGeometry"+$xformNr+".transform");
//	connectAttr ($mesh+".outMesh") ("uemTransformGeometry"+$xformNr+".inputGeometry");
	$tempString2=`listConnections -s 0 -d 1 -sh 1 ("uemTransformSC"+$xformNr+".outputGeometry")`;
	connectAttr ("uemTransformSC"+$xformNr+".outputGeometry[0]") ("uemTransformGeometry"+$xformNr+".inputGeometry");
	connectAttr -f ("uemTransformGeometry"+$xformNr+".outputGeometry") ($tempString2[0]+".inMesh");
	select $dupObj;
	doBakeNonDefHistory( 1, {"prePost" });

	//connected to BlendShape
	$historyNodes=`listHistory -pdo 1 -interestLevel 1 $sc`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="blendShape")
			{
			if (`getAttr Main.sx`==1.0)
				{
				connectAttr -f ($historyNodes[$y]+".outputGeometry[0]") ("uemTransformSC"+$xformNr+".originalGeometry[0]");
				connectAttr -f ($historyNodes[$y]+".outputGeometry[0]") ("uemTransformSC"+$xformNr+".input[0].inputGeometry");
				}
			else
				print ("// BlendShapes do not work with Scaled Unreal Skeleton, Skipping BlendShapes.\n");
			}

	$xformNr++;
	}

delete unrealMannequinSkinTransferSetup;
select -cl;
print ("// Skinning Transferred.\n");
}

global proc asUnrealJointConstrain (string $asJoint, string $ueJoint, int $mo[], float $offset[])
{
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $tempString[];

if (!`objExists $asJoint` || !`objExists $ueJoint`)
	return;

if ($mo[0])
	pointConstraint -mo $asJoint $ueJoint;
else
	pointConstraint $asJoint $ueJoint;
if ($mo[1])
	orientConstraint -mo $asJoint $ueJoint;
else
	{
	$tempString=`orientConstraint $asJoint $ueJoint`;
	setAttr ($tempString[0]+".offset") -type float3 $offset[0] $offset[1] $offset[2];
	}
//scaleConstraint -mo $asJoint $ueJoint;
connectAttr ($asJoint+".s") ($ueJoint+".s");
setAttr ($ueJoint+".segmentScaleCompensate") `getAttr ($asJoint+".segmentScaleCompensate")`;

addAttr -ln matchJoint -dt "string" $ueJoint;
setAttr -type "string" ($ueJoint+".matchJoint") $asJoint;

//avoid the 360 offset
for ($y=0;$y<size($XYZ);$y++)
	{
	if (`getAttr ($ueJoint+".r"+$xyz[$y])`>180 && `getAttr ($ueJoint+"_orientConstraint1.offset"+$XYZ[$y])`>179)
		setAttr ($ueJoint+"_orientConstraint1.offset"+$XYZ[$y]) (`getAttr ($ueJoint+"_orientConstraint1.offset"+$XYZ[$y])`-360);
	if (`getAttr ($ueJoint+".r"+$xyz[$y])`<-180 && `getAttr ($ueJoint+"_orientConstraint1.offset"+$XYZ[$y])`<-179)
		setAttr ($ueJoint+"_orientConstraint1.offset"+$XYZ[$y]) (`getAttr ($ueJoint+"_orientConstraint1.offset"+$XYZ[$y])`+360);
	}
}

global proc asDeletePartialJoints ()
{
if (!`objExists "DeformSet"`)
	error "Object \"DeformSet\" not found, No valid AdvancedSkeleton rig found in the scene.";

int $deleteAll,$numChar,$num;
float $pos[];
string $side,$fitJoint;
string $m="Delete Partial Joints for the following ?\n\n";
string $sel[]=`ls -sl`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $joints[],$tempString[];

for ($i=0;$i<size($sel);$i++)
	{
	//allow for also a controller to be selected, and partialJoint itself to be selected
	if (`gmatch $sel[$i] "*Partial_*"`)
		$sel[$i]=`substitute "Partial_" $sel[$i] "_"`;
	if (`gmatch $sel[$i] "FK*"`)
		$sel[$i]=`substring $sel[$i] 3 99`;
	if (`sets -im ControlSet $sel[$i]`)
		{
		$tempString[0]=`substitute "FK" $sel[$i] ""`;
		if (`objExists $tempString[0]`)
		$joints[size($joints)]=$tempString[0];
		$m+=$tempString[0]+"\n";
		}
	if (`sets -im DeformSet $sel[$i]`)
		{
		$joints[size($joints)]=$sel[$i];
		$m+=$sel[$i]+"\n";
		}
	}
if (!size($joints))
	{
	$joints=$deformJointsList;
	$m+="All deformation joints";
	$deleteAll=1;
	}

string $dialog=`confirmDialog -t "Confirm"
	-m $m
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	return;

for ($i=0;$i<size($joints);$i++)
	{
	$numChar=size($joints[$i]);
	$side=`substring $joints[$i] ($numChar-1) $numChar`;
	$fitJoint=`substring $joints[$i] 1 ($numChar-2)`;

	clear $tempString;
	if (`objExists ($fitJoint+"Partial"+$side)`)
		{
		$tempString={($fitJoint+"Partial"+$side),($fitJoint+$side+"_00"),($fitJoint+$side+"_00Offset"),
			($fitJoint+$side+"_00Offset_parentConstraint1"),($fitJoint+"Partial"+$side+"_pointConstraint1"),($fitJoint+"Partial"+$side+"_orientConstraint1"),
			("FKOffset"+$fitJoint+"Partial"+$side)};
		for ($y=0;$y<size($tempString);$y++)
			if (`objExists $tempString[$y]`)
				delete $tempString[$y];
		$num++;
		}
	if (`objExists ($fitJoint+"Partial1"+$side)`)//MultiPartial
		$tempString={("IKCurveInfoAllMultiply"+$fitJoint+$side),($fitJoint+"Partial1"+$side),("PartialMultiJoints"+$fitJoint+$side)};
		if (`objExists ($fitJoint+"Partial1"+$side)`)
			$num+=size(`listRelatives -ad -type joint ($fitJoint+"Partial1"+$side)`)+1;
		for ($y=0;$y<size($tempString);$y++)
			if (`objExists $tempString[$y]`)
				delete $tempString[$y];
	}

if ($deleteAll && `objExists PartialJointsSystem`)
 delete PartialJointsSystem;

if (size($joints))
	print ("// "+$num+" Partial Joints deleted\n");
}

global proc asCreatePartialJoints ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (!`objExists "DeformSet"`)
	error "Object \"DeformSet\" not found, No valid AdvancedSkeleton rig found in the scene.";

int $sideFactor;
int $incCtrl=`checkBox -q -v asBodyPartialJointsIncCtrlCheckBox`;
int $numMultiJoints=`intFieldGrp -q -v1 multiPartialJointsIntFieldGrp`;
int $autoBind=`checkBox -q -v asBodyMultiPartialJointsBindCheckBox`;
int $multi=`objExists asCreateMultiPartialJoints`;
int $numJointsCreated;
float $charHeight=`asgetCharHeight`;
float $radius=$charHeight/100.0;
float $stepLenght;
string $dialogResult="OK";
string $m="Create Partial Joints for the following ?\n\n";
string $name,$side,$parent,$target,$newCtrlBuildPoseCmd,$setRange,$followAttrObj,$partJoint,$cmd;
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asIcons.ma";
string $sel[]=`ls -sl`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $joints[],$children[],$partialJoints[],$zero[],$buffer[],$tempString[],$skinClusters[];

for ($i=0;$i<size($sel);$i++)
	{
	if (`sets -im ControlSet $sel[$i]`)
		{
		$tempString[0]=`substitute "FK" $sel[$i] ""`;
		if (`objExists $tempString[0]`)
		$joints[size($joints)]=$tempString[0];
		$m+=$tempString[0]+"\n";
		}
	if (`sets -im DeformSet $sel[$i]`)
		{
		$joints[size($joints)]=$sel[$i];
		$m+=$sel[$i]+"\n";
		}
	}
if (!size($joints))
	{
	$joints=$deformJointsList;
	$m+="All deformation joints";
	}

if (!`objExists asBatch`)
	$dialogResult=`confirmDialog -t "Confirm"
		-m $m
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
if ($dialogResult!="OK")
	return;

if ($incCtrl)
	asImportIconsFile $iconsFile;

for ($i=0;$i<size($joints);$i++)
	{
	$children=`listRelatives -type joint -c $joints[$i]`;
	$tempString=`listRelatives -type joint -p $joints[$i]`;
	$parent=$tempString[0];
	if (!size($children) || $parent=="" || `gmatch $joints[$i] "*Part[0-9]*"`)
		continue;
	if (`gmatch $joints[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	select $joints[$i];
	tokenize $joints[$i] "_" $buffer;
	$name=$buffer[0];
	$side="_"+$buffer[1];
	$partialJoints[$i]=$name+"Partial"+$side;
	$zero[$i]=$name+$side+"_00";
	if (`objExists $partialJoints[$i]`)
		{
		warning ("Skipping PartialJoint:\""+$partialJoints[$i]+"\", as this alread exists.\n");
		continue;
		}
	if (!`objExists PartialJointsSystem`)
		createNode -n PartialJointsSystem -p MotionSystem transform;
	if (!`objExists PartialJointsConstraints`)
		createNode -n PartialJointsConstraints -p PartialJointsSystem transform;
	select $joints[$i];
	joint -n $partialJoints[$i];
	setAttr ($partialJoints[$i]+".rotateOrder") `getAttr ($joints[$i]+".rotateOrder")`;
	setAttr ($partialJoints[$i]+".segmentScaleCompensate") 0;
	parent $partialJoints[$i] $parent;
	addAttr -ln partialJoint -at bool -dv true $partialJoints[$i];
	sets -add "DeformSet" $partialJoints[$i];
	createNode -n ($zero[$i]+"Offset") -p $joints[$i] transform;
	setAttr ($zero[$i]+"Offset.rotateOrder") `getAttr ($joints[$i]+".rotateOrder")`;
	parent ($zero[$i]+"Offset") PartialJointsSystem;
	duplicate -n $zero[$i] ($zero[$i]+"Offset");
	parent $zero[$i] ($zero[$i]+"Offset");
	parentConstraint -mo $parent ($zero[$i]+"Offset");
	addAttr -ln partialJoint -at bool $zero[$i];
	$target=$partialJoints[$i];
	$followAttrObj=$partialJoints[$i];

	if ($multi)
		{
		if (`attributeExists fat $joints[$i]`)
			$radius=`getAttr ($joints[$i]+".fat")`;
		$stepLenght=(($radius*2)/($numMultiJoints+0.0))*$sideFactor;
		move -r -os -wd ((-1*$sideFactor*$radius)+$stepLenght) 0 0 $partialJoints[$i];
		for ($y=1;$y<$numMultiJoints+1;$y++)
			{
			$partJoint=$name+"Partial"+$y+$side;
			duplicate -n $partJoint $partialJoints[$i];
			if ($y>1)
				{
				parent $partJoint ($name+"Partial"+($y-1)+$side);
				setAttr ($partJoint+".tx") $stepLenght;
				}
			$numJointsCreated++;
			}
		$tempString=`ikHandle -sol ikSplineSolver -ns 1 -scv 1 -roc 1 -pcv false -sj ($name+"Partial1"+$side) -ee ($name+"Partial"+$numMultiJoints+$side)`;
		rename $tempString[0] ("IkHandlePartial"+$name+$side);
		rename $tempString[1] ("EffectorPartial"+$name+$side);
		rename $tempString[2] ("IKCurve"+$name+$side);
		setAttr -l 1 ("IkHandlePartial"+$name+$side+".v") 0;
		if (!`objExists ("PartialMultiJoints"+$name+$side)`)
			{
			createNode -n ("PartialMultiJoints"+$name+$side) -p PartialJointsSystem transform;
			addAttr -k 1 -ln locatorVis -at bool -dv 0 ("PartialMultiJoints"+$name+$side);
			}
		parent ("IkHandlePartial"+$name+$side) ("IKCurve"+$name+$side) ("PartialMultiJoints"+$name+$side);
		for ($y=0;$y<4;$y++)
			{
			createNode -n ("PMJX"+$y+$name+$side) -p ("PartialMultiJoints"+$name+$side) transform;
			$pos=`xform -q -ws -t ("IKCurve"+$name+$side+".cv["+$y+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ("PMJX"+$y+$name+$side);
			spaceLocator -n ("PMJLoc"+$y+$name+$side);
			connectAttr ("PartialMultiJoints"+$name+$side+".locatorVis") ("PMJLoc"+$y+$name+$side+".v");
			setAttr ("PMJLoc"+$y+$name+$side+".overrideEnabled") 1;
			setAttr ("PMJLoc"+$y+$name+$side+".overrideColor") 13;
			if ($y==1 || $y==2)
				setAttr ("PMJLoc"+$y+$name+$side+".overrideColor") 14;
			parent -r ("PMJLoc"+$y+$name+$side) ("PMJX"+$y+$name+$side);
			connectAttr ("PMJLoc"+$y+$name+$side+".worldPosition") ("IKCurve"+$name+$side+".controlPoints["+$y+"]");
			if ($y<2)
				{
				parentConstraint -mo $parent ("PMJX"+$y+$name+$side);
				scaleConstraint $parent ("PMJX"+$y+$name+$side);
				}
			else
				{
				parentConstraint -mo $joints[$i] ("PMJX"+$y+$name+$side);
				scaleConstraint $joints[$i] ("PMJX"+$y+$name+$side);
				}
			}
		parent ("PMJLoc1"+$name+$side) ("PMJLoc0"+$name+$side);
		parent ("PMJLoc2"+$name+$side) ("PMJLoc3"+$name+$side);
		delete ("PMJX1"+$name+$side) ("PMJX2"+$name+$side);

		createNode -n ("IKCurveInfo"+$name+$side) curveInfo;
		connectAttr ("IKCurve"+$name+$side+".worldSpace[0]") ("IKCurveInfo"+$name+$side+".inputCurve");

		//stretchy lenght Normalize & MainScaleMultiply
		createNode -n ("IKCurveInfoNormalize"+$name+$side) multiplyDivide;
		setAttr ("IKCurveInfoNormalize"+$name+$side+".operation") 2;
		createNode -n ("IKCurveInfoAllMultiply"+$name+$side) multiplyDivide;
		setAttr ("IKCurveInfoAllMultiply"+$name+$side+".operation") 2;
		connectAttr ("IKCurveInfoNormalize"+$name+$side+".outputX") ("IKCurveInfoAllMultiply"+$name+$side+".input1X");
		connectAttr MainScaleMultiplyDivide.outputX ("IKCurveInfoAllMultiply"+$name+$side+".input2X");
		connectAttr ("IKCurveInfo"+$name+$side+".arcLength") ("IKCurveInfoNormalize"+$name+$side+".input1X");
		setAttr ("IKCurveInfoNormalize"+$name+$side+".input2X") `getAttr ("IKCurveInfo"+$name+$side+".arcLength")`;

		//connect scale so the Offset scales along
//		connectAttr ("IKCurveInfoNormalize"+$name+$side+".output.outputX") ($name+"Partial1"+$side+".sx");
		createNode -n ("IKCurveTxMultiply"+$name+$side) multiplyDivide;
		setAttr ("IKCurveTxMultiply"+$name+$side+".input1X") $stepLenght;
//		connectAttr ("IKCurveInfoNormalize"+$name+$side+".output.outputX") ("IKCurveTxMultiply"+$name+$side+".input2X");
		connectAttr ("IKCurveInfoAllMultiply"+$name+$side+".output.outputX") ("IKCurveTxMultiply"+$name+$side+".input2X");
		for ($y=2;$y<$numMultiJoints+1;$y++)
			connectAttr ("IKCurveTxMultiply"+$name+$side+".output.outputX") ($name+"Partial"+$y+$side+".tx");

		delete $partialJoints[$i] ($name+$side+"_00Offset");

		if ($autoBind)
			{
			$tempString=`listConnections -s 0 -d 1 -type skinCluster $joints[$i]`;
			$skinClusters=`stringArrayRemoveDuplicates $tempString`;
			for ($y=0;$y<size($skinClusters);$y++)
				{
				if ($skinClusters[$y]=="skinClusterSkinCage")
					continue;
				$cmd="skinCluster -e -dr 4";
				for ($z=1;$z<$numMultiJoints+1;$z++)
					$cmd+=" -ai "+$name+"Partial"+$z+$side;
				$cmd+=" "+$skinClusters[$y];
				evalEcho ($cmd);
				}
			}
		continue;
		}

	//Ctrl
	if ($incCtrl)
		{
		createNode -n ("FKOffset"+$partialJoints[$i]) -p PartialJointsSystem transform;
		createNode -n ("FKExtra"+$partialJoints[$i]) -p ("FKOffset"+$partialJoints[$i]) transform;
		asLockAttr ("FKExtra"+$partialJoints[$i]) 0 0 1 1;	
//		circle -n ("FK"+$partialJoints[$i]) -c 0 0 0 -nr 1 0 0 -sw 360 -r ($charHeight/20.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0;
		duplicate -n ("FK"+$partialJoints[$i]) FaceA_icon;
		setAttr ("FK"+$partialJoints[$i]+".t") -type float3 0 0 0;
		scale -r 0.834 0.834 0.834 ("FK"+$partialJoints[$i]+".cv[0:99]");
		setAttr ("FK"+$partialJoints[$i]+"Shape.overrideEnabled") 1;
		setAttr ("FK"+$partialJoints[$i]+"Shape.overrideColor") 16;
		parent ("FK"+$partialJoints[$i]) ("FKExtra"+$partialJoints[$i]);
		sets -add ControlSet ("FK"+$partialJoints[$i]) ("FKExtra"+$partialJoints[$i]);
		asAlign ("FKOffset"+$partialJoints[$i]) $joints[$i] 1 1 0 1;
		parentConstraint ("FK"+$partialJoints[$i]) $partialJoints[$i];
		scaleConstraint ("FK"+$partialJoints[$i]) $partialJoints[$i];
		parent ($partialJoints[$i]+"_parentConstraint1") ($partialJoints[$i]+"_scaleConstraint1") PartialJointsSystem;
		//update buildPose
		$newCtrlBuildPoseCmd ="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 FKExtra"+$partialJoints[$i]+";";
		$newCtrlBuildPoseCmd+="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 FK"+$partialJoints[$i]+";";
		$newCtrlBuildPoseCmd+="setAttr FK"+$partialJoints[$i]+".follow 5;";		
		if (!`attributeExists udExtraAttr buildPose`)
			addAttr -ln udExtraAttr -dt "string" buildPose;
		setAttr -type "string" buildPose.udExtraAttr (`getAttr buildPose.udExtraAttr`+$newCtrlBuildPoseCmd);
		$target="FKOffset"+$partialJoints[$i];
		$followAttrObj="FK"+$partialJoints[$i];

		if (!`attributeExists partialVis Main`)
			{
			addAttr -k 1 -ln partialVis -at bool -dv 1 Main;
			setAttr -k 0 -cb 1 Main.partialVis;
			}
		connectAttr Main.partialVis ("FKOffset"+$partialJoints[$i]+".v");
		}

	orientConstraint $zero[$i] $joints[$i] $target;
	setAttr ($target+"_orientConstraint1.interpType") 2;
	pointConstraint $joints[$i] $target;
	setAttr ($target+"_pointConstraint1.offsetX") ($sideFactor*$charHeight/5000);
	scaleConstraint $joints[$i] $target;
	if (!$incCtrl)
		parent ($zero[$i]+"Offset_parentConstraint1") ($target+"_orientConstraint1") ($target+"_pointConstraint1") ($target+"_scaleConstraint1") PartialJointsConstraints;

	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 5 $followAttrObj;
	$setRange="FK"+$partialJoints[$i]+"SR";
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($followAttrObj+".follow") ($setRange+".value.valueX");
	connectAttr ($followAttrObj+".follow") ($setRange+".value.valueY");
	connectAttr ($setRange+".outValue.outValueY") ($target+"_orientConstraint1."+$zero[$i]+"W0");
	connectAttr($setRange+".outValue.outValueX") ($target+"_orientConstraint1."+$joints[$i]+"W1");

	$numJointsCreated++;
	}

if ($incCtrl && `objExists iconsGroup`)
	delete iconsGroup;

select -cl;
for ($i=0;$i<size($joints);$i++)
	if (`gmatch $partialJoints[$i] "*Partial_*"`)
		if (`objExists $partialJoints[$i]`)
			select -add $partialJoints[$i];

print ("// "+$numJointsCreated+" Partial Joints created\n");
}

global proc asCreateMultiPartialJoints ()
{
string $sel[]=`ls -sl`;
if (!`objExists asCreateMultiPartialJoints`)
createNode -n asCreateMultiPartialJoints transform;
select $sel;
asCreatePartialJoints;
delete asCreateMultiPartialJoints;
}

global proc asCustomOrientJointsCreate ()
{
string $space=`optionMenu -q -v asCustomOrientJointsSpaceOptionMenu`;
string $front=`optionMenu -q -v asCustomOrientJointsFrontOptionMenu`;
string $tempString[],$tempString2[],$tempString3[];

if (`objExists GameSkeletonRoot_M`)
	delete GameSkeletonRoot_M;

//create
duplicate -n GameSkeletonRoot_M Root_M;
parent -w GameSkeletonRoot_M;
$tempString=`listRelatives -f -ad -type joint GameSkeletonRoot_M`;
$tempString2=`listRelatives -ad -type joint GameSkeletonRoot_M`;
for ($i=0;$i<size($tempString);$i++)
	rename $tempString[$i] ("GameSkeleton"+$tempString2[$i]);

//orient
$tempString=`listRelatives -ad -type joint GameSkeletonRoot_M`;
$tempString[size($tempString)]="GameSkeletonRoot_M";
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listRelatives -c -type joint $tempString[$i]`;
		$tempString3=`listRelatives -p -type joint $tempString[$i]`;
		if (size($tempString2))
			parent -w $tempString2;
		if ($tempString3[0]!="")
			parent -w $tempString[$i];

		if ($space=="World")
			{
			setAttr ($tempString[$i]+".jointOrient") -type float3 0 0 0;
			setAttr ($tempString[$i]+".rotate") -type float3 0 0 0;
			if ($front=="x") setAttr ($tempString[$i]+".jointOrient") -type float3 0 -90 0;
			if ($front=="y") setAttr ($tempString[$i]+".jointOrient") -type float3 90 0 0;
			}
		if ($space=="Local")
			{
			if ($front=="y") rotate -r -os 0 0 -90 $tempString[$i];
			if ($front=="z") rotate -r -os 0 90 0 $tempString[$i];
			if ($front=="y" || $front=="z")
			makeIdentity -apply 1 -t 0 -r 1 -s 0 -n 0 $tempString[$i];
			}
		if ($tempString3[0]!="")
			parent $tempString[$i] $tempString3[0];
		if (size($tempString2))
			parent $tempString2 $tempString[$i];
		}

//if RootMotionJoint was already added, then include this
if (`objExists DeformationSystem|root`)
	{
	select -cl;
	joint -n GameSkeletonRoot;
	parent GameSkeletonRoot_M GameSkeletonRoot;
	}

select GameSkeletonRoot_M;
print "// GameSkeleton created\n";
}

global proc asCustomOrientJointsDelete ()
{
if (`objExists GameSkeletonRoot_M`) delete GameSkeletonRoot_M;
if (`objExists GameSkeletonRoot`) delete GameSkeletonRoot;
print "// GameSkeleton deleted\n";
}

global proc asCustomOrientJointsShowAxis ()
{
string $sel[]=`ls -sl`;
select -hi GameSkeletonRoot_M;
ToggleLocalRotationAxes;
select $sel;
}

global proc asCustomOrientJointsConnect ()
{
string $tempString[];

asCustomOrientJointsDisconnect;
$tempString=`listRelatives -ad -type joint GameSkeletonRoot_M`;
$tempString[size($tempString)]="GameSkeletonRoot_M";
for ($i=0;$i<size($tempString);$i++)
	{
	parentConstraint -mo  (`substitute "GameSkeleton" $tempString[$i] ""`) $tempString[$i];
	scaleConstraint -mo  (`substitute "GameSkeleton" $tempString[$i] ""`) $tempString[$i];
	}
print "// GameSkeleton connected	\n";
}

global proc asCustomOrientJointsDisconnect ()
{
$tempString=`listRelatives -ad -type joint GameSkeletonRoot_M`;
$tempString[size($tempString)]="GameSkeletonRoot_M";
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists ($tempString[$i]+"_parentConstraint1")`) delete ($tempString[$i]+"_parentConstraint1");
	if (`objExists ($tempString[$i]+"_scaleConstraint1")`) delete ($tempString[$i]+"_scaleConstraint1");
	}
}

global proc asCustomOrientTransferSkin ()
{
int $transferBack;
string $tempString[],$scps[],$scs[],$skinClusters[];
string $sourceJoints[]=`listRelatives -ad -type joint Root_M`;
$sourceJoints[size($sourceJoints)]="Root_M";
string $destJoints[]=`listRelatives -ad -type joint GameSkeletonRoot_M`;
$destJoints[size($destJoints)]="GameSkeletonRoot_M";

if (`attributeExists skinTransferred GameSkeletonRoot_M`)
	{
	$transferBack=`getAttr GameSkeletonRoot_M.skinTransferred`;
	setAttr GameSkeletonRoot_M.skinTransferred (!$transferBack);
	}
else
	addAttr -ln skinTransferred -dv 1 -at bool GameSkeletonRoot_M;

if ($transferBack)
	{
	$tempString=$sourceJoints;
	$sourceJoints=$destJoints;
	$destJoints=$tempString;
	}

for ($i=0;$i<size($sourceJoints);$i++)
	{
	$scs=`listConnections -p 0 -type skinCluster ($sourceJoints[$i]+".worldMatrix[0]")`;
	$scps=`listConnections -p 1 -type skinCluster ($sourceJoints[$i]+".worldMatrix[0]")`;
	for ($y=0;$y<size($scps);$y++)
		connectAttr -f ($destJoints[$i]+".worldMatrix[0]") $scps[$y];
	for ($y=0;$y<size($scs);$y++)
		if (!`stringArrayCount $scs[$y] $skinClusters`)
			$skinClusters[size($skinClusters)]=$scs[$y];
	}
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
dgdirty -a;

if ($transferBack)
	print "// Transferring skinning back to AdvancedSkeleton joints.\n";
else
	print ("// Skinning transferred to Game Skeleton\n");
}

global proc asCreateGameEngineRootMotion ()
{
int $opm=`asGetOpm`;
float $charHeight=`asgetCharHeight`;
string $tempString[];

if (`objExists root`)
	error "\"root\" already exists";
select -cl;

joint -n root;
$tempString=`listRelatives -c -type joint DeformationSystem`;
parent root DeformationSystem;
//parentConstraint Main root;
//parent root_parentConstraint1 ConstraintSystem;
if (size($tempString))
	parent $tempString root;

createNode -n FKOffsetroot_M -p RootSystem transform;
createNode -n FKFollowroot_M -p FKOffsetroot_M transform;
createNode -n FKExtraroot_M -p FKFollowroot_M transform;
asLockAttr FKExtraroot_M 0 0 1 1;	
circle -n FKroot_M -c 0 0 0 -nr 0 1 0 -sw 360 -r ($charHeight/20.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0;
setAttr FKroot_MShape.overrideEnabled 1;
setAttr FKroot_MShape.overrideColor 17;
asLockAttr FKroot_M 0 0 1 1;	
parent FKroot_M FKExtraroot_M;
sets -add ControlSet FKroot_M FKExtraroot_M;
parentConstraint FKroot_M root;
parent root_parentConstraint1 ConstraintSystem;
parentConstraint Main MainSystem FKFollowroot_M;

addAttr -k 1 -ln followMain -at double -min 0 -max 10 -dv 0 FKroot_M;
createNode -n rootRange setRange;
setAttr rootRange.maxX 1;
setAttr rootRange.minY 1;
setAttr rootRange.oldMaxX 10;
setAttr rootRange.oldMaxY 10;
connectAttr FKroot_M.followMain rootRange.value.valueX;
connectAttr FKroot_M.followMain rootRange.value.valueY;
connectAttr rootRange.outValueX FKFollowroot_M_parentConstraint1.MainW0;
connectAttr rootRange.outValueY FKFollowroot_M_parentConstraint1.MainSystemW1;

//in OPM Root_M inherits the Xform, so turn it off
if ($opm && `objExists Root_M`)
	setAttr Root_M.inheritsTransform 0;

select -cl;
print ("// root-motion-joint \"root\" created.\n");
}

global proc asDeleteGameEngineRootMotion ()
{
string $tempString[];

if (!`objExists root`)
	error "\"root\" not found";

$tempString=`listRelatives -c -type joint root`;
if (size($tempString))
	parent $tempString DeformationSystem;
delete root root_parentConstraint1;
if (`objExists FKOffsetroot_M`)
	delete FKOffsetroot_M;
select -cl;
print ("// root-motion-joint \"root\" deleted.\n");
}

global proc asGameEngineScaling (int $onOff)
{
int $isInIk;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $deformJoints[],$tempString[],$tempString2[],$parents[];

$tempString=`ls "GameEngineScalingSSCMPD*"`;
if (size($tempString))
	delete $tempString;

//turn off segmentScaleCompensate
$deformJoints=`listRelatives -type joint -ad "DeformationSystem"`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	if ($onOff && (`getAttr ($deformJoints[$i]+".segmentScaleCompensate")` || $deformJoints[$i]=="Root_M"))
		{
		if (!`attributeExists GameEngineScalingSSC $deformJoints[$i]`)
			addAttr -k 0 -ln GameEngineScalingSSC -at bool -dv 1 $deformJoints[$i];
		setAttr ($deformJoints[$i]+".segmentScaleCompensate") 0;
		}
	else if ($onOff==0 && `attributeExists GameEngineScalingSSC $deformJoints[$i]`)
		setAttr ($deformJoints[$i]+".segmentScaleCompensate") 1;
	}

//existing scaleConnections
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (!`attributeExists GameEngineScalingSSC $deformJoints[$i]`)
		continue;
	for ($y=0;$y<size($XYZ);$y++)
		{
		if ($onOff)
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 ($deformJoints[$i]+".scale"+$XYZ[$y])`;
			if ($tempString[0]=="")
				continue;
			if (!`attributeExists ("GameEngineScalingS"+$XYZ[$y]) $deformJoints[$i]`)
				{
				addAttr -k 0 -ln ("GameEngineScalingS"+$XYZ[$y]) -at double $deformJoints[$i];
				connectAttr -f $tempString[0] ($deformJoints[$i]+".GameEngineScalingS"+$XYZ[$y]);
				}
			disconnectAttr $tempString[0] ($deformJoints[$i]+".scale"+$XYZ[$y]);
			setAttr ($deformJoints[$i]+".scale"+$XYZ[$y]) 1;
			//also FKParentConstraintTo.. Note these do not get restored upon switching Back, but remain connected from .GameEngineScalingS
			if (`objExists ("FKParentConstraintTo"+$deformJoints[$i])`)
				{
				if (`isConnected ($deformJoints[$i]+".scale") ("FKParentConstraintTo"+$deformJoints[$i]+".scale")`)
					disconnectAttr ($deformJoints[$i]+".scale") ("FKParentConstraintTo"+$deformJoints[$i]+".scale");
				if (!`isConnected ($deformJoints[$i]+".GameEngineScalingS"+$XYZ[$y]) ("FKParentConstraintTo"+$deformJoints[$i]+".scale"+$XYZ[$y])`)
					connectAttr -f ($deformJoints[$i]+".GameEngineScalingS"+$XYZ[$y]) ("FKParentConstraintTo"+$deformJoints[$i]+".scale"+$XYZ[$y]);
				}
			}
		else if ($onOff==0 && `attributeExists ("GameEngineScalingS"+$XYZ[$y]) $deformJoints[$i]`)
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 ($deformJoints[$i]+".GameEngineScalingS"+$XYZ[$y])`;
			if ($tempString[0]=="")
				continue;
			if (`isConnected $tempString[0] ($deformJoints[$i]+".scale"+$XYZ[$y])`)
				continue;//already switched to Maya scaling
			connectAttr -f $tempString[0] ($deformJoints[$i]+".scale"+$XYZ[$y]);				
			}
		}
	}

//manual segmentScaleCompensate with 1/x
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (!`attributeExists GameEngineScalingSSC $deformJoints[$i]` || !`attributeExists GameEngineScalingSX $deformJoints[$i]`)
		continue;
	if (`gmatch $deformJoints[$i] "*Part[0-9]*"`)
		continue;
	if ($onOff && !`objExists ("GameEngineScalingSSCMPD2"+$deformJoints[$i])`)
		{
		createNode -n ("GameEngineScalingSSCMPD2"+$deformJoints[$i]) multiplyDivide;
		for ($y=0;$y<size($XYZ);$y++)
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 ($deformJoints[$i]+".GameEngineScalingS"+$XYZ[$y])`;
			if ($tempString[0]=="")
				continue;
			$isInIk=0;
			if (`gmatch $tempString[0] "ScaleBlend*"`)
				$isInIk=1;
			connectAttr $tempString[0] ("GameEngineScalingSSCMPD2"+$deformJoints[$i]+".input1.input1"+$XYZ[$y]);
			connectAttr ("GameEngineScalingSSCMPD2"+$deformJoints[$i]+".output"+$XYZ[$y]) ($deformJoints[$i]+".scale"+$XYZ[$y]);
			}

		$tempString=`listRelatives -p  -type joint $deformJoints[$i]`;
		if (`gmatch $tempString[0] "*Part[0-9]*"` || $isInIk)// || $inIk
			{
			$tempString2=`ls -l $tempString[0]`;
			tokenize $tempString2[0] "|" $parents;
			for ($y=size($parents)-2;$y>-1;$y--)
				if (!`gmatch $parents[$y] "*Part[0-9]*"`)
					{
					if (!`objExists ("FK"+$parents[$y])`)
						continue;
					if (!`objExists ("GameEngineScalingSSCMPD1"+$deformJoints[$i])`)
						{
						createNode -n ("GameEngineScalingSSCMPD1"+$deformJoints[$i]) multiplyDivide;
						setAttr ("GameEngineScalingSSCMPD1"+$deformJoints[$i]+".input1") -type float3 1 1 1;
						for ($z=0;$z<size($XYZ);$z++)
							{
							$tempString=`listConnections -s 1 -d 0 -p 1 ($parents[$y]+".GameEngineScalingS"+$XYZ[$z])`;
							if ($tempString[0]=="")
								continue;
							connectAttr $tempString[0] ("GameEngineScalingSSCMPD1"+$deformJoints[$i]+".input2.input2"+$XYZ[$z]);
							}
						setAttr ("GameEngineScalingSSCMPD1"+$deformJoints[$i]+".operation") 2;
						}
					for ($z=0;$z<size($XYZ);$z++)
						connectAttr -f ("GameEngineScalingSSCMPD1"+$deformJoints[$i]+".output"+$XYZ[$z]) ("GameEngineScalingSSCMPD2"+$deformJoints[$i]+".input2.input2"+$XYZ[$z]);
					break;
					}
			}
		}
	}

select -cl;
if ($onOff)
	print ("// Switched to GameEngine compatible scaling system.\n");
else
	print ("// Switched to Maya scaling system (segmentScaleCompensate).\n");
}

global proc asUnrealTwistJointsBehaviour (int $onOff)
{
int $childDepth;
string $deformJoints[]=`listRelatives -ad -type joint DeformationSystem`;
string $tempString[];
string $parent,$originalParent,$fitJoint;

if ($onOff)
	for ($i=0;$i<size($deformJoints);$i++)
		{
		$tempString=`listRelatives -p $deformJoints[$i]`;
		$parent=$tempString[0];
		$childDepth=0;
		while (`gmatch $parent "*Part[0-9]*"`)
			{
			$tempString=`listRelatives -p $parent`;
			$parent=$tempString[0];
			$childDepth++;
			}
		if ($childDepth<1)
			continue;

		$tempString=`listRelatives -p $deformJoints[$i]`;
		$originalParent=$tempString[0];

		tokenize $parent "_" $tempString;
		$fitJoint=$tempString[0];
		if (`attributeExists inbetweenJoints $fitJoint`)
			continue;//Skipping Inbetweens

		print ("// parenting "+$deformJoints[$i]+" to "+$parent+"\n");
		parent $deformJoints[$i] $parent;
		if (`gmatch $deformJoints[$i] "*Part[0-9]*"`)
			reorder -relative -1 $deformJoints[$i];
		if (!`attributeExists originalParent $deformJoints[$i]`)
			addAttr -ln originalParent -dt "string" $deformJoints[$i];
		setAttr -type "string" ($deformJoints[$i]+".originalParent") $originalParent;
		}

if (!$onOff)
	for ($i=0;$i<size($deformJoints);$i++)
		{
		$tempString=`listRelatives -p $deformJoints[$i]`;
		if (!`attributeExists originalParent $deformJoints[$i]`)
			continue;
		$originalParent=`getAttr ($deformJoints[$i]+".originalParent")`;
		print ("// parenting "+$deformJoints[$i]+" to "+$originalParent+"\n");
		parent $deformJoints[$i] $originalParent;
		deleteAttr ($deformJoints[$i]+".originalParent");
		}

select -cl;
if ($onOff)
	{
	print ("// Switched twist-joints-parenting to \"Unreal IK solvers Behaviour\".\n");
	}
else
	print ("// Switchedtwist-joints-parenting to \"Default Maya Behaviour\".\n");
}

global proc asCreateJointGroups ()
{
string $deformJoints[]=`listRelatives -ad -type joint DeformationSystem`;
string $tempString[],$tempString2[];
string $constraint;

for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Part[0-9]*"` || `gmatch $deformJoints[$i] "Spine*"` || `gmatch $deformJoints[$i] "Chest*"`)
		continue;
	$tempString=`listConnections ($deformJoints[$i]+".rx")`;
	$constraint=$tempString[0];
	if($constraint=="")
		continue;

	createNode -n ($deformJoints[$i]+"JointGroup") transform;
	asAlign ($deformJoints[$i]+"JointGroup") $deformJoints[$i] 1 1 0 1;
	$tempString=`listRelatives -p $deformJoints[$i]`;
	parent ($deformJoints[$i]+"JointGroup") $tempString[0];
	parent $deformJoints[$i] ($deformJoints[$i]+"JointGroup");

	if (`objExists ("IKX"+$deformJoints[$i])`)
		{
		createNode -n ("IKXJointGroup"+$deformJoints[$i]) transform;
		asAlign ("IKXJointGroup"+$deformJoints[$i]) $deformJoints[$i] 1 1 0 1;
		parent ("IKXJointGroup"+$deformJoints[$i]) ("IKX"+$deformJoints[$i]);
		}

	$tempString=`listConnections -s 1 -d 0 -p 1 -c 1 $constraint`;
	for ($y=0;$y<size($tempString);$y=$y+2)
		{
		if (`gmatch $tempString[$y] "*targetJointOrient"`)
			{
			disconnectAttr $tempString[$y+1] $tempString[$y];
			setAttr -type float3 $tempString[$y] 0 0 0;
			continue;
			}
		if (`gmatch $tempString[$y+1] "IKX*"`)
			{
			$tempString2[0]=`substitute "IKX" $tempString[$y+1] "IKXJointGroup"`;
			catchQuiet (`connectAttr -f $tempString2[0] $tempString[$y]`);
			}
		}
	}
print "// JointGroups created\n";
select -cl;
}

global proc asBsPopulatePopupMenu (string $action)
{
string $popupMenu="asBs"+$action+"PopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
if (!`objExists asFaceBS`)
	return;
string $targets[]=`asBSGetTargets`;

setParent -menu $popupMenu;
for ($i=0;$i<size($targets);$i++)
	{
	if ($targets[$i]=="mouth_close_M")
		continue;
	menuItem -sm 0 -l $targets[$i] -c ("asBSAdjustTargetFromPopUpMenu "+$targets[$i]);
	}
}

global proc asDsPopulatePopupMenu (string $action)
{
string $popupMenu="asDs"+$action+"PopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
int $numKeys,$tempNumKeys,$firstDsAttr,$numLev3Menus;
float $keyValues[],$tempKeyValues[];
string $cmd,$lev1Menu,$lev2Menu,$lev3Menu,$drivingAttr,$animCurve;
string $tempString[],$attrs[],$animCurves[];
string $drivingSystems[]=`asDsGetDrivingSystems`;

for ($i=0;$i<size($drivingSystems);$i++)
	{
	$firstDsAttr=1;
	if (`gmatch $drivingSystems[$i] "*_L"` && $action=="Edit")
		continue;
	if (`gmatch $drivingSystems[$i] "CTRL_L_*"`)//Metahuman
		continue;

	//$menu2s
	$attrs=`asDsGetAttrs $drivingSystems[$i]`;
	$numLev3Menus=0;
	for ($y=0;$y<size($attrs);$y++)
		{
		$drivingAttr=$attrs[$y];
		if (`gmatch $drivingAttr "*Left"`)//ctrlARKit_M
			continue;

		if ($firstDsAttr)
			{
			//$menu1s
			setParent -menu $popupMenu;
			$lev1Menu=`menuItem -sm 1 -l $drivingSystems[$i]`;
			$firstDsAttr=0;
			}

		if ($action=="Graph" || $action=="Delete")
			{
			menuItem -p $lev1Menu -c ("asDsEdit "+$action+" "+$drivingSystems[$i]+" "+$attrs[$y]+" 0") -l $attrs[$y];
			continue;
//			break;//No level3 menus
			}
		else
			{
			$lev2Menu=`menuItem -p $lev1Menu -sm 1 -l $attrs[$y]`;
			}

		//$menu3s
		$animCurves=`asDsGetAnimCurves $drivingSystems[$i] $drivingAttr`;
	
		if (!size($animCurves))
			{
//print ($drivingSystems[$i]+"\n");
			//dont need lev2Menu e.g. ctrlMouthCorner_R.tx & ty, as we use .smile etc
			deleteUI $lev2Menu;
			continue;
			}
/*
		$maxNumKeys=0;
		for ($a=0;$a<size($animCurves);$a++)//for multiple animCurve`s, find the one with the most keys
			{
			$numKeys=`keyframe -q -keyframeCount $animCurves[$a]`;
			if ($numKeys>$maxNumKeys)
				{
				$maxNumKeys=$numKeys;
				$animCurve=$animCurves[$a];
				}
			}
*/
		//That means not finding the KeyValues that might be on the `other` curves, so
		clear $keyValues;
		for ($a=0;$a<size($animCurves);$a++)//for multiple animCurve`s, find the one with the most keys
			{
			$tempNumKeys=`keyframe -q -keyframeCount $animCurves[$a]`;
			for ($x=0;$x<$tempNumKeys;$x++)
				{
				$tempKeyValues=`keyframe -in $x -q -fc $animCurves[$a]`;
				$tempKeyValues[0]=`asRoundOff $tempKeyValues[0] 3`;
				if (!`floatArrayCount $tempKeyValues[0] $keyValues`)
					$keyValues[size($keyValues)]=$tempKeyValues[0];
				}
			}
		$keyValues=`sort $keyValues`;
		$numKeys=size($keyValues);

		for ($x=0;$x<size($keyValues);$x++)
			{
			if($keyValues[$x]==0)
				continue;
			$cmd="asDsEdit "+$action+" "+$drivingSystems[$i]+" "+$attrs[$y]+" "+$keyValues[$x];
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 0 -l $keyValues[$x] -c $cmd`;
			$numLev3Menus++;
			}
		}
//	if ($numLev3Menus==0 && $action=="Edit")
//		deleteUI $lev1Menu;
	}
}

global proc string[] asGetBlendedDrivers (string $obj, string $attr)
{
float $driver1Value,$driver2Value;
string $mpd,$setRange,$driver1,$driver2;
string $tempString[],$blendedDrivers[];

$tempString=`listConnections -s 1 -d 0 ($obj+"."+$attr)`;

if (`objectType $tempString[0]`=="multiplyDivide")//version pre 5.767
	{
	$mpd=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 ($mpd+".input1X")`;
	}
$setRange=$tempString[0];
$tempString=`listConnections -s 1 -d 0 ($setRange+".valueX")`;
if (`objectType $tempString[0]`=="plusMinusAverage")//version from 5.767
	{
	$tempString=`listConnections -s 1 -d 0 ($tempString[0]+".input1D[0]")`;
	$mpd=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 ($mpd+".input1X")`;
	if (`objectType $tempString[0]`=="blendWeighted")
		$tempString=`listConnections -s 1 -d 0 -p 1 ($tempString[0]+".input[0]")`;
	else
		$tempString=`listConnections -s 1 -d 0 -p 1 ($mpd+".input1X")`;
	$driver1=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 ($mpd+".input1Y")`;
	if (`objectType $tempString[0]`=="blendWeighted")
		$tempString=`listConnections -s 1 -d 0 -p 1 ($tempString[0]+".input[0]")`;
	else
		$tempString=`listConnections -s 1 -d 0 -p 1 ($mpd+".input1Y")`;
	$driver2=$tempString[0];
	}
else
	{
	$tempString=`listConnections -s 1 -d 0 -p 1 ($setRange+".valueX")`;
	$driver1=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 -p 1 ($setRange+".valueY")`;
	$driver2=$tempString[0];
	}
$driver1Value=`getAttr ($setRange+".maxX")`;
$driver2Value=`getAttr ($setRange+".maxY")`;

$blendedDrivers={$driver1,$driver2};
return $blendedDrivers;
}

global proc float[] asGetBlendedDriverValues (string $obj, string $attr)
{
float $blendedDriverValues[]={1,1};
string $tempString[];

tokenize $attr "_" $tempString;
if (`gmatch $tempString[0] "*Neg"`) $blendedDriverValues[0]=-1;
if (`gmatch $tempString[1] "*Neg"`) $blendedDriverValues[1]=-1;

return $blendedDriverValues;
}

global proc asVersionRequirementCheck (string $bodyFace, float $version)
{
string $reBuildButtonLabel="ReBuild AdvancedSkeleton";
string $versionAttrObj="Main";
string $versionString=$version;
string $versionStringThousand;

//ensure 3decimals for clairity
$versionStringThousand=`floor($version*1000)`;
if (size($versionString)<5)
	$versionString=`substring $versionStringThousand 1 1`+"."+`substring $versionStringThousand 2 4`;

if ($bodyFace=="face")
	{
	$reBuildButtonLabel="ReBuild AdvancedFace";
	$versionAttrObj="FaceGroup";
	}
if (`attributeExists version $versionAttrObj`)
	if (`getAttr ($versionAttrObj+".version")`<$version) 
		error ("AdvancedSkeleton "+$bodyFace+"-rig version older then v"+$versionString+" detected, You must first run \""+$reBuildButtonLabel+"\", before you can use this function");
}

global proc asDsCreate ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global int $asDSMirror;
global int $asDSDisableMirror;
global int $asDSAngle;
global int $asDSAdvancedOptions;
global int $asBuilding;
global int $asRebuilding;
global float $asDSAttrMin;
global float $asDSAttrMax;

$asDSAdvancedOptions=0;
$asDSDisableMirror=0;
int $modifier=`getModifiers`;
if ($modifier==4)
	$asDSAdvancedOptions=1;

int $isFace,$isEditingExisting,$flippedDriverValue;
string $sel[]=`ls -sl`;

int $reusingSdkXform,$useExistingController,$breakSideLoop,$blendedAttr,$numChar,$inControlSet,$inFaceControlSet,$testSymmetry,$otherDsIsDriver,$allDrivensMiddle;
int $skipX,$skipY,$skipZ;
float $runValues[],$pos[],$drivenValues[],$blendedDriverValues[],$keyXValues[],$keyYValues[];
float $poseValue,$currentValue,$maxDistAmoungDrivens,$minX,$maxX,$minY,$maxY,$minZ,$maxZ,$difX,$difY,$difZ,$controlScale,$min,$dist,$defaultValue,$inLoopDriveValue;
string $parent,$child,$obj,$attr,$drivenObj,$drivenAttr,$m,$t,$controllerName,$side,$oppositeSide,$buildPoseNode,$dialogResult,$controllerName,$attrName,$restorePoseCmd;
string $attrType,$originalSideControllerName,$originalSideAttrName,$ctrl,$animCurve,$mirroredAnimCurve,$att,$driveSource,$bw,$SDKDrivingBW,$SDKDrivenBW,$bwInputAttr;
string $controllerSide,$tweakedAttrName,$allSet;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$drivens[],$sdkDrivens[],$runObjAttrs[],$checkObjAttr[],$drivenObjs[],$buildPoseCmds[],$runCmds[];
string $existingSdkXforms[],$realDrivenObj[],$blendedDrivers[],$connectionAttrNames[];
float $driverValue=10;
float $scale=`asGetScale`;
float $sideTreshold=0.01*$scale;

asVersionRequirementCheck body 5.732;
asVersionRequirementCheck face 5.732;

if (`objExists EditingDrivingSystem`) delete EditingDrivingSystem;

//TestSymmetry used
if (`objExists TestSymmetry`)
	{
	$testSymmetry=1;
	currentTime 0;
//	dgdirty -a;
	$restorePoseCmd=`getAttr TestSymmetry.udAttr`;
	delete TestSymmetry;
	catchQuiet (`eval ($restorePoseCmd)`);
	}
//TestAnimation used
asDsRemoveTestAnimation;

//Do we come from AdvancedSkeleton BUILD Mode ?
int $comeFromASBuild=0;
if ($asBuilding || $asRebuilding)
	$comeFromASBuild=1;
else
	{
	$asDSObjName="";
	$asDSAttrName="";
	}

//Are we editing Existing DrivingSystem ?
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	$isEditingExisting=1;
	$tempString[0]=`headsUpDisplay -q -l HUDEDSMode`;
	tokenize $tempString[0] $tempString2;
	tokenize $tempString2[3] "=" $tempString3;
	tokenize $tempString3[0] "." $tempString4;
	$asDSObjName=$tempString4[0];
	$asDSAttrName=$tempString4[1];
	$driverValue=$tempString3[1];
	//if $otherDsIsDriver switch $asDSObjName to be the coresponding FK ctrl
	if (`objExists ("FK"+$asDSObjName)`)
		{
		$asDSObjName="FK"+$asDSObjName;
		$otherDsIsDriver=1;
		}
	}

//run asUpdatePoseAttributes, as we might have `dud` cmds, due to manually deleted drivingSystems
asUpdatePoseAttributes;

//Find driven attribute(s)
//get $buildPoseCmds
if (`objExists ControlSet`)
	{
	$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
	if (`attributeExists udExtraAttr buildPose`) $buildPoseCmds[0]=$buildPoseCmds[0]+`getAttr buildPose.udExtraAttr`;
	}
if (`objExists FaceControlSet`)
	{
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
	if (`attributeExists udExtraAttr faceBuildPose`) $buildPoseCmds[0]=$buildPoseCmds[0]+`getAttr faceBuildPose.udExtraAttr`;
	}
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}

for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<size($buildPoseCmds);$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;

		if (`gmatch $tempString[$i] "*FKIK*"`)//filter FKIK* as this might be just to get to FK.
			continue;
//		if (`gmatch $tempString[$i] "*_L[.]*"` || `gmatch $tempString[$i] "*_L*"`)
//			continue;
//				error ("Found modified values on the Left side ("+$checkObjAttr[$z]+"), Only modify Right side (or middle)");
		if (`gmatch $tempString[$i] "*Extra*[.]*"`)
			continue;
//				error ("Found modified values on the Extra controller, Only modify the Main controllers");

		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			tokenize $objAttr "." $tempString3;
			$obj=$tempString3[0];
			$attr=$tempString3[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;//default 15=trs
			if (size($tempString2)==11) $loopTimes=6;//11=tr
			if (size($tempString2)==7) $loopTimes=3;//7=t
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";
			$checkObjAttr[1]=$obj+".translateY";
			$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
//			$poseValue=0; // incorrect for non-zero IkLocal
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if ($loopTimes>1)
				{
				if ($z==0) $poseValue=$tempString2[3];//tx
				if ($z==1) $poseValue=$tempString2[4];//ty
				if ($z==2) $poseValue=$tempString2[5];//tz
				if ($z==3 && $tempString2[7]!="") $poseValue=$tempString2[7];//rx (not always in the xform cmd)
				if ($z==4 && $tempString2[8]!="") $poseValue=$tempString2[8];//rx (not always in the xform cmd)
				if ($z==5 && $tempString2[9]!="") $poseValue=$tempString2[9];//rx (not always in the xform cmd)
				if($z>5) $poseValue=1;//scale not always in the xform cmd
				}

			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				{
				if (`gmatch $checkObjAttr[$z] "*_L*"`)
					$asDSDisableMirror=1;

				if ($skipY && `gmatch $checkObjAttr[$z] "*[.]ty"`)
					;
				else if ($skipX && `gmatch $checkObjAttr[$z] "*[.]tx"`)
					;
				else if ($skipZ && `gmatch $checkObjAttr[$z] "*[.]tz"`)
					;
				else
					{
					$drivens[size($drivens)]=$checkObjAttr[$z];
					if (!`stringArrayCount $obj $drivenObjs`)
						$drivenObjs[size($drivenObjs)]=$obj;
					}
				}
			}
		}
	}

if (!$isEditingExisting)
	if (size($drivens)==0)
		error ("Found no driven attributes, all controls are in Build-Pose");

$buildPoseNode="buildPose";
$allSet="AllSet";
if (`objExists FaceControlSet`)
	if ((`objExists $drivenObjs[0]` && `sets -im FaceControlSet $drivenObjs[0]`) || (`objExists $controllerName` && `sets -im FaceControlSet $controllerName`))
		{//complex check, since $drivenObjs[0] does not exist when `deleting` last SDK by editing values to zero 
		$isFace=1;
		$buildPoseNode="faceBuildPose";
		$allSet="FaceAllSet";
		}

$allDrivensMiddle=1;
for ($i=0;$i<size($drivens);$i++)
	if (`gmatch $drivens[$i] "*_R[.]*"` || `gmatch $drivens[$i] "*_L[.]*"`)
		$allDrivensMiddle=0;
if ($allDrivensMiddle)
	$asDSDisableMirror=1;

$m="Create system to drive these attributes?\n\n";
for ($i=0;$i<size($drivens);$i++)
	{
	float $value=`getAttr $drivens[$i]`;
	$value=`asRoundOff $value 3`;
	$t="Create New";
	$m+=$drivens[$i]+" = "+$value+"\n";
	if (`gmatch $drivens[$i] "SmilePull_*"`)
		error ("SmilePull controller found in pose, This controller can not be Driven.Make sure the SmilePull controllers are set to zero");
	}

$asDSMessage=$m;

if (!$comeFromASBuild && !$isEditingExisting)
	{
	$dialogResult=`layoutDialog -t $t -ui asDsLayout`;
	if ($dialogResult!="OK")
		return;
	}

//"drive from selected object" option, so remove driver from $drivens
if (`stringArrayCount ($asDSObjName+"."+$asDSAttrName) $drivens`)
	{
	$drivens=`stringArrayRemove {$asDSObjName+"."+$asDSAttrName} $drivens`;
	$driverValue=`getAttr ($asDSObjName+"."+$asDSAttrName)`;
	$driverValue=`asRoundOff $driverValue 3`;
	setAttr ($asDSObjName+"."+$asDSAttrName) 0;
	//not for existing `standard` DrivingSystems
	$tempString=`listRelatives -p $asDSObjName`;
	$parent=$tempString[0];
	if ($parent!="DrivingSystem")
		$otherDsIsDriver=1;
	if (!size($drivens))
		error "Empty list of Driven Objects";
	}
//with "testAnimation==Off", FKElbow_R.rotateY could be in $drivens list for FKElbow_R.angleY drive
$tempString[0]=`substitute "angle" $asDSAttrName "rotate"`;
if (`stringArrayCount ($asDSObjName+"."+$tempString[0]) $drivens`)
	$drivens=`stringArrayRemove {$asDSObjName+"."+$tempString[0]} $drivens`;

$side="_R";
$controllerSide="_R";
for ($b=1;$b>-2;$b=$b-2)
	{
	$attrName=$asDSAttrName;
	if ($b==-1 && `gmatch $asDSAttrName "*Right"`)//ctrlARKit_M
		$attrName=`substitute "Right" $attrName "Left"`;

	if ($b==-1 && !$asDSMirror)
		continue;
	if ($b==-1 && $allDrivensMiddle)
		continue;

	if      ($b==-1 && $side=="_R") {$side="_L";$oppositeSide="_R";}
	else if ($b==-1 && $side=="_L") {$side="_R";$oppositeSide="_L";}
	if      ($b==-1 && `gmatch $attrName "*Right"`) {$side="_L";$oppositeSide="_R";}//ctrlARKit_M
	else if ($b==-1 && `gmatch $attrName "*Left"`)  {$side="_L";$oppositeSide="_R";}//ctrlARKit_M

	$controllerSide=$side;
	if ($allDrivensMiddle)
		$controllerSide="_M";

	for ($i=0;$i<size($drivenObjs);$i++)
		if ($b==-1)
			{
			$drivenObjs[$i]=`substitute $oppositeSide $drivenObjs[$i] $side`;
			if (!`objExists $drivenObjs[$i]`)
				{
				print ("// \""+$drivenObjs[$i]+"\" not found, skipping mirroring.\n");
				$breakSideLoop=1;
				}
			}
	if ($breakSideLoop)
		continue;
	for ($i=0;$i<size($drivens);$i++)
		if ($b==-1)
			$drivens[$i]=`substitute $oppositeSide $drivens[$i] $side`;

	$controllerName=$asDSObjName;
	if (!`gmatch $controllerName "*_[A-Z]"` && !`gmatch $controllerName "*_R_*"` && !`gmatch $controllerName "*_L_*"` && !`gmatch $controllerName "*_C_*"`)
		$controllerName+=$controllerSide;
	if ($asDSObjName=="")
		for ($y=1;$y<99;$y++)
			{
			$controllerName="DrivingSystem"+$y+$controllerSide;
			if (!`objExists $controllerName`)
				break;
			}

	if (`objExists $controllerName`) //use-existing-Control
		{
		$useExistingController=1;
		if ($b==-1)
			{
			$controllerName=`substitute $oppositeSide $controllerName $controllerSide`;
			if (!`objExists $controllerName`)
				break;
			}
		}
	else
		asDsCreateController $controllerName $drivenObjs;

	if ($attrName=="")
		for ($y=1;$y<99;$y++)
			{
			$attrName="driver"+$y;
			if (!`attributeExists $attrName $controllerName`)
				break;
			}

	if ($b==1)
		{
		$originalSideControllerName=$controllerName;
		$originalSideAttrName=$attrName;
		}

	if (!`attributeExists $attrName $controllerName`)
		{
		addAttr -k 1 -ln $attrName -at double $controllerName;
		if ($asDSAttrHasMin && $asDSAttrSoftLimits)
			addAttr -e -hasSoftMinValue 1 -softMinValue $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMin && !$asDSAttrSoftLimits)
			addAttr -e -min $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && $asDSAttrSoftLimits)
			addAttr -e -hasSoftMaxValue 1 -softMaxValue $asDSAttrMax ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && !$asDSAttrSoftLimits)
			addAttr -e -max $asDSAttrMax ($controllerName+"."+$attrName);
		}
	else
		{
		$attrType=`getAttr -type ($controllerName+"."+$attrName)`;
		if (!`gmatch $attrType "double*"`)//not to set limits on xform attrs
			{
			if ($driverValue<0)
				addAttr -e -softMinValue $driverValue ($controllerName+"."+$attrName);
			else if ($driverValue>10)
				addAttr -e -softMaxValue $driverValue ($controllerName+"."+$attrName);
			}
		}

	if ($otherDsIsDriver)
		{
		if (`gmatch $controllerName "FK*"`)
			$controllerName=`substitute "FK" $controllerName ""`;
		if ($asDSAngle)
			{
			$attrName=`substitute "rotate" $attrName "angle"`;
			if (!`attributeExists $attrName $controllerName`)
				asCreateAngleAttrs $controllerName;
			//find new $driverValue in angle-values
			if ($b==1)
				{
				//Max 90 degrees
				if (abs($driverValue)>90)
					{
					warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
					if ($driverValue>0) $driverValue=90;
					if ($driverValue<0) $driverValue=-90;
					}
				setAttr ($asDSObjName+"."+`substitute "angle" $attrName "rotate"`) $driverValue;
				$driverValue=`getAttr ($asDSObjName+"."+$attrName)`;
				$driverValue=`asRoundOff $driverValue 3`;
				setAttr ($asDSObjName+"."+`substitute "angle" $attrName "rotate"`) 0;
				}
			}
		else
			$attrName=`asOPMCompatibleDriverAttr $controllerName $asDSAttrName`;			
		}

	asEnsureOutputBlendWeighted ($controllerName+"."+$attrName);

	//remove OutputBlendWeighted from AllSet if $otherDsIsDriver, so ReBuilding will work with driven CustomControllers
	if ($otherDsIsDriver && $isFace && `objExists ("bw"+$controllerName+"_"+$attrName)` && `objExists FaceAllSet`)
		sets -rm FaceAllSet ("bw"+$controllerName+"_"+$attrName);
	if ($otherDsIsDriver && !$isFace && `objExists ("bw"+$controllerName+"_"+$attrName)` && `objExists AllSet`)
		sets -rm AllSet ("bw"+$controllerName+"_"+$attrName);

	$blendedAttr=`asFaceIsBlendedAttr $controllerName $attrName`;

	for ($i=0;$i<size($drivens);$i++)
		{
		tokenize $drivens[$i] "[.]" $tempString;
		$drivenAttr=$tempString[1];
		$drivenObj=$tempString[0];

		$connectionAttrNames[$i]=$attrName;

		if ($b==-1 && !`gmatch $drivenObj "*_L"`&& !`gmatch $drivenAttr "*Side"`)
			continue;

		tokenize $drivenObj "_" $tempString;
		if (`gmatch $drivenObj "SDK*"`)
			$realDrivenObj[$i]=$drivenObj;
		else if (`objExists ("SDK"+$drivenObj)` && `attributeExists $drivenAttr ("SDK"+$drivenObj)`)// not use SDK for custom attr
			$realDrivenObj[$i]="SDK"+$drivenObj;
		else
			{
			//bw
			$bwInputAttr="";
			$tempString=`listConnections -s 0 -d 1 -type blendWeighted ($drivenObj+"."+$drivenAttr)`;
			$SDKDrivenBW=$tempString[0];
			$tempString=`listConnections -s 0 -d 1 -type blendWeighted ($controllerName+"."+$attrName)`;
			$SDKDrivingBW=$tempString[0];
			if ($SDKDrivenBW!="")
				{
				$tempString =`listConnections -s 1 -d 0 -type animCurve ($SDKDrivenBW+".input")`;
				$tempString2=`listConnections -s 0 -d 1 -type animCurve ($SDKDrivingBW+".output")`;
				$bwInputAttr="";
				for ($y=0;$y<size($tempString);$y++)
					if (`stringArrayCount $tempString[$y] $tempString2`)
						{
						$tempString3=`listConnections -s 0 -d 1 -p 1 -type blendWeighted ($tempString[$y]+".output")`;
						tokenize $tempString3[0] "." $tempString4;
						$bwInputAttr=$tempString4[1];
//print ("$bwInputAttr="+$bwInputAttr+", because:"+$tempString[$y]+" also found to be connected to"+$SDKDrivingBW+".output\n");
						}
				$realDrivenObj[$i]=$SDKDrivenBW;
				if ($bwInputAttr=="")//Unable to find $bwInputAttr, so we take nextAvailable
					$bwInputAttr="input["+`getAttr -s ($realDrivenObj[$i]+".input")`+"]";
//				error ("Unable to find $bwInputAttr for \""+$realDrivenObj[$i]+"\"");
				}
			}

		if (`gmatch $realDrivenObj[$i] "bw*"`)
			$sdkDrivens[$i]=$realDrivenObj[$i]+"."+$bwInputAttr;
		else
			{
			$sdkDrivens[$i]=$realDrivenObj[$i]+"."+$drivenAttr;
			if (!`objExists ("SDK"+$drivenObj)`)//first attr in new obj
				asDsCreateSDKXform $drivenObj;
			$sdkDrivens[$i]="SDK"+$drivenObj+"."+$drivenAttr;
			//also remove SDKXform from AllSet if $otherDsIsDriver
			if ($otherDsIsDriver && `objExists $allSet`)
				{
				sets -rm $allSet ("SDK"+$drivenObj);
				if (`objExists ("SDK"+$drivenObj+"ScaleMPD")`)
					sets -rm $allSet ("SDK"+$drivenObj+"ScaleMPD");
				}
			}

		$drivenValues[$i]=`getAttr $drivens[$i]`;
		}

	if ($isEditingExisting && $isFace)//store _tweaked info
		{
		if (!`objExists FaceSetupEditHistory`)
			{
			createNode -n FaceSetupEditHistory -p ControlsSetup transform;
			sets -add FaceAllSet FaceSetupEditHistory;
			}
		$tweakedAttrName=$controllerName+"_"+$attrName+"_tweaked";
		if (!`attributeExists $tweakedAttrName FaceSetupEditHistory`)
			addAttr -k 0 -dv 1 -ln $tweakedAttrName -at bool FaceSetupEditHistory;
		}

	if ($b==-1)	//use asMirror to get mirrorValues
		{
		$restorePoseCmd=`asGetRestorePoseCmd`;
		if (`window -q -ex tempWindow`)
			deleteUI tempWindow;
		window tempWindow;
		columnLayout;
		optionMenu tempWindowOptionMenu;
			menuItem -l ":";
		text -l "ControlSet " tempWindowControlSetsText;
		optionVar -sv asMOSide "asMOSideR2L";
		optionVar -sv asMOSpace "asMOSpaceMain";
		optionVar -sv asMOAxis "asMOAxisX";
		optionVar -sv asMOSelOnly "asMOSelOnlyAll";
		if ($isFace)
			text -e -l "FaceControlSet " tempWindowControlSetsText;
		asMirror tempWindow;
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;
		deleteUI tempWindow;
		eval($restorePoseCmd);
		}

	for ($i=0;$i<size($sdkDrivens);$i++)
		{
		$inLoopDriveValue=$driverValue;
		//If a side Ctrl is driving a center Ctrl (e.g. ctrlBrow_R driving EyeBrowCenter_M), then Half the value
		if (`gmatch $drivens[$i] "*_M[.]*"` && (`gmatch $controllerName "*_R"` || `gmatch $controllerName "*_L"`))
			if (!`gmatch $drivens[$i] "*[.]s[x-z]"` || `gmatch $drivens[$i] "*[.]scale[X-Z]"`)//not for scale
				if (!$allDrivensMiddle)//not when $allDrivensMiddle and NoMirror. e.g. simple prop with simple Center DS
					$drivenValues[$i]=$drivenValues[$i]/2.0;

		//special case for *Side attr e.g. ctrlMouth_M.jawSide to reverse value
		if ($b==-1 && $isFace && `gmatch $drivens[$i] "*[.]*Side"`)
			$drivenValues[$i]=$drivenValues[$i]*-1;

		//special case for ctrlLips_M.tx
		if ($b==-1 && $asDSObjName=="ctrlLips_M" && $asDSAttrName=="translateX" && !`gmatch $sdkDrivens[$i] "*_M[.]*"`)
			$inLoopDriveValue=$driverValue*-1;

		//Special case, eyes are no-flipped, and might have different values looking Left vs Right
		if ($drivens[$i]=="Eye_L.ry" && `objExists SDKEye_R_rotateY`)
			{
			$keyXValues=`keyframe -q -fc SDKEye_R_rotateY`;
			$keyYValues=`keyframe -q -vc SDKEye_R_rotateY`;
			if ($keyXValues[0]==-1)//as v5.866 or later 
				{
				print ("// Non-mirroed controller detected (Eye), Swapping driver-value from:"+$driverValue+" to :");
				$inLoopDriveValue=$driverValue*-1;
				$drivenValues[$i]=$drivenValues[$i]*-1;
				print ($driverValue+".\n");
				}
			}

		asEnsureBlendWeighted $sdkDrivens[$i];
		$driveSource=$controllerName+"."+$connectionAttrNames[$i];
		$bw="bw"+$controllerName+"_"+$connectionAttrNames[$i];	
		if (`objExists $bw`)
			$driveSource=$bw+".output";
		//change to setAttr, then SDK without spesify values, as this auto-resolves values for multi-drivers of scale
		//..that causes other issues, e.g. Emotions_M.sad driving both ctrlBrow_R & EyeBrowInner_R, so changing this back.
		//..unless driven is scale
		if (`gmatch $sdkDrivens[$i] "*[.]s[x-z]"` || `gmatch $sdkDrivens[$i] "*[.]scale[X-Z]"`)
			{
			setAttr $driveSource $driverValue;
			setAttr $sdkDrivens[$i] $drivenValues[$i];
			setDrivenKeyframe -itt "linear" -ott "linear" -cd $driveSource $sdkDrivens[$i];
			}
		else
			setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValues[$i] -dv $inLoopDriveValue -cd $driveSource $sdkDrivens[$i];
//print ("setDrivenKeyframe -itt linear -ott linear -v "+$drivenValues[$i]+" -dv "+$inLoopDriveValue+" -cd "+$driveSource+" "+$sdkDrivens[$i]+";\n");
		}

	//then set the "Start" SDK keyframe
	$restorePoseCmd=`asGetRestorePoseCmd`;
	if ($isFace)
		asGoToBuildPose faceSetup;
	else
		asGoToBuildPose bodySetup;

	for ($i=0;$i<size($sdkDrivens);$i++)
		{
		$defaultValue=`getAttr $drivens[$i]`;
		if (`gmatch $drivens[$i] "SDK*"`)
			{
			$tempString[0]=`substitute "SDK" $drivens[$i] ""`;
			$defaultValue=`getAttr $tempString[0]`;
			}
		$driveSource=$controllerName+"."+$connectionAttrNames[$i];
		$bw="bw"+$controllerName+"_"+$connectionAttrNames[$i];	
		if (`objExists $bw`)
			$driveSource=$bw+".output";
//		$defaultValue=`asEnsureCorrectMultiDriverScaleValue $defaultValue $driveSource $sdkDrivens[$i]`;
//		setDrivenKeyframe -itt "linear" -ott "linear" -v $defaultValue -dv 0 -cd $driveSource $sdkDrivens[$i];
		setAttr $driveSource 0;
		setAttr $sdkDrivens[$i] $defaultValue;
		setDrivenKeyframe -itt "linear" -ott "linear" -cd $driveSource $sdkDrivens[$i];
		}
	for ($i=0;$i<size($sdkDrivens);$i++)
		setInfinity -pri cycleRelative -poi cycleRelative $sdkDrivens[$i];
	eval($restorePoseCmd);

//	if (!$blendedAttr && !$isEditingExisting && !$useExistingController)//!$useExistingController was added in 5.799. but should be $otherDsIsDriver
	if (!$blendedAttr && !$isEditingExisting && !$otherDsIsDriver)
		setAttr -type "string" ($buildPoseNode+".udAttr") (`getAttr ($buildPoseNode+".udAttr")`+";setAttr "+$controllerName+"."+$attrName+" 0;");
	}

asEnsureSDKcurvesNamed;

//Check if any existing SDK has been `zero`d out, then remove the SDK curve
//To find a better solution for this, because currently this breaks ctrlMouth_M
$tempString=`listConnections -s 0 -d 1 -scn 1 -type animCurve ($originalSideControllerName+"."+$originalSideAttrName)`;
if (`objExists ("bw"+$originalSideControllerName+"_"+$originalSideAttrName)`)
	$tempString=`listConnections -s 0 -d 1 -scn 1 -type animCurve ("bw"+$originalSideControllerName+"_"+$originalSideAttrName+".output")`;
for ($i=0;$i<size($tempString);$i++)
	{
	$animCurve=$tempString[$i];
	tokenize $animCurve "_" $tempString2;
	if (`gmatch $tempString2[0] "SDK*"`)
		$ctrl=`substring $tempString2[0] 4 99`+"_"+$tempString2[1];
	else if (`gmatch $tempString2[0] "bw*"`)
		$ctrl=`substring $tempString2[0] 3 99`+"_"+$tempString2[1];
	if (!`objExists $ctrl`)
		continue;
	if (`gmatch $ctrl "*_L"`)
		continue;	
	$inControlSet=$inFaceControlSet=0;
	if (`objExists ControlSet`) if (`sets -im ControlSet $ctrl`) $inControlSet=1;
	if (`objExists FaceControlSet`) if (`sets -im FaceControlSet $ctrl`) $inFaceControlSet=1;
	if (!$inControlSet && !$inFaceControlSet)
		continue;
	$att=$tempString2[2];
	while (`gmatch $att "*[0-9]"`)
		{
		$numChar=size($att);
		$att=`substring $att 1 ($numChar-1)`;
		}
	$currentValue=`getAttr ($ctrl+"."+$att)`;
	if (`attributeExists $att $ctrl`)
		if (((`gmatch $att "scale[X-Z]"` || `gmatch $att "s[x-z]"`) && `getAttr ($ctrl+"."+$att)`==1) || `getAttr ($ctrl+"."+$att)`==0)//1 for scale, 0 for trans/rot
		//all other keys on curve must be zero as well, otherwice we migh remove a -1 driven valid key
		//Note removing Scale curves, should be auto-updating the `asEnsureCorrectMultiDriverScaleValue` to ensure sum of 1, not yet implemented
			{
			$keyXValues=`keyframe -q -fc $animCurve`;

			for ($y=0;$y<size($keyXValues);$y++)
				if ($keyXValues[$y]==$driverValue)
					{
					if ($skipX || $skipY)
						continue;
					print ("// Found value of Zero, on \""+$ctrl+"."+$att+"\" , now removing this Key ("+$keyXValues[$y]+")\n");
//print ("selectKey -add -k -f "+$driverValue+" "+$animCurve+";\n");
					selectKey -add -k -f $driverValue $animCurve;
					cutKey -animation keys -clear ;
					//and the Mirrored SDK
					$mirroredAnimCurve=`asDsGetMirroredAnimCurve $animCurve`;
					if (`objExists $mirroredAnimCurve` && $mirroredAnimCurve!=$animCurve)
						{
//print ("selectKey -add -k -f "+$driverValue+" "+$mirroredAnimCurve+";\n");
						selectKey -add -k -f $driverValue $mirroredAnimCurve;
						cutKey -animation keys -clear ;
						}

					if (size($keyXValues)<3)// only 2 keys, delete the whole animCurve node
						{
						print ("// Found value of Zero, on \""+$ctrl+"."+$att+"\" , now removing this SDK\n");
						delete $animCurve;
						//and the Mirrored SDK
						if (`objExists $mirroredAnimCurve` && $mirroredAnimCurve!=$animCurve)
							delete $mirroredAnimCurve;
						}
					}
			}
	}

select -cl;

if ($isFace)
	asGoToBuildPose faceSetup;
else
	asGoToBuildPose bodySetup;

if (!$useExistingController)
	asDsOptimizeControllers;

select -cl;
if ($isEditingExisting)
	print ("// Edited DrivingSystem "+$originalSideControllerName+"."+$originalSideAttrName+";\n");
else if (!$comeFromASBuild)
	print ("// Created DrivingSystem "+$originalSideControllerName+"."+$originalSideAttrName+";\n");

if (!$asBuilding && !$asRebuilding)
	{
	asDsToFitSkeleton;
	asUpdateButtonEnables;//could be 1st DS for the rig
	}
}

global proc asDsAutoFindAndEdit ()
{
float $value,$driveValue;
string $drivingSystem,$driveAttr,$leftDrivingSystem;
string $attrs[];
string $drivingSystems[]=`asDsGetDrivingSystems`;

asVersionRequirementCheck face 5.732;
asVersionRequirementCheck body 5.732;

for ($i=0;$i<size($drivingSystems);$i++)
	{
	$attrs=`asDsGetAttrs $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		$value=`getAttr ($drivingSystems[$i]+"."+$attrs[$y])`;
		$value=`asRoundOff $value 3`;

		//Ignore blendedAttribs, if the blendSource is 0, as the blendedAttrib may be non-zero, due to bw-driving. e.g. Happy drives mouthCnrX&Y via bw
		if (`gmatch $attrs[$y] "*tx*_ty*"` && `getAttr ($drivingSystems[$i]+".tx")`==0 && `getAttr ($drivingSystems[$i]+".ty")`==0)
			continue;

		//Ignore blendedAttribs that are 0.5 as the new DS blends-in attrs more soft
		if (`gmatch $attrs[$y] "*tx*_ty*"` && ($value==0.5 || $value==-0.5))
			continue;

		//Ignore tx & ty for ctrlMouthCorner
		if (`gmatch $drivingSystems[$i] "ctrlMouthCorner_*"` && `gmatch $attrs[$y] "translate[A-Z]"`)
			continue;

		//Ignore smile/frown, if x & y are zero, as this means other DS driving these, e.g. ctrlEmotions_M.happy drives smile
		if (`gmatch $drivingSystems[$i] "ctrlMouthCorner_*"` && `getAttr ($drivingSystems[$i]+".tx")`==0 && `getAttr ($drivingSystems[$i]+".ty")`==0)
			continue;

		if ($value!=0)
			{
			if (`gmatch $drivingSystems[$i] "*_L"` || `gmatch $attrs[$y] "*Left"`)
				if ($attrs[$y]!="mouthLeft" && $attrs[$y]!="jawLeft") //special case, Center controller that `goes` sideways
					error ("Found modified values on the Left side ("+$drivingSystems[$i]+"."+$attrs[$y]+"), Only modify Right side (or middle)");
// No longer error, just set the Left to zero, since e.g. ctrlEmotions_M.happy drives Left ctrlMouthCorner as well
			if ($drivingSystem!="")
				{
				//Adding BlendedAttribute ?
				if ($drivingSystem==$drivingSystems[$i] && $driveAttr=="translateX" && $attrs[$y]=="translateY")
					{
					//BlendedAttribute removed for now. will try to bring this back in a better way
					if (!`gmatch $drivingSystem "ctrlMouthCorner_*"`)
						error "Editing Blended Driving Attributes is currently not available for this controller. Only apply translate X or Y";

					$attrs[$y]=`asGetBlendedAttributeName {$drivingSystems[$i]+".tx",$drivingSystems[$i]+".ty"}`;
					addAttr -k 0 -ln $attrs[$y] -at double -dv 1 $drivingSystems[$i];
	/*
					if (!`attributeExists $attrs[$y] $drivingSystems[$i]`)
						{
						if (`confirmDialog -t "Multiple drivers found"
							-m "Create Blended Attribute from TX And TY ?"
							-b "OK" -b "Cancel" -db "Cancel"
							-ds "Cancel"`!="OK")
								return;
						$attrs[$y]=`asCreateBlendedAttribute {$drivingSystems[$i]+".tx",$drivingSystems[$i]+".ty"}`;
						}
*/
					if (`objExists BlendedCorrectiveDriver`) delete BlendedCorrectiveDriver;
					if (`gmatch $drivingSystems[$i] "*_R"`)
						{
						//Add to Left side as well
						$leftDrivingSystem=`substitute "_R" $drivingSystems[$i] "_L"`;
						setAttr ($leftDrivingSystem+".tx") `getAttr ($drivingSystems[$i]+".tx")`;
						setAttr ($leftDrivingSystem+".ty") `getAttr ($drivingSystems[$i]+".ty")`;
//						addAttr -k 0 -ln $attrs[$y] -at double -dv 0 $leftDrivingSystem;
//						asCreateBlendedAttribute {$leftDrivingSystem+".tx",$leftDrivingSystem+".ty"};
						if (`objExists BlendedCorrectiveDriver`) delete BlendedCorrectiveDriver;
						setAttr ($leftDrivingSystem+".tx") 0;
						setAttr ($leftDrivingSystem+".ty") 0;
						}
					$value=1;
					}
				else if (`gmatch $drivingSystem "ctrlMouthCorner_*"`)
					error ("ctrlMouthCorner must be set to one of the Corners, in order to Edit the DrivingSystem");
				else
					error ("Found multiple driver values set: "+$drivingSystem+"."+$driveAttr+" AND "+$drivingSystems[$i]+"."+$attrs[$y]);
				}
			$drivingSystem=$drivingSystems[$i];
			$driveAttr=$attrs[$y];
			$driveValue=$value;
			if ($drivingSystem=="ctrlMouth_M" && $driveAttr=="translateX")
				error ("ctrlMouth_M.translateX can not be Edited, instead Edit the ctrlMouthCorner attributes");
			if (`gmatch $driveAttr "*_*"` && !`getAttr -se ($drivingSystem+"."+$driveAttr)`)//BlendedAttribute, assuming other attribs are just contributing to this.
				break;
			}
		}
	}

if ($drivingSystem=="")
	warning "Either right click on this button to edit specific drive-values, or set a driver-value, and click the button";
else
	asDsEdit "Edit" $drivingSystem $driveAttr $driveValue;

select -cl;
}

global proc asDsEdit (string $action, string $obj, string $attr, float $value)
{
int $testAnim=`checkBox -q -v asDsTestAnimCheckBox`;
int $testSym=`checkBox -q -v asDsTestSymCheckBox`;
int $showOnlyAffected=`checkBox -q -v asDsShowOnlyAffectedCheckBox`;
int $numDriven,$blendedAttr,$numChar,$isFace,$otherDsIsDriver,$numUnderS,$flip,$isClusterControl,$isClusterLocalOrientControl;
int $colorNr=16;
float $driver1Value,$driver2Value,$startValue;
float $drivenValues[],$limits[];
string $stripName,$restoreParentCmd,$mpd,$setRange,$driver1Attr,$driver2Attr,$sideLess,$setAttrCmd,$bw,$destAttr,$fkObjAttr;
string $drivingAttr=$attr;
string $sel[]=`ls -sl`;
string $drivenObjs[],$drivenAttrs[],$drivenSdkNode[],$allKeyableAttrs[];
string $animCurves[],$sortedAnimCurves[],$tempString[],$tempString2[],$tempString3[],$controls[],$connectedNodes[],$nextConnectedNodes[];

if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $obj`)
		$isFace=1;

//could be coming straight from Edit DS mode
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	headsUpDisplay -e -rem HUDEDSMode;
	displayColor headsUpDisplayLabels 16;
	}
asDsRemoveTestAnimation;
if (`objExists EditingDrivingSystem`) delete EditingDrivingSystem;
if (`objExists TestSymmetry`) delete TestSymmetry;

if ($isFace)
	asVersionRequirementCheck face 5.732;
else
	asVersionRequirementCheck body 5.732;

	$blendedAttr=`asFaceIsBlendedAttr $obj $attr`;

//swap ctrlMouth_M.tx to ctrlMouthCorner_R.tx
if ($obj=="ctrlMouth_M" && $attr=="tx")
	$obj="ctrlMouthCorner_R";
//	error ("// Can not set DrivingSystem from ctrlMouth_M.tx, use ctrlMouthCorner_R.tx instead.\n");

$tempString=`ls -l $obj`;
if (!`gmatch $tempString[0] "*|DrivingSystem|*"`)
if (!$isFace && !`gmatch $tempString[0] "*|DrivingSystem|*"`)//standard ctrl is driver
	$otherDsIsDriver=1;

if ($blendedAttr)//BlendedAttribute
	{
	$driver1Attr="translateX";
	$driver2Attr="translateY";
	$driver1Value=1;
	$driver2Value=1;
	if (`gmatch $attr "*txNeg*"`) $driver1Value=-1;
	if (`gmatch $attr "*tyNeg*"`) $driver2Value=-1;
	if ($attr=="smile") {$driver1Value=1;$driver2Value=1;}
	if ($attr=="frown") {$driver1Value=1;$driver2Value=-1;}
	if ($attr=="narrowSmile") {$driver1Value=-1;$driver2Value=1;}
	if ($attr=="narrowFrown") {$driver1Value=-1;$driver2Value=-1;}
	}

if ($action!="Graph")
	{
	if (`objExists ControlSet`) asGoToBuildPose bodySetup;
	if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;
	}

$animCurves=`asDsGetAnimCurves $obj $drivingAttr`;

if ($action=="Edit")
	{
	if (`gmatch $attr "angle*"`)//single angles (not blended angles)
		asSetRotationFromAngle ("FK"+$obj) $attr $value;
	else if (!$blendedAttr)
		{
		if (`gmatch $attr "opm*"`)
			setAttr ("FK"+$obj+"."+`substitute "opm" $attr ""`) $value;
		else
			setAttr ($obj+"."+$attr) $value;
		}
	else
		{
		setAttr ($obj+"."+$driver1Attr) $driver1Value;
		setAttr ($obj+"."+$driver2Attr) $driver2Value;
		$tempString2=`asDsGetAnimCurves $obj $driver1Attr`;
		$animCurves=`stringArrayCatenate $animCurves $tempString2`;
		$tempString2=`asDsGetAnimCurves $obj $driver2Attr`;
		$animCurves=`stringArrayCatenate $animCurves $tempString2`;
		}

	if (`attributeQuery -n $obj -softRangeExists $attr`)
		$limits=`attributeQuery -n $obj -softRange $attr`;
	else if ($attr=="tx" || $attr=="ty" ||$attr=="tz")
		$limits=`eval ("transformLimits -q -"+$attr+" "+$obj)`;
	else if ($attr=="translateX") $limits=`eval ("transformLimits -q -tx "+$obj)`;
	else if ($attr=="translateY") $limits=`eval ("transformLimits -q -ty "+$obj)`;
	else if ($attr=="translateZ") $limits=`eval ("transformLimits -q -tz "+$obj)`;
//	else if (`gmatch $attr "tx*_ty*"`)
	else if ($blendedAttr)
		$limits={0,1};
	if ($otherDsIsDriver)
		$limits=`asDSGetDriverMinMax $obj $attr`;
	if (!`gmatch $attr "angle*"`)
		{
		if ($value>0 && $value!=$limits[1]) $colorNr=13;
		if ($value<0 && $value!=$limits[0]) $colorNr=13;
		}
	}

//sorting $animCurves, as ctrl can be both direct and in-direct driven ) e.g Phoneme drive both ctrl + CtrlBox that also drives same ctrl
//sort ctrlBox ctrls to come first
for ($i=0;$i<size($animCurves);$i++)
	if (`gmatch $animCurves[$i] "bwctrl*"`)
		$sortedAnimCurves[size($sortedAnimCurves)]=$animCurves[$i];
for ($i=0;$i<size($animCurves);$i++)
	if (!`stringArrayCount $animCurves[$i] $sortedAnimCurves`)
		$sortedAnimCurves[size($sortedAnimCurves)]=$animCurves[$i];

for ($i=0;$i<size($sortedAnimCurves);$i++)
	if (size(`ls -type animCurve $sortedAnimCurves[$i]`))	
		{
		tokenize $sortedAnimCurves[$i] "_" $tempString2;
		$drivenSdkNode[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+"_";
			}

		if (`gmatch $sortedAnimCurves[$i] "SDK*"`) $stripName=`substring $sortedAnimCurves[$i] 4 99`;
		if (`gmatch $sortedAnimCurves[$i] "bw*"`)  $stripName=`substring $sortedAnimCurves[$i] 3 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		tokenize $stripName "_" $tempString2;
		$drivenObjs[$numDriven]="";
		$numUnderS=1;
		if (`gmatch $sortedAnimCurves[$i] "bw*"`) $numUnderS=3;
			for ($y=0;$y<size($tempString2)-$numUnderS;$y++)
				{
				$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+$tempString2[$y];
				if ($y<size($tempString2)-($numUnderS+1))
					$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+"_";
				}
		string $drivenAttr=$tempString2[size($tempString2)-$numUnderS];
		for ($a=0;$a<3;$a++)
			if (`gmatch $drivenAttr "*[0-9]"`)
				{
				$numChars=size($drivenAttr);
				$drivenAttr=`substring $drivenAttr 1 ($numChars-1)`;
				}
		$drivenAttrs[$numDriven]=$drivenAttr;
		//Changed, tince there can be multiple drivers (direct+indirect), so current attrValue might not be correct drivenValue
		$drivenValues[$numDriven]=`getAttr ($sortedAnimCurves[$i]+".output")`;
		//if `bw` exists, use that value instead, as it is pre-djusted to allow for scale-ds
		$tempString=`listConnections -s 0 -d 1 -type blendWeighted ($sortedAnimCurves[$i]+".output")`;
		if ($tempString[0]!="")
			$drivenValues[$numDriven]=`getAttr ($tempString[0]+".output")`;
		//special case when blending multiple scale values
		//When blending Scales, all SDK`s except the first one, needs value of 1 removed, unless its just adding a key to existing sdk
		//Here we should be restoring the value of 1 when Editing the DS (not yet implemented)
//		if (!`gmatch $drivenAttr "*[.]s[x-z]"` || `gmatch $drivenAttr "*[.]scale[X-Z]"`)//not for scale
//			$drivenValues[$numDriven]=$drivenValues[$numDriven]+1;
//print ($sortedAnimCurves[$i]+" : "+$drivenObjs[$numDriven]+" : "+$drivenAttrs[$numDriven]+" : "+$drivenValues[$numDriven]+"\n");
		$numDriven++;
		}

if ($action=="Graph")
	{
	select -cl;
	$connectedNodes=`listConnections -s 0 -d 1 -scn 1 -type blendWeighted ($obj+"."+$drivingAttr)`;
	while (size($connectedNodes))
		{
		clear $nextConnectedNodes;
		for ($i=0;$i<size($connectedNodes);$i++)
			{
			if (`objectType $connectedNodes[$i]`=="transform")
				select -add $connectedNodes[$i];
			$tempString=`listConnections -s 0 -d 1 -scn 1 -type blendWeighted $connectedNodes[$i]`;
			$tempString2=`listConnections -s 0 -d 1 -scn 1 -type animCurve $connectedNodes[$i]`;
			$tempString3=`listConnections -s 0 -d 1 -scn 1 -type transform $connectedNodes[$i]`;
			$nextConnectedNodes=`stringArrayCatenate $nextConnectedNodes $tempString`;
			$nextConnectedNodes=`stringArrayCatenate $nextConnectedNodes $tempString2`;
			$nextConnectedNodes=`stringArrayCatenate $nextConnectedNodes $tempString3`;
			$nextConnectedNodes=`stringArrayRemove {"FitSkeleton"} $nextConnectedNodes`;
			}
		clear $connectedNodes;
		$connectedNodes=$nextConnectedNodes;
		}
	GraphEditor;
	return;
	}
if ($action=="Delete")
	{
	if (`objExists ControlSet`) asGoToBuildPose bodySetup;
	if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;
	refresh;
	$connectedNodes=`listConnections -s 0 -d 1 -scn 1 -type blendWeighted ($obj+"."+$drivingAttr)`;
	$tempString=`listConnections -s 0 -d 1 -scn 1 ($obj+"."+$drivingAttr)`;
	$tempString2=`listConnections -s 0 -d 1 -scn 1 -c 1 -p 1 ($obj+"."+$drivingAttr)`;
	for ($y=0;$y<size($tempString);$y++)
		if ($tempString[$y]=="DrivingSystem")//standard ctrl is driver
			disconnectAttr ($obj+"."+$drivingAttr) $tempString2[($y*2)+1];
		else if (!`sets -im AllSet $tempString[$y]`)
			delete $tempString[$y];
	//remove attr
	if (!$otherDsIsDriver)
		catchQuiet (`deleteAttr ($obj+"."+$drivingAttr)`);
	asDsRemoveTestAnimation;//yes this means it runs twice, but attrs needs to be un-muted before `asUpdatePoseAttributes`

	//Remove the animCurve, so if a new DS with same name gets created, it does not use the old values
	clear $tempString;
	if (`objExists $connectedNodes[0]`)
		delete $connectedNodes[0];

	asUpdatePoseAttributes;
	if (`objExists ControlSet`) asGoToBuildPose bodySetup;
	print ("// Deleted DrivingSystem: "+$obj+"."+$drivingAttr+"\n");
	return;
	}

if (`objExists ControlSet`) asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;

if (`objExists SmilePullOffset_R`) setAttr SmilePullOffset_R.v 0;
if (`objExists SmilePullOffset_L`) setAttr SmilePullOffset_L.v 0;

asDsRemoveTestAnimation;

if (`objExists EditingDrivingSystem`) delete EditingDrivingSystem;
if (`objExists TestSymmetry`) delete TestSymmetry;


if ($testSym)
	{
	if ($isFace)
		$controls=`sets -q FaceControlSet`;
	else	
		$controls=`sets -q ControlSet`;
	createNode -n TestSymmetry transform;
	for ($i=0;$i<size($controls);$i++)
		{
		if (!`gmatch $controls[$i] "*_L"`)
			continue;

		$numChar=size($controls[$i]);
		$sideLess=`substring $controls[$i] 1 ($numChar-2)`;

		if (!`objExists  ($sideLess+"_R")`)
			continue;

		$isClusterControl=$isClusterLocalOrientControl=0;
		$tempString=`ls -l $controls[$i]`;
		if (`gmatch $tempString[0] "*CustomSystem|*"`)
			$isClusterControl=1;
		if ($isClusterControl)
			if (`attributeExists localOrient $controls[$i]`)
				$isClusterLocalOrientControl=`getAttr ($controls[$i]+".localOrient")`;

		$allKeyableAttrs=`listAttr -k -m -sn $controls[$i]`;
		for ($y=0;$y<size($allKeyableAttrs);$y++)
			{
			if (`getAttr -l ($controls[$i]+"."+$allKeyableAttrs[$y])`)
				continue;
			if (`gmatch $allKeyableAttrs[$y] "*_*"`)//e.g .followupperLid_L
				continue;
			addAttr -k 1 -ln ($sideLess+"_"+$allKeyableAttrs[$y]) -at double TestSymmetry;
			createNode -n ("TestSymmetry_"+$sideLess+"_"+$allKeyableAttrs[$y]+"_MultiplyDivide") multiplyDivide;
			connectAttr ($sideLess+"_R."+$allKeyableAttrs[$y]) ("TestSymmetry_"+$sideLess+"_"+$allKeyableAttrs[$y]+"_MultiplyDivide.input1.input1X");

			$flip=1;
			if (`gmatch $controls[$i] "FK*_L"` || `gmatch $controls[$i] "FK*_R"`
			 || `gmatch $controls[$i] "Bend*_L"` || `gmatch $controls[$i] "Bend*_R"`
			 || `attributeExists ikLocal $controls[$i]`
			 || $isClusterLocalOrientControl)
			 	{
			 	if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ty" || $allKeyableAttrs[$y]=="tz")
			 		$flip=-1;
			 	}
			else
				if ($allKeyableAttrs[$y]=="tx" || $allKeyableAttrs[$y]=="ry" || $allKeyableAttrs[$y]=="rz")
					$flip=-1;
			if ($isFace && !$isClusterControl)
				$flip=1;

			setAttr ("TestSymmetry_"+$sideLess+"_"+$allKeyableAttrs[$y]+"_MultiplyDivide.input2X") $flip;
			connectAttr ("TestSymmetry_"+$sideLess+"_"+$allKeyableAttrs[$y]+"_MultiplyDivide.outputX") ("TestSymmetry."+$sideLess+"_"+$allKeyableAttrs[$y]);
			connectAttr ("TestSymmetry."+$sideLess+"_"+$allKeyableAttrs[$y]) ($sideLess+"_L."+$allKeyableAttrs[$y]);
			$setAttrCmd+="setAttr "+$sideLess+"_L."+$allKeyableAttrs[$y]+" "+`getAttr ($sideLess+"_L."+$allKeyableAttrs[$y])`+";";
			}
		}
	addAttr -ln udAttr -dt "string"  TestSymmetry;
	setAttr -type "string" TestSymmetry.udAttr $setAttrCmd;
	}

if (!`objExists EditingDrivingSystem`)
	{
	createNode -n EditingDrivingSystem transform;
	addAttr -k 0 -ln DrivingSystems -at bool -dv 1 EditingDrivingSystem;
	}

if ($showOnlyAffected)
	asDSShowOnlyAffected $drivenObjs 1;

for ($i=0;$i<size($drivenObjs);$i++)
	{
	if (`gmatch $drivenObjs[$i] "*_L"`)
		continue;
	if (`getAttr -l ($drivenObjs[$i]+"."+$drivenAttrs[$i])`)
		continue;//v5.678 and before had SmilePull_R.tz as a DS, which is locked
	print ("setAttr "+$drivenObjs[$i]+"."+$drivenAttrs[$i]+" "+$drivenValues[$i]+";\n");

	if ($otherDsIsDriver)//only otherDsDrivers needs muting SDK`s ,since it needs the Driver to have Test-Anim as well, so avoid double up
		asDsMuteSDK 1;
	if (`gmatch $drivenObjs[$i] "Eye_*"` && !`getAttr ctrlBox.EyeCtrlVis`)
		{
		print ("// Eye controller driven, but EyeCtrlVis currently Off. Switching \"ctrlBox.EyeCtrlVis\" to On.\n");
		setAttr ctrlBox.EyeCtrlVis 1;
		}
	if (`gmatch $drivenObjs[$i] "*Region_*"` && !`getAttr ctrlBox.RegionsCtrlVis`)
		{
		print ("// Region controller driven, but RegionsCtrlVis currently Off. Switching \"ctrlBox.RegionsCtrlVis\" to On.\n");
		setAttr ctrlBox.RegionsCtrlVis 1;
		}
	if ($testAnim)
		{
		$startValue=0;
		if (`gmatch $drivenAttrs[$i] "s[x-z]"` || `gmatch $drivenAttrs[$i] "scale[X-Z]"`)
			$startValue=1;
		setKeyframe -t 0  -v $startValue ($drivenObjs[$i]+"."+$drivenAttrs[$i]);
		setKeyframe -t 30 -v $drivenValues[$i] ($drivenObjs[$i]+"."+$drivenAttrs[$i]);
		$tempString2=`listConnections -s 1 -d 0 -type animCurve ($drivenObjs[$i]+"."+$drivenAttrs[$i])`;
		rename $tempString2[0] ("asDSEdit_"+$tempString2[0]);
		}
	else
		setAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i]) $drivenValues[$i];
	if (`gmatch $drivenObjs[$i] "LipPull_*"` || `gmatch $drivenObjs[$i] "MouthNarrow_*"`)
		{
		tokenize $drivenObjs[$i] "_" $tempString;
		setAttr ($tempString[0]+"Offset_"+$tempString[1]+".v") 1;
		}
	}

//Set FKIK to FK (if $FKIK exists)
if (`objExists ("FK"+$obj)` && `objExists ("FKX"+$obj)` && `objExists ("IKX"+$obj)` && `objExists ("FKOffset"+$obj)`)
	{
/*
	$tempString=`listConnections -s 1 -d 0 -scn 1 ($obj+".tx")`;
	if (`objExists ("BendParentConstraint"+$obj+"_parentConstraint1")`)//Might be bendy-limb
		$tempString[0]="BendParentConstraint"+$obj+"_parentConstraint1";
	if ($tempString[0]!="")
		$tempString2=`listAttr -ud $tempString[0]`;
	if ($tempString2[1]!="")
		$tempString3=`listConnections -s 1 -d 0 -scn 1 ($tempString[0]+"."+$tempString2[1])`;
	if ($tempString3[0]!="")
		$FKIK=$tempString3[0];
*/
	$FKIK=`asFindFKIKCtrl ("FK"+$obj)`;
	if (`attributeExists FKIKBlend $FKIK`)
		setAttr ($FKIK+".FKIKBlend") 0;
	print ("setAttr "+$FKIK+".FKIKBlend 0;\n");
	}

$fkObjAttr=$obj+"."+$drivingAttr;
if (!`gmatch $obj "IK*"` && `objExists ("FK"+$obj+"."+$drivingAttr)`)
	$fkObjAttr="FK"+$obj+"."+$drivingAttr;

if (`gmatch $attr "angle*"`)
	{
	$fkObjAttr="FK"+$obj+"."+`substitute "angle" $drivingAttr "rotate"`;
	asSetRotationFromAngle ("FK"+$obj) $attr $value;
	$value=`getAttr $fkObjAttr`;
	setAttr $fkObjAttr 0;
	}

if (`gmatch $attr "opm*"`)
	{
	$fkObjAttr="FK"+$obj+"."+`substitute "opm" $drivingAttr ""`;
	setAttr $fkObjAttr $value;
	}

if ($testAnim && `objExists $fkObjAttr`)
	{
	//30f symmetrical animation
	playbackOptions -min 0 -ast 0 -aet 30 -max 30;
	autoKeyframe -state 1;
	if ($otherDsIsDriver)
		{
		setKeyframe -t 0  -v 0 $fkObjAttr;
		setKeyframe -t 30 -v $value $fkObjAttr;
		$tempString2=`listConnections -type animCurve $fkObjAttr`;
		rename $tempString2[0] ("asDSDriverEdit_"+$tempString2[0]);
		}
	currentTime 30;
	print ("// Animation from 0 to 30 created, Make any Edits at frame 30.\n");
	}

if (`objExists MetaHumanControlPanelToggle` && `gmatch $obj "CTRL_*_*"`)
	setAttr MetaHumanControlPanelToggle.MetaHumanControlPanelVis 0;

//Removed as we do not wish to apply driver value, it would cause double xform
//if (!$testAnim && `objExists $fkObjAttr`)
//	catchQuiet (`setAttr $fkObjAttr $value`);//could be locked e.g. ctrlMouthCorner_R.txPos_tyNeg

//removed this.not sure now why this was here.
//if ($blendedAttr)
//	deleteAttr ($obj+"."+$drivingAttr);//only needed for bringing this info this far.

if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
headsUpDisplay -s 2 -b 0 -bs "medium" -l ("Editing Driving System:  "+$obj+"."+$attr+"="+$value) -lfs "large" HUDEDSMode;
displayColor headsUpDisplayLabels $colorNr;

//select $sel;
asUpdateButtonEnables;
select -cl;
}

global proc float[] asDSGetDriverMinMax (string $obj, string $attr)
{
string $tempString[];
float $keyXValues[],$minMax[];

if (`gmatch $obj "FK*"`)//standard ctrl is driver
	$obj=`substitute "FK" $obj ""`;
$tempString=`listConnections -scn 1 -s 0 -d 1 -type animCurve ($obj+"."+$attr)`;
if (!`objExists $tempString[0]`)
	{
	$tempString=`listConnections -scn 1 -s 0 -d 1 -type blendWeighted ($obj+"."+$attr)`;
	if (`objExists $tempString[0]`)
		$tempString=`listConnections -scn 1 -s 0 -d 1 -type animCurve ($tempString[0]+".output")`;
	}
if (`objExists $tempString[0]`)
	{
	$keyXValues=`keyframe -q -fc $tempString[0]`;
	$minMax[0]=`asRoundOff $keyXValues[0] 3`;
	$minMax[1]=`asRoundOff $keyXValues[size($keyXValues)-1] 3`;
	}
return $minMax;
}

global proc string asDsGetMirroredAnimCurve (string $animCurve)
{
string $mirroredAnimCurve,$animCurveDriveSource,$mirroredAnimCurveDriveSource,$animCurveConnectsTo;
string $tempString[],$tempString2[],$tempString3[];

$tempString=`listConnections -s 0 -d 1 ($animCurve+".output")`;
$animCurveConnectsTo=$tempString[0];
//print ("$animCurveConnectsTo="+$animCurveConnectsTo+"\n");

$mirroredAnimCurve=`substitute "_R" $animCurve "_L"`;
//side ctrl might drive center ctrl (e.g ctrlARKit_M.mouthPressRight drives SDKLipRegion_M_translateY)
if ($mirroredAnimCurve==$animCurve)
	{
	$tempString=`listConnections -s 1 -d 0 ($animCurve+".input")`;
	$animCurveDriveSource=$tempString[0];
//print ("$animCurveDriveSource="+$animCurveDriveSource+"\n");
	if ($animCurveDriveSource!="")
			{
			$mirroredAnimCurveDriveSource=`substitute "_R" $animCurveDriveSource "_L"`;
			$mirroredAnimCurveDriveSource=`substitute "Right" $animCurveDriveSource "Left"`;
//print ("$mirroredAnimCurveDriveSource="+$mirroredAnimCurveDriveSource+"\n");
			if ($mirroredAnimCurveDriveSource!=$animCurveDriveSource)
				{
				$tempString2=`listConnections -s 0 -d 1 -type animCurve ($mirroredAnimCurveDriveSource+".output")`;
				for ($i=0;$i<size($tempString2);$i++)
					{
					$tempString3=`listConnections -s 0 -d 1 ($tempString2[$i]+".output")`;
					for ($y=0;$y<size($tempString3);$y++)
						if ($tempString3[$y]==$animCurveConnectsTo)
							{
//print ("Yes using same $animCurveConnectsTo "+$animCurveConnectsTo+"\n");
							$mirroredAnimCurve=$tempString2[$i];
							break;
							}
					}
				}
			}
	}
//print ("$animCurve="+$animCurve+"\n");
//print ("$mirroredAnimCurve="+$mirroredAnimCurve+"\n");

return $mirroredAnimCurve;
}

global proc asDsMuteSDK (int $onOff)
{
//int $isMemeberAllSet,$isMemeberFaceAllSet;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $tempString[]=`ls -type transform  "SDK*"`;

for ($i=0;$i<size($tempString);$i++)
	{
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			if (!size(`listConnections ($tempString[$i]+"."+$trs[$y]+$xyz[$z])`))
				continue;
			if ($onOff)
				mute ($tempString[$i]+"."+$trs[$y]+$xyz[$z]);
			else
				mute -disable ($tempString[$i]+"."+$trs[$y]+$xyz[$z]);
			}
	}
}

global proc asDsRemoveTestAnimation ()
{
float $currentTime=`currentTime -q`;
string $tempString[],$tempString2[];

currentTime 30;
$tempString=`ls -type animCurve "asDSEdit_*"`;
for ($i=0;$i<size($tempString);$i++)
	delete $tempString[$i];

currentTime 0;
$tempString=`ls -type animCurve "asDSDriverEdit_*"`;//driver
for ($i=0;$i<size($tempString);$i++)
	delete $tempString[$i];

currentTime $currentTime;
asDsMuteSDK 0;
}

global proc asDsEditCancel ()
{
string $tempString[];

if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	headsUpDisplay -e -rem HUDEDSMode;
	displayColor headsUpDisplayLabels 16;
	}

asDsRemoveTestAnimation;

if (`objExists EditingDrivingSystem`) delete EditingDrivingSystem;
if (`objExists TestSymmetry`) delete TestSymmetry;

asDSShowOnlyAffected {} 0;

if (`objExists SmilePullOffset_R`) setAttr SmilePullOffset_R.v 1;
if (`objExists SmilePullOffset_L`) setAttr SmilePullOffset_L.v 1;

if (`objExists ControlSet`) asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;

if (`objExists MetaHumanControlPanelToggle`) setAttr MetaHumanControlPanelToggle.MetaHumanControlPanelVis 1;

asUpdateButtonEnables;
dgdirty -a;//needed if entering Edit mode was `unDone`, which not fully undoes, then hit Cancel to restore normality
}

global proc asDsEditApply ()
{
global string $gMainProgressBar;
global int $asDSMirror;
$asDSMirror=1;

progressBar -e -st "working" -bp -ii 1 -min 0 -max 2 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

asDSShowOnlyAffected {} 0;

if (`objExists SmilePullOffset_R`) setAttr SmilePullOffset_R.v 1;
if (`objExists SmilePullOffset_L`) setAttr SmilePullOffset_L.v 1;

asDsCreate;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	headsUpDisplay -e -rem HUDEDSMode;
	displayColor headsUpDisplayLabels 16;
	}
if (`objExists MetaHumanControlPanelToggle`) setAttr MetaHumanControlPanelToggle.MetaHumanControlPanelVis 1;
asUpdateButtonEnables;
}

global proc asDsSdk (string $driver, string $driven, float $driverValue, float $drivenValue)
{
float $startValue=0;
string $driverBw,$drivenBw,$driveSource;
string $tempString[],$tempString2[],$beforeSDKCurves[],$afterSDKCurves[];

if (`gmatch $driven "*[.]s[x-z]"` || `gmatch $driven "*[.]scale[X-Z]"`)
	$startValue=1;

$drivenValue=`asRoundOff $drivenValue 3`;
if ($drivenValue==$startValue)
	return;

if (!`objExists $driven`)
	{
	warning ("Driven object:\""+$driven+"\" not found, skipping.");//just warning, helps build FaceSetups without all elements, e.g. lips only
	return;
//	error ("\""+$driven+"\" does not exist");
	}

string $blendWeighted=`asEnsureBlendWeighted $driven`;

//if $driver has a bw, then we use the bw as the driver instead .e.g ctrlBox drivers such as ctrlBrow_R.ty
$driveSource=$driver;
$driverBw=`asCtrlToBw $driver`;
if (`objExists $driverBw`)
	$driveSource=$driverBw+".output";

//Also if the $driven has a bw, use it instead .e.g ctrlARKit_M drives ctrlBrow_R.tx (Unless $driven is a SDKNode)(then auto bw)
$drivenBw=`asCtrlToBw $driven`;
if (`objExists $drivenBw` && !`gmatch $driven "SDK*"`)
	if (!`objExists ARKitQuickConnecting`)//Not for `ARKit quick-connect`, this we want to occupy the actual controllers
		$driven=$drivenBw+".input";

//if a bw* is the $driven ensure the driven-attribute is the next-avaiable-index
if (`gmatch $driven "bw*[.]input"` && `objectType $driven`=="blendWeighted")
	{
	dgeval $driven;//helps getAttr -s get correct count
	$driven+="["+`getAttr -s $driven`+"]";
	}

//When blending Scales, all SDK`s except the first one, needs value of 1 removed, unless its just adding a key to existing sdk
if (`gmatch $driven "*[.]s[x-z]*"` || `gmatch $driven "*[.]scale[X-Z]*"`)
	$tempString=`listConnections -s 1 -d 0 -scn 1 ($blendWeighted+".input")`;
		if (size($tempString))
			{
			$tempString2=`listConnections -s 1 -d 0 -scn 1 $tempString[0]`;
			if ($tempString2[0]!=$driverBw)//just adding a key to existing sdk
				{
				$startValue=$startValue-1;
				$drivenValue=$drivenValue-1;
				}
			}

$beforeSDKCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve ($blendWeighted+".input")`;
setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v $startValue -cd $driveSource $driven;
setDrivenKeyframe -itt "linear" -ott "linear" -dv $driverValue -v $drivenValue -cd $driveSource $driven;

asEnsureSDKcurvesNamed;
$afterSDKCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve ($blendWeighted+".input")`;
for ($i=0;$i<size($afterSDKCurves);$i++)
	{
	if (`stringArrayCount $afterSDKCurves[$i] $beforeSDKCurves`)
		continue;

	setAttr ($afterSDKCurves[$i]+".preInfinity") 4;
	setAttr ($afterSDKCurves[$i]+".postInfinity") 4;
	}
}

global proc asDSShowOnlyAffected (string $drivenObjs[], int $hideShow)
{
string $tempString[],$tempString2[];
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	$tempString=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $tempString`;
	}

//correspond ctrls vis
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString2=`listRelatives -s -ni $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		if (`stringArrayCount $controlSetMembers[$i] $drivenObjs` || $hideShow==0)
			catchQuiet (`setAttr ($tempString2[$y]+".v") 1`);
		else
			catchQuiet (`setAttr ($tempString2[$y]+".v") 0`);
		}
	}
}

global proc int asFaceIsBlendedAttr (string $obj, string $attr)
{
int $blendedAttr;

if (!`getAttr -se ($obj+"."+$attr)` && `gmatch $attr "*_*"`)
	$blendedAttr=1;
if (`gmatch $obj "ctrlMouthCorner_*"` && ($attr=="smile" || $attr=="frown" || $attr=="narrowSmile" || $attr=="narrowFrown"))
	$blendedAttr=1;

return $blendedAttr;
}

global proc string[] asGetDeformJointsByDistance (float $pos[])
{
int $numChar;
float $nearestJointDist,$mag;
float $pos2[],$deformJointDists[];
string $magString;
string $distDeformJoints[],$distDeformJointsSorted[],$deformJointDistsSorted[],$tempString[];
string $deformJoints[]=`listRelatives -type joint -ad DeformationSystem`;

$nearestJointDist=9999;
for ($i=0;$i<size($deformJoints);$i++)
	{
//	if (`gmatch $deformJoints[$i] "*Part[0-9]*"`)
//		continue;
	if (`gmatch $deformJoints[$i] "*_L"`)
		continue;
	if (`gmatch $deformJoints[$i] "*Partial_*"`)
		continue;
//	if (!size(`listRelatives -c -type joint $deformJoints[$i]`))//Not attach to endJoint
//		continue;
	$pos2=`xform -q -ws -t $deformJoints[$i]`;
	$mag=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
	$magString=`asRoundOff $mag 3`;//to avoid exponential notation (e.g 1.234567e-2)
	//ensure 3 digets after .
	tokenize $magString "[.]" $tempString;
	$numchar=size($tempString[1]);
	if ($tempString[1]=="")
		$magString+=".";
	for ($y=$numchar;$y<3;$y++)
		$magString+="0";
	//ensure 5 digets before .
	$numchar=size($tempString[0]);
	for ($y=$numchar;$y<5;$y++)
		$magString="0"+$magString;
	$distDeformJoints[size($distDeformJoints)]=$magString+"|"+$deformJoints[$i];
	}
$distDeformJointsSorted=`sort $distDeformJoints`;

for ($i=0;$i<size($distDeformJointsSorted);$i++)
	{
	tokenize $distDeformJointsSorted[$i] "|" $tempString;
	$numChar=size($tempString[1]);
//	$deformJointDistsSorted[$i]=`substring $tempString[1] 1 ($numChar-2)`;
	$deformJointDistsSorted[$i]=$tempString[1];
	}
return $deformJointDistsSorted;
}

global proc asWmLayout ()
{
string $mesh;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $tempString[];

$tempString=`listRelatives -s -ni $geometry`;
$mesh=$tempString[0];
$sgs=`listConnections -s 1 -d 0 -type shadingEngine ($mesh+".instObjGroups[0].objectGroups")`;

columnLayout -adj 1 -w 250;
	separator -h 20;
	text -l "Multiple shaders found on face-object.\nWhich shader to use ?";
	separator -h 10;
	optionMenu -cc ("setAttr shaderChooserDialog.shader -type \"string\" #1") asWmDriveOptionMenu;
	for ($i=0;$i<size($sgs);$i++)
		{
		$tempString=`listConnections -s 1 -d 0 ($sgs[$i]+".surfaceShader")`;
		$shader=$tempString[0];
		menuItem -l $shader;
		if ($i==0)
			setAttr shaderChooserDialog.shader -type "string" $shader;
		}
//	optionMenu -e -cc ("setAttr shaderChooserDialog.shader -type \"string\" #1") asWmDriveOptionMenu;
	separator -h 10;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;

	setParent..;
}

global proc asCCOK ()
{
string $name=`textFieldGrp -q -tx asCustomControlNameTextFieldGrp`;
int $mirror=`checkBox -q -v asCustomControlMirrorCheckBox`;
int $middle=`checkBox -q -v asCustomControlMiddleCheckBox`;
int $local=`checkBox -q -v asCustomControlLocalCheckBox`;
int $partialParent=`checkBox -q -v asCustomControlPartialParentCheckBox`;
string $parent=`optionMenuGrp -q -v asCustomControlParentOptionMenuGrp`;
string $skinCluster;
if (`optionMenuGrp -q -ex asCustomControlSkinClusterOptionMenuGrp`)
	$skinCluster=`optionMenuGrp -q -v asCustomControlSkinClusterOptionMenuGrp`;

optionVar -iv asCCMirror $mirror;
optionVar -iv asCCMiddle $middle;
optionVar -iv asCCLocal $local;
optionVar -iv asCCPartialParent $partialParent;

setAttr -type "string" CreatingCustomControl.name $name;
setAttr CreatingCustomControl.mirror $mirror;
setAttr CreatingCustomControl.middle $middle;
setAttr CreatingCustomControl.local $local;
setAttr -type "string" CreatingCustomControl.parent $parent;
setAttr CreatingCustomControl.partialParent $partialParent;
setAttr -type "string" CreatingCustomControl.skinCluster $skinCluster;
}

global proc asCCLayout ()
{
float $pos[];
int $face=`getAttr CreatingCustomControl.face`;
int $mirror,$local,$enablePartialOption;
int $middle=`optionVar -q asCCMiddle`;
int $partialParent=`optionVar -q asCCPartialParent`;
int $gameEngine=`checkBox -q -v asBodyGameEngineCheckBox`;
string $name,$preferredParent,$softMod;
string $side="_R";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $type=`getAttr CreatingCustomControl.type`;
string $softModHandle=`getAttr CreatingCustomControl.softModHandle`;
string $selXforms[]=`ls -sl -type transform`;
string $deformJointsByDistance[];
string $tempString[],$existingSkinClusters[];

if (!`optionVar -ex asCCMirror`)
	optionVar -iv asCCMirror 1;
$mirror=`optionVar -q asCCMirror`;
if (!`optionVar -ex asCCLocal`)
	optionVar -iv asCCLocal 1;
$local=`optionVar -q asCCLocal`;
if ($mirror && $middle)
	$middle=0;
if ($type=="Skin" && !$face)
	$enablePartialOption=1;
if (!$enablePartialOption)
	$partialParent=0;

if ($face)
	$deformJointsByDistance={$headJoint};
else
	{
	$pos=`getAttr ($softModHandle+".origin")`;
	$deformJointsByDistance=`asGetDeformJointsByDistance $pos`;
	}

//remove endJoints
for ($i=0;$i<size($deformJointsByDistance);$i++)
	if (size(`listRelatives -c -type joint $deformJointsByDistance[$i]`)==0)
		if (!`attributeExists control $deformJointsByDistance[$i]` && size($deformJointsByDistance)>1)
			$deformJointsByDistance=`stringArrayRemove {$deformJointsByDistance[$i]} $deformJointsByDistance`;

//$preferredParent
if ($face && `objExists FaceFitSkeleton`)
	if (`attributeExists HeadJoint FaceFitSkeleton`)
		$preferredParent=`getAttr FaceFitSkeleton.HeadJoint`;
//(or sencond selected Xform)
if ($selXforms[1]!="") 
//	if (`sets -im DeformSet $selXforms[1]` || $face)// commented out in v 6.2635 (as nonASBody rigs do not have DeformSet
		$preferredParent=$selXforms[1];

//ensure $deformJointsByDistance[0] is $preferredParent
if ($preferredParent!="")
	{
	$deformJointsByDistance=`stringArrayRemove {$preferredParent} $deformJointsByDistance`;
	stringArrayInsertAtIndex(0, $deformJointsByDistance, $preferredParent);
	}

//$name=`asCustomControlNameFromNearestJoint $deformJointsByDistance[0] "Skin" $side`;
$name=`asCustomControlNameFromNearestJoint $deformJointsByDistance[0] $type $side`;

if (`objExists asBatch`)
	$name=`getAttr asBatch.name`;

columnLayout;
	text -l ("\tCreating new "+$type+" Control:");
	separator -h 10 -st none;
	textFieldGrp -cw2 40 150 -l "name:" -tx $name asCustomControlNameTextFieldGrp;
	separator -h 10 -st none;
	rowLayout -nc 3;
		checkBox -l "mirror  " -v $mirror -cc "optionVar -iv asCCMirror #1" -onc "checkBox -e -v 0 asCustomControlMiddleCheckBox" asCustomControlMirrorCheckBox;
		checkBox -l "middle  " -v $middle -cc "optionVar -iv asCCMiddle #1" -onc "checkBox -e -v 0 asCustomControlMirrorCheckBox" asCustomControlMiddleCheckBox;
		checkBox -l "local" -v $local -cc "optionVar -iv asCCLocal #1" asCustomControlLocalCheckBox;
		setParent..;
	checkBox -m $enablePartialOption -h 30 -l "50% joint as parent" -v $partialParent -cc "optionVar -iv asCCPartialParent #1" asCustomControlPartialParentCheckBox;
	separator -m (!$enablePartialOption) -h 30 asCustomControlPartialParentCheckBoxStandin;
	optionMenuGrp -cw2 40 150 -l "parent:" asCustomControlParentOptionMenuGrp;
		for ($i=0;$i<size($deformJointsByDistance);$i++)
			menuItem -l ($deformJointsByDistance[$i]);
	if (`asMayaVersionAsFloat`>=2024 && $type=="Skin")
		{
		optionMenuGrp -en (!$gameEngine) -cw2 40 150 -l "node:" asCustomControlSkinClusterOptionMenuGrp;
		$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
		$softMod=$tempString[0];
		$tempString=`listHistory $softMod`;
		for ($i=0;$i<size($tempString);$i++)
			if (`objectType $tempString[$i]`=="skinCluster")
				$existingSkinClusters[size($existingSkinClusters)]=$tempString[$i];
		for ($i=0;$i<size($existingSkinClusters);$i++)
			menuItem -l $existingSkinClusters[$i];
		menuItem -l "*new";
		}

	separator -h 20 -st none;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asCCOK;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
}

global proc asDsLayout ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAdvancedOptions;
global int $asDSDisableMirror;
string $tempString[];
//string $blendedAttrs[]={"txPos_tyPos","txPos_tyNeg","txNeg_tyPos","txNeg_tyNeg"};
tokenize $asDSMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asDSMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asDSMessage+=$tempString[$i]+"\n";
	$asDSMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout -adj 0 -w 250;
columnLayout -adj 0;
	text -l $asDSMessage asDSMessageText;
	separator -h 10 -st none;
	setParent..;
rowLayout -nc 2;
	separator -st none -w 20;
	optionMenu -cc asDSChangeDriveOption asDSDriveOptionMenu;
	 menuItem "create new controller";
	 menuItem "use existing controller";
	 menuItem "drive from selected object";
	setParent..;
columnLayout -adj 1 asDSInputsColumnLayout;
	rowLayout -nc 3 asDSControlNameRowLayout;
		text -w 100 -l "Control Name:";
		columnLayout;
			textField -w 80 asDSObjNameTextField;
			optionMenu -m 0 asDSObjNameOptionMenu;
			setParent..;
		setParent..;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 asDSAttrNameTextField;
		setParent..;   	

	if ($asDSAdvancedOptions)
		{
		separator -h 10 -st none;
		text -l "Attribute limits:";
		rowLayout -en 1 -nc 8;
			checkBox -w 40 -v 1 -l "min:" asDSAttrHasMin;
			floatField -w 30 -v 0 -pre 1 asDSAttrMin;
			separator -w 10 -st none;
			checkBox -w 40 -v 1 -l "max:" asDSAttrHasMax;
			floatField -w 30 -v 10 -pre 1 asDSAttrMax;
			setParent..;
		separator -h 5 -st none;
		checkBox -l "Use Soft limits" -v 1 asDSAttrSoftLimits;
		}
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 0;
	rowLayout -nc 2 -en (!$asDSDisableMirror) asDSMirrorRowLayout;
		text -w 100 -l "Mirror:";
    checkBox -l "" -v (!$asDSDisableMirror) asDSMirrorCheckBox;
		setParent..;
	rowLayout -m 0 -nc 3 asDSAngleRowLayout;
		text -w 100 -l "Angle Rotations:";
    checkBox -l "" -v 1 -cc asDSChangeDriveOption asDSAngleCheckBox;
		setParent..;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asDsGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;

//populate asDSObjNameOptionMenu
string $drivingSystems[]=`asDsGetDrivingSystems`;
//if (size($drivingSystems))
//	rowLayout -e -en 1 asDSUseControlRowLayout;
setParent -menu asDSObjNameOptionMenu;

//This proc also used by CreateNewBlendShape, then $drivingSystems are actuall faceCtrls
if ($asDSMessage=="Create New BlendShape")
	{
	clear $drivingSystems;
	if (`objExists ctrlBox`)
		{
		$tempString=`listRelatives -c -type transform ctrlBox`;
		for ($i=0;$i<size($tempString);$i++)
			$drivingSystems[$i]=`substitute "Box" $tempString[$i] ""`;
		}
	}

for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"`)
		continue;
	menuItem -l $drivingSystems[$i];
	}

//fill out fields if we are editing
if ($asDSObjName!="")
	{
	textField -e -ed 0 -tx $asDSAttrName asDSAttrNameTextField;
	rowLayout -e -en 0 asDSControlNameRowLayout;
//	checkBox -e -en 1 -v 1 asDSUseControlCheckBox;
	optionMenu -e -en 1 -v $asDSObjName asDSObjNameOptionMenu;
	columnLayout -e -m 0 asDSInputsColumnLayout;

	string $oppositeObjName="";
	if (`gmatch $asDSObjName "*_R"`) $oppositeObjName=`substitute "_R" $asDSObjName "_L"`;
	if (`gmatch $asDSObjName "*_L"`) $oppositeObjName=`substitute "_L" $asDSObjName "_R"`;
	if (!`objExists $oppositeObjName`)
		{
		checkBox -e -v 0 asDSMirrorCheckBox;
		rowLayout -e -en 0 asDSMirrorRowLayout;
		}
	}
asDSChangeDriveOption;
}

global proc asDSChangeDriveOption ()
{
global string $asDSMessage;
int $useExistingController,$driveFromSelectedObject,$selectedIsValidDriver,$selectedIsValidAngleDriver,$angleDriverOptionEnable;
int $asDSAngleCheckBoxValue=`checkBox -q -v asDSAngleCheckBox`;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[],$tempString3[];
string $driveOption=`optionMenu -q -v asDSDriveOptionMenu`;
string $selectedmessageLine,$selectedDriverObj,$selectedDriverAttr;

tokenize $asDSMessage "\n" $tempString;
for ($i=1;$i<size($tempString);$i++)
	{
	tokenize $tempString[$i] "=" $tempString2;
	tokenize $tempString2[0] "." $tempString3;
	$selectedDriverObj=`strip $tempString3[0]`;
	$selectedDriverAttr=`strip $tempString3[1]`;
	if ($selectedDriverObj==$sel[0])
		{
		$selectedIsValidDriver=1;
		$selectedmessageLine=$tempString[$i];
		if (`gmatch $selectedDriverAttr "rotate*"`)
			$selectedIsValidAngleDriver=1;
		break;
		}
	}
$tempString=`optionMenu -q -itemListLong asDSDriveOptionMenu`;
if (!$selectedIsValidDriver)
	menuItem -e -en 0 $tempString[2];
//print ("// \"drive from selected object\" option disabled, since selected object is not in the list.\n");

if ($driveOption=="use existing controller") $useExistingController=1;
if ($driveOption=="drive from selected object") $driveFromSelectedObject=1;
optionMenu -e -m $useExistingController asDSObjNameOptionMenu;
textField -e -m (!$useExistingController) asDSObjNameTextField;
textField -e -ed (!$driveFromSelectedObject) asDSObjNameTextField;
textField -e -ed (!$driveFromSelectedObject) asDSAttrNameTextField;

//Angle driver ?
if ($driveFromSelectedObject && $selectedIsValidAngleDriver)
	$angleDriverOptionEnable=1;
rowLayout -e -m $angleDriverOptionEnable asDSAngleRowLayout;

if ($driveFromSelectedObject)
	{
	textField -e -tx $selectedDriverObj asDSObjNameTextField;
	textField -e -tx $selectedDriverAttr asDSAttrNameTextField;
	text -e -l `substitute $selectedmessageLine $asDSMessage ""` asDSMessageText;
	}
else
	{
	textField -e -tx "" asDSObjNameTextField;
	textField -e -tx "" asDSAttrNameTextField;
	text -e -l $asDSMessage asDSMessageText;
	}
}

global proc string asDsCreateSDKXform (string $drivenObj)
{
int $isFace,$isCustomCtrl;
int $opm=`asGetOpm`;
string $child=$drivenObj;
string $sdkXform,$parentm,$deformJoint,$previousFKScaleOutTo;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $tempString[];

if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObj`)
		$isFace=1;

$tempString=`listRelatives -p $drivenObj`;
$parent=$tempString[0];

if (`gmatch $parent "*Extra*"`)
	{
	$child=$parent;
	$tempString=`listRelatives -p $parent`;
	$parent=$tempString[0];
	}

if (`gmatch $drivenObj "FK*"`)
	$deformJoint=`substitute "FK" $drivenObj ""`;
else//customCtrl
	{
	tokenize $drivenObj "_" $tempString;
	$tempString[0]=$tempString[0]+"Joint_"+$tempString[1];
	if (`objExists $tempString[0]`)
		$deformJoint=$tempString[0];
	$isCustomCtrl=1;
	}

$sdkXform="SDK"+$drivenObj;
createNode -n $sdkXform -p $parent transform;
//Add to AllSet only if controller is already in AllSet, (so not for CustomControllers)
if (`sets -im AllSet $drivenObj`)
	sets -add AllSet $sdkXform;
setAttr ($sdkXform+".rotateOrder") `getAttr ($drivenObj+".rotateOrder")`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1;

parent $child $sdkXform;

//Also affects scale
if ($deformJoint!="" && $isFace==0 && !$opm)
	{
	createNode -n ($sdkXform+"ScaleMPD") multiplyDivide;
	setAttr ($sdkXform+"ScaleMPD.isHistoricallyInteresting") 0;
	if (`sets -im AllSet $drivenObj`)
		sets -add AllSet ($sdkXform+"ScaleMPD");
	for ($z=0;$z<size($xyz);$z++)
		{
		$tempString=`listConnections -s 0 -d 1 -p 1 ($drivenObj+".s"+$xyz[$z])`;
		if ($isCustomCtrl)
			{
			//customControls connected scale direct, not by each scale axis
			$z=99;
			$tempString=`listConnections -s 0 -d 1 -p 1 -type joint ($drivenObj+".s")`;
			}
		$previousFKScaleOutTo=$tempString[0];
		connectAttr ($drivenObj+".s"+$xyz[$z]) ($sdkXform+"ScaleMPD.input1"+$XYZ[$z]);
		connectAttr ($sdkXform+".s"+$xyz[$z]) ($sdkXform+"ScaleMPD.input2"+$XYZ[$z]);
		if ($previousFKScaleOutTo!="")
			connectAttr -f ($sdkXform+"ScaleMPD.output"+$XYZ[$z]) $previousFKScaleOutTo;
		}
	}

return $sdkXform;
}

global proc string[] asDsGetDrivingSystems ()
{
int $sdkConnection;
string $bw,$objectType;
string $drivingSystems[],$tempString[],$tempString2[],$tempString3[],$attrs[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
if (`objExists ctrlBox` && !`objExists asFaceBS`)
	{
	$tempString=`listRelatives -ad -type transform ctrlBox`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$sdkConnection=0;
		$attrs=`asDsGetAttrs $tempString[$i]`;
		for ($y=0;$y<size($attrs);$y++)
			{
			$bw="bw"+$tempString[$i]+"_"+$attrs[$y];	
			if (!`objExists $bw`)
				continue;
//			$tempString2=`listConnections -s 0 -d 1 -type animCurve $bw`;
//			if (`gmatch $tempString2[0] "*SDK*"`)
			$sdkConnection=1;
			}
		if ($sdkConnection)
			$drivingSystems[size($drivingSystems)]=$tempString[$i];
		}
	}

//Changed detection of otherDsDrivers(AutoDrivers) in v 5.8763, as some versions reBuilt without restoring DrivingSystem.otherDsDrivers connections
//any bw->SDK* connections
$tempString=`ls -type blendWeighted "bw*"`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -scn 1 ($tempString[$i]+".output")`;
	if ($tempString2[0]=="")
		continue;
	$objectType=`objectType $tempString2[0]`;
	if ($tempString2[0]=="" || `gmatch $objectType "animCurve*"`) //Skip outputBWs
		continue;
	$tempString2=`listConnections -scn 1 -type animCurve ($tempString[$i]+".input")`;
	if ($tempString2[0]=="")
		continue;
	$tempString2=`listConnections -scn 1 -type blendWeighted ($tempString2[0]+".input")`;
	if ($tempString2[0]=="")
		continue;
	$tempString2=`listConnections -scn 1 -type transform ($tempString2[0]+".input")`;
	if ($tempString2[0]=="")
		continue;
	$tempString3=`listRelatives -p $tempString2[0]`;
	if ($tempString3[0]=="DrivingSystem") // Skip ordinary DrivingSystem
		continue;
	if (`gmatch $tempString2[0] "SmilePull_[A-Z]"` || `gmatch $tempString2[0] "Lip_[A-Z]"`)
		continue; // Skip SmilePull & Lip
	if (!`stringArrayCount $tempString2[0] $drivingSystems`)
		if (!`gmatch $tempString2[0] "CTRL_*_*"`)//not adding MH here
			$drivingSystems[size($drivingSystems)]=$tempString2[0];
	}

if (`attributeExists MetaHumanControlPanelVis MetaHumanControlPanelToggle`)
	if (`getAttr MetaHumanControlPanelToggle.MetaHumanControlPanelVis`)
		{
//		clear $drivingSystems;
		$tempString=`listRelatives -ad -type transform FRM_faceGUI`;
		for ($i=0;$i<size($tempString);$i++)
			{
			if (!`gmatch $tempString[$i] "CTRL_*"`)
				continue;
			if (`gmatch $tempString[$i] "*[f-F]ollowHead*"` || $tempString[$i]=="CTRL_expressions" || $tempString[$i]=="CTRL_faceTweakersGUI" || $tempString[$i]=="CTRL_GUIswitch")
				continue;
			$tempString2=`listRelatives -s $tempString[$i]`;
			if ($tempString2[0]!="")
				{
				$tempString3=`listConnections -s 0 -d 1 ($tempString2[0]+".instObjGroups")`;
				if ($tempString3[0]=="asBlackSG")//disabled and set to use asBlackSG
					continue;
				}
			$drivingSystems[size($drivingSystems)]=$tempString[$i];
			}
		}

return $drivingSystems;
}

global proc string[] asDsGetAttrs (string $drivingSystem)
{
int $isFace,$isMH,$otherDsIsDriver;
string $attrs[],$tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[];

if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivingSystem`)
		$isFace=1;
$tempString=`ls -l $drivingSystem`;
if (!$isFace && !`gmatch $tempString[0] "*|DrivingSystem|*"`)//standard ctrl is driver
	$otherDsIsDriver=1;
if ($isFace && `gmatch $tempString[0] "*|GRP_faceGUI|*"`)//standard ctrl is driver
	$isMH=1;

if ($isFace || $isMH)
	{
	if (!`getAttr -l ($drivingSystem+".tx")`)
		$attrs={"translateX","translateY"};
	if ($isMH)
		$attrs=`listAttr -k $drivingSystem`;
//	if ($drivingSystem=="ctrlMouth_M")
//		$attrs={"ty"};
	$tempString=`listAttr -ud $drivingSystem`;
//	if ($drivingSystem!="ctrlEye_R" && $drivingSystem!="ctrlEye_L" && $drivingSystem!="ctrlMouth_M")
		for ($i=0;$i<size($tempString);$i++)
			if (!`getAttr -l ($drivingSystem+"."+$tempString[$i])`)
				if (`getAttr -k ($drivingSystem+"."+$tempString[$i])` || `getAttr -cb ($drivingSystem+"."+$tempString[$i])`)
					$attrs[size($attrs)]=$tempString[$i];
	if ($drivingSystem=="ctrlPhonemes_M")
		$attrs=`stringArrayRemove {"multipliers","jaw","lip"} $attrs`;
	}
else if ($otherDsIsDriver)
	{
	//Changed detection of otherDsDrivers(AutoDrivers) in v 5.8763, as some versions reBuilt without restoring DrivingSystem.otherDsDrivers connections
	$tempString2=`listConnections -s 0 -d 1 -scn 1 -p 0 -type blendWeighted $drivingSystem`;
	$tempString3=`listConnections -s 0 -d 1 -scn 1 -p 1 -type blendWeighted $drivingSystem`;
	for ($i=0;$i<size($tempString2);$i++)
		{
		$tempString4=`listConnections -s 1 -d 0 -scn 1 -p 1 $tempString3[$i]`;
		tokenize $tempString4[0] "." $tempString5;
		$attrs[size($attrs)]=$tempString5[1];
		}
	}
else
	$attrs=`listAttr -ud $drivingSystem`;

$attrs=`stringArrayRemove {"optimizedDS"} $attrs`;
return $attrs;
}

global proc string[] asDsGetAnimCurves (string $drivingSystem, string $drivingAttr)
{
string $bw,$driveSource,$nonFK;
string $animCurves[],$tempString[],$pmas[];

if (`gmatch $drivingSystem "FK*"`)//standard ctrl is driver
	{
	$nonFK=`substitute "FK" $drivingSystem ""`;
	if (`attributeExists $drivingAttr $nonFK`)//since a DrivingSystem could be named "FK*"
		$drivingSystem=$nonFK;
	}
$driveSource=$drivingSystem+"."+$drivingAttr;
$bw="bw"+$drivingSystem+"_"+$drivingAttr;	
if (`objExists $bw`)
	$driveSource=$bw+".output";
$tempString=`listConnections -scn 1 -s 0 -d 1 -type animCurve $driveSource`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "SDK*"` || `gmatch $tempString[$i] "bw*"`)
		$animCurves[size($animCurves)]=$tempString[$i];

return $animCurves;
}

global proc asDsGetName ()
{
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global float $asDSAttrMin;
global float $asDSAttrMax;
global int $asDSMirror;
global int $asDSAngle;
$asDSAttrName=`textField -q -tx asDSAttrNameTextField`;
if (`textField -q -m asDSObjNameTextField`)
	$asDSObjName=`textField -q -tx asDSObjNameTextField`;
else
	$asDSObjName=`optionMenu -q -v asDSObjNameOptionMenu`;
$asDSAttrHasMin=1;
$asDSAttrHasMax=1;
$asDSAttrSoftLimits=1;
$asDSAttrMin=0;
$asDSAttrMax=10;
if (`checkBox -q -ex asDSAttrHasMin`) $asDSAttrHasMin=`checkBox -q -v asDSAttrHasMin`;
if (`checkBox -q -ex asDSAttrHasMax`) $asDSAttrHasMax=`checkBox -q -v asDSAttrHasMax`;
if (`checkBox -q -ex asDSAttrSoftLimits`) $asDSAttrSoftLimits=`checkBox -q -v asDSAttrSoftLimits`;
if (`floatField -q -ex asDSAttrMin`) $asDSAttrMin=`floatField -q -v asDSAttrMin`;
if (`floatField -q -ex asDSAttrMax`) $asDSAttrMax=`floatField -q -v asDSAttrMax`;
$asDSMirror=`checkBox -q -v asDSMirrorCheckBox`;
$asDSAngle=`checkBox -q -v asDSAngleCheckBox`;
}

global proc string asEnsureBlendWeighted (string $sdkDriven)
{
int $isFaceControl;
string $obj,$attr,$blendWeighted;
string $tempString[];

tokenize $sdkDriven "." $tempString;
$obj=$tempString[0];
$attr=$tempString[1];
if (size($tempString)>2)
	$attr+="."+$tempString[2];

if ($attr=="tx") $attr="translateX";
if ($attr=="ty") $attr="translateY";
if ($attr=="tz") $attr="translateZ";
if ($attr=="rx") $attr="rotateX";
if ($attr=="ry") $attr="rotateY";
if ($attr=="rz") $attr="rotateZ";
if ($attr=="sx") $attr="scaleX";
if ($attr=="sy") $attr="scaleY";
if ($attr=="sz") $attr="scaleZ";

if (`objExists FaceAllSet`)
	if (`sets -im FaceAllSet $obj`)
		$isFaceControl=1;
if (`objExists FaceBuildingSets`)
	$isFaceControl=1;

$blendWeighted=`substituteAllString ($obj+"."+$attr) "." "_"`;
$blendWeighted=`substituteAllString $blendWeighted "[" "_"`;
$blendWeighted=`substituteAllString $blendWeighted "]" "_"`;
$blendWeighted="bw"+ $blendWeighted;
if (`gmatch $sdkDriven "bw*"` && `objectType $obj`=="blendWeighted")
	$blendWeighted=$obj;
if (!`objExists $blendWeighted`)
	{
	createNode -n $blendWeighted blendWeighted;
	if ($isFaceControl && `objExists FaceAllSet`)
		if (`sets -im FaceAllSet $obj`)//Add to AllSet only if controller is already in AllSet, (so not for CustomControllers)
			sets -add FaceAllSet $blendWeighted;
	if (!$isFaceControl && `objExists AllSet`)
		if (`sets -im AllSet $obj`)//Add to AllSet only if controller is already in AllSet, (so not for CustomControllers)
			sets -add AllSet $blendWeighted;

	if (!`objExists asEnsureOutputBlendWeighted`)
		{
		//preserve existing input, by adding to th bw
		$tempString=`listConnections -s 1 -d 0 -p 1 ($obj+"."+$attr)`;
		if ($tempString[0]!="")
			connectAttr -f $tempString[0] ($blendWeighted+".input[0]");
		connectAttr -f ($blendWeighted+".output") ($obj+"."+$attr);
		}
	else
		{
		//changing direct connect to OutputBlendWeighted to SDK
//		asFaceBsSdk ($obj+"."+$attr) 1 ($blendWeighted+".input[0]") 1;
		connectAttr -f ($obj+"."+$attr) ($blendWeighted+".input[0]");
		}
	}

//outputBW might have existed (due to custom DS have been deleted). so just connect
if (`objExists asEnsureOutputBlendWeighted` && !`isConnected -ignoreUnitConversion ($obj+"."+$attr) ($blendWeighted+".input[0]")`)
	connectAttr -f ($obj+"."+$attr) ($blendWeighted+".input[0]");
return $blendWeighted;
}

global proc string asEnsureOutputBlendWeighted (string $sdkDriven)
{
if (!`objExists asEnsureOutputBlendWeighted`)
	createNode -n asEnsureOutputBlendWeighted transform;
string $blendWeighted=`asEnsureBlendWeighted $sdkDriven`;
delete asEnsureOutputBlendWeighted;
return $blendWeighted;
}

global proc string asCtrlToBw (string $ctrl)
{
string $bw=$ctrl;

if (`gmatch $bw "*[.]t[x-z]"`)
	{
	$bw=`substitute "[.]tx" $bw ".translateX"`;
	$bw=`substitute "[.]ty" $bw ".translateY"`;
	$bw=`substitute "[.]ty" $bw ".translateZ"`;
	}
if (`gmatch $bw "*[.]r[x-z]"`)
	{
	$bw=`substitute "[.]rx" $bw ".rotateX"`;
	$bw=`substitute "[.]ry" $bw ".rotateY"`;
	$bw=`substitute "[.]ry" $bw ".rotateZ"`;
	}
if (`gmatch $bw "*[.]s[x-z]"`)
	{
	$bw=`substitute "[.]sx" $bw ".scaleX"`;
	$bw=`substitute "[.]sy" $bw ".scaleY"`;
	$bw=`substitute "[.]sy" $bw ".scaleZ"`;
	}
$bw="bw"+`substitute "[.]" $bw "_"`;

return $bw;
}

global proc asEnsureSDKcurvesNamed ()
{
int $isFaceControl;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];
string $newName;

$tempString=`ls -type transform "*SDK*_*"`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`ls -l $tempString[$i]`;
	if (!`gmatch $tempString2[0] "*|MotionSystem|*"` && !`gmatch $tempString2[0] "*|FaceMotionSystem|*"`)
		continue;
	if (`gmatch $tempString2[0] "*|MotionSystem|*"`) $isFaceControl=0;
	if (`gmatch $tempString2[0] "*|FaceMotionSystem|*"`) $isFaceControl=1;

	$tempString2=`listConnections -scn 1 -s 1 -d 0 $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		$tempString3=`listConnections -scn 1 -s 1 -d 0 $tempString2[$y]`;
		for ($z=0;$z<size($tempString3);$z++)
			{
			if (!`gmatch $tempString3[$z] "animCurve*"`)
				continue;
			$tempString4=`listConnections -scn 1 -p 1  -d 1 -s 0 ($tempString2[$y]+".output")`;
			$newName=`substitute "[.]" $tempString4[0] "_"`;
			rename $tempString3[$z] $newName;

			if ($isFaceControl && `objExists FaceAllSet`)
				if (`sets -im FaceAllSet $tempString[$i]`)//Add to AllSet only if controller is already in AllSet, (so not for CustomControllers)
					sets -add FaceAllSet $newName;
			if (!$isFaceControl && `objExists AllSet`)
				if (`sets -im AllSet $tempString[$i]`)//Add to AllSet only if controller is already in AllSet, (so not for CustomControllers)
					sets -add AllSet $newName;
			}
		}
	}
}

global proc asDsOptimizeControllers ()
{
string $sel[]=`ls -sl`;
int $numChar;
int $opm=`asGetOpm`;
float $dist,$maxDist;
float $pos[3],$pos2[3];
string $constraintTo,$deformJoint,$rlaChild,$endJoint,$objectType;
string $bws[],$tempString[],$animCurves[],$allDrivenObjs[],$allDrivenDeformJoints[],$longNames[],$parents[],$drivingSystems[];
createNode -n tempSamplerOffset transform;
createNode -n tempSampler -p tempSamplerOffset transform;

if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($a=0;$a<size($drivingSystems);$a++)
	{
	//only once per DS
	if (`attributeExists optimizedDS $drivingSystems[$a]`)
		continue;
	addAttr -k 0 -ln optimizedDS -at bool -dv 1 $drivingSystems[$a];

	$constraintTo="";
	$tempString=`listConnections -s 1 -d 0 ($drivingSystems[$a]+".tx")`;
	if ($tempString[0]!="" && `objectType $tempString[0]`=="parentConstraint")
		delete $tempString[0];
	asLockAttr $drivingSystems[$a] 0 0 0 1;

	//Find common ancestors
	clear $allDrivenDeformJoints;
	clear $longNames;
	$animCurves=`listConnections -s 0 -d 1 -type animCurve $drivingSystems[$a]`;
	$bws=`listConnections -s 0 -d 1 -type blendWeighted $drivingSystems[$a]`;
	for ($i=0;$i<size($bws);$i++)
		{
		$tempString=`listConnections -s 0 -d 1 -type animCurve $bws[$i]`;
		$animCurves=`stringArrayCatenate $animCurves $tempString`;
		}
	if (`gmatch $tempString[0] "bw*"`)
		$animCurves=`listConnections -s 0 -d 1 -type animCurve $tempString[0]`;
	for ($i=0;$i<size($animCurves);$i++)
		{
		//find $deformJoint from $animCurves ( does not work on nested DS )
		tokenize $animCurves[$i] "_" $tempString;
		$numChar=`size $animCurves[$i]` - `size($tempString[size($tempString)-1])` - 1;
		$allDrivenObjs[$i]=$animCurves[$i];
		if (`gmatch $animCurves[$i] "SDK*"`)
			$allDrivenObjs[$i]=`substring $animCurves[$i] 4 $numChar`;
		if (`gmatch $allDrivenObjs[$i] "[0-9]*"`)
			$allDrivenObjs[$i]=`substring $allDrivenObjs[$i] 2 99`;
		$objectType=`objectType $allDrivenObjs[$i]`;
		if ($objectType!="joint" && $objectType!="transform")
			continue;
		$deformJoint=$allDrivenObjs[$i];
		if (`gmatch $allDrivenObjs[$i] "FK*"`)
			$deformJoint=`substitute "FK" $allDrivenObjs[$i] ""`;
		if (`objExists $deformJoint`)
			if (!`stringArrayCount $deformJoint $allDrivenDeformJoints`)
				$allDrivenDeformJoints[size($allDrivenDeformJoints)]=$deformJoint;
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$tempString=`ls -l $allDrivenDeformJoints[$i]`;
		$longNames[$i]=$tempString[0];
		select $drivingSystems[$a];
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 1 0 $allDrivenDeformJoints[$i] $drivingSystems[$a];
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		tokenize $longNames[$i] "|" $parents;
		for ($y=size($parents)-2;$y>-1;$y--)
			{
			$numOthersHaveThisParent=0;
			for ($z=0;$z<size($longNames);$z++)
			if (`gmatch $longNames[$z] ("*|"+$parents[$y]+"|*")`)
				$numOthersHaveThisParent++;
			if ($numOthersHaveThisParent==size($longNames))
				{
				$constraintTo=$parents[$y];
				$i=999;$y=-999;$z=999;
				}
			}
		}

	if ($constraintTo=="")
		{
		asLockAttr $drivingSystems[$a] 1 1 1 1;
		continue;
		}

	delete `parentConstraint $drivingSystems[$a] tempSamplerOffset`;
	$pos=`xform -q -ws -t $constraintTo`;
	$maxDist=0;
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$endJoint=$allDrivenDeformJoints[$i];
		$rlaChild=`asRlaChild $allDrivenDeformJoints[$i]`;
		if ($rlaChild!="")
			$endJoint=$rlaChild;
		$pos2=`xform -q -ws -t $endJoint`;
		$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		if ($dist>$maxDist)
			$maxDist=$dist;
		delete `pointConstraint $endJoint tempSampler`;
		}
	if ($maxDist<0.01) $maxDist=0.5;

	delete `pointConstraint $constraintTo $drivingSystems[$a]`;
	if (`objExists ($drivingSystems[$a]+"_aimConstraint1")`)
		delete ($drivingSystems[$a]+"_aimConstraint1");
	setAttr -type float3 ($drivingSystems[$a]+".s") ($maxDist*1.2) ($maxDist*0.5) 1;
	makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $drivingSystems[$a];
	if ($opm)
		asParentConstraint $constraintTo $drivingSystems[$a] "-mo";
	else
		parentConstraint -mo $constraintTo $drivingSystems[$a];

	asLockAttr $drivingSystems[$a] 1 1 1 1;
	}
if (`objExists tempSamplerOffset`)
	delete tempSamplerOffset;

select $sel;
}

global proc asDsCreateController (string $objName, string $drivenObjs[])
{
int $isChildOfOtherDriven;
float $scale;
float $pos1[],$pos2[];
string $tempString[],$tempString2[];
string $objectType,$deformJoint,$rlaChild,$restorePoseCmd;
string $constraintTo="Root_M";

$tempString=`circle -n $objName -c 0 0 0 -nr 0 0 1 -sw 180 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
$objName=$tempString[0];
scale -r -1 1 1 ($objName+".cv[0:10]");
sets -add AllSet $objName;
sets -add AllSet ($objName+"Shape");
sets -add ControlSet $objName;
setAttr ($objName+"Shape.overrideEnabled") 1;
setAttr ($objName+"Shape.overrideColor") 17;
if (!`objExists DrivingSystem`)
	{
	createNode -n DrivingSystem -p MotionSystem transform;
	sets -add AllSet DrivingSystem;
//	addAttr -m -ln otherDsDrivers -attributeType message DrivingSystem;
	}
if (!`isConnected Main.drvSysVis DrivingSystem.v`)
	connectAttr Main.drvSysVis DrivingSystem.v;
parent $objName DrivingSystem;

$deformJoint=$drivenObjs[0];
if (`gmatch $drivenObjs[0] "FK*"`)
$deformJoint=`substitute "FK" $drivenObjs[0] ""`;
//since $drivenObjs[0] could be a blendWeighted (nested DrivingSystem), we use Root
$objectType=`objectType $deformJoint`;
if ($objectType!="joint" && $objectType!="transform")
	$deformJoint="Root_M";
if (`objExists $deformJoint`)
	$constraintTo=$deformJoint;
asAlign $objName $deformJoint 1 1 0 0;
$rlaChild=`asRlaChild $deformJoint`;

if (`objExists $rlaChild`)
	{
	$pos1=`xform -q -ws -t $deformJoint`;
	$pos2=`xform -q -ws -t $rlaChild`;
	$scale=`mag<<$pos2[0]-$pos1[0],$pos2[1]-$pos1[1],$pos2[2]-$pos1[2]>>`;
	setAttr -type float3 ($objName+".s") $scale $scale $scale;
//	scale -r $scale $scale $scale ($objName+".cv[0:10]");
	}

$restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`) asGoToBuildPose bodySetup;
//if (`objExists ($objName+"_pointConstraint1")`)
//	delete ($objName+"_pointConstraint1");
if (`objExists $constraintTo`)
	parentConstraint -mo $constraintTo $objName;
eval($restorePoseCmd);
asLockAttr $objName 1 1 1 1;
}

global proc asCreateAngleAttrs (string $joint)
{
string $sel[]=`ls -sl`;
string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
float $charHeight=`asgetCharHeight`;
float $posNegMult;
int $sideFactor=1;
if (`gmatch $joint "*_L"`)
	$sideFactor=-1;
string $FKjoint=$joint;
if (`objExists ("FK"+$joint)`)
	$FKjoint="FK"+$joint;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $RGB[]={"R","G","B"};
string $posNegs[]={"Pos","Neg"};
string $absPriAxis=`asGetAxis primary   $joint Main 1`;
string $absSecAxis=`asGetAxis secondary $joint Main 1`;
string $absTerAxis=`asGetAxis tertiary  $joint Main 1`;
string $loc,$endLoc;

for ($i=0;$i<size($XYZ);$i++)
	{
	addAttr -k 1 -ln ("angle"+$XYZ[$i]) -at double $joint;
	addAttr -k 0 -ln ("angle"+$XYZ[$i]) -at double $FKjoint;
	setAttr -e -channelBox true ("FK"+$joint+".angle"+$XYZ[$i]);
	connectAttr -f ($joint+".angle"+$XYZ[$i]) ($FKjoint+".angle"+$XYZ[$i]);
	}
if (!`objExists AngleSystem`)
	{
	createNode -n AngleSystem -p MotionSystem transform;
	setAttr AngleSystem.inheritsTransform 0;
	}

string $tempString[]=`listRelatives -p $joint`;
string $parent=$tempString[0];

createNode -n ($joint+"AngleSamplerBaseParent") -p AngleSystem transform;
createNode -n ($joint+"AngleSamplerBase") -p ($joint+"AngleSamplerBaseParent") transform;
pointConstraint $parent ($joint+"AngleSamplerBaseParent");
orientConstraint $parent ($joint+"AngleSamplerBaseParent");
delete `orientConstraint $joint ($joint+"AngleSamplerBase")`;
pointConstraint $joint ($joint+"AngleSamplerBase");

createNode -n ($joint+"AngleSamplerRotate") -p ($joint+"AngleSamplerBase") transform;

$endLoc=$joint+"AngleSamplerEnd";
spaceLocator -n $endLoc;
parent $endLoc ($joint+"AngleSamplerRotate");
setAttr -type float3 ($endLoc+".t") 0 0 0;
setAttr ($endLoc+".translate"+$absPriAxis) ($sideFactor*0.7071104);
setAttr -type float3 ($endLoc+".r") 0 0 0;
setAttr -type float3 ($endLoc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);

for ($i=0;$i<size($XYZ);$i++)
	{
	if ($XYZ[$i]==$absPriAxis)
		continue;
	for ($y=0;$y<size($posNegs);$y++)
		{
		$posNegMult=1;
		if ($y==1) $posNegMult=-1;
		$loc=$joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y];
		setAttr ($joint+"AngleSamplerRotate.rotate"+$XYZ[$i]) (90*$posNegMult);
		duplicate -n $loc $endLoc;
		parent $loc ($joint+"AngleSamplerBase");
		setAttr ($joint+"AngleSamplerRotate.rotate"+$XYZ[$i]) 0;
		}
	}

orientConstraint $joint ($joint+"AngleSamplerRotate");

for ($y=0;$y<size($posNegs);$y++)
	{
	createNode -n ($joint+"OneMinus"+$posNegs[$y]) plusMinusAverage;
	setAttr ($joint+"OneMinus"+$posNegs[$y]+".operation") 2;
	setAttr -type float3 ($joint+"OneMinus"+$posNegs[$y]+".input3D[0]") 1 1 1;
	}
//Y & Z
for ($i=0;$i<size($XYZ);$i++)
	{
	if ($XYZ[$i]==$absPriAxis)
		continue;
	for ($y=0;$y<size($posNegs);$y++)
		{
		createNode -n ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]) distanceBetween;
		connectAttr -f ($joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y]+"Shape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point1");
		connectAttr -f ($joint+"AngleSamplerEndShape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point2");
		connectAttr -f ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".distance") ($joint+"OneMinus"+$posNegs[$y]+".input3D[1].input3D"+$xyz[$i]);
		}
	createNode -n ($joint+"AngleCondition"+$XYZ[$i]) condition;
	setAttr ($joint+"AngleCondition"+$XYZ[$i]+".operation") 2;
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".firstTerm");
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".secondTerm");
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".colorIfTrue"+$RGB[$i]);
	createNode -n ($joint+"AngleInverse"+$XYZ[$i]) unitConversion;
	setAttr ($joint+"AngleInverse"+$XYZ[$i]+".conversionFactor") -1;
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleInverse"+$XYZ[$i]+".input");
	connectAttr -f ($joint+"AngleInverse"+$XYZ[$i]+".output") ($joint+"AngleCondition"+$XYZ[$i]+".colorIfFalse"+$RGB[$i]);
	connectAttr -f ($joint+"AngleCondition"+$XYZ[$i]+".outColor.outColor"+$RGB[$i]) ($joint+".angle"+$XYZ[$i]);
	}

//TwistAxis
createNode -n ($joint+"AngleTwistMultiplyDivide") multiplyDivide;
setAttr ($joint+"AngleTwistMultiplyDivide.operation") 2;
setAttr -type float3 ($joint+"AngleTwistMultiplyDivide.input2") 90 1 1;
if (`objExists ("TwistBalancer"+$joint)`) // tapping into existing twist system
	connectAttr -f ("TwistBalancer"+$joint+".rotate"+$absPriAxis) ($joint+"AngleTwistMultiplyDivide.input1.input1"+$absPriAxis);
else // create twist deriver
	{
	select ($joint+"AngleSamplerBase");
	joint -n ($joint+"AngleTwistUnTwist");
	joint -n ($joint+"AngleTwistUnTwistEnd");
	setAttr ($joint+"AngleTwistUnTwistEnd.translate"+$absPriAxis) ($charHeight/12.0*$sideFactor);
	select ($joint+"AngleTwistUnTwist");
	joint -n ($joint+"AngleTwistBalancer");
	orientConstraint -mo ($joint) ($joint+"AngleTwistBalancer");
	ikHandle -n ($joint+"AngleTwistUnTwistIK") -ns 2 -sol "ikRPsolver" -sj ($joint+"AngleTwistUnTwist") -ee ($joint+"AngleTwistUnTwistEnd");
	parent ($joint+"AngleTwistUnTwistIK") ($joint+"AngleSamplerBase");
	parentConstraint -mo $joint ($joint+"AngleTwistUnTwistIK");
	createNode -n ($joint+"AngleTwistUnTwistPoleVec") -p ($joint+"AngleSamplerBase") transform;
	poleVectorConstraint ($joint+"AngleTwistUnTwistPoleVec") ($joint+"AngleTwistUnTwistIK");
	connectAttr -f ($joint+"AngleTwistBalancer.rotate"+$absPriAxis) ($joint+"AngleTwistMultiplyDivide.input1.input1"+$absPriAxis);
	}
connectAttr ($joint+"AngleTwistMultiplyDivide.output.output"+$absPriAxis) ($joint+".angle"+$absPriAxis);

setAttr -l 1 ($joint+"AngleSamplerBaseParent.v") 0;
eval($restorePoseCmd);
select $sel;
}

global proc string asGetBlendedAttributeName (string $drivers[])
{
string $tempString[],$driverObjs[],$driverAttrs[];
string $attr;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$attr+=$driverAttrs[$i];
	if (`getAttr $drivers[$i]`>=0)
		$attr+="Pos";
	else
		$attr+="Neg";
	if ($i<size($drivers)-1)
		$attr+="_";
	}
return $attr;
}

global proc string asCreateCustomBlendedAttribute (string $drivers[], string $attrName)
{
float $driverValues[];
string $sel[]=`ls -sl`;
string $tempString[],$driverObjs[],$driverAttrs[],$bwDriverAttrs[];
string $setAnglesCmd,$attr,$clp,$mpd,$pma,$sr;

if ($attrName=="")
	$attr=`asGetBlendedAttributeName $drivers`;
else
	$attr=$attrName;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$driverValues[$i]=`getAttr $drivers[$i]`;

	$tempString[0]="FK"+`substitute "angle" $drivers[$i] "rotate"`;
	if (`objExists $tempString[0]`)
		$setAnglesCmd+="setAttr "+$tempString[0]+" "+`getAttr $tempString[0]`+";";
	}

if (`attributeExists $attr $driverObjs[0]`)
	{
	select $sel;
	return $attr;
	}

addAttr -k 0 -ln $attr -at double $driverObjs[0];
setAttr -e -channelBox true ($driverObjs[0]+"."+$attr);
if (!`gmatch $driverObjs[0] "FK*"` && `objExists ("FK"+$driverObjs[0])`)
	{
	addAttr -k 0 -ln $attr -at double ("FK"+$driverObjs[0]);
	setAttr -e -channelBox true ("FK"+$driverObjs[0]+"."+$attr);
	connectAttr ($driverObjs[0]+"."+$attr) ("FK"+$driverObjs[0]+"."+$attr);
	}

$sr=$driverObjs[0]+$attr+"SetRange";
$clp=$driverObjs[0]+$attr+"Clamp";
$pma=$driverObjs[0]+$attr+"PlusMinusAverage";
$mpd=$driverObjs[0]+$attr+"MPD";

createNode -n $mpd multiplyDivide;
//connectAttr ($driverObjs[0]+"."+$driverAttrs[0]) ($mpd+".input1X");
//connectAttr ($driverObjs[0]+"."+$driverAttrs[1]) ($mpd+".input1Y");
//changed to use bw
$bwDriverAttrs[0]=`asEnsureOutputBlendWeighted ($driverObjs[0]+"."+$driverAttrs[0])`;
$bwDriverAttrs[1]=`asEnsureOutputBlendWeighted ($driverObjs[0]+"."+$driverAttrs[1])`;
connectAttr ($bwDriverAttrs[0]+".output") ($mpd+".input1X");
connectAttr ($bwDriverAttrs[1]+".output") ($mpd+".input1Y");

if ($driverValues[0]==-1)//first driver neg
	setAttr ($mpd+".input2X") -1;
if ($driverValues[1]==-1)//second driver neg
	setAttr ($mpd+".input2Y") -1;

createNode -n $pma plusMinusAverage;
connectAttr ($mpd+".outputX") ($pma+".input1D[0]");
connectAttr ($mpd+".outputY") ($pma+".input1D[1]");

createNode -n $sr setRange;
connectAttr -f ($pma+".output1D") ($sr+".valueX");
setAttr -type float3 ($sr+".max") 100 100 100;
setAttr ($sr+".max") -type float3 100 100 100;
setAttr ($sr+".oldMax") -type float3 200 200 200;

addAttr -k 1 -ln dvX -at double -dv `getAttr ($driverObjs[0]+"."+$driverAttrs[0])` $sr;
addAttr -k 1 -ln dvY -at double -dv `getAttr ($driverObjs[0]+"."+$driverAttrs[1])` $sr;

addAttr -ln setAnglesCmd -dt "string" $sr;
setAttr -type "string" ($sr+".setAnglesCmd") $setAnglesCmd;

//connectAttr -f ($sr+".outValueX") ($driverObjs[0]+"."+$attr);
//clamp
createNode -n $clp clamp;
connectAttr ($sr+".outValueX") ($clp+".inputR");
addAttr -k 0 -ln ($attr+"MaxValue") -at double -dv 10 $driverObjs[0];
connectAttr ($driverObjs[0]+"."+$attr+"MaxValue") ($clp+".maxR");
connectAttr ($clp+".outputR") ($driverObjs[0]+"."+$attr);	

asEnsureOutputBlendWeighted ($driverObjs[0]+"."+$attr);

select $sel;
return $attr;
}

global proc string[] asSetBlendedAttribute (string $driverObj, string $driverAttr, float $value, int $getDriversMode)
{
string $tempString[],$drivers[];
string $setAnglesCmd,$setRange,$pma,$mpd;
int $connectedToMultDiv=1;
string $plug=$driverObj+"."+$driverAttr;
float $dvs[];
while ($connectedToMultDiv)
	{
	$connectedToMultDiv=0;
	$tempString=`listConnections -s 1 -d 0 -scn 1 $plug`;
	string $nodeA=$tempString[0];
	if(size($tempString)>0)
		{
		if (`objectType $nodeA`=="multiplyDivide")
			{
			$connectedToMultDiv=1;
			$plug=$nodeA+".input1.input1X";
			if (`attributeExists setAnglesCmd $nodeA`)
				$setAnglesCmd=`getAttr ($nodeA+".setAnglesCmd")`;
			}
		else if (`objectType $nodeA`=="setRange")
			{
			$setRange=$nodeA;
			$dvs[size($dvs)]=`getAttr ($setRange+".dvX")`;
			$dvs[size($dvs)]=`getAttr ($setRange+".dvY")`;
			$tempString=`listConnections -s 1 -d 0 -scn 1 ($setRange+".valueX")`;
			$pma=$tempString[0];

			$tempString=`listConnections -s 1 -d 0 -scn 1 ($pma+".input1D[0]")`;
			$mpd=$tempString[0];

			$tempString=`listConnections -s 1 -d 0 -scn 1 ($mpd+".input1X")`;
			if (`objectType $tempString[0]`=="blendWeighted")
				$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($tempString[0]+".input[0]")`;
			else
				$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($mpd+".input1X")`;
			$drivers[size($drivers)]=$tempString[0];
		
			$tempString=`listConnections -s 1 -d 0 -scn 1 ($mpd+".input1Y")`;
			if (`objectType $tempString[0]`=="blendWeighted")
				$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($tempString[0]+".input[0]")`;
			else
				$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($mpd+".input1Y")`;
			$drivers[size($drivers)]=$tempString[0];
			}
		}
	
	}

//For inbetweens, just find the values were all inputs are equal, and sum up to total
if ($value<1)
	for ($i=0;$i<size($dvs);$i++)
		{
		float $temp=`pow $dvs[$i] 2`;
		$dvs[$i]=`sqrt($temp*$value)`;
		}

for ($i=0;$i<size($drivers);$i++)
	if (!$getDriversMode)
		{
		string $setDriver=$drivers[$i];
		if (`gmatch $setDriver "*[.]angle*"`)// blended angles
			eval $setAnglesCmd;
		else
			{
			string $FKDriver="FK"+$drivers[$i];
			if (`objExists $FKDriver`)
				$setDriver=$FKDriver;
			setAttr $setDriver $dvs[$i];
			}
		}

$drivers=`sort $drivers`;
return $drivers;
}

global proc asCorrectiveShapesBatchEdit ()
{
int $num;
string $tempString[];
asPopulateCorrectivePopupMenu Edit;
string $popupMenu="asEditCorrectiveShapesPopupMenu";
string $l1,$l2,$l3,$l4,$l5;
string $lev1s[],$lev2s[],$lev3s[],$lev4s[],$lev5s[];

$lev1s=`popupMenu -q -ia $popupMenu`;
for ($i=0;$i<size($lev1s);$i++)
	{
	$l1=`menuItem -q -l $lev1s[$i]`;
	$lev2s=`menu -q -itemArray $lev1s[$i]`;
	for ($y=0;$y<size($lev2s);$y++)
		{
		$l2=`menuItem -q -l $lev2s[$y]`;
		$lev3s=`menu -q -itemArray $lev2s[$y]`;
		for ($z=0;$z<size($lev3s);$z++)
			{
			$l3=`menuItem -q -l $lev3s[$z]`;
			$lev4s=`menu -q -itemArray $lev3s[$z]`;
			for ($a=0;$a<size($lev4s);$a++)
				{
				$l4=`menuItem -q -l $lev4s[$a]`;
				$lev5s=`menu -q -itemArray $lev4s[$a]`;
				for ($b=0;$b<size($lev5s);$b++)
					{
					$l5=`menuItem -q -l $lev5s[$b]`;
					evalEcho ("asEditCorrectiveShape "+$l1+" "+$l2+" "+$l3+" "+$l5);
					refresh;
					asConnectCorrective;
					$num++;
					}
				}
			}
		}
	}
asGoToBuildPose bodySetup;
select -cl;
print ("// Batch Edited :"+$num+" Corrective Shapes.\n");
}

global proc string asCreateCorrectiveShapes ()
{
global int $asSkipConfirm;
source bsMultiIndexForTarget;
int $useSoftMods=`checkBox -q -v asCorrectiveShapesUseSoftModsCheckBox`;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[];
if(size($sel)==0)
	error "No mesh selected, select geometry on your character";
if (size($sel)>1)
	error "More than 1 object selected, Only 1 object must be selected";
if (`gmatch $sel[0] "*__*"`)
	error "Selected object IS a Corrective Shape. Select geometry on your character";
if ($sel[0]!="")
	if (`objectType $sel[0]`=="mesh")
		$sel=`listRelatives -p $sel[0]`;
$tempString=`listRelatives -ni -s $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not geometry";
if (`objectType $tempString[0]`!="mesh")
	error "Selected object is not a mesh";

string $controlSetMembers[];
if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;

string $drivers[],$nonAngleDrivers[],$keyableAttr[];
string $objAttr,$corrective;
float $poseValue,$currentValue;
//Find driving attribute(s)
string $buildPoseCmds[],$runCmds[];
//get $buildPoseCmds
if (`objExists ControlSet`)
	$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}
string $runObjAttrs[],$checkObjAttr[];
float $runValues[];
for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<2;$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;//default 15=trs
			if (size($tempString2)==11) $loopTimes=6;//11=tr
			if (size($tempString2)==7) $loopTimes=3;//7=t
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKExtra*"`)//must filter FKExtraJaw_M & FKExtraEye_*, so just filter all Extra
				continue;
			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;
			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$drivers[size($drivers)]=$checkObjAttr[$z];
			}
		}
	}
if (size($drivers)==0)
	error ("Found no driving attribute, all values are in Build-Pose");

if ($useSoftMods && !`objExists CorrectiveSoftModsSystem`)
	{
	createNode -n CorrectiveSoftModsSystem -p MotionSystem transform;
	createNode -n CorrectiveSoftMods -p CorrectiveSoftModsSystem transform;
	setAttr -l 1 CorrectiveSoftMods.v 0;
	}
if (!$useSoftMods && `objExists CorrectiveSoftModsSystem`)
	{
	if (`confirmDialog -t "Not Using SoftMods"
		-m "This will deleted all previously stored \"SoftMod Correctives\" information."
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`!="OK")
			return "";
	delete CorrectiveSoftModsSystem;
	}

//For twistDistributed limbs, if not using "Angle", then rx is not excepted, neighter is any mix
if (!`checkBox -q -v asCorrectiveShapesAngleCheckBox`)
	{
	if (`gmatch $drivers[0] "*[.]rotateX"` || `size($drivers)`>1)
		{
		tokenize $drivers[0] "[.]" $tempString;
		int $numChar=size($tempString[0]);
		string $fitJoint=`substring $tempString[0] 3 ($numChar-2)`;
		if (`objExists $fitJoint`)
			if (`attributeExists twistJoints $fitJoint` || `attributeExists inbetweenJoints $fitJoint`)
				{
				warning "Due to \"twistJoints\" or \"inbetweenJoints\" beeing used, rotation values will not work, Now turning On \"Angle\" rotations.";
				checkBox -e -v 1 asCorrectiveShapesAngleCheckBox;
				asCreateCorrectiveShapes;
				return "";
				}
		}
	}

for ($i=0;$i<size($drivers);$i++)
	{
	string $nonFKDriver=`substitute "FK" $drivers[$i] ""`;
	if (`objExists $nonFKDriver`)
//		if (!`gmatch $drivers[0] "FK*[.]translate*"`) //(FK*.t* dont have zero default values)
			$drivers[$i]=$nonFKDriver;
	}

//Ensure OPM CompatibleDriverAttr
if (!`checkBox -q -v asCorrectiveShapesAngleCheckBox`)
	for ($i=0;$i<size($drivers);$i++)
		{
		tokenize $drivers[$i] "." $tempString;
		$tempString[1]=`asOPMCompatibleDriverAttr $tempString[0] $tempString[1]`;
		$drivers[$i]=$tempString[0]+"."+$tempString[1];
		}

tokenize $drivers[0] "[.]" $tempString;
string $deformObj=$sel[0];
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $directDriverAttr=$driverAttr;
float $dv=`getAttr $drivers[0]`;
float $idv=0;

$nonAngleDrivers=$drivers;

//angle driver
if (`checkBox -q -v asCorrectiveShapesAngleCheckBox`)
	if (`gmatch $driverAttr "rotate*"`)//rotation && !blended
		{
		if (!`attributeExists "angleX" $driverObj`)
			asCreateAngleAttrs $driverObj;

		//Max 90 degrees
		float $FKdv=`getAttr ("FK"+$drivers[0])`;
		if (abs($FKdv)>90)
			{
			warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
			if ($FKdv>0) $dv=90;
			if ($FKdv<0) $dv=-90;
			setAttr ("FK"+$drivers[0]) $dv;
			}
		for ($i=0;$i<size($drivers);$i++)
			{
			if (`gmatch $drivers[$i] "*[.]rotate*"`)
				{
				$drivers[$i]=`substitute "rotate" $drivers[$i] "angle"`;
				$driverAttr=`substitute "rotate" $driverAttr "angle"`;
				}
			$idv=$dv;
			$dv=`getAttr ($driverObj+"."+$driverAttr)`;
			if (`gmatch $driverAttr "*X"` && `objExists ("TwistBalancer"+$driverObj)`)
				{
				//$idv special case if RX from a twist-system
				$idv=`getAttr ("TwistBalancer"+$driverObj+"."+$directDriverAttr)`;
				}
			}
		//2 rotation attributes could be translated to 3 angle attributes
		string $XYZ[]={"X","Y","Z"};
		if (size($drivers)>1)
			for ($i=0;$i<size($drivers);$i++)
				{
				for ($y=0;$y<size($XYZ);$y++)
					{
					string $check=$driverObj+".angle"+$XYZ[$y];
					float $checkVal=`getAttr $check`;
					if (abs($checkVal)>0.001)
						if (!`stringArrayCount $check $drivers`)
							{
							$drivers[size($drivers)]=$check;
							$drivers=`sort $drivers`;
							}
					}
				}
		}

if (size($drivers)>1)
	{
	//We might have arrived back here from already created blendAttr
	if (`objExists BlendedCorrectiveDriver`)
		{
		$driverObj=`getAttr BlendedCorrectiveDriver.driverObj`;
		$driverAttr=`getAttr BlendedCorrectiveDriver.driverAttr`;
		$dv=`getAttr ($driverObj+"."+$driverAttr)`;
		}
	else
		{
		string $m="Create Corrective Shape from blend of these drivers?\n\n";
		for ($i=0;$i<size($drivers);$i++)
			{
			float $value=`getAttr $drivers[$i]`;
			$value=`asRoundOff $value 3`;
			$m+=$drivers[$i]+" = "+$value+"\n";
			}
		if (!$asSkipConfirm)
			if (`confirmDialog -t "Multiple Drivers Found"
				-m $m
				-b "OK" -b "Cancel" -db "Cancel"
				-ds "Cancel"`!="OK")
					return "";

		createNode -n BlendedCorrectiveDriver transform;
		addAttr -ln driverObj -dt "string" BlendedCorrectiveDriver;
		setAttr -type "string" BlendedCorrectiveDriver.driverObj $driverObj;
		addAttr -ln driverAttr -dt "string" BlendedCorrectiveDriver;
		setAttr -type "string" BlendedCorrectiveDriver.driverAttr $driverAttr;
		select $sel;

		asCreateCustomBlendedAttribute $drivers $driverAttr;
		asCreateCorrectiveShapes;
		if (`objExists BlendedCorrectiveDriver`)
			delete BlendedCorrectiveDriver;
		return "";
		}
	}

string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
$dv=`asRoundOff $dv 3`;

float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;

if (`objExists $attrCode`)
	error ("CorrectiveShapes for: \""+$attrCode+"\" already exists.");

if (size($drivers)==1 && !$asSkipConfirm)
	{
	string $dialog=`confirmDialog -t "Single Driver Found"
		-m ("Create Corrective Shape from this driver?\n\n"+$driverObj+"."+$driverAttr+" = "+$dv)
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
	if ($dialog!="OK")
		return "";
	}

asCorrectiveDuplicate $attrCode $sel[0];

addAttr -k 0 -ln CorrectiveShapes -at bool -dv 1 $attrCode;
addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

asUpdateButtonEnables;
return $attrCode;
}

global proc float asCorrectiveGetIV (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $iv=1;
string $bs=$deformObj+"Corrective";
if (!`objExists $bs`)
	return 1;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
float $maxKeyVal;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount ($driverObj+"__"+$driverAttr+"__"+$posNeg) $weights`)
	{
	$tempString=`listConnections ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
	float $keyXValues[]=`keyframe -q -fc $tempString[0]`;
	float $keyYValues[]=`keyframe -q -vc $tempString[0]`;
	float $xvalueAtOneY=$keyXValues[size($keyXValues)-1];
	for ($i=0;$i<size($keyYValues);$i++)
		if ($keyYValues[$i]==1)
			$xvalueAtOneY=$keyXValues[$i];

	$iv=$dv/$xvalueAtOneY;
	$iv=`asRoundOff $iv 3`;
	}
return $iv;
}

global proc asCorrectiveDuplicate (string $attrCode, string $source)
{
global string $gMainPane;
int $useSoftMods=`objExists CorrectiveSoftModsSystem`;
float $focalLength;
float $charHeight=`asgetCharHeight`;
float $bb[];
string $modelPanel,$correctiveSoftModsObject,$softModHandle,$softMod,$firstInChainSoftMod,$lastInChainSoftMod;
string $group="Group";
string $bs=$source+"Corrective";
string $tempString[],$tempString2[],$correctiveSoftModHandles[],$restoreCmds[];
string $historyNodes[]=`listHistory -pdo 1 -interestLevel 1 $source`;

if ($useSoftMods && `objExists $bs`) setAttr ($bs+".envelope") 0;
if ($source=="FaceCorrective")
	{
	$tempString=`listConnections FaceCorrective.originalDeformObj`;
	duplicate -n $attrCode $tempString[0];
	}
else
	duplicate -n $attrCode $source;
if ($useSoftMods && `objExists $bs`) setAttr ($bs+".envelope") 1;
asLockAttr $attrCode 0 0 0 0;
for ($i=0;$i<size($restoreCmds);$i++)
	eval($restoreCmds[$i]);
setAttr ($attrCode+".v") 1;
$tempString=`listRelatives -p $attrCode`;
if ($tempString[0]!="")
	parent -w $attrCode;
$tempString=`listRelatives -f -s $attrCode`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
$tempString=`listRelatives -f -s $attrCode`;
rename $tempString[0] ($attrCode+"Shape");

select $attrCode;

if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 0;

$tempString=`ls -sl -l $source`;
if (!`gmatch $tempString[0] "|Group|*"`)
	{
	setAttr ($source+".v") 0;
	if (!`attributeExists "correctiveShapeModeHidden" $group`)
		addAttr -ln "correctiveShapeModeHidden" -dt "string" $group;
	setAttr -type "string" ($group+".correctiveShapeModeHidden") $source;
	}

if ($useSoftMods)
	{
	if (`objExists ("CorrectiveSoftMods_"+$attrCode)`)
		$correctiveSoftModHandles=`listRelatives -c ("CorrectiveSoftMods_"+$attrCode)`;
	for ($i=0;$i<size($correctiveSoftModHandles);$i++)
		{
		$softModHandle=$correctiveSoftModHandles[$i];
		$softMod=`substitute "Handle" $softModHandle ""`;
		$tempString=`listConnections -s 1 -d 0 ($softMod+".input[0].inputGeometry")`;
		if ($tempString[0]=="")
			$firstInChainSoftMod=$softMod;
		$tempString=`listConnections -s 0 -d 1 ($softMod+".outputGeometry[0]")`;
		if ($tempString[0]=="")
			$lastInChainSoftMod=$softMod;
		parent -w $softModHandle;
		}

	if ($firstInChainSoftMod!="")
		{
		select $attrCode;
		$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
		$tempString2=`listConnections -s 1 -d 0 -shapes 1 ($tempString[0]+".input[0].inputGeometry")`;
		connectAttr ($tempString2[0]+".worldMesh") ($firstInChainSoftMod+".input[0].inputGeometry");
		connectAttr -f ($lastInChainSoftMod+".outputGeometry[0]") ($attrCode+".inMesh");
		delete $tempString[0];
		}

	select -cl;
//	SoftModTool;
	}
else
	SculptGeometryTool;

if (`headsUpDisplay -q -ex HUDCSMMode`)
	print ("headsUpDisplay HUDCSMMode already exists. skipping\n");
else
	{
	headsUpDisplay -s 2 -b 0 -bs "medium" -l "Corrective Shape Mode" -lfs "large" HUDCSMMode;
	scriptJob -runOnce true -e deleteAll "asExitCorrectiveMode";
	}
}

global proc asConnectCorrective ()
{
global string $gSelect;
global string $gMainProgressBar;
int $useSoftMods=`objExists CorrectiveSoftModsSystem`;
float $currentTime=`currentTime -q`;
string $correctiveShape,$softMod,$softModHandle,$softModSet,$wipSoftModHandle,$wipSoftMod,$softModGroup,$leftSoftModGroup,$sideCorrectiveShape,$mesh;
string $tangentType="spline";
string $sel[]=`ls -sl`;
string $tempString[],$history[],$existingTargets[],$restoreCmds[],$drivers[],$mirroredDrivers[],$wipSoftModHandles[];
string $rootLevelObjects[]=`ls -as`;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		$correctiveShape=$rootLevelObjects[$i];
if ($correctiveShape=="")
	error "Could not find the CorrectiveShape object in the scene";

if (size(`ls -type animCurve "asDSDriverEdit_*"`) && $currentTime!=30)
	error "Applying Corrective that has Test-Animation, but the Current Time is not set to 30. Make sure to go to Frame 30 before Applying";

int $softModNr;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
tokenize `substituteAllString $correctiveShape "__"  "|"` "|" $tempString;
string $deformObj=$tempString[0];
string $driverObj=$tempString[1];
string $driverAttr=$tempString[2];
$driverAttr=`asOPMCompatibleDriverAttr $driverObj $driverAttr`;
string $originalDeformObj=$deformObj;
if ($originalDeformObj=="FaceCorrective")
	{
	$tempString=`listConnections FaceCorrective.originalDeformObj`;
	$originalDeformObj=$tempString[0];
	}
float $dv=`getAttr ($correctiveShape+".driverValue")`;
float $idv=`getAttr ($correctiveShape+".indirectDriverValue")`;
float $value,$defaultValue;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
float $iv=`getAttr ($correctiveShape+".inbetweenValue")`;
int $deleteMode=`objExists DeleteCorrectiveShape`;
string $deltaShape=$driverObj+"__"+$driverAttr+"__"+$posNeg;
string $sdk=`asRemoveNameSpace $deformObj`+"Corrective_"+$deltaShape;
float $keyXValues[],$pos[],$pos2[],$foc[];
float $driverValues[],$mirroredDriverValues[],$rotates[];
if (`objExists $sdk`)
	$keyXValues=`keyframe -q -fc $sdk`;
if ($correctiveShape==$deformObj)
	error "Can not use itself as Corrective Shape, Select the Corrective Shape";
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;
int $isJoystick=0;
$tempString=`ls -l $driverObj`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isJoystick=1;
float $mirrorDv=$dv;
string $mirrorPosNeg=$posNeg;
if (($driverAttr=="translateX" && !$isJoystick) || (`gmatch $driverObj "FK*"` && `gmatch $driverAttr "translate*"`))
	{
	$mirrorDv=$dv*-1;
	if ($posNeg=="pos") $mirrorPosNeg="neg";
	if ($posNeg=="neg") $mirrorPosNeg="pos";
	}
int $doMirror=0;
string $mirrorDriverObj,$FKMirrorDriverObj,$mirrorDeltaShape,$mirrorSdk,$currentDriver,$inLoopSide;
string $side="_R";
string $mirrorDriverAttr=$driverAttr;
string $mirrorSide="_L";
if (`gmatch $driverObj "*_L"`)
	{
	$side="_L";
	$mirrorSide="_R";
	}

setToolTo $gSelect;

if (`checkBox -q -v asCorrectiveShapesMirrorCheckBox`)
	{
	$mirrorDriverObj=`substitute $side $driverObj $mirrorSide`;
	$mirrorDriverAttr=`asOPMCompatibleDriverAttr $mirrorDriverObj $driverAttr`;
	$FKMirrorDriverObj=`substitute $side $FKDriverObj $mirrorSide`;
	$mirrorDeltaShape=`substitute $side $deltaShape $mirrorSide`;
	if ($mirrorPosNeg!=$posNeg)
		$mirrorDeltaShape=`substitute $posNeg $mirrorDeltaShape $mirrorPosNeg`;
	$mirrorSdk=`substitute $side $sdk $mirrorSide`;

	if (`objExists $mirrorDriverObj` && $driverObj!=$mirrorDriverObj)
		{
		$doMirror=1;
		//angle attrs
		if (`gmatch $driverAttr "angle*"`)
			if (!`attributeExists "angleX" $mirrorDriverObj`)
				asCreateAngleAttrs $mirrorDriverObj;
		//blended attrs
		if (`gmatch $driverAttr "*_*"`)
			{
			$drivers=`asSetBlendedAttribute $driverObj $driverAttr 0 1`;
			for ($i=0;$i<size($drivers);$i++)
				{
				$driverValues[$i]=`getAttr $drivers[$i]`;
				$mirroredDriverValues[$i]=$driverValues[$i];
				$mirroredDrivers[$i]=`substitute $side $drivers[$i] $mirrorSide`;
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						$rotates=`getAttr ($FKDriverObj+".r")`;
						setAttr -type float3 ($FKDriverObj+".r") 0 0 0;
						}
					}
				else
					setAttr $drivers[$i] 0;
				if ((`gmatch $mirroredDrivers[$i] "*[.]translateX"` && !$isJoystick) || (`objExists ("FK"+$driverObj)` && `gmatch $mirroredDrivers[$i] "*[.]translate*"`))
					$mirroredDriverValues[$i]=$driverValues[$i]*-1;
				//temporary mirror blended pose
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						setAttr -type float3 ($FKMirrorDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
					}
				else
					setAttr $mirroredDrivers[$i] $mirroredDriverValues[$i];
				}
			//asCreateBlendedAttribute
			$mirrorDriverAttr=`asCreateCustomBlendedAttribute $mirroredDrivers ""`;
			$mirrorDeltaShape=$mirrorDriverObj+"__"+$mirrorDriverAttr+"__pos";
			//restore blended pose
			for ($i=0;$i<size($drivers);$i++)
				{
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						setAttr -type float3 ($FKMirrorDriverObj+".r") 0 0 0;
						setAttr -type float3 ($FKDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
						}
					}
				else
					{
					setAttr $mirroredDrivers[$i] 0;
					setAttr $drivers[$i] $driverValues[$i];					
					}
				}
			}
		}
	}


if ($useSoftMods)
	{
	$history=`listHistory -pdo 1 -interestLevel 1 $correctiveShape`;
	for ($i=0;$i<size($history);$i++)
		{
		if (`objectType $history[$i]`!="softMod")
			continue;
		$softMod=$history[$i];
		$tempString=`listConnections -s 1 -d 0 ($history[$i]+".matrix")`;
		$softModHandle=$tempString[0];
		if (!`objExists ("CorrectiveSoftMods_"+$correctiveShape)`)
			createNode -n ("CorrectiveSoftMods_"+$correctiveShape) -p CorrectiveSoftMods transform;
		parent $softModHandle ("CorrectiveSoftMods_"+$correctiveShape);
		}

	$tempString=`listRelatives -s -ni $correctiveShape`;
	$mesh=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 -p 1 ($mesh+".inMesh")`;
	if ($tempString[0]!="")//blank doing a Delete a Left
		disconnectAttr $tempString[0] ($mesh+".inMesh");

	select $correctiveShape;
	DeleteHistory;
	select -cl;
	}

$history=`listHistory -pdo 1 $deformObj`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
			setAttr ($history[$i]+".envelope") 0;
			$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
			}

//If Corrective on mesh that have "asFaceBS", then create separate "Corrective" mesh
$history=`listHistory -pdo 1 $deformObj`;
if (`stringArrayCount asFaceBS $history`)
	{
	if (!`objExists FaceCorrective`)
		{
		duplicate -n FaceCorrective $deformObj;
		$existingTargets=`listAttr -m asFaceBS.w`;
		blendShape -e -t $deformObj `size($existingTargets)` FaceCorrective 1 asFaceBS;
		addAttr -k 0 -ln CorrectiveShapes -at bool -dv 1 asFaceBS;
		setAttr asFaceBS.FaceCorrective 1;
		addAttr -longName originalDeformObj -attributeType message FaceCorrective;
		connectAttr ($deformObj+".message") FaceCorrective.originalDeformObj;
		$originalDeformObj=$deformObj;
		}
	$deformObj="FaceCorrective";
	}

duplicate -n $deltaShape $deformObj;
asLockAttr $deltaShape 0 0 0 0;
$tempString=`listRelatives -p $deltaShape`;
if ($tempString[0]!="")
	parent -w $deltaShape;

addAttr -k 1 -ln driverValue -at double -dv $dv $deltaShape;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $deltaShape;
if($doMirror && !$deleteMode)
	{
	duplicate -n $mirrorDeltaShape $deformObj;
	asLockAttr $mirrorDeltaShape 0 0 0 0;
	$tempString=`listRelatives -p $mirrorDeltaShape`;
	if ($tempString[0]!="")
		parent -w $mirrorDeltaShape;
	addAttr -k 1 -ln driverValue -at double -dv $mirrorDv $mirrorDeltaShape;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $mirrorDeltaShape;
	}

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

//Inverse shapes from other deformers
//if (`gmatch $driverAttr "*_*"` && `objExists ($deformObj+"Corrective")`)
duplicate -n ($deltaShape+"_componentReverse") $originalDeformObj;
$tempString=`listRelatives -p ($deltaShape+"_componentReverse")`;
if ($tempString[0]!="")
	parent -w ($deltaShape+"_componentReverse");
select $correctiveShape $originalDeformObj ($deltaShape+"_componentReverse");
//blendShape -n ($deltaShape+"_componentReverseBS") -frontOfChain -w 0 1 -w 1 1;
asBlendShapeFrontOfChain ($deltaShape+"_componentReverseBS");
setAttr ($deltaShape+"_componentReverseBS.w[0]") 1;
setAttr ($deltaShape+"_componentReverseBS.w[1]") 1;

$history=`listHistory -pdo 1 $deformObj`;
string $weights[];
if (`objExists ($deformObj+"Corrective.w")`)
	$weights=`listAttr -m ($deformObj+"Corrective.w")`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			if ($history[$i]==($deformObj+"Corrective"))
				if (`gmatch $driverAttr "*_*"`)
					for ($y=0;$y<size($weights);$y++)
						{
						if ($weights[$y]!=$deltaShape)
							setAttr ($deformObj+"Corrective."+$weights[$y]) 0;
						}

select ($deltaShape+"_componentReverse");
DeleteHistory;
select ($deltaShape+"_componentReverse") $correctiveShape;
//blendShape -n ($deltaShape+"_componentReverseBS2") -frontOfChain -w 0 1;
asBlendShapeFrontOfChain ($deltaShape+"_componentReverseBS2");
setAttr ($deltaShape+"_componentReverseBS2.w[0]") 1;
select $correctiveShape;

DeleteHistory;
for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);
delete ($deltaShape+"_componentReverse");

//Restore bsTargets that were rest to Zero, by dgdirty. SDK`s will ensure restore.
dgdirty -a;
//eval ($resetTargetsRestoreCmd);

select $deltaShape $deformObj;
asCorrectiveConnectBS;

$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
	setAttr ($deformObj+"Corrective."+$deltaShape) 1;

int $incOnce,$numVtxMoved;
int $numVtxs[]=`polyEvaluate -v $deltaShape`;
float $mag,$prevMag,$move;
float $tol=0.001;
float $selPos[]=`xform -q -ws -t $correctiveShape`;
float $deformPos[]=`xform -q -ws -t $deformObj`;
xform -ws -t $deformPos[0] $deformPos[1] $deformPos[2] $correctiveShape;
float $posA[3],$posA2[3],$posB[3],$temp[3];
//string $xyz[]={"x","y","z"};

//get current FKIK blend values
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
string $restoreFKIKCmds[];
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`gmatch $controlSetMembers[$i] "FKIK*_*"`)
		if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
			$restoreFKIKCmds[size($restoreFKIKCmds)]="setAttr "+$controlSetMembers[$i]+".FKIKBlend "+`getAttr ($controlSetMembers[$i]+".FKIKBlend")`+";";

string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

float $zv=`getAttr ($driverObj+"."+$driverAttr)`;
$zv=`asRoundOff $zv 3`;
float $mirrorZv;
if($doMirror)
	{
	$mirrorZv=`getAttr ($mirrorDriverObj+"."+$mirrorDriverAttr)`;
	$mirrorZv=`asRoundOff $mirrorZv 3`;
	}

//restore all FKIK blend values as berfore GoToBuildPose, since we might have changed to FK to do corrective
for ($i=0;$i<size($restoreFKIKCmds);$i++)
	eval ($restoreFKIKCmds[$i]);

eval($restorePoseCmd);
dgdirty -a;

//Go to `Corrective` Pose, (not guranteed to already be in this pose, specially if editing Existing target)
//asGoToCorrectivePose $driverObj $driverAttr $dv;
//refresh;

$tempString=`listRelatives -f -s $deformObj`;
string $preDeformMesh;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		$preDeformMesh=$tempString[$i];

//matrix loop utilities
float $xPoint[],$yPoint[],$zPoint[],$newPos[];
createNode -n correctiveMatrixUtilities transform;
createNode -n matrix2xform parentConstraint;
createNode -n matrix2scale scaleConstraint;
createNode -n invMReaderOffset transform;
addAttr -ln theMatrix -dt "matrix" invMReaderOffset;
createNode -n invMReader -p invMReaderOffset transform;
createNode -n invMNewPos -p invMReader transform;
createNode -n defOffset transform;
createNode -n corPos -p defOffset transform;
connectAttr -f corPos.translate invMNewPos.translate;
connectAttr -f corPos.rotate invMNewPos.rotate;
connectAttr -f corPos.scale invMNewPos.scale;
//invMReaderOffset.theMatrix to matrixInverter.xform
createNode -n matrixInverter transform;
createNode -n matrix2xform2 parentConstraint;
createNode -n matrix2scale2 scaleConstraint;
connectAttr invMReaderOffset.theMatrix  matrix2xform2.target[0].targetParentMatrix;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateX matrixInverter.translate.translateX;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateY matrixInverter.translate.translateY;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateZ matrixInverter.translate.translateZ;
connectAttr matrix2xform2.constraintRotate.constraintRotateX matrixInverter.rotate.rotateX;
connectAttr matrix2xform2.constraintRotate.constraintRotateY matrixInverter.rotate.rotateY;
connectAttr matrix2xform2.constraintRotate.constraintRotateZ matrixInverter.rotate.rotateZ;
connectAttr invMReaderOffset.theMatrix matrix2scale2.target[0].targetParentMatrix;
connectAttr matrix2scale2.constraintScale matrixInverter.scale;
//matrixInverter.inverseMatrix to invMReader.xform
connectAttr matrixInverter.inverseMatrix matrix2xform.target[0].targetParentMatrix;
connectAttr matrix2xform.constraintTranslate.constraintTranslateX invMReader.translate.translateX;
connectAttr matrix2xform.constraintTranslate.constraintTranslateY invMReader.translate.translateY;
connectAttr matrix2xform.constraintTranslate.constraintTranslateZ invMReader.translate.translateZ;
connectAttr matrix2xform.constraintRotate.constraintRotateX invMReader.rotate.rotateX;
connectAttr matrix2xform.constraintRotate.constraintRotateY invMReader.rotate.rotateY;
connectAttr matrix2xform.constraintRotate.constraintRotateZ invMReader.rotate.rotateZ;
connectAttr matrixInverter.inverseMatrix matrix2scale.target[0].targetParentMatrix;
connectAttr matrix2scale.constraintScale invMReader.scale;
parent matrix2xform matrix2scale invMReaderOffset defOffset matrixInverter matrix2xform2 matrix2scale2 correctiveMatrixUtilities;
//setAttr ($deformObj+"Corrective.envelope") 0;

//Existing blendShape nodes causes a inverse (&multiplied) deformation, so envelope off these.
$history=`listHistory -pdo 1 $deformObj`;
clear $restoreCmds;
string $bsNodes[];
string $skinCluster;
for ($i=0;$i<size($history);$i++)
	{
	if (`objectType $history[$i]`=="skinCluster" && $skinCluster=="")
		$skinCluster=$history[$i];
// Removed at 5.576: && $history[$i]!="asFaceBS"
	if (`objectType $history[$i]`=="blendShape")
		{
		setAttr ($history[$i]+".envelope") 0;
		$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
		}
	}

//Make sure the corrective is the first BS before the skinCluster
catchQuiet (`reorderDeformers $skinCluster ($deformObj+"Corrective") $deformObj`);
//And before "asFaceBS" // removed at v5.562 .. nope, brought back again.
if (`objExists "asFaceBS"`)
	catchQuiet (`reorderDeformers "asFaceBS" ($deformObj+"Corrective") $deformObj`);

if (`exists invertShape`)//Maya2017+
	{
	eval($restorePoseCmd);
	select $deformObj $correctiveShape;
	$tempString[0]=`invertShape`;
	rename $tempString[0] asInvertedShape;
	select asInvertedShape $deltaShape;
	asBlendShapeFrontOfChain asInvertedShapeTempBS;
	setAttr asInvertedShapeTempBS.asInvertedShape 1;
	delete asInvertedShape;
	select $deltaShape;
	DeleteHistory;
	}
else//Maya<2017
	{
	//xyz Offsets`s
	move -r 1 0 0 ($preDeformMesh+".vtx[0:999999]");
	duplicate -n xOffsetts $originalDeformObj;
	move -r -1 1 0 ($preDeformMesh+".vtx[0:999999]");
	duplicate -n yOffsetts $originalDeformObj;
	move -r 0 -1 1 ($preDeformMesh+".vtx[0:999999]");
	duplicate -n zOffsetts $originalDeformObj;
	move -r 0 0 -1 ($preDeformMesh+".vtx[0:999999]");
	asLockAttr xOffsetts 0 0 0 0;
	asLockAttr yOffsetts 0 0 0 0;
	asLockAttr zOffsetts 0 0 0 0;
	parent xOffsetts yOffsetts zOffsetts correctiveMatrixUtilities;

	progressBar -e -st ("Computing Delta Shape") -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($i=0;$i<$numVtxs[0];$i++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{
			progressBar -e -ep $gMainProgressBar;
			xform -ws -t $selPos[0] $selPos[1] $selPos[2] $correctiveShape;
			blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
			delete $deltaShape;
			if (`objExists $mirrorDeltaShape`)
				delete $mirrorDeltaShape;
			delete correctiveMatrixUtilities;
			select $correctiveShape;
			print ("// Corrective Shape Cancelled	\n");
			return;
			}
		if ($deleteMode)
			break;
		progressBar -e -s 1 $gMainProgressBar;

		$posA=`xform -q -ws -t ($originalDeformObj+".vtx["+$i+"]")`;
		$posB=`xform -q -ws -t ($correctiveShape+".vtx["+$i+"]")`;

		if (abs($posA[0]-$posB[0])<$tol && abs($posA[1]-$posB[1])<$tol && abs($posA[2]-$posB[2])<$tol)
			continue;

		$numVtxMoved++;

		//inverseMatrix
		float $nonDefPos[]=`xform -q -ws -t ($preDeformMesh+".vtx["+$i+"]")`;
		float $defPos[]=`xform -q -ws -t ($originalDeformObj+".vtx["+$i+"]")`;
		float $corPos[]=`xform -q -ws -t ($correctiveShape+".vtx["+$i+"]")`;

		xform -ws -t $nonDefPos[0] $nonDefPos[1] $nonDefPos[2] invMReaderOffset;

		xform -ws -t $defPos[0] $defPos[1] $defPos[2] defOffset;
		xform -ws -t $corPos[0] $corPos[1] $corPos[2] corPos;

		$xPoint=`xform -q -ws -t ("xOffsetts.vtx["+$i+"]")`;
		$yPoint=`xform -q -ws -t ("yOffsetts.vtx["+$i+"]")`;
		$zPoint=`xform -q -ws -t ("zOffsetts.vtx["+$i+"]")`;

		setAttr -type "matrix" invMReaderOffset.theMatrix 
		($xPoint[0]-$defPos[0]) ($xPoint[1]-$defPos[1]) ($xPoint[2]-$defPos[2]) 0
		($yPoint[0]-$defPos[0]) ($yPoint[1]-$defPos[1]) ($yPoint[2]-$defPos[2]) 0
		($zPoint[0]-$defPos[0]) ($zPoint[1]-$defPos[1]) ($zPoint[2]-$defPos[2]) 0
		0 0 0 1;

		$newPos=`xform -q -ws -t invMNewPos`;
		xform -ws -t $newPos[0] $newPos[1] $newPos[2] ($deltaShape+".vtx["+$i+"]");
		}
	progressBar -e -ep $gMainProgressBar;
	}

//setAttr ($deformObj+"Corrective.envelope") 1;
delete correctiveMatrixUtilities;
xform -ws -t $selPos[0] $selPos[1] $selPos[2] $correctiveShape;
print ("//Calculated "+$numVtxMoved+" vtx for deltashape\n");

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
eval($restorePoseCmd);
dgdirty -a;

if($doMirror && !$deleteMode)
	{
	createNode -n ($deltaShape+"MirrorGroup") transform;
	parent $deltaShape ($deltaShape+"MirrorGroup");
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	duplicate -n ($mirrorDeltaShape+"Default") $mirrorDeltaShape;
	select ($mirrorDeltaShape+"Default") $deltaShape;
	blendShape -n tempMirrorCorrectiveBS -frontOfChain;
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 1;
	select $mirrorDeltaShape $deltaShape;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 0;
	select $mirrorDeltaShape;
	DeleteHistory;
	delete ($mirrorDeltaShape+"Default");
	select $mirrorDeltaShape $deformObj;
	asCorrectiveConnectBS;
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	}
if ($deleteMode)
	{
	$existingTargets=`listAttr -m ($deformObj+"Corrective.w")`;
	print ("deleting "+$deltaShape+", (inbetweenValue="+$iv+", value="+$dv+")\n");
	blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
	selectKey -add -k -f $dv $sdk;
	cutKey -animation keys -clear;
	}

delete $deltaShape;
delete $correctiveShape;
if($doMirror && !$deleteMode)
	delete $mirrorDeltaShape ($deltaShape+"MirrorGroup");
if ($deleteMode)
	delete DeleteCorrectiveShape;
$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if ($iv<1)
	;//print ("Inbetweener..skipping SDK..\n");
if ($iv==1) //SDK for inbetweens not done here
	if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
		{
		if (`objExists $sdk`) if (size($keyXValues)<2) delete $sdk;
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv $zv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv $dv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		asTweakSDKCurveForRotation ($deformObj+"Corrective."+$deltaShape);
		if($doMirror && !$deleteMode)
			{
			if (`objExists $mirrorSdk`) {float $mirrorKeyValues[]=`keyframe -q -fc $mirrorSdk`;if (size($mirrorKeyValues)<2) delete $mirrorSdk;}
			setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv $mirrorZv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv $mirrorDv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			asTweakSDKCurveForRotation ($deformObj+"Corrective."+$mirrorDeltaShape);
			}
		}

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;


string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 1;
asExitCorrectiveMode;
autoKeyframe -state $autoKeyframe;
if ($originalDeformObj!="FaceCorrective")
	select $originalDeformObj;
asUpdateButtonEnables;
print "// Corrective Shape applied.\n";
}

global proc asCancelCorrective ()
{
global string $gSelect;
int $numShapeLessXforms;
string $wipLess;
string $tempString[],$tempString2[],$tempString3[];
string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`gmatch $rootLevelObjects[$i] "softMod*Handle"`)
		delete $rootLevelObjects[$i];
refresh;

for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		{
		delete $rootLevelObjects[$i];
		tokenize $rootLevelObjects[$i] "_" $tempString;
		if (`objExists $tempString[0]`)
			if ($tempString[0]!="FaceCorrective")
				select $tempString[0];
		}

//Restore WIPs
if (`objExists CorrectiveSoftModsWipBlendShape`)
	delete CorrectiveSoftModsWipBlendShape;
if (`objExists CorrectiveSoftMods`)
	{
	$tempString=`listRelatives -c CorrectiveSoftMods`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "*WIP"`)
			{
			$wipLess=`substitute "WIP" $tempString[$i] ""`;
			rename $tempString[$i] $wipLess;
			$tempString2=`listRelatives -c -type transform $wipLess`;
			for ($y=0;$y<size($tempString2);$y++)
				{
				$tempString3=`listConnections -type skinCluster ($tempString2[$y]+".worldMatrix[0]")`;
				setAttr ($tempString3[0]+".envelope") 1;
				}
			}
	}

if (`objExists "Group"`)
	setAttr "Group.v" 1;
asExitCorrectiveMode;

if (`objExists ControlSet`) asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;

select -cl;
setToolTo $gSelect;
asUpdateButtonEnables;
}

global proc asTweakSDKCurveForRotation (string $objAttr)
{
int $negDriver;
int $negDriverMult=1;
float $keyXValues[],$keyXValues[];
string $sdk;
string $tempString[];

$tempString=`listConnections $objAttr`;
$sdk=$tempString[0];
if (!`gmatch $objAttr "*rotate*"` && !`gmatch $objAttr "*angle*"`)
	return;

$keyXValues=`keyframe -q -fc $sdk`;
$keyYValues=`keyframe -q -vc $sdk`;

if ($keyXValues[0]<0)
	{
	$negDriver=1;
	$negDriverMult=-1;
	}

print ("$negDriver="+$negDriver+"\n");

if (`gmatch $objAttr "*angle*"`)
	{
	keyTangent -index (!$negDriver) -itt fixed -ott fixed -inAngle (0.06*$negDriverMult) -outAngle (0.06*$negDriverMult) $sdk;
	}
else
	{
	setAttr ($sdk+".preInfinity")   ($negDriver);
	setAttr ($sdk+".postInfinity") (!$negDriver);
	keyTangent -index (!$negDriver) -itt fixed -ott fixed -inAngle (0.06*$negDriverMult) -outAngle (0.06*$negDriverMult) $sdk;
	keyTangent -index ($negDriver) -itt fixed -ott fixed -inAngle 0 -outAngle 0 $sdk;
	}
}

global proc asExitCorrectiveMode ()
{
global string $gMainPane;
float $focalLength;
string $tempString[];
//setAttr "Group.v" 1; crashes maya :(

string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	

if (`attributeExists "correctiveShapeModeHidden" $group`)
	if (`getAttr ($group+".correctiveShapeModeHidden")`!="FaceCorrective")
		setAttr (`getAttr ($group+".correctiveShapeModeHidden")`+".v") 1;
if (`headsUpDisplay -q -ex HUDCSMMode`)
	headsUpDisplay -rem HUDCSMMode;

//removed, maybe we do not need to return to build pose, and added to CancelCorrective proc
//if (`objExists ControlSet`) asGoToBuildPose bodySetup;
//if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;

if (`objExists perspCorrective`)
	{
	$focalLength=`getAttr "persp.focalLength"`;
	if (`getAttr persp.filmFit`==1)
		setAttr "persp.focalLength" ($focalLength/2.0);

	delete perspCorrective;
	switchPanes single 0;
	$modelPanel=`paneLayout -q -p1 $gMainPane`;
	modelEditor -e -camera persp $modelPanel;
	}

asDsRemoveTestAnimation;

dgdirty -a;//needed if entering Edit mode was `unDone`, which not fully undoes, then hit Cancel to restore normality
}

global proc asCorrectiveConnectBS ()
{
int $numLetters,$wc,$mi;
string $sel[]=`ls -sl`;
string $deltaShape=$sel[0];
string $deformObj=$sel[1];
string $tempString[];
tokenize `substituteAllString $deltaShape "__"  "|"` "|" $tempString;
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $posNeg="pos";
if (`getAttr ($deltaShape+".driverValue")`<0)
	$posNeg="neg";
float $iv=`getAttr ($deltaShape+".inbetweenValue")`;
int $existingTargetNr=-1;
if (`objExists ($deformObj+"Corrective")`) //BSnode Exists (Adding Target to BS node)
	{
	int $inputTargetGroups[]=`getAttr -mi ($deformObj+"Corrective.inputTarget[0].inputTargetGroup")`;
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	for ($i=0;$i<size($existingTargets);$i++)
		{
		if ($existingTargets[$i]==$deltaShape)
			$existingTargetNr=$i;
		}
	if ($existingTargetNr!=-1 && $iv==1) // BSnode and BStarget Exists (Replacing target)
		{
		print ("// Replacing BlendShape Target\n");
		connectAttr -f ($deltaShape+".worldMesh[0]") ($deformObj+"Corrective.inputTarget[0].inputTargetGroup["+$inputTargetGroups[$existingTargetNr]+"].inputTargetItem[6000].inputGeomTarget");
		}
	else if ($iv<1 || $iv>1) // BSnode and `similar` target Exists (This must be a inbetween target)
		{
		print ("// connecting inbeween shape at: "+$iv+" for targetNr: "+$existingTargetNr+"\n");
		blendShape -e -inBetween -t $deformObj $inputTargetGroups[$existingTargetNr] $deltaShape $iv ($deformObj+"Corrective");
		//add a key, so this inbeween can be extracted
		setDrivenKeyframe -v $iv -dv `getAttr ($deltaShape+".driverValue")` -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg);
		}
	else
		{
		print ("// Creating New BlendShape\n");
		$wc=`blendShape -q -wc ($deformObj+"Corrective")`;
			if ($wc>0)
				{
				$mi=bsMultiIndexForTarget(($deformObj+"Corrective"),$wc-1);
				if ($mi!=-1)
					$wc=$mi+1;
				}
		print ("blendShape -e -t "+$deformObj+" "+$wc+" "+$deltaShape+" 1 "+$deformObj+"Corrective;\n");
		blendShape -e -t $deformObj $wc $deltaShape 1 ($deformObj+"Corrective");
		}
	}
else
	{
//	blendShape -n ($deformObj+"Corrective") -frontOfChain;
	asBlendShapeFrontOfChain ($deformObj+"Corrective");
	addAttr -k 0 -ln CorrectiveShapes -at bool -dv 1 ($deformObj+"Corrective");
	}
}

global proc string asOPMCompatibleDriverAttr (string $driverObj, string $driverAttr)
{
int $opm=`asGetOpm`;
int $numLetters;
float $m[];
string $compatibleDriverAttr=$driverAttr;
string $restorePoseCmd;
string $axis;
string $sel[]=`ls -sl`;

if (`gmatch $driverAttr "opm*"`)
	$driverAttr=`substitute "opm" $driverAttr ""`;

if ($opm && `gmatch $driverAttr "rotate*"`)
	{
	$restorePoseCmd=`asGetRestorePoseCmd`;
	$compatibleDriverAttr="opm"+$driverAttr;
	if (!`attributeExists $compatibleDriverAttr $driverObj`)
		{
		addAttr -k 0 -ln $compatibleDriverAttr -at double $driverObj;
		createNode -n ($driverObj+"DM"+$driverAttr) decomposeMatrix;
		setAttr ($driverObj+"DM"+$driverAttr+".inputRotateOrder") `getAttr ($driverObj+".rotateOrder")`;
		$numLetters=size($driverAttr);
		$axis=`substring $driverAttr $numLetters $numLetters`;
		createNode -n ($driverObj+"DMMM"+$driverAttr) multMatrix;

		//need the matrix At BuildPose
		asGoToBuildPose bodySetup;
		$m=`getAttr ($driverObj+".offsetParentMatrix")`;
		eval($restorePoseCmd);

		$m=`matrixUtil -q -inverse $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15]`;
		setAttr ($driverObj+"DMMM"+$driverAttr+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		connectAttr ($driverObj+".offsetParentMatrix") ($driverObj+"DMMM"+$driverAttr+".matrixIn[1]");
		connectAttr ($driverObj+"DMMM"+$driverAttr+".matrixSum") ($driverObj+"DM"+$driverAttr+".inputMatrix");
		connectAttr ($driverObj+"DM"+$driverAttr+".outputRotate"+$axis) ($driverObj+"."+$compatibleDriverAttr);
		select $sel;
		}
	}

return $compatibleDriverAttr;
}

global proc asPopulateCorrectivePopupMenu (string $action)
{
string $popupMenu="as"+$action+"CorrectiveShapesPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
string $correctiveBS[]=`ls -r 1 -type blendShape "*Corrective"`;
int $menuExisted,$en;
float $keyXValues[],$keyYValues[];
string $label,$menu,$lev1Menu,$lev2Menu,$lev3Menu,$lev4Menu,$lev5Menu,$correctiveSoftModGroup,$sdk,$deformObj;
string $weights[],$tempString[],$menu2s[],$menu3s[],$menu4s[],$softModHandles[],$correctiveSoftModGroups[];
string $menu2Label,$prevMenu2Label,$menu3Label,$prevMenu3Label,$menu4Label,$prevMenu4Label;

for ($i=0;$i<size($correctiveBS);$i++)
	{
	$deformObj=`substitute "Corrective" $correctiveBS[$i] ""`;
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph")
		$sm=0;
	$lev1Menu=`menuItem -sm $sm -l $deformObj`;
	if ($action=="Graph")
		{
		menuItem -e -c ("select "+$correctiveBS[$i]+";GraphEditor;") $lev1Menu;
		continue;
		}
	$weights=`listAttr -m ($correctiveBS[$i]+".w")`;
	$weights=`sort $weights`;

	for ($y=0;$y<size($weights);$y++)
		{
		tokenize `substituteAllString $weights[$y] "__"  "|"` "|" $tempString;
		string $driverObj=$tempString[0];
		string $driverAttr=$tempString[1];
		string $posNeg=$tempString[2];
		setParent -menu $lev1Menu;

		if (`gmatch $driverObj "*_L"` && $action=="Edit")
			continue;

		//$menu2s
		$prevMenu2Label=$menu2Label;
		$menu2Label=$driverObj;
		if ($menu2Label==$prevMenu2Label)//Re-use
			setParent -menu $lev2Menu;
		else
			{
			setParent -menu $lev1Menu;
			$lev2Menu=`menuItem -sm 1 -l $menu2Label`;
			}
	
		//$menu3s
		$prevMenu3Label=$menu3Label;
		$menu3Label=$driverAttr;
		if ($menu3Label==$prevMenu3Label && $menu2Label==$prevMenu2Label)//Re-use
			setParent -menu $lev3Menu;
		else
			{
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 1 -l $menu3Label`;
			}

		//$menu4s
		$prevMenu4Label=$menu4Label;
		$menu4Label=$posNeg;
//		if ($menu4Label==$prevMenu4Label)//Re-use
//			setParent -menu $lev4Menu;
//		else
			{
			setParent -menu $lev3Menu;
			$lev4Menu=`menuItem -sm 1 -l $menu4Label`;
			}

		$tempString=`listConnections ($correctiveBS[$i]+"."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
		$sdk=$tempString[0];
		$keyXValues=`keyframe -q -fc $sdk`;
		$keyYValues=`keyframe -q -vc $sdk`;
		$haveKeyAtOne=0;
		for ($z=0;$z<size($keyYValues);$z++)
			if ($keyYValues[$z]==1)
				$haveKeyAtOne=1;
		if (!$haveKeyAtOne)
			warning "Found No keys at with \"Y\" value of 1, Unable to determine which shape is not a inbetween";
		float $smallestKeyXValue=99;
		for ($z=0;$z<size($keyXValues);$z++)
			if (abs($keyXValues[$z])<$smallestKeyXValue)
				$smallestKeyXValue=abs($keyXValues[$z]);
		for ($z=0;$z<size($keyXValues);$z++)
			{
			if (($keyXValues[$z]>=0 && $keyXValues[$z]==$smallestKeyXValue) || ($keyXValues[$z]<0 && $keyXValues[$z]==-1*$smallestKeyXValue))
				continue;
			float $roundFactor;
			if ($keyXValues[$z]>0) $roundFactor=0.5;
			else $roundFactor=-0.5;
			$keyXValues[$z]=(trunc($keyXValues[$z]*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
			$cmd="";
			if ($action=="Delete")
				$cmd="createNode -n DeleteCorrectiveShape transform;";
			if ($action=="Edit" || $action=="Delete")
				$cmd+="asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" \""+$keyXValues[$z]+"\" ";
			if ($action=="Delete")
				$cmd+=";asConnectCorrective;"; 
			if ($action=="Graph")
				$cmd="select -hierarchy "+$correctiveSoftModGroup+";select -d "+$correctiveSoftModGroup+";GraphEditor;"; 
			$en=1;
			$label=$keyXValues[$z];
			if ($action=="Delete")
				if ($keyYValues[$z]==1 && size($keyXValues)>2)
//				if (($keyXValues[$z]>0 && size($keyXValues)>2 && $z==size($keyXValues)-1)
//				 || ($keyXValues[$z]<0 && size($keyXValues)>2 && $z==0))
					$en=0;
//			if (($keyXValues[$z]>0 && $z<size($keyXValues)-1) || ($keyXValues[$z]<0 && $z>0))
			if ($keyYValues[$z]!=1)
				$label+=" (inbtw)";
			setParent -menu $lev4Menu;
			menuItem -en $en -l $label -c $cmd;
			}
		}
	}
}

global proc float asSetRotationFromAngle (string $driverObj, string $driverAttr, float $dv)
{
//Dont set `mix` values
if (`gmatch $driverAttr "*_*"`)
	return 1;
string $XYZ=`substitute "angle" $driverAttr ""`;
float $a=1-`abs($dv)`;
float $c=0.707;
float $b=0.707;
float $rads = ((`pow $b 2`) + (`pow $c 2`) - (`pow $a 2`)) /( 2*$b*$c);
float $deg=90-`acosd($rads)`;
if ($dv<0)
	$deg*=-1;
string $controller="FK"+$driverObj;
if (`sets -im ControlSet $driverObj`)
	$controller=$driverObj;
setAttr ($controller+".rotate"+$XYZ) $deg;
return $deg;
}

global proc asGoToCorrectivePose (string $driverObj, string $driverAttr, float $dv)
{
string $FKIK;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)` && !`gmatch $driverObj "IK*"`)
	$FKDriverObj="FK"+$driverObj;

//inbetween changes the driverValue
int $numChar=size($driverObj);
string $fitJoint=`substring $driverObj 1 ($numChar-2)`;
if (`objExists $fitJoint`)
	if (`attributeExists inbetweenJoints $fitJoint`)
		$dv=$dv*(`getAttr ($fitJoint+".inbetweenJoints")`+1);

if (`gmatch $driverAttr "opm*"`)
	setAttr ($FKDriverObj+"."+`substitute "opm" $driverAttr ""`) $dv;
else
	{
	if (!`getAttr -settable ($FKDriverObj+"."+$driverAttr)`)//blended (including blended angles
		{
		asSetBlendedAttribute $driverObj $driverAttr $dv 0;
		if (`gmatch $driverAttr "angle*"`)//single angles (not blended angles)
			$idv=`asSetRotationFromAngle $driverObj $driverAttr $dv`;
		}
	else
		setAttr ($FKDriverObj+"."+$driverAttr) $dv;
	}

print ("setAttr "+$FKDriverObj+"."+$driverAttr+" "+$dv+";\n");

//Set FKIK to FK (if $FKIK exists)
if (`objExists ("FK"+$driverObj)` && `objExists ("FKX"+$driverObj)` && `objExists ("IKX"+$driverObj)` && `objExists ("FKOffset"+$driverObj)`)
	{
	$tempString=`listConnections -s 1 -d 0 -scn 1 ($driverObj+".tx")`;
	if (`objExists ("BendParentConstraint"+$driverObj+"_parentConstraint1")`)//Might be bendy-limb
		$tempString[0]="BendParentConstraint"+$driverObj+"_parentConstraint1";
	if ($tempString[0]!="")
		$tempString2=`listAttr -ud $tempString[0]`;
	if ($tempString2[1]!="")
		$tempString3=`listConnections -s 1 -d 0 -scn 1 ($tempString[0]+"."+$tempString2[1])`;
	if ($tempString3[0]!="")
		$FKIK=$tempString3[0];
	if (`attributeExists FKIKBlend $FKIK`)
		setAttr ($FKIK+".FKIKBlend") 0;
	print ("setAttr "+$FKIK+".FKIKBlend 0;\n");
	}
}

global proc asEditCorrectiveShape (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
//print ("asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" "+$dv+"\n");
int $autoKeyframe=`autoKeyframe -q -state`;
int $useSoftMods=`objExists CorrectiveSoftModsSystem`;
float $iv,$idv;
float $foc[],$pos[],$pos2[];
string $attrCode,$correctiveSoftModGroup,$softMod,$softModHandle;
string $posNeg="pos";
if ($dv<0) $posNeg="neg";
string $tempString[],$tempString2[],$savedSoftModHandles[],$savedSoftMods[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

autoKeyframe -state 0;

if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

asGoToCorrectivePose $driverObj $driverAttr $dv;

$attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;
$iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;

asCorrectiveDuplicate $attrCode $deformObj;
$pos=`xform -q -ws -t $attrCode`;

addAttr -k 0 -ln CorrectiveShapes -at bool -dv 1 $attrCode;
addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

asUpdateButtonEnables;
autoKeyframe -state $autoKeyframe;
dgdirty -a;
}

global proc asMatchSoftModSettings (string $source, string $dest)
{
float $falloffRadius,$falloffMode;
float $falloffCurvePoss[],$falloffCurveVals[],$falloffCurveInterps[];
string $sourceSoftMod=$source;
string $destSoftMod=$dest;
string $tempString[];

//can be softMod or softModHandle
if (`objectType $source`=="transform")
	{
	$tempString=`listConnections ($source+".worldMatrix[0]")`;
	$sourceSoftMod=$tempString[0];
	}
if (`objectType $dest`=="transform")
	{
	$tempString=`listConnections ($dest+".worldMatrix[0]")`;
	$destSoftMod=$tempString[0];
	}

$falloffRadius=`getAttr ($sourceSoftMod+".falloffRadius")`;
$falloffMode=`getAttr ($sourceSoftMod+".falloffMode")`;
for ($i=0;$i<`getAttr -s ($sourceSoftMod+".falloffCurve")`;$i++)
	{
	$falloffCurvePoss[$i]=`getAttr ($sourceSoftMod+".falloffCurve["+$i+"].falloffCurve_Position")`;
	$falloffCurveVals[$i]=`getAttr ($sourceSoftMod+".falloffCurve["+$i+"].falloffCurve_FloatValue")`;
	$falloffCurveInterps[$i]=`getAttr ($sourceSoftMod+".falloffCurve["+$i+"].falloffCurve_Interp")`;
	}

setAttr ($destSoftMod+".falloffRadius") $falloffRadius;
setAttr ($destSoftMod+".falloffMode") $falloffMode;
for ($y=0;$y<size($falloffCurvePoss);$y++)
	{
	setAttr ($destSoftMod+".falloffCurve["+$y+"].falloffCurve_Position") $falloffCurvePoss[$y];
	setAttr ($destSoftMod+".falloffCurve["+$y+"].falloffCurve_FloatValue") $falloffCurveVals[$y];
	setAttr ($destSoftMod+".falloffCurve["+$y+"].falloffCurve_Interp") $falloffCurveInterps[$y];
	}
}

global proc string asRemoveNameSpace (string $name)
{
string $return=$name;
string $tempString[];
tokenize $name ":" $tempString;
if (size($tempString)>1)
	$return=`substitute ($tempString[0]+":") $name ""`;

return $return;
}

global proc int asGetNextFreeMultiIndex (string $attr)
{
for($i=1;$i<10000000;$i++)
	{
	string $con = `connectionInfo -sfd ($attr + "["+$i+"]")`;
	if(size($con)==0)
		return($i);
	}
return(0);
}

global proc asCBDCreateCurves ()
{
int $opm=`asGetOpm`;
string $sel[]=`ls -sl`;
string $mesh=`textField -q -tx asBodyCorrectiveCBDMeshTextField`;
string $fkControl=`textField -q -tx asBodyCorrectiveCBDFKControlTextField`;
string $joint=`substitute "FK" $fkControl ""`;
string $curveCmd,$curve,$slideSideNr,$axis,$parentJoint,$childJoint,$getXFrom,$deleteSlidersCmd,$bindCmd,$name,$side;
string $tempString[],$curves[],$startProfile;
float $pos[],$tempPos[],$jo[],$m[];
float $fat,$parentfat,$childfat;
int $haveSkinCage=`objExists SkinCage`;
int $rotYonly,$rotZonly,$singleAxisPositive;

if (!`gmatch $fkControl "FK*"`)
	error "Select FK-controller(s)";
if ($mesh=="")
	error "Mesh must be chosen";

$tempString=`listRelatives -type joint -p $joint`;
if (`gmatch $tempString[0] "*Part1_*"`)
	error "This limb is has only 1 Twist-Joint. A minimum of 2 Twist-Joints is required for Curved-Based-Deformations";
if (!`gmatch $tempString[0] "*Part*"`)
	error "This limb is has No Twist-Joints. A minimum of 2 Twist-Joints is required for Curved-Based-Deformations";

tokenize $joint "_" $tempString;
$name=$tempString[0];
$side="_"+$tempString[1];

if (!$haveSkinCage)
	{
	asCreateSkinCage;
	asSkinCurvesToWidth;
	setAttr SkinCage.v 0;
	setAttr SkinCurves1.v 0;
	setAttr SkinCurves2.v 0;
	}
select -cl;
if (`objExists tempLoc`)
	delete tempLoc;
if (`objExists curveDeformationObjects`)
	delete `sets -q curveDeformationObjects`;
createNode -n curveDeformationObjects objectSet;
createNode -n curveDeformationSetup transform;
setAttr curveDeformationSetup.overrideEnabled 1;
setAttr curveDeformationSetup.overrideColor 13;
sets -add curveDeformationObjects curveDeformationSetup;
addAttr -ln mesh -dt "string" curveDeformationSetup;
setAttr -l 1 -type "string" curveDeformationSetup.mesh $mesh;
addAttr -ln fkControl -dt "string" curveDeformationSetup;
setAttr -l 1 -type "string" curveDeformationSetup.fkControl $fkControl;

$tempString=`listRelatives -type joint -p $joint`;
while (`gmatch $tempString[0] "*Part[0-9]*"`)
	$tempString=`listRelatives -type joint -p $tempString[0]`;
$parentJoint=$tempString[0];
$tempString=`listRelatives -type joint -c $joint`;
while (`gmatch $tempString[0] "*Part[0-9]*"`)
	$tempString=`listRelatives -type joint -c $tempString[0]`;
$childJoint=$tempString[0];
$fat=`getAttr ($joint+".fat")`*`getAttr  ($joint+".fatWidth")`;
$parentfat=`getAttr ($parentJoint+".fat")`*`getAttr  ($parentJoint+".fatWidth")`;
$childfat=`getAttr ($childJoint+".fat")`*`getAttr  ($childJoint+".fatWidth")`;

//find $startProfile & $endProfile
if (`objExists ($joint+"_startProfile")`) $startProfile=$joint+"_startProfile";
else
	for ($y=20;$y>0;$y--)
		if (`objExists ($parentJoint+"_twistProfile"+$y)`)
			{
			$startProfile=$parentJoint+"_twistProfile"+$y;
			break;
			}

if (`objExists ($joint+"_endProfile")`) $endProfile=$joint+"_endProfile";
else
	if (`objExists ($joint+"_twistProfile1")`)
		$endProfile=$joint+"_twistProfile1";
//if (!`objExists $endProfile`)
//	$endProfile=$childJoint+"_middleProfile";

//Ensure sliders
if (!`objExists ($name+"middleSlider0"+$side)`) {select ($joint+"_middleProfile");asCreateSliders;$deleteSlidersCmd+="select "+$joint+"_middleProfile;asDeleteSliders;";}
if (!`objExists ($name+"startSlider0"+$side)`)
	if (`objExists $startProfile`){select $startProfile;asCreateSliders;$deleteSlidersCmd+="select "+$startProfile+";asDeleteSliders;";}
	else
		{
		for ($i=0;$i<5;$i++)
			if (`objExists ($name+"middleSlider"+$i+$side)`)
				{
				duplicate -n ($name+"startSlider"+$i+$side) ($name+"middleSlider"+$i+$side);
				parent ($name+"startSlider"+$i+$side) $joint;
				setAttr ($name+"startSlider"+$i+$side+".tx") `getAttr ($joint+".tx")`;
				}
		}
if (!`objExists ($name+"endSlider0"+$side)`)
	if (`objExists $endProfile`){select $endProfile;asCreateSliders;$deleteSlidersCmd+="select "+$endProfile+";asDeleteSliders;";}
	else
		{
		for ($i=0;$i<5;$i++)
			if (`objExists ($name+"middleSlider"+$i+$side)`)
				{
				duplicate -n ($name+"endSlider"+$i+$side) ($name+"middleSlider"+$i+$side);
				parent ($name+"endSlider"+$i+$side) $joint;
				setAttr ($name+"endSlider"+$i+$side+".tx") `getAttr ($childJoint+".tx")`;
				}
		}

//$rotYonly,$rotZonly & $singleAxisPositive
$rotYonly=$rotZonly=0;
if (!`objExists ($name+"middleSlider0"+$side)`) $rotYonly=1;
if (!`objExists ($name+"middleSlider1"+$side)`) $rotZonly=1;
$singleAxisPositive=0;
$jo=`getAttr ($joint+".jointOrient")`; // check jointOrient to find bend axis
if ($opm)
	{
	$m=`getAttr ($joint+".offsetParentMatrix")`;
	$jo=`matrixUtil -q -rotation $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15]`;
	}
if ($rotYonly && $jo[1]>0) $singleAxisPositive=1;
if ($rotZonly && $jo[2]>0) $singleAxisPositive=1;
addAttr -k 1 -ln "rotYonly" -at bool -dv $rotYonly curveDeformationSetup;
addAttr -k 1 -ln "rotZonly" -at bool -dv $rotZonly curveDeformationSetup;
addAttr -k 1 -ln "singleAxisPositive" -at bool -dv $singleAxisPositive curveDeformationSetup;

spaceLocator -n tempLoc;
pointConstraint $parentJoint $joint $childJoint tempLoc;
parent tempLoc $joint;
setAttr -type float3 tempLoc.r 0 0 0;

for ($a=1;$a>-2;$a=$a-2)
	{
	if ($a==1)  $axis="Y";
	if ($a==-1) $axis="Z";
	if ($rotYonly && $axis=="Y") continue;
	if ($rotZonly && $axis=="Z") continue;

	for ($b=1;$b>-2;$b=$b-2)
		{
		$curveCmd="curve -d 3";
		if ($b==1)  $curve="deformationCurve"+$axis+"1";
		if ($b==-1) $curve="deformationCurve"+$axis+"2";
		if ($a==1  && $b==1)  $slideSideNr="2";
		if ($a==1  && $b==-1) $slideSideNr="0";
		if ($a==-1 && $b==1)  $slideSideNr="3";
		if ($a==-1 && $b==-1) $slideSideNr="1";

		$curves[size($curves)]=$curve;
		setAttr -type float3 ("tempLoc_pointConstraint1.offset") 0 0 0;
		for ($y=0;$y<9;$y++)
			{
			if ($y==0)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 1;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 0;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ($parentfat*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==1)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 3;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==2)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 1;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ((($fat+$parentfat)/2.0)*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}

			if ($y<3 && `gmatch $joint "*_R"` && `gmatch $parentJoint "*_M"` && $curve!="deformationCurveZ1")
				{//Branching such as Hip, not to extend to far across axis
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				$tempPos=`xform -q -ws -t tempLoc`;
				$pos[0]=$tempPos[0];
				}
			if ($y<3 && `gmatch $joint "*_R"` && $pos[0]>0)
				$pos[0]=0;

			if ($y==3)
				{
				$pos=`xform -q -ws -t ($name+"startSlider"+$slideSideNr+$side)`;
				}
			if ($y==4)
				{
				$pos=`xform -q -ws -t ($name+"middleSlider"+$slideSideNr+$side)`;
				}
			if ($y==5)
				{
				$pos=`xform -q -ws -t ($name+"endSlider"+$slideSideNr+$side)`;
				}
			if ($y==6)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 1;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ((($fat+$childfat)/2.0)*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==7)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 3;
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==8)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 0;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 1;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ($childfat*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$curveCmd+=" -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 6 -k 6";
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] $curve;
		setAttr ($curve+".dispCV") 1;
		parent $curve curveDeformationSetup;
/*
		select $childJoint $parentJoint ($name+"startSlider"+$slideSideNr+$side) ($name+"middleSlider"+$slideSideNr+$side) ($name+"endSlider"+$slideSideNr+$side) $curve;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($curve+"SC");
		for ($y=0;$y<9;$y++)
			{
			if ($y==0) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==1) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==2) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==3) skinPercent -tv ($name+"startSlider" +$slideSideNr+$side) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==4) skinPercent -tv ($name+"middleSlider"+$slideSideNr+$side) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==5) skinPercent -tv ($name+"endSlider"   +$slideSideNr+$side) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==6) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==7) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==8) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			}
*/
		$bindCmd+="select "+$childJoint+" "+$parentJoint+" "+$name+"startSlider"+$slideSideNr+$side+" "+$name+"middleSlider"+$slideSideNr+$side
			+" "+$name+"endSlider"+$slideSideNr+$side+" "+$curve+";";
		$bindCmd+="$tempString=`newSkinCluster \"-toSelectedBones -mi 3 -dr 4 -rui false\"`;";
		$bindCmd+="rename $tempString[0] "+$curve+"SC;";
		for ($y=0;$y<9;$y++)
			{
			if ($y<3)  $bindCmd+="skinPercent -tv "+$parentJoint+" 1 "+$curve+"SC "+$curve+".cv["+$y+"];";
			if ($y==3) $bindCmd+="skinPercent -tv "+$name+"startSlider" +$slideSideNr+$side+" 1	"+$curve+"SC "+$curve+".cv["+$y+"];";
			if ($y==4) $bindCmd+="skinPercent -tv "+$name+"middleSlider"+$slideSideNr+$side+" 1	"+$curve+"SC "+$curve+".cv["+$y+"];";
			if ($y==5) $bindCmd+="skinPercent -tv "+$name+"endSlider"   +$slideSideNr+$side+" 1	"+$curve+"SC "+$curve+".cv["+$y+"];";
			if ($y>5) $bindCmd+="skinPercent -tv "+$childJoint+" 1 "+$curve+"SC "+$curve+".cv["+$y+"];";
/*
			if ($y==1) $bindCmd+="skinPercent -tv "+$parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==2) $bindCmd+="skinPercent -tv "+$parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==3) $bindCmd+="skinPercent -tv "+($name+"startSlider"+$slideSideNr+$side) 1	($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==4) $bindCmd+="skinPercent -tv "+($name+"middleSlider"+$slideSideNr+$side) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==5) $bindCmd+="skinPercent -tv "+($name+"endSlider"+$slideSideNr+$side) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==6) $bindCmd+="skinPercent -tv "+$childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==7) $bindCmd+="skinPercent -tv "+$childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==8) $bindCmd+="skinPercent -tv "+$childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
*/
			}
		}
	}

addAttr -ln bindCmd -dt "string" curveDeformationSetup;
setAttr -type "string" curveDeformationSetup.bindCmd $bindCmd;

if (`objExists deformationCurveZ1` && `objExists deformationCurveY2`)
	reorder -relative -1 deformationCurveZ1;
delete tempLoc;

addAttr -k 1 -ln haveSkinCage -at bool -dv $haveSkinCage curveDeformationSetup;
addAttr -ln deleteSlidersCmd -dt "string" curveDeformationSetup;
setAttr -type "string" curveDeformationSetup.deleteSlidersCmd $deleteSlidersCmd;
addAttr -k 1 -ln curvesBound -at bool -dv 0 curveDeformationSetup;
asCBDReBindCurves;

//select $curves;
//change to -cl, after making curves red
select -cl;
}

global proc asCBDUnBindCurves ()
{
string $tempString[]=`ls -type skinCluster "deformationCurve*SC"`;
for ($i=0;$i<size($tempString);$i++)
	delete $tempString[$i];
setAttr curveDeformationSetup.curvesBound 0;
}

global proc asCBDReBindCurves ()
{
if (!`attributeExists bindCmd curveDeformationSetup`)
	return;
if (`getAttr curveDeformationSetup.curvesBound`)
	error "Curves already bound";
string $bindCmd=`getAttr curveDeformationSetup.bindCmd`;
print ($bindCmd+"\n");
eval $bindCmd;
setAttr curveDeformationSetup.curvesBound 1;
print "// Curves Bound.\n";
select -cl;
}

global proc asCBDCreateTestAnim ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
string $fkIkCtrl;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;
float $singleAxisRotValue=-90;
if ($singleAxisPositive)
	$singleAxisRotValue=90;

if (`attributeExists curvesBound curveDeformationSetup`)
	if (!`getAttr curveDeformationSetup.curvesBound`)
		error "Curves are not Skinned, click on \"Re-Bind\" first.";

$fkIkCtrl=`asFindFKIKCtrl $fkControl`;
if (`attributeExists FKIKBlend $fkIkCtrl`)
	setAttr ($fkIkCtrl+".FKIKBlend") 0;

currentTime 0;
if ($rotYonly || $rotZonly)
	{
	playbackOptions -min 0 -ast 0 -aet 10 -max 10;
	if ($rotYonly) setKeyframe ($fkControl+".ry");
	if ($rotZonly) setKeyframe ($fkControl+".rz");
	currentTime 10;
	if ($rotYonly)	{setAttr ($fkControl+".ry") $singleAxisRotValue;setKeyframe ($fkControl+".ry");}
	if ($rotZonly)	{setAttr ($fkControl+".rz") $singleAxisRotValue;setKeyframe ($fkControl+".rz");}
	}
else
	{
	playbackOptions -min 0 -ast 0 -aet 80 -max 80;
	setKeyframe ($fkControl+".r");
	currentTime 10;setAttr ($fkControl+".ry") 90;setKeyframe ($fkControl+".r");
	currentTime 20;setAttr ($fkControl+".ry") 0;setKeyframe ($fkControl+".r");
	currentTime 30;setAttr ($fkControl+".ry") -90;setKeyframe ($fkControl+".r");
	currentTime 40;setAttr ($fkControl+".ry") 0;setKeyframe ($fkControl+".r");
	currentTime 50;setAttr ($fkControl+".rz") 90;setKeyframe ($fkControl+".r");
	currentTime 60;setAttr ($fkControl+".rz") 0;setKeyframe ($fkControl+".r");
	currentTime 70;setAttr ($fkControl+".rz") -90;setKeyframe ($fkControl+".r");
	currentTime 80;setAttr ($fkControl+".rz") 0;setKeyframe ($fkControl+".r");
	}
refresh;
currentTime 5;
}

global proc asCBDHideMesh ()
{
string $source=`textField -q -tx asBodyCorrectiveCBDMeshTextField`;
if (`objExists $source`)
	setAttr ($source+".v") 0;
}

global proc asCBDCreateDeformMesh ()
{
float $pos[];
float $radius;
float $currentTime=`currentTime -q`;
string $tempString[];
string $newSkinCluster;
currentTime 0;

if (`objExists Corrective`) delete Corrective;
if (`objExists deformationLoft`) delete deformationLoft;

string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
string $joint=`substitute "FK" $fkControl ""`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;
string $existingSkinCluster=`findRelatedSkinCluster $mesh`;
string $curves[]=`listRelatives -c curveDeformationSetup`;

if ($existingSkinCluster=="")
	error ("No SkinCluster on:\""+$mesh+"\"");

select $curves;
//	select $curves[0] $curves[2] $curves[1] $curves[3];
$tempString=`loft -n deformationLoft -ch 1 -u 1 -c 1 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true`;
setAttr deformationLoftShape.curvePrecisionShaded 4;
setAttr deformationLoft.v 0;
parent deformationLoft curveDeformationSetup;

duplicate -n Corrective $mesh;
asLockAttr Corrective 0 0 0 0;
parent Corrective curveDeformationSetup;
setAttr Corrective.v 1;
$tempString=`listRelatives -s Corrective`;
for ($z=0;$z<size($tempString);$z++)
	if (`getAttr ($tempString[$z]+".intermediateObject")`)
		delete $tempString[$z];

/*
//skinCluster first (fir out-of-bounds-regions)
$tempString=`listHistory -pdo 1 $mesh`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$existingSkinCluster=$tempString[$y];
*/
select Corrective `listConnections ($existingSkinCluster+".matrix")`;
//$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
$tempString=`asDeformer ("newSkinCluster \"-toSelectedBones -mi 3 -dr 4 -rui false\"")`;
rename $tempString[0] CorrectiveSC;
$tempString=`listConnections CorrectiveSC.message`;
rename $tempString[0] CorrectiveSCSet;
select $mesh Corrective;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

nurbsToPoly -n deformationMesh -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 deformationLoft;
parent deformationMesh curveDeformationObjects;
setAttr deformationMesh.v 0;
polySmooth -mth 0 -dv 2 -bnr 1 -c 1 -kb 0 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 deformationMesh;

sets -add curveDeformationObjects $curves deformationLoft deformationMesh Corrective;
select -r Corrective deformationMesh;
//$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
$tempString=`asDeformer ("doWrapArgList 7 { \"1\",\"0\",\"1\", \"2\", \"0\", \"1\", \"1\", \"0\" }")`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
rename $tempString[0] CorrectiveWrap;
$tempString=`listConnections CorrectiveWrap.message`;
rename $tempString[0] CorrectiveWrapSet;
if (`gmatch $joint "*_R"`)
	{
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 999 -da 1 0 0 -dp 999 0 0;
	sets -remove CorrectiveWrapSet `ls -sl`;
	}

$pos=`xform -q -ws -t $fkControl`;
select Corrective;
$radius=(`getAttr ($joint+".fat")`*`getAttr ($joint+".fatWidth")`)*6;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $radius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl`;
polySelectConstraint -m 0;
catchQuiet (`sets -remove CorrectiveSCSet $tempString`);
asInvertSelection;
sets -remove CorrectiveWrapSet `ls -sl`;
ConvertSelectionToFaces;
delete;
$tempString=`listConnections -s 1 -d 0 Corrective.inMesh`;
rename $tempString[0] CorrectiveDeleteComponent;

currentTime $currentTime;
}

global proc asCBDShowOriginal ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
setAttr ($mesh+".v") 1;
if (`objExists Corrective`)
	setAttr Corrective.v 0;
}

global proc asCBDShowNew ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
setAttr ($mesh+".v") 0;
if (`objExists Corrective`)
	setAttr Corrective.v 1;
}

global proc asCBBakeDeformMesh ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;

setAttr ($mesh+".v") 1;
textField -e -tx Corrective asBakeToCorrective1TextField;
textField -e -tx $mesh asBakeToCorrective2TextField;

if (`objExists CorrectiveDeleteComponent`)
	delete CorrectiveDeleteComponent;

string $checkBoxes[]=`rowLayout -q -ca asBakeAxisRowLayout`;
for ($i=0;$i<size($checkBoxes);$i++)
	if ($rotYonly || $rotZonly)
		checkBox -e -v 0 $checkBoxes[$i];
	else
		checkBox -e -v 1 $checkBoxes[$i];
checkBox -e -v 0 asBakeX1CheckBox;
checkBox -e -v 0 asBakeX2CheckBox;
if ($rotYonly && $singleAxisPositive) checkBox -e -v 1 asBakeY1CheckBox;
if ($rotYonly && !$singleAxisPositive) checkBox -e -v 1 asBakeY2CheckBox;
if ($rotZonly && $singleAxisPositive) checkBox -e -v 1 asBakeZ1CheckBox;
if ($rotZonly && !$singleAxisPositive) checkBox -e -v 1 asBakeZ2CheckBox;

if ($rotYonly || $rotZonly)
	checkBox -e -v 0 asCorrectiveShapesAngleCheckBox; 
else
	checkBox -e -v 1 asCorrectiveShapesAngleCheckBox;

select $fkControl;
asBakeIntoCorrectiveShapes;
textField -e -tx "" asBakeToCorrective1TextField;
textField -e -tx "" asBakeToCorrective2TextField;

asCBCleanup;
print "// CurveBased Deformation Corrective BlendShape complete.\n";
}

global proc asCBCleanup ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
eval (`getAttr curveDeformationSetup.deleteSlidersCmd`);
if (!`getAttr curveDeformationSetup.haveSkinCage`)
	asDeleteSkinCage;

delete `sets -q curveDeformationObjects`;
setAttr ($mesh+".v") 1;
string $tempString[]=`listConnections -s 1 -d 0 -type animCurveTA $fkControl`;
for ($i=0;$i<size($tempString);$i++)
	delete $tempString[$i];
setAttr -type float3 ($fkControl+".r") 0 0 0;
}

global proc asBakeIntoCorrectiveShapes ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl`;
string $source=`textField -q -tx asBakeToCorrective1TextField`;
string $dest=`textField -q -tx asBakeToCorrective2TextField`;
string $corrective;
if ($source=="" || !`objExists $source` || `gmatch $source "*[.]*"`)
	error "Source not valid";
if ($dest=="" || !`objExists $dest` || `gmatch $dest "*[.]*"`)
	error "Destination not valid";
string $tempString[]=`listRelatives -s -ni $source`;
string $sourceShape=$tempString[0];
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
asSetAllFK "";
select -cl;
$asSkipConfirm=1;
string $xyz[]={"x","x","y","y","z","z"};
float $rots[]={90,-90,90,-90,90,-90};
for ($i=0;$i<size($sel);$i++)
	{
	print ("// Start checking:"+$sel[$i]+"\n");
	if (!`gmatch $sel[$i] "FK*"`)
		continue;
	if (!`sets -im ControlSet $sel[$i]`)
		continue;
	if (`gmatch $sel[$i] "FKExtra*"`)
		continue;
	if (`gmatch $sel[$i] "FKRoot*"`)
		continue;
	for ($y=0;$y<size($xyz);$y++)
		{
		if ($y==0 && !`checkBox -q -v asBakeX1CheckBox`) continue;
		if ($y==1 && !`checkBox -q -v asBakeX2CheckBox`) continue;
		if ($y==2 && !`checkBox -q -v asBakeY1CheckBox`) continue;
		if ($y==3 && !`checkBox -q -v asBakeY2CheckBox`) continue;
		if ($y==4 && !`checkBox -q -v asBakeZ1CheckBox`) continue;
		if ($y==5 && !`checkBox -q -v asBakeZ2CheckBox`) continue;
		print ("// Baking:"+$sel[$i]+".r"+$xyz[$y]+"="+$rots[$y]+"\n");
		setAttr ($sel[$i]+".r"+$xyz[$y]) $rots[$y];
		refresh;
		select $dest;
		$corrective=`asCreateCorrectiveShapes`;
		$tempString=`listRelatives -s -ni $corrective`;
		$correctiveShape=$tempString[0];
		connectAttr -f ($sourceShape+".outMesh") ($correctiveShape+".inMesh");
		asConnectCorrective;
		setAttr ($sel[$i]+".r"+$xyz[$y]) 0;
		}
	}
$asSkipConfirm=0;
eval($restorePoseCmd);
select $sel;
}

global proc asUpdatePoseAttributes ()
{
//update buildPoses and run attributes
string $poseAttr,$existingCmd,$newCmd;
string $tempString[];
string $restorePoseCmd=`asGetRestorePoseCmd`;

for ($a=0;$a<6;$a++)
	{
	if ($a==0) $poseAttr="buildPose.udAttr";
	if ($a==1) $poseAttr="faceBuildPose.udAttr";
	if ($a==2) $poseAttr="FitSkeleton.run";
	if ($a==3) $poseAttr="FaceFitSkeleton.run";
	if ($a==4) $poseAttr="buildPose.udExtraAttr";
	if ($a==5) $poseAttr="faceBuildPose.udExtraAttr";
	if (!`objExists $poseAttr`)
		continue;
	$existingCmd=`getAttr $poseAttr`;
	$newCmd="";
	tokenize $existingCmd ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (!catchQuiet (`eval ($tempString[$i])`))
			$newCmd+=$tempString[$i]+";";
		else if ($tempString[$i]!="")
			print ("// Removing from "+$poseAttr+":"+$tempString[$i]+"\n");
	setAttr -type "string" $poseAttr $newCmd;
	}
eval ($restorePoseCmd);
}

global proc string asGetRestorePoseCmd ()
{
string $restorePoseCmd;
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	string $faceControlSetMembers[]=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $faceControlSetMembers`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	string $attrs[]=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		if (`getAttr -l ($controlSetMembers[$i]+"."+$attrs[$y])`)
			continue;
		if (!`getAttr -settable ($controlSetMembers[$i]+"."+$attrs[$y])`)
			continue;
		$restorePoseCmd+="setAttr "+$controlSetMembers[$i]+"."+$attrs[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$attrs[$y])`+";";
		}
	}

return $restorePoseCmd;
}

global proc asSkinCurvesToWidth ()
{
if (!`objExists SkinCurves2` || !`objExists SkinCurves1`)
	error "SkinCurves not found. Create SkinCage first";
float $pos[],$pos2[];
string $skinCurves1[]=`listConnections SkinCurves1.drawInfo`;
string $skinCurves2[]=`listConnections SkinCurves2.drawInfo`;
string $tempString[];
string $joint,$aboveBelowProfile,$belowProfile,$parentJoint,$parentTarget;
for ($i=0;$i<size($skinCurves1);$i++)
	{
	tokenize $skinCurves1[$i] "_" $tempString;
	$joint="";
	for ($y=0;$y<size($tempString)-1;$y++)
		{
		$joint+=$tempString[$y];
		if ($y<size($tempString)-2)
			$joint+="_";
		}
	if (!`objExists $joint`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	while (`gmatch $tempString[0] "*Part[0-9]*"`)
		$tempString=`listRelatives -type joint -p $tempString[0]`;
	$parentJoint=$tempString[0];
	if (!`objExists $parentJoint`)
		continue;
	$tempString=`listRelatives -type joint -c $joint`;
	$childJoint=$tempString[0];
	if (!`objExists $childJoint`)
		continue;

	//ignore `inbetween` joints
	$tempString=`listRelatives -type joint -c $joint`;
	if (`gmatch $tempString[0] "*Part[0-9]*"` && !`attributeExists twistAmount $tempString[0]`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	if (`gmatch $tempString[0] "*Part[0-9]*"` && !`attributeExists twistAmount $tempString[0]`)
		continue;

	for ($a=0;$a<2;$a++)
		{
		// find profile
		$aboveBelowProfile="";
		if ($a==0 && !`attributeExists noStartCurve $joint`)
			{
			if (`objExists ($joint+"_startProfile")`)
				$aboveBelowProfile=$joint+"_startProfile";
			else
				{
				for ($y=20;$y>0;$y--)
					if (`objExists ($parentJoint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$parentJoint+"_twistProfile"+$y;
						break;
						}
				}
			if ($aboveBelowProfile=="")
				continue;
			}
		if ($a==1)
			{
			if (`objExists ($joint+"_endProfile")`)
				$aboveBelowProfile=$joint+"_endProfile";
			else
				{
				for ($y=1;$y<21;$y++)
					if (`objExists ($joint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$joint+"_twistProfile"+$y;
						break;
						}
				}
			}
		if ($aboveBelowProfile=="" || `gmatch $aboveBelowProfile "Neck*"`)//skip neck
			continue;
	
		// place profile
		int $targetIds[2]={0,1};
		$tempString=`listRelatives -p $aboveBelowProfile`;
		string $offsetNode=$tempString[0];
		string $parentConstraint=$offsetNode+"_pointConstraint1";
		string $scaleConstraint=$offsetNode+"_scaleConstraint1";
		string $targetAttrs[]=`listAttr -ud $parentConstraint`;
		setAttr -type float3 ($parentConstraint+".offset") 0 0 0;
		$tempString=`listConnections ($parentConstraint+".target[0].targetParentMatrix")`;
		if ($tempString[0]==`substitute "Profile" $skinCurves1[$i] "Curve"`)
			{
			$targetIds={1,0};
			$tempString=`listConnections ($parentConstraint+".target[1].targetParentMatrix")`;
			if ($tempString[0]=="")
				continue;
			}
		$parentTarget=$tempString[0];
		$pos=`xform -q -ws -t $skinCurves1[$i]`;
		$pos2=`xform -q -ws -t $parentTarget`;
		float $toParentDist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	
		$tempString=`listRelatives -c $skinCurves1[$i]`;
		$innerCurve=$tempString[0];
		$pos=`xform -q -ws -t ($innerCurve+".cv[0]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		float $curveHeight=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		$pos=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[2]")`;
		float $curveWidth=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		float $hwAverage=($curveHeight+$curveWidth)/2.0;
	
		if ($targetAttrs[1]!="")
			{
			float $weight=($hwAverage/2.0)/$toParentDist;
			if ($weight>0.45)
				$weight=0.45;

			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			}
		}
	}
}

global proc asCreateGroinLocators ()
{
if (`objExists GroinStart`) delete GroinStart;
if (`objExists GroinSide`) delete GroinSide;
spaceLocator -n GroinStart;
spaceLocator -n GroinSide;
float $posA[]=`xform -q -ws -t Root`;
float $posB[]=`xform -q -ws -t Root_M_middleCurve.cv[2]`;
xform -ws -t 0 ($posA[1]*0.9) $posA[2] GroinStart;
xform -ws -t $posB[0] ($posB[1]*1.03) $posA[2] GroinSide;
select -cl;
}

global proc asAdjustGroinArea ()
{
float $pos[];
float $posGroinStart[]=`xform -q -ws -t GroinStart`;
float $posGroinSide[]=`xform -q -ws -t GroinSide`;

if (!`objExists Root_M_middleCurve` || !`objExists Hip_R_startProfileShape`)
	{
	if (`objExists GroinStart`) delete GroinStart;
	if (`objExists GroinSide`) delete GroinSide;
	warning "Skipped, because required profile-curves not found";
	return;
	}

$pos=`xform -q -ws -t Root_M_middleProfile`;
xform -ws -t 0 $posGroinSide[1] $pos[2] Root_M_middleProfile;

$pos=`xform -q -ws -t Root_M_middleCurve.cv[2]`;
xform -ws -t $pos[0] ($pos[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[3];
$pos=`xform -q -ws -t Root_M_middleProfileShape.cv[2]`;
xform -ws -t $pos[0] ($pos[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[3];

$pos=`xform -q -ws -t Root_M_middleCurve.cv[1]`;
xform -ws -t $pos[0] ($pos[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[0] Hip_R_startProfileShape.cv[4];
$pos=`xform -q -ws -t Root_M_middleProfileShape.cv[1]`;
xform -ws -t $pos[0] ($pos[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[0] Hip_R_middleProfileShape.cv[4];

$pos=`xform -q -ws -t Hip_R_middleProfileShape.cv[2]`;
xform -ws -t $pos[0] ($posGroinStart[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[2];
$pos=`xform -q -ws -t Hip_R_middleProfileShape.cv[1]`;
xform -ws -t $pos[0] ($posGroinStart[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[1];

$pos=`xform -q -ws -t Hip_R_startProfileShape.cv[2]`;
xform -ws -t 0 ($posGroinStart[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[2];
$pos=`xform -q -ws -t Hip_R_startProfileShape.cv[1]`;
xform -ws -t 0 ($posGroinStart[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[1];

scale -r 1.2 1.2 1.2 Hip_R_startProfile;

//might overlap with twistProfiles
int $twistJoints=`getAttr Hip.twistJoints`;
for ($i=1;$i<$twistJoints+1;$i++)
	{
	$pos=`xform -q -ws -t ("Hip_R_twistProfileShape"+$i+".cv[1]")`;
	if ($pos[1]>$posGroinStart[1])
		move -r 0 (($pos[1]-$posGroinStart[1])*-1.2) 0 ("Hip_R_twistProfileShape"+$i+".cv[1:2]");
	}

asMirrorControlCurves 0 SkinCageCurvesSet;

if (`objExists GroinStart`) delete GroinStart;
if (`objExists GroinSide`) delete GroinSide;
}

global proc asCreateSkinCage ()
{
string $upAxisDirection=`upAxis -q -ax`;
string $absSecAxis,$absTerAxis;
string $secAxis="Y";
string $terAxis="Z";
string $name,$side;

if (!`asConfirmIfNotInBuildPose`)
	return;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;
string $tempString[];

if (`objExists MeshGeometry`)
	{
	asRebuildSkinCage;
	return;
	}

if ($upAxisDirection=="z")
	asSceneUpAxisFlip Group y;

asEnsureAllFitJointAttrs;//v 5.813 upgrade new fat attributes

createNode -n Cages transform;
parent Cages Geometry;
createNode -n MeshGeometry transform;
parent MeshGeometry Geometry;
setAttr "MeshGeometry.overrideEnabled" 1;
createNode -n MeshCurves transform;
parent MeshCurves Geometry;
createNode -n NurbsGeometry transform;
setAttr NurbsGeometry.v 0;
parent NurbsGeometry Geometry;
sets -em -name SkinCageCurvesSet;
sets -add "Sets" SkinCageCurvesSet;

select -cl;
createDisplayLayer -e -name "SkinCage" -number 1 -nr;
createDisplayLayer -e -name "SkinCurves1" -number 2 -nr;
createDisplayLayer -e -name "SkinCurves2" -number 3 -nr;
setAttr SkinCurves2.v 0; setAttr SkinCurves2.displayType 0; setAttr SkinCurves2.color 13;
setAttr SkinCurves1.v 1; setAttr SkinCurves1.displayType 0; setAttr SkinCurves1.color 14;
setAttr SkinCage.displayType 2;

//Build tubes
string $topNodes[]=`listRelatives -type joint -c DeformationSystem`;
asAnalyzeChainJoints $topNodes[0];

//pickup single brancers
string $children[];
$tempString=`asListAllDecents $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $tempString[$i]`)
			continue;
	$children=`asListChildren $tempString[$i]`;
	if (size($children)>0)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asBuildChainCurves {$tempString[$i]};
	}


//Branch
asCreateBranchBoxes;

//merge copies.
select `ls -as "*_copy" "*_branch"`;
$tempString=`polyUnite -ch 0 -n skinCage`;
setAttr skinCage.keepBorder 0;
polyMergeVertex -d 0.0001 -am 1 -ch 1 skinCage;
select skinCage;
DeleteHistory;
//polyNormal -normalMode 2 -userNormalMode 0 -ch 0 skinCage;
//DeleteHistory;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
string $middleCurves[]=`ls -type transform "*_middleCurve"`;

//UV
polyAutoProjection -ch 0 -lm 0 -pb 0 -ibd 0 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0 skinCage;

//skinn
string $joint,$twistJoint;
select -cl;
for ($i=0;$i<size($middleCurves);$i++)
	{
	tokenize `substitute "_middleProfile"  $middleCurves[$i] ""` "_" $tempString;
	$name=$tempString[0];
	$side="_"+$tempString[1];
	if (`objExists ($name+"Partial"+$side)`)
		select -add ($name+"Partial"+$side);

	$joint=`substitute "_middleCurve" $middleCurves[$i] ""`;
	select -add $joint;
	//include twistJoints
	for ($y=1;$y<99;$y++)
		{
		tokenize $joint "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$y+"_"+$tempString[1];
		if (`objExists $twistJoint`)
			select -add ($twistJoint);
		else
			break;
		}
	//include nonListedParents
	$tempString=`listRelatives -type joint -p $joint`;
	if (size($tempString))
		if (!`objExists ($tempString[0]+"_middleCurve")`)
			if (!`gmatch $tempString[0] "*Part[0-9]*"`)
				select -add $tempString[0];
	//include 50`s (now called "Partial")
	if (`objExists ($name+"Partial"+$side)`)
		select -add ($name+"Partial"+$side);
	//deselect endJoints
	$tempString=`listRelatives -type joint -c $joint`;
	if (!`size($tempString)`)
		select -d $joint;
	}
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r `listRelatives -c MeshGeometry`;
//select `ls -sl -ni "*_poly"`;
select -add skinCage;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
string $cylinders[]=`ls -type transform "*_poly"`;
for ($i=0;$i<size($cylinders);$i++)
	{
	delete `listConnections ($cylinders[$i]+"Shape.inMesh")`;
	setAttr -l 1 ($cylinders[$i]+".v") 0;
	}

//wrap
$cylinders=`ls -type transform "*_poly"`;
//select -cl;
//deformer -type wrap skinCage;
select -r skinCage;
select -add $cylinders[0];
asDeformer ("doWrapArgList 7 { \"1\",\"0\",\"1\", \"2\", \"0\", \"1\", \"1\", \"0\" }");//use asDeformer to ensure Set is created in Maya2022 and above
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
for ($i=1;$i<size($cylinders);$i++)
	{
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}

$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;

reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

//scale profileCurves to markers
float $scale=`asGetScale`;
float $sideTreshold=0.01*$scale;
$fitSkeletonJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitSkeletonJoints);$i++)
		{
		$fitSkeletonSide[$i]="_R";
		$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$fitSkeletonSide[$i]="_M";

		$side=$fitSkeletonSide[$i];
		if ($b==-1 && $fitSkeletonSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";

		string $profileCurve=$fitSkeletonJoints[$i]+$side+"_middleProfile";
		if (`objExists $profileCurve`)
			{
			if (!`attributeExists fat $fitSkeletonJoints[$i]`)
				continue;
			float $fat=`getAttr ($fitSkeletonJoints[$i]+$side+".fat")`;
			float $fatFront=`getAttr ($fitSkeletonJoints[$i]+$side+".fatFront")`;
			float $fatWidth=`getAttr ($fitSkeletonJoints[$i]+$side+".fatWidth")`;
			$absSecAxis=`asGetAxis secondary $fitSkeletonJoints[$i] FitSkeleton 1`;
			$absTerAxis=`asGetAxis tertiary $fitSkeletonJoints[$i] FitSkeleton 1`;
			setAttr ($profileCurve+".scale"+$absSecAxis) ($fat*$fatFront);
			setAttr ($profileCurve+".scale"+$absTerAxis) ($fat*$fatWidth);
			refresh;
			}
		}

//Profiles tweaks
asProfileTweaks;
asMirrorControlCurves 0 SkinCageCurvesSet;
if ($upAxisDirection=="z")
	asSceneUpAxisFlip Group z;
print "// SkinCage created\n";
select -cl;
}

global proc asDeleteSkinCage ()
{
string $deleteObjs[]={"skinCage","SkinSub","Cages","MeshGeometry","MeshCurves","NurbsGeometry","SkinCage","SkinCurves1","SkinCurves2","SkinCageCurvesSet"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asRebuildSkinCage ()
{
string $restoreShapesCmds[];
string $profileCurveShapes[]=`ls -type nurbsCurve "*ProfileShape*"`;
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($profileCurveShapes);$i++)
	{
	$form=`getAttr ($profileCurveShapes[$i]+".form")`;
	$spans=`getAttr ($profileCurveShapes[$i]+".spans")`;
	$degrees=`getAttr ($profileCurveShapes[$i]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($profileCurveShapes[$i]+".cv["+$y+"]")`;
		$restoreShapesCmds[size($restoreShapesCmds)]="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$profileCurveShapes[$i]+".cv["+$y+"];";
		}
	}

asDeleteSkinCage;
asCreateSkinCage;
for ($i=0;$i<size($restoreShapesCmds);$i++)
	print ($restoreShapesCmds[$i]+"\n");
for ($i=0;$i<size($restoreShapesCmds);$i++)
	catchQuiet (`eval $restoreShapesCmds[$i]`);
}

global proc asProfileTweaks ()
{
int $cvs[],$oppositeCvs[],$flipCvs[];
int $terAxisNr;
float $dist,$minDist;
float $pos1[],$pos2[],$pos3[],$sca1[],$sca2[];
string $heelFitJoint,$toesFitJoint,$cv,$closestCv,$absTerAxis;

string $ankleProfileEnds[]=`ls -type transform "*Ankle*_*endProfile"`;
for ($i=0;$i<size($ankleProfileEnds);$i++)
	{
	string $ankle=`substitute "_endProfile" $ankleProfileEnds[$i] ""`;
	int $numChar=size($ankle);
	string $fitAnkle=`substring $ankle 1 ($numChar-2)`;
	string $side=`substring $ankle ($numChar-1) 99`;
	int $b=1;
	if ($side=="_L") $b=-1;
	$heelFitJoint=$toesFitJoint="";
	$tempString=`listRelatives -c -type joint $fitAnkle`;
	for ($y=0;$y<size($tempString);$y++)
		{
		string $label=`asLabel $tempString[$y]`;
		if (`gmatch $label "*Heel*"`)
			$heelFitJoint=$tempString[$y];
		if (`gmatch $label "*Toes*"`)
			$toesFitJoint=$tempString[$y];
		}
	if ($heelFitJoint=="")
		continue;
	float $anklePos[]=`xform -q -ws -t $ankleProfileEnds[$i]`;
	float $heelPos[]=`xform -q -ws -t $heelFitJoint`;
	$absTerAxis=`asGetAxis tertiary $fitAnkle FitSkeleton 1`;
	$terAxisNr=`asAxisToAxisNr $absTerAxis`;
	if (`gmatch $ankleProfileEnds[$i] "*_R_*"`)
		$cvs={0,1,4};
	else
		$cvs={2,3};
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`getAttr ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t ($heelPos[0]*$b) $heelPos[1] $heelPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		setAttr ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]."+`tolower $absTerAxis`+"Value") $existingPos[$terAxisNr];
		scale -r -p $anklePos[0] $anklePos[1] $anklePos[2] 1.2 1.2 1 ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		}
	}

string $toeProfileMiddle[]=`ls -type transform "*Toes*Profile"`;
for ($i=0;$i<size($toeProfileMiddle);$i++)
	{
	$pos1=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv[0]")`;
	$pos2=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv[2]")`;
	$transformPos=`xform -q -ws -t $toeProfileMiddle[$i]`;
	if (`gmatch $toeProfileMiddle[$i] "*_R_*"`)
		{$cvs={0,1,4};$oppositeCvs={2,3};}
	else
		{$cvs={2,3};$oppositeCvs={0,1,4};}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t $existingPos[0] 0 $existingPos[2] ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]");
		scale -ws -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1 1.2 1 ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]"); 
		}

	for ($y=0;$y<size($oppositeCvs);$y++)
		{
		if (`gmatch $toeProfileMiddle[$i] "*_start*"`)
			scale -ws -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1 0.5 1 ($toeProfileMiddle[$i]+".cv["+$oppositeCvs[$y]+"]"); 
		}

	}

if (`objExists Neck_M_startCurve` && `objExists Chest_M_middleProfile`)
	{
	$sca1=`getAttr Chest_M_middleProfile.s`;
	$sca2=`getAttr Neck_M_middleProfile.s`;
	for ($i=0;$i<5;$i++)
		{
		$pos1=`xform -q -ws -t ("Neck_M_middleProfile.cv["+$i+"]")`;
		setAttr -type float3 Neck_M_middleProfile.s $sca1[0] $sca1[1] $sca1[2];
		$pos2=`xform -q -ws -t ("Neck_M_middleProfile.cv["+$i+"]")`;
		setAttr -type float3 Neck_M_middleProfile.s $sca2[0] $sca2[1] $sca2[2];
		xform -ws -t ($pos1[0]*1.1) (($pos1[1]+$pos2[1])/2.0) (($pos1[2]+$pos2[2])/2.0) ("Neck_M_startProfile.cv["+$i+"]");
		}
	}
}

global proc asCreateSliders ()
{
global int $asBuilding;
global int $asDSMirror;
global int $asDSAngle;
global string $asDSAttrName;
global string $asDSObjName;
if (!`asConfirmIfNotInBuildPose`)
	return;
int $error = 0;
int $opm=`asGetOpm`;
int $incCtrl=`checkBox -q -v asBodySlidersIncCtrlCheckBox`;
string $joint;
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asIcons.ma";
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $m[];
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

if (`objExists closestSampler`)
	delete closestSampler;
if (!`objExists SlideSystem`)
	createNode -n SlideSystem -p MotionSystem transform;
if (!`isConnected MainScaleMultiplyDivide.output SlideSystem.s`)
	connectAttr MainScaleMultiplyDivide.output SlideSystem.s;

int $sideFactor=1;
int $vtxNr[];
int $bendAxis,$cvNr;
float $widthFactor,$widthFactorY,$widthFactorZ,$driverValue,$drivenValue;
float $pos[],$posA[],$posB[],$temp[];
string $deformJoint,$name,$side,$firstPa,$stEnMid,$drivenAttribute,$parentJoint,$sdk;
string $tempString[],$branchVtxs[],$branchVtxSliderNrs[],$skinCurveSliderInfo[];

if ($incCtrl)
	asImportIconsFile $iconsFile;

createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*_L_*"`)
		$sideFactor=-1;
	else
		$sideFactor=1;

	$bendAxis=0;//all directions
	$skinCurveSliderInfo=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	tokenize $deformJoint "_" $tempString;
	$name=$tempString[0];
	$side="_"+$tempString[1];

	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -type joint -p $parent`;
		$parent=$tempString[0];
		}
	$tempString=`listRelatives -type joint -p $deformJoint`;
	$firstPa=$tempString[0];

	if ($skinCurveSliderInfo[1]=="")
		{
		print ("// Skipping "+$sel[$i]+", as it`s not defining start or end or middle of deformation\n");
		continue;
		}
	$stEnMid=$skinCurveSliderInfo[1];
	if (`objExists ($name+$stEnMid+"Slider0"+$side)` || `objExists ($name+$stEnMid+"Slider1"+$side)`)
		continue;

	createNode -n messureTemp transform;
	pointConstraint $sel[$i] messureTemp;
	parent messureTemp $firstPa;
	if ($skinCurveSliderInfo[1]=="end")
		parent messureTemp $deformJoint;
	float $xOffset=`getAttr messureTemp.tx`;
	delete messureTemp;

	if (!`objExists  ($name+"SlideSystem"+$side)`)
		createNode -n ($name+"SlideSystem"+$side) -p SlideSystem transform;

	if (!`objExists ($name+"Partial"+$side)`)// && $skinCurveSliderInfo[1]=="middle",//removed as Start/End for !$incCtrl need these
		{
		createNode -n asBatch transform;
//		checkBox -e -v $incCtrl asBodyPartialJointsIncCtrlCheckBox;
		checkBox -e -v 0 asBodyPartialJointsIncCtrlCheckBox;
		select $deformJoint;
		asCreatePartialJoints;
		delete asBatch;

		}

	//only 2 for elbow/knee, determine $bendAxis
	if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
		{
		float $jo[]=`getAttr ($deformJoint+".jointOrient")`; // check jointOrient to find bend axis
		if ($opm)
			{
			$m=`getAttr ($deformJoint+".offsetParentMatrix")`;
			$jo=`matrixUtil -q -rotation $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15]`;
			}
		if (abs($jo[1])>abs($jo[2])) $bendAxis=1;// .joY greater than .joZ, so not a Zbender
		if (abs($jo[2])>abs($jo[1])) $bendAxis=2;// .joZ greater than .joY, so not a Ybender
		}

	for ($y=0;$y<4;$y++)
		{
		//only 2 for elbow/knee, determine $bendAxis
		if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
			{
			if ($bendAxis==1) if ($y==0 || $y==2) continue;
			if ($bendAxis==2) if ($y==1 || $y==3) continue;
			}
		if ($skinCurveSliderInfo[1]=="start") $parentJoint=$firstPa;
//		if ($skinCurveSliderInfo[1]=="middle") $parentJoint=$name+"Slide50"+$side;
		if ($skinCurveSliderInfo[1]=="middle") $parentJoint=$name+"Partial"+$side;
		if ($skinCurveSliderInfo[1]=="end") $parentJoint=$deformJoint;
		select $parentJoint;
		joint -n ($name+$stEnMid+"Slider"+$y+$side);
		sets -add ("DeformSet") ($name+$stEnMid+"Slider"+$y+$side);
		$cvNr=$y;
		if ($sideFactor==-1)
			$cvNr=`asCVNrSideFlip $y`;
		$posA=`xform -q -ws -t ($sel[$i]+".cv["+$cvNr+"]")`;
		$posB=`xform -q -ws -t ($sel[$i]+".cv["+($cvNr+1)+"]")`;
		$pos={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($name+$stEnMid+"Slider"+$y+$side);
		$widthFactorY=`getAttr ($name+$stEnMid+"Slider"+$y+$side+".ty")`;
		$widthFactorZ=`getAttr ($name+$stEnMid+"Slider"+$y+$side+".tz")`;
		$widthFactorY=`abs($widthFactorY)`;
		$widthFactorZ=`abs($widthFactorZ)`;
		$widthFactor=`max $widthFactorY $widthFactorZ`;

		//Ctrl
		if ($incCtrl)
			{
			$joint=$name+$stEnMid+"Slider"+$y+$side;
			createNode -n ("FKOffset"+$joint) -p ($name+"SlideSystem"+$side) transform;
			createNode -n ("FKExtra"+$joint) -p ("FKOffset"+$joint) transform;
			asLockAttr ("FKExtra"+$joint) 0 0 1 1;	
			duplicate -n ("FK"+$joint) Bend_icon;
			setAttr ("FK"+$joint+".t") -type float3 0 0 0;
			scale -r 0.1 0.1 0.1 ("FK"+$joint+".cv[0:99]");
			parent ("FK"+$joint) ("FKExtra"+$joint);
			sets -add ControlSet ("FK"+$joint) ("FKExtra"+$joint);
			asAlign ("FKOffset"+$joint) $joint 1 1 0 1;
			asParentConstraint ("FK"+$joint) $joint "";
			asParentConstraint $parentJoint ("FKOffset"+$joint) "-mo";
			//update buildPose
			$newCtrlBuildPoseCmd ="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 FKExtra"+$joint+";";
			$newCtrlBuildPoseCmd+="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 FK"+$joint+";";
			if (!`attributeExists udExtraAttr buildPose`)
				addAttr -ln udExtraAttr -dt "string" buildPose;
			setAttr -type "string" buildPose.udExtraAttr (`getAttr buildPose.udExtraAttr`+$newCtrlBuildPoseCmd);

			//DrivingSystem
			$posA=`asGetTransformValues ($name+$stEnMid+"Slider"+$y+$side) translate`;
			for ($a=0;$a<2;$a++)
				{
//				if ($a==1 && $asDSAngle)
//					continue;
//				if ($a==1 && $skinCurveSliderInfo[1]!="middle")
//					continue;
				$asDSAttrName="rotateZ";
				$driverValue=90;
				if ($y==1 || $y==2)
					$driverValue*=-1;
				if ($a==1)
					$driverValue*=-1;

				if ($y==0) $drivenValue=$posA[1]/4.0;
				if ($y==2) $drivenValue=$posA[1]/4.0;
				if ($y==1) $drivenValue=$posA[2]/4.0;
				if ($y==3) $drivenValue=$posA[2]/4.0;

				if ($a==1 && $skinCurveSliderInfo[1]!="middle")
					$drivenValue*=-1;

				if ($skinCurveSliderInfo[1]!="middle" && ($y==0 || $y==1))
					$drivenValue*=-1;

				if ($skinCurveSliderInfo[1]=="start")  $drivenAttribute="translateX";
				if ($skinCurveSliderInfo[1]=="end")    $drivenAttribute="translateX";
				if ($skinCurveSliderInfo[1]=="middle") {if ($y==0 || $y==2) $drivenAttribute="translateY";else $drivenAttribute="translateZ";}

				if ($skinCurveSliderInfo[1]=="end")    $driverValue*=-1;

				if ($bendAxis==0)
					{
					$asDSAngle=1;
					if ($y==0 || $y==2) $asDSAttrName="rotateZ";
					if ($y==1 || $y==3) $asDSAttrName="rotateY";
					}
				if ($bendAxis==2)
					{
					$asDSAngle=0;
					$asDSAttrName="rotateZ";
					}

				setAttr ("FK"+$deformJoint+"."+$asDSAttrName) $driverValue;

				setAttr ("FK"+$joint+"."+$drivenAttribute) $drivenValue;
//print ("setAttr FK"+$joint+"."+$drivenAttribute+" "+$drivenValue+";\n");
				$asDSObjName="FK"+$deformJoint;
				$asBuilding=1;
				$asDSMirror=0;
//if ($y==1) a;
				asDsCreate;
				}
			$asBuilding=0;

			if (!$asDSAngle)
				{
				$sdk="SDKFK"+$joint+"_"+$drivenAttribute;
				setAttr ($sdk+".preInfinity") 1;
				setAttr ($sdk+".postInfinity") 1;
				keyTangent -index 0 -inTangentType spline -outTangentType spline $sdk;
				keyTangent -index 2 -inTangentType spline -outTangentType spline $sdk;
				}

			if (!`attributeExists partialVis Main`)
				{
				addAttr -k 1 -ln partialVis -at bool -dv 1 Main;
				setAttr -k 0 -cb 1 Main.partialVis;
				}
			connectAttr Main.partialVis ("FKOffset"+$joint+".v");
			
			}

		else
			{
			if (!`objExists ($name+"SlideDist"+$y+$side)`)
				{
				// recylcle these between starters, enders, and middlers
				createNode -n ($name+"SlideDist"+$y+$side) distanceBetween	;
				createNode -n ($name+"SlideStart"+$y+$side) transform;
				createNode -n ($name+"SlideEnd"+$y+$side) transform;
	//			connectAttr -f ($name+"SlideStart"+$y+".t") ($name+"SlideDist"+$y+".point1");
				connectAttr -f ($name+"SlideEnd"+$y+$side+".t") ($name+"SlideDist"+$y+$side+".point2");
	//			$tempString=`spaceLocator`;rename $tempString[0] ($name+"SlideStart"+$y+$side);
	//			$tempString=`spaceLocator`;rename $tempString[0] ($name+"SlideEnd"+$y+$side);
	//			setAttr -type float3 ($name+"SlideStart"+$y+$side+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
	//			setAttr -type float3 ($name+"SlideEnd"+$y+$side+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
				parent ($name+"SlideStart"+$y+$side) $firstPa;
				parent ($name+"SlideEnd"+$y+$side) $firstPa;
				xform -ws -t $pos[0] $pos[1] $pos[2] ($name+"SlideStart"+$y+$side);
				xform -ws -t $pos[0] $pos[1] $pos[2] ($name+"SlideEnd"+$y+$side);		
				parent ($name+"SlideEnd"+$y+$side) ($name+"Partial"+$side);
				setAttr ($name+"SlideEnd"+$y+$side+".tx") 0;
				float $temp[3]=`getAttr ($name+"SlideEnd"+$y+$side+".t")`;
				float $mag=`mag <<$temp[0],$temp[1],$temp[2]>>`*$sideFactor;
				$temp[0]=`getAttr ($deformJoint+".tx")`;
				setAttr -type float3 ($name+"SlideStart"+$y+$side+".t") ($temp[0]-$mag) 0 0;
				parent ($name+"SlideStart"+$y+$side) ($name+"SlideSystem"+$side);
				parent ($name+"SlideEnd"+$y+$side) ($name+"SlideStart"+$y+$side);
	//			parentConstraint -mo $firstPa ($name+"SlideStart"+$y+$side);
				parentConstraint -mo $deformJoint ($name+"SlideStart"+$y+$side);
				parentConstraint -mo ($name+"Partial"+$side) ($name+"SlideEnd"+$y+$side);
				//behaviour
				createNode -n ($name+"SlideDistNormalize"+$y+$side) multiplyDivide;
				setAttr ($name+"SlideDistNormalize"+$y+$side+".operation") 2;
				connectAttr ($name+"SlideDist"+$y+$side+".distance") ($name+"SlideDistNormalize"+$y+$side+".input1X");
				setAttr ($name+"SlideDistNormalize"+$y+$side+".input2X") `getAttr ($name+"SlideDistNormalize"+$y+$side+".input1X")`;
				}

			//they all share `_SlideMultiply` & `SlideReducer` & `_SlidePlusOffset`
			createNode -n ($name+$stEnMid+"SlideReducer"+$y+$side) multiplyDivide;
			setAttr ($name+$stEnMid+"SlideReducer"+$y+$side+".input2X") $widthFactor;
			if ($skinCurveSliderInfo[1]=="start")
				setAttr ($name+$stEnMid+"SlideReducer"+$y+$side+".input2X") ($widthFactor*-1);
			//on opposide side, the start and end must move opposite direction
			if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
				setAttr ($name+$stEnMid+"SlideReducer"+$y+$side+".input2X") (`getAttr ($name+$stEnMid+"SlideReducer"+$y+$side+".input2X")`*$sideFactor);
			createNode -n ($name+$stEnMid+"SlideMultiply"+$y+$side) multiplyDivide;
			addAttr -k 1 -ln slide -at double -dv 1 ($name+$stEnMid+"Slider"+$y+$side);
			connectAttr ($name+$stEnMid+"Slider"+$y+$side+".slide") ($name+$stEnMid+"SlideMultiply"+$y+$side+".input2X");
			connectAttr ($name+$stEnMid+"SlideReducer"+$y+$side+".outputX") ($name+$stEnMid+"SlideMultiply"+$y+$side+".input1X");
			createNode -n ($name+$stEnMid+"SlidePlusOffset"+$y+$side) plusMinusAverage;
			connectAttr ($name+$stEnMid+"SlideMultiply"+$y+$side+".outputX") ($name+$stEnMid+"SlidePlusOffset"+$y+$side+".input1D[0]");
			if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
				{
				createNode -n ($name+$stEnMid+"SlideMinusOne"+$y+$side) plusMinusAverage;
				setAttr ($name+$stEnMid+"SlideMinusOne"+$y+$side+".operation") 2;
				connectAttr ($name+"SlideDistNormalize"+$y+$side+".outputX") ($name+$stEnMid+"SlideMinusOne"+$y+$side+".input1D[0]");
				setAttr ($name+$stEnMid+"SlideMinusOne"+$y+$side+".input1D[1]") 1;

				connectAttr ($name+$stEnMid+"SlideMinusOne"+$y+$side+".output1D") ($name+$stEnMid+"SlideReducer"+$y+$side+".input1X");
				setAttr ($name+$stEnMid+"SlidePlusOffset"+$y+$side+".input1D[1]") $xOffset;
				connectAttr ($name+$stEnMid+"SlidePlusOffset"+$y+$side+".output1D") ($name+$stEnMid+"Slider"+$y+$side+".tx");
				}
			if ($skinCurveSliderInfo[1]=="middle")
				{
				string $slideAxis="z";
				if ($bendAxis==2)
					$slideAxis="y";
				if (($bendAxis==0) && ($y==0 || $y==2))
					$slideAxis="y";
				createNode -n ($name+$stEnMid+"SlideReverse"+$y+$side) reverse;
				connectAttr ($name+"SlideDistNormalize"+$y+$side+".outputX") ($name+$stEnMid+"SlideReverse"+$y+$side+".inputX");
				createNode -n ($name+$stEnMid+"SlideAbsolutor"+$y+$side) condition;
				if (`getAttr ($name+$stEnMid+"Slider"+$y+$side+".t"+$slideAxis)`>0)
					setAttr ($name+$stEnMid+"SlideAbsolutor"+$y+$side+".operation") 4;
				else
					setAttr ($name+$stEnMid+"SlideAbsolutor"+$y+$side+".operation") 2;
				connectAttr ($name+$stEnMid+"SlideReverse"+$y+$side+".outputX") ($name+$stEnMid+"SlideAbsolutor"+$y+$side+".firstTerm");
				connectAttr ($name+$stEnMid+"SlideReverse"+$y+$side+".outputX") ($name+$stEnMid+"SlideAbsolutor"+$y+$side+".colorIfFalseR");
				createNode -n ($name+$stEnMid+"SlideReducer"+$y+$side) multiplyDivide;
				createNode -n ($name+$stEnMid+"SlideTimesMinusOne"+$y+$side) multiplyDivide;
				connectAttr ($name+$stEnMid+"SlideReverse"+$y+$side+".outputX") ($name+$stEnMid+"SlideTimesMinusOne"+$y+$side+".input1X");
				setAttr ($name+$stEnMid+"SlideTimesMinusOne"+$y+$side+".input2X") -1;
				connectAttr ($name+$stEnMid+"SlideTimesMinusOne"+$y+$side+".outputX") ($name+$stEnMid+"SlideAbsolutor"+$y+$side+".colorIfTrueR");
				connectAttr ($name+$stEnMid+"SlideAbsolutor"+$y+$side+".outColorR") ($name+$stEnMid+"SlideReducer"+$y+$side+".input1X");

				setAttr ($name+$stEnMid+"SlidePlusOffset"+$y+$side+".input1D[1]") `getAttr ($name+$stEnMid+"Slider"+$y+$side+".t"+$slideAxis)`;
				connectAttr ($name+$stEnMid+"SlidePlusOffset"+$y+$side+".output1D") ($name+$stEnMid+"Slider"+$y+$side+".t"+$slideAxis);
				}
			}

		//skinning
		skinCluster -e -lw false -wt 0 -ai ($name+$stEnMid+"Slider"+$y+$side) skinClusterSkinCage;
		$temp=`xform -q -ws -t ($sel[$i]+".cv["+$cvNr+"]")`;
		setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		skinPercent -tv ($name+$stEnMid+"Slider"+$y+$side) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
		if ($bendAxis==0) //all directions
			{
			if ($y>0) skinPercent -tv ($name+$stEnMid+"Slider"+($y-1)+$side) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
			if ($y==3) skinPercent -tv ($name+$stEnMid+"Slider3"+$side) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[0]+"]");
			}
		if (($bendAxis==1 && $y==3) || ($bendAxis==2 && $y==2)) //last loop for Z or Ybender
			{
			int $pickupVtx=2;
			int $sliderNr=1;
			if ($bendAxis==2) {$pickupVtx=1;$sliderNr=0;}
			if ($sideFactor==-1) $pickupVtx=`asCVNrSideFlip $pickupVtx`;
			$temp=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($name+$stEnMid+"Slider"+$sliderNr+$side) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			$pickupVtx=4;
			$sliderNr=3;
			if ($bendAxis==2) {$pickupVtx=3;$sliderNr=2;}
			if ($sideFactor==-1) $pickupVtx=`asCVNrSideFlip $pickupVtx`;
//if ($bendAxis==2) {print ("$bendAxis="+$bendAxis+" $pickupVtx="+$pickupVtx+" $sliderNr="+$sliderNr+"\n");a;}
			$temp=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($name+$stEnMid+"Slider"+$sliderNr+$side) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			}

		}

	//branchVtx`s edgeloopCheck to see if there`s a extra vtx, if so.. this is a `brancher`
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	$branchVtxSliderNrs=`asGetBranchedVtx $tempString 1`;
	for ($y=0;$y<size($branchVtxs);$y++)
		skinPercent -tv ($name+$stEnMid+"Slider"+$branchVtxSliderNrs[$y]+$side) 1 skinClusterSkinCage $branchVtxs[$y];
	}

if (`objExists closestSampler`)
	delete closestSampler;

if (`objExists iconsGroup`)
	delete iconsGroup;

print "// Sliders created\n";
select $sel;
}

global proc string[] asGetBranchedVtx (string $inputVtxs[], int $vertsOrSliderNr)
{
string $return[],$branchVtxs[],$branchVtxSliderNrs[];
string $connectVtx0s[],$connectVtx1s[],$connectVtx2s[],$connectVtx3s[];
for ($y=0;$y<4;$y++)
	{
	select $inputVtxs[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $inputVtxs[$y];
	$tempString=`ls -sl -fl`;
	if ($y==0) $connectVtx0s=$tempString;
	if ($y==1) $connectVtx1s=$tempString;
	if ($y==2) $connectVtx2s=$tempString;
	if ($y==3) $connectVtx3s=$tempString;
	}
for ($y=0;$y<size($connectVtx0s);$y++) {
	if (`stringArrayCount $connectVtx0s[$y] $connectVtx1s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=0;}
if (`stringArrayCount $connectVtx0s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=3;}}
for ($y=0;$y<size($connectVtx1s);$y++)
	if (`stringArrayCount $connectVtx1s[$y] $connectVtx2s`) {$branchVtxs[size($branchVtxs)]=$connectVtx1s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=1;}
for ($y=0;$y<size($connectVtx2s);$y++)
	if (`stringArrayCount $connectVtx2s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx2s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=2;}
if ($vertsOrSliderNr)
	$return=$branchVtxSliderNrs;
else
	$return=$branchVtxs;
return $return;
}

global proc asDeleteSliders ()
{
int $error,$remove50;
int $haveSliderJoint[],$vtxNr[];
float $charHeight=`asgetCharHeight`;
float $currentTime=`currentTime -q`;
float $pos[];
string $name,$side;
string $sel[]=`ls -sl`;
string $tempString[];

if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
currentTime 0;
for ($i=0;$i<size($sel);$i++)
	{
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	tokenize $skinCurveSliderInfo[0] "_" $tempString;
	$name=$tempString[0];
	$side="_"+$tempString[1];
	for ($y=0;$y<4;$y++)
		{
		//skinning
		$pos=`xform -q -ws -t $sel[$i]`;
		createNode -n closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker1;
		$pos=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		createNode -n closestSamplerShrinker2 -p closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker2;
		$pos=`xform -q -ws -t closestSamplerShrinker2`;
		scale -r 0.832 0.832 0.832 closestSamplerShrinker1;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		delete closestSamplerShrinker1;
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		}
	//$branchVtxs
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	for ($y=0;$y<size($branchVtxs);$y++)
		{
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage $branchVtxs[$y];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage $branchVtxs[$y];
		}
	//delete the joint (+ctrl)
	for ($y=0;$y<4;$y++)
		{
		if (`objExists ($name+$skinCurveSliderInfo[1]+"Slider"+$y+$side)`)
			delete ($name+$skinCurveSliderInfo[1]+"Slider"+$y+$side);
		if (`objExists ("FKOffset"+$name+$skinCurveSliderInfo[1]+"Slider"+$y+$side)`)
			delete ("FKOffset"+$name+$skinCurveSliderInfo[1]+"Slider"+$y+$side);
		}

	//delete SlideSystem
	if (`objExists ($name+"SlideSystem"+$side)`)
		if (!size(`listRelatives -c ($name+"SlideSystem"+$side)`))
			delete ($name+"SlideSystem"+$side);
/*
	//remove 50 system, if no longer required
	$remove50=0;
	if (!`objExists ($name+"SlideDistNormalize1"+$side)`)
		{
		if (`objExists ($name+"Slide50"+$side)`)
			delete ($name+"Slide50"+$side);
		if (`objExists ($name+"Slide00"+$side)`)
			delete ($name+"Slide00"+$side);
		for ($y=0;$y<4;$y++)
			if (`objExists ($name+"SlideStart"+$y+$side)`)
				delete ($name+"SlideStart"+$y+$side);
		}
*/
	if ($skinCurveSliderInfo[1]=="middle")
		{
		if (`objExists ($name+"Partial"+$side)`)
			delete ($name+"Partial"+$side);
		if (`objExists ($name+"Slide00Offset"+$side)`)
			delete ($name+"Slide00Offset"+$side);
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
currentTime $currentTime;
select -cl;
}

global proc int asCVNrSideFlip (int $cvNr)
{
int $returnCvNr;

if ($cvNr==0 || $cvNr==4) $returnCvNr=2;
if ($cvNr==1) $returnCvNr=3;
if ($cvNr==2) $returnCvNr=0;
if ($cvNr==3) $returnCvNr=1;

return $returnCvNr;
}

global proc string asListParent (string $obj)
{
string $tempString[]=`listRelatives -type joint -p $obj`;
return $tempString[0];
}

global proc string[] asListChildren (string $obj)
{
int $skip,$skipChildrenToo;
string $fitJoint,$rlaChild;
string $return[];
string $tempString[],$tempString2[];
string $skips[]={"FaceJoint_M","Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_",
								"Jaw_","JawEnd_","Eye_","Eye[0-9]_","Partial_","Float","VS[0-9]JStart"};
string $skipsChildrenToo[]={"FaceJoint_M","PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","Partial_","Float","VS[0-9]JStart"};

//asRlaChild sohuld be first in the order
$rlaChild=`asRlaChild $obj`;
if (`objExists $rlaChild`)
	if (!`stringArrayCount $rlaChild $skips`)
		$return[0]=$rlaChild;

$tempString=`listRelatives -type joint -c $obj`;
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	if ($tempString[$i]==$rlaChild)
		continue;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempString[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skipChildrenToo=1;
	tokenize $tempString[$i] "_" $tempString2;
	$fitJoint=$tempString2[0];
	if (`attributeExists noSkin $fitJoint`)
		if (`getAttr ($fitJoint+".noSkin")`)
			{
			$skip=1;
			$skipChildrenToo=1;
			}
	if (`attributeExists skinControlJoint $tempString[$i]`)
		if (`getAttr ($tempString[$i]+".skinControlJoint")`)
			{
			$skip=1;
			$skipChildrenToo=1;
			}

	if ($skip)
		{
		if (!$skipChildrenToo)
			{
			$tempString2=`listRelatives -type joint -c $tempString[$i]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$skip=0;
				for ($y=0;$y<size($skips);$y++)
					if (`gmatch $tempString2[$z] ("*"+$skips[$y]+"*")`)
						$skip=1;
				if (!$skip)
					$return[size($return)]=$tempString2[$z];
				}
			}
		}
	else
		if ($tempString[$i]!="")
			$return[size($return)]=$tempString[$i];
	}
return $return;
}

global proc string[] asListAllDecents (string $obj)
{
int $skip;
string $fitJoint;
string $return[],$tempString2[],$tempString3[];
string $tempString[]=`listRelatives -type joint -ad $obj`;
string $tempStringFullPath[]=`listRelatives -type joint -ad -f $obj`;
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_",
								"Jaw_","Eye_","Partial_","Float","Part[0-9]_","Part[0-9][0-9]_","VS[0-9]JStart"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","Partial_","Float","VS[0-9]JStart"};
for ($i=0;$i<size($tempString);$i++)
	{
	if (size(`ls $tempString[$i]`)>1)
		$tempString[$i]=$tempStringFullPath[$i];
	$skip=0;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempStringFullPath[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skip=1;

	tokenize $tempString[$i] "_" $tempString2;
	$fitJoint=$tempString2[0];
	clear $tempString2;
	if (`objExists $fitJoint`)
		$tempString2=`ls -l $fitJoint`;
	tokenize $tempString2[0] "|" $tempString3;
	for ($y=0;$y<size($tempString3);$y++)
		if (`attributeExists noSkin $tempString3[$y]`)
			if (`getAttr ($tempString3[$y]+".noSkin")`)
				$skip=1;
	for ($y=0;$y<size($tempString3);$y++)
		if (`attributeExists skinControlJoint $tempString3[$y]`)
			if (`getAttr ($tempString3[$y]+".skinControlJoint")`)
				$skip=1;

	if (`attributeExists noSkin $fitJoint`)
		if (`getAttr ($fitJoint+".noSkin")`)
			$skip=1;
	if (`attributeExists skinControlJoint $tempString[$i]`)
		if (`getAttr ($tempString[$i]+".skinControlJoint")`)
			$skip=1;


	if (!$skip)
		$return[size($return)]=$tempString[$i];
	}
return $return;
}

global proc asAnalyzeChainJoints (string $firstJoint)
{
string $kids[]=`asListChildren $firstJoint`;
string $chainJoints[],$tempString[];
clear $chainJoints;
float $pos[3];

//If $firstJoint is "*Part[0-9]*", then downscan until solid firstJoint
if (`gmatch $firstJoint "*Part[0-9]*"`)
	{
	string $child=$firstJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`asListChildren $child`;
		$child=$tempString[0];
		if (!`gmatch $child "*Part[0-9]*"`)
			break;
		}
	$firstJoint=$child;
	clear $kids;
	$kids=`asListChildren $firstJoint`;
	}


while(size($kids)==1)
	{
	if (size($chainJoints)==0)
		$chainJoints[size($chainJoints)]=$firstJoint;
	if (!`gmatch $kids[0] "*Part[0-9]*"`)
		$chainJoints[size($chainJoints)]=$kids[0];
	$tempString=`asListChildren $kids[0]`;
	clear $kids;
	for ($y=0;$y<size($tempString);$y++)
			$kids[size($kids)]=$tempString[$y];
	}

if (size($kids)>1)
	for ($y=0;$y<size($kids);$y++)
		asAnalyzeChainJoints $kids[$y];

//Root exception
if ($chainJoints[0]=="Spine1_M")
	stringArrayInsertAtIndex(0, $chainJoints, "Root_M");

if (size($chainJoints))
	if (!`objExists ($chainJoints[0]+"_middleCurve")`)
		asBuildChainCurves $chainJoints;
}

global proc asBuildChainCurves (string $chainJoints[])
{
int $childIsTwistJoint,$partJointNr,$partJoints,$flip;
int $firstChildMinusX[],$spineJoint[],$terminator[],$topJoint[],$downTwist[],$upTwist[];
float $twistAmount,$rotXoffSet,$twistRot;
float $charHeight=`asgetCharHeight`;
string $curve,$startCurve,$endCurve,$twistCurve,$surface,$poly,$parent,$parentChainJoint,$childChainJoint,$twistJoint,$skinToJoint;
string $fitJoint,$flipppedCurve,$joint,$previousJoint,$priAxis,$absPA,$name,$side;
string $tempString[],$tempString2[],$children[],$siblings[],$curves[],$copyCurves[],$startCurves[],$middleCurves[],$endCurves[],$twistCurves[],$absPriAxis[];
float $scale;
float $pos1[],$pos2[],$pos3[],$priNrml[];

for ($i=0;$i<size($chainJoints);$i++)
	$absPriAxis[$i]=`asGetAxis primary $chainJoints[$i] Main 1`;

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (`gmatch $chainJoints[$i] "Head_M"` || `gmatch $chainJoints[$i] "Hair_M"` || `gmatch $chainJoints[$i] "Root_M"` || `gmatch $chainJoints[$i] "Spine*_M"` || `gmatch $chainJoints[$i] "Chest_M"` || `gmatch $chainJoints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$tempString=`asListChildren $chainJoints[$i]`;
	if (size($tempString))
		if (`getAttr ($tempString[0]+".translate"+$absPriAxis[$i])`<0)
			$firstChildMinusX[$i]=1;
	if (size($tempString)==0)
		$terminator[$i]=1;
	if (`asListParent $chainJoints[$i]`=="")
		$topJoint[$i]=1;
	}

//Middlecurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$middleCurve=$chainJoints[$i]+"_middleCurve";
	$middleCurves[size($middleCurves)]=$middleCurve;
	asCreateMeshCurve $middleCurve;
	$profileCurve=`substitute "Curve" $middleCurve "Profile"`;
	$scale=$charHeight/40;
	if (`gmatch $chainJoints[$i] "Wrist_*"`)
		$scale=$charHeight/80;
	if (`gmatch $chainJoints[$i] "Elbow_*"`)
		$scale=$charHeight/60;
	if (`gmatch $chainJoints[$i] "*Finger*"`)
		$scale=$charHeight/140;
	if ($spineJoint[$i])
		$scale=$charHeight/15;
	xform -os -s $scale $scale $scale $profileCurve;

	asAlign $profileCurve $chainJoints[$i] 1 1 0 0;
	//partially align with parent for elbow/knee
	$parent=`asListParent $chainJoints[$i]`;
	if (`gmatch $chainJoints[$i] "Elbow*"` || `gmatch $chainJoints[$i] "Knee*"`)
		if ($parent!="")
			{//opm req interpType 2
			$tempString=`orientConstraint $chainJoints[$i] $parent $profileCurve`;
			setAttr ($tempString[0]+".interpType") 2;
			delete $tempString[0];
			}

	if ($terminator[$i])
		asAlign $profileCurve `asListParent $chainJoints[$i]` 0 1 0 0;
	parent $profileCurve MeshCurves;
	editDisplayLayerMembers -noRecurse SkinCurves1 $profileCurve;

	refresh;
	}

//Twistcurves (includes partialJoints)
for ($i=0;$i<size($chainJoints);$i++)
	{
	$childIsTwistJoint=1;
	$joint=$chainJoints[$i];
	tokenize $joint "_" $tempString;
	$fitJoint=$tempString[0];
	$partJoints=2;//$partJoints can be TwistJoints or InbetweenJoints
	if (`attributeExists inbetweenJoints $fitJoint`)
		$partJoints=`getAttr ($fitJoint+".inbetweenJoints")`;
	if (`attributeExists twistJoints $fitJoint`)
		$partJoints=`getAttr ($fitJoint+".twistJoints")`;
	$partJointNr=1;
	while($childIsTwistJoint)
		{
		$childIsTwistJoint=0;
		$tempString=`asListChildren $joint`;
		$twistJoint=$tempString[0];
		for ($y=0;$y<size($tempString);$y++)
			if (`gmatch $tempString[$y] "*Part[0-9]*"`)
				$twistJoint=$tempString[$y];
		$joint=$twistJoint;
		if (`gmatch $joint "*Part[0-9]*"`)
			$childIsTwistJoint=1;
		else
			break;
		if ($childIsTwistJoint)
			{
			$downTwist[$i]=$downTwist[$i]+1;
			$twistCurve=$chainJoints[$i]+"_twistCurve"+$downTwist[$i];
			$twistCurves[size($twistCurves)]=$twistCurve;
			asCreateMeshCurve $twistCurve;
			$profileCurve=`substitute "Curve" $twistCurve "Profile"`;
			createNode -n ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") transform;
			parent ($chainJoints[$i]+"_twistProfile"+$downTwist[$i]) ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			parent ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") MeshCurves;
			editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
			asAlign ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") $twistJoint 1 1 0 0;
			$twistAmount=(1.0/($partJoints+1))*$partJointNr;			
			pointConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			pointConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			}
		$partJointNr++;
		}
	if ($i>0 && $downTwist[$i-1])
		$upTwist[$i]=$downTwist[$i-1];
	}

//Startcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		$startCurve=$chainJoints[$i]+"_startCurve";
		$startCurves[size($startCurves)]=$startCurve;
		asCreateMeshCurve $startCurve;
		$profileCurve=`substitute "Curve" $startCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_startCurveOffset") transform;
		parent ($chainJoints[$i]+"_startProfile") ($chainJoints[$i]+"_startCurveOffset");
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_startCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		//first startCurve
		if ($i==0)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_startProfile.translate"+$absPriAxis[$i]) 0.482;
			else
				setAttr ($chainJoints[$i]+"_startProfile.translate"+$absPriAxis[$i]) -0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		if ($i>0)
			{
			pointConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			}
		}
	}

//Endcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		$endCurve=$chainJoints[$i]+"_endCurve";
		$endCurves[size($endCurves)]=$endCurve;
		asCreateMeshCurve $endCurve;
		$profileCurve=`substitute "Curve" $endCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_endCurveOffset") transform;
		parent ($chainJoints[$i]+"_endProfile") ($chainJoints[$i]+"_endCurveOffset");
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_endCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		//last endCurve
		if ($i==size($chainJoints)-1)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_endProfile.translate"+$absPriAxis[$i]) -0.482;
			else
				setAttr ($chainJoints[$i]+"_endProfile.translate"+$absPriAxis[$i]) 0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		if ($i<size($chainJoints)-1)
			{
			pointConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			}
		}
	}

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_startCurve";
	$curves[size($curves)]=$chainJoints[$i]+"_middleCurve";
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_endCurve";
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		$curves[size($curves)]=$chainJoints[$i]+"_twistCurve"+$y;

	//branch
	$children=`asListChildren $chainJoints[$i]`;
	$tempString[0]=`asListParent $chainJoints[$i]`;
	$parent=$tempString[0];
	if ($parent!="")
		$siblings=`asListChildren $parent`;
	if (!(size($children)>1 || size($siblings)>1))
		continue;
	}

//unTwist curves
for ($i=0;$i<size($curves);$i++)
	{
	duplicate -n ($curves[$i]+"_copy") $curves[$i];
	connectAttr ($curves[$i]+".worldSpace[0]") ($curves[$i]+"_copy.create");
	$copyCurves[size($copyCurves)]=$curves[$i]+"_copy";
	tokenize $curves[$i] "_" $tempString;
	$joint="";
	for ($y=0;$y<size($tempString);$y++)
		{
		$joint+=$tempString[$y];
		if ($y==size($tempString)-2)
			break;
		$joint+="_";
		}
	$absPA=`asGetAxis primary $joint Main 1`;
	$twistRot=`getAttr ($joint+".jointOrient"+$absPA)`;
	if ($i>0 && ($twistRot>90 || $twistRot<-90) && $joint!=$previousJoint)//only detect flip once per joint
		$flip=!$flip;
//if ($joint=="Toes_R") $flip=!$flip;
	$previousJoint=$joint;
	if ($flip)
		setAttr ($curves[$i]+"_copy.rotate"+$absPA) 180;
	}

$surface=$chainJoints[0]+"_surface";
$poly=$chainJoints[0]+"_poly";
if (size($chainJoints)==1)
		extrude -n $surface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($charHeight/-250) -rotation 0 -scale 1 -dl 3 $copyCurves;
else
	loft -n $surface -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true $copyCurves;

parent $surface NurbsGeometry;
nurbsToPoly -n $poly -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 $surface;
polySoftEdge -angle 0 -ch 1 $poly;
if (`gmatch $chainJoints[0] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $poly;
//polyMergeVertex -d 0.01 -am 1 -ch 1 $poly;
polyMergeVertex -d 0.0001 -am 1 -ch 1 $poly;
//displaySmoothness -polygonObject 3;
duplicate -n ($poly+"_copy") $poly;
parent $poly MeshGeometry;

//Create SkinCluster
select $chainJoints;
//include parentJoint
$tempString=`listRelatives -type joint -p $chainJoints[0]`;
if (size($tempString))
	select -add $tempString[0];
//deselect endJoints
for ($i=0;$i<size($chainJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
	if (!`size($tempString)`)
		select -d $chainJoints[$i];
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -type joint -c $tempString[$i]`;
	if (size($tempString2))
		select -add $tempString[$i];
	}
//include twistJoints
for ($i=0;$i<size($chainJoints);$i++)
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		select -add ($tempString[0]+"Part"+$y+"_"+$tempString[1]);
		}
//include 50`s (now called "Partial")
for ($i=0;$i<size($chainJoints[$i]);$i++)
	{
	tokenize $chainJoints[$i] "_" $tempString;
	$name=$tempString[0];
	$side="_"+$tempString[1];
	if (`objExists ($name+"Partial"+$side)`)
		select -add ($name+"Partial"+$side);
	}
select -add $poly;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

float $temp[3];
int $vertIndex;
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($poly+"Shape.outMesh") closestSampler.inMesh;
$tempString=`listConnections ($poly+"Shape.inMesh")`;
string $skinCluster=$tempString[0];

//Skinning cylinders
for ($i=0;$i<size($chainJoints);$i++)
	{
	tokenize $chainJoints[$i] "_" $tempString;
	$name=$tempString[0];
	$side="_"+$tempString[1];

	//Middlecurves
	for ($y=0;$y<4;$y++)
		{
		$temp=`xform -q -ws -t ($chainJoints[$i]+"_middleCurve.cv["+$y+"]")`;
		setAttr closestSampler.inPositionX $temp[0];
		setAttr closestSampler.inPositionY $temp[1];
		setAttr closestSampler.inPositionZ $temp[2];
		$vertIndex=`getAttr closestSampler.closestVertexIndex`;
		$skinToJoint=$chainJoints[$i];
		$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
		if (!`size($tempString)`)
			{
			$tempString2=`listRelatives -type joint -p $chainJoints[$i]`;
			if (`size($tempString2)`)
				$skinToJoint=$tempString2[0];
			}

		skinPercent -tv $skinToJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		$tempString=`listRelatives -type joint -p $chainJoints[$i]`;
		if (!$spineJoint[$i])
			if (size($tempString))
				if ($skinToJoint==$chainJoints[$i])
					skinPercent -tv $tempString[0] 0.5 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		if (`objExists ($name+"Partial"+$side)`)
			skinPercent -tv ($name+"Partial"+$side) 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
		}

	//Twistcurves
	for ($z=1;$z<$downTwist[$i]+1;$z++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$z+"_"+$tempString[1];
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_twistCurve"+$z+".cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $twistJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}

		}

	//Startcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$topJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_startCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			if ($i>0)
				skinPercent -tv $chainJoints[$i-1] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			else
				{
				$tempString=`listRelatives -type joint -p $chainJoints[0]`;
				skinPercent -tv $tempString[0] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
				}
			}
		}
	//Endcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_endCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $chainJoints[$i] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}
		}
	}

if (size($children)==0)
	{
	$endJoint=$chainJoints[size($chainJoints)-1];
	$priAxis=`asGetAxis primary $endJoint Main 0`;
	$priNrml=`asAxisToVector $priAxis`;
	polyPlane -n ($endJoint+"_cap_copy") -w 1 -h 1 -sx 1 -sy 1 -ax $priNrml[0] $priNrml[1] $priNrml[2] -cuv 2 -ch 0;
	if (`gmatch $endJoint "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($endJoint+"_cap_copy");
	setAttr -type float3 ($endJoint+"_cap_copy.s") ($scale*2*(1/1.2)) ($scale*2*(1/1.2)) ($scale*2*(1/1.2));
	asAlign ($endJoint+"_cap_copy") $endJoint 1 1 0 0;
	asAlign ($endJoint+"_cap_copy") `asListParent $endJoint` 0 1 0 0;
	}
}

global proc asCreateMeshCurve (string $curve)
{
string $joint;
string $tempString[];

tokenize $curve "_" $tempString;
for ($y=0;$y<size($tempString)-1;$y++)
	{
	$joint+=$tempString[$y];
	if ($y<size($tempString)-2)
		$joint+="_";
	}

$tempString[0]=`curve -d 1 -p 0 -1 1 -p 0 1 1 -p 0 1 -1 -p 0 -1 -1 -p 0 -1 1`;
rename $tempString[0] $curve;
reverseCurve -ch 0 -rpo 1 $curve;

//axis-orient
if (`objExists tempXform`) delete tempXform;
createNode -n tempXform transform;
$tempString=`orientConstraint tempXform $curve`;
asSetOrientOffsetFromAxis $tempString[0] $joint FitSkeleton;

delete $tempString[0];
delete tempXform;
refresh;
makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 $curve;

$profileCurve=`substitute "Curve" $curve "Profile"`;
duplicate -n $profileCurve $curve;
sets -add SkinCageCurvesSet $profileCurve;
scale -r 1.2 1.2 1.2 $profileCurve;
parent $curve $profileCurve;
connectAttr ($profileCurve+".worldSpace[0]") ($curve+".create");
setAttr ($curve+".v") 0;

}

global proc asCreateBranchBoxes ()
{
int $closestFaceNr,$maxNumFaces,$extrudeDirectionFlip,$numNonPlanarA,$numNonPlanarB,$leastOneEdgeWillConnect;
int $tempInts[];
int $edges[]={14,16,18,19,22,24,26,27,30,32,34,35,38,40,42,43,46,48,50,51,54,56,58,59,62,64,66,67,70,72,
	74,75,78,80,82,83,86,88,90,91,94,96,98,99,102,104,106,107,110,112,114,115,118,120,122,123,126,128,130,
	131,134,136,138,139,142,144,146,147,150,152,154,155,158,160,162,163,166,168,170,171};
vector $v1,$v2;
string $curve,$mesh,$parentCurve,$childCurve,$bridgeCurve,$bridgeSide,$rlaChild,$closestVtxA,$closestVtxB;
string $tempString[],$tempString2[],$children[];
float $height=`getAttr "Main.height"`;
float $dist,$minDist,$minVtxDist,$dot,$minDot;
float $posA[],$posB[],$posC[],$vtxAPos[],$vtxBPos[];
string $joints[]=`asListAllDecents DeformationSystem`;

for ($i=0;$i<size($joints);$i++)
	{
	$children=`asListChildren $joints[$i]`;

	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $joints[$i]`)
			continue;

	//For the Root, drop Spine as child
	$rlaChild=`asRlaChild $joints[$i]`;
	if ($joints[$i]=="Root_M" && `stringArrayCount $rlaChild $children`)
		$children=`stringArrayRemove {$rlaChild} $children`;

	//drop children that nave no curve
	for ($y=0;$y<size($children);$y++)
		if (!`objExists ($children[$y]+"_startCurve")` && !`objExists ($children[$y]+"_middleCurve")`)
			{
			$children=`stringArrayRemove {$children[$y]} $children`;
			$y--;
			}

	if (size($children)<2) // branching only with 2 or more children
		continue;

	//find $parentCurve
	$parentCurve=$joints[$i]+"_middleCurve";
	if (`objExists ($joints[$i]+"_endCurve")`)
		$parentCurve=($joints[$i]+"_endCurve");

	//drop joints that have no curve
	if (!`objExists $parentCurve`)
		continue;

	createNode -n branchBoxCenter transform;
	pointConstraint $joints[$i] branchBoxCenter;
	if ($joints[$i]!="Root_M")
		for ($y=0;$y<size($children);$y++)
			pointConstraint $children[$y] branchBoxCenter;

	//find $childrenCurves
	for ($y=0;$y<size($children);$y++)
		{
		if (`objExists ($children[$y]+"_startCurve")`)
			$childCurve=$children[$y]+"_startCurve";
		else if (`objExists ($children[$y]+"_middleCurve")`)
			$childCurve=$children[$y]+"_middleCurve";

		//find closest `facing-ratio` face by dotProducting faceNormals
		polyPlane -n ("tempPolyPlane"+$children[$y]) -w 1 -h 1 -sx 1 -sy 1 -ax 0 1 0 -cuv 2 -ch 0;
		asAlign ("tempPolyPlane"+$children[$y]) $childCurve 1 0 0 0;
	//change to aim at a point in the center of the `branch-box`
//		delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "vector" -worldUpVector 1 0 0 branchBoxCenter ("tempPolyPlane"+$children[$y])`;
		delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "vector" -worldUpVector 1 0 0 $joints[$i] ("tempPolyPlane"+$children[$y])`;
		makeIdentity -a 1 -t 0 -r 1 -s 0 ("tempPolyPlane"+$children[$y]);
		$v1=`asGetPolyFaceNormal ("tempPolyPlane"+$children[$y]+".f[0]")`;
		delete ("tempPolyPlane"+$children[$y]);

		if ($y>0)
			{
			//bridge from FaceOnExistingBridge instead
			tokenize $joints[$i] "_" $tempString;
			$bridgeSide="_"+$tempString[size($tempString)-1];
			$bridgeCurve="bridgeCurve_"+$joints[$i]+$bridgeSide+"_middleProfile";
			select $childCurve;
			$tempString=`cluster -n tempCluster -envelope 1`;
			$posA=`getAttr tempClusterHandleShape.origin`;
			delete tempCluster;
			$minDist=999;
			$minDot=999;
			$tempInts=`polyEvaluate -f bridgeMesh`;
			$maxNumFaces=$tempInts[0];
			for ($z=0;$z<$maxNumFaces;$z++)
				{
				$v2=`asGetPolyFaceNormal ("bridgeMesh.f["+$z+"]")`;
				$dot=`dotProduct $v1 $v2 0`;
				if ($dot<$minDot)
					{
					//only if at least 1 edge will be connecting to nearest vtx
					if (`objExists closestSampler`)
						delete closestSampler;
					createNode -n closestSampler closestPointOnMesh;
					connectAttr -f bridgeMesh.outMesh closestSampler.inMesh;
					$leastOneEdgeWillConnect=0;
					select ("bridgeMesh.f["+$z+"]");
					ConvertSelectionToVertices;
					$tempString=`ls -sl -fl`;
					for ($a=0;$a<4;$a++)
						{
						$posA=`xform -q -ws -t ($childCurve+".cv["+$a+"]")`;
						setAttr -type float3 closestSampler.inPosition $posA[0] $posA[1] $posA[2];
						$tempString2[0]="bridgeMesh.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";	
						if (`stringArrayCount $tempString2[0] $tempString`)
							$leastOneEdgeWillConnect=1;
						}
					if ($leastOneEdgeWillConnect)
						{
						$minDot=$dot;
						$closestFaceNr=$z;
						}
					delete closestSampler;
					}
				}
			select ("bridgeMesh.f["+$closestFaceNr+"]");
			ConvertSelectionToEdges;
			DuplicateCurve -ch 0;
			$tempString=`ls -sl`;
//			AttachCurve -ch 0;preference-dependence
			attachCurve -ch 0 -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1;
			delete $tempString;
			$tempString=`ls -sl`;
			rename $tempString[0] $bridgeCurve;
			}

		for ($b=1;$b>-2;$b=$b-2)
			{
			$extrudeDirectionFlip=1;
			if ($b==1)  {$curve=$parentCurve;$mesh="parentMesh";$extrudeDirectionFlip=-1;}
			if ($b==-1) {$curve=$childCurve;$mesh="childMesh";}
			if ($y>0 && $b==1) $curve=$bridgeCurve;
			if (`gmatch $curve "*_L_*"`) $extrudeDirectionFlip*=-1;
			if (`gmatch $curve "*Root_M_*"`) $extrudeDirectionFlip*=-1;
			extrude -n parentSurface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($height/100*$extrudeDirectionFlip) -rotation 0 -scale 1 -dl 3 $curve;
			if (`objExists $bridgeCurve`) delete $bridgeCurve;
			nurbsToPoly -n $mesh -mnd 1 -ch 0 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 1 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 parentSurface;
			delete parentSurface;
			select ($mesh+".e[2]") ($mesh+".e[6]") ($mesh+".e[9]") ($mesh+".e[11]");
			FillHole;
			if ($extrudeDirectionFlip==-1)
				polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $mesh;
			}
		select parentMesh childMesh;
		DeleteHistory;
		polyUnite -mergeUVSets 1 -name ("bridgeMesh"+$y);
		select ("bridgeMesh"+$y);
		DeleteHistory;
		//Use high `divisions` for bridge, as it is more likly to not `flip`, then later remove excess topology.
		$tempString=`polyBridgeEdge -ch 1 -divisions 20 -twist 0 -taper 1 -curveType 0 -smoothingAngle 30`;
		rename $tempString[0] SkinCurvesBranchingPolyBridgeEdge;

//if ($y==3) {select -add $childCurve;a;}
		select ("bridgeMesh"+$y+".f[0:9]");
		delete;
		select -cl;
		for ($z=0;$z<size($edges);$z++)
			select -add ("bridgeMesh"+$y+".e["+$edges[$z]+"]");
		$tempString=`ls -sl`;
		ConvertSelectionToVertices;
		$tempString2=`ls -sl`;
		select $tempString;
		delete;
		select $tempString2;
		delete;
		select ("bridgeMesh"+$y);
		DeleteHistory;
		if ($y==0)
			duplicate -n bridgeMesh bridgeMesh0;
		else
			{
			rename bridgeMesh bridgeMeshOld;
			delete ("bridgeMeshOld.f["+$closestFaceNr+"]");//break open tunnel
			duplicate -n ("bridgeMeshToMerge"+$y) ("bridgeMesh"+$y);
			select bridgeMeshOld ("bridgeMeshToMerge"+$y);
			polyUnite -ch 0 -mergeUVSets 1 -name bridgeMesh;
			polyMergeVertex  -d 0.001 -am 1 -ch 0 bridgeMesh;
			select -cl;
			//remove non-symmetry edges, for branches from center with even number of children e.g. crotch
			if (`gmatch $joints[$i] "*_M"` && size($children)%2==0)
				asRemoveForthEdge bridgeMesh;
			}
		}
	delete branchBoxCenter;
	rename bridgeMesh ($joints[$i]+"_branch");
	delete `ls "bridgeMesh*"`;
	}
}

global proc int[] asCvFlip (int $vc[])
{
int $flipCv[]=$vc;
if ($vc[0]==0 && $vc[1]==1) $flipCv={3,2};
if ($vc[0]==1 && $vc[1]==0) $flipCv={2,3};

if ($vc[0]==2 && $vc[1]==3) $flipCv={1,0};
if ($vc[0]==3 && $vc[1]==2) $flipCv={0,1};

if ($vc[0]==1 && $vc[1]==2) $flipCv={0,3};
if ($vc[0]==2 && $vc[1]==1) $flipCv={3,0};

if ($vc[0]==0 && $vc[1]==3) $flipCv={1,2};
if ($vc[0]==3 && $vc[1]==0) $flipCv={2,1};
return $flipCv;
}

global proc asCopySkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinCage`)
	return;
string $sel[]=`ls -sl`;
int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 skinCage`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r skinCage ;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc asHardenWeights ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
int $hasSkinCluster;
string $maxTransform;
string $tempString[],$history[],$joints[],$transforms[];
float $values[];
string $skinCluster;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s -ni $sel[$i]`;
	if (size($tempString)<1)
		continue;

	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}
	if (!$hasSkinCluster)
		error ("Object:\""+$sel[$i]+"\" has not skinCluster");		
	$joints=`listConnections ($skinCluster+".matrix")`;
	for ($y=0;$y<size($joints);$y++)
		setAttr ($joints[$y]+".lockInfluenceWeights") 0;

	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Hardening Vtx weight" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
		progressBar -e -s 1 $gMainProgressBar;
		$transforms=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		float $maxValue=0;
		for ($z=0;$z<size($transforms);$z++)
			{
			if ($values[$z]>$maxValue)
				{
				$maxValue=$values[$z];
				$maxTransform=$transforms[$z];
				}
			}
		skinPercent -tv $maxTransform 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
		}
	progressBar -e -ep $gMainProgressBar;
	}
}

global proc asApplyDeltaMush ()
{
string $tempString[];
string $confirmResult,$systemCmd;

deltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1;
asConnectDeltaMushScale;

print "// DeltaMush applied\n";
}

global proc asConnectDeltaMushScale () 
{
if (!`objExists Main`)
	return;
string $deltaMushNodes[]=`ls -type deltaMush`;

for ($i=0;$i<size($deltaMushNodes);$i++)
	{
	if (`isConnected MainScaleMultiplyDivide.outputX ($deltaMushNodes[$i]+".sx")`)
		continue;
	connectAttr MainScaleMultiplyDivide.outputX ($deltaMushNodes[$i]+".sx");
	connectAttr MainScaleMultiplyDivide.outputY ($deltaMushNodes[$i]+".sy");
	connectAttr MainScaleMultiplyDivide.outputZ ($deltaMushNodes[$i]+".sz");
	}
}

global proc asWrapExlude ()
{
//if (!`asConfirmIfNotInBuildPose`)
//	return;

string $sel[]=`ls -sl`;
if (!size($sel))
	error "No vertices selected ";
if (!`gmatch $sel[0] "*[.]vtx[[]*"`)
	error "Selection must be  vertices";
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
string $wrapDeformer,$skinCluster;
int $hadSkinCluster=0;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`nodeType $tempString[$y]` == "wrap")
		$wrapDeformer=$tempString[$y];
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
	}
if ($wrapDeformer=="")
	error "No wrap deformer on selected object";

if ($skinCluster=="")
	{
	asCopySkin;
	$tempString=`ls -sl -o`;
	$tempString=`listRelatives -p $tempString[0]`;
	select $tempString[0];
	asSmoothSkin;
	select $sel;
	}
else
	$hadSkinCluster=1;
$tempString=`listHistory -pdo 1 $sel[0]`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
$tempString=`listConnections ($wrapDeformer+".message")`;
string $wrapSet=$tempString[0];
$tempString=`listConnections ($skinCluster+".message")`;
string $skinClusterSet=$tempString[0];
sets -rm $wrapSet;
asInvertSelection;
sets -rm $skinClusterSet;
if (!$hadSkinCluster)
	{
	$tempString=`ls -sl -o`;
	select $tempString[0];
	removeUnusedInfluences;
	}
select $sel;
print ("// Selected vertices are now deformed by "+$skinCluster+" instead of wrapDeformer\n");
}

global proc asCreateSkinSub ()
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "\"skinCage\" not found, You must create a skinCage (option2) first.";
if (`objExists skinSub`)
	error "\"skinSub\" already exists.";
if (!`objExists Cages`)
	{
	createNode -n Cages transform;
	parent Cages "Geometry";
	}

createNode -n subWrapPolySmoothProxy polySmoothProxy;
polyCube -n skinSub  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
parent skinSub Cages;
connectAttr skinCageShape.outMesh subWrapPolySmoothProxy.inputPolymesh;
connectAttr subWrapPolySmoothProxy.output skinSub.inMesh;
select skinSub;
createDisplayLayer -name SkinSub -number 1 -nr;
//setAttr SkinSub.shading 0;
setAttr SkinSub.displayType 2;
setAttr SkinSub.color 30;
setAttr SkinCage.displayType 1;
select $sel;
}

global proc asDeleteSkinSub ()
{
if (`objExists skinSub`)
	delete skinSub;
if (`objExists SkinSub`)
	delete SkinSub;
}

global proc asWrapSkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
if (!`objExists skinSub`)
	error "\"skinSub\" not found, you must create SubWrap first";
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	{
	string $historyNodes[]=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]` == "wrap")
			error ($sel[$i]+" already have wrapDeformer");
	}

if (!`attributeExists wrapDeform Main`)
	{
	addAttr -k 1 -ln "wrapDeform" -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.wrapDeform;
	}
if (!`objExists wrapDeformReverse`)
	{
	createNode -n wrapDeformReverse reverse;
	connectAttr Main.wrapDeform wrapDeformReverse.inputX;
	}
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	select -add skinSub ;
//	CreateWrap;
//	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	asDeformer ("doWrapArgList 7 { \"1\",\"0\",\"1\", \"2\", \"1\", \"1\", \"1\", \"0\" }");//use asDeformer to ensure Set is created in Maya2022 and above
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
	}
string $wraps[]=`listConnections -type wrap skinSub.worldMesh`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
float $wrapValues[]={0,0,1,0,0};
string $wrap;

for ($i=0;$i<size($wraps);$i++)
	{
	$wrap=`rename $wraps[$i] ("subWrap"+($i+1))`;
	$tempString=`listConnections ($wrap+".outputGeometry")`;
	setAttr ($wrap+".nodeState") 1;
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (`attributeExists $wrapAttrs[$y] $tempString[0]`) //We could be reattaching, so reuse wrapInfo
			$wrapValues[$y]=`getAttr ($tempString[0]+"."+$wrapAttrs[$y])`;
		setAttr ($wrap+"."+$wrapAttrs[$y]) $wrapValues[$y];
		}
	setAttr skinSub.dropoff 4;
	setAttr skinSub.smoothness 0;
	setAttr skinSub.inflType 2;
	connectAttr wrapDeformReverse.output.outputX ($wrap+".nodeState");
	}
select -cl;
}

global proc asSkinSubAttach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinSub`) error "\"skinSub\" not found, you must create SubWrap first";
if (!`objExists skinCage`) error "\"skinCage\" not found, you must create SubWrap first";
if (!`attributeExists subWrapped skinCage`) error "No SubWraps have been detached";
int $numAttach;
string $msh;
string $tempString[];
$tempString[0]=`getAttr skinCage.subWrapped`;
tokenize $tempString[0] ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	$msh=$tempString[$i];
	if (!`objExists $msh`)
		continue;
	select $msh;
	asWrapSkin;
	$numAttach++;
	}
print ("//"+$numAttach+" SubWrap(s) attached");
}

global proc asSkinSubDetach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
string $tempString[],$tempString2[];
string $msh,$subWrappedString;
for ($i=0;$i<size($subWraps);$i++)
	{
	//store wrapInfo on the meshes they deform.
	$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString2=`listRelatives -p $tempString[$y]`;
			$msh=$tempString2[0];
			}
	$subWrappedString+=$msh+";";
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (!`attributeExists $wrapAttrs[$y] $msh`) addAttr -ln $wrapAttrs[$y] -at double $msh;
		setAttr ($msh+"."+$wrapAttrs[$y]) `getAttr ($subWraps[$i]+"."+$wrapAttrs[$y])`;
		}
	delete $subWraps;
	print ("//"+`size($subWraps)`+" SubWrap(s) detached");
	}
if (!`attributeExists subWrapped skinCage`)
	addAttr -ln "subWrapped" -dt "string" skinCage;
setAttr -type "string" skinCage.subWrapped $subWrappedString;
}

global proc asSmoothSkin ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $pos[];
string $tempString[];
string $smoothJoints[];
if (`objExists Head_M`)
	{
	$tempString=`listRelatives -p Head_M`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$smoothJoints[size($smoothJoints)]=$parent;
		$tempString=`listRelatives -p $parent`;
		$parent=$tempString[0];
		}
	}
string $lookforJoints[]={"Root_M","Hip_R","Hip_L"};
for ($i=0;$i<size($lookforJoints);$i++)
if (`objExists $lookforJoints[$i]`)
	$smoothJoints[size($smoothJoints)]=$lookforJoints[$i];
string $skinCluster;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]` == "skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		error "Found no skinCluster on selected object";
	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Finding Vtx for smoothing" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		for ($z=0;$z<size($smoothJoints);$z++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
			if ($z==0)
				progressBar -e -s 1 $gMainProgressBar;
			$tempString=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
			if (`stringArrayCount $smoothJoints[$z] $tempString`)
				{
				select -add ($sel[$i]+".vtx["+$y+"]");
				//middleVtx to root
				if (`gmatch $smoothJoints[$z] "*Root_M*"` || `gmatch $smoothJoints[$z] "*Hip_*"`)
					{
					$pos=`xform -q -ws -t ($sel[$i]+".vtx["+$y+"]")`;
					if ($pos[0]>($charHeight/-5000.0) && $pos[0]<($charHeight/5000.0))
						skinPercent -tv $smoothJoints[$z] 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
					}
				}
			}
		if (size(`ls -sl`))
			weightHammerVerts;
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asDeleteSkinCurves ()
{
if (!`objExists skinCageShape` || !`objExists skinClusterSkinCage`)
	return;
setAttr skinClusterSkinCage.envelope 0;
duplicate -n asTempMesh skinCageShape;
setAttr skinClusterSkinCage.envelope 1;
string $deleteObjs[]={"SkinCurves1","SkinCurves2","MeshGeometry","MeshCurves","NurbsGeometry"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
string $tempString[]=`listRelatives -s -type mesh skinCage`;
for ($mesh in $tempString)
	if ($mesh!="skinCageShape")
		{
		connectAttr asTempMesh.outMesh ($mesh+".inMesh");
		evalDeferred -lp ("delete asTempMesh");
		break;
		}
}

global proc string asNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";if ($nr==1) $letter="A";if ($nr==2) $letter="B";
if ($nr==3) $letter="C";if ($nr==4) $letter="D";if ($nr==5) $letter="E";
if ($nr==6) $letter="F";if ($nr==7) $letter="G";if ($nr==8) $letter="H";
if ($nr==9) $letter="I";if ($nr==10) $letter="J";if ($nr==11) $letter="K";
if ($nr==12) $letter="L";if ($nr==13) $letter="M";if ($nr==14) $letter="N";
if ($nr==15) $letter="O";if ($nr==16) $letter="P";if ($nr==17) $letter="Q";
if ($nr==18) $letter="R";if ($nr==19) $letter="S";if ($nr==20) $letter="T";
if ($nr==21) $letter="U";if ($nr==22) $letter="V";if ($nr==23) $letter="W";
if ($nr==24) $letter="X";if ($nr==25) $letter="Y";if ($nr==26) $letter="Z";
return $letter;
}

global proc asSetRenderable (string $shape, int $onOff)
{
string $atts[]={"castsShadows","receiveShadows","motionBlur","primaryVisibility","smoothShading","visibleInReflections","visibleInRefractions"};
//"doubleSided";
for ($i=0;$i<size($atts);$i++)
	if (`attributeExists $atts[$i] $shape`)
		setAttr ($shape+"."+$atts[$i]) $onOff;
}

global proc asImportIconsFile (string $iconsFile)
{
string $beforeObj[],$afterObj[];
int $fromBefore[];
int $readLine;
$fileId=`fopen $iconsFile "r"`;
string $nextLine = `fgetline $fileId`;
string $previousLine;

createNode -n "iconsGroup" transform;
setAttr "iconsGroup.v" 0;
$beforeObj=`ls -l -as`;

while ( size( $nextLine ) > 0 )
	{
	if (!$readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
	if (`gmatch $nextLine "createNode nurbsCurve*"`)
		{
		$readLine=1;
		eval ($previousLine);
		$previousLine = $nextLine;
		$nextLine = `fgetline $fileId`;
		continue;
		}
	if ($readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
		else
			{
			$readLine=0;
			eval ($previousLine);
			}
	$previousLine=$nextLine;
	$nextLine = `fgetline $fileId`;
	}
fclose $fileId;
$afterObj=`ls -l -as`;
for ($i=0;$i<size($afterObj);$i++)
	for ($y=0;$y<size($beforeObj);$y++)
		if ($afterObj[$i]==$beforeObj[$y])
			$fromBefore[$i]=1;
for ($i=0;$i<size($afterObj);$i++)
	if (!$fromBefore[$i])
		parent $afterObj[$i] "iconsGroup";
}

global proc vector asGetPolyFaceNormal (string $obj)
{
int $numTokens;
float $x,$y,$z;
vector $normal;
string $polyInfoString;
string $tokens[],$tempString[];

$tempString=`polyInfo -fn $obj`;
$polyInfoString=$tempString[0];
$numTokens=`tokenize $polyInfoString " " $tokens`;
if ( ( $numTokens > 3 ) && ( $tokens[0] == "FACE_NORMAL" ) )
	{
  $x = ($tokens[$numTokens-3]);
  $y = ($tokens[$numTokens-2]);
  $z = ($tokens[$numTokens-1]);
  $normal = << $x, $y, $z >>;
  $normal = `unit $normal`;
	}
return $normal;
}
	
global proc asCreateController (string $type, string $name, string $side, string $fitJoint)
{
int $rotOrder,$ikLocalType2,$noFlip,$partNr;
float $defaultCtrlScale,$boneLenght,$fat,$fatFront,$fatWidth,$childFat,$childFatFront,$childFatWidth,$partFactor;
float $pos[3],$rot[3],$sca[3],$childSca[3],$axisRot[3],$pos1[3],$pos2[3];
float $s[3]={-1,-1,-1};
//string $absPriAxis=`asGetAxis primary $fitJoint Main 1`;
//string $absSecAxis=`asGetAxis secondary $fitJoint Main 1`;
string $rlaChild;
string $sel[]=`ls -sl`;
string $shapes[],$tempString[];

if (`attributeExists ikLocal $fitJoint`)
	if (`getAttr ($fitJoint+".ikLocal")`==2)//$ikLocal=localOrient
		$ikLocalType2=1;

if (`attributeExists noFlip $fitJoint`)
	$noFlip=`getAttr ($fitJoint+".noFlip")`;

select -cl;
$rotOrder=`getAttr ($fitJoint+".rotateOrder")`;
createNode -n ($type+"Offset"+$name+$side) transform;

createNode -n ($type+"Extra"+$name+$side) transform;
sets -add ControlSet ($type+"Extra"+$name+$side);
parent ($type+"Extra"+$name+$side) ($type+"Offset"+$name+$side);
asLockAttr ($type+"Extra"+$name+$side) 0 0 1 1;
if (`gmatch $name "*Scapula*"`)
	duplicate -n ($type+$name+$side) "Scapula_icon";
else if ($type=="FK" && `gmatch $name "*Part[0-9]*"`)
	duplicate -n ($type+$name+$side) Part_icon;
else
	duplicate -n ($type+$name+$side) ($type+"_icon");
xform -os -t 0 0 0 -ro 0 0 0 ($type+$name+$side);
setAttr -k 0 -cb 1 ($type+$name+$side+".v");
if ($type=="FK" || $type=="IKLocal" || $type=="Bend" || $type=="IKhybrid" || $ikLocalType2)
	{
	if ($noFlip) $s={1,1,1};
	setAttr ($type+"Offset"+$name+$side+".rotateOrder") $rotOrder;
	setAttr ($type+"Extra"+$name+$side+".rotateOrder") $rotOrder;
	setAttr ($type+$name+$side+".rotateOrder") $rotOrder;
	}

if ($side=="_L")
	setAttr -type float3 ($type+$name+$side+".s") -1 -1 -1;

$height=`getAttr "Main.height"`;
$defaultCtrlScale=$height/30.0;
$sca={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
$tempString=`listRelatives -c -type joint $fitJoint`;
if ($tempString[0]!="")
	{
	$pos1=`xform -q -ws -t $fitJoint`;
	$pos2=`xform -q -ws -t $tempString[0]`;
	$boneLenght=`mag<<$pos2[0]-$pos1[0],$pos2[1]-$pos1[1],$pos2[2]-$pos1[2]>>`;
	if ($boneLenght>1)
		$boneLenght=$boneLenght/2.0;
	else
		$boneLenght=$boneLenght+((1-$boneLenght)/2.0);
	$defaultCtrlScale=$defaultCtrlScale*$boneLenght;
	$sca={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
	}

if (`attributeExists fat $fitJoint` && `attributeExists fatFront $fitJoint` && `attributeExists fatWidth $fitJoint`)
	{//Default use fat from FitJoint, as it might not have a correspoding DeformJoint e.g. Bendy controller
	$fat=`getAttr ($fitJoint+$side+".fat")`;
	$fatFront=`getAttr ($fitJoint+$side+".fatFront")`;
	$fatWidth=`getAttr ($fitJoint+$side+".fatWidth")`;
	$sca={$defaultCtrlScale,$fat*$fatFront,$fat*$fatWidth};
	}
if (`attributeExists fat ($name+$side)` && `attributeExists fatFront ($name+$side)` && `attributeExists fatWidth ($name+$side)`)
	{//Override if correspoding DeformJoint has fat added e.g. TwistJoint
	$fat=`getAttr ($name+$side+".fat")`;
	$fatFront=`getAttr ($name+$side+".fatFront")`;
	$fatWidth=`getAttr ($name+$side+".fatWidth")`;
	$sca={$defaultCtrlScale,$fat*$fatFront,$fat*$fatWidth};
	}

/* Removed, taper now in DeformJoint creation
//Twist Ctrls Taper scale
//if ($type=="Twist" && `attributeExists joints $fitJoint`)
if ($type=="FK" && `gmatch $name "*Part[0-9]*"` && `attributeExists partControllers $fitJoint`)
	{
	$rlaChild=`asRlaChild $fitJoint`;
	if (`attributeExists fat $rlaChild`)
		{
		$partNr=`asPartNrFromPartName $name`;
		$childFat=`getAttr ($rlaChild+$side+".fat")`;
		$childFatFront=`getAttr ($rlaChild+$side+".fatFront")`;
		$childFatWidth=`getAttr ($rlaChild+$side+".fatWidth")`;
		$childSca={$defaultCtrlScale,$childFat*$childFatFront,$childFat*$childFatWidth};
		$partFactor=1-($partNr+0.0)/(`getAttr ($fitJoint+".twistJoints")`+1);
		$sca[1]=($sca[1]*$partFactor) + ($childSca[1]*(1-$partFactor));
		}
	}
*/

$shapes=`listRelatives -s -f ($type+$name+$side)`;
for ($i=0;$i<size($shapes);$i++)
	{
	xform -s $sca[1] $sca[1] $sca[1] ($shapes[$i]+".cv[0:99]");
	xform -s 1.5 1.5 1.5 ($shapes[$i]+".cv[0:99]");
	}
makeIdentity -a 1 -t 1 -r 1 -s 1 ($type+$name+$side);

parent -r ($type+$name+$side) ($type+"Extra"+$name+$side);

$pos=`xform -q -ws -t ($fitJoint+$side)`;
$rot=`xform -q -ws -ro ($fitJoint+$side)`;
xform -ws -t $pos[0] $pos[1] $pos[2] ($type+"Offset"+$name+$side);
if ($type=="FK" || $type=="IKLocal" || $type=="Bend" || $type=="HipSwinger" || $type=="IKhybrid")
	{
	select -cl;
	$shapes=`listRelatives -s -f ($type+$name+$side)`;
	for ($i=0;$i<size($shapes);$i++)
		select -add ($shapes[$i]+".cv[0:99]");
	cluster -n tempCluster -envelope 1;
	$pos=`xform -q -ws -t ($type+$name+$side)`;
	xform -ws -t $pos[0] $pos[1] $pos[2] tempClusterHandle.rotatePivot;
	createNode -n tempXform transform;
	$tempString=`orientConstraint tempXform tempClusterHandle`;
	asSetOrientOffsetFromAxis $tempString[0] ($fitJoint+$side) Main;
	select ($type+$name+$side);
	DeleteHistory;
	delete $tempString[0] tempClusterHandle tempXform;
	}
if ($type=="FK")
	xform -ws -ro $rot[0] $rot[1] $rot[2] ($type+"Offset"+$name+$side);

select $sel;
}

global proc asCreateUnTwister (string $fitJoint, string $side, string $twistParent, string $twistParentSide, string $fitJointIK, int $b, int $IkUnTwister, string $ikFollow)
{
int $opm,$rotateOrderNr;
float $scale=`asGetScale`;
if (`objExists ("TwistFollow"+$fitJoint+$side)`)
	return;
string $parentIK;
string $tempString[],$iKInfo[],$twistParentIKInfo[];
$iKInfo=`asFitJointIKInfo $fitJoint`;
string $IK=$iKInfo[0];
string $IKChildJoint=$iKInfo[3];
string $IKNumCtrls=$iKInfo[5];
//fake IK-mid ctrl, to control mid locs
if ($IKNumCtrls==2)
	$IKNumCtrls=3;
string $absPriAxis=`asGetAxis primary ($fitJoint+$side) Main 1`;

if (`checkBox -q -ex asBodyOffsetParentMatrixCheckBox`)
	$opm=`checkBox -q -v asBodyOffsetParentMatrixCheckBox`;

if ($opm)
	{
	asCreateUnTwisterOPM $fitJoint $side $twistParent $twistParentSide $fitJointIK $b $IkUnTwister $ikFollow;
	return;
	}

//find $parentIK
if (`objExists ($twistParent+$twistParentSide)`)
	{
	$twistParentIKInfo=`asFitJointIKInfo $twistParent`;
	$parentIK=$twistParentIKInfo[0];
	}
$tempString=`listRelatives -p $fitJoint`;
string $fitJointParent=$tempString[0];

//print ("TwistFollow"+$fitJoint+$side+"\n");
createNode -n ("TwistFollow"+$fitJoint+$side) -p TwistSystem transform;
createNode -n ("TwistFollowParent"+$fitJoint+$side) -p TwistSystem transform;
asAlign ("TwistFollow"+$fitJoint+$side) ($fitJoint+$side) 1 1 0 1;
if (`objExists ("IKSp"+$fitJoint+$side)`)
	asAlign ("TwistFollow"+$fitJoint+$side) ("IKSp"+$fitJoint+$side) 1 1 0 1;
setAttr -l 1 ("TwistFollow"+$fitJoint+$side+".v") 0;
setAttr -l 1 ("TwistFollowParent"+$fitJoint+$side+".v") 0;

if ($IkUnTwister)
	{
	parentConstraint ($ikFollow+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		{
		if (`objExists ("IKSp"+$twistParent+$twistParentSide)`)
			parentConstraint ("IKSp"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		else
			parentConstraint ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		}
	}
else
	{
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		{
		if ($fitJointParent=="Root" && !$opm)
			parentConstraint LegLockConstrained ("TwistFollowParent"+$fitJoint+$side);
		else
			asConstraintToFKIK "parent" $parentIK ("FKX"+$twistParent+$twistParentSide) ("IKX2"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		}
	}

if (!`objExists ($twistParent+$twistParentSide)`)
	parentConstraint RootX_M ("TwistFollowParent"+$fitJoint+$side);	
//Makes FKIK mixing less flippy, but `might` cause cycle
//		parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);
//setAttr ("TwistFollow"+$fitJoint+$side+"_parentConstraint1.interpType") 2;



select ($fitJoint+$side);
//if (`objExists ("IKSp"+$fitJoint+$side)`)
//	select ("IKSp"+$fitJoint+$side);
joint -n ("UnTwist"+$fitJoint+$side);
joint -n ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwist"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);

if ($IkUnTwister)
	pointConstraint ($ikFollow+$side) ("UnTwist"+$fitJoint+$side);
else
	asConstraintToFKIK "point" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("UnTwist"+$fitJoint+$side);

//stabalize constraint by adding offsetNode
createNode -n ("TwistFollowOffset"+$fitJoint+$side) -p ("TwistFollow"+$fitJoint+$side) transform;
createNode -n ("TwistFollowParentOffset"+$fitJoint+$side) -p ("TwistFollowParent"+$fitJoint+$side) transform;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".r") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".r") 0 0 0;
parent ("TwistFollowOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollowParentOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowOffset"+$fitJoint+$side);
parent ("TwistFollowParent"+$fitJoint+$side) ("TwistFollowParentOffset"+$fitJoint+$side);

setAttr ("UnTwistEnd"+$fitJoint+$side+".translate"+$absPriAxis) ($b*$scale);
ikHandle -n ("UnTwistIK"+$fitJoint+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$fitJoint+$side) -ee ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwistIK"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
poleVectorConstraint ("UnTwist"+$fitJoint+$side) ("UnTwistIK"+$fitJoint+$side);

select ("UnTwist"+$fitJoint+$side);
joint -n ("TwistBalancer"+$fitJoint+$side);
//Primary Axis to be the last axis in rotation order
if ($absPriAxis=="X") $rotateOrderNr=5;
if ($absPriAxis=="Y") $rotateOrderNr=3;
if ($absPriAxis=="Z") $rotateOrderNr=4;
setAttr ("TwistBalancer"+$fitJoint+$side+".rotateOrder") $rotateOrderNr;

if ($IkUnTwister)
	parentConstraint ($ikFollow+$side) ("TwistBalancer"+$fitJoint+$side);
else
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistBalancer"+$fitJoint+$side);
//360, part1
parentConstraint ("UnTwist"+$fitJoint+$side) ("TwistBalancer"+$fitJoint+$side);
//setAttr ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1.interpType") 0;
if (!`objExists MainTwistFlipSetRange`)
	{
	createNode -n MainTwistFlipSetRange setRange;
	setAttr MainTwistFlipSetRange.oldMinX 0;
	setAttr MainTwistFlipSetRange.oldMaxX 1;
	setAttr MainTwistFlipSetRange.minX 1;
	setAttr MainTwistFlipSetRange.maxX 0;

	setAttr MainTwistFlipSetRange.oldMinY 0;
	setAttr MainTwistFlipSetRange.oldMaxY 1;
	setAttr MainTwistFlipSetRange.minY 1;
	setAttr MainTwistFlipSetRange.maxY 2;

	setAttr MainTwistFlipSetRange.oldMinZ 0;
	setAttr MainTwistFlipSetRange.oldMaxZ 1;
	setAttr MainTwistFlipSetRange.minZ 0;
	setAttr MainTwistFlipSetRange.maxZ 1;

//	connectAttr Main.twistFlip MainTwistFlipSetRange.valueX;
//	connectAttr Main.twistFlip MainTwistFlipSetRange.valueY;
	}
//connectAttr -f MainTwistFlipSetRange.outValue.outValueX ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1.interpType");
$tempString=`listAttr -ud ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1")`;
//connectAttr -f Main.twistFlip ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1."+$tempString[size($tempString)-1]);
connectAttr -f MainTwistFlipSetRange.outValue.outValueZ ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1."+$tempString[size($tempString)-1]);

//autoTwist & extraTwist attributes
string $autoTwistCtrl="FK"+$fitJoint+$side;
if ($IkUnTwister)
	$autoTwistCtrl="IK"+$IK+$IKNumCtrls+$side;

addAttr -ln "twist" -at double ("TwistBalancer"+$fitJoint+$side);
addAttr -k 0 -ln "autoTwist" -at double -min 0 -max 10 -dv 10 $autoTwistCtrl;
addAttr -k 0 -ln "extraTwist" -at double $autoTwistCtrl;

createNode -n ($autoTwistCtrl+"AutoTwistUnitConversion") unitConversion;
setAttr ($autoTwistCtrl+"AutoTwistUnitConversion.conversionFactor") 0.1;
connectAttr ($autoTwistCtrl+".autoTwist") ($autoTwistCtrl+"AutoTwistUnitConversion.input");

//360, part2 //setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*2);
createNode -n ($autoTwistCtrl+"360TwistDivideMultiplyDivide") multiplyDivide;
connectAttr -f MainTwistFlipSetRange.outValue.outValueY ($autoTwistCtrl+"360TwistDivideMultiplyDivide.input1X");
connectAttr -f ("TwistBalancer"+$fitJoint+$side+".rotate"+$absPriAxis) ($autoTwistCtrl+"360TwistDivideMultiplyDivide.input2X");

createNode -n ($autoTwistCtrl+"AutoTwistMultiplyDivide") multiplyDivide;
connectAttr -f ($autoTwistCtrl+"AutoTwistUnitConversion.output") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input1X");

connectAttr -f ($autoTwistCtrl+"360TwistDivideMultiplyDivide.outputX") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input2X");
//connectAttr -f ("TwistBalancer"+$fitJoint+$side+".rotateX") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input2X");

createNode -n ($autoTwistCtrl+"ExtraTwistPlusMinusAverage") plusMinusAverage;
connectAttr -f ($autoTwistCtrl+"AutoTwistMultiplyDivide.outputX") ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.input1D[0]");
connectAttr -f ($autoTwistCtrl+".extraTwist") ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.input1D[1]");
connectAttr -f ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.output1D") ("TwistBalancer"+$fitJoint+$side+".twist");
//	connectAttr -f ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.output1D") IKSpineHandle_M.twist;
}

global proc asCreateUnTwisterOPM (string $fitJoint, string $side, string $twistParent, string $twistParentSide, string $fitJointIK, int $b, int $IkUnTwister, string $ikFollow)
{
string $nonPartRlaChild=`nonPartRlaChild $fitJoint`;
int $rotOrder=`getAttr ($fitJoint+".rotateOrder")`;

if ($twistParent=="") {$twistParent="RootX";$twistParentSide="_M";}

createNode -n ($fitJoint+"MMTwist"+$side) multMatrix;
/*
createNode -n ("TwistStartOffset"+$fitJoint+$side) -p ($fitJoint+$side) transform;
createNode -n ("TwistStart"+$fitJoint+$side) -p ("TwistStartOffset"+$fitJoint+$side)  transform;
parent ("TwistStartOffset"+$fitJoint+$side) ($twistParent+$twistParentSide);
parent -r ("TwistStartOffset"+$fitJoint+$side) TwistSystem;
//xform -os -ro 0 0 0 ("TwistStart"+$fitJoint+$side);//TwistFlipping when `aiming backwards` and not at 180, (which is same for straight limbs, but)
//connectAttr ($twistParent+$twistParentSide+".worldMatrix") ("TwistStartOffset"+$fitJoint+$side+".offsetParentMatrix");
//connectAttr ($fitJoint+"MM"+$side+".matrixSum") ("TwistStartOffset"+$fitJoint+$side+".offsetParentMatrix");

connectAttr ("TwistStart"+$fitJoint+$side+".worldInverseMatrix") ($fitJoint+"MMTwist"+$side+".matrixIn[1]");
*/
createNode -n ($fitJoint+"DMTwist"+$side) decomposeMatrix;
setAttr ($fitJoint+"DMTwist"+$side+".inputRotateOrder") $rotOrder;
connectAttr ($fitJoint+"MMTwist"+$side+".matrixSum") ($fitJoint+"DMTwist"+$side+".inputMatrix");

createNode -n ($fitJoint+"QTETwist"+$side) quatToEuler;
connectAttr ($fitJoint+"DMTwist"+$side+".outputQuatX") ($fitJoint+"QTETwist"+$side+".inputQuatX");
connectAttr ($fitJoint+"DMTwist"+$side+".outputQuatW") ($fitJoint+"QTETwist"+$side+".inputQuatW");

/*
//update any UnTwisting Child to have a `Twist-inclusive-TwistStart` (e.g. when doing Shoulder, then Elbow has been done, now connect)
if (`objExists ("TwistStart"+$nonPartRlaChild+$side)`)
	connectAttr ($fitJoint+"QTETwist"+$side+".outputRotate") ("TwistStart"+$nonPartRlaChild+$side+".r");
*/
}

global proc asInsertMMPlug (string $sourcePlug, string $MM, int $plugNr)
{
//int $numPlugs=`getAttr -s ($MM+".matrixIn")`;does not give the correct value during build
int $numPlugs=size(`listConnections -s 1 -d 0 $MM`);
string $plug,$nextPlug;
string $tempString[],$existingPlugs[];

for ($i=$plugNr;$i<$numPlugs;$i++)
	{
	$tempString=`listConnections -s 1 -d 0 -p 1 ($MM+".matrixIn["+$i+"]")`;
	$existingPlugs[$i]=$tempString[0];
	}
for ($i=0;$i<$numPlugs;$i++)
	connectAttr -f $existingPlugs[$i] ($MM+".matrixIn["+($i+1)+"]");
if ($sourcePlug=="")
	disconnectAttr $existingPlugs[$plugNr] ($MM+".matrixIn["+$plugNr+"]");
else
	connectAttr -f $sourcePlug ($MM+".matrixIn["+$plugNr+"]");

/*
int $numIn=`getAttr -s ($MM+".matrixIn")`;
float $m[];
string $tempString[],$tempString2[];

for ($i=$numIn;$i>0;$i--)
	{
	//get previous slot
	$tempString=`listConnections -s 1 -d 0 -p 1 ($MM+".matrixIn["+($i-1)+"]")`;

	//first free up slot, if taken
	$tempString2=`listConnections -s 1 -d 0 -p 1 ($MM+".matrixIn["+$i+"]")`;
	if ($tempString2[0]!="")
		disconnectAttr $tempString2[0] ($MM+".matrixIn["+$i+"]");

	if ($tempString[0]=="")
		{
		$m=`getAttr ($MM+".matrixIn["+($i-1)+"]")`;
		setAttr ($MM+".matrixIn["+$i+"]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		}
	else
		connectAttr -f $tempString[0] ($MM+".matrixIn["+$i+"]");
	}
connectAttr -f $sourcePlug ($MM+".matrixIn["+$plugNr+"]");
*/
}

global proc asInvertSelection ()
{
//Maya 2018 does not seem to work with "InvertSelection" on component selection
string $tempString[]=`ls -sl`;
string $tempString2[]=`ls -sl -o`;
if (`gmatch $tempString[0] "*[.]vtx*"`)
	{
	select ($tempString2[0]+".vtx[0:999999]");
	select -d $tempString;
	}
else if (`gmatch $tempString[0] "*[.]f*"`)
	{
	select ($tempString2[0]+".f[0:999999]");
	select -d $tempString;
	}
else if (`gmatch $tempString[0] "*[.]e*"`)
	{
	select ($tempString2[0]+".e[0:999999]");
	select -d $tempString;
	}
else
	InvertSelection;
}


global proc asUnitConvertAndReverse (string $name, string $driver)
{
createNode -n ($name+"UnitConversion")  unitConversion;
setAttr ($name+"UnitConversion.conversionFactor") 0.1;
connectAttr $driver ($name+"UnitConversion.input");
createNode -n ($name+"Reverse")  reverse;
connectAttr ($name+"UnitConversion.output") ($name+"Reverse.inputX");
}


global proc asNormalizeAndReverse (string $name, string $driver, int $inclReverse)
{//unlike asUnitConvertAndReverse, this preserves _$side at end of name
string $tempString[];
tokenize $name "[.]" $tempString;
string $obj=$tempString[0];
string $attr=$tempString[1];
tokenize $obj "_" $tempString;
$sideLess=$tempString[0];
string $side=$tempString[1];
if ($side!="")
	$side="_"+$side;
/*
string $firstAttrLetter=`substring $attr 1 1`;
string $remainingLetters=`substring $attr 2 999`;
string $name=$sideLess+`toupper $firstAttrLetter`+$remainingLetters;
*/
//createNode -n ($name+"MDL"+$side) multDoubleLinear;
//connectAttr $driver ($name+"MDL"+$side+".input1");
//setAttr ($name+"MDL"+$side+".input2") 0.1;
createNode -n ($sideLess+"UnitConversion"+$side)  unitConversion;
setAttr ($sideLess+"UnitConversion"+$side+".conversionFactor") 0.1;
connectAttr $driver ($sideLess+"UnitConversion"+$side+".input");
if ($inclReverse)
	{
	createNode -n ($sideLess+"Reverse"+$side)  reverse;
	connectAttr ($sideLess+"UnitConversion"+$side+".output") ($sideLess+"Reverse"+$side+".inputX");
	}
}

global proc asSkinWeightMerge (string $sourceSc, string $destSc, string $removeJoint)
{
string $cmd;
string $infJoints[];

$cmd+="import maya.OpenMaya as OpenMaya\n";
$cmd+="import maya.OpenMayaAnim as OpenMayaAnim\n";
$cmd+="import maya.cmds as cmds\n";
$cmd+="import maya.mel as mel\n";

$cmd+="# poly mesh and skinCluster name\n";
$cmd+="sourceSCName = '"+$sourceSc+"'\n";
$cmd+="destSCName = '"+$destSc+"'\n";
$cmd+="removeJoint = '"+$removeJoint+"'\n";

$cmd+="# get the MFnSkinCluster for destSCName\n";
$cmd+="selList = OpenMaya.MSelectionList()\n";
$cmd+="selList.add(destSCName)\n";
$cmd+="clusterNode = OpenMaya.MObject()\n";
$cmd+="selList.getDependNode(0, clusterNode)\n";
$cmd+="skinFn = OpenMayaAnim.MFnSkinCluster(clusterNode)\n";

$cmd+="# get the MDagPath for all influence\n";
$cmd+="infDags = OpenMaya.MDagPathArray()\n";
$cmd+="skinFn.influenceObjects(infDags)\n";

//$cmd+="print infDags\n";

$cmd+="# create a dictionary whose key is the MPlug indice id and \n";
$cmd+="# whose value is the influence list id\n";
$cmd+="infIds = {}\n";
$cmd+="infs = []\n";
$cmd+="for x in xrange(infDags.length()):\n";
//$cmd+="	infPath = infDags[x].fullPathName()\n";
$cmd+="	infPath = infDags[x].partialPathName()\n";
//$cmd+="	infId = int(skinFn.indexForInfluenceObject(infDags[x]))\n";
$cmd+="	infId = x\n";
$cmd+="	infIds[infId] = x\n";
$cmd+="	infs.append(infPath)\n";

$cmd+="# get the MPlug for the weightList and weights attributes\n";
$cmd+="wlPlug = skinFn.findPlug('weightList')\n";
$cmd+="wPlug = skinFn.findPlug('weights')\n";
$cmd+="wlAttr = wlPlug.attribute()\n";
$cmd+="wAttr = wPlug.attribute()\n";
$cmd+="wInfIds = OpenMaya.MIntArray()\n";

$cmd+="# the weights are stored in dictionary, the key is the vertId, \n";
$cmd+="# the value is another dictionary whose key is the influence id and \n";
$cmd+="# value is the weight for that influence\n";
$cmd+="weights = {}\n";
$cmd+="for vId in xrange(wlPlug.numElements()):\n";
$cmd+="	vWeights = {}\n";
$cmd+="	# tell the weights attribute which vertex id it represents\n";
$cmd+="	wPlug.selectAncestorLogicalIndex(vId, wlAttr)\n";
	
$cmd+="	# get the indice of all non-zero weights for this vert\n";
$cmd+="	wPlug.getExistingArrayAttributeIndices(wInfIds)\n";

$cmd+="	# create a copy of the current wPlug\n";
$cmd+="	infPlug = OpenMaya.MPlug(wPlug)\n";
$cmd+="	for infId in wInfIds:\n";
$cmd+="		# tell the infPlug it represents the current influence id\n";
$cmd+="		infPlug.selectAncestorLogicalIndex(infId, wAttr)\n";
		
$cmd+="		# add this influence and its weight to this verts weights\n";
$cmd+="		try:\n";
$cmd+="			vWeights[infIds[infId]] = infPlug.asDouble()\n";
$cmd+="		except KeyError:\n";
$cmd+="			# assumes a removed influence\n";
$cmd+="			pass\n";
$cmd+="	weights[vId] = vWeights\n";

$cmd+="cmds.copySkinWeights(ss=sourceSCName , ds=destSCName, noMirror=True)\n";

$cmd+="for vertId, weightData in weights.items():\n";
$cmd+="	wlAttr = '%s.weightList[%s]' % (destSCName, vertId)\n";
$cmd+="	for infId, infValue in weightData.items():\n";
$cmd+="		if infs[infId] == removeJoint:\n";
$cmd+="			continue\n";
$cmd+="		wAttr = '.weights[%s]' % infId\n";
$cmd+="		cmds.setAttr(wlAttr + wAttr, infValue)\n";

python ($cmd);
}

global proc asSkinWeightSet (string $joint, string $geometry, string $skinCluster, int $vtxNrs[], float $weights[])
{
string $cmd;
string $infJoints[];

if (`asIsMayaLT`)
	{
	asSkinWeightSetMayaLT $joint $geometry $skinCluster $vtxNrs $weights;
	return;
	}

$cmd+="import re as re\n";
$cmd+="import maya.cmds as mc\n";
$cmd+="import maya.OpenMaya as om\n";
$cmd+="import maya.OpenMayaAnim as oma\n";
$cmd+="# get the MFnSkinCluster for clusterName\n";
$cmd+="selList = om.MSelectionList()\n";
$cmd+="selList.add('"+$skinCluster+"')\n";
$cmd+="clusterNode = om.MObject()\n";
$cmd+="selList.getDependNode(0, clusterNode)\n";
$cmd+="skinFn = oma.MFnSkinCluster(clusterNode)\n";
$cmd+="# get the MDagPath for all influence\n";
$cmd+="infDags = om.MDagPathArray()\n";
$cmd+="skinFn.influenceObjects(infDags)\n";
$cmd+="conns = mc.listConnections ('"+$skinCluster+".matrix',c=1)\n";
$cmd+="for i in range(len(conns)):\n";
$cmd+="    if conns[i] == '"+$joint+"':\n";
$cmd+="        stringer = conns[i-1]\n";
$cmd+="        nrA = stringer.split('[')\n";
$cmd+="        nrB = nrA[1].split(']')\n";
$cmd+="        jointNr = int (nrB[0])\n";
$cmd+="vtxNrs = [";
for ($i=0;$i<size($vtxNrs);$i++)
	$cmd+=$vtxNrs[$i]+",";
$cmd+="]\n";
$cmd+="weights = [";
for ($i=0;$i<size($weights);$i++)
	$cmd+=$weights[$i]+",";
$cmd+="]\n";
$cmd+="for i in range(len(vtxNrs)):\n";
$cmd+="    vtxNr = vtxNrs[i]\n";
$cmd+="    wAttr = '"+$skinCluster+".wl[%s].w[%d]' %(vtxNr,jointNr)\n";
$cmd+="    mc.setAttr(wAttr, weights[i])\n";

python ($cmd);

setAttr ($joint+".lockInfluenceWeights") 1;
catchQuiet (`skinPercent -normalize true $skinCluster $geometry`);
setAttr ($joint+".lockInfluenceWeights") 0;
catchQuiet (`skinPercent -normalize true $skinCluster $geometry`);
}

global proc asSkinWeightSetMayaLT (string $joint, string $geometry, string $skinCluster, int $vtxNrs[], float $weights[])
{
for ($i=0;$i<size($weights);$i++)
	catchQuiet (`skinPercent -tv $joint $weights[$i] $skinCluster ($geometry+".vtx["+$vtxNrs[$i]+"]")`);
}

global proc asSkinWeightBySoftMod (string $joint, string $geometry, string $skinCluster, float $falloffRadius, float $maxWeight)
{
global string $gMainProgressBar;
int $numCurvePoints;
int $falloffMode=$maxWeight;//$maxWeight no longer used, using this arg as $falloffMode
float $weight;
float $pos[]=`xform -q -ws -t $joint`;
float $posAs[],$cv0[],$cv1[];
string $vtx,$fitJoint,$falloffCurveString,$cmd,$softMod,$softSelectCmd;
string $sel[]=`ls -sl`;
string $tempString[],$infJoints[];
int $clusterWeighting;
if (`objectType $skinCluster`=="cluster")
	{
	$clusterWeighting=1;
	$pos=`xform -q -ws -piv $joint`;
	}


if (`asIsMayaLT`)
	{
	asSkinWeightBySoftModMayaLT $joint $geometry $skinCluster $falloffRadius $maxWeight;
	return;
	}

if (!`objExists tempSoftModCopy` && !`gmatch $joint "LipPullJoint_*"`)//coming from asFaceConvertSoftModBackToControl proc
	{
	//create softSelection
	if (`objExists closestSampler2`) delete closestSampler2;
	createNode -n closestSampler2 closestPointOnMesh;
	connectAttr -f ($geometry+".outMesh") closestSampler2.inMesh;
	setAttr closestSampler2.inPosition $pos[0] $pos[1] $pos[2];
	select ($geometry+".vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]");
	delete closestSampler2;
	softSelect -softSelectReset;
	softSelect -e -softSelectEnabled 1 -softSelectFalloff $falloffMode -softSelectDistance $falloffRadius;
	if (`objExists convertingSoftMod`)
		{
		$softMod=`getAttr convertingSoftMod.softMod`;
		$numCurvePoints=`getAttr -s ($softMod+".falloffCurve")`;
		$softSelectCmd="softSelect -e -softSelectCurve \"";
		for ($i=0;$i<$numCurvePoints;$i++)
			{
			if ($i>0)
				$softSelectCmd+=",";
			$softSelectCmd+=`getAttr ($softMod+".falloffCurve["+$i+"].falloffCurve_FloatValue")`+",";
			$softSelectCmd+=`getAttr ($softMod+".falloffCurve["+$i+"].falloffCurve_Position")`+",";
			$softSelectCmd+=`getAttr ($softMod+".falloffCurve["+$i+"].falloffCurve_Interp")`;
			}
		$softSelectCmd+="\"";
		eval ($softSelectCmd);
		}
	$cmd+="import maya.cmds as mc\n";
	$cmd+="import maya.OpenMaya as om\n";
	$cmd+="import maya.OpenMayaAnim as oma\n";
	$cmd+="def softSelection():\n";
	$cmd+="    selection = om.MSelectionList()\n";
	$cmd+="    softSelection = om.MRichSelection()\n";
	$cmd+="    om.MGlobal.getRichSelection(softSelection)\n";
	$cmd+="    softSelection.getSelection(selection)\n";
	$cmd+="    dagPath = om.MDagPath()\n";
	$cmd+="    component = om.MObject()\n";
	$cmd+="    iter = om.MItSelectionList( selection,om.MFn.kMeshVertComponent )\n";
	$cmd+="    elements = []\n";
	$cmd+="    while not iter.isDone(): \n";
	$cmd+="        iter.getDagPath( dagPath, component )\n";
	$cmd+="        dagPath.pop()\n";
	$cmd+="        node = dagPath.fullPathName()\n";
	$cmd+="        fnComp = om.MFnSingleIndexedComponent(component)\n";
	$cmd+="        for i in range(fnComp.elementCount()):\n";
	$cmd+="            elements.append([node, fnComp.element(i), fnComp.weight(i).influence()] )\n";
	$cmd+="        iter.next()\n";
	$cmd+="    return elements\n";
	$cmd+="def softSelWeights():\n";
	$cmd+="    softElementData = softSelection()\n";
	$cmd+="    selection = [\"%s.vtx[%d]\" % (el[0], el[1])for el in softElementData ]\n";

	$cmd+="    # get the MFnSkinCluster for clusterName\n";
	$cmd+="    selList = om.MSelectionList()\n";
	$cmd+="    selList.add('"+$skinCluster+"')\n";
	$cmd+="    clusterNode = om.MObject()\n";
	$cmd+="    selList.getDependNode(0, clusterNode)\n";
	$cmd+="    skinFn = oma.MFnSkinCluster(clusterNode)\n";

	$cmd+="    # get the MDagPath for all influence\n";
	$cmd+="    infDags = om.MDagPathArray()\n";
	$cmd+="    skinFn.influenceObjects(infDags)\n";

	$cmd+="    for x in range(infDags.length()):\n";
	$cmd+="        infPath = infDags[x].partialPathName()\n";
	$cmd+="        infIndexes = skinFn.indexForInfluenceObject(infDags[x])\n";
	$cmd+="        if infPath == '"+$joint+"':\n";
	$cmd+="            joint = infPath\n";
	$cmd+="            jointNr = infIndexes\n";


	$cmd+="    for i in range(len(softElementData)):\n";
	$cmd+="        vtxNr = softElementData[i][1]\n";
	$cmd+="        wAttr = '"+$skinCluster+".wl[%s].w[%d]' %(vtxNr,jointNr)\n";
	$cmd+="        infValue = softElementData[i][2]\n";
	$cmd+="        mc.setAttr(wAttr, infValue)\n";
//	$cmd+="        print(wAttr, infValue)\n";

	$cmd+="softSelWeights()\n";

	python ($cmd);

	softSelect -e -softSelectEnabled 0;
	softSelect -softSelectReset;

	//normalize
	$infJoints=`listConnections ($skinCluster+".matrix")`;
	for ($i=0;$i<size($infJoints);$i++)
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
	setAttr ($joint+".lockInfluenceWeights") 1;
	skinPercent -normalize true $skinCluster $geometry;
	setAttr ($joint+".lockInfluenceWeights") 0;

	select $sel;
	return;
}

duplicate -n tempMesh $geometry;
select tempMesh;
$tempString=`asDeformer softMod`;
rename $tempString[0] TempSoftMod;
rename $tempString[1] TempSoftModHandle;

if (`objExists tempSoftModCopy`)//coming from asFaceConvertSoftModBackToControl proc
	{
	setAttr TempSoftMod.falloffRadius `getAttr tempSoftModCopy.falloffRadius`;
	setAttr TempSoftMod.falloffMode  `getAttr tempSoftModCopy.falloffMode `;
	for ($i=0;$i<`getAttr -s tempSoftModCopy.falloffCurve`;$i++)
		connectAttr -f ("tempSoftModCopy.falloffCurve["+$i+"]") ("TempSoftMod.falloffCurve["+$i+"]");
	}

setAttr -type float3 TempSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
setAttr TempSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] TempSoftModHandle;
setAttr TempSoftMod.falloffMode 1;
setAttr TempSoftMod.falloffRadius $falloffRadius;

if (`gmatch $joint "LipPullJoint_*"` && !`objExists tempSoftModCopy`)
	{
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Position 0;
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_FloatValue 1;
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_Position 1;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_FloatValue 0;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_Position 0.3043;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_FloatValue 0.439273;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_Position 0.0806;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_FloatValue 0.945397;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_Interp 3;
	}
if (`gmatch $joint "MouthNarrowJoint_*"` && !`objExists tempSoftModCopy`)
	{
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Interp 1;
	}

select tempMesh;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl -fl`;
if ($clusterWeighting)
	{
	select $geometry;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
	asInvertSelection;
	percent -v 0 $skinCluster `ls -sl`;
	}
polySelectConstraint -m 0;

progressBar -e -st ("SkinWeight by SoftMod ("+$joint+")") -bp -ii 1 -min 0 -max ((size($tempString))+1) $gMainProgressBar;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists eyeLidArea`)
		if (`sets -im eyeLidArea $tempString[$i]`)
			continue;
	if (`objExists lipArea`)
		if (`sets -im lipArea $tempString[$i]`)
			continue;

	$posA=`xform -q -ws -t $tempString[$i]`;
	$posAs[$i]=$posA[1];
	}
setAttr TempSoftModHandle.ty 1;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
	progressBar -e -s 1 $gMainProgressBar;

	$posB=`xform -q -ws -t $tempString[$i]`;
	$weight=($posB[1]-$posAs[$i])*$maxWeight;
	if ($weight<0) $weight=0;
	if ($weight>1) $weight=1;
	$vtx=`substitute tempMesh $tempString[$i] $geometry`;
	if ($clusterWeighting)
		catchQuiet (`percent -v $weight $skinCluster $vtx`);
	else
	 	catchQuiet (`skinPercent -tv $joint $weight $skinCluster $vtx`);
	}
setAttr TempSoftModHandle.ty 0;

//update FitJoint radius & falloffCurveString
tokenize $joint "_" $tempString;
$fitJoint=`substitute "Joint" $tempString[0] ""`;
if (`attributeExists falloffRadius $fitJoint`)
	setAttr ($fitJoint+".falloffRadius") $falloffRadius;
if (`objExists $fitJoint`)
	{
	if (!`attributeExists falloffCurve $fitJoint`)
		addAttr -ln falloffCurve -dt "string" $fitJoint;
	$numCurvePoints=`getAttr -s TempSoftMod.falloffCurve`;
	for ($i=0;$i<$numCurvePoints;$i++)
		{
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_Position "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_Position")`+";";
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_Interp "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_Interp")`+";";
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue")`+";";
		}
		setAttr -type "string" ($fitJoint+".falloffCurve") $falloffCurveString;
	}

delete tempMesh;
if (`objExists tempSoftModCopy`) delete tempSoftModCopy;

progressBar -e -ep $gMainProgressBar;

select $sel;
}

global proc asSkinWeightBySoftModMayaLT (string $joint, string $geometry, string $skinCluster, float $falloffRadius, float $maxWeight)
{
global string $gMainProgressBar;
int $numCurvePoints;
float $weight;
float $pos[]=`xform -q -ws -t $joint`;
float $posAs[];
string $vtx,$fitJoint,$falloffCurveString;
string $sel[]=`ls -sl`;
string $tempString[];
int $clusterWeighting;
if (`objectType $skinCluster`=="cluster")
	{
	$clusterWeighting=1;
	$pos=`xform -q -ws -piv $joint`;
	}

duplicate -n tempMesh $geometry;
select tempMesh;
$tempString=`asDeformer softMod`;
rename $tempString[0] TempSoftMod;
rename $tempString[1] TempSoftModHandle;

if (`objExists tempSoftModCopy`)//coming from asFaceConvertSoftModBackToControl proc
	{
	setAttr TempSoftMod.falloffRadius `getAttr tempSoftModCopy.falloffRadius`;
	setAttr TempSoftMod.falloffMode  `getAttr tempSoftModCopy.falloffMode `;
	for ($i=0;$i<`getAttr -s tempSoftModCopy.falloffCurve`;$i++)
		connectAttr -f ("tempSoftModCopy.falloffCurve["+$i+"]") ("TempSoftMod.falloffCurve["+$i+"]");
	}

setAttr -type float3 TempSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
setAttr TempSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] TempSoftModHandle;
setAttr TempSoftMod.falloffMode 1;
setAttr TempSoftMod.falloffRadius $falloffRadius;

if ($joint=="SmilePullJoint_R" && !`objExists tempSoftModCopy`)
	{
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Position 0;
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_FloatValue 1;
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_Position 1;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_FloatValue 0;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_Position 0.3043;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_FloatValue 0.439273;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_Position 0.0806;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_FloatValue 0.945397;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_Interp 3;
	}
if ($joint=="MouthNarrowJoint_R" && !`objExists tempSoftModCopy`)
	{
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Interp 1;
	}

select tempMesh;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl -fl`;
if ($clusterWeighting)
	{
	select $geometry;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
	asInvertSelection;
	percent -v 0 $skinCluster `ls -sl`;
	}
polySelectConstraint -m 0;

progressBar -e -st ("SkinWeight by SoftMod ("+$joint+")") -bp -ii 1 -min 0 -max ((size($tempString))+1) $gMainProgressBar;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists eyeLidArea`)
		if (`sets -im eyeLidArea $tempString[$i]`)
			continue;
	if (`objExists lipArea`)
		if (`sets -im lipArea $tempString[$i]`)
			continue;

	$posA=`xform -q -ws -t $tempString[$i]`;
	$posAs[$i]=$posA[1];
	}
setAttr TempSoftModHandle.ty 1;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
	progressBar -e -s 1 $gMainProgressBar;

	$posB=`xform -q -ws -t $tempString[$i]`;
	$weight=($posB[1]-$posAs[$i])*$maxWeight;
	if ($weight<0) $weight=0;
	if ($weight>1) $weight=1;
	$vtx=`substitute tempMesh $tempString[$i] $geometry`;
	if ($clusterWeighting)
		catchQuiet (`percent -v $weight $skinCluster $vtx`);
	else
	 	catchQuiet (`skinPercent -tv $joint $weight $skinCluster $vtx`);
	}
setAttr TempSoftModHandle.ty 0;

//update FitJoint radius & falloffCurveString
tokenize $joint "_" $tempString;
$fitJoint=`substitute "Joint" $tempString[0] ""`;
if (`attributeExists falloffRadius $fitJoint`)
	setAttr ($fitJoint+".falloffRadius") $falloffRadius;
if (`objExists $fitJoint`)
	{
	if (!`attributeExists falloffCurve $fitJoint`)
		addAttr -ln falloffCurve -dt "string" $fitJoint;
	$numCurvePoints=`getAttr -s TempSoftMod.falloffCurve`;
	for ($i=0;$i<$numCurvePoints;$i++)
		{
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_Position "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_Position")`+";";
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_Interp "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_Interp")`+";";
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue")`+";";
		}
		setAttr -type "string" ($fitJoint+".falloffCurve") $falloffCurveString;
	}

delete tempMesh;
if (`objExists tempSoftModCopy`) delete tempSoftModCopy;

progressBar -e -ep $gMainProgressBar;
select $sel;
}

global proc asFollow (string $driver, string $driven, string $target)//nonOPM
{
string $setRange=$driver+"SetRangeFollow";

if (!`objExists $target`)
	return;

if (!`attributeExists "follow" $driver`)
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 0 $driver;
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($driver+".follow") ($setRange+".value.valueX");
	connectAttr ($driver+".follow") ($setRange+".value.valueY");
	}
createNode -n ($driven+"FollowNoScaleOffset") transform;
createNode -n ($driven+"FollowNoScale") -p ($driven+"FollowNoScaleOffset") transform;
pointConstraint $target ($driven+"FollowNoScaleOffset");
orientConstraint $target ($driven+"FollowNoScaleOffset");
parent ($driven+"FollowNoScaleOffset") ("IKFollow");

createNode -n ($driven+"FollowOffset") transform;
createNode -n ($driven+"Follow") -p ($driven+"FollowOffset") transform;
asAlign ($driven+"FollowOffset") $driven 1 1 0 0;
parent ($driven+"FollowOffset") ("IKFollow");
parentConstraint -mo ($driven+"FollowNoScale") ($driven+"Follow");

createNode -n ($driven+"StaticOffset") transform;
createNode -n ($driven+"Static") -p ($driven+"StaticOffset") transform;
asAlign ($driven+"StaticOffset") $driven 1 1 0 0;
parent ($driven+"StaticOffset") ("IKStatic");
string $tempString[]=`parentConstraint ($driven+"Static") ($driven+"Follow") $driven`;
string $constraint=$tempString[0];
select $constraint;
connectAttr ($setRange+".outValue.outValueY") ($constraint+"."+$driven+"Static"+"W0");
connectAttr ($setRange+".outValue.outValueX") ($constraint+"."+$driven+"Follow"+"W1");
}

global proc asParentConstraintBlend (string $driver, string $driven, string $target)//OPM
{
float $udMax=10; 
float $m1[],$m2[];
string $name,$side;
string $setRange=$driver+"SetRangeFollow";
string $tempString[];

tokenize $driven "_" $tempString;
$name=$tempString[0];
$side="_"+$tempString[1];

$m1=`xform -q -ws -m $driven`;
//$m2 is the matrix between $driven & $target
createNode -n tempTransformMatrix -p $driven transform;
parent tempTransformMatrix $target;
$m2=`xform -q -os -m tempTransformMatrix`;
delete tempTransformMatrix;
createNode -n ($name+"BM"+$side) blendMatrix;
setAttr ($name+"BM"+$side+".inputMatrix") -type "matrix" $m1[0] $m1[1] $m1[2] $m1[3] $m1[4] $m1[5] $m1[6] $m1[7] $m1[8] $m1[9] $m1[10] $m1[11] $m1[12] $m1[13] $m1[14] $m1[15];

addAttr -k 1 -ln follow -at double -min 0 -max $udMax -dv $udMax $driver;
createNode -n ($driver+"FollowMDL"+$side) multDoubleLinear;
connectAttr ($driver+".follow") ($driver+"FollowMDL"+$side+".input1");
setAttr ($driver+"FollowMDL"+$side+".input2") 0.1;

createNode -n ($name+"MMFollow"+$side) multMatrix;
//0 offset between $driven & $target
//1 main drv
setAttr ($name+"MMFollow"+$side+".matrixIn[0]") -type "matrix" $m2[0] $m2[1] $m2[2] $m2[3] $m2[4] $m2[5] $m2[6] $m2[7] $m2[8] $m2[9] $m2[10] $m2[11] $m2[12] $m2[13] $m2[14] $m2[15];
connectAttr ($target+".worldMatrix[0]") ($name+"MMFollow"+$side+".matrixIn[1]");
connectAttr ($name+"MMFollow"+$side+".matrixSum") ($name+"BM"+$side+".target[0].targetMatrix");
connectAttr ($driver+"FollowMDL"+$side+".output") ($name+"BM"+$side+".target[0].weight");

//BM.inputMatrix to have the offset + Main to get scale
createNode -n ($name+"MMStatic"+$side) multMatrix;
setAttr ($name+"MMStatic"+$side+".matrixIn[0]") -type "matrix" $m1[0] $m1[1] $m1[2] $m1[3] $m1[4] $m1[5] $m1[6] $m1[7] $m1[8] $m1[9] $m1[10] $m1[11] $m1[12] $m1[13] $m1[14] $m1[15];
connectAttr Main.worldMatrix[0] ($name+"MMStatic"+$side+".matrixIn[1]");
connectAttr ($name+"MMStatic"+$side+".matrixSum") ($name+"BM"+$side+".inputMatrix");

connectAttr ($name+"BM"+$side+".outputMatrix") ($driven+".offsetParentMatrix");
xform -os -t 0 0 0 -ro 0 0 0 $driven;
}

global proc asFollowLevels (string $driver, string $driven, string $fitJoint)//OPM
{
int $childOfChest;
float $m1[]=`xform -q -ws -m $driven`;
float $m2[],$tempFloat[];
float $dv,$scale,$sideTreshold;
string $name,$side,$iKStartJoint,$iKMiddleJoint,$iKEndJoint,$iKSolver;
string $parentSide="_M";
string $tempString[],$iKInfo[];
string $levelNames[]={"Main","Root"};
string $levelNodes[]={"Main","RootX_M"};//Not root joint, as we do not want to follow offsets applied by IKSpine1_M

tokenize $driven "_" $tempString;
$name=$tempString[0];
$side="_"+$tempString[1];

//Analyze IK
$iKInfo=`asFitJointIKInfo $fitJoint`;
$iKStartJoint=$iKInfo[1];
$iKMiddleJoint=$iKInfo[2];
$iKEndJoint=$iKInfo[3];
$iKSolver=$iKInfo[4];

//include Chest Level, (if ik is child of Spine)
if (`objExists $iKStartJoint`)
	{
	$tempString=`ls -l $iKStartJoint`;
	tokenize $tempString[0] "|" $tempString;
	for ($i=size($tempString)-1;$i>-1;$i--)
		if ($tempString[$i]=="Chest")
			{
			$childOfChest=1;
			break;
			}
	}
if ($childOfChest)
	{
	$levelNames[size($levelNames)]="Chest";
	$levelNodes[size($levelNodes)]="Chest_M";
	}

//follow Parent aka "follow" in non-opm. e.g. bug antenna follow head
if ($iKSolver=="ikSplineSolver")
	{
	$tempString=`listRelatives -p $iKStartJoint`;
	if ($tempString[0]!="" && $tempString[0]!="Root" && $tempString[0]!="Chest")
		{
		$scale=`asGetScale`;
		$sideTreshold=0.01*$scale;
		$tempFloat=`xform -q -ws -t $tempString[0]`;
		if ($tempFloat[0]>$sideTreshold) $parentSide="_L";
		if ($tempFloat[0]<($sideTreshold*-1)) $parentSide="_R";
		$levelNames[size($levelNames)]=$tempString[0];
		$levelNodes[size($levelNodes)]=$tempString[0]+$parentSide;
		}
	}

createNode -n ($name+"BM"+$side) blendMatrix;
setAttr ($name+"BM"+$side+".inputMatrix") -type "matrix" $m1[0] $m1[1] $m1[2] $m1[3] $m1[4] $m1[5] $m1[6] $m1[7] $m1[8] $m1[9] $m1[10] $m1[11] $m1[12] $m1[13] $m1[14] $m1[15];

for ($i=0;$i<size($levelNames);$i++)
	{
	$dv=0;
	if ($levelNames[$i]=="Main" || `attributeExists stiff $driver`)//SplineIK`s to follow by default, e.g. Ik Head follow Chest
		$dv=10;
	if (!`objExists $levelNodes[$i]`)
		continue;
	addAttr -k 1 -ln ("follow"+$levelNames[$i]) -at double -min 0 -max 10 -dv $dv $driver;
	createNode -n ($driver+"Follow"+$levelNames[$i]+"MDL"+$side) multDoubleLinear;
	connectAttr ($driver+".follow"+$levelNames[$i]) ($driver+"Follow"+$levelNames[$i]+"MDL"+$side+".input1");
	setAttr ($driver+"Follow"+$levelNames[$i]+"MDL"+$side+".input2") 0.1;
	createNode -n ($name+"MM"+$levelNames[$i]+$side) multMatrix;

	//0 offset to the target from origin
	//1 inv of 2(main drv)
	//2 main drv
	setAttr ($name+"MM"+$levelNames[$i]+$side+".matrixIn[0]") -type "matrix" $m1[0] $m1[1] $m1[2] $m1[3] $m1[4] $m1[5] $m1[6] $m1[7] $m1[8] $m1[9] $m1[10] $m1[11] $m1[12] $m1[13] $m1[14] $m1[15];
	$m2=`getAttr ($levelNodes[$i]+".worldInverseMatrix[0]")`;
	setAttr ($name+"MM"+$levelNames[$i]+$side+".matrixIn[1]") -type "matrix" $m2[0] $m2[1] $m2[2] $m2[3] $m2[4] $m2[5] $m2[6] $m2[7] $m2[8] $m2[9] $m2[10] $m2[11] $m2[12] $m2[13] $m2[14] $m2[15];
	connectAttr ($levelNodes[$i]+".worldMatrix[0]") ($name+"MM"+$levelNames[$i]+$side+".matrixIn[2]");
	connectAttr ($name+"MM"+$levelNames[$i]+$side+".matrixSum") ($name+"BM"+$side+".target["+$i+"].targetMatrix");
	connectAttr ($driver+"Follow"+$levelNames[$i]+"MDL"+$side+".output") ($name+"BM"+$side+".target["+$i+"].weight");
	}

connectAttr ($name+"BM"+$side+".outputMatrix") ($driven+".offsetParentMatrix");
xform -os -t 0 0 0 -ro 0 0 0 $driven;
}

global proc asConstraintToFKIK (string $type, string $fitJointIK, string $fk, string $ik, string $target)
{
int $numChar,$mmNr,$plugNr;
int $opm=`asGetOpm`;
string $mm,$sideLess;
string $contraintCmd="pointConstraint ";
if ($type=="orient")
	$contraintCmd="orientConstraint ";
if ($type=="parent")
	$contraintCmd="parentConstraint ";
if ($type=="scale")
	$contraintCmd="scaleConstraint ";
$contraintCmd+=$fk;
if (`objExists $ik`)
	$contraintCmd+=" "+$ik;
$contraintCmd+=" "+$target;
string $tempString[];
tokenize $target "_" $tempString;
string $side="_"+$tempString[size($tempString)-1];
tokenize $fk "_" $tempString;
string $contraintToSide="_"+$tempString[size($tempString)-1];
$sideLess=$fk;
$numChar=size($sideLess);
if (`gmatch $fk "FKX*"`) $sideLess=`substring $sideLess 4 ($numChar-2)`;
else if (`gmatch $fk "FK*"`) $sideLess=`substring $sideLess 3 ($numChar-2)`;

if ($opm)
	{
	$mm=$sideLess+"MM"+$side;
	for ($mmNr=1;$mmNr<99;$mmNr++)
		if (!`objExists ($sideLess+"MM"+$mmNr+$side)`)
			break;
	createNode -n ($sideLess+"MM"+$mmNr+$side) multMatrix;
	if (`objExists ($sideLess+"BM"+$side)`)
		connectAttr ($sideLess+"BM"+$side+".outputMatrix") ($sideLess+"MM"+$mmNr+$side+".matrixIn[0]");
	else if (`objExists ("FKX"+$sideLess+$side)`)//FK only
		connectAttr ("FKX"+$sideLess+$side+".worldMatrix") ($sideLess+"MM"+$mmNr+$side+".matrixIn[0]");		
	else
		{
		$tempString[0]="FKX"+`asRlaParent $sideLess`+$side;
		$m=`getAttr ($sideLess+".matrix")`;
		setAttr ($sideLess+"MM"+$mmNr+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		connectAttr ($tempString[0]+".worldMatrix") ($sideLess+"MM"+$mmNr+$side+".matrixIn[1]");
		$plugNr++;
		}
	$plugNr++;
	$tempString=`listRelatives -p $target`;
	if ($tempString[0]!="")
		connectAttr ($tempString[0]+".worldInverseMatrix") ($sideLess+"MM"+$mmNr+$side+".matrixIn["+$plugNr+"]");

	if ($type=="point" || $type=="orient" || $type=="scale")
		{
		createNode -n ($sideLess+"PM"+$mmNr+$side) pickMatrix;
		setAttr ($sideLess+"PM"+$mmNr+$side+".useTranslate") 0;
		setAttr ($sideLess+"PM"+$mmNr+$side+".useRotate") 0;
		setAttr ($sideLess+"PM"+$mmNr+$side+".useScale") 0;
		setAttr ($sideLess+"PM"+$mmNr+$side+".useShear") 0;
		if ($type=="point") setAttr ($sideLess+"PM"+$mmNr+$side+".useTranslate") 1;
		if ($type=="orient") setAttr ($sideLess+"PM"+$mmNr+$side+".useRotate") 1;
		if ($type=="scale") setAttr ($sideLess+"PM"+$mmNr+$side+".useScale") 1;
		connectAttr ($sideLess+"MM"+$mmNr+$side+".matrixSum") ($sideLess+"PM"+$mmNr+$side+".inputMatrix");
		connectAttr ($sideLess+"PM"+$mmNr+$side+".outputMatrix") ($target+".offsetParentMatrix");	
		}
	else
		connectAttr ($sideLess+"MM"+$mmNr+$side+".matrixSum") ($target+".offsetParentMatrix");
	xform -os -t 0 0 0 -ro 0 0 0 $target;
	}
else
	{
	$tempString=`eval ($contraintCmd)`;
	string $constraint=$tempString[0];
	if (`objExists $ik` && `objExists ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide)`)
		{
		connectAttr ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide+".outputX") ($constraint+"."+$fk+"W0");
		connectAttr ("FKIKBlend"+$fitJointIK+"UnitConversion"+$contraintToSide+".output") ($constraint+"."+$ik+"W1");
		}
	}
}

global proc asFaceModelCheck ()
{
string $geometry=`textField -q -tx asFaceFaceTextField`;

if (!`objExists $geometry`)
	error "No geometry choosen for \"Face\"";

select $geometry;
asModelChecker;
}

global proc asModelCheckerUI ()
{
if (`window -q -ex asModelChecker`)
	deleteUI asModelChecker;
window -t "Model Checker" asModelChecker;
columnLayout;
	separator -st none -h 10;
	text -l "Check for default Transformation values,";
	text -l "and Model Symmetry.";
	separator -st none -h 5;
	text -l "Select the model, then:";
	separator -st none -h 10;
	button -w 50 -l "Check" -c asModelChecker;
showWindow;
}

global proc asModelChecker ()
{
global string $gMainProgressBar;
int $numVtxs,$mirrortVtx,$i,$gameEngine;
int $asSkipModelSymmetryCheck=`objExists asSkipModelSymmetryCheck`;
int $tempInt[];
float $mag;
float $posA[],$posB[],$tempFloat[];
string $sel[]=`ls -sl`;
string $m,$warningM,$objectType;
string $okMessage="Continue Anyway";
string $historyNodes[],$tempString[],$checkTransforms[];

if ($asSkipModelSymmetryCheck)
	delete asSkipModelSymmetryCheck;

if (!size($sel))
	error "Nothing Selected";

$tempString=`listRelatives -c -type mesh`;
if (!`size($tempString)`)
	error "Selected object is not a Mesh, Select the your model instead.";

$warningM="This will likely cause errors if you proceed.\n\n"
				 +"It is recommended that you use the \"Model Clean\" tool,\n"
				 +"before rigging.\n";

if (`checkBox -q -ex asFaceGameEngineCheckBox`)
	$gameEngine=`checkBox -q -v asFaceGameEngineCheckBox`;

//find parent Transforms
$tempString=`ls -l $sel[0]`;
tokenize $tempString[0] "|" $checkTransforms;
for ($i=0;$i<size($checkTransforms);$i++)
	{
	if (size(`ls $checkTransforms[$i]`)>1)
		{//in case of multiple objs with this name
		$tempString[0]="";
		for ($y=0;$y<$i+1;$y++)
			$tempString[0]=$tempString[0]+"|"+$checkTransforms[$y];
		$checkTransforms[$i]=$tempString[0];
		}
	select $checkTransforms[$i];
	refresh;
	$m="";
	$tempFloat=`getAttr ($checkTransforms[$i]+".t")`;
	if ($tempFloat[0]!=0) $m+="TranslateX = "+$tempFloat[0]+", should be 0\n";
	if ($tempFloat[1]!=0) $m+="TranslateY = "+$tempFloat[1]+", should be 0\n";
	if ($tempFloat[2]!=0) $m+="TranslateZ = "+$tempFloat[2]+", should be 0\n";
	$tempFloat=`getAttr ($checkTransforms[$i]+".r")`;
	if ($tempFloat[0]!=0) $m+="RotateX = "+$tempFloat[0]+", should be 0\n";
	if ($tempFloat[1]!=0) $m+="RotateY = "+$tempFloat[1]+", should be 0\n";
	if ($tempFloat[2]!=0) $m+="RotateZ = "+$tempFloat[2]+", should be 0\n";
	$tempFloat=`getAttr ($checkTransforms[$i]+".s")`;
	if ($tempFloat[0]!=1) $m+="ScaleX = "+$tempFloat[0]+", should be 1\n";
	if ($tempFloat[1]!=1) $m+="ScaleY = "+$tempFloat[1]+", should be 1\n";
	if ($tempFloat[2]!=1) $m+="ScaleZ = "+$tempFloat[2]+", should be 1\n";
	$tempFloat=`getAttr ($checkTransforms[$i]+".rp")`;
	if ($tempFloat[0]!=0) $m+="RotatePivotX = "+$tempFloat[0]+", should be 0\n";
	if ($tempFloat[1]!=0) $m+="RotatePivotY = "+$tempFloat[1]+", should be 0\n";
	if ($tempFloat[2]!=0) $m+="RotatePivotZ = "+$tempFloat[2]+", should be 0\n";
	$tempFloat=`getAttr ($checkTransforms[$i]+".sp")`;
	if ($tempFloat[0]!=0) $m+="ScalePivotX = "+$tempFloat[0]+", should be 0\n";
	if ($tempFloat[1]!=0) $m+="ScalePivotY = "+$tempFloat[1]+", should be 0\n";
	if ($tempFloat[2]!=0) $m+="ScalePivotZ = "+$tempFloat[2]+", should be 0\n";

	if ($m!="")
		$m="Object: \""+$checkTransforms[$i]+"\"\n\n"+$m+"\nThe above transform values are Non-Default values.\n"+$warningM;
	if ($m!="")
		{
		$dialog=`confirmDialog -t "Confirm" -m $m -b $okMessage -b "Cancel" -db "Cancel" -ds "Cancel"`;
		if ($dialog!=$okMessage)
			error "Operation cancelled. It is recommended that you fix the Non-Default transform values.";
		}
	}

//contruction-history check
$historyNodes=`listHistory -pdo 1 -il 2 $sel[0]`;
$m="";
for ($i=0;$i<size($historyNodes);$i++)
	{
	if (`gmatch $historyNodes[$i] "asResetTransform*"` || `gmatch $historyNodes[$i] "rl4Embedded*"`)
		continue;
	$objectType=`objectType $historyNodes[$i]`;
	if ($objectType!="skinCluster" && $objectType!="blendShape" && $objectType!="tweak" && $objectType!="deltaMush")
		$m+=$historyNodes[$i]+"\n";
	if ($objectType=="deltaMush" && $gameEngine)
		$m+="DeltaMush not supported in GameEngine.\n"+$historyNodes[$i]+"\n";
	}
if ($m!="")
	{
	$m+="\nThe above HistoryNodes were found.\n"+$warningM;
	$dialog=`confirmDialog -t "Confirm" -m $m -b $okMessage -b "Cancel" -db "Cancel" -ds "Cancel"`;
	if ($dialog!=$okMessage)
		error "Operation cancelled. It is recommended that you remove the HistoryNodes.";
	}

//Symmetry check
if (!$asSkipModelSymmetryCheck)
	{
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr -f ($sel[0]+".outMesh") closestSampler.inMesh;
	$tempInt=`polyEvaluate -v $sel[0]`;
	$numVtxs=$tempInt[0];
	select -cl;
	progressBar -e -st "Checking symmetry" -bp -ii 1 -min 0 -max $numVtxs $gMainProgressBar;
	for ($i=0;$i<$numVtxs;$i++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
		progressBar -e -s 1 $gMainProgressBar;
		$posA=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
		if ($posA[0]>0.001)
			continue;
		setAttr closestSampler.inPosition ($posA[0]*-1) $posA[1] $posA[2];
		$mirrortVtx=`getAttr closestSampler.closestVertexIndex`;
		$posB=`xform -q -ws -t ($sel[0]+".vtx["+$mirrortVtx+"]")`;
		$mag=`mag <<($posA[0]-($posB[0]*-1)),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
		if ($mag>0.001)
			select -add ($sel[0]+".vtx["+$i+"]") ($sel[0]+".vtx["+$mirrortVtx+"]");
		}
	progressBar -e -ep $gMainProgressBar;
	delete closestSampler;
	refresh;
	if (size(`ls -sl`))
		{
		$dialog=`confirmDialog -t "Confirm" -m "Selected verticies are not symmetrical" -b $okMessage -b "Cancel" -db "Cancel" -ds "Cancel"`;
		if ($dialog!=$okMessage)
			error "Operation cancelled. It is recommended that you make the model symmetrical.";
		}
	else
		print "// Model is symmetrical.\n";
	}
}

global proc asRemoveForthEdge (string $poly)
{
int $tempInts[];
int $numVtxs;
//string $poly="Chest_M_branch";
string $vtxA,$vtxB;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];

$tempInts=`polyEvaluate -v $poly`;
$numVtxs=$tempInts[0];
for ($i=0;$i<$numVtxs;$i++)
	{
	$vtxA=$poly+".vtx["+$i+"]";
	select $vtxA;
	ConvertSelectionToEdges;
	if (size(`ls -sl -fl`)<4) continue;
	ConvertSelectionToVertices;
	select -d $vtxA;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		select $tempString[$y];
		ConvertSelectionToEdges;
		if (size(`ls -sl -fl`)<4) continue;
		ConvertSelectionToVertices;
		select -d $tempString[$y];
		$tempString3=`ls -sl -fl`;
		
		for ($z=0;$z<size($tempString3);$z++)
			if ($tempString3[$z]==$vtxA)
				{
				$vtxB=$tempString[$y];
				select $vtxA $vtxB;
				ConvertSelectionToContainedEdges;
				if (size (`ls -sl`))
					catchQuiet (`delete`);
				}
		}
	}
select -cl;
}

global proc asAnimationTesterUI ()
{
string $frameLayouts[]={"asATBody","asATFace"};
for ($i=0;$i<size($frameLayouts);$i++)
	if (!`optionVar -ex ($frameLayouts[$i]+"FrameLayout")`)
		optionVar -iv ($frameLayouts[$i]+"FrameLayout") 1;

if (`window -q -ex asAnimationTester`)
    deleteUI asAnimationTester;
window -t AnimationTester asAnimationTester;
columnLayout -adj 1;
	text -l "Apply test animation:";
	separator -h 10;
	frameLayout -mw 10 -cll 1 -cl `optionVar -q asATBodyFrameLayout` -cc asFL -ec asFL -l "Body" asATBodyFrameLayout;
		frameLayout -cll 1 -cl `optionVar -q asATSkinningTestFrameLayout` -cc asFL -ec asFL -l " Skinning Test" asATSkinningTestFrameLayout;
			floatFieldGrp -pre 0 -numberOfFields 3 -label "rotate" -value1 90 -value2 90 -value3 90 -cw4 65 30 30 30 asBodyTestRotateFloatFieldGrp;
			intFieldGrp -l "frames" -v1 5 -cw2 65 30 asBodyTestFramesIntFieldGrp;
			rowLayout -nc 2;
				separator -w 67 -st none;
				checkBox -l "both positive and negative directions" asBodyTestPosNegCheckBox;
				setParent..;
			rowLayout -nc 2;
				separator -w 67 -st none;
				checkBox -l "both right and left side" asBodyTestRightLeftCheckBox;
				setParent..;
			rowLayout -nc 2;
				separator -w 67 -st none;
				checkBox -l "only on selected control" asBodyTestSelectedCheckBox;
				setParent..;
			button -w 100 -l "apply" -c asAnimationTest;
			separator -h 5;
			text -l "paint weights:";
			text -l "(double click to choose the moving joint)";
			shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" -dcc asAnimationTesterPaintWeights
				-image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c "ArtPaintSkinWeightsTool;";
			setParent..;
		rowLayout -nc 2;
			separator -h 20 -w 50 -st none;
			button -l "Remove Body animation" -c "asMCLRemoveBody \"\"";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl `optionVar -q asATFaceFrameLayout` -cc asFL -ec asFL -l "Face" asATFaceFrameLayout;
		columnLayout;
			rowLayout -nc 3;
				separator -h 20 -w 50 -st none;
				optionMenu asATFaceOptionMenu;
				button -l apply -c ("asMCLTestFace \"\"");
//				button -l "import Face test-animation" -c "asMCLTestFace \"\"";
			setParent..;
		setParent..;
		rowLayout -nc 2;
			separator -h 20 -w 50 -st none;
			button -l "Remove Face animation" -c "asMCLRemoveFace \"\"";
			setParent..;
	setParent..;


showWindow;
asPopulateATFaceOptionMenu;
}

global proc asAnimationTest ()
{
int $posNeg=`checkBox -q -v asBodyTestPosNegCheckBox`;
int $rightLeft=`checkBox -q -v asBodyTestRightLeftCheckBox`;
int $selected=`checkBox -q -v asBodyTestSelectedCheckBox`;
int $frames=`intFieldGrp -q -v1 asBodyTestFramesIntFieldGrp`;
float $currentTime;
float $r[],$currentRot[];
$r[0]=`floatFieldGrp -q -v1 asBodyTestRotateFloatFieldGrp`;
$r[1]=`floatFieldGrp -q -v2 asBodyTestRotateFloatFieldGrp`;
$r[2]=`floatFieldGrp -q -v3 asBodyTestRotateFloatFieldGrp`;
string $selectedXYZ;
string $fkSystems[]={"FKOffsetRoot_M"};
string $tempString[]=`listRelatives -c -type transform FKSystem`;
string $xyz[]={"x","y","z"};
string $tempString2[];
string $sel[]=`ls -sl`;

playbackOptions -min 0 -ast 0 -max 2000 -aet 2000;
currentTime 0;
asSetAllFK "";
if (`attributeExists legLock RootX_M`)
	setAttr RootX_M.legLock 10;

for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$fkSystems[0])
		$fkSystems[size($fkSystems)]=$tempString[$i];

for ($i=0;$i<size($fkSystems);$i++)
//for ($i=0;$i<1;$i++)
	{
	$tempString=`listRelatives -ad -type nurbsCurve $fkSystems[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`listRelatives -p $tempString[$y]`;
		$ctrl=$tempString2[0];
		if (!`sets -im ControlSet $ctrl`)
			continue;
		if (!$rightLeft && !$selected && `gmatch $ctrl "*_L"`)
			continue;
		if ($selected && !`stringArrayCount $ctrl $sel`)
			continue;
		if ($selected)
			{
			//preferred axis and $posNeg provided
			$currentRot=`getAttr ($ctrl+".r")`;
			if ($currentRot[0]!=0) $selectedXYZ="x";
			if ($currentRot[1]!=0) $selectedXYZ="y";
			if ($currentRot[2]!=0) $selectedXYZ="z";
			if ($selectedXYZ!="")
				$r=$currentRot;
			}

		for ($z=0;$z<size($xyz);$z++)
			{
			for ($b=1;$b>-2;$b=$b-2)//2ways (positive and negative values)
				{
				if ($b==-1 && !$posNeg)
					continue;
				if ($r[$z]==0)
					continue;
				if ($selectedXYZ!="" && $xyz[$z]!=$selectedXYZ)
					continue;
				setKeyframe -v 0 ($ctrl+".r"+$xyz[$z]);
				$currentTime+=$frames;currentTime $currentTime;
				setKeyframe -v ($r[$z]*$b) ($ctrl+".r"+$xyz[$z]);
				$currentTime+=$frames;currentTime $currentTime;
				setKeyframe -v 0 ($ctrl+".r"+$xyz[$z]);
				}
			}
		$currentTime+=$frames;currentTime $currentTime;
		}
	}
$currentTime=$currentTime-$frames;
playbackOptions -min 0 -ast 0 -max $currentTime -aet $currentTime;
currentTime 0;
}

global proc asAnimationTesterPaintWeights ()
{
float $t[],$r[],$s[];
string $objAttr;
string $joint="Root_M";
string $sel[]=`ls -sl`;
string $controlSetMembers[],$tempString[],$tempString2[];
if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;
string $trs[]={"t","r"};
string $xyz[]={"x","y","z"};

for ($i=0;$i<size($controlSetMembers);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$objAttr=$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z];
			if (!`getAttr -k $objAttr`)
				continue;
			$value=`getAttr $objAttr`;
			if ($value<-0.001 || $value>0.001)
				{
				print ("detected motion on:"+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+" : "+$value+"\n");
				$tempString[0]=`substitute "FK" $controlSetMembers[$i] ""`;
				if (`objExists $tempString[0]`)
					$joint=$tempString[0];
				$i=$y=$z=999;
				break;
				}
			}

//Select objects bound to $joint (if nothing selected);
if (size($sel)==0)
	{
	$tempString=`listConnections -s 0 -d 1 ($joint+".worldMatrix")`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objectType $tempString[$i]`!="skinCluster")
			continue;
		$tempString2=`listConnections -s 0 -d 1 $tempString[$i]`;
		for ($y=0;$y<size($tempString2);$y++)
			{
			if (`objectType $tempString2[$y]`=="mesh" || `objectType $tempString2[$y]`=="transform")
				select -add `listRelatives -p $tempString2[$y]`;
			}
		}
	}

ArtPaintSkinWeightsTool;
artAttrSkinPaintCtx -e -sao smooth -influence $joint artAttrSkinContext;
artSkinInflListChanging $joint 1;
artSkinInflListChanged artAttrSkinPaintCtx;
toolPropertyWindow;
}

global proc string asNearestFeatherParent (string $ctrl, string $fitJointsCurveGuide)
{
float $scale=`asGetScale`;
float $sideTreshold=0.01*$scale;
string $nearestJoint,$nearestFeatherParent;
int $arrivedAtTaggedJoint;
float $posA[]=`xform -q -ws -t $ctrl`;
if (`gmatch $ctrl "*_L"`)
	$posA[0]=$posA[0]*-1;
float $posB[];
float $dist;
float $minDist=999;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
string $curveGuideFitJoints[],$tempString[];
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists curveGuide $fitJoints[$i]`)
		continue;
	if (`getAttr -as ($fitJoints[$i]+".curveGuide")`!=$fitJointsCurveGuide)
		continue;
	$curveGuideFitJoints[size($curveGuideFitJoints)]=$fitJoints[$i];
	$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
	$curveGuideFitJoints=`stringArrayCatenate $tempString $curveGuideFitJoints`;
	}
for ($i=0;$i<size($curveGuideFitJoints);$i++)
	{
	$posB=`xform -q -ws -t $curveGuideFitJoints[$i]`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<$minDist)
		{
		$minDist=$dist;
		$nearestJoint=$curveGuideFitJoints[$i];
		}
	}
$tempString=`ls -l $nearestJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	if ($arrivedAtTaggedJoint)
		{
		$nearestFeatherParent=$tempString[$i];
		break;
		}
	if (`attributeExists curveGuide $tempString[$i]`)
		$arrivedAtTaggedJoint=1;
	}
if (`gmatch $ctrl "*_R"` && `objExists ($nearestFeatherParent+"_R")`) $nearestFeatherParent+="_R";
else if (`gmatch $ctrl "*_L"` && `objExists ($nearestFeatherParent+"_L")`) $nearestFeatherParent+="_L";
else $nearestFeatherParent+="_M";
return $nearestFeatherParent;
}

global proc asRemoveAllUnusedInfluences ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listHistory -pdo 1 $meshes[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			select `listRelatives -p $meshes[$i]`;
			removeUnusedInfluences;
			}
	}
select $sel;
print "// Unused influences removed.\n";
}

global proc asPruneSmallWeights ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listHistory -pdo 1 $meshes[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			select `listRelatives -p $meshes[$i]`;
			skinPercent -prw 0.01 $tempString[$y];
			}
	}
select $sel;
print "// Pruned Small Weights.\n";
}

global proc asSaveUIs ()
{
delete `ls sceneConfigurationScriptNode`;
delete `ls uiConfigurationScriptNode`;
delete `ls -type hyperView`;
flushUndo;
print "// Saved UI hyperGraph layouts, etc now removed.\n";
print "// Note: Save and re-open this file, for this to take effect.\n";
}

global proc asDeleteUnusedJoints ()
{
int $numChar;
string $fitJoint;
string $jointChildren[],$tempString[];
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;

if (`objExists root`)
	if (`attributeExists skinTransferred root`)
		error ("Unable to Delete UnusedJoints, because currently weights are transferred to Unreal Skeleton, which would cause undesired results.");

for ($i=0;$i<size($joints);$i++)
	{
	$numChar=size($joints[$i]);
	$fitJoint=`substring $joints[$i] 1 ($numChar-2)`;
	if (!`objExists $fitJoint`)
		continue;
	$jointChildren=`listRelatives -ad -type joint $fitJoint`;
	if (size($jointChildren))
		continue;
	if (`attributeExists control $fitJoint`)
		if (`getAttr ($fitJoint+".control")`)
			continue;

	print ("// deleting joint:\""+$joints[$i]+"\"\n");
	delete $joints[$i];
	}
}

global proc asTagAllControllers ()
{
string $sel[]=`ls -sl`;
string $tempString[],$controlSetMembers[];

if (`asMayaVersionAsFloat`<2018)
	error "This function is not avaiable in maya versions older then 2018";

if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	$tempString=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $tempString`;
	}

//Also include ctrlBox & each `ctrl-limit-box`, to auto-hide this as well
if (`objExists ctrlBox`)
	{
	$controlSetMembers[size($controlSetMembers)]="ctrlBox";
	$tempString=`listRelatives -c -type transform ctrlBox`;
	for ($i=0;$i<size($tempString);$i++)
		$controlSetMembers[size($controlSetMembers)]=$tempString[$i];
	}

//remove old tags
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`objExists ($controlSetMembers[$i]+"_tag")`)
		delete ($controlSetMembers[$i]+"_tag");

select $controlSetMembers;
TagAsController;
if (!`attributeExists showOnMouseProximity Main`)
	{
	addAttr -k 1 -ln showOnMouseProximity -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.showOnMouseProximity;
	}
if (!`objExists showOnMouseProximityMPD`)
	{
	createNode -n showOnMouseProximityMPD multiplyDivide;
	setAttr showOnMouseProximityMPD.input2X 2;
	connectAttr Main.showOnMouseProximity showOnMouseProximityMPD.input1X;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`objExists ($controlSetMembers[$i]+"_tag")`)
		continue;
	setAttr ($controlSetMembers[$i]+"_tag.isHistoricallyInteresting") 0;
	if ($controlSetMembers[$i]!="Main")
		{
		if (`attributeExists vMode ($controlSetMembers[$i]+"_tag")`)
			connectAttr showOnMouseProximityMPD.outputX ($controlSetMembers[$i]+"_tag.vMode");
		else if (`attributeExists visibilityMode ($controlSetMembers[$i]+"_tag")`)
			connectAttr showOnMouseProximityMPD.outputX ($controlSetMembers[$i]+"_tag.visibilityMode");
		//to ensure Main.showOnMouseProximity attr works when toggled as a `virtual slider` in Parallel eval mode
		if (!`attributeExists vMode $controlSetMembers[$i]`)
			addAttr -k 0 -ln vMode -at bool $controlSetMembers[$i];
		connectAttr ($controlSetMembers[$i]+"_tag.visibilityMode") ($controlSetMembers[$i]+".vMode");
		}
	}

select $sel;
print "// All controllers tagged, and \"showOnMouseProximity\" attribute added to Main controller\n";
}

global proc asReduceEyeLidJoints (int $newJointCount)
{
global string $gMainProgressBar;
int $modifier=`getModifiers`;
int $nonSymmetrical=`checkBox -q -v asFaceNonSymCheckBox`;
int $midNr,$mid1Nr,$mid4Nr,$outerNr,$upperOuterNr,$oldNr,$newNr;
int $upperMidNr,$upperMid1Nr,$upperMid4Nr;
int $lowerMidNr,$lowerMid1Nr,$lowerMid4Nr;	
int $nearest1Nr,$nearest2Nr;
float $pos[],$posA[],$posB[],$posMid[],$posMid1[],$posMid4[],$posStart[],$posEnd[];
float $dist,$min1Dist,$min2Dist;
float $midDist,$midDist1,$midDist4,$minMidDist,$minMid1Dist,$minMid4Dist,$value,$ty,$tyUpper,$tyDif,$blinkCenter;
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $eyeLash=`textField -q -tx asFaceEyelashTextField`;
string $upperLower,$UpperLower,$upperLowerOpposite,$InnerOuter,$side,$leftSuffix,$vtx,$newName,$nearest1,$nearest2;
string $tempString[],$tempString2[],$existingJoints[],$vtxs[],$fitVtxs[],$nonFullWeightedVtxs[],$joints[],$ctrls[];
string $xyz[]={"x","y","z"};

if (`attributeExists asReduceEyeLidJoints FaceDeformationSystem`)
	error "Already reduced number of EyeLidJoints";

if (`objExists asFaceBS`)
	error "Joints reduction only works for rig-type:\"Joints\"";

asVersionRequirementCheck face 6.000;

progressBar -e -st "Reducing number of joints" -bp -ii 1 -min 0 -max 5 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
if (`objExists tempXform`)
	delete tempXform;
createNode -n tempXform transform;

//find $nonFullWeightedVtxs, to be hammered later
select eyeLidArea;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	{
	if (size(`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $tempString[$i]`)>2)
		$nonFullWeightedVtxs[size($nonFullWeightedVtxs)]=$tempString[$i];
	}

asFaceLockWeights 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerOpposite="lower";}
		else {$upperLower="lower";$upperLowerOpposite="upper";}

		progressBar -e -s 1 $gMainProgressBar;
		$existingJoints=`ls -type joint ($upperLower+"LidMain*"+$side)`;

		if ($side=="_R" || $nonSymmetrical)
			{
			$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidMainCurve"+$leftSuffix)`;
			select -cl;
			$fitVtxs=`stringToStringArray $tempString[0] " "`;
			}

		//For the lower, re-use the first and last joint from upper
		if ($upperLower=="lower")
			{
			$tempString=`ls -type joint ("upperLidMain*"+$side)`;
			stringArrayInsertAtIndex(0, $existingJoints, $tempString[0]);
			stringArrayInsertAtIndex(size($existingJoints), $existingJoints, $tempString[size($tempString)-1]);
			}

		//find $midNr/$ from closest joint
		$posMid=`xform -q -ws -t ($upperLower+"Lid"+$side)`;
		$posMid1=`xform -q -ws -t ($upperLower+"Lid1"+$side)`;
		$posMid4=`xform -q -ws -t ($upperLower+"Lid4"+$side)`;
		$minMidDist=$minMid1Dist=$minMid4Dist=999;
		for ($i=1;$i<size($existingJoints)-1;$i++)
			{
			$pos=`xform -q -ws -t $existingJoints[$i]`;
			$midDist=`mag<<$posMid[0]-$pos[0],$posMid[1]-$pos[1],$posMid[2]-$pos[2]>>`;
			if ($midDist<$minMidDist) {$midNr=$i;$minMidDist=$midDist;}

			$mid1Dist=`mag<<$posMid1[0]-$pos[0],$posMid1[1]-$pos[1],$posMid1[2]-$pos[2]>>`;
			if ($mid1Dist<$minMid1Dist) {$mid1Nr=$i;$minMid1Dist=$mid1Dist;}

			$mid4Dist=`mag<<$posMid4[0]-$pos[0],$posMid4[1]-$pos[1],$posMid4[2]-$pos[2]>>`;
			if ($mid4Dist<$minMid4Dist) {$mid4Nr=$i;$minMid4Dist=$mid4Dist;}
			}
		$outerNr=size($existingJoints)-1;

		if ($upperLower=="upper")
			{
			$upperMidNr=$midNr;
			$upperMid1Nr=$mid1Nr;
			$upperMid4Nr=$mid4Nr;
			$upperOuterNr=$outerNr;
			}
		if ($upperLower=="lower")
			{
			$lowerMidNr=$midNr;
			$lowerMid1Nr=$mid1Nr;
			$lowerMid4Nr=$mid4Nr;
			}

		//find eyelid closing move distance 
		if ($side=="_R" || $nonSymmetrical)
			{
			//move eyeLid ctrl until reach opposite side
			if ($modifier!=4) refresh;
			for ($i=0;$i<99;$i++)
				{
				move -r -os  0 (-0.05*$upperLowerFactor) 0 ($upperLower+"Lid"+$side);
				$ty=`getAttr ($upperLower+"Lid"+$side+".ty")`;
				if ($upperLower=="upper")
					$tyUpper=$ty;
				$posA=`xform -q -ws -t $fitVtxs[$midNr]`;
				xform -ws -t $posA[0] $posA[1] $posA[2] tempXform;
				setAttr -l 1 tempXform.tx;
				setAttr -l 1 tempXform.tz;
				delete `geometryConstraint ($upperLowerOpposite+"LidMainCurve"+$side) tempXform`;
				$posB=`xform -q -ws -t tempXform`;
				$tyDif=$posA[1]-$posB[1];
				setAttr -l 0 tempXform.tx;
				setAttr -l 0 tempXform.tz;
				if ($upperLower=="upper" && $tyDif<=0)
					break;
				if ($upperLower=="lower" && $tyDif>=0)
					break;
				}
			if ($modifier!=4) refresh;
			setAttr ($upperLower+"Lid"+$side+".ty") 0;
			}

		if (($side=="_R" || $nonSymmetrical) && $newJointCount==4)
			{
			setAttr ($upperLower+"Lid"+$side+".ty") $ty;
			//inner->outer
			for ($i=1;$i<$outerNr;$i++)
				{
				$vtxs=`asInfluenceVerts $existingJoints[$i] $skinCluster 1.0`;
				if (size($vtxs)==0)
					continue;
				if ($i==$midNr)
					continue;
				else if ($i<$midNr)
					skinPercent -tv $existingJoints[0] 1 $skinCluster $vtxs;
				else if ($i>$midNr)
					skinPercent -tv $existingJoints[$outerNr] 1 $skinCluster $vtxs;
				for ($y=0;$y<101;$y++)
					{
					$value=$y*0.01;
					skinPercent -tv $existingJoints[$midNr] $value $skinCluster $vtxs;
					$posA=`xform -q -ws -t $fitVtxs[$i]`;
					xform -ws -t $posA[0] $posA[1] $posA[2] tempXform;
					setAttr -l 1 tempXform.tx;
					setAttr -l 1 tempXform.tz;
					delete `geometryConstraint ($upperLowerOpposite+"LidMainCurve"+$side) tempXform`;
					$posB=`xform -q -ws -t tempXform`;
					$tyDif=$posA[1]-$posB[1];
					setAttr -l 0 tempXform.tx;
					setAttr -l 0 tempXform.tz;
					if ($upperLower=="upper" && $tyDif<=0)
						break;
					if ($upperLower=="lower" && $tyDif>=0)
						break;
					}
				if ($modifier!=4)
					refresh;
				}
			setAttr ($upperLower+"Lid"+$side+".ty") 0;
			}

		if ($newJointCount==8)
			{
			//weighting vtx inbtw the remaining joints to the 2 nearest joints
			$joints={"upperLidMain0"+$side,$upperLower+"LidMain"+$midNr+$side,$upperLower+"LidMain"+$mid1Nr+$side,$upperLower+"LidMain"+$mid4Nr+$side,"upperLidMain"+$upperOuterNr+$side};
			$ctrls={"innerLid"+$side,$upperLower+"Lid"+$side,$upperLower+"Lid1"+$side,$upperLower+"Lid4"+$side,"outerLid"+$side};

			for ($i=1;$i<$outerNr;$i++)
				{
				$vtxs=`asInfluenceVerts ($upperLower+"LidMain"+$i+$side) $skinCluster 1.0`;
				if (!size($vtxs))
					continue;
				$posA=`xform -q -ws -t ($upperLower+"LidMain"+$i+$side)`;
				$min1Dist=$min2Dist=999;
				for ($y=0;$y<size($joints);$y++)
					{
					$posB=`xform -q -ws -t $ctrls[$y]`;
					$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
					if ($dist<$min1Dist)
						{
						$nearest1Nr=$y;
						$min1Dist=$dist;
						}
					}
				for ($y=0;$y<size($joints);$y++)
					{
					if ($y==$nearest1Nr)
						continue;
					$posB=`xform -q -ws -t $ctrls[$y]`;
					$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
					if ($dist<$min2Dist)
						{
						$nearest2Nr=$y;
						$min2Dist=$dist;
						}
					}
				$value=$min2Dist/($min1Dist+$min2Dist);
				skinPercent -tv $joints[$nearest1Nr] 1 $skinCluster $vtxs;
				skinPercent -tv $joints[$nearest2Nr] (1-$value) $skinCluster $vtxs;

				//then tricky weight balancing to still close eyeLid
				if ($side=="_R" || $nonSymmetrical)
					{
					setAttr ($upperLower+"Lid"+$side+".ty") $ty;
//					if ($joints[$nearest1Nr]==$upperLower+"LidMain"+$midNr+$side || $joints[$nearest2Nr]==$upperLower+"LidMain"+$midNr+$side)
						for ($y=0;$y<101;$y++)
							{
							$value=`skinPercent -t ($upperLower+"LidMain"+$midNr+$side) -ignoreBelow 0.001 -query -v $skinCluster $fitVtxs[$i]`+0.01;
							if ($value>1.0)
								break;
							skinPercent -tv ($upperLower+"LidMain"+$midNr+$side) $value $skinCluster $vtxs;
							$posA=`xform -q -ws -t $fitVtxs[$i]`;
							xform -ws -t $posA[0] $posA[1] $posA[2] tempXform;
							setAttr -l 1 tempXform.tx;
							setAttr -l 1 tempXform.tz;
							delete `geometryConstraint ($upperLowerOpposite+"LidMainCurve"+$side) tempXform`;
							$posB=`xform -q -ws -t tempXform`;
							$tyDif=$posA[1]-$posB[1];
							setAttr -l 0 tempXform.tx;
							setAttr -l 0 tempXform.tz;
							if ($upperLower=="upper" && $tyDif<=0)
								break;
							if ($upperLower=="lower" && $tyDif>=0)
								break;
							if ($modifier!=4)
								refresh;
							}
					setAttr ($upperLower+"Lid"+$side+".ty") 0;
					}
				}
			}

		//remove joints
		for ($i=1;$i<size($existingJoints)-1;$i++)
			if ($i!=$midNr && !($newJointCount==8 && ($i==$mid1Nr || $i==$mid4Nr)))
				{
				delete $existingJoints[$i];
				delete ($upperLower+"LidMain"+$i+"Aim"+$side);
				}
		skinPercent -normalize true $skinCluster $geometry;

		//remove controllers
		if ($newJointCount==4)
			for ($i=1;$i<5;$i++)
				delete ($upperLower+"Lid"+$i+"Offset"+$side);
		if ($newJointCount==8)
			for ($i=2;$i<4;$i++)
				delete ($upperLower+"Lid"+$i+"Offset"+$side);
		}
	}


//rename joints etc, to keep joint names better matching Ctrl names
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerOpposite="lower";$midNr=$upperMidNr;$mid1Nr=$upperMid1Nr;$mid4Nr=$upperMid4Nr;}
		else {$upperLower="lower";$upperLowerOpposite="upper";$midNr=$lowerMidNr;$mid1Nr=$lowerMid1Nr;$mid4Nr=$lowerMid4Nr;}


		$tempString=`listRelatives -ad -type transform LidSetup EyeLidJoints_M`;
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`gmatch $tempString[$i] ("upperLidMain0*"+$side)`)
				{
				$newName=`substitute "upper" $tempString[$i] "inner"`;
				if (`objectType $tempString[$i]`=="joint") $newName=`substitute "0" $newName "Joint"`;
				else $newName=`substitute "0" $newName ""`;
				rename $tempString[$i] $newName;
				}
			else if (`gmatch $tempString[$i] ("upperLidMain"+$upperOuterNr+"*"+$side)`)
				{
				$newName=`substitute "upper" $tempString[$i] "outer"`;
				if (`objectType $tempString[$i]`=="joint") $newName=`substitute ((string)$upperOuterNr) $newName "Joint"`;
				else $newName=`substitute ((string)$upperOuterNr) $newName ""`;
				rename $tempString[$i] $newName;
				}
			else if (`gmatch $tempString[$i] ($upperLower+"LidMain"+$midNr+"*"+$side)`)
				{
				$newName=`substitute ((string)$midNr) $tempString[$i] ""`;
				if (`objectType $tempString[$i]`=="joint") $newName=`substitute ((string)$midNr) $newName "Joint"`;
				else $newName=`substitute ((string)$midNr) $newName ""`;
				rename $tempString[$i] $newName;
				}
			else if (`gmatch $tempString[$i] ($upperLower+"LidMain"+$mid1Nr+"*"+$side)`)
				{
				$newName=`substitute ((string)$mid1Nr) $tempString[$i] "1"`;
				if (`objectType $tempString[$i]`=="joint") $newName=`substitute ((string)$mid1Nr) $newName "Joint"`;
				else $newName=`substitute ((string)$mid1Nr) $newName ""`;
				rename $tempString[$i] $newName;
				}
			else if (`gmatch $tempString[$i] ($upperLower+"LidMain"+$mid4Nr+"*"+$side)`)
				{
				$newName=`substitute ((string)$mid4Nr) $tempString[$i] "4"`;
				if (`objectType $tempString[$i]`=="joint") $newName=`substitute ((string)$mid4Nr) $newName "Joint"`;
				else $newName=`substitute ((string)$mid4Nr) $newName ""`;
				rename $tempString[$i] $newName;
				}
			}
		}
	}

//hammer $nonFullWeightedVtxs
select $nonFullWeightedVtxs;
if (size(`ls -sl`))
	weightHammerVerts;
select -cl;

if (!$nonSymmetrical)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;


//delete closestSampler tempXform LidJoints LidCurves_R LidCurves_L LidLocs_R LidLocs_L;
delete closestSampler tempXform;
asFaceLockWeights 0;

/*
//rename remaining joints to match onFaceJoint convention
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	rename ("LidMainInner"+$side) ("innerLidJoint"+$side);
	rename ("LidMainOuter"+$side) ("outerLidJoint"+$side);
	rename ("LidMainUpper"+$side) ("upperLidJoint"+$side);
	rename ("LidMainLower"+$side) ("lowerLidJoint"+$side);

	if ($newJointCount==8)
		rename ("LidMainUpper1"+$side) ("upperLid1Joint"+$side);
	}
*/

//LidContrls can rotate in $newJointCount==4
if ($newJointCount==4)
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) {$upperLower="upper";$UpperLower="Upper";}
			else {$upperLower="lower";$UpperLower="Lower";}
//			orientConstraint -mo ($upperLower+"Lid"+$side) ($upperLower+"LidMainAimEnd"+$side);
			connectAttr ($upperLower+"Lid"+$side+".rx") ($upperLower+"LidMainAimEnd"+$side+".rz");
			connectAttr ($upperLower+"Lid"+$side+".ry") ($upperLower+"LidMainAimEnd"+$side+".ry");
			connectAttr ($upperLower+"Lid"+$side+".rz") ($upperLower+"LidMainAimEnd"+$side+".rx");
			createNode -n ($upperLower+"LidMainAimEndRotMPD"+$side) multiplyDivide;
			connectAttr ($upperLower+"Lid"+$side+".rx") ($upperLower+"LidMainAimEndRotMPD"+$side+".input1X");
			connectAttr ($upperLower+"Lid"+$side+".ry") ($upperLower+"LidMainAimEndRotMPD"+$side+".input1Y");
			connectAttr ($upperLower+"Lid"+$side+".rz") ($upperLower+"LidMainAimEndRotMPD"+$side+".input1Z");
			setAttr ($upperLower+"LidMainAimEndRotMPD"+$side+".input2") -type float3 -1 -1 -1;
			if ($side=="_R")
				connectAttr -f ($upperLower+"LidMainAimEndRotMPD"+$side+".outputZ") ($upperLower+"LidMainAimEnd"+$side+".rx");
			if ($side=="_L")
				connectAttr -f ($upperLower+"LidMainAimEndRotMPD"+$side+".outputX") ($upperLower+"LidMainAimEnd"+$side+".rz");
			}
		}

//other affected objects (eyeLashes)
if ($eyeLash!="" && !`gmatch $eyeLash "*[.]*"`)
	{
	$tempString=`stringToStringArray $eyeLash " "`;
	for ($i=0;$i<size($tempString);$i++)
		{
		select $geometry $tempString[$i];
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}
	}

//lidOuters
if (`objExists upperLidOuter_R`)
	{
	asFaceLockWeights 1;
	setAttr ($headJoint+".lockInfluenceWeights") 0;
	select `ls -type joint "*Lid*Outer*_*"` $geometry;
	RemoveInfluence;
	skinPercent -normalize true $skinCluster $geometry;
	asFaceLockWeights 0;
	delete `ls -type joint "*Lid*Outer*_*"` `ls "*Lid*OuterOffset_*"`;
	}

//some attributes have been removed
asUpdatePoseAttributes;

addAttr -ln asReduceEyeLidJoints -at long  -dv $newJointCount FaceDeformationSystem;
select -cl;
print ("// EyeLidJoints reduced to:"+$newJointCount+"\n");
}

global proc asCustomReduceUI ()
{
string $tempString[];

if (`window -q -ex asCustomReduce`)
	deleteUI asCustomReduce;

$tempString=`listRelatives -c -type joint LipJoints_M`;

window -t "Custom Face Joint Reduce" asCustomReduce;
columnLayout;
	separator -h 10 -st none;
	rowLayout -nc 3;
		separator -w 150 -st none;
		text -l "Joints:";
		optionMenu -cc asCustomReduceCC asCREyeLidLipOptionMenu;
			menuItem -l "EyeLid";
			menuItem -l "Lip";
		setParent..;
	separator -h 10 -st none;
	rowLayout -nc 6;
		text -l "current count is:";
		intField -w 30 -ed 0 -v `size($tempString)` asCRCCIntField;
		text -l "keep every:" asCREIntField;
		optionMenu -cc asCustomReduceCC asCRREOptionMenu;
			menuItem -l "2nd";
			menuItem -l "3rd";
			menuItem -l "4th";
			menuItem -l "5th";
		text -l "\tnew count will be:";
		intField -w 30 -ed 0 -v 0 asCRNCIntField;
		setParent..;

		separator -h 30 -st none;
		rowLayout -nc 4;
			separator -w 60 -st none;
			button -l "Preview" -c "createNode -n asCustomReducePreview transform;asCustomReduce";
			text -l "\t(Selects the joints that will be kept)";
			setParent..;
		separator -h 25 -st none;
		rowLayout -nc 4;
			separator -w 60 -st none;
			button -w 100 -l "Apply" -c asCustomReduce;
			separator -w 25 -st none;
			button -w 100 -l "Close" -c "deleteUI asCustomReduce";
			setParent..;
		separator -h 25 -st none;

showWindow;
asCustomReduceCC;
}

global proc asCustomReduce ()
{
global string $gMainProgressBar;
int $every=`optionMenu -q -sl asCRREOptionMenu`+1;
int $newJointCount=`intField -q -v asCRNCIntField`;
int $upperLowerFactor,$preview,$jointNr;
float $jointWeights[],$sortedJointWeights[];
string $lidLip="Lip";
string $mainJoint="Joint";
string $parentJoint="LipJoints_M";
string $side,$upperLower,$joint,$sc,$mainJointOuter;
string $tempString[],$tempString2[],$removeJoints[],$skinClusters[],$allJoints[],$infs[];

asVersionRequirementCheck face 6.000;

if (`optionMenu -q -v asCREyeLidLipOptionMenu`=="EyeLid")
	{
	$lidLip="Lid";
	$mainJoint="Main";
	$parentJoint="EyeLidJoints_M";
	}

if (`objExists asCustomReducePreview`)
	{
	$preview=1;
	delete asCustomReducePreview;
	}

if ($lidLip=="Lip" && `attributeExists asReduceLipJoints FaceDeformationSystem`)
	error "Already reduced number of LipJoints";
if ($lidLip=="Lid" && `attributeExists asReduceEyeLidJoints FaceDeformationSystem`)
	error "Already reduced number of EyeLidJoints";

if ($preview && `attributeExists jointVis Main`)
	if (!`getAttr Main.jointVis`)
		setAttr Main.jointVis 1;

select -cl;
$tempString=`listRelatives -ad -type joint FaceJoint_M`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] ("*"+$lidLip+"*")`)
		if (!`gmatch $tempString[$i] ("*Base*")`)
			if ($tempString[$i]!="LipJoints_M" && $tempString[$i]!="EyeLidJoints_M")
				select -add $tempString[$i];
$allJoints=`ls -sl`;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		$mainJointOuter=$mainJoint;
		for ($c=1;$c>-2;$c=$c-2)
			{
			if ($c==-1 && $lidLip=="Lip") continue;
			if ($c==-1) $mainJointOuter="Outer";

			for ($i=1;$i<999;$i++)
				{
				$joint=$upperLower+$lidLip+$mainJointOuter+$i+$side;
				if (!`objExists $joint`)
					break;
				if (!($i%$every))
					continue;
				select -d $joint;
				}
			}
		}
	}
if ($preview)
	return;

$tempString=`ls -sl`;
select $allJoints;
select -d $tempString;
$removeJoints=`ls -sl`;

createNode -n ($lidLip+"JointReducedNoLongerDeformJoints") -p $parentJoint transform;
parent ($lidLip+"JointReducedNoLongerDeformJoints") ($lidLip+"Setup");
//For lip, the joints will still be used to drive e.g. upperLipRibbonCurve, since ctrls are attached to this
if ($lidLip=="Lip")
	{
//	parentConstraint LipJoints_M ($lidLip+"JointReducedNoLongerDeformJoints");
//	scaleConstraint LipJoints_M ($lidLip+"JointReducedNoLongerDeformJoints");
	asParentConstraint LipJoints_M LipJointReducedNoLongerDeformJoints "";
	}

$skinClusters=`listConnections -s 0 -d 1 -type skinCluster ($removeJoints[0]+".worldMatrix")`;
for ($y=0;$y<size($skinClusters);$y++)
	if (`gmatch $skinClusters[$y] "*LipRibbonCurveSC"`)
		$skinClusters=`stringArrayRemove {$skinClusters[$y]} $skinClusters`;

for ($y=0;$y<size($skinClusters);$y++)
	{
	if (`objExists ("asCustomReduceVtxSet"+$y)`) delete ("asCustomReduceVtxSet"+$y);
	if (`objExists ("asCustomReduceBalanceVtxSet"+$y)`) delete ("asCustomReduceBalanceVtxSet"+$y);
	sets -em -n ("asCustomReduceVtxSet"+$y);
	sets -em -n ("asCustomReduceBalanceVtxSet"+$y);//to be attempted to limit to 2 inf for improved balancng
	}

progressBar -e -st "Reducing number of joints" -bp -ii 1 -min 0 -max (size($removeJoints)*2) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
for ($i=0;$i<size($removeJoints);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	$joint=$removeJoints[$i];
	for ($y=0;$y<size($skinClusters);$y++)
		{
		select -cl;
		skinCluster -e -selectInfluenceVerts $joint $skinClusters[$y];
		select -d $joint;
		select -d `ls -sl -o`;
		if (size(`ls -sl`))
			sets -add ("asCustomReduceVtxSet"+$y) `ls -sl`;
		}
	}

select -cl;
for ($y=0;$y<size($skinClusters);$y++)
	select -add ("asCustomReduceVtxSet"+$y);
$tempString=`ls -sl -fl`;
for ($y=0;$y<size($skinClusters);$y++)
	{
	sets -clear ("asCustomReduceVtxSet"+$y);
	sets -clear ("asCustomReduceBalanceVtxSet"+$y);
	}
for ($i=0;$i<size($tempString);$i++)
	for ($y=0;$y<size($skinClusters);$y++)
		{
		select $tempString[$i];
		$tempString2=`skinPercent -ignoreBelow 0.001 -query -transform $skinClusters[$y] $tempString[$i]`;
		$tempString2=`stringArrayRemove {"LipJoint_R","LipJoint_L"} $tempString2`;//purpose blended for `corner-blend`
		if (size($tempString2)==0)
			continue;
		if (size($tempString2)==1)
			sets -add ("asCustomReduceBalanceVtxSet"+$y) `ls -sl`;
		if (size($tempString2)>1)
			sets -add ("asCustomReduceVtxSet"+$y) `ls -sl`;
		}

for ($i=0;$i<size($removeJoints);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	$joint=$removeJoints[$i];
	for ($y=0;$y<size($skinClusters);$y++)
		skinCluster -e -ri $joint $skinClusters[$y];
	}
//delete $removeJoints;
parent $removeJoints ($lidLip+"JointReducedNoLongerDeformJoints");

//rename $removeJoints to avoid duplicated names
for ($i=0;$i<size($removeJoints);$i++)
	$removeJoints[$i]=`rename $removeJoints[$i] ("LJRNLDJ"+$removeJoints[$i])`;//LJRNLDJ = LipJointReducedNoLongerDeformJoints

//First BalanceVtxSet"+$y);//limit to 2 strongest infs
for ($y=0;$y<size($skinClusters);$y++)
	{
	select ("asCustomReduceBalanceVtxSet"+$y);
	if (!size(`ls -sl`))
		continue;
	weightHammerVerts;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$jointWeights=`skinPercent -ignoreBelow 0.001 -query -v $skinClusters[$y] $tempString[$i]`;
		if (size($jointWeights)<2)
			continue;
		$sortedJointWeights=`sort $jointWeights`;
		skinPercent -pruneWeights $sortedJointWeights[size($sortedJointWeights)-2] $skinClusters[$y] $tempString[$i];
		}
	}

//Next Hammer the other vtxs
for ($y=0;$y<size($skinClusters);$y++)
	{
	select ("asCustomReduceVtxSet"+$y);
	if (!size(`ls -sl`))
		continue;
	weightHammerVerts;
	}

for ($y=0;$y<size($skinClusters);$y++)
	{
	delete ("asCustomReduceBalanceVtxSet"+$y);
	delete ("asCustomReduceVtxSet"+$y);	
	}

//rename joint to keep number in name sequential
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		$jointNr=1;
		for ($i=1;$i<999;$i++)
			{
			$joint=$upperLower+$lidLip+$mainJoint+$i+$side;
			if (!`stringArrayCount $joint $removeJoints` && !`objExists $joint`)
				break;
			if (!`stringArrayCount $joint $removeJoints`)
				{
				rename $joint ($upperLower+$lidLip+$mainJoint+$jointNr+$side);
				$jointNr++;
				}
			}
		}
	}

if ($lidLip=="Lip") addAttr -ln asReduceLipJoints -at long  -dv $newJointCount FaceDeformationSystem;
if ($lidLip=="Lid") addAttr -ln asReduceEyeLidJoints -at long  -dv $newJointCount FaceDeformationSystem;
select -cl;
print ("// Custom reduce completed, removed:"+`size($removeJoints)`+" joints.\n");
}

global proc asCustomReduceCC ()
{
int $currentCount=`intField -q -v asCRCCIntField`;
int $every=`optionMenu -q -sl asCRREOptionMenu`+1;
string $eyeLidLip=`optionMenu -q -v asCREyeLidLipOptionMenu`;
string $tempString[];

//update current count (lip or lid)
if ($eyeLidLip=="EyeLid")
	$tempString=`listRelatives -c -type joint EyeLidJoints_M`;
if ($eyeLidLip=="Lip")
	$tempString=`listRelatives -c -type joint LipJoints_M`;
$currentCount=size($tempString);
intField -e -v $currentCount asCRCCIntField;

//update new count
intField -e -v ($currentCount/$every) asCRNCIntField;
}

global proc asReduceLipJoints (int $newJointCount)
{
global string $gMainProgressBar;
int $aNr,$bNr,$cNr;
float $aDist,$bDist,$cDist,$minADist,$minBDist,$minCDist,$value;
float $pos[],$posA[],$posB[],$posC[];
string $geometry=`textField -q -tx asFaceFaceTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $side,$leftSuffix,$newName;
string $tempString[],$existingJoints[],$vtxs[],$historyNodes[],$inJoints[],$outJoints[],$hammerInVtxs[],$hammerOutVtxs[];

if (`attributeExists asReduceLipJoints FaceDeformationSystem`)
	error "Already reduced number of LipJoints";

if (`objExists asFaceBS`)
	error "Joints reduction only works for rig-type:\"Joints\"";

asVersionRequirementCheck face 6.000;

createNode -n LipJointReducedNoLongerDeformJoints -p LipJoints_M transform;
parent LipJointReducedNoLongerDeformJoints LipSetup;
asParentConstraint LipJoints_M LipJointReducedNoLongerDeformJoints "";

progressBar -e -st "Reducing number of joints" -bp -ii 1 -min 0 -max 5 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) {$side="_R";$leftSuffix="";}
	else {$side="_L";$leftSuffix="Left";}

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		progressBar -e -s 1 $gMainProgressBar;

		select `listRelatives -c -type joint LipJoints_M`;
		select `ls -sl ($upperLower+"*"+$side)`;
		$existingJoints=`ls -sl`;

		//find $aNr,$bNr from closest joint
		$posA=`xform -q -ws -t ($upperLower+"LipA"+$side)`;
		$posB=`xform -q -ws -t ($upperLower+"LipB"+$side)`;
		$posC=`xform -q -ws -t ($upperLower+"LipC"+$side)`;
		$minADist=$minBDist=$minCDist=999;
		for ($i=0;$i<size($existingJoints);$i++)
			{
			$pos=`xform -q -ws -t $existingJoints[$i]`;
			$aDist=`mag<<$posA[0]-$pos[0],$posA[1]-$pos[1],$posA[2]-$pos[2]>>`;
			$bDist=`mag<<$posB[0]-$pos[0],$posB[1]-$pos[1],$posB[2]-$pos[2]>>`;
			$cDist=`mag<<$posC[0]-$pos[0],$posC[1]-$pos[1],$posC[2]-$pos[2]>>`;
			if ($aDist<$minADist) {$aNr=$i;$minADist=$aDist;}
			if ($bDist<$minBDist) {$bNr=$i;$minBDist=$bDist;}
			if ($cDist<$minCDist) {$cNr=$i;$minCDist=$cDist;}
			}

		clear $outJoints;
		if ($side=="_R")
			$outJoints[size($outJoints)]=($upperLower+"LipJoint0_M");

		for ($i=0;$i<size($existingJoints);$i++)
			if ($i==$aNr || $i==$bNr || $i==$cNr)
				{
				if ($i==$aNr) $newName=$upperLower+"LipAJoint"+$side;
				if ($i==$bNr) $newName=$upperLower+"LipBJoint"+$side;
				if ($i==$cNr) $newName=$upperLower+"LipCJoint"+$side;
				rename $existingJoints[$i] $newName;
				$inJoints[size($inJoints)]=$newName;
				}
			else
				$outJoints[size($outJoints)]=$existingJoints[$i];

		for ($i=0;$i<size($inJoints);$i++)
			{
			$tempString=`asInfluenceVerts $inJoints[$i] $skinCluster 1.0`;
			$hammerInVtxs=`stringArrayCatenate $hammerInVtxs $tempString`;
			}

		for ($i=0;$i<size($outJoints);$i++)
			{
			$tempString=`asInfluenceVerts $outJoints[$i] $skinCluster 1.0`;
			$hammerOutVtxs=`stringArrayCatenate $hammerOutVtxs $tempString`;
			skinCluster -e -ri $outJoints[$i] $skinCluster;
			parent $outJoints[$i] LipJointReducedNoLongerDeformJoints;
			}
		}
	}

//hammer vtx that was weighted to removed joints
select $hammerOutVtxs;
if (size(`ls -sl`))
	weightHammerVerts;

//then hammer vtx at remaining joints for smoothing
select $hammerInVtxs;
if (size(`ls -sl`))
	weightHammerVerts;
//	asWeightHammerVerts 0;

//then hammer lipFalloffArea
select lipFalloffArea;
if (size(`ls -sl`))
	weightHammerVerts;

asFaceLockWeights 0;

//other affected objects (mustache etc)
$tempString=`listConnections upperLipJoint0_M.worldMatrix`;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]==$skinCluster)
		continue;
	$historyNodes=`listHistory -il 2 -f 1 $tempString[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="mesh")
			{
			select $geometry $historyNodes[$y];
			copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
			}
	}

//parent Constraint nodes to DeformJointConstraints
$tempString=`listRelatives -ad -type constraint FaceJoint_M`;
if (size($tempString))
	parent $tempString DeformJointConstraints;

addAttr -ln asReduceLipJoints -at long  -dv $newJointCount FaceDeformationSystem;
select -cl;
print ("// LipJoints reduced to:"+$newJointCount+"\n");
}

global proc float asDistFactor (string $from, string $toA, string $toB)
{
float $distFactor;
float $pos[]=`xform -q -ws -t $from`;
float $posA[]=`xform -q -ws -t $toA`;
float $posB[]=`xform -q -ws -t $toB`;
float $distToA=`mag<<$pos[0]-$posA[0],$pos[1]-$posA[1],$pos[2]-$posA[2]>>`;
float $distToB=`mag<<$pos[0]-$posB[0],$pos[1]-$posB[1],$pos[2]-$posB[2]>>`;
$distFactor=$distToA/($distToA+$distToB);
//if ($distFactor<0.5)
//	$distFactor=`smoothstep 0 1 $distFactor`;

return $distFactor;
}

global proc string[] asInfluenceVerts (string $joint, string $skinCluster, float $threshold)
{
string $sel[]=`ls -sl`;
select -cl;
string $vtx[],$tempString[],$infs[];

skinCluster -e -selectInfluenceVerts $joint $skinCluster;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] "*[.]*"`)
		continue;
	$infs=`skinPercent -ignoreBelow $threshold -q -t $skinCluster $tempString[$i]`;
	for ($y=0;$y<size($infs);$y++)
		if ($infs[$y]==$joint)
			$vtx[size($vtx)]=$tempString[$i];
	}

select $sel;
return $vtx;
}

global proc freezeSkinCluster (string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
int $numMatrix;
float $jointMatrix[];
string $tempString[];

$numMatrix=`getAttr -s ($skinCluster+".bindPreMatrix")`;
for ($i=0;$i<$numMatrix;$i++)
	{
	$tempString=`listConnections -s 1 -d 1 ($skinCluster+".matrix["+$i+"]")`;
	if (!`objExists $tempString[0]`)
		continue;
	$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
	setAttr ($skinCluster+".bindPreMatrix["+$i+"]") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
	}
}

global proc asSetDisplayLayersToR ()
{
string $displayLayers[]=`listConnections layerManager.displayLayerId`;
for ($i=$y=0;$i<size($displayLayers);$i++)
	{
	if ($displayLayers[$i]=="defaultLayer")
		continue;
	setAttr ($displayLayers[$i]+".displayType") 2;
	}
}

global proc asPublish ()
{
string $sceneName=`file -q -sn`;
if ($sceneName=="")
	error "File not saved, can not publish";
string $tempString[],$controlSetMembers[],$animatedCtrls[],$attrs[];
string $publishFile;
string $basename=`basenameEx $sceneName`;
string $filePath=`asStripPath $sceneName 1`;

//check for animation
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	$tempString=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $tempString`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$attrs=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		if (size(`listConnections -s 1 -d 0 -type animCurve ($controlSetMembers[$i]+"."+$attrs[$y])`))
			$animatedCtrls[size($animatedCtrls)]=$controlSetMembers[$i];
	}
if (size($animatedCtrls))
	{
	select $animatedCtrls;
	refresh;
	if (`confirmDialog -title "Confirm" -message 
		("Animation found:\n\n"
		+"The selected controllers have animation.\n"
		+"Do you wish to proceed to publish rig with the animation")
	    -button "Yes" -button "No" -defaultButton "No"
	    -cancelButton "No" -dismissString "No"`!="Yes")
		return;
	}

if (`gmatch $sceneName "*[.]mb"`)
	{
	print "// Your working file is already MB format, appending \"_Published\" to the name.\n";
	$publishFile=$filePath+$basename+"_Published.mb";
	}
else
	$publishFile=$filePath+$basename+".mb";
if (`file -q -ex $publishFile`)
	{
	print ("// Publish file already exits, performing incrementalSave for backup.\n");
	file -rename $publishFile;
	incrementalSaveScene;
	file -rename $sceneName;
	}

//string $references[]=`file -q -r`;
//for ($i=0;$i<size($references);$i++)
//	file -importReference $references[$i];
file -f -op "v=0" -typ "mayaBinary" -ea $publishFile;

print ("// Published: \""+$publishFile+"\".\n");
}

global proc asZipExport ()
{
int $numTok;
string $sceneName=`file -q -sn`;
string $ext,$suppportDir,$suppportMayaFile,$zipFile;
string $sLoc=`asGetScriptLocation`;
string $curl=$sLoc+"/AdvancedSkeletonFiles/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeletonFiles/bin/7za.e";
string $tempString[];

$tempString=`fileDialog2 -fileFilter "*.7z" -dialogStyle 2`;
$zipFile=$tempString[0];
if ($zipFile=="")
	return;

$numTok=`tokenize $sceneName "." $tempString`;
$ext=$tempString[$numTok-1];
$suppportDir=`asGetTempDirectory`+"AdvancedSkeleton/support";
if (!`file -q -ex $suppportDir`)
	sysFile -md $suppportDir;
$suppportMayaFile=$suppportDir+"/support."+$ext;
print ("// exporting to file:\""+$suppportMayaFile+"\\n");
if ($ext=="ma")
	file -f -op "v=0" -typ "mayaAscii" -ea $suppportMayaFile;
if ($ext=="mb")
	file -f -op "v=0" -typ "mayaBinary" -ea $suppportMayaFile;

//zip
if (`about -mac` || `about -linux`)
  $cmd="zip -r "+$zipFile+" "+$suppportMayaFile;
else
	$cmd="start\/wait/I \"zipping\"  \""+$zip+"\" a \""+$zipFile+"\" \""+$suppportMayaFile+"\"";
print ("// Starting Zip:"+$cmd+";\n");
system($cmd);

}

global proc asReBuildDagPose ()
{
string $tempString[];

if (!`asConfirmIfNotInBuildPose`)
	return;

$tempString= `ls -type dagPose`;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*uildPose*"`)
		delete $tempString[$i];
select -hi Root_M;
if (`objExists |root`) //Unreal Skeleton
	select -hi |root;
select -d `ls -sl "*Constraint*"`;
select -add DeformationSystem;//fbx exporter preffers this to be included
string $bindPoseNode=`dagPose -save -selection -bindPose -name bindPose`;
select -cl;
print ("// dagPose node: \""+$bindPoseNode+"\" created.\n");
}

global proc asSelectNearestVtxOnMesh (string $transform, string $geometry)
{
int $closestVertexIndex;
float $pos[];
string $closestPointOnMeshNode,$mesh;
string $tempString[];

$tempString=`listRelatives -ni -s $geometry`;
$mesh=$tempString[0];
$closestPointOnMeshNode=`createNode closestPointOnMesh`;
connectAttr ($mesh+".outMesh") ($closestPointOnMeshNode+".inMesh");

$pos=`xform -q -ws -t $transform`;
setAttr -type float3 ($closestPointOnMeshNode+".inPosition") $pos[0] $pos[1] $pos[2];
$closestVertexIndex=`getAttr ($closestPointOnMeshNode+".result.closestVertexIndex")`;
delete $closestPointOnMeshNode;
select ($mesh+".vtx["+$closestVertexIndex+"]");	
}

global proc asOneJointProp ()
{
string $skin=`textField -q -tx asBodySkinTextField`;
string $all=`textField -q -tx asBodyAllTextField`;
string $alls[]=`stringToStringArray $all " "`;
string $checkObjs[]={"FitSkeleton","|Group","Root"};
string $skins[]=`stringToStringArray $skin " "`;
string $tempString[];
float $s;
float $bb[];

if ($skin=="") error "No object defined as \"Skin\"";
for ($i=0;$i<size($skins);$i++)
	if (!`objExists $skins[$i]`) error ("Choosen Skin object:\""+$skins[$i]+"\" not found");
for ($i=0;$i<size($alls);$i++)
	if (!`objExists $alls[$i]`) error ("Choosen All object:\""+$alls[$i]+"\" not found");
for ($i=0;$i<size($checkObjs);$i++)
	if (`objExists $checkObjs[$i]`) error ($checkObjs[$i]+" already exists");

$bb=`xform -q -ws -bb $skins[0]`;
select -cl;
joint -n Root -p (($bb[0]+$bb[3])/2.0) (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0);
setAttr Root.jointOrient -type float3 90 0 90;//assume Spine Start, with x-down
asEnsureFitJointAttrs Root;
setAttr Root.fat ($bb[4]/2.0);
asCreateFitSkeleton;
$s=$bb[4]/2.0;
xform -s $s $s $s FitSkeleton.cv[0:7];
asSavePrepInput;
parent Root FitSkeleton;
asReBuildAdvancedSkeleton;

select -cl;
for ($i=0;$i<size($skins);$i++)
	select -add $skins[$i];
eval ("select -add "+$all);
if (!`objExists Hi`)
	createDisplayLayer -name Hi -number 1 -nr;

select -add Root_M;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
select -cl;

//determine `top node` of geo, for parenting to rig
$tempString=`ls -l $skins[0]`;
tokenize $tempString[0] "|" $tempString;
catchQuiet (`parent $tempString[0] Geometry`);//catchQuiet to skip referenced-in-errors

print "// One Joint Prop rig created.\n";
}

global proc asDeleteAdvanced ()
{
string $upAxisDirection=`upAxis -q -ax`;
string $tempString[],$tempString2[];

if (!`objExists FitSkeleton`)
	return;
asDetectPreviousFails;
if (`objExists FaceGroup`)
	{
	if (`confirmDialog -t Confirm -m "This will also delete the FaceSetup" -b "Ok" -b "Cancel" -db "Ok"`!="Ok")
		return;
	asDeleteAdvancedFace;
	}
if (!`objExists |FitSkeleton`)
	parent -w FitSkeleton;
if ($upAxisDirection=="z")
	asSceneUpAxisFlip FitSkeleton z;
if (`objExists Geometry`)
	{
	$tempString=`listRelatives -type transform -c Geometry`;
	if (size($tempString))
		parent -w $tempString;
	}
if (`objExists Sets`)
	{
	//set MPD`s to `noOp` first, to avoid Warning `divide by zero`
	select Sets;
	$tempString=`ls -sl -type multiplyDivide`;
	for ($i=0;$i<size($tempString);$i++)
		catchQuiet (`setAttr ($tempString[$i]+".operation") 0`);

	if (`objExists AllSet`)
		{
		$tempString=`sets -q AllSet`;
		for ($i=0;$i<size($tempString);$i++)
			if (`gmatch $tempString[$i] "*CurveInfo*"`)
				if (`objExists $tempString[$i]`)
					{
//					delete $tempString[$i];//some Maya version throw warning
					select $tempString[$i];
					delete;
					}
		}

	select Sets;
	select -d `listConnections -type animCurve FitSkeleton`;//keep drivingSystems
	delete;
	if (`objExists DeformSet`) delete DeformSet;
	if (`objExists ControlSet`) delete ControlSet;
	if (`objExists AllSet`) delete AllSet;
	if (`objExists Sets`) delete Sets;
	}
print ("// Existing AdvancedSkeleton removed.\n");
asUpdateButtonEnables;
}

global proc asDetectPreviousFails ()
{
int $previousFail;
string $m,$m2;

if (`objExists AllSet`)
	if (!size(`sets -q AllSet`))
		{
		$previousFail=1;
		$m="Empty \"AllSet\" found,\nindicating a previous build attempt has failed.\n\n";
		}
if (`objExists "|Group"` && `objExists "|FitSkeleton"`)
	{
	$previousFail=1;
	$m="TopNode \"Group\" found and unparented \"FitSkeleton\" found,\nindicating a previous build attempt has failed.\n\n";
	}

//detect empty AllSet
if ($previousFail)
	{
	$m+="This means there is a un-completed rig in the scene\n\n"
		+"In order to Continue, you must \"Undo\" to go back to before the Error.";

	$m2="Learn more about how to manage AdvancedSkeleton Errors here: https://youtu.be/bkMYO_-OCAU\n";
	if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Open ScriptEditor" -db "Ok"`=="Open ScriptEditor")
		ScriptEditor;
	error ($m+"\n"+$m2);
	}

//string $button=`button -w 200 -h 50 -l $buttonLabel -c ("showHelp -a \""+$helpUrl+"\"")`;
}

global proc asVersionUpdates ()
{
//v 6.0303 found right-hand DrivingSystem-anim-curves with tangets not matching left side, attempting to auto-fix
string $keyIttsR[],$keyIttsL[],$keyOttsR[],$keyOttsL[],$tempString[],$legazyObjAttrs[];
string $side,$m,$dialogResult;
string $fingers[]={"Thumb","Pinky","Ring","Middle","Cup","Index"};
string $orientFitAttrs[]={"primaryAxis","secondaryAxis","worldmatch","mirTrans"};

for ($y=0;$y<size($fingers);$y++)
	for ($i=1;$i<4;$i++)
		{
		if (!`objExists ("SDKFK"+$fingers[$y]+"Finger"+$i+"_R_rotateY")` || !`objExists ("SDKFK"+$fingers[$y]+"Finger"+$i+"_R_rotateY")`)
			continue;
		if (!`objExists ("SDKFK"+$fingers[$y]+"Finger"+$i+"_L_rotateY")` || !`objExists ("SDKFK"+$fingers[$y]+"Finger"+$i+"_L_rotateY")`)
			continue;
		$keyIttsR=`keyTangent -q -itt ("SDKFK"+$fingers[$y]+"Finger"+$i+"_R_rotateY")`;
		$keyOttsR=`keyTangent -q -ott ("SDKFK"+$fingers[$y]+"Finger"+$i+"_R_rotateY")`;
		$keyIttsL=`keyTangent -q -itt ("SDKFK"+$fingers[$y]+"Finger"+$i+"_L_rotateY")`;
		$keyOttsL=`keyTangent -q -ott ("SDKFK"+$fingers[$y]+"Finger"+$i+"_L_rotateY")`;
		if ($keyIttsR[0]=="linear" && $keyIttsR[1]=="fixed" && $keyIttsR[2]=="fixed" && $keyIttsL[0]=="linear" && $keyIttsL[1]=="linear" && $keyIttsL[2]=="linear")
			{
			print ("// detected incorrect DrivingSystem-keyTangent from older version of AdvancedSkeleton on:\"SDKFK"+$fingers[$y]+"Finger"+$i+"_R_rotateY\" now fixing this.\n");
			keyTangent -in "0:3" -itt linear -ott linear ("SDKFK"+$fingers[$y]+"Finger"+$i+"_R_rotateY");
			}
		}

//v 6.210 added "Control Orient", with intention of Leaving Joint Default Oriented, and custom Orient only controllers.
//so older version rigs, might have legacy FitSkeleton-orient FitAttributes. offer to remove these here
$tempString=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	for ($y=0;$y<size($orientFitAttrs);$y++)
		{
		if (`attributeExists $orientFitAttrs[$y] $tempString[$i]`)
			$legazyObjAttrs[size($legazyObjAttrs)]=$tempString[$i]+"."+$orientFitAttrs[$y];
		}
if (size($legazyObjAttrs))
	{
	$m="Old Custom-orientations Attributes found.\n";
	$m+="It is recommended to delete these";
	$dialogResult=`confirmDialog -t Confirm -m $m -b "Ok" -b "No, just proceed" -b "Open YouTube explainer video" -b "Cancel" -db "Ok"`;
	if ($dialogResult=="Open YouTube explainer video")
		{
		showHelp -a "https://youtu.be/-olqo7YCy3I";
		error "YouTube video opened, and Process Cancelled";
		}
	else if ($dialogResult=="Ok")
		{
		for ($i=0;$i<size($legazyObjAttrs);$i++)
			deleteAttr $legazyObjAttrs[$i];
		asFitModeManualUpdate;
		refresh;
		}
	else if ($dialogResult=="No, just proceed")
		return;
	else
	 error "Process Cancelled";
	}
}

global proc asReBuildAdvancedSkeleton ()
{
global int $asBuilding;
global int $asRebuilding;
global string $gMainProgressBar;
int $opm=`asGetOpm`;
int $asConfirmIfNotInBuildPose=`asConfirmIfNotInBuildPose`;
string $m;
string $currentUnitLinear=`currentUnit -q -f`;
$m="Units currently set to: \""+$currentUnitLinear+"\"\nAdvancedSkeleton requires \"cm\".\nClick OK to switch";
string $reservedNames[]={"Group","MotionSystem","DeformationSystem","Geometry"};
string $allNodeTypes[]=`allNodeTypes`;

if (!$asConfirmIfNotInBuildPose)
	return;

if ($currentUnitLinear!="centimeter")
	{
	if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`=="Ok")
		currentUnit -l cm;
	else
		return;
	}

asDetectPreviousFails;

if ($opm && !`stringArrayCount "quatToEuler" $allNodeTypes`)
	{
	loadPlugin quatNodes;
	error "quatToEuler command missing, now attempting to load required plugin \"quatNodes.mll\", Try running Build again.";
	}

if (`objExists AutoPlacing`)
	asFitDeleteGuides;

if (!`objExists "Group"`)
	{
	$asBuilding=1;

	for ($i=0;$i<size($reservedNames);$i++)
		if (`objExists $reservedNames[$i]`)
			{
			select $reservedNames[$i];
			error ("This object is called: \""+$reservedNames[$i]+"\", Rename this object to another name, before Building AdvancedSkeleton");
			}

	asBuildAdvancedSkeleton;//First build
	asUpdateButtonEnables;
	$asBuilding=0;
	return;
	}

if (`objExists "prefix_Group"`)
	error "Object \"prefix_Group\" found, which means a previous build failed. Try to Undo previous build, to restore functional AdvancedSkeleton";

if (`objExists "Group"` && `objExists FitSkeleton`)
	if (!`getAttr FitSkeleton.v`)
		asToggleFitAdvancedSkeleton;

int $keepAll=`checkBox -q -v asKeepAllCheckBox`;
int $keepCurveShapes=`checkBox -q -v asKeepCurveShapesCheckBox`;
int $keepControlOrient=`checkBox -q -v asKeepControlOrientCheckBox`;
int $keepBuildPose=`checkBox -q -v asKeepBuildPoseCheckBox`;
int $keepParenting=`checkBox -q -v asKeepParentingCheckBox`;
int $keepParentConstraints=`checkBox -q -v asKeepParentConstraintsCheckBox`;
int $keepLockHide=`checkBox -q -v asKeepLockHideCheckBox`;
int $keepUserAttrs=`checkBox -q -v asKeepUserAttrsCheckBox`;
int $keepLimits=`checkBox -q -v asKeepLimitsCheckBox`;
int $keepSkinning=`checkBox -q -v asKeepSkinningCheckBox`;
int $removeUnusedAttributes=`checkBox -q -v asRemoveUnusedAttributesCheckBox`;
string $upAxisDirection=`upAxis -q -ax`;
string $tempString[],$tempString2[],$sources[],$destinations[],$sourcesNoPlug[],$destinationsNoPlug[];
string $roots[];

if (!`objExists FitSkeleton`)
	error "No skeleton to rebuild\n";

asVersionUpdates;
parent -w FitSkeleton;

if (`attributeExists axisChanged FitSkeleton`)
	{
	print ("// detected change of Axis settings, so keeping of CurveShapes will be skipped, since due to changed orientations.\n");
	$keepAll=0;
	$keepCurveShapes=0;
	}

progressBar -e -st "Analyzing AdvancedSkeleton" -bp -ii 0 -min 0 -max (size(`sets -q AllSet`)*2) $gMainProgressBar;

//Pre Rebuild
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $userAttrs[],$children[],$connections[],$connectionsObj[],$connectCmdsSource[],$connectCmdsDest[];
string $addAttrCmds[],$setAttrCmds[],$cmds[],$shapeCmds[],$connectCmds[],$skinClusters[],$jointClusters[],$checkAttrs[];
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$enumName,$skinCluster,$control;
string $charSet,$objectType,$target,$restorePoseCmd,$preRebuildScript;
int $childIsMember,$alreadyConnected,$overrideRGBColors;
int $locked;
int $e[2];
float $version;
float $mx[];
float $range[2];
float $vals[2];

if (`attributeExists version Main`)
	$version=`getAttr Main.version`;

//Pre Rebuild : preRebuildScript
if (!`attributeExists preRebuildScript FitSkeleton`)
	asEnsureFitSkeletonAttributes;
$preRebuildScript=`getAttr FitSkeleton.preRebuildScript`;
if ($preRebuildScript!="")
	evalEcho ($preRebuildScript);

if (`objExists CustomSystem` && `objExists ControlSet`)
	{
	$tempString=`listRelatives -ad CustomSystem`;
	if (size($tempString))
		sets -rm ControlSet $tempString;
	}

//getting $allSetMembers after preRebuildScript, as it may rename controllers
string $allSet="AllSet";
string $allSetMembers[]=`sets -q $allSet`;
string $controlSet="ControlSet";
string $controlSetMembers[]=`sets -q $controlSet`;

//filter-out any accedentally added components from AllSet
for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*[.]*"`)
		{
		sets -rm $allSet $allSetMembers[$i];
		$allSetMembers=`stringArrayRemove {$allSetMembers[$i]} $allSetMembers`;
		}

if (`objExists FaceAllSet`)
	if (`sets -im "Sets" FaceAllSet`)
		sets -rm "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	if (`sets -im "Sets" FaceControlSet`)
		sets -rm "Sets" FaceControlSet;

//Pre Rebuild : $keepBuildPose
if (!$keepAll && !$keepBuildPose)
	if (`objExists FitSkeleton`)
		if (`attributeExists run FitSkeleton`)
			setAttr -type "string" FitSkeleton.run "";

//Pre Rebuild : udExtraAttr (extra added ctrls. e.g. CustomControllers)
if ($keepAll || $keepBuildPose)
	if (`attributeExists udExtraAttr buildPose`)
		if (`getAttr buildPose.udExtraAttr`!="")
			{
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists udExtraAttr buildPose`)"
					+"	addAttr -ln udExtraAttr -dt \"string\" buildPose;";
			$setAttrCmds[size($setAttrCmds)]="setAttr -type \"string\" buildPose.udExtraAttr \""+`getAttr buildPose.udExtraAttr`+"\";";
			}

//Pre Rebuild : Bind Pose is not same as Build Pose
if ($asConfirmIfNotInBuildPose==2)
	$restorePoseCmd=`asGetRestorePoseCmd`;

//Pre Rebuild parentConstraints
string $constraintParent,$constraintChild;
string $parentConstraints[]=`ls -type parentConstraint`;
string $parentConstraintParents[],$parentConstraintChildren[];
for ($i=$y=0;$i<size($parentConstraints);$i++)
	{
	if (!$keepAll && !$keepParentConstraints)
		continue;
	if (`sets -im $allSet $parentConstraints[$i]` || `gmatch $parentConstraints[$i] "*Box_*"`)
		continue;
	if ($parentConstraints[$i]=="AimEyeFollow_M_parentConstraint1")//connected multiTarget constraint
		continue;

	$tempString=`listConnections ($parentConstraints[$i]+".target[0].targetJointOrient")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintParent=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	$tempString=`listConnections ($parentConstraints[$i]+".constraintTranslate.constraintTranslateX")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintChild=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	if (!`objExists $constraintParent` || !`objExists $constraintChild`)
		continue;
	if (!`sets -im $allSet $constraintParent` && !`sets -im $allSet $constraintChild`)
		continue;

	$parentConstraintParents[$y]=$constraintParent;
	$parentConstraintChildren[$y]=$constraintChild;
	delete $parentConstraints[$i];
	$y++;
	}

//Pre Rebuild userDefinedAttr
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepUserAttrs)
		continue;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"` || $at=="message")
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		//v5.792 replaced "IKLeg_R.roll" with rollStartAngle & rollEndAngle
		if ($ln=="rollAngle" && `attributeExists swivel $allSetMembers[$i]`)
			continue;
		//toe attribute no longer used
		if ($ln=="toe")
			if (size(`listConnections ($allSetMembers[$i]+"."+$ln)`)==0)
				continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$enumName="";
		if ($at=="enum")
			$enumName="-en \""+`addAttr -q -en ($allSetMembers[$i]+"."+$userAttrs[$y])`+"\"";
		$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$enumName+" "+$allSetMembers[$i]+";";
		//Non-keyable
		if ($k=="0" && $cb)
			$addAttrCmds[size($addAttrCmds)]="if (`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	setAttr -cb 1 "+$allSetMembers[$i]+"."+$userAttrs[$y]+";";
		}
	}

//Pre Rebuild : Main attrs e.g. Main.jointVis
if (`objExists Main`)
	{
	$tempString=`listAttr -cb Main`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$dv=`getAttr ("Main."+$tempString[$i])`;
		$setAttrCmds[size($setAttrCmds)]="if (`attributeExists "+$tempString[$i]+" Main`)"
					+"	setAttr Main."+$tempString[$i]+" "+$dv+";";
		}
	}

//Pre Rebuild Geometry-Parenting (anything parented to "Geometry", will always be preserved)
if (`objExists Group|Geometry`)
	{
	$children=`listRelatives -c Geometry`;
	$cmds[size($cmds)]="parent Geometry Group";
	}

//Pre Rebuild Parenting
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepParenting)
		continue;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	if (`objectType $allSetMembers[$i]`=="objectSet")
		continue;

	//non AS onto AS
	$children=`listRelatives -c $allSetMembers[$i]`;
	for ($y=0;$y<size($children);$y++)
		{
		$tempString=`ls $children[$y]`;
		if (size($tempString)>1)
			error ("ObjectName not unique "+$children[$y]+"\n");
		$childIsMember=0;
		for ($z=0;$z<size($allSetMembers);$z++)
			if ($children[$y]==$allSetMembers[$z])
				$childIsMember=1;
		if ($children[$y]=="Geometry")
			continue;
		if (!$childIsMember)
			{
			$tempString=`ls -s $children[$y]`;
			if ($tempString[0]!="")
				$cmds[size($cmds)]="parent -r -s "+$children[$y]+" "+$allSetMembers[$i]+";";
			else if (`getAttr ($children[$y]+".inheritsTransform")` && !`gmatch $children[$y] "*_?_[0-9][0-9]"`)
				$cmds[size($cmds)]="parent "+$children[$y]+" "+$allSetMembers[$i]+";";
			else
				$cmds[size($cmds)]="parent -r "+$children[$y]+" "+$allSetMembers[$i]+";";
			}
		}

	// AS onto non AS
	$tempString=`listRelatives -p $allSetMembers[$i]`;
	if ($tempString[0]!="")
		if (!`sets -im AllSet $tempString[0]`)
			$cmds[size($cmds)]="parent "+$allSetMembers[$i]+" "+$tempString[0]+";";
	}

//Pre Rebuild $keepSkinning
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepSkinning)
		continue;

	//Incoming connections
	$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]` && !`gmatch $connections[$y+1] "*[.]angle*"`)
			continue;
		if ($connections[$y+1]=="Group.message")
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver" || $objectType== "displayLayerManager")
			continue;
		if ($connections[$y+1]=="time1.outTime")
			continue;
		if (`gmatch $connections[$y] "*FKAimAt*_aimConstraint*"`)
			continue;
		if (`attributeExists drivingSystemOut $connectionsObj[$y+1]`)//drivingSystem SDK`s to be connected elsewhere
			continue;
		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y+1];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y];
		}

	//Outgoing connections
	$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			if ($connectionsObj[$y]!="Main.ctrlCurveVis" && $connectionsObj[$y]!="Main.ctrlMeshVis")//exception for "ctrlCurveVis" as this is added when running ControlMesh
				continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="materialInfo" || $objectType=="partition")
			continue;
		//changed to allow user-defined selection-set to persist
//		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
		if ($objectType=="objectSet")
			if ($connectionsObj[$y+1]=="AllSet" || $connectionsObj[$y+1]=="ControlSet" || $connectionsObj[$y+1]=="DeformSet")
				continue;
		if ($objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
			continue;
		if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
			if ($objectType!="objectSet")
				continue;
		if ($objectType=="skinCluster")
			$skinClusters[size($skinClusters)]=$connectionsObj[$y+1];
		if ($objectType=="jointCluster")
			$jointClusters[size($jointClusters)]=$connectionsObj[$y+1];
		//v 5.732 changed DrivingSystems to use `asEnsureOutputBlendWeighted`, so we do not want re-build from old versions to restore `direct to sdk` connections
		if (`objectType $connections[$y]`!="blendWeighted" && `gmatch $connections[$y+1] "SDK*"` && $objectType=="transform")
			{
			print ("DrivingSystem from rig version older then 5.732 found, skipping connection:"+$connections[$y]+" -> "+$connections[$y+1]+"\n");
			continue;
			}

		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y+1];
		}
	}

//Pre Rebuild $keepSkinning (joints added to deformSet)
clear $tempString;
if (`objExists DeformSet`)
	$tempString=`sets -q DeformSet`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!$keepAll && !$keepSkinning)
		continue;

	if (!`sets -im $allSet $tempString[$i]`)
		$cmds[size($cmds)]="sets -add DeformSet "+$tempString[$i];
	}

//Pre Rebuild $transformLimits
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepLimits)
		continue;

	if (`objectType $allSetMembers[$i]`=="joint" || `sets -im ControlSet $allSetMembers[$i]`)
		{
		$tr="r";
		for ($y=0;$y<2;$y++)
			{
			if ($y==1)
				continue;
			for ($y=0;$y<size($trs);$y++)
				for ($z=0;$z<size($xyz);$z++)
					{
					$e=`eval ("transformLimits -q -e"+$trs[$y]+$xyz[$z]+" "+$allSetMembers[$i])`;
					if ($e[0] || $e[1])
						{
						$vals=`eval ("transformLimits -q -"+$trs[$y]+$xyz[$z]+" "+$allSetMembers[$i])`;
						$cmds[size($cmds)]="transformLimits -"+$trs[$y]+$xyz[$z]+" "+$vals[0]+" "+$vals[1]+" -e"+$trs[$y]+$xyz[$z]+" "+$e[0]+" "+$e[1]+" "+$allSetMembers[$i]+";";
						}
					}
			}
		}
	}

//Pre Rebuild Lock and Hide
for ($i=0;$i<size($controlSetMembers);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			if (!$keepAll && !$keepLockHide)
				continue;
			if (`getAttr -l ($controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z])`)
				$cmds[size($cmds)]="setAttr -l 1 "+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+";";
			if (!`getAttr -k ($controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z])`)
				$cmds[size($cmds)]="setAttr -k 0 "+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+";";
			if (`getAttr -cb ($controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z])`)
				$cmds[size($cmds)]="setAttr -cb 1 "+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+";";
			}

//Pre Rebuild CurveShapes
string $curveShape;
int $spans,$degree,$numCVs;
float $cvPos[3];
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!$keepAll && !$keepCurveShapes)
		continue;
	if ($controlSetMembers[$i]=="RootX_M" && $version<5.9419)
		continue;//New RootX_M icon in 5.9419 (now single shape node)
	$tempString=`listRelatives -p $controlSetMembers[$i]`;
	if ($tempString[0]=="DrivingSystem" && $version<6.0524)
		continue;//v 6.0524 fixed the non-default scale value of DrivingSystems, so do not restore curves as they would then look wrong
	$tempString=`listRelatives -s $controlSetMembers[$i]`;
	for ($z=0;$z<size($tempString);$z++)
		{
		$curveShape=$tempString[$z];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
			$shapeCmds[size($shapeCmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
			}
		//color
		$overrideRGBColors=0;
		if (`attributeExists overrideRGBColors $curveShape`)
			$overrideRGBColors=`getAttr ($curveShape+".overrideRGBColors")`;
		if ($overrideRGBColors)
			{
			$shapeCmds[size($shapeCmds)]="setAttr "+$curveShape+".overrideRGBColors "+`getAttr ($curveShape+".overrideRGBColors")`+";";
			$shapeCmds[size($shapeCmds)]="setAttr "+$curveShape+".overrideColorR "+`getAttr ($curveShape+".overrideColorR")`+";";
			$shapeCmds[size($shapeCmds)]="setAttr "+$curveShape+".overrideColorG "+`getAttr ($curveShape+".overrideColorG")`+";";
			$shapeCmds[size($shapeCmds)]="setAttr "+$curveShape+".overrideColorB "+`getAttr ($curveShape+".overrideColorB")`+";";
			}
		else
			$shapeCmds[size($shapeCmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($curveShape+".overrideColor")`+";";
		}
	}

//Pre Rebuild Disable expressions to avoid warnings
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im $allSet $tempString[$i]`)
		setAttr ($tempString[$i]+".nodeState") 1;

//Rebuild
$allSetMembers[size($allSetMembers)]="Group";
$allSetMembers[size($allSetMembers)]="Sets";
$allSetMembers[size($allSetMembers)]="AllSet";
$allSetMembers[size($allSetMembers)]="ControlSet";
$allSetMembers[size($allSetMembers)]="DeformSet";

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
	else
		$allSetMembers[$i]="";

//unprefix CylShapes in order to preserve these
$tempString=`ls -type nurbsSurface "*_CylShape*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		rename $tempString[$i] `substitute "prefix_" $tempString[$i] ""`;

//unprefix Added Shapes in order to preserve these (they might have `inherited the prefixing from parent transform)
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`objExists ("prefix_"+$controlSetMembers[$i])`)
		continue;
	$tempString=`listRelatives -s ("prefix_"+$controlSetMembers[$i])`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "prefix_*"`)
			if (!`sets -im prefix_AllSet $tempString[$y]`)
				rename $tempString[$y] `substitute "prefix_" $tempString[$y] ""`;
	}
//not sure what causes extra RootX_MShape to occur, but here removing them
$tempString=`ls -type nurbsCurve "*RootX_MShape*"`;
for ($y=0;$y<size($tempString);$y++)
	if (!`sets -im prefix_AllSet $tempString[$y]`)
		delete $tempString[$y];

progressBar -e -ep $gMainProgressBar;


$asRebuilding=1;
evalDeferred ("$asRebuilding=0;");
asBuildAdvancedSkeleton;
//$asRebuilding=0;//move to above as a deferred, as rebuild can fail, and be undone, so avoid stuck with $asRebuilding=1


//redo parentConstraints
for ($i=0;$i<size($parentConstraintParents);$i++)
	if (`objExists $parentConstraintParents[$i]` && `objExists $parentConstraintChildren[$i]`)
		parentConstraint -mo $parentConstraintParents[$i] $parentConstraintChildren[$i];


//Post Rebuild
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($cmd in $setAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($i=0;$i<size($connectCmds);$i++)
	{
	$alreadyConnected=0;
	if (`objExists $connectCmdsSource[$i]` && `objExists $connectCmdsDest[$i]`)
		if (`isConnected -iuc $connectCmdsSource[$i] $connectCmdsDest[$i]`)
			$alreadyConnected=1;
	if (!$alreadyConnected)
		if (catchQuiet (`eval ($connectCmds[$i])`)) warning ("Failed: "+$connectCmds[$i]+"\n");
	}

for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//Geometry reparented from "prefix_Group" to "Group", (since inherit Xform is Off, in a Zup scene, this will rotate)
if ($upAxisDirection=="z" && `objExists Geometry`)
	catchQuiet (`setAttr Geometry.rx 0`);

//Post Rebuild Remove attributes that were restored due to increased number of IK controls
$checkAttrs={"ikCvVis","stretchy","follow","volume"};
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`gmatch $controlSetMembers[$i] "IK*[0-9]*"`)
		continue;
	for ($y=0;$y<size($checkAttrs);$y++)
		if (`attributeExists $checkAttrs[$y] $controlSetMembers[$i]`)
			{
			$tempString=`listConnections -s 0 -d 1 ($controlSetMembers[$i]+"."+$checkAttrs[$y])`;
			if (!size($tempString))
				deleteAttr ($controlSetMembers[$i]+"."+$checkAttrs[$y]);
			}
	}

//Post Rebuild Control orient
if ($keepControlOrient || $keepAll)
	{
	createNode -n asSetControlOrientBatchMode transform;
	asSetControlOrient;
	delete asSetControlOrientBatchMode;
	}

//Post Rebuild $shapeCmds
for ($cmd in $shapeCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//Post Rebuild CurveShapes, that have non-matching spans or degree or form
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`objExists $controlSetMembers[$i]`)
		continue;
	if ($controlSetMembers[$i]=="RootX_M" && $version<5.9419)
		continue;//New RootX_M icon in 5.9419 (now single shape node)
	clear $tempString;
	if (`objExists ("prefix_"+$controlSetMembers[$i])`)
		$tempString=`listRelatives -s ("prefix_"+$controlSetMembers[$i])`;
	for ($z=0;$z<size($tempString);$z++)
		{
		$tempString2=`listRelatives -p $tempString[$z]`;
		$control=`substitute "prefix_" $tempString2[0] ""`;
		$curveShape=`substitute "prefix_" $tempString[$z] ""`;
		if (!`objExists $control`)
			continue;

		if (!`objExists $curveShape`)//multi curve shapes
			{
			sets -rm prefix_AllSet $tempString[$z];
			parent -r -s $tempString[$z] $control;
			rename $tempString[$z] $curveShape;
			continue;
			}

		if ((`getAttr ($curveShape+".spans")`==`getAttr ("prefix_"+$curveShape+".spans")`)
			&& (`getAttr ($curveShape+".degree")`==`getAttr ("prefix_"+$curveShape+".degree")`)
			&& (`getAttr ($curveShape+".form")`==`getAttr ("prefix_"+$curveShape+".form")`))
			continue;
		connectAttr -f ("prefix_"+$curveShape+".local") ($curveShape+".create");

		if (!`objExists tempCurveForRefresh`)
			{
			curve -n tempCurveForRefresh -d 1 -p 0 0 0 -k 0;
			}
		connectAttr ($curveShape+".local") tempCurveForRefresh.create;
		refresh;
		if (`objExists tempCurveForRefresh`)
			delete tempCurveForRefresh;
		}
	}

//reset bindPose
string $bindPose;
string $newSetMembers[]=`sets -q $allSet`;
for ($i=0;$i<size($newSetMembers);$i++)
	{
	if (`objectType $newSetMembers[$i]`=="joint")
		{
		select $newSetMembers[$i];
		$tempString=`dagPose -q -bp`;
		$bindPose=$tempString[0];
		if (`objExists $bindPose`)
			{
			$tempString=`listConnections ($newSetMembers[$i]+".bindPose")`;
			if ($tempString[0]==$bindPose)
				{
				select -add $bindPose;
				dagPose -rs;
				}
			}
		}
	}

if ($asConfirmIfNotInBuildPose==2) //Bind Pose is not same as Build Pose
	{
	tokenize $restorePoseCmd ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		catchQuiet (`eval($tempString[$i])`);
	}

for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*CurveInfo*"`)
		if (`objExists $allSetMembers[$i]`)
			{
//			delete $allSetMembers[$i];//some Maya version throw warning
			select $allSetMembers[$i];
			delete;
			}

if (`objExists prefix_Group`) delete prefix_Group;
if (`objExists prefix_volume1OverSpine_M`) delete prefix_volume1OverSpine_M;
refresh;
for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		catchQuiet (`delete $allSetMembers[$i]`);

$skinClusters=`stringArrayRemoveDuplicates $skinClusters`;
$jointClusters=`stringArrayRemoveDuplicates $jointClusters`;
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
for ($i=0;$i<size($jointClusters);$i++)
	freezeJointCluster $jointClusters[$i];

if (`objExists FaceAllSet`)
	sets -add "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	sets -add "Sets" FaceControlSet;

//if ($runCmd!="")
//	evalEcho $runCmd;

//Post Rebuild : CustomControllers to be ControlSet-members
if (`objExists CustomSystem`)
	{
	$tempString=`listRelatives -type nurbsCurve -type nurbsSurface -ad CustomSystem`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listRelatives -p $tempString[$i]`;
		sets -add ControlSet $tempString2[0];
		}
	}

//Post Rebuild : special case, Body ReBuilt from non-OPM to OPM and has NonOPM FaceSetup
if (`attributeExists useOffsetParentMatrix FitSkeleton`)
	if (`getAttr FitSkeleton.useOffsetParentMatrix`)
		if (`objExists FaceMotionSystem_pointConstraint1` && `objExists MainAndHeadScaleMultiplyDivide`)
			{
			print "// detected BodyRig rebuilt from Non-OPM to OPM, decomposing HeadScale for FaceSetup Scale attachment.\n";
			createNode -n HeadScaleDM decomposeMatrix;
			$tempString=`listConnections -s 1 -d 0 MainAndHeadScaleMultiplyDivide.input2`;
			$tempString=`listConnections -s 1 -d 0 -p 1 ($tempString[0]+".offsetParentMatrix")`;
			connectAttr $tempString[0] HeadScaleDM.inputMatrix;
			connectAttr -f HeadScaleDM.outputScale MainAndHeadScaleMultiplyDivide.input2;
			}

//check for leftover attributes, that could be caused by removed FitAttributes
$controlSetMembers=`sets -q ControlSet`;
if ($removeUnusedAttributes)
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		if ($controlSetMembers[$i]=="Main")
			continue;
		$userAttrs=`listAttr -ud $controlSetMembers[$i]`;
		for ($y=0;$y<size($userAttrs);$y++)
			{
			if (`getAttr -l ($controlSetMembers[$i]+"."+$userAttrs[$y])`)
				continue;
			if ($userAttrs[$y]=="ikLocal" || $userAttrs[$y]=="clusterControl" || $userAttrs[$y]=="skinControl"
			 || $userAttrs[$y]=="softModControl" || $userAttrs[$y]=="SquashControl" || $userAttrs[$y]=="localOrient" || $userAttrs[$y]=="parent"
			 || $userAttrs[$y]=="optimizedDS"
			 || $userAttrs[$y]=="primaryAxis" || $userAttrs[$y]=="secondaryAxis" || $userAttrs[$y]=="worldorient" || $userAttrs[$y]=="worldmatch"
			 || $userAttrs[$y]=="curveUnafeccted" || $userAttrs[$y]=="mirror" || $userAttrs[$y]=="mirroredBehaviour" || $userAttrs[$y]=="mirroredTranslate"
			 || $userAttrs[$y]=="customAxis")
				continue;
			$tempString=`listConnections -s 1 -d 1 ($controlSetMembers[$i]+"."+$userAttrs[$y])`;
			if (!size($tempString))
				{
				warning ("Found un-used attribute:\""+$controlSetMembers[$i]+"."+$userAttrs[$y]+"\", now removing this.");
				deleteAttr ($controlSetMembers[$i]+"."+$userAttrs[$y]);
				}
			}
		}

eval ("dgdirty -a");
select -cl;
print "// ReBuild Complete\n";
}

global proc asBuildAdvancedSkeleton ()
{
global int $asRebuilding;
global string $gSelect;
float $scale,$sideTreshold;
float $tempFloat[],$firstJointPos[];
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeletonFiles/div/asIcons.ma";
string $confirmResult,$oldName,$newName,$topNode;
string $selJoints[]=`ls -sl -type joint`;
string $fitJoints[],$tempString[];

if (`objExists FitSkeleton`)
	$topNode="FitSkeleton";
else if (size($selJoints))
	$topNode=$selJoints[0];
else
	error "No FitSkeleton found, and no joints selected, unable to proceed.";

//underscore check
$fitJoints=`listRelatives -ad -type joint $topNode`;

for ($i=0;$i<size($fitJoints);$i++)
	if (`gmatch $fitJoints[$i] "*_*"` && !`gmatch $fitJoints[$i] "*_NonSymmetry"`)
		{
		select $fitJoints[$i];
		refresh;
		if (`confirmDialog -title "Confirm" -message 
			("Underscore found in joint-name:\n\n"
			+$fitJoints[$i]+"\n\n"
			+"Using underscore in joint-names causes compatability issues with tools such as\n"
			+"SelectorDesigner, CorrectiveShaper & DrivingSystems\n."
			+"It is possible to continue,\n"
			+"But recommodation is to Cancel, and remove the underscore.")
		    -button "Continue Anyway" -button "Cancel" -defaultButton "Cancel"
		    -cancelButton "Cancel"`!="Continue Anyway")
			return;
		break;//only popup on first occurance
		}

//FitSkeleton from basic joints
if (!`objExists FitSkeleton` && size($selJoints))
	{
	asCreateFitSkeleton;
	parent $selJoints[0] FitSkeleton;
//	$fitJoints=`listRelatives -c -type joint`;
	}

$scale=`asGetScale`;
$sideTreshold=0.01*$scale;

//preBuild check
if (!`objExists FitSkeleton`)
	error "FitSkeleton not found. You must import a FitSkeleton, or select a joint-chain.\n";
if (!`file -q -ex $iconsFile`)
	error ("File not found:"+$iconsFile);
if (!$asRebuilding)
	if (`objExists "Group"`)
		error "AdvancedSkeleton already exists, use ReBuild instead";
$tempString=`listRelatives -c -type joint FitSkeleton`;
if ($tempString[0]=="")
	{
	asFitModeManualUpdate;//some fitJoints could have `generated xforms`, then this will remove them.
	$tempString=`listRelatives -c -type joint FitSkeleton`;
	if ($tempString[0]=="")
		error "FitSkeleton has no joints parented to it";
	}
$firstJointPos=`xform -q -ws -t $tempString[0]`;
if ($tempString[0]=="Root" && ($firstJointPos[0]>$sideTreshold || $firstJointPos[0]<(-1*$sideTreshold)))
	{//Existing Root but not centered, gets renamed, so new centered root gets generated
	rename Root RootSide;
	$tempString=`listRelatives -c -type joint FitSkeleton`;
	}
if ($tempString[0]!="Root")
	{
	if (`objExists "Root"`)
		error "The top-level joint must be named \"Root\", but another object in this scene is already called Root";
	if ($firstJointPos[0]<$sideTreshold && $firstJointPos[0]>(-1*$sideTreshold))
		rename $tempString[0] Root;
	else
		{
		select FitSkeleton;
		joint -n Root;
		xform -ws -t 0 $firstJointPos[1] $firstJointPos[2] Root;
		parent $tempString[0];
		}
	}

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;

catchQuiet (`editDisplayLayerGlobals -useCurrent 0`);

createNode -n asFitModeManualUpdateFromBuild transform;
asFitModeManualUpdate; //Ensure joint rotations & jointOrientations & uniqueNames
asOffFitMode;

//_NonSymmetry
$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (`gmatch $fitJoints[$i] "*_NonSymmetry"`)
		continue;
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	for ($y=0;$y<size($tempString);$y++)
	if (`gmatch $tempString[$y] "*_NonSymmetry"`)
		{
		if (!`attributeExists previousParent $tempString[$y]`)
			addAttr -ln previousParent -dt "string" $tempString[$y];
		setAttr -type "string" ($tempString[$y]+".previousParent") $fitJoints[$i];
		if (!`objExists NonSymmetryFitJoints`)
			createNode -n NonSymmetryFitJoints transform;
		setAttr NonSymmetryFitJoints.v 0;
		parent $tempString[$y] NonSymmetryFitJoints;
		}
	}

$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
//Ensure not starting on Right side
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempFloat=`xform -q -ws -t $fitJoints[$i]`;
	if ($tempFloat[0]>$sideTreshold)
		{
		$tempString=`listRelatives -type joint -p $fitJoints[$i]`;
		if ($tempString[0]!="")
			{
			$tempFloat=`xform -q -ws -t $tempString[0]`;
			if ($tempFloat[0]<(-1*$sideTreshold))
				break;//ok to be on Left side, if parent is on right (X-axis crossing now possible also with Mirrored limbs)
			}
		$ancestorNoMiror=0;
		$tempString=`ls -l $fitJoints[$i]`;
		tokenize $tempString[0] "|" $tempString;
		for ($y=0;$y<size($tempString);$y++)
		for ($y=0;$y<size($tempString);$y++)
			if (`attributeExists noMirror $tempString[$y]`)
				if (`getAttr ($tempString[$y]+".noMirror")`)
					$ancestorNoMiror=1;

		if (!$ancestorNoMiror)
			error ("\""+$fitJoints[$i]+"\" is on the Left side, FitSkeleton side-joints must start on the Right side. (or have \"noMirror\" attribute added)");
		}
	}

asEnsureAllFitJointAttrs;

string $rootIKInfo[]=`asFitJointIKInfo Root`;
string $nonCenteredSpineJoints="";
if ($rootIKInfo[0]=="Spine")
	{
	string $rootIKJoints[]=`asGetIKJoints $rootIKInfo[1] $rootIKInfo[3]`;
	for ($i=0;$i<size($rootIKJoints);$i++)
		{
		float $rootIKJointPos[]=`xform -q -ws -t $rootIKJoints[$i]`;
		if ($rootIKJointPos[0]>$sideTreshold || $rootIKJointPos[0]<($sideTreshold*-1))
			$nonCenteredSpineJoints+="\""+$rootIKJoints[$i]+"\" ";
		}
	if ($nonCenteredSpineJoints!="")
		error ("These Spine joints are not in the center: "+$nonCenteredSpineJoints);
	}

//Pre rebuild Z-up
string $upAxisDirection=`upAxis -q -ax`;
if ($upAxisDirection=="z")
	asSceneUpAxisFlip FitSkeleton y;

setToolTo $gSelect;
asSetFixedWrapOptions;
int $opm=`asGetOpm`;
int $numLetters,$centerBtwFeet,$inbetweenJoints,$reachedQtoes,$hasChildWithToesLabel,$stiffCtrl1Nr,$stiffCtrl2Nr,$stiffLocNr,$closestIkCtrlNr,$closestIkCtrlNr1,$closestIkCtrlNr2,$ikControlNr,$numChar,$segmentScaleCompensate;
int $numMainExtras,$worldOrientUp,$sideFactor,$ancestorNoMiror,$numNonLab,$noCtrl,$numCVs,$plugNr;
int $fitJointTwistJoints[],$fitJointUpTwistJoints[],$fitJointDualTwistJoints[],$fitJointBendyJoints[],$fitJointUpBendyJoints[],$fitJointBend[],$fitJointInbetweenJoints[],$fitJointUnTwister[],$fitJointRotOrder[];
int $fitJointIsEndJoint[],$ikLocal[],$ikLocalType[],$fitJointGlobal[],$fitJointsWheel[],$fitJointsRollingBall[],$fitJointUserSegScaleComp[],$fitJointSegScaleComp[],$fitJointFirstAfterIK[],$fitJointNonDef[];
int $fitJointsAim[],$fitJointNoMirrorCode[],$fitJointNoFlip[],$fitJointNoControl[],$fitJointNoSkin[],$fitJointGlobalTranslate[],$fitJointControl[],$fitJointChildOfPart[],$fitJointsFollowPivot[];
int $isIKStart[],$isIKEnd[],$isIKBelowIKEnd[],$fitJointIKNumCtrls[],$fitJointIKNumCtrlsFakeMid[],$fitJointPartJoints[];
int $fitJointLockTx[],$fitJointLockTy[],$fitJointLockTz[],$fitJointLockRx[],$fitJointLockRy[],$fitJointLockRz[],$fitJointLockSx[],$fitJointLockSy[],$fitJointLockSz[],$fitJointsAimAxis[],$fitJointsAimUpAxis[];
float $pos[3],$pos2[3],$rot[3],$sca[3],$parentPos[3],$parentRot[3],$temp[3],$temp2[3],$temp3[3],$aimV[3],$jo[3],$pa[3];
float $footRotOut[],$ikLenght[],$fitJointGlobalValue[],$m[];
float $dist,$minDist,$minDist1,$minDist2,$defaultDistance,$posFactor,$invPosFactor,$weight,$fat,$fatFront,$fatWidth,$lockCenterTolerance,$height,$lenght,$width,$maxFitJoint,$minFitJoint,$iconScaleFactor,$twistDistance,$w,
	$aimX,$aimY,$aimZ,$xUp,$yUp,$zUp,$xOff,$yOff,$zOff,$xWorldUp,$yWorldUp,$zWorldUp,$c,$d,$twistAmount,$inbetweenWeight;
float $defaultAngleDirection,$defaultAngle,$defaultUnstretchedLenght,$defaultOffsetAngle,$yy,$zz,$scalerWeight,$parameter,$hf,$diameter,$scaleFactor;
float $udMax=10;
$scale=`asGetScale`;
string $side,$childSide,$parentSide,$parent,$joint,$multipleDivide,$childLabel,$ankle,$heel,$toes,$toesEnd,$bigToe,$pinkyToe,$scapula,$label,$offsetParent,$curveGuide,$ctrl,$ikParentConstraintTo,$worldUpObject,$inbetweenJoint;
string $startJoint,$endJoint,$middleJoint,$IKEndJoint,$blendWeighted,$newSDK,$ds,$dsObjName,$dsSide,$aimAtSide,$aimUpSide,$worldUpType,$alignToObject,$bw,$target,$fitJointLeft,$part,$ikParent;
string $postRebuildScript,$crvCmd,$base,$translateSource,$scaleSource,$contraintTo,$contraintTo2,$unTwisterChild,$direction,$volumeOutPlug,$exp,$setAttrCmd;
string $hipSwingerJoint="Spine1";
string $fitJointLabel[],$fitJointSide[],$fitJointParent[],$fitJointParentSide[],$fitJointChild[],$fitJointChildSide[],$fitJointsFollowSide[],$fitJointsIkFollowSide[],$fitJointQtoes[],$deformJoints[];
string $fitJointsFollow[],$fitJointsIkFollow[],$fitJointsAttachTo[],$fitJointsAttachMode[],$fitJointsAimAt[],$fitJointsAimConstraint[],$fitJointsCurveGuide[],$tempString2[],$tempString3[],$FKXJoints[],$sdks[],$sdkPlugs[];
string $asFitJointIKInfo[],$fitJointIK[],$fitJointIKStartJoint[],$fitJointIKMiddleJoint[],$fitJointIKEndJoint[],$fitJointIKSolver[],$IKJoints[],$userAttrs[],$footRollJoints[],$rotPos[],$ikLegs[],$controlSetMembers[];
string $primarySecondary[]={"primary","secondary"};
string $startMidEnd[]={"Start","Mid","End"};
string $XYZ[]={"X","Y","Z"};
string $RGB[]={"R","G","B"};
string $allBefore[]=`ls`;

if (`objExists FitSkeletonVisualizers`)
	{
	delete FitSkeletonVisualizers;
	asUpdateButtonEnables;
	}

if (`attributeExists numMainExtras FitSkeleton`)//pre 5.732
	$numMainExtras=`getAttr FitSkeleton.numMainExtras`;
if (`attributeExists numMainExtras Root`)//post 5.732
	$numMainExtras=`getAttr Root.numMainExtras`;

asImportIconsFile $iconsFile;

//--Sets--//
select -cl;
sets -name ControlSet;
sets -name DeformSet;
sets -name AllSet;
sets -name "Sets";
sets -add "Sets" AllSet ControlSet DeformSet;
sets -add ControlSet `listRelatives -c iconsGroup`;

createNode -n "Group" transform;
asLockAttr "Group" 1 1 1 0;

//--2nd level transforms--//
parent FitSkeleton "Group";
createNode -n MotionSystem -p "Group" transform;
createNode -n DeformationSystem -p "Group" transform;
if (!$asRebuilding || !`objExists Geometry`)
	{
	createNode -n Geometry transform;
	setAttr -l 1 Geometry.inheritsTransform 0;
	parent Geometry "Group";
	//auto-parent geo
	$tempString=`ls -type transform -r 1 "geo"`;
	if (size($tempString))
		parent $tempString Geometry;
	}

//Main
createNode -n MainSystem -p MotionSystem transform;
duplicate -n Main Main_icon;
parent Main MainSystem;

//xform -s (0.285*$scale) (0.285*$scale) (0.285*$scale) Main.cv[0:7];
connectAttr -f FitSkeletonShape.worldSpace[0] MainShape.create;
refresh;
disconnectAttr FitSkeletonShape.worldSpace[0] MainShape.create;

for ($i=1;$i<$numMainExtras+1;$i++)
	{
	if ($i==1)
		duplicate -n ("MainExtra"+$i) Main;
	else
		duplicate -n ("MainExtra"+$i) ("MainExtra"+($i-1));
	xform -s 1.1 1.1 1.1 ("MainExtra"+$i+".cv[0:7]");
	setAttr ("MainExtra"+$i+"Shape.overrideColor") (19+$i);
	}
for ($i=1;$i<$numMainExtras;$i++)
	parent ("MainExtra"+$i) ("MainExtra"+($i+1));
if ($numMainExtras>0)
	parent Main MainExtra1;

createNode -n MainScaleMultiplyDivide multiplyDivide;
connectAttr Main.scale MainScaleMultiplyDivide.input1;
for ($i=1;$i<$numMainExtras+1;$i++)
	{
	createNode -n ("MainScaleMultiplyDivide"+$i) multiplyDivide;
	if ($i==1)
		connectAttr Main.scale ("MainScaleMultiplyDivide"+$i+".input1");
	else
		connectAttr ("MainScaleMultiplyDivide"+($i-1)+".output") ("MainScaleMultiplyDivide"+$i+".input1");
	connectAttr ("MainExtra"+$i+".scale") ("MainScaleMultiplyDivide"+$i+".input2");
	connectAttr -f ("MainScaleMultiplyDivide"+$i+".output") MainScaleMultiplyDivide.input1;
	}

setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v 0;
connectAttr -f MotionSystem.v MainShape.v;
for ($i=1;$i<$numMainExtras+1;$i++)
	connectAttr -f MotionSystem.v ("MainExtra"+$i+"Shape.v");

//--4th level transforms--//
createNode -n FKSystem -p MotionSystem transform;
createNode -n IKSystem -p MotionSystem transform;
createNode -n FKIKSystem -p MotionSystem transform;
createNode -n BendSystem -p MotionSystem transform;
createNode -n AimSystem -p MotionSystem transform;
createNode -n RootSystem -p MotionSystem transform;
createNode -n TwistSystem -p MotionSystem transform;
createNode -n GlobalSystem -p MotionSystem transform;
createNode -n ConstraintSystem -p MotionSystem transform;
createNode -n DynamicSystem -p MotionSystem transform;
createNode -n DrivingSystem -p MotionSystem transform;
setAttr -l 1 BendSystem.inheritsTransform 0;

//--5th level transforms--//
createNode -n IKJoints -p IKSystem transform;
//if ($opm)
//	createNode -n IKMP -p IKSystem transform;
//createNode -n IKJointsOPM -p IKSystem transform;
createNode -n IKHandle -p IKSystem transform;
createNode -n IKPoleVector -p IKSystem transform;
createNode -n IKFollow -p IKSystem transform;
createNode -n IKStatic -p IKSystem transform;
createNode -n IKCurve -p IKSystem transform;
setAttr -l 1 IKCurve.inheritsTransform 0;
createNode -n IKMessure -p IKSystem transform;
createNode -n BendCurve -p BendSystem transform;
createNode -n BendJoints -p BendSystem transform;
createNode -n BendMPX -p BendSystem transform;

//--FollowMain--//
//if (!$opm)
	createNode -n IKHandleFollowMain -p IKHandle transform;
createNode -n RootFollowMain -p RootSystem transform;
createNode -n GlobalFollowMain -p GlobalSystem transform;
$tempString={"RootFollowMain","GlobalFollowMain","IKStatic"};
//if (!$opm)
if (!$opm)
	$tempString[size($tempString)]="IKHandleFollowMain";
for ($i=0;$i<size($tempString);$i++) 
	asParentConstraint Main $tempString[$i] "";

//--ScaleWithMain--//
if ($opm)
	{
	connectAttr MainScaleMultiplyDivide.output IKMessure.s;
	connectAttr MainScaleMultiplyDivide.output IKJoints.s;
	}
else
	{
	connectAttr MainScaleMultiplyDivide.output IKSystem.s;
	connectAttr MainScaleMultiplyDivide.output FKIKSystem.s;
	connectAttr MainScaleMultiplyDivide.output TwistSystem.s;
	connectAttr MainScaleMultiplyDivide.output GlobalSystem.s;
	connectAttr MainScaleMultiplyDivide.output DynamicSystem.s;
	connectAttr MainScaleMultiplyDivide.output DeformationSystem.s;
	connectAttr MainScaleMultiplyDivide.output BendJoints.s;	
	}
connectAttr MainScaleMultiplyDivide.output FKSystem.s;
connectAttr MainScaleMultiplyDivide.output AimSystem.s;
connectAttr MainScaleMultiplyDivide.output RootSystem.s;
connectAttr MainScaleMultiplyDivide.output DrivingSystem.s;

addAttr -k 1 -ln fkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkVis;
connectAttr -f Main.fkVis FKSystem.v;
addAttr -k 1 -ln ikVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.ikVis;
connectAttr -f Main.ikVis "IKSystem.v";
addAttr -k 1 -ln fkIkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkIkVis;
connectAttr -f Main.fkIkVis FKIKSystem.v;
addAttr -k 1 -ln aimVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimVis;
connectAttr -f Main.aimVis AimSystem.v;
addAttr -k 1 -ln aimFKVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimFKVis;
addAttr -k 1 -ln aimLRVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimLRVis;
addAttr -k 1 -ln fingerVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fingerVis;
addAttr -k 1 -ln bendVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.bendVis;
addAttr -k 1 -ln arrowVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.arrowVis;
addAttr -k 1 -ln drvSysVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.drvSysVis;
addAttr -k 1 -ln jointVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.jointVis;

connectAttr -f Main.bendVis BendSystem.v;

if (`objExists jointLayer`)
	delete jointLayer;

//Adding inbetweenJoints to FitSkeleton
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists inbetweenJoints $fitJoints[$i]`)
		continue;
	$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	if ($inbetweenJoints<1)
		continue;
	$rlaChild=`asRlaChild $fitJoints[$i]`;
	if ($rlaChild=="")
		continue;
	select $fitJoints[$i];
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		$inbetweenJoint=$fitJoints[$i]+"Part"+$y;
		joint -n $inbetweenJoint;
		if ($y==1)
			{//re-order so InbetweenJoints are 1st child, for better `asRlaChild` results
			$tempString=`listRelatives -c -type transform $fitJoints[$i]`;
			if (size($tempString)>1)
			reorder -relative ((size($tempString)-1)*-1) $inbetweenJoint;
			}
		setAttr ($inbetweenJoint+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
		$weight=(1.0/($inbetweenJoints+1))*$y;
		$tempString=`pointConstraint -w $weight $rlaChild $inbetweenJoint`;
		pointConstraint -w (1-$weight) $fitJoints[$i] $inbetweenJoint;
		delete $tempString[0];
		addAttr -k 1 -ln tempInbetweener -at bool -dv 1 $inbetweenJoint;
		$noCtrl=1;
//		if (`attributeExists partControllers $fitJoints[$i]`)
//			$noCtrl=!`getAttr ($fitJoints[$i]+".partControllers")`;
//		if ($noCtrl)
//			addAttr -k 1 -ln noControl -at bool -dv 1 $inbetweenJoint;
		$fat=(`getAttr ($fitJoints[$i]+".fat")`*(1-$weight)) + (`getAttr ($rlaChild+".fat")`*$weight);
		$fatFront=(`getAttr ($fitJoints[$i]+".fatFront")`*(1-$weight)) + (`getAttr ($rlaChild+".fatFront")`*$weight);
		$fatWidth=(`getAttr ($fitJoints[$i]+".fatWidth")`*(1-$weight)) + (`getAttr ($rlaChild+".fatWidth")`*$weight);
		addAttr -k 0 -ln fat -at double -dv $fat $inbetweenJoint;
		addAttr -k 0 -ln fatFront -at double -dv $fatFront $inbetweenJoint;
		addAttr -k 0 -ln fatWidth -at double -dv $fatWidth $inbetweenJoint;
		}
	parent $rlaChild $inbetweenJoint;
	}

//Analyze
$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	//Analyze $fitJointLabel
	$fitJointLabel[$i]=`asLabel $fitJoints[$i]`;
	$fitJointPartJoints[$i]=`asGetPartJoints $fitJoints[$i]`;

	//Analyze $fitJointSide, from first parent that is off-to-side
	$fitJointSide[$i]="_M";
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		$pos=`xform -q -ws -t $tempString[$y]`;
		if ($pos[0]>$sideTreshold)
			{
			$fitJointSide[$i]="_L";
			break;
			}
		if ($pos[0]<($sideTreshold*-1))
			{
			$fitJointSide[$i]="_R";
			break;
			}
		}

	//Analyze $fitJointNoMirror & $fitJointNoFlip
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`attributeExists noMirror $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noMirror")`)
				$fitJointNoMirrorCode[$i]=-1;//skips -1 side (left)
		if (`attributeExists noMirrorLeft $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noMirrorLeft")`)
				if ($fitJointNoMirrorCode[$i]==-1)
					$fitJointNoMirrorCode[$i]=1;//skips  1 side (right)
		if (`attributeExists noFlip $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noFlip")`)
				$fitJointNoFlip[$i]=1;
		}

	//Analyze $fitJointNoControl
	if (`attributeExists noControl $fitJoints[$i]`)
		$fitJointNoControl[$i]=`getAttr ($fitJoints[$i]+".noControl")`;

	//Analyze $fitJointControl
	if (`attributeExists control $fitJoints[$i]`)
		$fitJointControl[$i]=`getAttr ($fitJoints[$i]+".control")`;

	//Analyze $fitJointNoSkin
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`attributeExists noSkin $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noSkin")`)
				$fitJointNoSkin[$i]=1;
		}

	//Analyze $fitJointControl
	if (`attributeExists childOfPart $fitJoints[$i]`)
		$fitJointChildOfPart[$i]=`getAttr ($fitJoints[$i]+".childOfPart")`;

	//Analyze $fitJointIsEndJoint
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($tempString[0]=="")
		$fitJointIsEndJoint[$i]=1;
	else
		$fitJointIsEndJoint[$i]=0;

	//Analyze rotateOrder
	$fitJointRotOrder[$i]=`getAttr ($fitJoints[$i]+".rotateOrder")`;

	//Analyze Parent
	$tempString=`listRelatives -p -type joint $fitJoints[$i]`;
	$fitJointParent[$i]=$tempString[0];

	//Analyze ParentSide, from first parent that is off-to-side
	if ($fitJointParent[$i]!="")
		{
		$fitJointParentSide[$i]="_M";
		$tempString=`ls -l $fitJointParent[$i]`;
		tokenize $tempString[0] "|" $tempString;
		for ($y=0;$y<size($tempString);$y++)
			{
			$pos=`xform -q -ws -t $tempString[$y]`;
			if ($pos[0]>$sideTreshold)
				{
				$fitJointParentSide[$i]="_L";
				break;
				}
			if ($pos[0]<($sideTreshold*-1))
				{
				$fitJointParentSide[$i]="_R";
				break;
				}
			}
		}

	//Analyze Child
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	$fitJointChild[$i]=$tempString[0];
	//Prefer X-down child
	if (size($tempString)>1)
		for ($y=0;$y<size($tempString);$y++)
			{
			$temp=`getAttr ($tempString[$y]+".t")`;
			if ($temp[1]>-0.01 && $temp[1]<0.01 && $temp[2]>-0.01 && $temp[2]<0.01)
				{
				$fitJointChild[$i]=$tempString[$y];
				break;
				}
			}

	//Analyze ChildSide
	if ($fitJointChild[$i]!="")
		{
		$fitJointChildSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointChild[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointChildSide[$i]="_M";
		if ($temp[0]>$sideTreshold)
			$fitJointChildSide[$i]="_L";
		}

	//TwistJoints, BendyJoints & inbetweenJoints Require a RlaChild
	if (`asRlaChild $fitJoints[$i]`!="")
		{

		//Analyze TwistJoints
		if (`attributeExists twistJoints $fitJoints[$i]`)
			$fitJointTwistJoints[$i]=`getAttr ($fitJoints[$i]+".twistJoints")`;

		//Analyze BendyJoints
		if (`attributeExists bendyJoints $fitJoints[$i]`)
			$fitJointBendyJoints[$i]=`getAttr ($fitJoints[$i]+".bendyJoints")`;

		//Analyze inbetweenJoints
		if (`attributeExists inbetweenJoints $fitJoints[$i]`)
			$fitJointInbetweenJoints[$i]=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
		if (`attributeExists unTwister $fitJoints[$i]`)
			if ($fitJointInbetweenJoints[$i]>0)
				$fitJointUnTwister[$i]=`getAttr ($fitJoints[$i]+".unTwister")`;

		//Analyze fitJointDualTwistJoints, child has upTwist and not twist, so e.g Elbow. aka: Last TwistJoint can be twisted from End as well.
		if (`attributeExists twistJoints $fitJoints[$i]`)
			if ($fitJointChild[$i]!="")
				if (!`attributeExists twistJoints $fitJointChild[$i]`)
					if (`asRlaChild $fitJointChild[$i]`!="") //not if child is a end-joint as it then has now ctrl to upTwist
						$fitJointDualTwistJoints[$i] =`getAttr ($fitJoints[$i]+".twistJoints")`;
		}

	//Analyze UpTwistJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists twistJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpTwistJoints[$i]=`getAttr ($fitJointParent[$i]+".twistJoints")`;

	//Analyze UpBendyJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists bendyJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpBendyJoints[$i]=`getAttr ($fitJointParent[$i]+".bendyJoints")`;

	//Analyze global
	if (`attributeExists "global" $fitJoints[$i]`)
		{
		$fitJointGlobal[$i]=1;
		$fitJointGlobalValue[$i]=`getAttr ($fitJoints[$i]+".global")`;
		if (`attributeExists "globalTranslate" $fitJoints[$i]`)
			$fitJointGlobalTranslate[$i]=`getAttr ($fitJoints[$i]+".globalTranslate")`;
		}

	//Analyze Aim
	if (`attributeExists aim $fitJoints[$i]`)
		$fitJointsAim[$i]=1;

	//Analyze follow
	if (`attributeExists follow $fitJoints[$i]`)
		{
		$fitJointsFollow[$i]=`getAttr -asString ($fitJoints[$i]+".follow")`;
		$pos=`xform -q -ws -t $fitJointsFollow[$i]`;
		$fitJointsFollowSide[$i]="_M";
		if ($pos[0]>$sideTreshold)
			$fitJointsFollowSide[$i]="_L";
		if ($pos[0]<($sideTreshold*-1))
			$fitJointsFollowSide[$i]="_R";
		if (`attributeExists followPivot $fitJoints[$i]`)
			$fitJointsFollowPivot[$i]=`getAttr ($fitJoints[$i]+".followPivot")`;
		}

	//Analyze ikFollow
	if (`attributeExists ikFollow $fitJoints[$i]`)
		{
		$fitJointsIkFollow[$i]=`getAttr -asString ($fitJoints[$i]+".ikFollow")`;
		$pos=`xform -q -ws -t $fitJointsIkFollow[$i]`;
		$fitJointsIkFollowSide[$i]="_M";
		if ($pos[0]>$sideTreshold)
			$fitJointsIkFollowSide[$i]="_L";
		if ($pos[0]<($sideTreshold*-1))
			$fitJointsIkFollowSide[$i]="_R";
		}

	//Analyze geoAttach
	if (`attributeExists geoAttach $fitJoints[$i]`)
		{
		$fitJointsAttachTo[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttach")`;
		if (`gmatch $fitJointsAttachTo[$i] "*__*"` && !`objExists $fitJointsAttachTo[$i]`)
			{
			$tempString[0]=`substitute "__" $fitJointsAttachTo[$i] ":"`;
			if (`objExists $tempString[0]`)
				$fitJointsAttachTo[$i]=$tempString[0];
			}
		if (`attributeExists geoAttachMode $fitJoints[$i]`)
			$fitJointsAttachMode[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttachMode")`;
		}

	//Analyze aimAt
	if (`attributeExists aimAt $fitJoints[$i]`)
		{
		$fitJointsAimAt[$i]=`getAttr -asString ($fitJoints[$i]+".aimAt")`;
		$fitJointsAimAxis[$i]=`getAttr ($fitJoints[$i]+".aimAxis")`;
		$fitJointsAimUpAxis[$i]=`getAttr ($fitJoints[$i]+".aimUpAxis")`;
		}

	//Analyze aimConstraint
	$tempString=`listConnections -s 1 -d 0 -type aimConstraint $fitJoints[$i]`;
	if ($tempString[0]!="")
		{
		$fitJointsAimConstraint[$i]=$tempString[0];
		$tempString=`listConnections -s 1 -d 0 ($fitJointsAimConstraint[$i]+".target[0].targetParentMatrix")`;
		$fitJointsAimAt[$i]=$tempString[0];
		}

	//Analyze curveGuide
	if (`attributeExists curveGuide $fitJoints[$i]`)
		{
		$fitJointsCurveGuide[$i]=`getAttr -asString ($fitJoints[$i]+".curveGuide")`;
		if (`gmatch $fitJointsCurveGuide[$i] "*__*"` && !`objExists $fitJointsCurveGuide[$i]`)
			{
			$tempString[0]=`substitute "__" $fitJointsCurveGuide[$i] ":"`;
			if (`objExists $tempString[0]`)
				$fitJointsCurveGuide[$i]=$tempString[0];
			}
		}

	//Analyze Wheel
	if (`attributeExists wheel $fitJoints[$i]`)
		$fitJointsWheel[$i]=1;

	//Analyze RollingBall
	if (`attributeExists rollingBall $fitJoints[$i]`)
		$fitJointsRollingBall[$i]=1;

	//Analyze SegScaleComp
	if (`attributeExists segScaleComp $fitJoints[$i]`)
		{
		$fitJointUserSegScaleComp[$i]=1;
		$fitJointSegScaleComp[$i]=`getAttr ($fitJoints[$i]+".segScaleComp")`;
		}

	//Analyze $fitJointHipSwinger
	if (`attributeExists hipSwinger $fitJoints[$i]`)
		{
		if (`nonPartRlaParent $fitJoints[$i]`=="Root")
			$hipSwingerJoint=$fitJoints[$i];
		else
			warning ("hipSwinger label found on: \""+$fitJoints[$i]+"\", but this is not a Child of \"Root\", so this will be skipped.");
		}

	//Analyze IK
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	$fitJointIK[$i]=$asFitJointIKInfo[0];
	$fitJointIKStartJoint[$i]=$asFitJointIKInfo[1];
	$fitJointIKMiddleJoint[$i]=$asFitJointIKInfo[2];
	$fitJointIKEndJoint[$i]=$asFitJointIKInfo[3];
	$fitJointIKSolver[$i]=$asFitJointIKInfo[4];
	if ($asFitJointIKInfo[5]!="")
		{
		$fitJointIKNumCtrls[$i]=$asFitJointIKInfo[5];
		//fake IK-mid ctrl, to control mid locs
		if ($fitJointIKNumCtrls[$i]==2)
			{
			$fitJointIKNumCtrls[$i]=3;
			$fitJointIKNumCtrlsFakeMid[$i]=1;
			}
		}
	if ($fitJointIKStartJoint[$i]==$fitJoints[$i])
		$isIKStart[$i]=1;
	if ($fitJointIKEndJoint[$i]==$fitJoints[$i])
		if (!`gmatch $fitJointLabel[$i] "*Toes*"`)
			$isIKEnd[$i]=1;

	//Not to use UnTwister, if in IK, as the untwisting conflicts
	if ($fitJointIK[$i]!="" && $fitJointUnTwister[$i])
		{
		warning ("Setting "+$fitJoints[$i]+".unTwister to \"0\", since FK-unTwister will not work for joint that is in IK-chain");
		setAttr ($fitJoints[$i]+".unTwister") 0;
		$fitJointUnTwister[$i]=0;
		}

	//Analyze $isIKBelowIKEnd ($toes/qtoes)
	if ($fitJointIK[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointIKStartJoint[$i]`;
		$IKEndJoint=$asFitJointIKInfo[3];
		$tempString=`listRelatives -type joint -ad $fitJoints[$i]`;
		if ($fitJoints[$i]!=$IKEndJoint)
		if (!`stringArrayCount $IKEndJoint $tempString`)
			$isIKBelowIKEnd[$i]=1;
		}

	//Analyze $fitJointQtoes (for IKEndJoint)
	$fitJointQtoes[$i]="";
	if ($isIKEnd[$i])
		{
		$tempString=`listRelatives -type joint -ad $fitJoints[$i]`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*QToes*"`)
				$fitJointQtoes[$i]=$tempString[$y];
			}
		}

	//Analyze Non-deform joints
	if (`gmatch $fitJointLabel[$i] "*Heel*"` || `gmatch $fitJointLabel[$i] "*BigToe*"` || `gmatch $fitJointLabel[$i] "*PinkyToe*"`)
		$fitJointNonDef[$i]=1;

	//Analyze $ikLocal
	if (`attributeExists ikLocal $fitJoints[$i]`)
		{
		$ikLocal[$i]=1;
		//backwards compatible (used to be bool attribute)
		if (`getAttr -type ($fitJoints[$i]+".ikLocal")`=="bool" && $ikLocal[$i]==0)
			$ikLocal[$i]=-1;
		$ikLocalType[$i]=`getAttr ($fitJoints[$i]+".ikLocal")`;
		}

	//Analyze FirstAfterIK
	if ($fitJointParent[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointParent[$i]`;
		if ($asFitJointIKInfo[0]!="" && $fitJointIK[$i]!=$asFitJointIKInfo[0])
			$fitJointFirstAfterIK[$i]=1;
		//hack override to make HipSwinger work in opm even with no IK in spine
//removed in v 6.228, as it makes FK ctrls show when Spine is in IK,(if have tail)
//replace by "//hack to make OPM HipSwinger" further down
/*
		if ($fitJointParent[$i]=="Root")
			{
			$rlaChild=`asRlaChild $fitJointParent[$i]`;
			if ($rlaChild!=$fitJoints[$i])//not for joint in spine
				$fitJointFirstAfterIK[$i]=1;
			}
*/
		}

	//Analyze Lock (if out ouf $lockCenterTolerance)
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	$lockCenterTolerance=0.01*$scale;
	if ($pos[0]<-$lockCenterTolerance || $pos[0]>$lockCenterTolerance)
		{
		if (`getAttr -l ($fitJoints[$i]+".tx")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".ty")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".tz")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".rx")`) $fitJointLockRx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".ry")`) $fitJointLockRy[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".rz")`) $fitJointLockRz[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sx")`) $fitJointLockSx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sy")`) $fitJointLockSy[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sz")`) $fitJointLockSz[$i]=1;
		}
	}

//Analyze $centerBtwFeet
if (`attributeExists centerBtwFeet Root`)
	$centerBtwFeet=`getAttr Root.centerBtwFeet`;

//Analyze $ikLenght
for ($i=0;$i<size($fitJoints);$i++)
	{
	$ikLenght[$i]=0;
	if ($fitJointIK[$i]=="")
		continue;
	$tempString[0]=$fitJointIKEndJoint[$i];
	for ($a=0;$a<99;$a++)
		{
		if ($tempString[0]==$fitJointIKStartJoint[$i])
			break;
//		$ikLenght[$i]+=`getAttr ($tempString[0]+".translate"+$fitJointParentAbsPriAxis[$i])`;
		$pos=`xform -q -ws -t $tempString[0]`;
		$tempString=`listRelatives -p $tempString[0]`;
		$pos2=`xform -q -ws -t $tempString[0]`;
		$ikLenght[$i]+=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		}
	$ikLenght[$i]=abs($ikLenght[$i]);
	}

//height
for ($a=0;$a<3;$a++)
	{
	$maxFitJoint=0;
	$minFitJoint=99;
	if (size($fitJoints)==1)
		$minFitJoint=0;//single joint rig, messures height from Ground
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		if ($pos[$a]>$maxFitJoint)
			$maxFitJoint=$pos[$a];
		if ($pos[$a]<$minFitJoint)
			$minFitJoint=$pos[$a];
		}
	if ($a==0) $width=$maxFitJoint-$minFitJoint;
	if ($a==1) $height=$maxFitJoint-$minFitJoint;
	if ($a==2) $lenght=$maxFitJoint-$minFitJoint;
	}
addAttr -ln height -at double Main;
setAttr -l 1 Main.height $height;
//$iconScaleFactor
$iconScaleFactor=$height;
if ($lenght>$height && $lenght>$width) $iconScaleFactor=$lenght;
if ($width>$height && $width>$lenght) $iconScaleFactor=$width;
$iconScaleFactor=$iconScaleFactor/80.0;


//--Creation--//
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		$pos=`xform -q -ws -t $fitJoints[$i]`;
		$rot=`xform -q -ws -ro $fitJoints[$i]`;
		$joint=$fitJoints[$i]+$side;
		if ($b==-1 && `objExists ($fitJoints[$i]+"_NonSymmetry")`)
			{
			$pos=`xform -q -ws -t ($fitJoints[$i]+"_NonSymmetry")`;
			$pos[0]=$pos[0]*-1;
			$tempString=`mirrorJoint -mirrorYZ -mirrorBehavior ($fitJoints[$i]+"_NonSymmetry")`;
			$rot=`xform -q -ws -ro $tempString[0]`;
			delete $tempString;
			}

		//Creation Deform
		select -cl;
		joint -n $joint;
		if (!$fitJointNoSkin[$i] && $fitJointsAttachTo[$i]=="")
			sets -add DeformSet $joint;
		if ($joint=="Root_M")
			{
			connectAttr -f Main.jointVis ($joint+".v");
			setAttr Root_M.segmentScaleCompensate 0;//for FBX export to work when Main.s != 1
			}
		setAttr ($joint+".rotateOrder") $fitJointRotOrder[$i];
		if ($opm)
			setAttr ($joint+".segmentScaleCompensate") 0;
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $joint;
		xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fat")` -ln fat -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatFront")` -ln fatFront -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatWidth")` -ln fatWidth -at double $joint;

		if ($side=="_L" && $fitJointNoMirrorCode[$i]!=-1)
			{
			$tempString=`mirrorJoint -mirrorYZ -mirrorBehavior $joint`;
			if (`asMayaVersionAsFloat`<2012)
				$tempString[0]=$joint+"1";
			if ($fitJointNoFlip[$i])
				rotate -r -os 0 0  180 $tempString[0];
			$rot=`xform -q -ws -ro $tempString[0]`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
			delete $tempString[0];
			}

		//Creation TwistJoints
		$rlaChild=`asRlaChild $fitJoints[$i]`;
		if ($rlaChild=="")
			continue;
		select ($fitJoints[$i]+$side);
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			joint -n ($fitJoints[$i]+"Part"+$y+$side);
			
			if (!$fitJointNoSkin[$i])
				sets -add DeformSet ($fitJoints[$i]+"Part"+$y+$side);
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
			if ($opm)
				setAttr ($fitJoints[$i]+"Part"+$y+$side+".segmentScaleCompensate") 0;

			$weight=(1.0/($fitJointTwistJoints[$i]+1))*$y;
			$fat=(`getAttr ($fitJoints[$i]+".fat")`*(1-$weight)) + (`getAttr ($rlaChild+".fat")`*$weight);
			$fatFront=(`getAttr ($fitJoints[$i]+".fatFront")`*(1-$weight)) + (`getAttr ($rlaChild+".fatFront")`*$weight);
			$fatWidth=(`getAttr ($fitJoints[$i]+".fatWidth")`*(1-$weight)) + (`getAttr ($rlaChild+".fatWidth")`*$weight);
			addAttr -k 0 -dv $fat -ln fat -at double ($fitJoints[$i]+"Part"+$y+$side);
			addAttr -k 0 -dv $fatFront -ln fatFront -at double ($fitJoints[$i]+"Part"+$y+$side);
			addAttr -k 0 -dv $fatWidth -ln fatWidth -at double ($fitJoints[$i]+"Part"+$y+$side);
			}
		}

//Parent Deform
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;//refresh;//cause crash in maya2023

		$joint=$fitJoints[$i]+$side;
		$parentJoint=$fitJointParent[$i]+$parentSide;
		if ($fitJointParent[$i]=="")
			parent $joint DeformationSystem;
		else
			parent $joint $parentJoint;
		}

//Parent TwistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointTwistJoints[$i]<1)
			continue;refresh;

		$twistDistance=`getAttr ($fitJointChild[$i]+$childSide+".tx")`/($fitJointTwistJoints[$i]+1.0);
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".tx") $twistDistance;
		
		//reParent child to last twist
		if ($fitJointTwistJoints[$i]>0)
			{
			parent -w ($fitJointChild[$i]+$childSide);//parent to world first, as this ensures auto-inverseScale connect
			parent ($fitJointChild[$i]+$childSide) ($fitJoints[$i]+"Part"+($fitJointTwistJoints[$i])+$side);
//			setAttr ($fitJointChild[$i]+$childSide+".segmentScaleCompensate") 0;
			}
		}

//Parent Custom 'ChildOfPart'
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		if ($fitJointChildOfPart[$i]!=0)
			{
			$tempString[0]=$fitJointParent[$i]+"Part"+$fitJointChildOfPart[$i]+$parentSide;
			parent $joint $tempString[0];
			}
		}
//Then update $fitJointParent[] values
for ($i=0;$i<size($fitJoints);$i++)
	if ($fitJointChildOfPart[$i]!=0)
		$fitJointParent[$i]=$fitJointParent[$i]+"Part"+$fitJointChildOfPart[$i];


//Freeze rotation(move to jointOrient)
//in some cases this is not accurate enought, and it will leave small values of jointOrient on axes that should be zero
//updating to `constraint-align` with FitSkeleton (orientConstraint + set jointOrients)
//temporary mirror FitSkeleton, to have Left side joints to `constraint-align` to
$tempString=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	rename $tempString[$i] ($tempString[$i]+"_FitJointRight");
$tempString=`listRelatives -c -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	mirrorJoint -mirrorYZ -mirrorBehavior -searchReplace "_FitJointRight" "_FitJointLeft" $tempString[$i];
$tempString=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*_FitJointRight"`)
		rename $tempString[$i] `substitute "_FitJointRight" $tempString[$i] ""`;
	if (`gmatch $tempString[$i] "*_FitJointLeft"`)
		rename $tempString[$i] `substitute "_FitJointLeft" $tempString[$i] "FitJointLeft"`;
	}

for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		$fitJointLeft=$fitJoints[$i]+"FitJointLeft";
		if (`objExists ($fitJoints[$i]+"_NonSymmetry")`)
			$fitJointLeft=$fitJoints[$i]+"_NonSymmetry";

		if ($fitJointNoFlip[$i])
			if (!(`getAttr -l ($fitJoints[$i]+".rx")` || `getAttr -l ($fitJoints[$i]+".ry")` || `getAttr -l ($fitJoints[$i]+".rz")`))//avoid attempting to orient joints with locked roation
				delete `orientConstraint $joint $fitJointLeft`;

		if ($b==-1)
			$tempString=`orientConstraint $fitJointLeft $joint`;
		else
			$tempString=`orientConstraint $fitJoints[$i] $joint`;
		$jo=`getAttr ($fitJoints[$i]+".jointOrient")`;
		setAttr ($joint+".jointOrient") -type float3 $jo[0] $jo[1] $jo[2];
		delete $tempString[0];

		//still run makeIdentity in firstBranchOffs, to ensure zero rotation
		if (($fitJointParentSide[$i]=="_M" || $fitJointParentSide[$i]=="") && $b==-1)
			{
			$segmentScaleCompensate=`getAttr ($joint+".segmentScaleCompensate")`;//makeIdentity on a joint, turns On segmentScaleCompensate
			makeIdentity -a 1 -r 1 $joint;
			if (!$segmentScaleCompensate)
				setAttr ($joint+".segmentScaleCompensate") 0;
			}
		}

$tempString=`listRelatives -c -type joint FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*FitJointLeft"`)
		delete $tempString[$i];


//Advanced Root
asCreateController "Root" "X" "_M" "Root";
xform -s 0.23 0.23 0.23 RootX_M;
setAttr RootX_M.rotateOrder 3;
makeIdentity -a 1 -s 1 RootX_M;
parent RootOffsetX_M RootFollowMain;
//createNode -n FKFollowRoot -p FKSystem transform;
//parentConstraint RootX_M FKFollowRoot;
//asParentConstraint RootX_M FKFollowRoot "";

//LegLock
//if (!$opm)
	{
	createNode -n LegLockConstrained -p Root transform;
	parent LegLockConstrained RootSystem;
	}

//Creation FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (($fitJointIsEndJoint[$i] || $fitJointChild[$i]=="") && !$fitJointControl[$i])
			continue;
		refresh;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		asCreateController "FK" $fitJoints[$i] $side $fitJoints[$i];

		select ("FK"+$fitJoints[$i]+$side);
		joint -n ("FKX"+$fitJoints[$i]+$side);
		setAttr ("FKX"+$fitJoints[$i]+$side+".drawStyle") 2;
		if ($opm)
			setAttr ("FKX"+$fitJoints[$i]+$side+".segmentScaleCompensate") 0;//this would break the non-uniform scale-comping for non-OPM
		if (!$fitJointInbetweenJoints[$i])
			connectAttr ("FK"+$fitJoints[$i]+$side+".scale") ("FKX"+$fitJoints[$i]+$side+".inverseScale");
		setAttr ("FKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$fitJoints[$i]+$side);

		if ($fitJointInbetweenJoints[$i])
			{
			for ($y=0;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				$w=(10.0/($fitJointInbetweenJoints[$i]+1))*($y+1);
				addAttr -k 1 -ln ("w"+$y) -at double -min 0 -max 10 -dv $w ("FK"+$fitJoints[$i]+$side);
				setAttr -k 0 -cb 1 ("FK"+$fitJoints[$i]+$side+".w"+$y);
				asUnitConvertAndReverse ("FKW"+$y+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side+".w"+$y);
				}

			parent ("FKX"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side);

			//using a InbetweenTarget, since FK controller could be `customOriented`
			createNode -n ("InbetweenTarget"+$fitJoints[$i]+$side) -p ("FK"+$fitJoints[$i]+$side)  transform;

			if ($opm)
				{
//				parent ("FKX"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side);
				connectAttr ("FK"+$fitJoints[$i]+$side+".s") ("FKX"+$fitJoints[$i]+$side+".s");
				for ($y=1;$y<$fitJointInbetweenJoints[$i]+1;$y++)
					connectAttr ("FK"+$fitJoints[$i]+$side+".s") ("FKX"+$fitJoints[$i]+"Part"+$y+$side+".s");

				for ($y=0;$y<$fitJointInbetweenJoints[$i]+1;$y++)
					{
					if ($y==0)
						$joint=$fitJoints[$i];
					else
						$joint=$fitJoints[$i]+"Part"+$y;

					if ($y==0) $base="FKOffset"+$fitJoints[$i]+$side;
					if ($y==1) $base=$fitJoints[$i]+"FKPS"+$side;
					if ($y>1)  $base=$fitJoints[$i]+"Part"+($y-1)+"FKPS"+$side;

					createNode -n ("InbetweenBase"+$joint+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;


					createNode -n ($joint+"InbetweenBM"+$side) blendMatrix;
					connectAttr ("InbetweenBase"+$joint+$side+".worldMatrix") ($joint+"InbetweenBM"+$side+".inputMatrix");
					connectAttr ("InbetweenTarget"+$fitJoints[$i]+$side+".worldMatrix") ($joint+"InbetweenBM"+$side+".target[0].targetMatrix");
					connectAttr ("FKW"+$y+$fitJoints[$i]+$side+"UnitConversion.output") ($joint+"InbetweenBM"+$side+".target[0].weight");
					//now we can remove the un-needed reverse (without it auto-removing the unitConversion node
					if ($opm)
						delete ("FKW"+$y+$fitJoints[$i]+$side+"Reverse");

					createNode -n ($joint+"InbetweenMM"+$side) multMatrix;
					connectAttr ($joint+"InbetweenBM"+$side+".outputMatrix") ($joint+"InbetweenMM"+$side+".matrixIn[0]");
/*
					//The BM is changes with .w attrs, HipSwinger should not
					if ($fitJoints[$i]=="Root" && $y==1)
						{
						createNode -n ($joint+"InbetweenFixedvalueBM"+$side) blendMatrix;
						setAttr ($joint+"InbetweenFixedvalueBM"+$side+".target[0].weight") `getAttr ($joint+"InbetweenBM"+$side+".target[0].weight")`;
						connectAttr ("InbetweenBase"+$joint+$side+".worldMatrix") ($joint+"InbetweenFixedvalueBM"+$side+".inputMatrix");
						connectAttr ("InbetweenTarget"+$fitJoints[$i]+$side+".worldMatrix") ($joint+"InbetweenFixedvalueBM"+$side+".target[0].targetMatrix");
						connectAttr -f ($joint+"InbetweenFixedvalueBM"+$side+".outputMatrix") ($joint+"InbetweenMM"+$side+".matrixIn[0]");
						}
*/
					connectAttr ($base+".worldInverseMatrix") ($joint+"InbetweenMM"+$side+".matrixIn[1]");

					createNode -n ($joint+"InbetweenDM"+$side) decomposeMatrix;
					setAttr ($joint+"InbetweenDM"+$side+".inputRotateOrder") $fitJointRotOrder[$i];
					connectAttr ($joint+"InbetweenMM"+$side+".matrixSum") ($joint+"InbetweenDM"+$side+".inputMatrix");
					createNode -n ($joint+"FKPS"+$side) -p ($joint+$side) transform;
					if ($y==0)
						{
						createNode -n ("FKXMM"+$fitJoints[$i]+$side) multMatrix;
						connectAttr ($fitJoints[$i]+"FKPS"+$side+".worldMatrix") ("FKXMM"+$fitJoints[$i]+$side+".matrixIn[0]");
						connectAttr ("FKOffset"+$fitJoints[$i]+$side+".worldInverseMatrix") ("FKXMM"+$fitJoints[$i]+$side+".matrixIn[1]");
						connectAttr ("FKXMM"+$fitJoints[$i]+$side+".matrixSum") ("FKX"+$fitJoints[$i]+$side+".offsetParentMatrix");
						}

					parent ($joint+"FKPS"+$side) $base;

					connectAttr ($joint+"InbetweenDM"+$side+".outputRotate") ($joint+"FKPS"+$side+".rotate");
					//allow for sx
					if ($y>0)
						{
						createNode -n ($joint+"SXMDL"+$side) multDoubleLinear;
						connectAttr ("FK"+$fitJoints[$i]+$side+".sx") ($joint+"SXMDL"+$side+".input1");
						setAttr ($joint+"SXMDL"+$side+".input2") `getAttr ($joint+"FKPS"+$side+".tx")`;
						connectAttr ($joint+"SXMDL"+$side+".output") ($joint+"FKPS"+$side+".tx");
						}
					}
				//allow for FK controller translate
				createNode -n ($fitJoints[$i]+"FKTransMM"+$side) multMatrix;
				connectAttr ("FK"+$fitJoints[$i]+$side+".worldMatrix") ($fitJoints[$i]+"FKTransMM"+$side+".matrixIn[0]");
				connectAttr ("FKOffset"+$fitJoints[$i]+$side+".worldInverseMatrix") ($fitJoints[$i]+"FKTransMM"+$side+".matrixIn[1]");

				createNode -n ($fitJoints[$i]+"FKTransDM"+$side) decomposeMatrix;
				connectAttr ($fitJoints[$i]+"FKTransMM"+$side+".matrixSum") ($fitJoints[$i]+"FKTransDM"+$side+".inputMatrix");
				connectAttr ($fitJoints[$i]+"FKTransDM"+$side+".outputTranslate") ($fitJoints[$i]+"FKPS"+$side+".t");
				}
			else
				{
//				parent ("FKX"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side);
				createNode -n ("Inbetween"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
				setAttr ("Inbetween"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
				asAlign ("Inbetween"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 1 0 0;
				for ($y=0;$y<$fitJointInbetweenJoints[$i]+1;$y++)
					{
					createNode -n ("Inbetween"+$fitJoints[$i]+"Part"+$y+$side) -p ("Inbetween"+$fitJoints[$i]+$side) transform;
					setAttr ("Inbetween"+$fitJoints[$i]+"Part"+$y+$side+".rotateOrder") $fitJointRotOrder[$i];
					if ($y==0)
						connectAttr ("FK"+$fitJoints[$i]+$side+".t") ("FKX"+$fitJoints[$i]+$side+".t");
					if ($y>0)
						parent ("Inbetween"+$fitJoints[$i]+"Part"+$y+$side) ("Inbetween"+$fitJoints[$i]+"Part"+($y-1)+$side);
					$target=("Inbetween"+$fitJoints[$i]+"Part"+$y+$side);
//					orientConstraint ("FK"+$fitJoints[$i]+$side)  ("FKOffset"+$fitJoints[$i]+$side) $target;
					orientConstraint ("InbetweenTarget"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side) $target;
					setAttr ($target+"_orientConstraint1.interpType") 2;//gives more accurate division by 3rds

					connectAttr ("FKW"+$y+$fitJoints[$i]+$side+"Reverse.outputX") ($target+"_orientConstraint1.FKOffset"+$fitJoints[$i]+$side+"W1");
					connectAttr ("FKW"+$y+$fitJoints[$i]+$side+"UnitConversion.output") ($target+"_orientConstraint1.InbetweenTarget"+$fitJoints[$i]+$side+"W0");

					if ($y==0)
						connectAttr ("Inbetween"+$fitJoints[$i]+"Part"+$y+$side+".r") ("FKX"+$fitJoints[$i]+$side+".r");
					else
						{
						createNode -n ("FKInbetween"+$fitJoints[$i]+"Part"+$y+$side) -p ("FKOffset"+$fitJoints[$i]+"Part"+$y+$side) transform;
						setAttr ("FKInbetween"+$fitJoints[$i]+"Part"+$y+$side+".rotateOrder") $fitJointRotOrder[$i];
						$tempString=`listRelatives -c ("FKOffset"+$fitJoints[$i]+"Part"+$y+$side)`;
						parent $tempString ("FKInbetween"+$fitJoints[$i]+"Part"+$y+$side) ;
						connectAttr ("Inbetween"+$fitJoints[$i]+"Part"+$y+$side+".r") ("FKInbetween"+$fitJoints[$i]+"Part"+$y+$side+".r");
						}
					}
				}
			}

		if($fitJointGlobal[$i])
			{
			addAttr -k 1 -ln "Global"-at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
			createNode -n ("globalUnitConversion"+$fitJoints[$i]+$side) unitConversion;
			setAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
			connectAttr ("FK"+$fitJoints[$i]+$side+".Global") ("globalUnitConversion"+$fitJoints[$i]+$side+".input");

			if ($fitJointGlobalTranslate[$i])
				{
				addAttr -k 1 -ln "GlobalTranslate" -at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
				createNode -n ("globalTranslateUnitConversion"+$fitJoints[$i]+$side) unitConversion;
				setAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
				connectAttr ("FK"+$fitJoints[$i]+$side+".GlobalTranslate") ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".input");
				}

			if ($opm)
				{
				createNode -n ("FKGlobal"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
				$tempString=`listRelatives -c ("FKOffset"+$fitJoints[$i]+$side)`;
				parent $tempString ("FKGlobal"+$fitJoints[$i]+$side);
				if ($fitJointGlobalTranslate[$i])
					{
					createNode -n ("FKGlobalTranslate"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
					parent ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalTranslate"+$fitJoints[$i]+$side);
					}
				createNode -n ("FKGlobal"+$fitJoints[$i]+"MM"+$side) multMatrix;
				$m=`getAttr ("FKOffset"+$fitJoints[$i]+$side+".worldMatrix")`;
				setAttr ("FKGlobal"+$fitJoints[$i]+"MM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
				connectAttr GlobalFollowMain.worldMatrix ("FKGlobal"+$fitJoints[$i]+"MM"+$side+".matrixIn[1]");
				connectAttr ("FKOffset"+$fitJoints[$i]+$side+".worldInverseMatrix") ("FKGlobal"+$fitJoints[$i]+"MM"+$side+".matrixIn[2]");
				//.target[0].rotateWeight not avaiable before Maya2023, so
				$rotPos={"Rot","Pos"};
				for ($y=0;$y<size($rotPos);$y++)
					{
					if (!$fitJointGlobalTranslate[$i] && $y==1)
						continue;
					createNode -n ("FKGlobal"+$fitJoints[$i]+"BM"+$rotPos[$y]+$side) blendMatrix;
					if ($y==0)
						connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+"BM"+$rotPos[$y]+$side+".target[0].weight");
					else
						connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+"BM"+$rotPos[$y]+$side+".target[0].weight");
					createNode -n ("FKGlobal"+$fitJoints[$i]+"PM"+$rotPos[$y]+$side) pickMatrix;
					if ($y==0)
						setAttr ("FKGlobal"+$fitJoints[$i]+"PM"+$rotPos[$y]+$side+".useTranslate") 0;
					if ($y==1)
						setAttr ("FKGlobal"+$fitJoints[$i]+"PM"+$rotPos[$y]+$side+".useRotate") 0;
					setAttr ("FKGlobal"+$fitJoints[$i]+"PM"+$rotPos[$y]+$side+".useScale") 0;
					setAttr ("FKGlobal"+$fitJoints[$i]+"PM"+$rotPos[$y]+$side+".useShear") 0;
					connectAttr ("FKGlobal"+$fitJoints[$i]+"MM"+$side+".matrixSum") ("FKGlobal"+$fitJoints[$i]+"PM"+$rotPos[$y]+$side+".inputMatrix");
					connectAttr ("FKGlobal"+$fitJoints[$i]+"PM"+$rotPos[$y]+$side+".outputMatrix") ("FKGlobal"+$fitJoints[$i]+"BM"+$rotPos[$y]+$side+".target[0].targetMatrix");

					if ($y==0)
						connectAttr ("FKGlobal"+$fitJoints[$i]+"BM"+$rotPos[$y]+$side+".outputMatrix") ("FKGlobal"+$fitJoints[$i]+$side+".offsetParentMatrix");
					else
						connectAttr ("FKGlobal"+$fitJoints[$i]+"BM"+$rotPos[$y]+$side+".outputMatrix") ("FKGlobalTranslate"+$fitJoints[$i]+$side+".offsetParentMatrix");
					}
				}
			else
				{
				createNode -n ("FKGlobalStatic"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
				setAttr ("FKGlobalStatic"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
				duplicate -n ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
				duplicate -n ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
				duplicate -n ("GlobalOffset"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);

				parent ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
				$parent="FKExtra"+$fitJoints[$i]+$side;
				if (`objExists ("FKFlip"+$fitJoints[$i]+$side)`)
					$parent="FKFlip"+$fitJoints[$i]+$side;
				parent $parent ("FKGlobal"+$fitJoints[$i]+$side);
				parent ("Global"+$fitJoints[$i]+$side) ("GlobalOffset"+$fitJoints[$i]+$side);
				parent ("GlobalOffset"+$fitJoints[$i]+$side) GlobalFollowMain;
				orientConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
				createNode -n ("globalReverse"+$fitJoints[$i]+$side) reverse;
				connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("globalReverse"+$fitJoints[$i]+$side+".inputX");
				connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.Global"+$fitJoints[$i]+$side+"W0");
				connectAttr ("globalReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");
				}

			if ($fitJointGlobalTranslate[$i])
				{
				if ($opm)
					{
					//.target[0].rotateWeight not avaiable before Maya2023, so
//					connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+"BM"+$side+".target[0].translateWeight");
//					connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+"BM"+$side+".target[1].weight");

					}
				else
					{
					pointConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
					createNode -n ("globalTranslateReverse"+$fitJoints[$i]+$side) reverse;
					connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("globalTranslateReverse"+$fitJoints[$i]+$side+".inputX");
					connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.Global"+$fitJoints[$i]+$side+"W0");
					connectAttr ("globalTranslateReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");
					}
				}
			}

		if ($fitJointNoControl[$i])
			{
			setAttr -l 1 ("FK"+$fitJoints[$i]+$side+"Shape.v") 0;
			sets -rm ControlSet {("FK"+$fitJoints[$i]+$side),("FKExtra"+$fitJoints[$i]+$side)};
			}

		if ($fitJointBendyJoints[$i] && $fitJointTwistJoints[$i]) 
			{//create controllers for TwistJoints (controllers for inbetween joints created above)
			for ($y=0;$y<$fitJointPartJoints[$i]+1;$y++)
				{
				if ($y==0) $part="";
				else $part="Part"+$y;

				asCreateController "Micro" ($fitJoints[$i]+$part) $side $fitJoints[$i];
				asAlign ("MicroOffset"+$fitJoints[$i]+$part+$side) ($fitJoints[$i]+$part+$side) 1 1 0 0;
				//for building visuals
				refresh;
				setAttr ("MicroOffset"+$fitJoints[$i]+$part+$side+".v") 0;
				}
			}
		}

//Connect inbetweenJoints vis
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$fitJointInbetweenJoints[$i])
			continue;

		addAttr -k 1 -ln inbetweenVis -at bool -dv 0 ("FK"+$fitJoints[$i]+$side);
		setAttr -k 0 -cb 1 ("FK"+$fitJoints[$i]+$side+".inbetweenVis");
		for ($y=1;$y<$fitJointInbetweenJoints[$i]+1;$y++)
			connectAttr ("FK"+$fitJoints[$i]+$side+".inbetweenVis") ("FK"+$fitJoints[$i]+"Part"+$y+$side+"Shape.v");
		}

//Connect inbetweenJoints scale
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($opm)
			continue;
		if (!$fitJointInbetweenJoints[$i])
			continue;
		for ($y=1;$y<$fitJointInbetweenJoints[$i]+1;$y++)
			{
			if (!`objExists ("FK"+$fitJoints[$i]+"Part"+$y+$side)`)
				continue;
			for ($z=0;$z<size($XYZ);$z++)
				{
				connectAttr ("FK"+$fitJoints[$i]+$side+".scale"+$XYZ[$z]) ("FK"+$fitJoints[$i]+"Part"+$y+$side+".scale"+$XYZ[$z]);
				setAttr -k 0 ("FK"+$fitJoints[$i]+"Part"+$y+$side+".scale"+$XYZ[$z]);
				}
			}
		}

//Creation AlignIKTo
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($isIKStart[$i] || $isIKEnd[$i])
			{
			createNode -n ("AlignIKTo"+$fitJoints[$i]+$side) transform;
			setAttr ("AlignIKTo"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			asAlign ("AlignIKTo"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 0 0 0;
			if ($fitJointIsEndJoint[$i])
				parent ("AlignIKTo"+$fitJoints[$i]+$side) ("FKX"+$fitJointParent[$i]+$side);
			else
				parent ("AlignIKTo"+$fitJoints[$i]+$side) ("FKX"+$fitJoints[$i]+$side);
			}
		}

//Creation of FKX endJoint in IK systems
//removed, as deform endJoint then is constraint to FK only (e.g. dinosaur head)

for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

//		if ($opm)
//			continue;
		if ($fitJointIK[$i]=="")
			continue;
		if ($fitJointIKSolver[$i]!="ikSplineSolver")
			continue;
		if (!$fitJointIsEndJoint[$i])
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		select ("FKX"+$fitJointParent[$i]+$parentSide);
		joint -n ("FKX"+$fitJoints[$i]+$side);
		setAttr ("FKX"+$fitJoints[$i]+$side+".drawStyle") 2;
		setAttr ("FKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$fitJoints[$i]+$side);
		xform -ws -t $pos[0] $pos[1] $pos[2] ("FKX"+$fitJoints[$i]+$side);
		}

//Parenting FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (($fitJointIsEndJoint[$i] || $fitJointChild[$i]=="") && !$fitJointControl[$i])
			continue;

		if ($opm)
			{
			parent ("FKOffset"+$fitJoints[$i]+$side) FKSystem;
			if ($fitJointFirstAfterIK[$i] || $fitJointChildOfPart[$i]!=0)
				{
				$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
				if (!`objExists $parentContraintToXform`)
					{
					createNode -n $parentContraintToXform -p FKSystem transform;
					if ($fitJointParent[$i]=="Root")
						asParentConstraint LegLockConstrained $parentContraintToXform "-includePickMatrix"; 
					else
						asParentConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform "-includePickMatrix"; 
					}
				parent ("FKOffset"+$fitJoints[$i]+$side) $parentContraintToXform;
				}
			}
		else
			{
			if ($fitJointParent[$i]=="")
				parent ("FKOffset"+$fitJoints[$i]+$side) FKSystem;
			else if ($fitJointFirstAfterIK[$i] || $fitJointChildOfPart[$i]!=0)
				{
				$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
				if (!`objExists $parentContraintToXform`)
					{
					createNode -n $parentContraintToXform -p FKSystem transform;
					//-mo as this prevents Ankle from flipping. nut this make scaleConstraint wrong
					asAlign $parentContraintToXform ($fitJointParent[$i]+$parentSide) 1 0 0 0;
	//				parentConstraint -mo ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
					if ($fitJointParent[$i]=="Root")// && !$opm
						parentConstraint LegLockConstrained $parentContraintToXform;
					else
						{
						//point & orient instead of parent, as we dont want inverseScale
						pointConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
						orientConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
						//parentConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
						}

					if ($fitJointParent[$i]=="Wrist")
						connectAttr Main.fingerVis ($parentContraintToXform+".v");
					}
				parent ("FKOffset"+$fitJoints[$i]+$side) $parentContraintToXform;
				}
			else
				parent ("FKOffset"+$fitJoints[$i]+$side) ("FKX"+$fitJointParent[$i]+$parentSide);
			}

		//FKPart controllers works both in FK & IK (true for Twist, not for inbetween)
		if ($fitJointBendyJoints[$i] && $fitJointTwistJoints[$i])
			{
			if (!`objExists MicroSystem`)
				{
				createNode -n MicroSystem -p MotionSystem transform;
				connectAttr MainScaleMultiplyDivide.output MicroSystem.s;
				}
			for ($y=0;$y<$fitJointPartJoints[$i]+1;$y++)
				{
				if ($y==0) $part="";
				else $part="Part"+$y;
				parent ("MicroOffset"+$fitJoints[$i]+$part+$side) MicroSystem;
				}
			}
		}

//Non OPM FKRoot_M constraints to RootX_M
if (!$opm && `objExists FKOffsetRoot_M`)
	parentConstraint -mo RootX_M FKOffsetRoot_M;

//FK segmentScaleCompensate
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		//default is segmentScaleCompensate=ON
		//auto-off for fingers and toes
		//can be manually set with $fitJointSegScaleComp
		$segmentScaleCompensate=1;
		if (`gmatch $fitJoints[$i] "*Finger*"` || `gmatch $fitJoints[$i] "*Cup*"` || `gmatch $fitJoints[$i] "*Toes*"`
			|| `gmatch $fitJointParent[$i] "*Head*"`) // removed: `gmatch $fitJoints[$i] "*Head*"`
			$segmentScaleCompensate=0;
		if ($opm && `gmatch $fitJoints[$i] "*Part[0-9]*"`)
			$segmentScaleCompensate=0;
		if ($fitJointUserSegScaleComp[$i])
			$segmentScaleCompensate=$fitJointSegScaleComp[$i];

		if ($opm)
			{
			if (`objExists ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide)`)
				{
				setAttr ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide+".useScale") (!$segmentScaleCompensate);
				setAttr ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide+".useShear") (!$segmentScaleCompensate);
				}

			if ($fitJointParent[$i]=="" && `objExists ("FKOffsetRoot"+$side)`)//Root
				{
				createNode -n ("RootFKMM"+$side) multMatrix;
				//find the rotation-offset from parent, and apply to .matrixIn[0], so we can have zeroed xform values
				delete `orientConstraint ("Root"+$side) ("FKOffsetRoot"+$side)`;
				xform -os -t 0 0 0 ("FKOffsetRoot"+$side);
				$m=`xform -q -os -m ("FKOffsetRoot"+$side)`;
				setAttr ("RootFKMM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
				connectAttr RootX_M.worldMatrix ("RootFKMM"+$side+".matrixIn[1]");
				xform -os -t 0 0 0 -ro 0 0 0 ("FKOffsetRoot"+$side);
				connectAttr ("RootFKMM"+$side+".matrixSum") ("FKOffsetRoot"+$side+".offsetParentMatrix");
				connectAttr FKSystem.inverseMatrix RootFKMM_M.matrixIn[2];
				}
			if (!$fitJointIsEndJoint[$i] && $fitJointsAttachTo[$i]=="" && !$fitJointFirstAfterIK[$i] && $fitJointParent[$i]!="") 
				{
				if (`objExists ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide)` && !`gmatch $fitJoints[$i] "*Part[0-9]*"`) //include setting .useScale for when using `ParentConstraintTo`
					setAttr ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide+".useScale") (!$segmentScaleCompensate);
					{
//					if (`gmatch $fitJoints[$i] "*Part1"`)
//						connectAttr ("FK"+$fitJointParent[$i]+$parentSide+".s") ("FKX"+$fitJointParent[$i]+$parentSide+".s");

					createNode -n ($fitJoints[$i]+"NoShearMM"+$side) multMatrix;
					createNode -n tempXform -p ($fitJoints[$i]+$side) transform;
					parent tempXform ($fitJointParent[$i]+$parentSide);
					xform -os -ro 0 0 0 tempXform;
					$m=`xform -q -os -m tempXform`;
					delete tempXform;
					setAttr ($fitJoints[$i]+"NoShearMM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];

					connectAttr ("FKX"+$fitJointParent[$i]+$parentSide+".worldMatrix") ($fitJoints[$i]+"NoShearMM"+$side+".matrixIn[1]");
					createNode -n ($fitJoints[$i]+"NoShearPM"+$side) pickMatrix;
					setAttr ($fitJoints[$i]+"NoShearPM"+$side+".useScale") 0;
					setAttr ($fitJoints[$i]+"NoShearPM"+$side+".useShear") 0;
					connectAttr ($fitJoints[$i]+"NoShearMM"+$side+".matrixSum") ($fitJoints[$i]+"NoShearPM"+$side+".inputMatrix");

					createNode -n ($fitJoints[$i]+"FKMM"+$side) multMatrix;

					if (`objExists ($fitJoints[$i]+"FKPS"+$side)` && `gmatch $fitJoints[$i] "*Part[0-9]*"`)//using FKPS(inbeween-noShear) instead of standard NoShear
						connectAttr ($fitJoints[$i]+"FKPS"+$side+".worldMatrix") ($fitJoints[$i]+"FKMM"+$side+".matrixIn[1]");
					else
						connectAttr ($fitJoints[$i]+"NoShearPM"+$side+".outputMatrix") ($fitJoints[$i]+"FKMM"+$side+".matrixIn[1]");
					$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
					connectAttr ($tempString[0]+".worldInverseMatrix[0]") ($fitJoints[$i]+"FKMM"+$side+".matrixIn[2]");

					createNode -n ($fitJoints[$i]+"PM"+$side) pickMatrix;
					setAttr ($fitJoints[$i]+"PM"+$side+".useScale") 0;
					connectAttr ($fitJoints[$i]+"FKMM"+$side+".matrixSum")  ($fitJoints[$i]+"PM"+$side+".inputMatrix");
					connectAttr ($fitJoints[$i]+"PM"+$side+".outputMatrix") ("FKOffset"+$fitJoints[$i]+$side+".offsetParentMatrix");
					xform -os -t 0 0 0 -ro 0 0 0 ("FKOffset"+$fitJoints[$i]+$side);

					//find the rotation-offset from parent, and apply to .matrixIn[0], so we can have zeroed xform values
					delete `orientConstraint ($fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side)`;
					$m=`xform -q -os -m ("FKOffset"+$fitJoints[$i]+$side)`;
					setAttr ($fitJoints[$i]+"FKMM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
					xform -os -t 0 0 0 -ro 0 0 0 ("FKOffset"+$fitJoints[$i]+$side);

					addAttr -k 0 -ln inheritScale -at bool -dv (!$segmentScaleCompensate) ("FK"+$fitJoints[$i]+$side);
	//				addAttr -k 1 -ln inheritScale -at bool -dv 0 ("FK"+$fitJoints[$i]+$side);
	//				setAttr -k 0 ("FK"+$fitJoints[$i]+$side+".inheritScale");// -cb 1
					connectAttr ("FK"+$fitJoints[$i]+$side+".inheritScale") ($fitJoints[$i]+"PM"+$side+".useScale");
					connectAttr ("FK"+$fitJoints[$i]+$side+".inheritScale") ($fitJoints[$i]+"NoShearPM"+$side+".useScale");

					}
				}
			}

		else
			{
			if ($segmentScaleCompensate)
				{
				//FKParentScaler(PS)
				if ($fitJointParent[$i]!="" && !$fitJointFirstAfterIK[$i] && !$fitJointIsEndJoint[$i] && $fitJointsAttachTo[$i]=="")
					{
					createNode -n ("FKPS1"+$fitJoints[$i]+$side) -p ("FK"+$fitJointParent[$i]+$parentSide) transform;
					createNode -n ("FKPS2"+$fitJoints[$i]+$side) -p ("FK"+$fitJoints[$i]+$side) transform;
					setAttr ("FKPS1"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
					setAttr ("FKPS2"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
					delete `pointConstraint ("FK"+$fitJoints[$i]+$side) ("FKPS2"+$fitJoints[$i]+$side)`;
					parent ("FKPS2"+$fitJoints[$i]+$side) ("FKPS1"+$fitJoints[$i]+$side);
					//Any ty or tz value, will cause skew e.g. cup
					//setAttr ("FKPS2"+$fitJoints[$i]+$side+".ty") 0;
					//setAttr ("FKPS2"+$fitJoints[$i]+$side+".tz") 0;
					$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
					parent ("FKPS1"+$fitJoints[$i]+$side) $tempString[0];
					scaleConstraint ("FK"+$fitJointParent[$i]+$parentSide) ("FKPS1"+$fitJoints[$i]+$side);
					pointConstraint -mo ("FKPS2"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side);
					}
				}
			else
				{
				setAttr ($fitJoints[$i]+$side+".segmentScaleCompensate") 0;
				if (`objExists ("FKX"+$fitJointParent[$i]+$side)`)
					setAttr ("FKX"+$fitJointParent[$i]+$side+".segmentScaleCompensate") 0;
				$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
				if (`objExists $parentContraintToXform`)
					if (!`isConnected ($fitJointParent[$i]+$parentSide+".s") ($parentContraintToXform+".s")`)
						connectAttr ($fitJointParent[$i]+$parentSide+".s") ($parentContraintToXform+".s");
				}
			}
		}

//Creation IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		select -cl;
		joint -n ("IKX"+$fitJoints[$i]+$side);
		setAttr ("IKX"+$fitJoints[$i]+$side+".drawStyle") 2;
		setAttr ("IKX"+$fitJoints[$i]+$side+".segmentScaleCompensate") 0;
		setAttr ("IKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
		//Extra child under IKX (IKX2), for the FKIK to constrain to, as this avoids constrain flip.
		createNode -n ("IKX2"+$fitJoints[$i]+$side) -p ("IKX"+$fitJoints[$i]+$side) transform;
		if ($isIKStart[$i])
			{
			createNode -n ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			setAttr ("IKParentConstraint"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			createNode -n ("IKXOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("IKXOffset"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("IKX"+$fitJoints[$i]+$side) ("IKXOffset"+$fitJoints[$i]+$side);
			if (`objExists ($fitJointParent[$i]+$parentSide)`)
				{
				$parentPos=`xform -q -ws -t ($fitJointParent[$i]+$parentSide)`;
				$parentRot=`xform -q -ws -ro ($fitJointParent[$i]+$parentSide)`;
				xform -ws -t $parentPos[0] $parentPos[1] $parentPos[2] -ro $parentRot[0] $parentRot[1] $parentRot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
				if ($fitJointIKSolver[$i]!="ikSplineSolver")
					{
					if ($fitJointParent[$i]=="Root")// && !$opm
						asParentConstraint LegLockConstrained ("IKParentConstraint"+$fitJoints[$i]+$side) "-includePickMatrix";
					else
						asParentConstraint ($fitJointParent[$i]+$parentSide) ("IKParentConstraint"+$fitJoints[$i]+$side) "-includePickMatrix";

					if ($opm)
						{
						connectAttr -f IKJoints.worldInverseMatrix ("IKParentConstraint"+$fitJoints[$i]+"MM"+$side+".matrixIn[1]");//ghost matrix-error here 22/10/23
						if (`objExists ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide)`)//take useScale value from FK equivalent
							{
							setAttr ("IKParentConstraint"+$fitJoints[$i]+"PM"+$side+".useScale") `getAttr ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide+".useScale")`;
							setAttr ("IKParentConstraint"+$fitJoints[$i]+"PM"+$side+".useShear") `getAttr ("FKParentConstraintTo"+$fitJointParent[$i]+"PM"+$parentSide+".useShear")`;
							}
						}
					}
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKXOffset"+$fitJoints[$i]+$side);
				makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
				}
			else
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
			asAlign ("IKXOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 1 0 0;
			parent ("IKXOffset"+$fitJoints[$i]+$side) ("IKParentConstraint"+$fitJoints[$i]+$side);
			}
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKX"+$fitJoints[$i]+$side);
		if ($isIKStart[$i] && $fitJointIKSolver[$i]=="ikRPsolver")
			{
			createNode -n ("IKMessureFrom"+$fitJoints[$i]+$side) -p ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			asAlign ("IKMessureFrom"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) 1 1 0 1;
			}
		}

//Parenting IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		if ($isIKStart[$i])
			{
			parent ("IKParentConstraint"+$fitJoints[$i]+$side) IKJoints;
//			if ($opm && !`getAttr -se ("IKParentConstraint"+$fitJoints[$i]+$side+".offsetParentMatrix")`)
//				parent ("IKParentConstraint"+$fitJoints[$i]+$side) IKJointsOPM;
			}
		else
			{
			parent ("IKX"+$fitJoints[$i]+$side) ("IKX"+$fitJointParent[$i]+$parentSide);
			//in some cases the parenting slightly changes the rotation, resolving this with a temp-constraint
			delete `orientConstraint ($fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side)`;
			makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
			}
		}

//Constraint to FK (&IK)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!`objExists ("FKX"+$fitJoints[$i]+$side)`)
			continue;

		if ($opm)
			{
			asParentConstraint ("FKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) "";
			if ($fitJointIK[$i]!="")
				{
				createNode -n ($fitJoints[$i]+"BM"+$side) blendMatrix;
				$tempString=`listConnections -p 1 ($fitJoints[$i]+"MM"+$side+".matrixIn[0]")`;//occational Error here(or 3lines below):No object matches name: matrix In[0]
				connectAttr $tempString[0] ($fitJoints[$i]+"BM"+$side+".inputMatrix");
				connectAttr ("IKX"+$fitJoints[$i]+$side+".worldMatrix") ($fitJoints[$i]+"BM"+$side+".target[0].targetMatrix");
				connectAttr -f ($fitJoints[$i]+"BM"+$side+".outputMatrix") ($fitJoints[$i]+"MM"+$side+".matrixIn[0]");
				}
			}
		else
			{
			pointConstraint ("FKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			orientConstraint ("FKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			if ($fitJointIK[$i]!="")
				{
				pointConstraint -w 0 ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
				orientConstraint -w 0 ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
				}
			parent ($fitJoints[$i]+$side+"_pointConstraint1") ConstraintSystem;
			parent ($fitJoints[$i]+$side+"_orientConstraint1") ConstraintSystem;
			}
		}

//EndJoints also to get Xform only from OPM ($opm)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$opm)
			continue;
		if (!$fitJointIsEndJoint[$i])
		continue;
		if (`objExists ($fitJoints[$i]+"MM"+$side)`)
			continue;

		$m=`getAttr ($fitJoints[$i]+$side+".matrix")`;
		setAttr ($fitJoints[$i]+$side+".offsetParentMatrix") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
		xform -os -t 0 0 0 -ro 0 0 0 ($fitJoints[$i]+$side);
		}

// 1-joint-FitSkeleton:
$tempString[0]="Root_M_pointConstraint1";
if ($opm) $tempString[0]="RootMM_M";
if (`objExists Root_M` && !`objExists $tempString[0]`)
		asParentConstraint RootX_M Root_M "-mo";

//UnTwister (inbetweener option)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointUnTwister[$i])
			{
			$tempString=`listRelatives -c -type joint ($fitJoints[$i]+"Part"+$fitJointInbetweenJoints[$i])`;
			$unTwisterChild=$tempString[0];
			asCreateUnTwister $unTwisterChild $side $fitJoints[$i] $side "" 1 0 "";
			if ($opm)
				{//(Inbetween UnTwister do not exists if in IK)
				connectAttr ("FKX"+$unTwisterChild+$side+".worldMatrix") ($unTwisterChild+"MMTwist"+$side+".matrixIn[0]");
				connectAttr ("FKX"+$fitJoints[$i]+$side+".worldInverseMatrix")  ($unTwisterChild+"MMTwist"+$side+".matrixIn[1]");
				}

			for ($y=1;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				if ($opm)
					{
					createNode -n ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side) multDoubleLinear;
					connectAttr ($unTwisterChild+"QTETwist"+$side+".outputRotateX") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input1");
					setAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2") ((1.0/($fitJointInbetweenJoints[$i]+1))*$y);
//					connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".output") ($fitJoints[$i]+"Part"+$y+$side+".rotate"+$fitJointAbsPriAxis[$i]);
					createNode -n ("twistCM"+$fitJoints[$i]+"Part"+$y+$side) composeMatrix;
					connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".output") ("twistCM"+$fitJoints[$i]+"Part"+$y+$side+".inputRotateX");
					asInsertMMPlug ("twistCM"+$fitJoints[$i]+"Part"+$y+$side+".outputMatrix") ($fitJoints[$i]+"Part"+$y+"MM"+$side) 0;
					}
				else
					{
					createNode -n ("InbetweenUnTwistDivider"+$fitJoints[$i]+"Part"+$y+$side) multiplyDivide;
					connectAttr ("TwistBalancer"+$unTwisterChild+$side+".twist") ("InbetweenUnTwistDivider"+$fitJoints[$i]+"Part"+$y+$side+".input1X");
					setAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+"Part"+$y+$side+".input2X") ((1.0/($fitJointInbetweenJoints[$i]+1))*$y);
					connectAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ($fitJoints[$i]+"Part"+$y+$side+"_orientConstraint1.offsetX");
					//to avoid that rotating the Base, to cause double twisting, contraint to FK instead of FKX:
					delete ("TwistFollowParent"+$unTwisterChild+$side+"_parentConstraint1");
					parentConstraint ("FKX"+$fitJoints[$i]+$side) ("TwistFollowParent"+$unTwisterChild+$side);
					}
				}
			}
		}

//Advanced Aim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		$c=$b;
		if ($fitJointNoFlip[$i] && $b==-1) $c=1;

		if (!$fitJointsAim[$i])
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;

		if (!`objExists ("Aim"+$fitJoints[$i])`)
			{
			createNode -n ("Aim"+$fitJoints[$i]) -p AimSystem transform;
			createNode -n ("AimOffset"+$fitJoints[$i]) -p ("Aim"+$fitJoints[$i]) transform;
			createNode -n ("AimFollow"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] ("Aim"+$fitJoints[$i]+"_M");
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideEnabled") 1;
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideColor") 17;
			sets -add ControlSet ("Aim"+$fitJoints[$i]+"_M");
			scale -r -p 0 0 0 ($scale/3.0) ($scale/3.0) ($scale/3.0) ("Aim"+$fitJoints[$i]+"_M.cv[0:4]");
			parent ("Aim"+$fitJoints[$i]+"_M") ("AimFollow"+$fitJoints[$i]);
			$pos=`xform -q -ws -t $fitJoints[$i]`;
			xform -ws -t 0 $pos[1] ($pos[2]+$scale*2) ("AimOffset"+$fitJoints[$i]);

			if ($opm)
				{
				asParentConstraintBlend ("Aim"+$fitJoints[$i]+"_M") ("AimFollow"+$fitJoints[$i]) ($fitJointParent[$i]+$fitJointParentSide[$i]);
				//multMatrix for localSpace
				createNode -n ("AimFollow"+$fitJoints[$i]+"MM") multMatrix;
				connectAttr ("AimFollow"+$fitJoints[$i]+"BM_.outputMatrix") ("AimFollow"+$fitJoints[$i]+"MM.matrixIn[0]");
				connectAttr ("AimOffset"+$fitJoints[$i]+".worldInverseMatrix") ("AimFollow"+$fitJoints[$i]+"MM.matrixIn[1]");
				connectAttr -f ("AimFollow"+$fitJoints[$i]+"MM.matrixSum") ("AimFollow"+$fitJoints[$i]+".offsetParentMatrix");
				}
			else
				{
				createNode -n ("AimFollowOn"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
				createNode -n ("AimFollowOff"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;

				//.follow setup
				addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 ("Aim"+$fitJoints[$i]+"_M");
				createNode -n ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M") unitConversion;
				setAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.conversionFactor") 0.1;
				connectAttr ("Aim"+$fitJoints[$i]+"_M.follow") ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.input");
				createNode -n ("Aim"+$fitJoints[$i]+"FollowReverse_M") reverse;
				connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("Aim"+$fitJoints[$i]+"FollowReverse_M.inputX");

				parentConstraint ("AimFollowOn"+$fitJoints[$i]) ("AimFollowOff"+$fitJoints[$i]) ("AimFollow"+$fitJoints[$i]);
//				parentConstraint -mo ($fitJointParent[$i]+$fitJointParentSide[$i]) ("AimFollowOn"+$fitJoints[$i]);
				//AimEye_M follow means 1 attr for L/R, so should follow 1st parent that is in `Center`. ( Probably "Head" )
				$tempString=`ls -l ($fitJointParent[$i]+$fitJointParentSide[$i])`;
				tokenize $tempString[0] "|" $tempString;
				for ($z=size($tempString)-1;$z>-1;$z--)
					if (`gmatch $tempString[$z] "*_M"`)
						break;
				parentConstraint -mo $tempString[$z] ("AimFollowOn"+$fitJoints[$i]);

				connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOn"+$fitJoints[$i]+"W0");
				connectAttr ("Aim"+$fitJoints[$i]+"FollowReverse_M.outputX") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOff"+$fitJoints[$i]+"W1");
				}
			}
		
		if ($side!="_M")
			{
			createNode -n ("AimOffset"+$fitJoints[$i]+$side) -p ("Aim"+$fitJoints[$i]+"_M") transform;
			duplicate -n ("Aim"+$fitJoints[$i]+$side) ("Aim"+$fitJoints[$i]+"_M");
			$tempString=`listRelatives -c -f -type transform ("Aim"+$fitJoints[$i]+$side)`;
			if (`size ($tempString)`) delete $tempString;
			parent ("Aim"+$fitJoints[$i]+$side) ("AimOffset"+$fitJoints[$i]+$side);
			asLockAttr ("Aim"+$fitJoints[$i]+$side) 0 1 1 1;
			deleteAttr ("Aim"+$fitJoints[$i]+$side+".follow");
			setAttr -type float3 ("AimOffset"+$fitJoints[$i]+$side+".s") 0.2 0.2 0.2;
			asAlign ("AimOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 0 0 0;
			setAttr ("AimOffset"+$fitJoints[$i]+$side+".tz") 0;
			connectAttr Main.aimLRVis ("Aim"+$fitJoints[$i]+$side+"Shape.v");
			}

		createNode -n ("FKAim"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAim"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side) 1 1 0 1;

		if ($opm)
			{
			$tempString=`listRelatives -c ("FKOffset"+$fitJoints[$i]+$side)`;
			parent ("FKAim"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side);
			createNode -n ("FKAim"+$fitJoints[$i]+"AM"+$side) aimMatrix;
			setAttr ("FKAim"+$fitJoints[$i]+"AM"+$side+".secondaryMode") 2;
			setAttr ("FKAim"+$fitJoints[$i]+"AM"+$side+".secondaryInputAxis") -type float3 0 0 1;
			setAttr ("FKAim"+$fitJoints[$i]+"AM"+$side+".secondaryTargetVector") -type float3 0 0 1;
			connectAttr ("AimEye"+$side+".worldMatrix[0]") ("FKAim"+$fitJoints[$i]+"AM"+$side+".primaryTargetMatrix");
			connectAttr ($fitJointParent[$i]+$fitJointParentSide[$i]+".worldMatrix[0]") ("FKAim"+$fitJoints[$i]+"AM"+$side+".secondaryTargetMatrix");
			connectAttr ("FKOffset"+$fitJoints[$i]+$side+".worldMatrix[0]") ("FKAim"+$fitJoints[$i]+"AM"+$side+".inputMatrix");
			createNode -n ("FKAim"+$fitJoints[$i]+"MM"+$side) multMatrix;
			connectAttr ("FKAim"+$fitJoints[$i]+"AM"+$side+".outputMatrix") ("FKAim"+$fitJoints[$i]+"MM"+$side+".matrixIn[1]");
			connectAttr ("FKOffset"+$fitJoints[$i]+$side+".worldInverseMatrix[0]") ("FKAim"+$fitJoints[$i]+"MM"+$side+".matrixIn[2]");
			connectAttr ("FKAim"+$fitJoints[$i]+"MM"+$side+".matrixSum") ("FKAim"+$fitJoints[$i]+$side+".offsetParentMatrix");
			
			//need invMtrix of FKAim, but as it has incoming ffsetParentMatrix, we can not getAttr, so use a tempPos
			createNode -n tempPos -p ("FKAim"+$fitJoints[$i]+$side) transform;
			parent tempPos ("FKOffset"+$fitJoints[$i]+$side);
			$m=`getAttr tempPos.inverseMatrix`;
			delete tempPos;
			setAttr ("FKAim"+$fitJoints[$i]+"MM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
			parent $tempString ("FKAim"+$fitJoints[$i]+$side);
			}
		else
			{
			$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
			parent ("FKAim"+$fitJoints[$i]+$side) $tempString[0];
			aimConstraint -aimVector $c 0 0 -upVector 0 0 1
				-worldUpVector 0 0 1 -worldUpType "objectrotation"
				-worldUpObject ($fitJointParent[$i]+$fitJointParentSide[$i]) ("Aim"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
			parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
			}
		connectAttr Main.aimFKVis ("FK"+$fitJoints[$i]+$side+"Shape.v");
		}


//Advanced IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		$c=$b;
		if ($fitJointNoFlip[$i] && $b==-1) $c=1;

		if (!$isIKEnd[$i])
			continue;

//		if ($opm && $fitJointIKSolver[$i]=="ikSplineSolver")//OPM SplineIK below
//			continue;

		$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
 
		//IKSp jointChain
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			createNode -n ("IKSp"+$fitJointIK[$i]+"Offset"+$side) -p IKJoints transform;
			setAttr -l 1 ("IKSp"+$fitJointIK[$i]+"Offset"+$side+".v") 0;
			asAlign ("IKSp"+$fitJointIK[$i]+"Offset"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 1 1 0 1;
//			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("FKX"+$fitJointIKStartJoint[$i]+$side) ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side)`;
			select ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
			for ($y=0;$y<size($IKJoints);$y++)
				{
				joint -n ("IKSp"+$IKJoints[$y]+$side);
				}
			//changing to no longer distribute IKSp joints evenly
			for ($y=0;$y<size($IKJoints);$y++)
				asAlign ("IKSp"+$IKJoints[$y]+$side) ("IKX"+$IKJoints[$y]+$side) 1 1 0 0;
			}
		//IKfake, first & last 2 joints in splineIK chain are `fake`, so that`real` can blend btw fake and ..AlignTo (for fixed end.rot in stretchy mode)
		//Also IKfake3 ensures correct twist distribution, as splikeIK twist assumes `end bone`
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			select ("IKSp"+$fitJointIKStartJoint[$i]+$side);
			joint -n ("IKfake0"+$fitJointIK[$i]+$side);
			setAttr -l 1 ("IKfake0"+$fitJointIK[$i]+$side+".v") 0;
			parent ("IKfake0"+$fitJointIK[$i]+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			$tempString=`listRelatives -c ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
			parent $tempString[0] ("IKfake0"+$fitJointIK[$i]+$side);

			select ("IKSp"+$fitJointIKEndJoint[$i]+$side);
			joint -n ("IKfake1"+$fitJointIK[$i]+$side);
			if ($fitJointChild[$i]=="")// If there is no child, then the joint Before the end-joint, should have the full rotation, since the end-joint is not bound to skin.
				{
				$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
				parent ("IKfake1"+$fitJointIK[$i]+$side) $tempString[0];
				}
			setAttr -l 1 ("IKfake1"+$fitJointIK[$i]+$side+".v") 0;
			}

		$startJoint="IKX"+$fitJointIKStartJoint[$i]+$side;
		$endJoint="IKX"+$fitJointIKEndJoint[$i]+$side;
		$middleJoint="IKX"+$fitJointIKMiddleJoint[$i]+$side;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			$startJoint="IKfake0"+$fitJointIK[$i]+$side;
			$endJoint="IKfake1"+$fitJointIK[$i]+$side;
//			if (`objExists ("IKfake2"+$fitJointIK[$i]+$side)`)
//				$endJoint="IKfake3"+$fitJointIK[$i]+$side;
			}
		if (`objExists ("IKfake1"+$fitJointIK[$i]+$side)` && size($IKJoints)==2)
			{
			$tempString=`listRelatives -p ("IKfake1"+$fitJointIK[$i]+$side)`;
			if ($tempString[0]!="IKfake0"+$fitJointIK[$i]+$side)
				parent ("IKfake1"+$fitJointIK[$i]+$side) ("IKfake0"+$fitJointIK[$i]+$side);
			}
		$tempString=`ikHandle -n ("IK"+$fitJointIK[$i]+"Handle"+$side) -ccv 0 -ns 2 -sol $fitJointIKSolver[$i] -sj $startJoint -ee $endJoint`;
		rename $tempString[1] ("IK"+$fitJointIK[$i]+"Effector"+$side);
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Handle"+$side+".v") 0;
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Effector"+$side+".v") 0;
		setAttr ("IK"+$fitJointIK[$i]+"Effector"+$side+".rotateOrder") $fitJointRotOrder[$i];
		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//controller
			asCreateController "IK" $fitJointIK[$i] $side $fitJoints[$i];
			if ($opm)
				parent ("IKOffset"+$fitJointIK[$i]+$side) IKHandle;
			else
				parent ("IKOffset"+$fitJointIK[$i]+$side) IKHandleFollowMain;
			if ($fitJointQtoes[$i]!="") 
				asAlign ("IKOffset"+$fitJointIK[$i]+$side) ($fitJointQtoes[$i]+$side) 1 0 0 0;
			$parent="IK"+$fitJointIK[$i]+$side;
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) $parent;
			//pole
			asCreateController "Pole" $fitJointIK[$i] $side $fitJoints[$i];
			if ($opm)
				parent ("PoleOffset"+$fitJointIK[$i]+$side) IKPoleVector;
			else
				parent ("PoleOffset"+$fitJointIK[$i]+$side) IKHandleFollowMain;
			asLockAttr ("Pole"+$fitJointIK[$i]+$side) 0 1 1 1;
			//place poleVector
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
//			$startJointChildJoint=$tempString[0];
			createNode -n tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer2 -p tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer3 -p tempPoleVecPlacer2 transform;
			$tempString=`pointConstraint ($fitJointIKStartJoint[$i]+$side) ($fitJointIKEndJoint[$i]+$side) tempPoleVecPlacer1`;

			$pos=`xform -q -ws -t ($fitJointIKMiddleJoint[$i]+$side)`;
			$pos2=`xform -q -ws -t ($fitJointIKEndJoint[$i]+$side)`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
			setAttr ($tempString[0]+"."+$fitJointIKStartJoint[$i]+$side+"W0") $dist;
			$pos=`xform -q -ws -t ($fitJointIKStartJoint[$i]+$side)`;
			$pos2=`xform -q -ws -t ($fitJointIKMiddleJoint[$i]+$side)`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
			setAttr ($tempString[0]+"."+$fitJointIKEndJoint[$i]+$side+"W1") $dist;

			if ($fitJointIKMiddleJoint[$i]!=$fitJointIKStartJoint[$i])
				{
				aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($fitJointIKStartJoint[$i]+$side) ($fitJointIKMiddleJoint[$i]+$side) tempPoleVecPlacer2;
				setAttr tempPoleVecPlacer3.tx $ikLenght[$i];

				//Arms/Legs with excatly 0 rotation, will get PreferredAngles set to rotZ
				$pos=`xform -q -ws -t tempPoleVecPlacer2`;
				$pos2=`xform -q -ws -t ($fitJointIKMiddleJoint[$i]+$side)`;
				$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
				if ($dist<0.001 && $dist>-0.001)
					{
					delete tempPoleVecPlacer1_pointConstraint1;
					parent tempPoleVecPlacer1 ($fitJointIKStartJoint[$i]+$side);
					move -r -ls -wd 0 -1 0 tempPoleVecPlacer1;
					setAttr ("IKX"+$fitJointIKMiddleJoint[$i]+$side+".preferredAngle") -type float3 0 0 -90;
					}
				}
			else //no knee joint
				setAttr tempPoleVecPlacer3.tz $ikLenght[$i];
			$temp=`xform -q -ws -t tempPoleVecPlacer3`;

			delete tempPoleVecPlacer1;
//			xform -ws -t ($temp[0]*$b) $temp[1] $temp[2] ("PoleOffset"+$fitJointIK[$i]+$side);
			xform -ws -t $temp[0] $temp[1] $temp[2] ("PoleOffset"+$fitJointIK[$i]+$side);

			spaceLocator -n ("PoleLoc"+$fitJointIK[$i]+$side);
			parent -r ("PoleLoc"+$fitJointIK[$i]+$side) ("Pole"+$fitJointIK[$i]+$side);
			setAttr ("PoleLoc"+$fitJointIK[$i]+$side+".v") 0;
			asLockAttr ("PoleLoc"+$fitJointIK[$i]+$side) 1 1 1 1;

/* yet to resolve poleVectorConstraint using matrixNodes
			if ($opm)
				{
				createNode -n ("IK"+$fitJointIK[$i]+"PolevectorMM"+$side) multMatrix;
				connectAttr ("Pole"+$fitJointIK[$i]+$side+".worldMatrix[0]") ("IK"+$fitJointIK[$i]+"PolevectorMM"+$side+".matrixIn[0]");
				createNode -n ("IK"+$fitJointIK[$i]+"PolevectorSpace"+$side) transform;
				$tempString=`listRelatives -p ("IKXOffset"+$fitJointIKStartJoint[$i]+$side)`;
				parent ("IK"+$fitJointIK[$i]+"PolevectorSpace"+$side) $tempString[0];
				asAlign ("IK"+$fitJointIK[$i]+"PolevectorSpace"+$side) ("IKXOffset"+$fitJointIKStartJoint[$i]+$side) 1 0 0 0;
				connectAttr ("IK"+$fitJointIK[$i]+"PolevectorSpace"+$side+".worldInverseMatrix[0]") ("IK"+$fitJointIK[$i]+"PolevectorMM"+$side+".matrixIn[1]");
				createNode -n ("IKXOffset"+$fitJointIKStartJoint[$i]+"PolevectorDM"+$side) decomposeMatrix;
				connectAttr ("IK"+$fitJointIK[$i]+"PolevectorMM"+$side+".matrixSum") ("IKXOffset"+$fitJointIKStartJoint[$i]+"PolevectorDM"+$side+".inputMatrix");
				connectAttr ("IKXOffset"+$fitJointIKStartJoint[$i]+"PolevectorDM"+$side+".outputTranslate") ("IK"+$fitJointIK[$i]+"Handle"+$side+".poleVector");
				}
			else
*/
			poleVectorConstraint ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side);
			//in case of 3 joint-XigZag-IK, the default created IK-handle`s poleVector could be Flipped, reverse this by set handle_M.twist 180;
			if (size($IKJoints)>3)
				{
				$pos=`xform -q -ws -t ($fitJointIKMiddleJoint[$i]+$side)`;
				$pos2=`xform -q -ws -t ("IKX"+$fitJointIKMiddleJoint[$i]+$side)`;
				$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
				if ($dist>0.01)
					{
					print ("// "+(size($IKJoints)-1)+" joint-XigZag-IK detected, setting \"IK"+$fitJointIK[$i]+"Handle"+$side+".twist\" to 180, to avoid IK-flip.\n");
					setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".twist") 180;
					}
				}
			$parent="IK"+$fitJointIK[$i]+$side;

			$tempString[0]=`createNode annotationShape`;
			$tempString=`listRelatives -p $tempString[0]`;
			$direction=`rename $tempString[0] ("PoleAnnotation"+$fitJointIK[$i]+$side)`;
			setAttr ($direction+"Shape.overrideEnabled") 1;
			setAttr ($direction+"Shape.overrideDisplayType") 2;
			connectAttr Main.arrowVis ($direction+".v");
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
			parent $direction ("IKX"+$fitJointIKMiddleJoint[$i]+$side);
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $direction;
//			connectAttr ("Pole"+$fitJointIK[$i]+$side+"Shape.worldMatrix[0]") ($direction+"Shape.dagObjectMatrix[0]");

			connectAttr ("PoleLoc"+$fitJointIK[$i]+$side+"Shape.worldMatrix[0]") ($direction+"Shape.dagObjectMatrix[0]");
			//orientCnstraint last segment to controller
			createNode -n ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) -p $parent transform;
			createNode -n ("IKFKAligned"+$fitJointIK[$i]+$side) -p ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) transform;
			asAlign ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
			if ($opm)
				{
//				setAttr ("IKX"+$fitJointIKEndJoint[$i]+$side+".rotateOrder") 0;//change to xyz rotOrder, since using only rotate from Decompose
				setAttr ("IKX"+$fitJointIKEndJoint[$i]+$side+".jo") -type float3 0 0 0;//change to xyz rotOrder, since using only rotate from Decompose
				createNode -n ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedMM"+$side) multMatrix;
				createNode -n ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedDM"+$side) decomposeMatrix;
				setAttr ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedDM"+$side+".inputRotateOrder") `getAttr ($fitJointIKEndJoint[$i]+$side+".rotateOrder")`;
				connectAttr ("IKFKAligned"+$fitJointIK[$i]+$side+".worldMatrix") ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedMM"+$side+".matrixIn[0]");
				connectAttr ("IKX"+$fitJointIKEndJoint[$i]+$side+".parentInverseMatrix") ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedMM"+$side+".matrixIn[1]");
				connectAttr ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedMM"+$side+".matrixSum") ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedDM"+$side+".inputMatrix");
				connectAttr ("IKX"+$fitJointIKEndJoint[$i]+"OrientConstrainedDM"+$side+".outputRotate") ("IKX"+$fitJointIKEndJoint[$i]+$side+".r");
				}
			else
					orientConstraint ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKEndJoint[$i]+$side);
			//$ikLocal
			if ($ikLocal[$i] && $ikLocalType[$i]==0)//$ikLocal=addCtrl
				{
				asCreateController "IKLocal" $fitJointIK[$i] $side $fitJoints[$i];
				asAlign ("IKLocalOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) $parent;
				asLockAttr ("IKLocal"+$fitJointIK[$i]+$side) 1 0 1 1;
				parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKLocal"+$fitJointIK[$i]+$side);
				}
			if ($ikLocal[$i] && $ikLocalType[$i]==1)//$ikLocal=nonZero
				{
				parent -w ("IKFKAlignedOffset"+$fitJointIK[$i]+$side);
//				asAlign ("IK"+$fitJointIK[$i]+$side) $fitJoints[$i] 0 1 0 0;
//				setAttr -type float3 ("IKFKAlignedOffset"+$fitJointIK[$i]+$side+".r") (90*$b) 0 180;
				createNode -n tempXform transform;
				asAlign tempXform ($fitJointIKMiddleJoint[$i]+$side) 1 1 0 0;
//				delete `aimConstraint -aimVector (1*$b) 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject tempXform tempXform ("IK"+$fitJointIK[$i]+$side)`;
				delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject tempXform tempXform ("IK"+$fitJointIK[$i]+$side)`;
				if (`gmatch $fitJointLabel[$i] "*Foot*"`)
					delete `aimConstraint -aimVector 0 1 0 -upVector 0 0 1 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject tempXform tempXform ("IK"+$fitJointIK[$i]+$side)`;
				delete tempXform;
				parent ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) $parent;
				asAlign ("AlignIKTo"+$fitJointIKEndJoint[$i]+$side) ("IK"+$fitJointIK[$i]+$side) 0 1 0 0;
				}
			if ($ikLocal[$i] && $ikLocalType[$i]==2)//$ikLocal=localOrient
				{
				parent -w ("IKFKAlignedOffset"+$fitJointIK[$i]+$side);
//				asAlign ("IKOffset"+$fitJointIK[$i]+$side) ($fitJoints[$i]+$side) 0 1 0 0;//causes Warning Cycle
				createNode -n tempXform transform;
				asAlign tempXform ("FKX"+$fitJoints[$i]+$side) 0 1 0 0;

				parent -w ("IK"+$fitJointIK[$i]+"Handle"+$side);
				asAlign ("IKOffset"+$fitJointIK[$i]+$side) tempXform 0 1 0 0;

				parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) $parent;

				delete tempXform;
				setAttr -type float3 ("IKFKAlignedOffset"+$fitJointIK[$i]+$side+".r") 0 0 0;
				setAttr -type float3 ("AlignIKTo"+$fitJointIKEndJoint[$i]+$side+".r") 0 0 0;
				addAttr -k 0 -ln ikLocal -at bool -dv 1 ("IK"+$fitJointIK[$i]+$side);
				addAttr -k 0 -ln ikLocal -at bool -dv 1 ("IKExtra"+$fitJointIK[$i]+$side);
				addAttr -k 0 -ln ikLocal -at bool -dv 1 ("Pole"+$fitJointIK[$i]+$side);
				addAttr -k 0 -ln ikLocal -at bool -dv 1 ("PoleExtra"+$fitJointIK[$i]+$side);
				}
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) IKHandle;
//			$numCVs=$fitJointIKNumCtrls[$i]*2;
			$numCVs=size($IKJoints);
			if ($fitJointIKNumCtrls[$i]==2) $numCVs=$numCVs+2;//2 extra middle CV when only 2 IKctrls
			$crvCmd="curve -n IK"+$fitJointIK[$i]+"Curve"+$side+" -d 3";
			if ($numCVs<4)//for less then 4cv`s change to degree==1
				$crvCmd="curve -n IK"+$fitJointIK[$i]+"Curve"+$side+" -d 1";
			for ($z=0;$z<$numCVs;$z++)
				 $crvCmd+=" -p 0 0 0";
			eval ($crvCmd);
			$tempString=`listRelatives -s ("IK"+$fitJointIK[$i]+"Curve"+$side)`;
			rename $tempString[0] ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
			parent ("IK"+$fitJointIK[$i]+"Curve"+$side) IKCurve;

			$tempString=`listRelatives -type joint -p ($fitJointIKStartJoint[$i]+$side)`;
			if ($tempString[0]=="") //Root
				$ikParentConstraintTo="IKSystem";
			else
				{
				$ikParentConstraintTo="IKParentConstraintTo"+$tempString[0];
				if (!`objExists $ikParentConstraintTo`)
					{
					createNode -n $ikParentConstraintTo -p IKSystem transform;
					if ($tempString[0]=="Root_M" && !$opm)//tails should be affected to LegLock as well
						parentConstraint LegLockConstrained $ikParentConstraintTo;
					else
						parentConstraint $tempString[0] $ikParentConstraintTo;
					}
				}

			createNode -n tempMotionPath motionPath;
			createNode -n tempPos transform;
			setAttr tempMotionPath.fractionMode 1;
			connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace") tempMotionPath.geometryPath;
			connectAttr tempMotionPath.allCoordinates tempPos.t;
			connectAttr tempMotionPath.rotate tempPos.rotate;
			setAttr tempMotionPath.worldUpType 2;
			setAttr tempMotionPath.frontAxis 0;
			setAttr tempMotionPath.upAxis 1;
			setAttr tempMotionPath.worldUpVector 0 1 0;
			connectAttr ($fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") tempMotionPath.worldUpMatrix;
			if ($side=="_L")
				setAttr tempMotionPath.inverseFront 1;
//			if ($side=="_L")
//				setAttr tempMotionPath.inverseUp 1;

			//create IKcv ctrls
			for ($z=0;$z<$numCVs;$z++)
				{
				spaceLocator -n ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				setAttr -l 1 ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".v") 0;
				connectAttr ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

				$pos=`xform -q -ws -t $IKJoints[$z]`;
				xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);

				if ($z!=0 && $z!=$numCVs-1)
					{
//					asCreateController "Pole" ("cv"+$fitJointIK[$i]+$z) $side $fitJointIKStartJoint[$i];
					asCreateController "IKcv" ($fitJointIK[$i]+$z) $side $fitJointIKStartJoint[$i];
					if ($opm)
						parent ("IKcvOffset"+$fitJointIK[$i]+$z+$side) IKHandle;
					else
						parent ("IKcvOffset"+$fitJointIK[$i]+$z+$side) IKHandleFollowMain;
//					rename ("Polecv"+$fitJointIK[$i]+$z+$side) ("IKcv"+$fitJointIK[$i]+$z+$side);
//					rename ("PoleExtracv"+$fitJointIK[$i]+$z+$side) ("IKExtracv"+$fitJointIK[$i]+$z+$side);
//					rename ("PoleOffsetcv"+$fitJointIK[$i]+$z+$side) ("IKcvOffset"+$fitJointIK[$i]+$z+$side);
					asLockAttr ("IKcv"+$fitJointIK[$i]+$z+$side) 0 1 1 0;
					setAttr ("IKcv"+$fitJointIK[$i]+$z+$side+"Shape.overrideColor") 17;
//					xform -s 0.01 1 1 ("IKcv"+$fitJointIK[$i]+$z+$side+".cv[0:99]");
//					connectAttr Main.ikCvVis ("IKcvOffset"+$fitJointIK[$i]+$z+$side+".v");
					asAlign ("IKcvOffset"+$fitJointIK[$i]+$z+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) 1 1 0 0;
					parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IKcv"+$fitJointIK[$i]+$z+$side);
					}
				}

			//orient IKcv ctrls
			for ($z=0;$z<$numCVs;$z++)
				if ($z!=0 && $z!=$numCVs-1)
					{
					setAttr "tempMotionPath.uValue" ((1.0/($numCVs-1))*$z);
					$rot=`xform -q -ws -ro tempPos`;
					xform -s 0.01 1 1 ("IKcv"+$fitJointIK[$i]+$z+$side+".cv[0:99]");
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IKcv"+$fitJointIK[$i]+$z+$side+".cv[0:99]");
					}

			//create IK ctrls
			for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
				{
				$ikControlNr=$q;
				asCreateController "IK" ($fitJointIK[$i]+$ikControlNr) $side $fitJointIKStartJoint[$i];
				parent ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) IKHandleFollowMain;

				$parent="IK"+$fitJointIK[$i]+$ikControlNr+$side;

				createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) transform;
				createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"X"+$side) -p ("IK"+$fitJointIK[$i]+$ikControlNr+$side) transform;
				if (!$opm)//Even as a xform with no values, it needs to parentConstrain to parent, for it to `flip-correct` when IKSpine3_M rotates 180 forward
					parentConstraint ("IK"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+"X"+$side);

				if ($q==1 || $q==$fitJointIKNumCtrls[$i])//Start and End
					{
					xform -s 0.1 1 1 ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");

					if ($q==1)
							parent -r ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side);
					if ($q==$fitJointIKNumCtrls[$i])
							parent -r ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) ("FKX"+$IKJoints[size($IKJoints)-2]+$side);
					parent -w ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side);
					$rot=`xform -q -ws -ro ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side)`;
					if ($ikLocal[$i])
						xform -ws -ro $rot[0] $rot[1] $rot[2] ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side);
					else
						xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");

					if ($q==1) $alignToObject=$fitJointIKStartJoint[$i];
					else $alignToObject=$fitJointIKEndJoint[$i];

					delete `pointConstraint ($alignToObject+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side)`;
					}
				else//inbetween-spline-ik-ctrls
					{
					circle -n tempCircle -c 0 0 0 -nr 1 0 0 -sw 360 -r (`getAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.controlPoints[0].xValue")`*1.2) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0;
					parent -add -s tempCircleShape ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
					delete tempCircle;
					delete ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape");
					rename tempCircleShape ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape");
					setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.overrideEnabled") 1;
					setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.overrideColor") 13;

					setAttr "tempMotionPath.uValue" ((1.0/($fitJointIKNumCtrls[$i]-1))*($q-1));
					asAlign ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) tempPos 1 1 0 0;
					asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) 1 0 0 0;
					if ($ikLocal[$i])
						asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) 0 1 0 0;
					else
						{
						$rot=`xform -q -ws -ro ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side)`;
						xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
						}
					}

				parent ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) $parent;
				setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side+".t") -type float3 0 0 0;

				if ($q==1)
					{
					$parent2="IK"+$fitJointIK[$i]+"1"+$side;
					parent ("IK"+$fitJointIK[$i]+"Locator"+"0"+$side) $parent2;
					}
				if ($q==$fitJointIKNumCtrls[$i])
					{
					$parent2="IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side;
					parent ("IK"+$fitJointIK[$i]+"Locator"+($numCVs-1)+$side) $parent2;
					}

				//LocalOrient1 & 2, for scaling
				createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) -p $parent transform;
				if ($ikControlNr==$fitJointIKNumCtrls[$i])
					asAlign ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) ("FKX"+$fitJointIKEndJoint[$i]+$side) 0 1 0 0;
				else
					asAlign ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 0 1 0 0;
				createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient2"+$side) -p ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) transform;
				}

			for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
				{
				$ikControlNr=$q;
				asCreateController "IKhybrid" ($fitJointIK[$i]+$ikControlNr) $side $fitJointIKStartJoint[$i];
				asAlign ("IKhybridOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 1 1 0 0;
				if ($ikControlNr>1)
					asAlign ("IKhybridOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) 0 1 0 0;
				if ($ikControlNr==1)
					{
					parent ("IKhybridOffset"+$fitJointIK[$i]+$ikControlNr+$side) $fitJointIKStartJoint[$i];
					parent ("IKhybridOffset"+$fitJointIK[$i]+$ikControlNr+$side) IKHandleFollowMain;
					}
				else
					delete `pointConstraint ("IK"+$fitJointIK[$i]+$ikControlNr+$side) ("IKhybridOffset"+$fitJointIK[$i]+$ikControlNr+$side)`;
				//offset IKhybrid for easier seleting
				$pos =`xform -q -ws -t ("IK"+$fitJointIK[$i]+"1"+$side)`;
				$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+"2"+$side)`;
				$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`/(10.0*$b);
				if ($q>1)
					$dist*=-1;
				move -r -os -wd $dist 0 0 ("IKhybrid"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
				}

			//IKhybrid parenting
			$parent="IKhybrid"+$fitJointIK[$i]+($fitJointIKNumCtrls[$i])+$side;
			parent ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) $parent;
			//adding IKhybrid affected SplineIK follow Off, base of Spline not following, instead of just end of Spline not following.
			//changing 1st IK ctrl to be not parented to hybrid
//			parent ("IKOffset"+$fitJointIK[$i]+"1"+$side) ("IKhybrid"+$fitJointIK[$i]+"1"+$side);
			parent ("IKOffset"+$fitJointIK[$i]+"1"+$side) ("IKhybridOffset"+$fitJointIK[$i]+"1"+$side);
			for ($q=$fitJointIKNumCtrls[$i];$q>1;$q--)
				{
				$parent="IKhybrid"+$fitJointIK[$i]+($q-1)+$side;
				parent ("IKhybridOffset"+$fitJointIK[$i]+$q+$side) $parent;
				}

			//IkcvVis (both from ikCvVis attribute and from FKIK.IKVis
			addAttr -k 1 -ln ikCvVis -at bool -dv 0 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			addAttr -k 1 -ln ikHybridVis -at bool -dv 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			setAttr -k 0 -cb 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikHybridVis");
			setAttr -k 0 -cb 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikCvVis");
			for ($z=0;$z<$numCVs;$z++)
				if ($z!=0 && $z!=$numCVs-1)
					connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikCvVis") ("IKcvOffset"+$fitJointIK[$i]+$z+$side+".v");

			//Ikcv constrained, to the 2 nearest IKctrls, and contrain-weighted according to distance to IKctrls
			for ($z=1;$z<$numCVs-1;$z++)
				{
				$pos=`xform -q -ws -t ("IKcv"+$fitJointIK[$i]+$z+$side)`;
				//$minDist1
				$minDist1=9999;
				for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
					{
					$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$q+$side)`;
					$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
					if ($dist<$minDist1)
						{
						$closestIkCtrlNr1=$q;
						$minDist1=$dist;
						}
					}
				//$minDist2
				$minDist2=99999;//IkSpine over 10k units tall issue, fixed
				for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
					{
					if ($q==$closestIkCtrlNr1)
						continue;
					$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$q+$side)`;
					$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
					if ($dist<$minDist2)
						{
						$closestIkCtrlNr2=$q;
						$minDist2=$dist;
						}
					}

				//ensure $closestIkCtrlNr1 & $closestIkCtrlNr2 are sorted, for stiffness to work
				if ($numCVs>3)
					{
					if ($z==1 && $closestIkCtrlNr2=="1")//Start Stiffness
						{
						$tempString[0]=$closestIkCtrlNr1;
						$tempString[1]=$minDist1;
						$closestIkCtrlNr1=$closestIkCtrlNr2;
						$minDist1=$minDist2;
						$closestIkCtrlNr2=$tempString[0];
						$minDist2=$tempString[1];
						}
					if ($z==($numCVs-2) && $closestIkCtrlNr2==$fitJointIKNumCtrls[$i])////End Stiffness
						{
						$tempString[0]=$closestIkCtrlNr1;
						$tempString[1]=$minDist1;
						$closestIkCtrlNr1=$closestIkCtrlNr2;
						$minDist1=$minDist2;
						$closestIkCtrlNr2=$tempString[0];
						$minDist2=$tempString[1];
						}
					}

				if ($opm)
					{
					for ($aa=1;$aa<3;$aa++)
						{
						if ($aa==1) $closestIkCtrlNr=$closestIkCtrlNr1;
						if ($aa==2) $closestIkCtrlNr=$closestIkCtrlNr2;
						createNode -n ("IKcvOffset"+$fitJointIK[$i]+$z+"MM"+$aa+$side) multMatrix;
						connectAttr ("IK"+$fitJointIK[$i]+$closestIkCtrlNr+"X"+$side+".worldMatrix") ("IKcvOffset"+$fitJointIK[$i]+$z+"MM"+$aa+$side+".matrixIn[1]");
						createNode -n tempMatrixXform -p ("IKcvOffset"+$fitJointIK[$i]+$z+$side) transform;
						parent tempMatrixXform ("IK"+$fitJointIK[$i]+$closestIkCtrlNr+"X"+$side);
						$m=`xform -q -os -m tempMatrixXform`;
						delete tempMatrixXform;
						setAttr ("IKcvOffset"+$fitJointIK[$i]+$z+"MM"+$aa+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
						}
					createNode -n ("IKcvOffset"+$fitJointIK[$i]+$z+"BM"+$side) blendMatrix;
					connectAttr ("IKcvOffset"+$fitJointIK[$i]+$z+"MM"+"2"+$side+".matrixSum") ("IKcvOffset"+$fitJointIK[$i]+$z+"BM"+$side+".inputMatrix");
					connectAttr ("IKcvOffset"+$fitJointIK[$i]+$z+"MM"+"1"+$side+".matrixSum") ("IKcvOffset"+$fitJointIK[$i]+$z+"BM"+$side+".target[0].targetMatrix");
					connectAttr ("IKcvOffset"+$fitJointIK[$i]+$z+"BM"+$side+".outputMatrix") ("IKcvOffset"+$fitJointIK[$i]+$z+$side+".offsetParentMatrix");
					xform -os -t 0 0 0 -ro 0 0 0 ("IKcvOffset"+$fitJointIK[$i]+$z+$side);
					setAttr ("IKcvOffset"+$fitJointIK[$i]+$z+"BM"+$side+".target[0].weight") ($minDist2/($minDist1+$minDist2));
					}
				else
					{
					parentConstraint -mo ("IK"+$fitJointIK[$i]+$closestIkCtrlNr1+"X"+$side) ("IK"+$fitJointIK[$i]+$closestIkCtrlNr2+"X"+$side) ("IKcvOffset"+$fitJointIK[$i]+$z+$side);
					setAttr ("IKcvOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr1+"X"+$side+"W0") ($minDist2/($minDist1+$minDist2));
					setAttr ("IKcvOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr2+"X"+$side+"W1") ($minDist1/($minDist1+$minDist2));
					}

				//stiffness
				if ($z==1 || $z==$numCVs-2)
					{
					if ($z==1) $stiffCtrl1Nr=1;
					if ($z==$numCVs-2) $stiffCtrl1Nr=$fitJointIKNumCtrls[$i];

					addAttr -k 1 -ln stiff -at double -min 0 -max 10 -dv 5 ("IK"+$fitJointIK[$i]+$stiffCtrl1Nr+$side);
					createNode -n ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side) setRange;
					connectAttr ("IK"+$fitJointIK[$i]+$stiffCtrl1Nr+$side+".stiff") ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".valueX");
					connectAttr ("IK"+$fitJointIK[$i]+$stiffCtrl1Nr+$side+".stiff") ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".valueY");
					setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".maxX") 1;
					setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".oldMax") -type float3 10 10 0;
					if ($opm)
						{
						setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".minX") `getAttr ("IKcvOffset"+$fitJointIK[$i]+$z+"BM"+$side+".target[0].weight")`;
						connectAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".outValueX") ("IKcvOffset"+$fitJointIK[$i]+$z+"BM"+$side+".target[0].weight");
						}
					else
						{
						setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".minX") `getAttr ("IKcvOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr1+"X"+$side+"W0")`;
						setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".minY") `getAttr ("IKcvOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr2+"X"+$side+"W1")`;
						connectAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".outValueX") ("IKcvOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr1+"X"+$side+"W0");
						connectAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".outValueY") ("IKcvOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr2+"X"+$side+"W1");
						}
					}
				}

			delete tempPos tempMotionPath;

			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IK"+$fitJointIK[$i]+"Handle"+$side+".inCurve");

			createNode -n ("IKCurveInfo"+$fitJointIK[$i]+$side) curveInfo;
			connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.worldSpace[0]") ("IKCurveInfo"+$fitJointIK[$i]+$side+".inputCurve");

			//IK spline stretchy
			addAttr -k 1 -ln stretchy -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
//			asUnitConvertAndReverse ("stretchy"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy");
			asNormalizeAndReverse ($fitJointIK[$i]+"Stretchy"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy") 1;

			//stretchy lenght Normalize & MainScaleMultiply
			createNode -n ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".operation") 2;
			createNode -n ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".operation") 2;
			connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".outputX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input1X");
			connectAttr MainScaleMultiplyDivide.outputX ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input2X");
			connectAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength") ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input1X");
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input2X") `getAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength")`;

			select `listRelatives -ad -type joint $startJoint`;
			select -d ("IKSp"+$fitJointIKEndJoint[$i]+$side);
			$tempString=`ls -sl`;
			for ($x=0;$x<size($tempString);$x++) 
				{
				createNode -n ($fitJointIK[$i]+"Stretchy"+"MultiplyDivide"+$x+$side) multiplyDivide;
				setAttr ($fitJointIK[$i]+"Stretchy"+"MultiplyDivide"+$x+$side+".input1X") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ($fitJointIK[$i]+"Stretchy"+"MultiplyDivide"+$x+$side+".input2X");

				createNode -n ($fitJointIK[$i]+"Stretchy"+"BlendTwo"+$x+$side) blendTwoAttr;
				connectAttr ($fitJointIK[$i]+"Stretchy"+"UnitConversion"+$side+".output") ($fitJointIK[$i]+"Stretchy"+"BlendTwo"+$x+$side+".attributesBlender");
				setAttr ($fitJointIK[$i]+"Stretchy"+"BlendTwo"+$x+$side+".input[0]") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ($fitJointIK[$i]+"Stretchy"+"MultiplyDivide"+$x+$side+".outputX") ($fitJointIK[$i]+"Stretchy"+"BlendTwo"+$x+$side+".input[1]");
				connectAttr ($fitJointIK[$i]+"Stretchy"+"BlendTwo"+$x+$side+".output") ($tempString[$x]+".translateX");
				}

			//Advanced Twist Control
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistControlEnable") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpType") 4;
			if (`attributeExists dForwardAxis ("IK"+$fitJointIK[$i]+"Handle"+$side)`)
				{
				setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dForwardAxis") 0;
				if ($side=="_L" && $fitJointNoMirrorCode[$i]!=-1)
					setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dForwardAxis") 1;
				}
//			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpAxis") 3;has no effect, as this will be `connected`
			setAttr -type float3 ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVector") 0 0 1;
			setAttr -type float3 ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorEnd") 0 0 1;

			connectAttr ("IK"+$fitJointIK[$i]+"1"+"LocalOrient2"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpMatrix");
//			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpMatrixEnd");
			duplicate -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalStartOrient"+$side) ("IK"+$fitJointIK[$i]+"1"+"LocalOrient2"+$side+".worldMatrix");
			$parent="IK"+$fitJointIK[$i]+$ikControlNr+$side;
			parent ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalStartOrient"+$side) $parent;
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalStartOrient"+$side+".t") -type float3 0 0 0;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalStartOrient"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpMatrixEnd");
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistValueType") 2;
			createNode -n ("IK"+$fitJointIK[$i]+"Ramp"+$side) ramp;
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".interpolation") 1;
			connectAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".outColor") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistRamp");
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList[0].color") -type double3 0 0 0;
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList[0].position") 0;
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistRampMult") 3.333;
			for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
				{
				setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].color") -type double3 0 0 0;
//				setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].position") ((1.0/($fitJointIKNumCtrls[$i]-1))*($z-1));
				//instead calculate percentage from a tempCurve, to better twist in correct place for non-even distributed joints
				$crvCmd="curve -n tempCurve -d 1";
				for ($a=0;$a<size($IKJoints);$a++)
					{
					$pos=`xform -q -ws -t ($IKJoints[$a]+$side)`;
					$crvCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
					}
				eval ($crvCmd);

				delete tempCurve;
				$posFactor=((1.0/($fitJointIKNumCtrls[$i]-1))*($z-1));
				setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].position") $posFactor;

				if ($opm)
					{
					createNode -n ("IK"+$fitJointIK[$i]+$z+"MM1"+$side) multMatrix;
					connectAttr ("IKOffset"+$fitJointIK[$i]+$z+$side+".worldInverseMatrix") ("IK"+$fitJointIK[$i]+$z+"MM1"+$side+".matrixIn[0]");
					$m=`getAttr ("IK"+$fitJointIK[$i]+$z+"LocalOrient0"+$side+".worldInverseMatrix")`;
					setAttr ("IK"+$fitJointIK[$i]+$z+"MM1"+$side+".matrixIn[1]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];

					createNode -n ("IK"+$fitJointIK[$i]+$z+"MM2"+$side) multMatrix;
					connectAttr ("IK"+$fitJointIK[$i]+$z+"LocalOrient0"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+$z+"MM2"+$side+".matrixIn[0]");
					connectAttr ("IK"+$fitJointIK[$i]+$z+"MM1"+$side+".matrixSum") ("IK"+$fitJointIK[$i]+$z+"MM2"+$side+".matrixIn[1]");


createNode -n ("IK"+$fitJointIK[$i]+$z+"DMTwist"+$side) decomposeMatrix;
connectAttr ("IK"+$fitJointIK[$i]+$z+"MM2"+$side+".matrixSum") ("IK"+$fitJointIK[$i]+$z+"DMTwist"+$side+".inputMatrix");

createNode -n ("IK"+$fitJointIK[$i]+$z+"QTETwist"+$side) quatToEuler;
connectAttr ("IK"+$fitJointIK[$i]+$z+"DMTwist"+$side+".outputQuatX") ("IK"+$fitJointIK[$i]+$z+"QTETwist"+$side+".inputQuatX");
connectAttr ("IK"+$fitJointIK[$i]+$z+"DMTwist"+$side+".outputQuatW") ("IK"+$fitJointIK[$i]+$z+"QTETwist"+$side+".inputQuatW");


					connectAttr ("IK"+$fitJointIK[$i]+$z+"QTETwist"+$side+".outputRotateX") ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].colorR");
					}
				else
					{
					//Derive actual twist, based on `asCreateUnTwister`
					createNode -n ("TwistFollow"+$fitJointIK[$i]+$z+$side) -p TwistSystem transform;
					setAttr -l 1 ("TwistFollow"+$fitJointIK[$i]+$z+$side+".v") 0;
					parentConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) ("TwistFollow"+$fitJointIK[$i]+$z+$side);
					createNode -n ("TwistFollowOffset"+$fitJointIK[$i]+$z+$side) -p ("TwistFollow"+$fitJointIK[$i]+$z+$side) transform;
					parent ("TwistFollowOffset"+$fitJointIK[$i]+$z+$side) TwistSystem;
					parent ("TwistFollow"+$fitJointIK[$i]+$z+$side) ("TwistFollowOffset"+$fitJointIK[$i]+$z+$side);

					createNode -n ("TwistFollowParent"+$fitJointIK[$i]+$z+$side) -p TwistSystem transform;
					setAttr -l 1 ("TwistFollowParent"+$fitJointIK[$i]+$z+$side+".v") 0;
	//				parentConstraint ("IK"+$fitJointIK[$i]+"1"+"LocalOrient2"+$side) ("TwistFollowParent"+$fitJointIK[$i]+$z+$side);
		
					createNode -n ("IK"+$fitJointIK[$i]+$z+"LocalOrient3"+$side) -p ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) transform;
					parent ("IK"+$fitJointIK[$i]+$z+"LocalOrient3"+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					parentConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient3"+$side) ("TwistFollowParent"+$fitJointIK[$i]+$z+$side);
		
					createNode -n ("TwistFollowParentOffset"+$fitJointIK[$i]+$z+$side) -p ("TwistFollowParent"+$fitJointIK[$i]+$z+$side) transform;
					parent ("TwistFollowParentOffset"+$fitJointIK[$i]+$z+$side) TwistSystem;
					parent ("TwistFollowParent"+$fitJointIK[$i]+$z+$side) ("TwistFollowParentOffset"+$fitJointIK[$i]+$z+$side);

					select ("TwistFollowParent"+$fitJointIK[$i]+$z+$side);
					joint -n ("UnTwist"+$fitJointIK[$i]+$z+$side);
					joint -n ("UnTwistEnd"+$fitJointIK[$i]+$z+$side);
					setAttr ("UnTwistEnd"+$fitJointIK[$i]+$z+$side+".tx") (($height/12.0)*$b);
					select ("UnTwist"+$fitJointIK[$i]+$z+$side);
					joint -n ("TwistBalancer"+$fitJointIK[$i]+$z+$side);

					pointConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) ("UnTwist"+$fitJointIK[$i]+$z+$side);
					ikHandle -n ("UnTwistIK"+$fitJointIK[$i]+$z+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$fitJointIK[$i]+$z+$side) -ee ("UnTwistEnd"+$fitJointIK[$i]+$z+$side);
					parent ("UnTwistIK"+$fitJointIK[$i]+$z+$side) ("TwistFollow"+$fitJointIK[$i]+$z+$side);
					poleVectorConstraint ("UnTwist"+$fitJointIK[$i]+$z+$side) ("UnTwistIK"+$fitJointIK[$i]+$z+$side);
					parentConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) ("TwistBalancer"+$fitJointIK[$i]+$z+$side);
					connectAttr ("TwistBalancer"+$fitJointIK[$i]+$z+$side+".rx") ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].colorR");
					//Reverse value for Left side
					if ($side=="_L")
						{
						$tempString=`listConnections -s 1 -d 0 ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].colorR")`;
						setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*-1);
						}
					}

				}
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($fitJointIKNumCtrls[$i])+"].color") -type double3 0 0 0;
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($fitJointIKNumCtrls[$i])+"].position") 1;

			//flipAxis
			addAttr -k 0 -ln "flipAxis" -at "enum" -en "bend:side:" ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"FlipUpAxisSetRange"+$side) setRange;

			setAttr ("IK"+$fitJointIK[$i]+"FlipUpAxisSetRange"+$side+".minX") 0;//up-axis=positiveY
			setAttr ("IK"+$fitJointIK[$i]+"FlipUpAxisSetRange"+$side+".maxX") 3;//up-axis=positiveZ
	
			setAttr ("IK"+$fitJointIK[$i]+"FlipUpAxisSetRange"+$side+".oldMax") -type float3 1 1 1;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") ("IK"+$fitJointIK[$i]+"FlipUpAxisSetRange"+$side+".value.valueX");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipUpAxisSetRange"+$side+".outValue.outValueX") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpAxis");

			createNode -n ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side) setRange;

			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".min") -type float3 0 1 0;
			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".max") -type float3 0 0 1;

			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".oldMax") -type float3 1 1 1;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".value.valueX");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".value.valueY");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".value.valueZ");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValueX") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorX");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValueY") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorY");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValueZ") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorZ");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValue.outValueX") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorEndX");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValue.outValueY") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorEndY");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValue.outValueZ") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorEndZ");
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") 1;

			//IK spline Follow
			$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
			$ikParent=$tempString[0];
			if ($ikParent=="DeformationSystem") $ikParent="RootX_M";
			if ($ikParent=="Root_M") $ikParent="LegLockConstrained";// && !$opm
			createNode -n ("IKhybridFollow"+$fitJointIK[$i]+"1"+$side) -p ("IKhybridOffset"+$fitJointIK[$i]+"1"+$side) transform;
			if (`objExists ("IKhybridFlip"+$fitJointIK[$i]+"1"+$side)`)
				parent ("IKhybridFlip"+$fitJointIK[$i]+"1"+$side) ("IKhybridFollow"+$fitJointIK[$i]+"1"+$side);
			else
				parent ("IKhybridExtra"+$fitJointIK[$i]+"1"+$side) ("IKhybridFollow"+$fitJointIK[$i]+"1"+$side);
			if ($opm)
				{
				parent ("IKhybridFollow"+$fitJointIK[$i]+"1"+$side) IKHandle;
				asFollowLevels ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKhybridFollow"+$fitJointIK[$i]+"1"+$side) $fitJoints[$i];
				setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".followRoot") 10;//default for SplineIK (but not for rotatPlaneIK
				}
			else
				{
				asFollow ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKhybridFollow"+$fitJointIK[$i]+"1"+$side) $ikParent;
//			asFollow ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) $ikParent;
				setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".follow") 10;
				}

			//Extra Offset needed, since ParentConstraint does not work well with non-uniform scaled parent (e.g. squashed spine)
			createNode -n ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side) -p IKHandleFollowMain transform;
			if ($opm)
				asParentConstraint $ikParent ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side) "";
			else
				{
				pointConstraint $ikParent ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side);
				orientConstraint $ikParent ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side);
				}
//			parentConstraint -mo $ikParent ("IKOffset"+$fitJointIK[$i]+"1"+$side);
			parent ("IKhybridOffset"+$fitJointIK[$i]+"1"+$side) ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side);


			for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
				{
				addAttr -k 1 -ln "followEnd" -at double -min 0 -max 10 -dv ((($z-1)/($fitJointIKNumCtrls[$i]-1.0))*10) ("IK"+$fitJointIK[$i]+$z+$side);
				asUnitConvertAndReverse ("IKFollowEnd"+$fitJointIK[$i]+$z+$side) ("IK"+$fitJointIK[$i]+$z+$side+".followEnd");
				if ($opm)
					{
/*
					createNode -n ("IKOffset"+$fitJointIK[$i]+$z+"BM"+$side) blendMatrix;
					connectAttr ("IKFollowEnd"+$fitJointIK[$i]+"1"+$side+".worldMatrix") ("IKOffset"+$fitJointIK[$i]+$z+"BM"+$side+".inputMatrix");
					connectAttr ("IKFollowEnd"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".worldMatrix") ("IKOffset"+$fitJointIK[$i]+$z+"BM"+$side+".target[0].targetMatrix");
					connectAttr ("IKFollowEnd"+$fitJointIK[$i]+$z+$side+"UnitConversion.output") ("IKOffset"+$fitJointIK[$i]+$z+"BM"+$side+".target[0].weight");
					createNode -n ("IKOffset"+$fitJointIK[$i]+$z+"MM"+$side) multMatrix;
					$tempString=`listRelatives -p ("IKOffset"+$fitJointIK[$i]+$z+$side)`;
					connectAttr ($tempString[0]+".worldInverseMatrix") ("IKOffset"+$fitJointIK[$i]+$z+"MM"+$side+".matrixIn[1]");
					connectAttr ("IKOffset"+$fitJointIK[$i]+$z+"BM"+$side+".outputMatrix") ("IKOffset"+$fitJointIK[$i]+$z+"MM"+$side+".matrixIn[0]");
					connectAttr ("IKOffset"+$fitJointIK[$i]+$z+"MM"+$side+".matrixSum") ("IKOffset"+$fitJointIK[$i]+$z+$side+".offsetParentMatrix");
					xform -os -t 0 0 0 -ro 0 0 0 ("IKOffset"+$fitJointIK[$i]+$z+$side);
*/

					$weight=(1.0/($fitJointIKNumCtrls[$i]-1))*($z-1);
					createNode -n ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side) multMatrix;
					createNode -n tempPos -p ("IK"+$fitJointIK[$i]+$z+$side) transform;
					parent tempPos ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
					$m=`xform -q -os -m tempPos`;
					setAttr ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
					connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".worldMatrix[0]") ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side+".matrixIn[1]");
					delete tempPos;
					createNode -n ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side) multMatrix;
					createNode -n tempPos -p ("IK"+$fitJointIK[$i]+$z+$side) transform;
					parent tempPos ("IKOffset"+$fitJointIK[$i]+"1"+$side);
					$m=`xform -q -os -m tempPos`;
					setAttr ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
					connectAttr ("IK"+$fitJointIK[$i]+"1"+$side+".worldMatrix[0]") ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side+".matrixIn[1]");
					delete tempPos;
					createNode -n ("IK"+$fitJointIK[$i]+"BM"+$z+$side) blendMatrix;
					connectAttr ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side+".matrixSum") ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".inputMatrix");
					connectAttr ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side+".matrixSum") ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".target[0].targetMatrix");
//					setAttr ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".target[0].weight") (1.0-$weight);
					connectAttr ("IKFollowEnd"+$fitJointIK[$i]+$z+$side+"Reverse.outputX") ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".target[0].weight");
					connectAttr ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".outputMatrix") ("IKOffset"+$fitJointIK[$i]+$z+$side+".offsetParentMatrix");
					xform -os -t 0 0 0 -ro 0 0 0 ("IKOffset"+$fitJointIK[$i]+$z+$side);
					}
				else
					{
					//IK FollowEnd constrain to constrained node, as direct constraint flips with the -mo constraint
					createNode -n ("IKFollowEnd"+$fitJointIK[$i]+$side) -p IKHandleFollowMain transform;
					createNode -n ("IKFollowEnd"+$fitJointIK[$i]+"1"+$side) -p ("IKFollowEnd"+$fitJointIK[$i]+$side) transform;
					createNode -n ("IKFollowEnd"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) -p ("IKFollowEnd"+$fitJointIK[$i]+$side) transform;
					parentConstraint ("IK"+$fitJointIK[$i]+"1X"+$side) ("IKFollowEnd"+$fitJointIK[$i]+"1"+$side);
					parentConstraint ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"X"+$side) ("IKFollowEnd"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

					parentConstraint -mo ("IKFollowEnd"+$fitJointIK[$i]+"1"+$side) ("IKFollowEnd"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
					//This can flip if Both Start+End Ik animates `as if Main.ry==180`, `shortest` would fix that, but then flip at 180 bend/side. no great solve for this yet.(keep type==average)
					connectAttr ("IKFollowEnd"+$fitJointIK[$i]+$z+$side+"Reverse.outputX") ("IKOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IKFollowEnd"+$fitJointIK[$i]+"1"+$side+"W0");
					connectAttr ("IKFollowEnd"+$fitJointIK[$i]+$z+$side+"UnitConversion.output") ("IKOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IKFollowEnd"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+"W1");
					}
				}

			//IKAc
			createNode -n ("IKAc"+$fitJointIK[$i]+"Offset"+$side) -p IKJoints transform;
			asAlign ("IKAc"+$fitJointIK[$i]+"Offset"+$side) ($IKJoints[0]+$side)  1 1 0 0;
			createNode -n ("IKAc"+$fitJointIK[$i]+"Offset2"+$side) -p IKJoints transform;
			createNode -n ("IKAc"+$fitJointIK[$i]+"Offset3"+$side) -p IKJoints transform;
			setAttr ("IKAc"+$fitJointIK[$i]+"Offset3"+$side+".inheritsTransform") 0;//since we move by POCI
			asAlign ("IKAc"+$fitJointIK[$i]+"Offset2"+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side)  1 1 0 0;
			for ($y=0;$y<size($IKJoints);$y++)
				{
				select ("IKAc"+$fitJointIK[$i]+"Offset"+$side);
				joint -n ("IKAc"+$IKJoints[$y]+$side);
				}
			setAttr -l 1 ("IKAc"+$fitJointIK[$i]+"Offset"+$side+".v") 0;
			if (`objExists tempNearestPointOnCurve`) delete tempNearestPointOnCurve;
			createNode -n tempNearestPointOnCurve nearestPointOnCurve;
			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKAcPoci"+$IKJoints[$y]+$side) pointOnCurveInfo;
				connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IKAcPoci"+$IKJoints[$y]+$side+".inputCurve");
				setAttr ("IKAcPoci"+$IKJoints[$y]+$side+".turnOnPercentage") 0;

				$pos=`xform -q -ws -t ("IKSp"+$IKJoints[$y]+$side)`;
				setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
				$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
				if (`getAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".degree")`==1 && $y==1)
					$parameter+=0.01;//in case of deg==1, push POCI `over the bend` to get better oriented joint
				setAttr ("IKAcPoci"+$IKJoints[$y]+$side+".parameter") $parameter;
//				connectAttr -f ("IKAcPoci"+$IKJoints[$y]+$side+".position") ("IKAc"+$IKJoints[$y]+$side+".t");
				createNode -n ("IKAcPociXform"+$IKJoints[$y]+$side) -p ("IKAc"+$fitJointIK[$i]+"Offset3"+$side) transform;
				connectAttr -f ("IKAcPoci"+$IKJoints[$y]+$side+".position") ("IKAcPociXform"+$IKJoints[$y]+$side+".t");
				if ($opm)
					{
					createNode -n ("IKAc"+$IKJoints[$y]+"MM"+$side) multMatrix;
					$tempString=`listRelatives -p ("IKAc"+$IKJoints[$y]+$side)`;
					connectAttr ($tempString[0]+".worldInverseMatrix") ("IKAc"+$IKJoints[$y]+"MM"+$side+".matrixIn[1]");
					connectAttr ("IKAcPociXform"+$IKJoints[$y]+$side+".worldMatrix") ("IKAc"+$IKJoints[$y]+"MM"+$side+".matrixIn[0]");
					createNode -n ("IKAc"+$IKJoints[$y]+"DM"+$side) decomposeMatrix;
					connectAttr ("IKAc"+$IKJoints[$y]+"MM"+$side+".matrixSum") ("IKAc"+$IKJoints[$y]+"DM"+$side+".inputMatrix");
					connectAttr ("IKAc"+$IKJoints[$y]+"DM"+$side+".outputTranslate") ("IKAc"+$IKJoints[$y]+$side+".t");				
					}
				else
					pointConstraint ("IKAcPociXform"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[$y]+$side);
/*
//Reverting to using the tangentConstraint as in versions before 5.520, where it was changed to AimCon`s
//in order to "- Reduced flipping occurring on Mid-SplineIk controllers"
//but as of v 6.0431 this ws found to cause other flippping issues when moving Mid-SplineIk ctrl in TX, so reverting
//				tangentConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("IKSp"+$IKJoints[$y]+$side) ("IK"+$fitJointIK[$i]+"Curve"+$side) ("IKAc"+$IKJoints[$y]+$side);
				tangentConstraint -weight 1 -aimVector $c 0 0
					-upVector 0 0 1 -worldUpType "objectrotation"
					-worldUpVector 0 0 1 -worldUpObject ("IKSp"+$IKJoints[$y]+$side) ("IK"+$fitJointIK[$i]+"Curve"+$side) ("IKAc"+$IKJoints[$y]+$side);
*/
				//v6.2901:changing tangentConstraint to AimConstraints, as that is more correct as per standard SplineIk solver
				if ($y==size($IKJoints)-1)
					{
					if ($opm)
						{
						createNode -n ("IKAc"+$IKJoints[$y]+"MM2"+$side) multMatrix;
						$tempString=`listRelatives -p ("IKAc"+$IKJoints[$y]+$side)`;
						connectAttr ($tempString[0]+".worldInverseMatrix") ("IKAc"+$IKJoints[$y]+"MM2"+$side+".matrixIn[1]");
						connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side+".worldMatrix") ("IKAc"+$IKJoints[$y]+"MM2"+$side+".matrixIn[0]");
						createNode -n ("IKAc"+$IKJoints[$y]+"DM2"+$side) decomposeMatrix;
						connectAttr ("IKAc"+$IKJoints[$y]+"MM2"+$side+".matrixSum") ("IKAc"+$IKJoints[$y]+"DM2"+$side+".inputMatrix");
						connectAttr ("IKAc"+$IKJoints[$y]+"DM2"+$side+".outputRotate") ("IKAc"+$IKJoints[$y]+$side+".r");
						}
					else
						orientConstraint -mo ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKAc"+$IKJoints[$y]+$side);//last just orientc
					}
				else
					{
					if ($opm)
						{
						createNode -n ("IKAc"+$IKJoints[$y]+"AM"+$side) aimMatrix;
						setAttr ("IKAc"+$IKJoints[$y]+"AM"+$side+".secondaryMode") 2;
						setAttr ("IKAc"+$IKJoints[$y]+"AM"+$side+".secondaryInputAxis") -type float3 0 1 0;
						setAttr ("IKAc"+$IKJoints[$y]+"AM"+$side+".secondaryTargetVector") -type float3 0 1 0;

						connectAttr ("IKAcPociXform"+$IKJoints[$y]+$side+".worldMatrix[0]") ("IKAc"+$IKJoints[$y]+"AM"+$side+".inputMatrix");

						connectAttr ("IKAc"+$IKJoints[($y+1)]+$side+".worldMatrix[0]") ("IKAc"+$IKJoints[$y]+"AM"+$side+".primaryTargetMatrix");
						connectAttr ("IKSp"+$IKJoints[$y]+$side+".worldMatrix[0]") ("IKAc"+$IKJoints[$y]+"AM"+$side+".secondaryTargetMatrix");

						createNode -n ("IKAc"+$IKJoints[$y]+"MM2"+$side) multMatrix;
						$tempString=`listRelatives -p ("IKAc"+$IKJoints[$y]+$side)`;
						connectAttr ($tempString[0]+".worldInverseMatrix") ("IKAc"+$IKJoints[$y]+"MM2"+$side+".matrixIn[1]");
						connectAttr ("IKAc"+$IKJoints[$y]+"AM"+$side+".outputMatrix")  ("IKAc"+$IKJoints[$y]+"MM2"+$side+".matrixIn[0]");

						createNode -n ("IKAc"+$IKJoints[$y]+"DM2"+$side) decomposeMatrix;
						connectAttr ("IKAc"+$IKJoints[$y]+"MM2"+$side+".matrixSum") ("IKAc"+$IKJoints[$y]+"DM2"+$side+".inputMatrix");
						connectAttr ("IKAc"+$IKJoints[$y]+"DM2"+$side+".outputRotate") ("IKAc"+$IKJoints[$y]+$side+".r");				

						}
					else
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0
							-worldUpObject ("IKSp"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[($y+1)]+$side) ("IKAc"+$IKJoints[$y]+$side);
					}
				}
			delete tempNearestPointOnCurve;
			//Constraint to IKAc jointChain
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) -p ("IKAc"+$IKJoints[$y]+$side) transform;
				asAlign ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) ($IKJoints[$y]+$side) 1 1 0 0;

				//change from parent to point+orient constr. with offset, for better offset behaviour (for curvey splines)
				parent ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) ("IKAc"+$fitJointIK[$i]+"Offset2"+$side);
				if ($y>0)
					{
					if ($opm)
						{
						asParentConstraint ("IKAc"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) "-includePickMatrix";
						setAttr ("IKAc"+$IKJoints[$y]+"FollowOffsetPM"+$side+".useScale") 0;
						setAttr ("IKAc"+$IKJoints[$y]+"FollowOffsetPM"+$side+".useShear") 0;
						}
					else
						{
						pointConstraint -mo ("IKAc"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side);
						orientConstraint -mo ("IKAc"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side);
						}
					}


//				parentConstraint ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
				//connect scale so the Offset scales along
				connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".output.outputX") ("IKAc"+$IKJoints[$y]+$side+".sx");
				connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".output.outputX") ("IKAc"+$IKJoints[$y]+$side+".sy");
				connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".output.outputX") ("IKAc"+$IKJoints[$y]+$side+".sz");
				}
			//changing 1st IK joint due to FixedOrient
//			parent ("IKAc"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) IKJoints;

			//Constraint to IKSp jointChain
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) -p ("IKSp"+$IKJoints[$y]+$side) transform;
				asAlign ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ($IKJoints[$y]+$side) 1 1 0 0;

				//change from parent to point+orient constr. with offset, for better offset behaviour (for curvey splines)
				parent ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
				if ($y>0)
					{
					if ($opm)
						asParentConstraint ("IKSp"+$IKJoints[$y]+$side) ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) "-mo";
					else
						{
						pointConstraint -mo ("IKSp"+$IKJoints[$y]+$side) ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side);
						orientConstraint -mo ("IKSp"+$IKJoints[$y]+$side) ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side);
						}
					}

				if ($opm)
					{
					createNode -n ($IKJoints[$y]+"IkBM"+$side) blendMatrix;
					connectAttr ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side+".worldMatrix") ($IKJoints[$y]+"IkBM"+$side+".inputMatrix");
					connectAttr ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side+".worldMatrix") ($IKJoints[$y]+"IkBM"+$side+".target[0].targetMatrix");
					createNode -n ($IKJoints[$y]+"IkMM"+$side) multMatrix;
					$tempString=`listRelatives -p ("IKX"+$IKJoints[$y]+$side)`;
					connectAttr ($tempString[0]+".worldInverseMatrix") ($IKJoints[$y]+"IkMM"+$side+".matrixIn[1]");
					connectAttr ($IKJoints[$y]+"IkBM"+$side+".outputMatrix") ($IKJoints[$y]+"IkMM"+$side+".matrixIn[0]");
					connectAttr ($IKJoints[$y]+"IkMM"+$side+".matrixSum") ("IKX"+$IKJoints[$y]+$side+".offsetParentMatrix");
					xform -os -t 0 0 0 -ro 0 0 0 ("IKX"+$IKJoints[$y]+$side);
					setAttr ("IKX"+$IKJoints[$y]+$side+".jo") -type float3 0 0 0;
					connectAttr ($fitJointIK[$i]+"StretchyUnitConversion"+$side+".output") ($IKJoints[$y]+"IkBM"+$side+".target[0].weight");
					}
				else
					{
					parentConstraint ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
					parentConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
					connectAttr ($fitJointIK[$i]+"StretchyUnitConversion"+$side+".output") ("IKX"+$IKJoints[$y]+$side+"_parentConstraint1.IKAc"+$IKJoints[$y]+"FollowOffset"+$side+"W0");
					connectAttr ($fitJointIK[$i]+"StretchyReverse"+$side+".outputX") ("IKX"+$IKJoints[$y]+$side+"_parentConstraint1.IKSp"+$IKJoints[$y]+"FollowOffset"+$side+"W1");
/*
					if ($IKJoints[$y]==$fitJointIKEndJoint[$i]) //fixedEnd replacement (always fixedEnd)
						{
						delete ("IKX"+$IKJoints[$y]+$side+"_parentConstraint1");
						$tempString=`pointConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKX"+$IKJoints[$y]+$side)`;
						$constraint=$tempString[0];
						$attrs=`listAttr -k -ud $constraint`;
						connectAttr ($fitJointIK[$i]+"StretchyReverse"+$side+".outputX") ($tempString[0]+"."+$attrs[0]);
						connectAttr ($fitJointIK[$i]+"StretchyUnitConversion"+$side+".output") ($tempString[0]+"."+$attrs[1]);
	//not sure why this was change, but now qpeds gets non-def pose warning, so chaning back
	//chaning this again, to remove -mo, as dragon got non-def pose warning
						orientConstraint ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKX"+$IKJoints[$y]+$side);
	//					orientConstraint -mo ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKX"+$IKJoints[$y]+$side);
	//					orientConstraint -mo ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKX"+$IKJoints[$y]+$side);
						}
	//				else
	//					parentConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
*/
					}
				}

			//removed, as lastSPjoint can not be orientConstrained
/*
			if ($opm)
				{//can not connect to it`s offsetParentMatrix plug, as that would override t from the ik-solver
				createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2MM"+$side) multMatrix;
				connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2MM"+$side+".matrixIn[0]");
				$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
				connectAttr ($tempString[0]+".worldInverseMatrix") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2MM"+$side+".matrixIn[1]");
				createNode -n ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2DM"+$side) decomposeMatrix;
				connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2MM"+$side+".matrixSum") ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2DM"+$side+".inputMatrix");
				connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2DM"+$side+".outputRotate") ("IKSp"+$fitJointIKEndJoint[$i]+$side+".r");
				}
			else
				orientConstraint -mo ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKSp"+$fitJointIKEndJoint[$i]+$side);
*/
			//changing 1st IK joint due to FixedOrient
//			parent ("IKSp"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) IKJoints;

			//adding FixedOrient Attribute added to first IK controller
			createNode -n ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side) -p ("IKfake0"+$fitJointIK[$i]+$side) transform;
			createNode -n ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) -p ("IK"+$fitJointIK[$i]+"1"+"LocalOrient2"+$side) transform;
//			asAlign ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) ("IKfake0"+$fitJointIK[$i]+$side) 1 1 0 0;
//was causing tail misaligment on spinosaurus
			asAlign ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) ("IKfake0"+$fitJointIK[$i]+$side) 1 0 0 0;

			createNode -n ("IKNonFixedOrient"+$fitJointIKStartJoint[$i]+$side) -p ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) transform;
			parent ("IKNonFixedOrient"+$fitJointIKStartJoint[$i]+$side) ("IKfake0"+$fitJointIK[$i]+$side);

			//"FixedOrient"
			addAttr -k 1 -ln "FixedOrient" -at double -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+"1"+$side);
			asUnitConvertAndReverse ("IKFixedOrient"+$fitJointIK[$i]+"1"+$side) ("IK"+$fitJointIK[$i]+"1"+$side+".FixedOrient");
			if ($opm)
				{
				createNode -n ("IK"+$fitJointIK[$i]+"1FixedOrientBM"+$side) blendMatrix;
				connectAttr ("IKNonFixedOrient"+$fitJointIKStartJoint[$i]+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"1FixedOrientBM"+$side+".inputMatrix");
				connectAttr ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"1FixedOrientBM"+$side+".target[0].targetMatrix");
				connectAttr ("IKFixedOrient"+$fitJointIK[$i]+"1"+$side+"UnitConversion.output") ("IK"+$fitJointIK[$i]+"1FixedOrientBM"+$side+".target[0].weight");

				createNode -n ("IK"+$fitJointIK[$i]+"1FixedOrientMM"+$side) multMatrix;
				connectAttr ("IK"+$fitJointIK[$i]+"1FixedOrientBM"+$side+".outputMatrix") ("IK"+$fitJointIK[$i]+"1FixedOrientMM"+$side+".matrixIn[0]");
				$tempString=`listRelatives -p ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side)`;
				connectAttr ($tempString[0]+".worldInverseMatrix") ("IK"+$fitJointIK[$i]+"1FixedOrientMM"+$side+".matrixIn[1]");

				createNode -n ("IK"+$fitJointIK[$i]+"1FixedOrientDM"+$side) decomposeMatrix;
				connectAttr ("IK"+$fitJointIK[$i]+"1FixedOrientMM"+$side+".matrixSum") ("IK"+$fitJointIK[$i]+"1FixedOrientDM"+$side+".inputMatrix");
				connectAttr ("IK"+$fitJointIK[$i]+"1FixedOrientDM"+$side+".outputRotate") ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side+".r");
				}
			else
				{
				orientConstraint ("IKNonFixedOrient"+$fitJointIKStartJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side);
				connectAttr ("IKFixedOrient"+$fitJointIK[$i]+"1"+$side+"Reverse.outputX") ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side+"_orientConstraint1.IKNonFixedOrient"+$fitJointIKStartJoint[$i]+$side+"W0");
				connectAttr ("IKFixedOrient"+$fitJointIK[$i]+"1"+$side+"UnitConversion.output") ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side+"_orientConstraint1.IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side+"W1");
				}
			parent ("IKAc"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side);
			}

		$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
		$ikParent=$tempString[0];

		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//PoleAim (PoleLeg avoid flipping in the forward plane)
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				createNode -n ("PoleAim"+$fitJointIK[$i]+$side) transform;
//				asAlign ("PoleAim"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 0;
				asAlign ("PoleAim"+$fitJointIK[$i]+$side) $ikParent 1 0 0 0;
				if ($opm)
					{
					parent ("PoleAim"+$fitJointIK[$i]+$side) IKHandle;
					createNode -n ("PoleAim"+$fitJointIK[$i]+"AM"+$side) aimMatrix;
					setAttr ("PoleAim"+$fitJointIK[$i]+"AM"+$side+".secondaryMode") 2;
					setAttr ("PoleAim"+$fitJointIK[$i]+"AM"+$side+".secondaryInputAxis") -type float3 0 0 1;
					setAttr ("PoleAim"+$fitJointIK[$i]+"AM"+$side+".secondaryTargetVector") -type float3 0 0 1;

					connectAttr ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") ("PoleAim"+$fitJointIK[$i]+"AM"+$side+".inputMatrix");

					connectAttr ("IK"+$fitJointIK[$i]+$side+".worldMatrix[0]") ("PoleAim"+$fitJointIK[$i]+"AM"+$side+".primaryTargetMatrix");
					connectAttr ("IKFKAlignedOffset"+$fitJointIK[$i]+$side+".worldMatrix[0]") ("PoleAim"+$fitJointIK[$i]+"AM"+$side+".secondaryTargetMatrix");
					connectAttr ("PoleAim"+$fitJointIK[$i]+"AM"+$side+".outputMatrix") ("PoleAim"+$fitJointIK[$i]+$side+".offsetParentMatrix");
					xform -os -t 0 0 0 -ro 0 0 0 ("PoleAim"+$fitJointIK[$i]+$side);
					asParentConstraintBlend ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side);
					}
				else
					{
					aimConstraint -aimVector $b 0 0 -upVector 0 0 1
						-worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("IKFKAlignedOffset"+$fitJointIK[$i]+$side)
						("IK"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side);
					parent ("PoleAim"+$fitJointIK[$i]+$side) IKHandleFollowMain;
					pointConstraint $ikParent ("PoleAim"+$fitJointIK[$i]+$side);
					}
				}
			else if ($opm)
				{
				asParentConstraintBlend ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				setAttr ("Pole"+$fitJointIK[$i]+$side+".follow") 0;
				}

			//Follow
			if ($opm)
				asFollowLevels ("IK"+$fitJointIK[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$side) $fitJoints[$i];
			else
				{
				if (!`gmatch $fitJointIK[$i] "*Leg*"`)
					{
					asFollow ("IK"+$fitJointIK[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$side) $ikParent;
					}
				if (`gmatch $fitJointIK[$i] "*Leg*"`)
					asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side);
				else
					asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				}
			}
		}


/*
//Advanced IK (OPM SplineIK)
//OPM Spline has numCv`s based un NumCtrls, NonOPM Spline has numCv`s based un NumJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		if (!$opm || $fitJointIKSolver[$i]!="ikSplineSolver")// below
			continue;

		$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;

		//Curve
		$tempString=`ikHandle -sol ikSplineSolver -ns 2 -scv false -roc false -pcv false -sj ("IKX"+$fitJointIKStartJoint[$i]+$side) -ee ("IKX"+$fitJointIKEndJoint[$i]+$side) `;
		delete $tempString[0] $tempString[1];
		rename $tempString[2] ("IK"+$fitJointIK[$i]+"Curve"+$side);
		$numCVs=$fitJointIKNumCtrls[$i]+2;
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s ($numCVs-3) -d 3 -tol 0.01 ("IK"+$fitJointIK[$i]+"Curve"+$side);
		parent ("IK"+$fitJointIK[$i]+"Curve"+$side) IKCurve;

		for ($z=0;$z<$numCVs;$z++)
			{
			spaceLocator -n ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
			setAttr -l 1 ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".v") 0;
			$pos=`xform -q -ws -t ("IK"+$fitJointIK[$i]+"Curve"+$side+".cv["+$z+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
			connectAttr ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");
			}

		//create IK ctrls
		createNode -n tempMotionPath motionPath;
		createNode -n tempPos transform;
		setAttr tempMotionPath.fractionMode 1;
		connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace") tempMotionPath.geometryPath;
		connectAttr tempMotionPath.allCoordinates tempPos.t;
		connectAttr tempMotionPath.rotate tempPos.rotate;
		setAttr tempMotionPath.worldUpType 2;
		setAttr tempMotionPath.frontAxis 0;
		setAttr tempMotionPath.upAxis 1;
		setAttr tempMotionPath.worldUpVector 0 1 0;
		connectAttr ($fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") tempMotionPath.worldUpMatrix;

		for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
			{
			$ikControlNr=$q;
			asCreateController "IK" ($fitJointIK[$i]+$ikControlNr) $side $fitJointIKStartJoint[$i];
//			parent ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) IKHandleFollowMain;

			$tempString=`listRelatives -p -type joint ($fitJointIKStartJoint[$i]+$side)`;
			$parent=$tempString[0];
			if ($parent=="")
				$parent="RootX_M";
			if (!`objExists ("IKParentConstraintTo"+$parent)`)
				{
				createNode -n ("IKParentConstraintTo"+$parent) -p IKHandle transform;
				connectAttr ($parent+".worldMatrix") ("IKParentConstraintTo"+$parent+".offsetParentMatrix");
				}
			parent ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) IKHandle;

			createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) transform;
			createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"X"+$side) -p ("IK"+$fitJointIK[$i]+$ikControlNr+$side) transform;
			if ($q==1 || $q==$fitJointIKNumCtrls[$i])//Start and End
				{
				if ($q==1)
					parent ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IKParentConstraintTo"+$parent);
				xform -s 0.1 1 1 ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
			
				if ($q==1)
						parent -r ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side);
				if ($q==$fitJointIKNumCtrls[$i])
						parent -r ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) ("FKX"+$IKJoints[size($IKJoints)-2]+$side);
//						parent -r ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) ($fitJointIKEndJoint[$i]+$side);
				parent -w ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side);
				$rot=`xform -q -ws -ro ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side)`;
				if ($ikLocal[$i])
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side);
				else
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");

				if ($q==1) $alignToObject=$fitJointIKStartJoint[$i];
				else $alignToObject=$fitJointIKEndJoint[$i];

				delete `pointConstraint ($alignToObject+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side)`;
				}
			else//inbetween-spline-ik-ctrls
				{
				circle -n tempCircle -c 0 0 0 -nr 1 0 0 -sw 360 -r (`getAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.controlPoints[0].xValue")`*1.2) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0;
				parent -add -s tempCircleShape ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
				delete tempCircle;
				delete ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape");
				rename tempCircleShape ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape");
				setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.overrideEnabled") 1;
				setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.overrideColor") 13;

				setAttr "tempMotionPath.uValue" ((1.0/($fitJointIKNumCtrls[$i]-1))*($q-1));
				asAlign ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) tempPos 1 1 0 0;
				asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) 1 0 0 0;
				if ($ikLocal[$i])
					asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) 0 1 0 0;
				else
					{
					$rot=`xform -q -ws -ro ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side)`;
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
					}
				}
			parent ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side) ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
			setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient0"+$side+".t") -type float3 0 0 0;
			}

		delete tempPos tempMotionPath;

		//Custom attributes
		addAttr -k 1 -ln ikHybridVis -at bool -dv 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		setAttr -k 0 -cb 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikHybridVis");

		addAttr -k 1 -ln stretchy -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		asNormalizeAndReverse ($fitJointIK[$i]+"Stretchy"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy") 0;
//		asUnitConvertAndReverse ("stretchy"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy");
		addAttr -k 1 -ln lenght -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		asNormalizeAndReverse ($fitJointIK[$i]+"Lenght"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".lenght") 0;
		if (`asMayaVersionAsFloat`>2020)//Maya2020 does not allow for connections to fractionMode attribute
			{
			addAttr -k 0 -ln parametric -at bool -dv 0 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);//dv 0 is more correctly keeping Twisting if InbetweenCtrls
			//aka "parametric Lenght" and "fractionMode"
			//fractionMode could also be called "distributed Stretching" vs "localized Stretching"
			setAttr -k 0 -cb 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".parametric");
			}

		//Stretchy
		createNode -n ("IKCurveInfo"+$fitJointIK[$i]+$side) curveInfo;
		connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.worldSpace[0]") ("IKCurveInfo"+$fitJointIK[$i]+$side+".inputCurve");

		//stretchy lenght Normalize & MainScaleMultiply
		createNode -n ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".operation") 2;
		createNode -n ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".operation") 2;
		connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".outputX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input1X");
		connectAttr MainScaleMultiplyDivide.outputX ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input2X");
		connectAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength") ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input1X");
		setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input2X") `getAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength")`;

		asFollowLevels ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) $fitJoints[$i];
		setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".followRoot") 10;//default for SplineIK (but not for rotatPlaneIK
		//default for bug antenna to follow head
		$tempString=`listRelatives -p $fitJointIKStartJoint[$i]`;
		if ($tempString[0]!="")
			if (`attributeExists ("follow"+$tempString[0]) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side)`)
				setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".follow"+$tempString[0]) 10;

		//parent Locators to ctrls
		parent ("IK"+$fitJointIK[$i]+"Locator0"+$side) ("IK"+$fitJointIK[$i]+"Locator1"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);
		parent ("IK"+$fitJointIK[$i]+"Locator"+($numCVs-1)+$side) ("IK"+$fitJointIK[$i]+"Locator"+($numCVs-2)+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		for ($z=2;$z<$numCVs-2;$z++)
			parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IK"+$fitJointIK[$i]+$z+$side);

		//parenConstrained Mid
		for ($z=2;$z<$numCVs-2;$z++)
			{
			$weight=(1.0/($fitJointIKNumCtrls[$i]-1))*($z-1);
//			createNode -n ("IK"+$fitJointIK[$i]+"StartPM"+$z+$side) pickMatrix;
//			setAttr ("IK"+$fitJointIK[$i]+"StartPM"+$z+$side+".useScale") 0;
//			setAttr ("IK"+$fitJointIK[$i]+"StartPM"+$z+$side+".useShear") 0;
			createNode -n ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side) multMatrix;
			createNode -n tempPos -p ("IK"+$fitJointIK[$i]+$z+$side) transform;
			parent tempPos ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			$m=`xform -q -os -m tempPos`;
			setAttr ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".worldMatrix[0]") ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side+".matrixIn[1]");
//			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".worldMatrix[0]") ("IK"+$fitJointIK[$i]+"StartPM"+$z+$side+".inputMatrix");
//			connectAttr ("IK"+$fitJointIK[$i]+"StartPM"+$z+$side+".outputMatrix") ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side+".matrixIn[1]");
			delete tempPos;

//			createNode -n ("IK"+$fitJointIK[$i]+"EndPM"+$z+$side) pickMatrix;
//			setAttr ("IK"+$fitJointIK[$i]+"EndPM"+$z+$side+".useScale") 0;
//			setAttr ("IK"+$fitJointIK[$i]+"EndPM"+$z+$side+".useShear") 0;
			createNode -n ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side) multMatrix;
			createNode -n tempPos -p ("IK"+$fitJointIK[$i]+$z+$side) transform;
			parent tempPos ("IKOffset"+$fitJointIK[$i]+"1"+$side);
			$m=`xform -q -os -m tempPos`;
			setAttr ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
			connectAttr ("IK"+$fitJointIK[$i]+"1"+$side+".worldMatrix[0]") ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side+".matrixIn[1]");
//			connectAttr ("IK"+$fitJointIK[$i]+"1"+$side+".worldMatrix[0]") ("IK"+$fitJointIK[$i]+"EndPM"+$z+$side+".inputMatrix");
//			connectAttr ("IK"+$fitJointIK[$i]+"EndPM"+$z+$side+".outputMatrix") ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side+".matrixIn[1]");
			delete tempPos;

			createNode -n ("IK"+$fitJointIK[$i]+"BM"+$z+$side) blendMatrix;
			connectAttr ("IK"+$fitJointIK[$i]+"StartMM"+$z+$side+".matrixSum") ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".inputMatrix");
			connectAttr ("IK"+$fitJointIK[$i]+"EndMM"+$z+$side+".matrixSum") ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".target[0].targetMatrix");
			setAttr ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".target[0].weight") (1.0-$weight);
			connectAttr ("IK"+$fitJointIK[$i]+"BM"+$z+$side+".outputMatrix") ("IKOffset"+$fitJointIK[$i]+$z+$side+".offsetParentMatrix");
			xform -os -t 0 0 0 -ro 0 0 0 ("IKOffset"+$fitJointIK[$i]+$z+$side);
			}


		//Poci to find position (result.parameter), then motionPath to attach
		$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
		createNode -n tempNearestPointOnCurve nearestPointOnCurve;
		connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
		for ($y=0;$y<size($IKJoints);$y++)
			{
			createNode -n ("IKMPXform"+$IKJoints[$y]+$side) -p IKMP transform;
			if ($y==0)//first skips curve-attach for simplicity
				{
				asAlign ("IKMPXform"+$IKJoints[$y]+$side) ($IKJoints[$y]+$side) 1 1 0 0;
				parent ("IKX"+$IKJoints[$y]+$side) ("IKMPXform"+$IKJoints[$y]+$side);
				asParentConstraint ("IK"+$fitJointIK[$i]+"1"+$side) ("IKMPXform"+$IKJoints[$y]+$side) "-mo";
				continue;
				}

			createNode -n ("IKPoci"+$IKJoints[$y]+$side) pointOnCurveInfo;
			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IKPoci"+$IKJoints[$y]+$side+".inputCurve");
			setAttr ("IKPoci"+$IKJoints[$y]+$side+".turnOnPercentage") 1;

			$pos=`xform -q -ws -t ("IKX"+$IKJoints[$y]+$side)`;
			setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];

			createNode -n ("IKMP"+$IKJoints[$y]+$side) motionPath;
			$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
			setAttr ("IKMP"+$IKJoints[$y]+$side+".uValue") $parameter;
			if (`asMayaVersionAsFloat`>2020)
				connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".parametric") ("IKMP"+$IKJoints[$y]+$side+".fractionMode");
			connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace") ("IKMP"+$IKJoints[$y]+$side+".geometryPath");
			connectAttr ("IKMP"+$IKJoints[$y]+$side+".allCoordinates") ("IKMPXform"+$IKJoints[$y]+$side+".t");

			//modified from using orientation from the MotionPath, to using AimAtChild
			setAttr ("IKMP"+$IKJoints[$y]+$side+".follow") 0;


			connectAttr MainScaleMultiplyDivide.output ("IKMPXform"+$IKJoints[$y]+$side+".s");

			//worldUpMatrix blend from 2 nearest ctrls
			createNode -n ("IKMPUpBM"+$IKJoints[$y]+$side) blendMatrix;
			$pos=`xform -q -ws -t ("IKX"+$IKJoints[$y]+$side)`;
			//$minDist1
			$minDist1=9999;
			for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
				{
				$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$q+$side)`;
				$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
				if ($dist<$minDist1)
					{
					$closestIkCtrlNr1=$q;
					$minDist1=$dist;
					}
				}
			//$minDist2
			$minDist2=99999;//IkSpine over 10k units tall issue, fixed
			for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
				{
				if ($q==$closestIkCtrlNr1)
					continue;
				$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$q+$side)`;
				$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
				if ($dist<$minDist2)
					{
					$closestIkCtrlNr2=$q;
					$minDist2=$dist;
					}
				}

			connectAttr ("IK"+$fitJointIK[$i]+$closestIkCtrlNr1+"LocalOrient0"+$side+".worldMatrix[0]") ("IKMPUpBM"+$IKJoints[$y]+$side+".inputMatrix");
			connectAttr ("IK"+$fitJointIK[$i]+$closestIkCtrlNr2+"LocalOrient0"+$side+".worldMatrix[0]") ("IKMPUpBM"+$IKJoints[$y]+$side+".target[0].targetMatrix");
			setAttr ("IKMPUpBM"+$IKJoints[$y]+$side+".target[0].weight") ($minDist1/($minDist1+$minDist2));
			connectAttr ("IKMPUpBM"+$IKJoints[$y]+$side+".outputMatrix") ("IKMP"+$IKJoints[$y]+$side+".worldUpMatrix");

			delete ("IKX2"+$IKJoints[$y]+$side);
			parent ("IKX"+$IKJoints[$y]+$side) IKJoints;
			parent ("IKX"+$IKJoints[$y]+$side) ("IKMPXform"+$IKJoints[$y]+$side);

			//Stretchy
			createNode -n ("IKStretchyMPD"+$IKJoints[$y]+$side) multiplyDivide;
			setAttr ("IKStretchyMPD"+$IKJoints[$y]+$side+".operation") 2;
			setAttr ("IKStretchyMPD"+$IKJoints[$y]+$side+".input1X") `getAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength")`;
			connectAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength") ("IKStretchyMPD"+$IKJoints[$y]+$side+".input2X");
			createNode -n ("IKStretchyMDL"+$IKJoints[$y]+$side) multDoubleLinear;
			connectAttr -f ("IKStretchyMPD"+$IKJoints[$y]+$side+".outputX") ("IKStretchyMDL"+$IKJoints[$y]+$side+".input1");
			setAttr ("IKStretchyMDL"+$IKJoints[$y]+$side+".input2") $parameter;

			createNode -n ("IKStretchyBlend"+$IKJoints[$y]+$side) blendTwoAttr;
			connectAttr ($fitJointIK[$i]+"StretchyUnitConversion"+$side+".output") ("IKStretchyBlend"+$IKJoints[$y]+$side+".attributesBlender");
			connectAttr ("IKStretchyMDL"+$IKJoints[$y]+$side+".output") ("IKStretchyBlend"+$IKJoints[$y]+$side+".input[0]");
			setAttr ("IKStretchyBlend"+$IKJoints[$y]+$side+".input[1]") $parameter;

			//Add Lenght
			createNode -n ("IKStretchyLenghtMDL"+$IKJoints[$y]+$side) multDoubleLinear;
			connectAttr ("IKStretchyBlend"+$IKJoints[$y]+$side+".output") ("IKStretchyLenghtMDL"+$IKJoints[$y]+$side+".input1");
			connectAttr ($fitJointIK[$i]+"LenghtUnitConversion"+$side+".output") ("IKStretchyLenghtMDL"+$IKJoints[$y]+$side+".input2");
			connectAttr -f ("IKStretchyLenghtMDL"+$IKJoints[$y]+$side+".output") ("IKMP"+$IKJoints[$y]+$side+".uValue");
			}
		delete tempNearestPointOnCurve;

		//IKhybrid
		for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
			{
			asCreateController "IKhybrid" ($fitJointIK[$i]+$q) $side $fitJointIKStartJoint[$i];

//			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikHybridVis")  ("IKhybrid"+$fitJointIK[$i]+$q+$side+"Shape.v");

			asAlign ("IKhybridOffset"+$fitJointIK[$i]+$q+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 1 1 0 0;
			if ($q>1)
				asAlign ("IKhybridOffset"+$fitJointIK[$i]+$q+$side) ("IK"+$fitJointIK[$i]+$q+"LocalOrient0"+$side) 1 1 0 0;
			if ($q==1)
				parent ("IKhybridOffset"+$fitJointIK[$i]+$q+$side) ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			else
				parent ("IKhybridOffset"+$fitJointIK[$i]+$q+$side) ("IKhybrid"+$fitJointIK[$i]+($q-1)+$side);

			//offset IKhybrid for easier seleting
			$pos =`xform -q -ws -t ("IK"+$fitJointIK[$i]+"1"+$side)`;
			$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+"2"+$side)`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`/10.0;
			if ($q>1)
				$dist*=-1;
			move -r -os -wd $dist 0 0 ("IKhybrid"+$fitJointIK[$i]+$q+$side+".cv[0:99]");
			}
		createNode -n ("IKOffsetFromHybrid"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) -p ("IKOffset"+$fitJointIK[$i]+($q-1)+$side) transform;
		parent ("IKOffsetFromHybrid"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKhybrid"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		parent ("IKExtra"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffsetFromHybrid"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		}
*/

//Advanced FKIK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$isIKStart[$i])
			continue;

		duplicate -n ("FKIK"+$fitJointIK[$i]+$side) "FKIK_icon";
		xform -ws -t 0 0 0 -ro 0 0 0 ("FKIK"+$fitJointIK[$i]+$side);
		//by default `bodyScale` determines FKIK icon scale, except if just a small limb e.g. just a spine, then use $ikLenght
		$tempFloat[0]=$iconScaleFactor;
		if ($iconScaleFactor<$ikLenght[$i]/60.0)
			$tempFloat[0]=$ikLenght[$i]/20.0;
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".scale") $tempFloat[0] $tempFloat[0] $tempFloat[0];

		setAttr ("FKIK"+$fitJointIK[$i]+$side+".rotateY") 90;
		makeIdentity -a 1 -t 1 -r 1 -s 1 ("FKIK"+$fitJointIK[$i]+$side);

		createNode -n ("FKIKParentConstraint"+$fitJointIK[$i]+$side) transform;
		$tempString=`listRelatives -p -type joint ($fitJointIKStartJoint[$i]+$side)`;
		$parent=$tempString[0];
		if ($parent=="Root_M")// && !$opm
			asParentConstraint LegLockConstrained ("FKIKParentConstraint"+$fitJointIK[$i]+$side) "";
		else if(`objExists $parent`)
			asParentConstraint $parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side) "";
		else
			asParentConstraint ($fitJointIKStartJoint[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side) "";
		parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side) ("FKIKSystem");

		$sca=`xform -q -r -s $fitJointIKStartJoint[$i]`;
		$sca[0]*=$scale;$sca[1]*=$scale;$sca[2]*=$scale;
		parent ("FKIK"+$fitJointIK[$i]+$side) ($fitJointIKStartJoint[$i]+$side);
//		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".t") ($iconScaleFactor*$b*5) 0 ($iconScaleFactor*$b*5);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".t") 0 0 0;
		setAttr ("FKIK"+$fitJointIK[$i]+$side+".tx") ($iconScaleFactor*$b*5);
		setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") ($iconScaleFactor*$b*5);

		//`fat` based side-distance
		if (`attributeExists fatWidth $fitJoints[$i]`)
			{
			$pos=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[0]")`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[5]")`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`*$b;

			setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (((`getAttr ($fitJoints[$i]+".fat")`*`getAttr ($fitJoints[$i]+".fatWidth")`*$b)+($dist/2.0)));
			}

		//ensure its moved to `outside` direction
		if ($side!="_M")
			{
			$pos=`xform -q -ws -t ($fitJointIKStartJoint[$i]+$side)`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side)`;
			if ($side=="_R" && $pos2[0]>$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			if ($side=="_L" && $pos2[0]<$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			}

		parent ("FKIK"+$fitJointIK[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		asLockAttr ("FKIK"+$fitJointIK[$i]+$side) 1 1 1 1;

		addAttr -k 1 -ln FKIKBlend -at double -min 0 -max $udMax -dv 0 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln autoVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -k 0 -cb 1 ("FKIK"+$fitJointIK[$i]+$side+".autoVis");
		addAttr -k 1 -ln FKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln IKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -ln startJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".startJoint") $fitJointIKStartJoint[$i];
		addAttr -ln middleJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".middleJoint") $fitJointIKMiddleJoint[$i];
		addAttr -ln endJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".endJoint") $fitJointIKEndJoint[$i];

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".input");

		if (!$opm)
			{
			createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side) reverse;
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".inputX");
			}

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side) condition;
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side) setRange;

		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".minX") 10;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".oldMaxX") 10;

		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".autoVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".firstTerm");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".IKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueR");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueG");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".valueX");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseR");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".outValueX") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseG");

		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$side+".v");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("PoleOffset"+$fitJointIK[$i]+$side+".v");
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			for ($z=1;$z<$fitJointIKNumCtrls[$i]+1;$z++)
//				connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$z+$side+".v");
//changed, as "paralell mode" makes the connected visibility cause the node to not update, so FKIKSwitch would cause IK to not follow RootX_M
//(when Switch to FK the switch back to IK)
				connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IK"+$fitJointIK[$i]+$z+$side+"Shape.v");

			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IK"+$fitJointIK[$i]+"Curve"+$side+".v");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideDisplayType") 1;

			createNode -n ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side) plusMinusAverage;
			setAttr ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side+".operation") 3;
//			connectAttr ("IK"+$fitJointIK[$i]+"1"+$side+"Shape.v") ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side+".input1D[0]");
//			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side+".input1D[0]");
//was attempt to move away from using another shape`s vis as source, as it could be curveSwapped, but gets 0-10 range instead of 0-1
//so UnitConversion this to 0-1 range
			createNode -n ("FKIKBlend"+$fitJointIK[$i]+"ConditionUnitConversion"+$side) unitConversion;
			setAttr ("FKIKBlend"+$fitJointIK[$i]+"ConditionUnitConversion"+$side+".conversionFactor") (1.0/$udMax);
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("FKIKBlend"+$fitJointIK[$i]+"ConditionUnitConversion"+$side+".input");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"ConditionUnitConversion"+$side+".output") ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side+".input1D[0]");

//			if (!$opm)
				{
				connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikHybridVis") ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side+".input1D[1]");
				setAttr ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side+".input1D[2]") -0.5;
				for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
					connectAttr ("FKIKBlend"+$fitJointIK[$i]+"HybridVisPMA"+$side+".output1D") ("IKhybrid"+$fitJointIK[$i]+$q+$side+"Shape.v");
				}
			}
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR")  ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side+".v");
		if (!$opm)
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorG")  ("FKOffset"+$fitJointIKStartJoint[$i]+$side+".v");

		for ($y=1;$y<99;$y++)
			{
			if (!`objExists ("IKcvExtra"+$fitJointIK[$i]+$y+$side)`)
				break;
			setAttr -l 0 ("IKcvExtra"+$fitJointIK[$i]+$y+$side+".v");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKcvExtra"+$fitJointIK[$i]+$y+$side+".v");
			}
		}

//FKOffset.v
if ($opm)
	for ($b=1;$b>-2;$b=$b-2)
		for ($i=0;$i<size($fitJoints);$i++)
			{
			$side=$fitJointSide[$i];
			$parentSide=$fitJointParentSide[$i];
			if ($b==-1 && $fitJointSide[$i]=="_M") continue;
			if ($b==-1) $side="_L";
			if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
			if ($b==$fitJointNoMirrorCode[$i]) continue;

			if ($fitJointIK[$i]=="" || !`objExists ("FKOffset"+$fitJoints[$i]+$side)`)
				continue;
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorG") ("FKOffset"+$fitJoints[$i]+$side+".v");
			}

//FKIK connect to constraints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($opm)
			{
			if ($fitJointIK[$i]!="" && `objExists ($fitJoints[$i]+"BM"+$side)`)
//				connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ($fitJoints[$i]+"BM"+$side+".target[0].weight");
				connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($fitJoints[$i]+"BM"+$side+".target[0].weight");
			}
		else
			{
			if (!`objExists ($fitJoints[$i]+$side+"_pointConstraint1")`)
				continue;

			if ($fitJointIK[$i]!="")
				{
				connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($fitJoints[$i]+$side+"_pointConstraint1.FKX"+$fitJoints[$i]+$side+"W0");
				connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($fitJoints[$i]+$side+"_orientConstraint1.FKX"+$fitJoints[$i]+$side+"W0");
				connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($fitJoints[$i]+$side+"_pointConstraint1.IKX"+$fitJoints[$i]+$side+"W1");
				connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($fitJoints[$i]+$side+"_orientConstraint1.IKX"+$fitJoints[$i]+$side+"W1");
				}
			}
	}

//Advanced IK, ikLocal used to get controller at start of IK (spesial usage, can create a "IKLocalArmShoulder_R" controller
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($isIKEnd[$i] || $fitJointIKSolver[$i]=="ikSplineSolver")
			continue;

		if ($ikLocal[$i] && `objExists ("FKParentConstraintTo"+$fitJointParent[$i]+$parentSide)`)
			{
			asCreateController "IKLocal" ($fitJointIK[$i]+$fitJoints[$i]) $side $fitJoints[$i];
			if ($ikLocalType[$i]==2)//$ikLocal=localOrient 
				asAlign ("IKLocalOffset"+$fitJointIK[$i]+$fitJoints[$i]+$side) $fitJointIKStartJoint[$i] 0 1 0 0;
			parent ("IKLocalOffset"+$fitJointIK[$i]+$fitJoints[$i]+$side) ("FKParentConstraintTo"+$fitJointParent[$i]+$parentSide);
			parentConstraint -mo ("IKLocal"+$fitJointIK[$i]+$fitJoints[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side);
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKLocalOffset"+$fitJointIK[$i]+$fitJoints[$i]+$side+".v");
			}
		}


//Advanced FootRoll
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!`gmatch $fitJointLabel[$i] "*Foot*"`)
			continue;

		$parent="IK"+$fitJointIK[$i]+$side;

		//find $ankle,$heel,$toes,$toesEnd & $footRollJoints
		$ankle=$fitJoints[$i];
		$heel="";$toes="";$toesEnd="";$bigToe="";$pinkyToe="";
		clear $footRollJoints;
		$tempString=`listRelatives -ad -type joint $ankle`;
//		for ($y=0;$y<size($tempString);$y++)
		for ($y=size($tempString)-1;$y>-1;$y--)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*ToesEnd*"`)
				{
				$toes=$tempString[$y];
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
				}
			if (`gmatch $childLabel "*BigToe*"`)
				$bigToe=$tempString[$y];
			if (`gmatch $childLabel "*PinkyToe*"`)
				$pinkyToe=$tempString[$y];
			if (`gmatch $childLabel "*ToesEnd*"`)
				{
				$toesEnd=$tempString[$y];
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
				}
			//skip joints below Toes (that is not ToesEnd)
			$tempString2=`ls -l $tempString[$y]`;
			if (`gmatch $tempString2[0] ("*|"+$toes+"|*")` && $tempString[$y]!=$toesEnd)
				continue;
			//skip joints that end-up at Toes label $hasChildWithToesLabel (e.g claw attached to Ankle)
			$hasChildWithToesLabel=0;
			$tempString2=`listRelatives -ad -type joint $tempString[$y]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$label=`asLabel $tempString2[$z]`;
				if (`gmatch $label "*Toes*"`)
					$hasChildWithToesLabel=1;
				}
			if (!$hasChildWithToesLabel)
				continue;
			if ($childLabel=="")
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
			}
		if ($heel!="")
			$footRollJoints[size($footRollJoints)]=$heel;

		if ($toes=="" || $toesEnd=="")
			continue;

		addAttr -k 1 -ln swivel -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
//		addAttr -k 1 -ln toe -at double ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln roll -at double ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln rollStartAngle -at double -dv 30 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln rollEndAngle -at double -dv 60 ("IK"+$fitJointIK[$i]+$side);

		if ($opm)
			{
			createNode -n ("IK"+$fitJointIK[$i]+$side+"SwivelUnitConversion"+$side) unitConversion;
			setAttr ("IK"+$fitJointIK[$i]+$side+"SwivelUnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".swivel") ("IK"+$fitJointIK[$i]+$side+"SwivelUnitConversion"+$side+".input");
			connectAttr ("IK"+$fitJointIK[$i]+$side+"SwivelUnitConversion"+$side+".output") ("PoleAim"+$fitJointIK[$i]+$side+".rx");
			}
		else
			{
			connectAttr ("IK"+$fitJointIK[$i]+$side+".swivel") ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX");
			$tempString=`listConnections ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX")`;
			setAttr ($tempString[0]+".conversionFactor") 0.1;
			}

		//find $footRotOut[$i]
		if ($toes!="")
			{
			$pos=`xform -q -ws -t $fitJoints[$i]`;
			$pos2=`xform -q -ws -t $toes`;
			createNode -n rotationSampler1 transform;
			xform -ws -t $pos[0] $pos2[1] $pos[2] rotationSampler1;
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "scene" $toes rotationSampler1;
			$footRotOut[$i]=`getAttr rotationSampler1.ry`;
			delete rotationSampler1;
			}

		createNode -n ("IK"+$fitJointIK[$i]+"FootRoll"+$side) -p $parent transform;
		$temp=`xform -q -ws -t ($fitJointIKEndJoint[$i]+$side)`;
		xform -ws -t $temp[0] $temp[1] $temp[2] ("IK"+$fitJointIK[$i]+"FootRoll"+$side);
		setAttr ("IK"+$fitJointIK[$i]+"FootRoll"+$side+".ry") ($footRotOut[$i]*$b);

		//$footRollJoints  IK->Heel->ToeEnd->Toes->Hocks
		for ($y=0;$y<size($footRollJoints);$y++)
			{
			asCreateController "Roll" $footRollJoints[$y] $side $footRollJoints[$y];
			if ($fitJointQtoes[$i]!="")//for Qtoes, RollToes are not `planted` on the ground, so use more intuitive `local` orient
				{
				delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "object"
					-worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) ("RollOffset"+$footRollJoints[$y]+$side)`;
				}
			else
				setAttr ("RollOffset"+$footRollJoints[$y]+$side+".ry") ($footRotOut[$i]*$b);
			if ($y>0)
				parent ("RollOffset"+$footRollJoints[$y-1]+$side) ("Roll"+$footRollJoints[$y]+$side);

			}
		parent ("RollOffset"+$footRollJoints[size($footRollJoints)-1]+$side) $parent;

		//Pinky/index toe side2side rocking
		if (`objExists $toes` && `objExists $bigToe` && `objExists $pinkyToe`)
			{
			addAttr -k 1 -ln rock -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) -p $parent transform;
//			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) -p $parent transform;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rotateOrder") 5;
			asAlign ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side) 1 1 0 0;
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $bigToe`)
				$pos=`xform -q -ws -t $bigToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side);
			duplicate -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $pinkyToe`)
				$pos=`xform -q -ws -t $pinkyToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) $parent;

			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side) clamp;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".minR") -200;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rock") ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz");
			if ($side=="_L")
				{
				$tempString=`listConnections ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz")`;
				setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*-1);
				}
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side) clamp;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".maxR") 200;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rock") ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz");
			if ($side=="_L")
				{
				$tempString=`listConnections ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz")`;
				setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*-1);
				}
			parent ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("RollOffset"+$footRollJoints[size($footRollJoints)-1]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
				
			if (`objExists ("IKLocalOffset"+$fitJointIK[$i]+$side)`)
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			}

		if ($ikLocal[$i] && $ikLocalType[$i]==0 && $heel!="")//$ikLocal=addCtrl
			{
			createNode -n ("RollOffsetOffset"+$heel+$side) -p $parent transform;
			asAlign ("RollOffsetOffset"+$heel+$side) ("RollOffset"+$heel+$side) 1 1 0 0;
			parent ("RollOffset"+$heel+$side) ("RollOffsetOffset"+$heel+$side);
			parent ("RollOffsetOffset"+$heel+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			}

		for ($y=-1;$y<size($footRollJoints)-1;$y++)
			{
			if ($y==-1)
				$startJoint=$ankle;
			else
				$startJoint=$footRollJoints[$y];
			$endJoint=$footRollJoints[$y+1];
			if ($startJoint==$heel || $endJoint==$heel)
				continue;
			$tempString=`ikHandle -n ("IK"+$startJoint+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$startJoint+$side) -ee ("IKX"+$footRollJoints[$y+1]+$side)`;
			rename $tempString[1] ("IK"+$startJoint+"Effector"+$side);
			parent ("IK"+$startJoint+"Handle"+$side) ("Roll"+$footRollJoints[$y+1]+$side);
			setAttr -l 1 ("IK"+$startJoint+"Handle"+$side+".v") 0;
			}

		//parent LegIKHandle to end of RollHierarchy
		if (`objExists ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side)`)
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);
		else
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("Roll"+$footRollJoints[0]+$side);

		//Roll system
		for ($y=0;$y<size($footRollJoints);$y++)
			{
			if ($footRollJoints[$y]!=$heel && $footRollJoints[$y]!=$toes && $footRollJoints[$y]!=$toesEnd)
				continue;
			createNode -n ("RollRoller"+$footRollJoints[$y]+$side) -p ("RollOffset"+$footRollJoints[$y]+$side) transform;
			parent ("RollExtra"+$footRollJoints[$y]+$side) ("RollRoller"+$footRollJoints[$y]+$side);
			}

		if ($heel!="")
			{
			createNode -n ("IKRollHeelClamp"+$fitJointIK[$i]+$side) clamp;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollHeelClamp"+$fitJointIK[$i]+$side+".input.inputR");
			connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollHeelClamp"+$fitJointIK[$i]+$side+".min.minR");
			connectAttr ("IKRollHeelClamp"+$fitJointIK[$i]+$side+".outputR") ("RollRoller"+$heel+$side+".rotateX");
			}

		if ($toes!="")
			{
			createNode -n ("IKRollToesPMA"+$fitJointIK[$i]+$side) plusMinusAverage;
			setAttr ("IKRollToesPMA"+$fitJointIK[$i]+$side+".operation") 2;
			setAttr ("IKRollToesPMA"+$fitJointIK[$i]+$side+".input1D[0]") 1;
//			connectAttr ("IK"+$fitJointIK[$i]+$side+".rollStartAngle") ("IKRollToesPMA"+$fitJointIK[$i]+$side+".input1D[1]");

			createNode -n ("IKRollToesSetRange2"+$fitJointIK[$i]+$side) setRange;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollToesSetRange2"+$fitJointIK[$i]+$side+".valueX");
			setAttr ("IKRollToesSetRange2"+$fitJointIK[$i]+$side+".maxX") 1;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rollStartAngle") ("IKRollToesSetRange2"+$fitJointIK[$i]+$side+".oldMinX");
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rollEndAngle") ("IKRollToesSetRange2"+$fitJointIK[$i]+$side+".oldMaxX");
			connectAttr ("IKRollToesSetRange2"+$fitJointIK[$i]+$side+".outValueX") ("IKRollToesPMA"+$fitJointIK[$i]+$side+".input1D[1]");

			createNode -n ("IKRollToesSetRange1"+$fitJointIK[$i]+$side) setRange;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollToesSetRange1"+$fitJointIK[$i]+$side+".valueX");
			setAttr ("IKRollToesSetRange1"+$fitJointIK[$i]+$side+".maxX") 1;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rollStartAngle") ("IKRollToesSetRange1"+$fitJointIK[$i]+$side+".oldMaxX");

			createNode -n ("IKRollToesMPD1"+$fitJointIK[$i]+$side) multiplyDivide;
			connectAttr ("IKRollToesPMA"+$fitJointIK[$i]+$side+".output1D") ("IKRollToesMPD1"+$fitJointIK[$i]+$side+".input1X");
			connectAttr ("IKRollToesSetRange1"+$fitJointIK[$i]+$side+".outValueX") ("IKRollToesMPD1"+$fitJointIK[$i]+$side+".input2X");

			createNode -n ("IKRollToesMPD2"+$fitJointIK[$i]+$side) multiplyDivide;
			connectAttr ("IKRollToesMPD1"+$fitJointIK[$i]+$side+".outputX") ("IKRollToesMPD2"+$fitJointIK[$i]+$side+".input1X");
			connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollToesMPD2"+$fitJointIK[$i]+$side+".input2X");

			connectAttr ("IKRollToesMPD2"+$fitJointIK[$i]+$side+".outputX") ("RollRoller"+$toes+$side+".rotateX");
			}
		if ($toesEnd!="")
			{
			createNode -n ("IKRollToesEndSetRange"+$fitJointIK[$i]+$side) setRange;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollToesEndSetRange"+$fitJointIK[$i]+$side+".valueX");
			setAttr ("IKRollToesEndSetRange"+$fitJointIK[$i]+$side+".maxX") 1;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rollStartAngle") ("IKRollToesEndSetRange"+$fitJointIK[$i]+$side+".oldMinX");
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rollEndAngle") ("IKRollToesEndSetRange"+$fitJointIK[$i]+$side+".oldMaxX");
			createNode -n ("IKRollToesEndMPD"+$fitJointIK[$i]+$side) multiplyDivide;
			connectAttr ("IKRollToesEndSetRange"+$fitJointIK[$i]+$side+".outValueX") ("IKRollToesEndMPD"+$fitJointIK[$i]+$side+".input1X");
			connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollToesEndMPD"+$fitJointIK[$i]+$side+".input2X");
			connectAttr ("IKRollToesEndMPD"+$fitJointIK[$i]+$side+".outputX") ("RollRoller"+$toesEnd+$side+".rotateX");
			}

		//IKToes (behaves as FKToes but for the IK)
		asCreateController "FK" ($toes+"Temp") $side $toes;
		rename ("FKOffset"+$toes+"Temp"+$side) ("IKOffset"+$toes+$side);
		rename ("FKExtra"+$toes+"Temp"+$side) ("IKExtra"+$toes+$side);
		rename ("FK"+$toes+"Temp"+$side) ("IK"+$toes+$side);
		if (`objExists ("FKFlip"+$toes+"Temp"+$side)`)
			rename ("FKFlip"+$toes+"Temp"+$side) ("IKFlip"+$toes+$side);
		addAttr -k 0 -ln ikLocal -at bool -dv 1 ("IK"+$toes+$side);
		addAttr -k 0 -ln ikLocal -at bool -dv 1 ("IKExtra"+$toes+$side);
		parent ("IKOffset"+$toes+$side) ("Roll"+$toesEnd+$side);
		createNode -n ("AlignIKTo"+$toes+$side) -p ("FKX"+$toes+$side) transform;
		setAttr ("AlignIKTo"+$toes+$side+".rotateOrder") `getAttr ($toes+$side+".rotateOrder")`;
		setAttr ("IK"+$toes+$side+"Shape.overrideColor") 13;
		$parent="IK"+$toes+$side;
		parent ("IK"+$toes+"Handle"+$side) $parent;

		if ($toes!="" && $opm)
			setAttr ("IKX"+$toes+$side+".segmentScaleCompensate") 0;

		//$qtoes aim
		if ($fitJointQtoes[$i]!="")
			{
			xform -ws -ro 0 0 0 ("AlignIKTo"+$toes+$side);

			addAttr -k 1 -ln toesAim -dv 10 -min 0 -max 10 -at double ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side) unitConversion;
			setAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".toesAim") ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".input");

			if ($opm)
				{
				$tempString=`listRelatives -c ("RollOffset"+$toes+$side)`;
				createNode -n ("RollToesAim"+$toes+$side) -p ("RollOffset"+$toes+$side) transform;
				asBlendedMatrixAim $toes $side 1 ("RollOffset"+$toes+$side) ("Pole"+$fitJointIK[$i]+$side) ("IKXOffset"+$fitJointIKStartJoint[$i]+$side) ("RollToesAim"+$toes+$side) 1 0;
//				setAttr ("FKAim"+$toes+"AM"+$side+".secondaryMode") 1;//objUp instead of objRotUp
				//$opm do not have Offset Xform for the child to be parented On, but it`s needed dud to directConnected rotation. so generating this
				createNode -p $tempString[0] -n ("ToesAimUnOffset"+$toes+$side) transform;
				parent ("ToesAimUnOffset"+$toes+$side) ("RollToesAim"+$toes+$side);
				parent $tempString ("ToesAimUnOffset"+$toes+$side);
				//.target[0].rotateWeight not avaiable before Maya2023, so
//				connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("Aim"+$toes+"BM"+$side+".target[0].rotateWeight");
				connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("Aim"+$toes+"BM"+$side+".target[0].weight");
				}
			else
				{
				createNode -n ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) -p ("IKX"+$fitJointIKStartJoint[$i]+$side) transform;
//				parent ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) $parent;
				parent ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) IKFollow;
				pointConstraint -mo ("IK"+$fitJointIK[$i]+$side) ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side);
				createNode -n ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side) reverse;
				connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side+".inputX");

				createNode -n ("RollToesAim"+$toes+$side) -p ("RollOffset"+$toes+$side) transform;
				$tempString=`listRelatives -p ("RollOffset"+$toes+$side)`;
				parent ("RollToesAim"+$toes+$side) $tempString[0];
				aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
					-worldUpObject ("Pole"+$fitJointIK[$i]+$side)
					("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 
					("RollToesAim"+$toes+$side);
				parent ("RollOffset"+$toes+$side) ("RollToesAim"+$toes+$side);
				connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side+".outputX") ("RollToesAim"+$toes+$side+"_aimConstraint1.RollToesAimTargetStatic"+$fitJointIK[$i]+$side+"W0");
				connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("RollToesAim"+$toes+$side+"_aimConstraint1.IKX"+$fitJointIKStartJoint[$i]+$side+"W1");
				}

			//dist driven liftRoll for Qtoes
			addAttr -k 1 -ln liftRoll -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 ("IK"+$fitJointIK[$i]+$side);
			$tempString=`listRelatives -c -type transform ("RollOffset"+$footRollJoints[0]+$side)`;
			createNode -n ("RollToesLiftRoll"+$footRollJoints[0]+$side) -p ("RollOffset"+$footRollJoints[0]+$side) transform;
			parent $tempString ("RollToesLiftRoll"+$footRollJoints[0]+$side);

			createNode -n ("IKLiftRolldistance"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
			$tempString=`listRelatives -p ("IKLiftRolldistance"+$fitJointIK[$i]+$side+"_Shape")`;
			rename $tempString[0] ("IKLiftRolldistance"+$fitJointIK[$i]+$side);
			parent ("IKLiftRolldistance"+$fitJointIK[$i]+$side) ("IKMessure");
			setAttr -l 1 ("IKLiftRolldistance"+$fitJointIK[$i]+$side+".v") 0;

			createNode -n ("IKLiftRolldistance"+$fitJointIKStartJoint[$i]+"DM"+$side) decomposeMatrix;
			connectAttr ("IKXOffset"+$fitJointIKStartJoint[$i]+$side+".worldMatrix") ("IKLiftRolldistance"+$fitJointIKStartJoint[$i]+"DM"+$side+".inputMatrix");
			connectAttr ("IKLiftRolldistance"+$fitJointIKStartJoint[$i]+"DM"+$side+".outputTranslate") ("IKLiftRolldistance"+$fitJointIK[$i]+$side+".startPoint");

			createNode -n ("IKLiftRolldistance"+$fitJointIK[$i]+"DM"+$side) decomposeMatrix;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".worldMatrix") ("IKLiftRolldistance"+$fitJointIK[$i]+"DM"+$side+".inputMatrix");
			connectAttr ("IKLiftRolldistance"+$fitJointIK[$i]+"DM"+$side+".outputTranslate") ("IKLiftRolldistance"+$fitJointIK[$i]+$side+".endPoint");

			$defaultDistance=`getAttr ("IKLiftRolldistance"+$fitJointIK[$i]+$side+"Shape.distance")`;

			//divide by Main.sy scale
			createNode -n ("IKLiftRollMainScaler"+$fitJointIK[$i]+"MPD"+$side) multiplyDivide;
			setAttr ("IKLiftRollMainScaler"+$fitJointIK[$i]+"MPD"+$side+".operation") 2;
			connectAttr ("IKLiftRolldistance"+$fitJointIK[$i]+$side+"Shape.distance") ("IKLiftRollMainScaler"+$fitJointIK[$i]+"MPD"+$side+".input1X");
			connectAttr MainScaleMultiplyDivide.outputY ("IKLiftRollMainScaler"+$fitJointIK[$i]+"MPD"+$side+".input2X");

			createNode -n ("IKLiftRollPMA"+$fitJointIK[$i]+$side) plusMinusAverage;
			setAttr ("IKLiftRollPMA"+$fitJointIK[$i]+$side+".operation") 2;
//			connectAttr ("IKLiftRolldistance"+$fitJointIK[$i]+$side+"Shape.distance") ("IKLiftRollPMA"+$fitJointIK[$i]+$side+".input1D[0]");
			connectAttr ("IKLiftRollMainScaler"+$fitJointIK[$i]+"MPD"+$side+".outputX") ("IKLiftRollPMA"+$fitJointIK[$i]+$side+".input1D[0]");
			setAttr ("IKLiftRollPMA"+$fitJointIK[$i]+$side+".input1D[1]") $defaultDistance;

			createNode -n ("IKLiftRollNormalizeMDL"+$fitJointIK[$i]+$side) multDoubleLinear;
			connectAttr ("IKLiftRollPMA"+$fitJointIK[$i]+$side+".output1D") ("IKLiftRollNormalizeMDL"+$fitJointIK[$i]+$side+".input1");
//			setAttr ("IKLiftRollNormalizeMDL"+$fitJointIK[$i]+$side+".input2") (10.0/$defaultDistance);

			createNode -n tempSampler -p $fitJointIKEndJoint[$i] transform;
			parent -w tempSampler;
			$yy=1;
			if (`getAttr ($fitJointIKEndJoint[$i]+".joz")`<0)
				$yy=-1;
			$rot=`getAttr tempSampler.r`;
			setAttr ("IKLiftRollNormalizeMDL"+$fitJointIK[$i]+$side+".input2") (((90+$rot[1])/$defaultDistance)/10.0*$yy);
			delete tempSampler;

			createNode -n ("IKLiftRollMDL"+$fitJointIK[$i]+$side) multDoubleLinear;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".liftRoll") ("IKLiftRollMDL"+$fitJointIK[$i]+$side+".input1");
			connectAttr ("IKLiftRollNormalizeMDL"+$fitJointIK[$i]+$side+".output") ("IKLiftRollMDL"+$fitJointIK[$i]+$side+".input2");

			createNode -n ("IKLiftRollClamp"+$fitJointIK[$i]+$side) clamp;

			if ($yy==1)
				{
				setAttr ("IKLiftRollClamp"+$fitJointIK[$i]+$side+".minR") -999;
				setAttr ("IKLiftRollClamp"+$fitJointIK[$i]+$side+".maxR") 0;//($rot[1]*-1)
				}
			else
				{
				setAttr ("IKLiftRollClamp"+$fitJointIK[$i]+$side+".minR") 0;//($rot[1]*-1)
				setAttr ("IKLiftRollClamp"+$fitJointIK[$i]+$side+".maxR") 999;
				}
			connectAttr ("IKLiftRollMDL"+$fitJointIK[$i]+$side+".output") ("IKLiftRollClamp"+$fitJointIK[$i]+$side+".inputR");
			connectAttr ("IKLiftRollClamp"+$fitJointIK[$i]+$side+".outputR") ("RollToesLiftRoll"+$footRollJoints[0]+$side+".rx");
			}
		}

//Advanced LegAim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$isIKStart[$i])
			continue;
		$tempString=`listRelatives -p $fitJoints[$i]`;
		$scapula=$tempString[0];
		if ($scapula!="")
			{
			$tempString[0]=`asLabel $scapula`;
			if (!`gmatch $tempString[0] "*LegAim*"`)
				continue;
			}

		addAttr -k 1 -ln legAim -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
		createNode -n ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side) unitConversion;
		setAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".legAim") ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".input");

		if ($opm)
			{
			$tempString=`listRelatives -c ("FKOffset"+$scapula+$side)`;
			createNode -n ("LegAim"+$scapula+$side) -p ("FKOffset"+$scapula+$side) transform;
			parent $tempString ("LegAim"+$scapula+$side);

			asBlendedMatrixAim $scapula $side $b ("FKOffset"+$scapula+$side) ("FKOffset"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAim"+$scapula+$side) 2 1;
			//.target[0].rotateWeight not avaiable before Maya2023, so
//			connectAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".output") ("Aim"+$scapula+"BM"+$side+".target[0].rotateWeight");
			connectAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".output") ("Aim"+$scapula+"BM"+$side+".target[0].weight");
			}
		else
			{
			$tempString=`listRelatives -p ("FKOffset"+$scapula+$side)`;
			$parent=$tempString[0];
			createNode -n ("LegAim"+$scapula+$side) -p $parent transform;
			asAlign ("LegAim"+$scapula+$side) ("FKOffset"+$scapula+$side) 1 0 0 0;
			duplicate -n ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
			duplicate -n ("LegAimOff"+$scapula+$side) ("LegAim"+$scapula+$side);

			aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
			asAlign ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) 1 1 0 0;
			orientConstraint ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
			parent ("FKOffset"+$scapula+$side) ("LegAim"+$scapula+$side);

			createNode -n ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side) multiplyDivide;
			connectAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input1X");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input2X");

			createNode -n ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side) reverse;
			connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".inputX");
			connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOn"+$scapula+$side+"W1");
			connectAttr ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOff"+$scapula+$side+"W0");
			}

		createNode -n ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistanceForLegAim"+$fitJointIK[$i]+$side);
		parent ("IKdistanceForLegAim"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".v") 0;

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".v") 0;
		parent ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side) IKMessure;
		duplicate -n ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		connectAttr ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".startPoint");
		connectAttr ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".endPoint");
		pointConstraint ("LegAim"+$scapula+$side) ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side);
		pointConstraint ("IK"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);

		$defaultDistance=`getAttr ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"Shape.distance")`;
		$defaultAngleDirection=`getAttr ($fitJoints[$i]+$side+".jointOrientZ")`;
		$defaultAngle=90;
		if ($defaultAngleDirection>0)
			$defaultAngle=-90;
		$defaultUnstretchedLenght=0;
		$parent=$fitJointIKEndJoint[$i];
		while ($parent!=$fitJointIKStartJoint[$i])
			{
			$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;
			$tempString=`listRelatives -p $parent`;
			$parent=$tempString[0];
			}
		$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;

		createNode -n tempSampler -p ("FK"+$scapula+$side) transform;
		parent tempSampler ("LegAim"+$scapula+$side);
		$defaultOffsetAngle=`getAttr tempSampler.rz`;
		delete tempSampler;
		}

//Advanced Scaling
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

//		if (($fitJointIsEndJoint[$i] || $fitJointChild[$i]=="") && $fitJointIK[$i]=="")
//			continue;

		if ($fitJointIK[$i]!="")
			{
			createNode -n ("ScaleBlend"+$fitJoints[$i]+$side) blendColors;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color1") 1 1 1;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color2") 1 1 1;

			if ($opm && !$isIKEnd[$i])
				{
				createNode -n ("ScaleBlendCM"+$fitJoints[$i]+$side) composeMatrix;
				for ($y=0;$y<size($RGB);$y++)
					{
					if ($y==0 && !$isIKEnd[$i])//skip scaleX as it make Ik stretchy wrong, but needed at end:IkWrist needs 3 axis 
						continue;
					connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output"+$RGB[$y]) ("ScaleBlendCM"+$fitJoints[$i]+$side+".inputScale"+$XYZ[$y]);
					}
				if (`objExists ($fitJoints[$i]+"MM"+$side)`)
					asInsertMMPlug ("ScaleBlendCM"+$fitJoints[$i]+$side+".outputMatrix") ($fitJoints[$i]+"MM"+$side) 0;
				}
			if (!$opm || $fitJointBendyJoints[$i])//used to be "else", but need to include OPM when using BendyJoints
				{
				for ($y=0;$y<size($RGB);$y++)
					{
					if (`objExists ("FK"+$fitJoints[$i]+$side)`)
						connectAttr ("FK"+$fitJoints[$i]+$side+".scale"+$XYZ[$y]) ("ScaleBlend"+$fitJoints[$i]+$side+".color2"+$RGB[$y]);
					if (!$fitJointBendyJoints[$i])
						connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output"+$RGB[$y]) ($fitJoints[$i]+$side+".scale"+$XYZ[$y]);
					}
				}
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("ScaleBlend"+$fitJoints[$i]+$side+".blender");
			}

		else if (`objExists ("FK"+$fitJoints[$i]+$side)`)// && !`gmatch $fitJoints[$i] "*Part[0-9]*"`
			{
			if (!$opm)
				{
				connectAttr ("FK"+$fitJoints[$i]+$side+".sx") ($fitJoints[$i]+$side+".sx");
				connectAttr ("FK"+$fitJoints[$i]+$side+".sy") ($fitJoints[$i]+$side+".sy");
				connectAttr ("FK"+$fitJoints[$i]+$side+".sz") ($fitJoints[$i]+$side+".sz");
				}
			}

		}

for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJoints[$i]==$fitJointIKEndJoint[$i] && $isIKEnd[$i])
			{
			if ($fitJointIKSolver[$i]=="ikRPsolver")
				{
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sx") ("ScaleBlend"+$fitJoints[$i]+$side+".color1R");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sy") ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sz") ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
//				if (!$opm)//also for OPM as of v 6.2416
					connectAttr ("IK"+$fitJointIK[$i]+$side+".scale") ("IKX"+$fitJoints[$i]+$side+".scale");
				//we have no accurate way to space-translate scale, for non-uniform IK scaling, so we assume T-pose (only be correct for T-pose)
				if (`gmatch $fitJointIK[$i] "*Leg*"` && !$ikLocal[$i])
					{
					connectAttr -f ("IK"+$fitJointIK[$i]+$side+".scaleX") ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
					connectAttr -f ("IK"+$fitJointIK[$i]+$side+".scaleY") ("ScaleBlend"+$fitJoints[$i]+$side+".color1R");
					connectAttr -f ("IK"+$fitJointIK[$i]+$side+".scaleZ") ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
					}
				if (`gmatch $fitJointIK[$i] "*Arm*"` && !$ikLocal[$i])
					{
					connectAttr -f ("IK"+$fitJointIK[$i]+$side+".scaleY") ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
					connectAttr -f ("IK"+$fitJointIK[$i]+$side+".scaleZ") ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
					}
				}

/*
			//ikSpline scaler ($opm)
			if ($fitJointIKSolver[$i]=="ikSplineSolver" && $opm)
				{
				for ($z=1;$z<$fitJointIKNumCtrls[$i]+1;$z++)
					{
					createNode -n ("IKScale"+$fitJointIK[$i]+$z+"MM"+$side) multMatrix;

//					connectAttr ("FKOffset"+$fitJointIKStartJoint[$i]+$side+".worldMatrix") ("IKScale"+$fitJointIK[$i]+$z+"MM"+$side+".matrixIn[0]");
					$m=`getAttr ("FKOffset"+$fitJointIKStartJoint[$i]+$side+".worldMatrix")`;
					setAttr ("IKScale"+$fitJointIK[$i]+$z+"MM"+$side+".matrixIn[0]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];

					connectAttr ("IK"+$fitJointIK[$i]+$z+$side+".matrix") ("IKScale"+$fitJointIK[$i]+$z+"MM"+$side+".matrixIn[1]");
					createNode -n ("IKScale"+$fitJointIK[$i]+$z+"DM"+$side) decomposeMatrix;
					connectAttr ("IKScale"+$fitJointIK[$i]+$z+"MM"+$side+".matrixSum") ("IKScale"+$fitJointIK[$i]+$z+"DM"+$side+".inputMatrix");
					}


				$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
				for ($y=1;$y<size($IKJoints);$y++)
					{
					createNode -n ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side) multiplyDivide;
					for ($z=0;$z<size($RGB);$z++)
						connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".output"+$XYZ[$z]) ("ScaleBlend"+$IKJoints[$y]+$side+".color1"+$RGB[$z]);

					//Twist-worldUpMatrix will find 2 nearest ctrls, so we use values and connect scale in the wtist section for OPM
//					if ($y==0 || $y==(size($IKJoints)-1))
//						connectAttr ("IKScale"+$fitJointIK[$i]+($y+1)+"DM"+$side+".outputScale") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
//						print ("connectAttr IKScale"+$fitJointIK[$i]+"1"+"DM"+$side+".outputScale IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1;\n");
//					else
						{
						$tempString=`listConnections -s 1 -d 0 ("IKMPUpBM"+$IKJoints[$y]+$side+".inputMatrix")`;
						$tempString=`listRelatives -p $tempString[0]`;
						$tempString[0]=`substitute ("IK"+$fitJointIK[$i]) $tempString[0] ""`;
						$closestIkCtrlNr1=`substitute $side $tempString[0] ""`;
						$tempString=`listConnections -s 1 -d 0 ("IKMPUpBM"+$IKJoints[$y]+$side+".target[0].targetMatrix")`;
						$tempString=`listRelatives -p $tempString[0]`;
						$tempString[0]=`substitute ("IK"+$fitJointIK[$i]) $tempString[0] ""`;
						$closestIkCtrlNr2=`substitute $side $tempString[0] ""`;
						$weight=`getAttr ("IKMPUpBM"+$IKJoints[$y]+$side+".target[0].weight")`;

	//print ($IKJoints[$y]+" : Nr1="+$closestIkCtrlNr1 +" : Nr2="+$closestIkCtrlNr2+" : "+$weight+"\n");

	//					connectAttr ("IKScale"+$fitJointIK[$i]+$closestIkCtrlNr1+"DM"+$side+".outputScale") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
						createNode -n ("IKScale"+$IKJoints[$y]+"BC"+$side) blendColors;
						connectAttr ("IKScale"+$fitJointIK[$i]+$closestIkCtrlNr1+"DM"+$side+".outputScale") ("IKScale"+$IKJoints[$y]+"BC"+$side+".color2");
						connectAttr ("IKScale"+$fitJointIK[$i]+$closestIkCtrlNr2+"DM"+$side+".outputScale") ("IKScale"+$IKJoints[$y]+"BC"+$side+".color1");
						setAttr ("IKScale"+$IKJoints[$y]+"BC"+$side+".blender") $weight;
						connectAttr ("IKScale"+$IKJoints[$y]+"BC"+$side+".output") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
						}
					}
				}
*/
			//ikSpline scaler (!$opm)
			if ($fitJointIKSolver[$i]=="ikSplineSolver")// && !$opm
				{
				if (!`objExists IKScaler`)
					{
					createNode -n IKScaler -p IKSystem transform;
					if ($opm)
						connectAttr MainScaleMultiplyDivide.output IKScaler.s;
					}
				$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
				for ($y=0;$y<size($IKJoints);$y++)
					{
					createNode -n ("IKScaler"+$IKJoints[$y]+$side) -p IKScaler transform;
					createNode -n ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side) multiplyDivide;
					connectAttr ("IKScaler"+$IKJoints[$y]+$side+".scale") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
					for ($z=0;$z<size($RGB);$z++)
						connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".output"+$XYZ[$z]) ("ScaleBlend"+$IKJoints[$y]+$side+".color1"+$RGB[$z]);
					for ($z=0;$z<$fitJointIKNumCtrls[$i];$z++)
						{
		        $yy=(1.0/(size($IKJoints)-1))*$y;
		        $zz=(1.0/($fitJointIKNumCtrls[$i]-1))*$z;
		        $weight=1-(abs($yy-$zz));
		        $weight=`smoothstep 0.5 1 $weight`;
						//first and last to ensure fully weighted to start/end ctrl
						if ($y==0 || $y==size($IKJoints)-1)
							if ($z!=0 && $z!=$fitJointIKNumCtrls[$i]-1)
								$weight=0;
						scaleConstraint -w $weight ("IK"+$fitJointIK[$i]+($z+1)+"LocalOrient2"+$side) ("IKScaler"+$IKJoints[$y]+$side);
						}
					$scalerWeight=((1.0 / (`size($IKJoints)`+1))*($y+1))*2;
					if ($scalerWeight>1)
						$scalerWeight=1-($scalerWeight-1);
					addAttr -k 1 -ln scalerWeight -at double -dv $scalerWeight ("IKScaler"+$IKJoints[$y]+$side);
					}
				}
			}
		}

//Advanced Stretchy (arms/legs)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if ($isIKBelowIKEnd[$i])
			continue;
		if ($fitJointIKSolver[$i]!="ikRPsolver")
			continue;

		addAttr -k 1 -ln stretchy -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln antiPop -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);

		createNode -n ("IKSetRangeStretch"+$fitJointIK[$i]+$side) setRange;
		createNode -n ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side) setRange;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".stretchy") ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".antiPop") ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".valueX");

		createNode -n ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) transform;
		asAlign ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 1 0 0;
		$tempString=`listRelatives -p ("IK"+$fitJointIK[$i]+"Handle"+$side)`;
		parent ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) $tempString[0];

		if ($opm)
			{
			//use distanceBetween instead of distanceDimShape, as it allows for matrix input
			createNode -n ("IKdistance"+$fitJointIK[$i]+$side+"Shape") distanceBetween;
//			connectAttr ("IKXOffset"+$fitJointIKStartJoint[$i]+$side+".worldMatrix") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.inMatrix1");
//			connectAttr ("IKmessureConstrainTo"+$fitJointIK[$i]+$side+".worldMatrix") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.inMatrix2");
			if (!`objExists MainPM_M`)
				{
				createNode -n MainPM_M pickMatrix;
				connectAttr Main.worldInverseMatrix MainPM_M.inputMatrix;
				}
			createNode -n ("IKXOffsetMM"+$fitJointIKStartJoint[$i]+$side) multMatrix;
			createNode -n ("IKmessureConstrainToMM"+$fitJointIK[$i]+$side) multMatrix;
			connectAttr ("IKXOffset"+$fitJointIKStartJoint[$i]+$side+".worldMatrix") ("IKXOffsetMM"+$fitJointIKStartJoint[$i]+$side+".matrixIn[0]");
			connectAttr ("IKmessureConstrainTo"+$fitJointIK[$i]+$side+".worldMatrix") ("IKmessureConstrainToMM"+$fitJointIK[$i]+$side+".matrixIn[0]");
			connectAttr MainPM_M.outputMatrix ("IKXOffsetMM"+$fitJointIKStartJoint[$i]+$side+".matrixIn[1]");
			connectAttr MainPM_M.outputMatrix ("IKmessureConstrainToMM"+$fitJointIK[$i]+$side+".matrixIn[1]");
			connectAttr ("IKXOffsetMM"+$fitJointIKStartJoint[$i]+$side+".matrixSum") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.inMatrix1");
			connectAttr ("IKmessureConstrainToMM"+$fitJointIK[$i]+$side+".matrixSum") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.inMatrix2");
			}
		else
			{
			$tempString=`spaceLocator`;
			rename $tempString[0] ("IKmessureLoc1"+$fitJointIK[$i]+$side);
			setAttr -l 1 ("IKmessureLoc1"+$fitJointIK[$i]+$side+".v") 0;
			pointConstraint ("IKX"+$fitJointIKStartJoint[$i]+$side)  ("IKmessureLoc1"+$fitJointIK[$i]+$side);
			parent ("IKmessureLoc1"+$fitJointIK[$i]+$side) ("IKMessure");
			$tempString=`spaceLocator`;
			rename $tempString[0] ("IKmessureLoc2"+$fitJointIK[$i]+$side);
			setAttr -l 1 ("IKmessureLoc2"+$fitJointIK[$i]+$side+".v") 0;
			asAlign ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 0 0 0;
			parent ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IKmessureLoc1"+$fitJointIK[$i]+$side);

			pointConstraint ("IKmessureConstrainTo"+$fitJointIK[$i]+$side)  ("IKmessureLoc2"+$fitJointIK[$i]+$side);

			createNode -n ("IKdistance"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
			$tempString=`listRelatives -p ("IKdistance"+$fitJointIK[$i]+$side+"_Shape")`;
			rename $tempString[0] ("IKdistance"+$fitJointIK[$i]+$side);
			parent ("IKdistance"+$fitJointIK[$i]+$side) ("IKMessure");
			setAttr -l 1 ("IKdistance"+$fitJointIK[$i]+$side+".v") 0;
			connectAttr ("IKmessureLoc2"+$fitJointIK[$i]+$side+".translate") ("IKdistance"+$fitJointIK[$i]+$side+".endPoint");
			}
		createNode -n ("IKmessureDiv"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".operation") 2;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".input2X") $ikLenght[$i];

		$distance=`getAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape.distance")`;
		createNode -n ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".attributesBlender");
		addAttr -ln antiPop -at double ("IKdistance"+$fitJointIK[$i]+$side+"Shape");
		setDrivenKeyframe -itt "spline" -ott "linear" -v $ikLenght[$i] -dv $ikLenght[$i] -cd ("IKdistance"+$fitJointIK[$i]+$side+"Shape.distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.antiPop");
		setKeyframe -itt "spline" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.1) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*1.2) -f ($ikLenght[$i]*1.2) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "linear" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.70) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*0.9) -f ($ikLenght[$i]*0.85) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		selectKey ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setInfinity -poi linear;
		duplicate -n ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		cutKey -in 0 -in 1 -in 2 ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape.distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.input");

		if ($fitJointIKMiddleJoint[$i]==$fitJointIKStartJoint[$i])//no knee joint, stretchy should also allow for `shortening`
			{
			setAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.preInfinity") 1;
			cutKey -in 0 -in 1 -in 2 ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
			setAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop.preInfinity") 1;
			}

		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[1]");

		createNode -n ("IKdistanceClamp"+$fitJointIK[$i]+$side) clamp;
		setAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".maxR") $ikLenght[$i];
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKdistanceClamp"+$fitJointIK[$i]+$side+".inputR");
		createNode -n ("IKmessureBlendStretch"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".attributesBlender");
		connectAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".outputR") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[1]");
		connectAttr ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".output") ("IKmessureDiv"+$fitJointIK[$i]+$side+".input1X");

		addAttr -k 1 -ln lock -at double -min 0 -max $udMax ("Pole"+$fitJointIK[$i]+$side);
//		if (!$opm)
			{
			createNode -n ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
			setAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+".lock") ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
			}

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			$temp[0]=`getAttr ($tempString[0]+".tx")`;
			createNode -n ($tempString[0]+"_IKmessureDiv"+$side) multiplyDivide;
			setAttr ($tempString[0]+"_IKmessureDiv"+$side+".input2X") $temp[0];
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input1X");
			//IkLengtControl
			addAttr -k 1 -ln ("Lenght"+($a+1)) -at double -dv 1 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ($tempString[0]+"_IKLenght"+$side) multiplyDivide;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".Lenght"+($a+1)) ($tempString[0]+"_IKLenght"+$side+".input1X");
			setAttr ($tempString[0]+"_IKLenght"+$side+".input2X") $temp[0];
			connectAttr ($tempString[0]+"_IKLenght"+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input2X");
			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			//IkFatnessControl
			addAttr -k 1 -ln ("Fatness"+($a+1)) -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("fatness"+$tempString[0]) plusMinusAverage;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".Fatness"+($a+1)) ("fatness"+$tempString[0]+".input1D[0]");

			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			//pole.lock
			createNode -n ("PoleLockBlender"+$tempString[0]) blendTwoAttr;
			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ("PoleLockBlender"+$tempString[0]+".input[0]");
			connectAttr ("PoleLockBlender"+$tempString[0]+".output") ($tempString[0]+".tx");
//			if ($opm)
//				connectAttr ("Pole"+$fitJointIK[$i]+$side+".lock")  ("PoleLockBlender"+$tempString[0]+".attributesBlender");
//			else
				connectAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".output")  ("PoleLockBlender"+$tempString[0]+".attributesBlender");
			createNode -n ($tempString[0]+"Distance") distanceBetween;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix1");
			if ($opm)
				{
				if ($a==0)
					connectAttr ("IKXOffset"+$fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
				else
					connectAttr ("IK"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
				}
			else
				{
				if ($a==0)
					connectAttr ("IKMessureFrom"+$fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
				else
					connectAttr ("IKmessureLoc2"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");//modified for Qtoes
				}
			createNode -n ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side) unitConversion;
			setAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".conversionFactor") $b;
			//divide by Main.sy scale
			createNode -n ("PoleLockMainScaler"+$tempString[0]) multiplyDivide;
			setAttr ("PoleLockMainScaler"+$tempString[0]+".operation") 2;
			connectAttr ($tempString[0]+"Distance.distance") ("PoleLockMainScaler"+$tempString[0]+".input1X");
			connectAttr MainScaleMultiplyDivide.outputY ("PoleLockMainScaler"+$tempString[0]+".input2X");
			connectAttr ("PoleLockMainScaler"+$tempString[0]+".outputX") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");

			connectAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".output") ("PoleLockBlender"+$tempString[0]+".input[1]");

			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}
		}

//LegLock
for ($i=0;$i<size($fitJoints);$i++)
	{
	$side=$fitJointSide[$i];
	$parentSide=$fitJointParentSide[$i];
	if ($b==-1 && $fitJointSide[$i]=="_M") continue;
	if ($b==-1) $side="_L";
	if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
	if ($b==$fitJointNoMirrorCode[$i]) continue;

	if ($fitJoints[$i]!="Root")
		continue;

	if ($opm)
		{
		createNode -n LegLockConstrainedDM_M decomposeMatrix;

		createNode -n LegLockConstrainedMM_M multMatrix;
		connectAttr Root_M.worldMatrix LegLockConstrainedMM_M.matrixIn[0];
		connectAttr RootSystem.worldInverseMatrix LegLockConstrainedMM_M.matrixIn[1];

		connectAttr LegLockConstrainedMM_M.matrixSum LegLockConstrainedDM_M.inputMatrix;
		connectAttr LegLockConstrainedDM_M.outputTranslate LegLockConstrained.t;
		if ($fitJointIK[$i]=="")
			connectAttr LegLockConstrainedDM_M.outputRotate LegLockConstrained.r;
		else
			{
			createNode -n LegLockConstrainedBM_M blendMatrix;
			connectAttr ("FKXRoot"+$side+".worldMatrix") LegLockConstrainedBM_M.inputMatrix;
			connectAttr ("IK"+$fitJointIK[$i]+"1LocalOrient3"+$side+".worldMatrix") LegLockConstrainedBM_M.target[0].targetMatrix;
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") LegLockConstrainedBM_M.target[0].weight;
			createNode -n LegLockConstrainedDM2_M decomposeMatrix;
			connectAttr LegLockConstrainedBM_M.outputMatrix LegLockConstrainedDM2_M.inputMatrix;
			connectAttr LegLockConstrainedDM2_M.outputRotate LegLockConstrained.r;
			}
		}
	else
		{
		pointConstraint Root_M LegLockConstrained;
		if ($fitJointIK[$i]=="")
			orientConstraint Root_M LegLockConstrained;
		else
			{
			orientConstraint ("FKXRoot"+$side) ("IK"+$fitJointIK[$i]+"1LocalOrient3"+$side) LegLockConstrained;
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("LegLockConstrained_orientConstraint1.IK"+$fitJointIK[$i]+"1LocalOrient3_MW1");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ("LegLockConstrained_orientConstraint1.FKXRoot_MW0");
			}
		}
	}

//HipSwinger
int $buildHipSwinger=`objExists ($hipSwingerJoint+"_M")`;
for ($i=0;$i<size($fitJoints);$i++)
	if (`asLabel $fitJoints[$i]`=="Root")
		if (`attributeExists hipSwinger $fitJoints[$i]`)
			if (`getAttr ($fitJoints[$i]+".hipSwinger")`==0)
				$buildHipSwinger=0;
if ($buildHipSwinger)
	{
	asCreateController "HipSwinger" "" "_M" $hipSwingerJoint;
	if (`objExists FKIKBlendSpineCondition_M`)
		connectAttr FKIKBlendSpineCondition_M.outColorG HipSwingerOffset_M.v;
	asAlign HipSwingerOffset_M Root_M 0 1 0 0;
	parent HipSwinger_M HipSwingerOffset_M;
	delete HipSwingerExtra_M;
	parent HipSwingerOffset_M FKSystem;
	$pos=`xform -q -ws -t Root`;
	delete `pointConstraint Root $hipSwingerJoint HipSwingerOffset_M`;
	setAttr HipSwingerOffset_M.tx (`getAttr Root.fat`*`getAttr Root.fatWidth`*-1.4);
	parent HipSwingerOffset_M FKRoot_M;
	asLockAttr HipSwinger_M 1 0 1 0;

	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints Root`)
		$inbetweenJoints=`getAttr Root.inbetweenJoints`;

	if ($opm)//OPM HipSwinger
		{
		//changing .w can break hipSwinger, so `locking`
		for ($y=1;$y<$inbetweenJoints;$y++)
			if (`attributeExists ("w"+$y) FKRoot_M`)
				setAttr -cb 0 ("FKRoot_M.w"+$y);
//		catchQuiet (`parent FKXRoot_M FKOffsetRoot_M`);//could be already by inbetween //Removed in v6.2272
		createNode -n HipSwingReverse -p FKRoot_M transform;
		parent HipSwingReverse FKOffsetRoot_M;
		asAlign HipSwingReverse ($hipSwingerJoint+"_M") 1 0 0 0;

		$parent="HipSwingReverse";

		createNode -n HipSwingReversePartBM_M blendMatrix;
		connectAttr HipSwinger_M.matrix ("HipSwingReversePartBM_M.target[0].targetMatrix");
		$inbetweenWeight=1;
		if ($inbetweenJoints)
			$inbetweenWeight=1.0/$inbetweenJoints;
		setAttr ("HipSwingReversePartBM_M.target[0].weight") $inbetweenWeight;//($inbetweenJoints+1)

		createNode -n HipSwingPartDM_M decomposeMatrix;
		setAttr HipSwingPartDM_M.inputRotateOrder `getAttr Root_M.rotateOrder`;
		connectAttr HipSwingReversePartBM_M.outputMatrix HipSwingPartDM_M.inputMatrix;

		if ($inbetweenJoints)
			for ($y=1;$y<$inbetweenJoints+2;$y++)
				{
				createNode -n ("HipSwingReversePart"+($inbetweenJoints+1-$y)) -p $parent transform;
				setAttr ("HipSwingReversePart"+($inbetweenJoints+1-$y)+".rotateOrder") `getAttr Root_M.rotateOrder`;
				setAttr ("HipSwingReversePart"+($inbetweenJoints+1-$y)+".tx") (`getAttr ("RootPart1.tx")`*-1);
				connectAttr ("HipSwingPartDM_M.outputRotate") ("HipSwingReversePart"+($inbetweenJoints+1-$y)+".r");
				$parent="HipSwingReversePart"+($inbetweenJoints+1-$y);
				}

		for ($y=1;$y<$inbetweenJoints;$y++)
			parent ("InbetweenBaseRootPart"+$y+"_M") HipSwingReversePart0;

		createNode -n HipSwingReverseRoot -p HipSwingReverse transform;
		asAlign HipSwingReverseRoot Root_M 1 1 0 0;
		if ($inbetweenJoints)
			parent HipSwingReverseRoot HipSwingReversePart1;

		if ($inbetweenJoints)
			parent RootFKPS_M HipSwingReverseRoot;
		else
			{
			createNode -n FKXMMRoot_M multMatrix;
			connectAttr HipSwingReverseRoot.worldMatrix FKXMMRoot_M.matrixIn[0];
			connectAttr FKOffsetRoot_M.worldInverseMatrix FKXMMRoot_M.matrixIn[1];
			connectAttr FKXMMRoot_M.matrixSum FKXRoot_M.offsetParentMatrix;
			connectAttr HipSwinger_M.r HipSwingReverse.r;
			}

		//make sure legs, tails etc follow hipSwung root(even if not $firstInIk and not FirstAfterIK)
		$tempString=`listRelatives -c FKRoot_M`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if ($tempString[$y]=="FKPS"+$hipSwingerJoint+"_M")
				continue;
			if (`gmatch $tempString[$y] "FKPS*"`)
				parent $tempString[$y] FKXRoot_M;
			}

		//hack to make OPM HipSwinger work correctly when $inbetweenJoints==0 (naughty hack uses constraint in OPM)
		if (!$inbetweenJoints && `objExists ($hipSwingerJoint+"NoShearMM_M")`)
			orientConstraint -mo FKRoot_M ("FKOffset"+$hipSwingerJoint+"_M");
		}
	else//Non-OPM HipSwinger
		{
		createNode -n HipSwingerStabilizerTarget transform;
		setAttr HipSwingerStabilizerTarget.rotateOrder `getAttr Root_M.rotateOrder`;
		if ($inbetweenJoints)
			asAlign HipSwingerStabilizerTarget HipSwinger_M 1 1 0 0;
		else
			{
			asAlign HipSwingerStabilizerTarget ("FKOffset"+$hipSwingerJoint+"_M") 1 1 0 0;
			asAlign HipSwingerStabilizerTarget $hipSwingerJoint 0 1 0 0;
			}

		parent HipSwingerStabilizerTarget FKRoot_M;
		createNode -n HipSwingReverse -p FKRoot_M transform;
		asAlign HipSwingReverse ($hipSwingerJoint+"_M") 1 0 0 0;

		$parent="HipSwingReverse";
		$inbetweenJoints=0;
		if (`attributeExists inbetweenJoints Root`)
			$inbetweenJoints=`getAttr Root.inbetweenJoints`;
		for ($y=1;$y<$inbetweenJoints+1;$y++)
			{
			createNode -n ("HipSwingReversePart"+$y) -p $parent transform;
			setAttr ("HipSwingReversePart"+$y+".rotateOrder") `getAttr Root_M.rotateOrder`;
			setAttr ("HipSwingReversePart"+$y+".tx") (`getAttr ("RootPart"+$y+"_M.tx")`*-1);
			duplicate -n ("HipSwingReverseXPart"+$y) ("HipSwingReversePart"+$y);
			if ($y>1)
				parent ("HipSwingReverseXPart"+$y) HipSwingReverse;
			orientConstraint ("HipSwingReversePart"+$y) ("HipSwingReverseXPart"+$y);
			$parent="HipSwingReversePart"+$y;
			}
		createNode -n HipSwingReverseRoot transform;
		asAlign HipSwingReverseRoot Root_M 1 1 0 0;

		$inbetweenWeight=1;
		if ($inbetweenJoints)
			$inbetweenWeight=1.0/$inbetweenJoints;

		for ($y=1;$y<$inbetweenJoints+1;$y++)
			{
			orientConstraint HipSwingerStabilizerTarget HipSwinger_M ("HipSwingReversePart"+$y);
			setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwingerStabilizerTargetW0") (1-($inbetweenWeight*$y));//($inbetweenJoints+1)
			setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwinger_MW1") ($inbetweenWeight*$y);
			setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.interpType") 2;
			}

		//inbetween done by constraint-blend, hipSwing done with constraint-offset
		if (!$opm)
			for ($y=1;$y<$inbetweenJoints+1;$y++)
				{
				if ($y==$inbetweenJoints)
					connectAttr ("HipSwingReverseXPart"+$y+".r") InbetweenRootPart0_M_orientConstraint1.offset;
				else
					connectAttr ("HipSwingReverseXPart"+($inbetweenJoints-$y)+".r") ("InbetweenRootPart"+$y+"_M_orientConstraint1.offset");
				}

		createNode -n HipSwingerStabilizer transform;
		setAttr HipSwingerStabilizer.rotateOrder `getAttr Root_M.rotateOrder`;
		if ($inbetweenJoints==0)
			{
			parent HipSwingReverseRoot HipSwingReverse;
			orientConstraint HipSwinger_M HipSwingReverse;
			parentConstraint HipSwingReverseRoot FKXRoot_M;

			parent HipSwingerStabilizer ("FKOffset"+$hipSwingerJoint+"_M");
			xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
			if (`objExists ("FKGlobalStatic"+$hipSwingerJoint+"_M")`)
				parent ("FKGlobalStatic"+$hipSwingerJoint+"_M") HipSwingerStabilizer;
			else
				parent ("FKExtra"+$hipSwingerJoint+"_M") HipSwingerStabilizer;
			}
		else
			{
			parent HipSwingReverseRoot ("HipSwingReversePart"+$inbetweenJoints);
			orientConstraint HipSwinger_M HipSwingReverseRoot;
			pointConstraint HipSwingReverseRoot FKXRoot_M;

			parent HipSwingerStabilizer ("FKXRootPart"+$inbetweenJoints+"_M");
			xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
			if (!$opm)
				if (`objExists ("FKOffset"+$hipSwingerJoint+"_M")`)
					parent ("FKOffset"+$hipSwingerJoint+"_M") HipSwingerStabilizer;
			}
		orientConstraint HipSwingerStabilizerTarget HipSwingerStabilizer;
		}
	}

//CenterBetweenFeet
if (!$opm)//$opm skips CenterBetweenFeet, cause it has the option for IK feet to Follow root, so cannot have both
	{
	$tempString=`ls "IKLeg*_*"`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im ControlSet $tempString[$i]`)
			$ikLegs[size($ikLegs)]=$tempString[$i];
	if (size($ikLegs) && $centerBtwFeet)
		{
		createNode -n RootCenterBtwLegsBlended_M transform;
		asAlign RootCenterBtwLegsBlended_M Root_M 1 0 0 1;
		parent RootCenterBtwLegsBlended_M RootSystem;
		parent RootOffsetX_M RootCenterBtwLegsBlended_M;
		createNode -n RootCenterBtwLegsOffset_M -p RootSystem transform;
		asAlign RootCenterBtwLegsOffset_M Root_M 1 0 0 1;
		duplicate -n RootCenter_M RootCenterBtwLegsOffset_M;
		duplicate -n RootCenterBtwLegs_M RootCenterBtwLegsOffset_M;
		parent RootCenter_M RootCenterBtwLegs_M RootFollowMain;
		for ($i=0;$i<size($ikLegs);$i++)
			{
			pointConstraint -skip y $ikLegs[$i] RootCenterBtwLegs_M;
			orientConstraint -skip x -skip z $ikLegs[$i] RootCenterBtwLegs_M;
			}
		parent RootCenterBtwLegsOffset_M RootCenterBtwLegs_M;
		parentConstraint RootCenter_M RootCenterBtwLegsOffset_M RootCenterBtwLegsBlended_M;
		createNode -n CenterBtwLegsUnitConversion unitConversion;
		setAttr CenterBtwLegsUnitConversion.conversionFactor 0.1;
		addAttr -k 1 -ln CenterBtwFeet -at double -min 0 -max 10 RootX_M;
		connectAttr RootX_M.CenterBtwFeet CenterBtwLegsUnitConversion.input;
		createNode -n CenterBtwLegsUnitReverse reverse;
		connectAttr CenterBtwLegsUnitConversion.output CenterBtwLegsUnitReverse.inputX;
		connectAttr CenterBtwLegsUnitConversion.output RootCenterBtwLegsBlended_M_parentConstraint1.RootCenterBtwLegsOffset_MW1;
		connectAttr CenterBtwLegsUnitReverse.outputX RootCenterBtwLegsBlended_M_parentConstraint1.RootCenter_MW0;
		//NodeState setup changes from setRange to condition, due to Maya2020 warning "Has No Effect" not supported on this constraint
		createNode -n CenterBtwLegsNodeStateCondition condition;
		setAttr CenterBtwLegsNodeStateCondition.operation 4;
		connectAttr RootX_M.CenterBtwFeet CenterBtwLegsNodeStateCondition.firstTerm;
		setAttr CenterBtwLegsNodeStateCondition.secondTerm 0.1;
		setAttr CenterBtwLegsNodeStateCondition.colorIfTrueR 2;
		setAttr CenterBtwLegsNodeStateCondition.colorIfFalseR 0;
		connectAttr -f CenterBtwLegsNodeStateCondition.outColorR RootCenterBtwLegs_M_pointConstraint1.nodeState;
		connectAttr -f CenterBtwLegsNodeStateCondition.outColorR RootCenterBtwLegs_M_orientConstraint1.nodeState;
		}
	}

//Locking
asLockAttr RootX_M 0 0 1 0;

//Advanced Twist ($opm)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$opm)
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if (!$fitJointTwistJoints[$i] && !$fitJointUpTwistJoints[$i])
			continue;

		asCreateUnTwister $fitJoints[$i] $side $fitJointParent[$i] $parentSide $fitJointIK[$i] $b 0 "";

		if ($fitJointIK[$i]=="")
			connectAttr ("FKX"+$fitJoints[$i]+$side+".worldMatrix")  ($fitJoints[$i]+"MMTwist"+$side+".matrixIn[0]");
		else
			connectAttr ($fitJoints[$i]+"BM"+$side+".outputMatrix") ($fitJoints[$i]+"MMTwist"+$side+".matrixIn[0]");
//		connectAttr ("FKOffset"+$fitJoints[$i]+$side+".worldInverseMatrix")  ($fitJoints[$i]+"MMTwist"+$side+".matrixIn[1]");

		createNode -n ($fitJoints[$i]+"XformInverter"+$side) -p TwistSystem transform;
		if (`objExists ($fitJointParent[$i]+"BM"+$parentSide)`)
			connectAttr ($fitJointParent[$i]+"BM"+$parentSide+".outputMatrix") ($fitJoints[$i]+"XformInverter"+$side+".offsetParentMatrix");
		else if (`objExists ($fitJointParent[$i]+$parentSide)`)
//			connectAttr ("FKX"+$fitJointParent[$i]+$parentSide+".worldInverseMatrix") ($fitJoints[$i]+"XformInverter"+$side+".offsetParentMatrix");
			connectAttr ("FKX"+$fitJointParent[$i]+$parentSide+".worldMatrix") ($fitJoints[$i]+"XformInverter"+$side+".offsetParentMatrix");

		delete `orientConstraint ($fitJoints[$i]+$side) ($fitJoints[$i]+"XformInverter"+$side)`;
		connectAttr ($fitJoints[$i]+"XformInverter"+$side+".worldInverseMatrix") ($fitJoints[$i]+"MMTwist"+$side+".matrixIn[1]");

		if (!$fitJointTwistJoints[$i])//Up-Twister, e.g Wrist, gets own local downTwister, then add values to the above Twister
			continue;//Up-Twister e.g. Wrist does not continue from here, the rest is done from $fitJointDualTwistJoints

		//divide and distribute the rotation
		for ($y=0;$y<$fitJointTwistJoints[$i]+1;$y++)
			{
			if ($y==0) $part="";
			else $part="Part"+$y;

			createNode -n ("twistAmountDivide"+$fitJoints[$i]+$part+$side) multDoubleLinear;
			$joint=$fitJoints[$i]+$part+$side;

//			$twistAmount=1.0/($fitJointTwistJoints[$i]+1.0);//($y/($fitJointTwistJoints[$i]+1.0));
			$twistAmount=$y/($fitJointTwistJoints[$i]+1.0);
			if ($y==0)
				$twistAmount=0;
			
			addAttr -k 1 -ln twistAmount -at double -min 0 -max 1 -dv $twistAmount $joint;
			addAttr -k 1 -ln twistAddition -at double $joint;

			connectAttr ($fitJoints[$i]+"QTETwist"+$side+".outputRotateX") ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".input1");

			if ($y==0 || $fitJointBendyJoints[$i])
				{
				createNode -n ("twistPreMultAdd"+$fitJoints[$i]+$part+$side) plusMinusAverage;
				connectAttr ($joint+".twistAmount") ("twistPreMultAdd"+$fitJoints[$i]+$part+$side+".input1D[0]");
				setAttr ("twistPreMultAdd"+$fitJoints[$i]+$part+$side+".input1D[1]") -1;
				connectAttr ("twistPreMultAdd"+$fitJoints[$i]+$part+$side+".output1D") ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".input2");
				}
			else
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".input2");
			createNode -n ("twistAddition"+$fitJoints[$i]+$part+$side) plusMinusAverage;
			connectAttr ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".output") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D[0]");
			connectAttr ($joint+".twistAddition") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D[1]");
//			connectAttr ("twistAddition"+$fitJoints[$i]+$part+$side+".output1D") ($joint+".rotate"+$fitJointAbsPriAxis[$i]);

			if ($y>1)//twistAmountParentSubtract
				{
				createNode -n ("twistAmountParentSubtract"+$fitJoints[$i]+$part+$side) multDoubleLinear;
				connectAttr ("twistAddition"+$fitJoints[$i]+"Part"+($y-1)+$side+".output1D") ("twistAmountParentSubtract"+$fitJoints[$i]+$part+$side+".input1");
				setAttr ("twistAmountParentSubtract"+$fitJoints[$i]+$part+$side+".input2") -1;
				if (!$fitJointBendyJoints[$i])
					for ($z=2;$z<$y+1;$z++)
						{
						$plugNr=`getAttr -s ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D")`;
						connectAttr ("twistAmountParentSubtract"+$fitJoints[$i]+"Part"+$z+$side+".output") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D["+$plugNr+"]");
						}
				}

			createNode -n ("twistCM"+$joint) composeMatrix;
			$pos=`getAttr ($joint+".t")`;
			setAttr ("twistCM"+$joint+".inputTranslate") -type float3 $pos[0] $pos[1] $pos[2];
			connectAttr ("twistAddition"+$fitJoints[$i]+$part+$side+".output1D") ("twistCM"+$joint+".inputRotateX");
			if ($y==0)
				asInsertMMPlug ("twistCM"+$joint+".outputMatrix") ($fitJoints[$i]+"MM"+$side) 0;
			else
				{
				connectAttr ("twistCM"+$joint+".outputMatrix") ($joint+".offsetParentMatrix");
				xform -os -t 0 0 0 -ro 0 0 0 $joint;
				}

			//Child`s UpTwist has been prepped, now use at Elbow
			if ($fitJointDualTwistJoints[$i] && $y>0)//e.g. Elbow
				{
				createNode -n ("upTwistAmountDivide"+$fitJointChild[$i]+$part+$childSide) multDoubleLinear;
				connectAttr ($fitJointChild[$i]+"QTETwist"+$childSide+".outputRotateX") ("upTwistAmountDivide"+$fitJointChild[$i]+$part+$childSide+".input1");
				$plugNr=`getAttr -s ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D")`;
				connectAttr ("upTwistAmountDivide"+$fitJointChild[$i]+$part+$childSide+".output") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D["+$plugNr+"]");
				connectAttr ($joint+".twistAmount") ("upTwistAmountDivide"+$fitJointChild[$i]+$part+$childSide+".input2");
				}

			//tx in IK
			if ($fitJointIK[$i]!="" && $y>0)
				{
				if (!`objExists ("IKStretchyTxMDL"+$fitJoints[$i]+$side)`)
					{
					createNode -n ("IKStretchyTxMDL"+$fitJoints[$i]+$side) multDoubleLinear;
					connectAttr ("PoleLockBlenderIKX"+$fitJointChild[$i]+$childSide+".output") ("IKStretchyTxMDL"+$fitJoints[$i]+$side+".input1");
					setAttr ("IKStretchyTxMDL"+$fitJoints[$i]+$side+".input2") (1.0/($fitJointTwistJoints[$i]+1.0));
					createNode -n ("PoleLockFKIKBlender"+$fitJoints[$i]+$side) blendTwoAttr;
					connectAttr ("IKStretchyTxMDL"+$fitJoints[$i]+$side+".output") ("PoleLockFKIKBlender"+$fitJoints[$i]+$side+".input[1]");
					setAttr ("PoleLockFKIKBlender"+$fitJoints[$i]+$side+".input[0]") `getAttr ("PoleLockFKIKBlender"+$fitJoints[$i]+$side+".input[1]")`;
					connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("PoleLockFKIKBlender"+$fitJoints[$i]+$side+".attributesBlender");
					}
				connectAttr ("PoleLockFKIKBlender"+$fitJoints[$i]+$side+".output") ("twistCM"+$joint+".inputTranslate.inputTranslateX");
/*
				createNode -n ("IKStretchyTxMDL"+$joint) multDoubleLinear;
				connectAttr ("PoleLockBlenderIKX"+$fitJointChild[$i]+$childSide+".output") ("IKStretchyTxMDL"+$joint+".input1");
				setAttr ("IKStretchyTxMDL"+$joint+".input2") (1.0/($fitJointTwistJoints[$i]+1.0)); 
				connectAttr ("IKStretchyTxMDL"+$joint+".output") ("twistCM"+$joint+".inputTranslate.inputTranslateX");
*/
				}
			}
		}

//Advanced Twist (!$opm)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($opm)
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointTwistJoints[$i])
			catchQuiet (`delete ($fitJoints[$i]+$side+"_pointConstraint1") ($fitJoints[$i]+$side+"_orientConstraint1")`);
		else if (!$fitJointUpTwistJoints[$i])
			continue;refresh;

		asCreateUnTwister $fitJoints[$i] $side $fitJointParent[$i] $parentSide $fitJointIK[$i] $b 0 "";

		if ($fitJointTwistJoints[$i])
			{
			asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			parent ($fitJoints[$i]+$side+"_pointConstraint1") ConstraintSystem;	
			}

		int $numTwisters=$fitJointTwistJoints[$i]+1;
		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			$numTwisters=$fitJointUpTwistJoints[$i]+1;
		for ($y=0;$y<$numTwisters;$y++)
			{
			if ($y==0) $part="";
			else $part="Part"+$y;

			createNode -n ("twistAmountDivide"+$fitJoints[$i]+$part+$side) multiplyDivide;
			createNode -n ("twistAddition"+$fitJoints[$i]+$part+$side) plusMinusAverage;
			createNode -n ("Twister"+$fitJoints[$i]+$part+$side) -p ("UnTwist"+$fitJoints[$i]+$side) transform;
			setAttr ("Twister"+$fitJoints[$i]+$part+$side+".rotateOrder") $fitJointRotOrder[$i];

			if ($fitJointTwistJoints[$i])
				{
				if ($y==0)
					$joint=$fitJoints[$i]+$side;
				else
					$joint=$fitJoints[$i]+$part+$side;
				addAttr -k 1 -ln twistAmount -at double -min 0 -max 1 $joint;
				addAttr -k 1 -ln twistAddition -at double $joint;
				setAttr ($joint+".twistAmount") ($y/($fitJointTwistJoints[$i]+1.0));
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".input2X");
				connectAttr ($joint+".twistAddition") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D[1]");
				orientConstraint ("Twister"+$fitJoints[$i]+$part+$side) $joint;
				parent ($joint+"_orientConstraint1") ConstraintSystem;
				}

			if (`attributeExists twist ("TwistBalancer"+$fitJoints[$i]+$side)`)//might not exists, if twist/bendy added within a IK-Spine
				connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".twist") ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".input1X");
			connectAttr ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".outputX") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D[0]");
			connectAttr ("twistAddition"+$fitJoints[$i]+$part+$side+".output1D") ("Twister"+$fitJoints[$i]+$part+$side+".rx");
			}

		//scale (if not usign bendy)
		if (!$fitJointBendyJoints[$i])
			for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
				{
				if ($y==0) $part="";
				else $part="Part"+$y;

				for ($z=0;$z<size($XYZ);$z++)
					{
					if ($fitJointIK[$i]=="")
						connectAttr ("FK"+$fitJoints[$i]+$side+".scale"+$XYZ[$z]) ($fitJoints[$i]+$part+$side+".scale"+$XYZ[$z]);
					else
						connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output"+$RGB[$z]) ($fitJoints[$i]+$part+$side+".scale"+$XYZ[$z]);
					}						
				}
		}

//Advanced Twist ($fitJointUpTwistJoints)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($opm)
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			for ($y=0;$y<$fitJointUpTwistJoints[$i]+1;$y++)
				{
				if ($y==0) $part="";
				else $part="Part"+$y;

				$joint=$fitJointParent[$i]+$part+$parentSide;

				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".input2X");
				if ($fitJointParent[$i]=="Root")
					print ("Skipping for Root: connectAttr twistAmountDivide"+$fitJoints[$i]+$part+$side+".outputX twistAddition"+$fitJointParent[$i]+$part+$parentSide+".input1D[2];\n");
				else
					connectAttr ("twistAmountDivide"+$fitJoints[$i]+$part+$side+".outputX") ("twistAddition"+$fitJointParent[$i]+$part+$parentSide+".input1D[2]");
				}
		}


//Advanced BendyJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		$c=$b;
		if ($fitJointNoFlip[$i] && $b==-1) $c=1;

		if ($fitJointIsEndJoint[$i])
			continue;
		if (!$fitJointBendyJoints[$i])
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$pos2=`xform -q -ws -t ($fitJointChild[$i]+$childSide)`;
		$crvCmd="curve -n Bend"+$fitJoints[$i]+"Curve"+$side+" -d 1 -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		eval ($crvCmd);
		$tempString=`listRelatives -s ("Bend"+$fitJoints[$i]+"Curve"+$side)`;
		rename $tempString[0] ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape");
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 2 -d 3 -tol 0.01 ("Bend"+$fitJoints[$i]+"Curve"+$side);
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
		parent ("Bend"+$fitJoints[$i]+"Curve"+$side) BendCurve;

		createNode -n ("BendParentConstraint"+$fitJoints[$i]+$side) -p BendSystem transform;
		if ($opm)
			{
			createNode -n ("BendParentConstraintMM"+$fitJoints[$i]+$side) multMatrix;
			createNode -n ("BendParentConstraintUnTwistCM"+$fitJoints[$i]+$side) composeMatrix;
			createNode -n ("twistAdditionSubtract"+$fitJoints[$i]+$side) multDoubleLinear;
			connectAttr ($fitJoints[$i]+"QTETwist"+$side+".outputRotateX") ("twistAdditionSubtract"+$fitJoints[$i]+$side+".input1");
			setAttr ("twistAdditionSubtract"+$fitJoints[$i]+$side+".input2") -1;
			connectAttr ("twistAdditionSubtract"+$fitJoints[$i]+$side+".output") ("BendParentConstraintUnTwistCM"+$fitJoints[$i]+$side+".inputRotateX");
			connectAttr ("BendParentConstraintUnTwistCM"+$fitJoints[$i]+$side+".outputMatrix") ("BendParentConstraintMM"+$fitJoints[$i]+$side+".matrixIn[0]");
			if (`objExists ($fitJoints[$i]+"BM"+$side)`)
				connectAttr ($fitJoints[$i]+"BM"+$side+".outputMatrix") ("BendParentConstraintMM"+$fitJoints[$i]+$side+".matrixIn[1]");
			else
				connectAttr ("FKX"+$fitJoints[$i]+$side+".worldMatrix") ("BendParentConstraintMM"+$fitJoints[$i]+$side+".matrixIn[1]");
			connectAttr ("BendParentConstraintMM"+$fitJoints[$i]+$side+".matrixSum") ("BendParentConstraint"+$fitJoints[$i]+$side+".offsetParentMatrix");
			}
		else
			{
			asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			orientConstraint ("UnTwist"+$fitJoints[$i]+$side)  ("BendParentConstraint"+$fitJoints[$i]+$side);
			}

//removed in v 5.621, as this cause issues when scaling FK. e.g. scale FKShoulder_R cause non-uniform spread of Part-joints
//restored in v 5.622, removing this caused main.scale side-effects
		if (!$opm)
			asConstraintToFKIK "scale" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);

		if (!$opm)
			{
			createNode -n ("BendParentConstraintOffset"+$fitJoints[$i]+$side) -p BendSystem transform;
			asAlign ("BendParentConstraintOffset"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side) 1 1 0 0;
			parent ("BendParentConstraint"+$fitJoints[$i]+$side) ("BendParentConstraintOffset"+$fitJoints[$i]+$side);
			}

		for ($z=0;$z<size($startMidEnd);$z++)
			{
			select BendJoints;
			joint -n ("Bend"+$fitJoints[$i]+$startMidEnd[$z]+$side);
			setAttr ("Bend"+$fitJoints[$i]+$startMidEnd[$z]+$side+".drawStyle") 2;
			}

		$bendControlNr=1;
		for ($z=0;$z<5;$z++)
			{
			if ($fitJointTwistJoints[$i]==0 && $z>0)
				{
				delete ("Bend"+$fitJoints[$i]+"Curve"+$side);
				break;
				}

			if ($z==0 || $z==2)//Controllers
				{
				asCreateController "Bend" ($fitJoints[$i]+$bendControlNr) $side $fitJoints[$i];
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) BendSystem;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ($fitJoints[$i]+$side) 1 1 0 0;
				if ($z==2)
					{
					delete `pointConstraint ($fitJoints[$i]+$side) ($fitJointChild[$i]+$childSide) ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side)`;
					if (`asMayaVersionAsFloat`>2020)//Maya2020 does not allow for connections to fractionMode attribute
						{
						addAttr -k 0 -ln parametric -at bool -dv 1 ("Bend"+$fitJoints[$i]+$bendControlNr+$side);//aka "parametric Lenght" and "fractionMode"
						setAttr -k 0 -cb 1 ("Bend"+$fitJoints[$i]+$bendControlNr+$side+".parametric");
						}
					}

				if ($z==4)
					{
					asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ($fitJoints[$i]+$side) 1 1 0 0;
					asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ($fitJointChild[$i]+$childSide) 1 0 0 0;
					}
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				$parent="Bend"+$fitJoints[$i]+$bendControlNr+$side;
				$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
/*
				if ($z==2 && $fitJointIK[$i]!="") //stretchy IK, slides bend2
					{
					createNode -n ("BendStretchyMDL"+$fitJoints[$i]+$bendControlNr+$side) multDoubleLinear;
					setAttr ("BendStretchyMDL"+$fitJoints[$i]+$bendControlNr+$side+".input1") `getAttr ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side+".tx")`;
					connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".outputX") ("BendStretchyMDL"+$fitJoints[$i]+$bendControlNr+$side+".input2");
					createNode -n ("BendStretchyIKFKBTA"+$fitJoints[$i]+$bendControlNr+$side) blendTwoAttr;
					connectAttr ("BendStretchyMDL"+$fitJoints[$i]+$bendControlNr+$side+".output") ("BendStretchyIKFKBTA"+$fitJoints[$i]+$bendControlNr+$side+".input[1]");
					setAttr ("BendStretchyIKFKBTA"+$fitJoints[$i]+$bendControlNr+$side+".input[0]") `getAttr ("BendStretchyIKFKBTA"+$fitJoints[$i]+$bendControlNr+$side+".input[1]")`;
					connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("BendStretchyIKFKBTA"+$fitJoints[$i]+$bendControlNr+$side+".attributesBlender");
					connectAttr ("BendStretchyIKFKBTA"+$fitJoints[$i]+$bendControlNr+$side+".output") ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side+".tx");
					}
*/
				//offset Bend ctrl for easier seleting
				$pos =`xform -q -ws -t ($fitJoints[$i]+$side)`;
				$pos2=$pos;
				$tempString=`listRelatives -c -type joint ($fitJoints[$i]+$side)`;
				if ($tempString[0]!="")
					$pos2=`xform -q -ws -t $tempString[0]`;
				$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`/(5.0*$b);
				if ($bendControlNr==1)
					move -r -os -wd $dist 0 0 ("Bend"+$fitJoints[$i]+$bendControlNr+$side+".cv[0:99]");
				$bendControlNr++;
				}
			}

		//Bend3, not a animator Controller, but still exists
		createNode -n ("Bend"+$fitJoints[$i]+"3"+$side) -p ("BendParentConstraint"+$fitJoints[$i]+$side) transform;
		asAlign ("Bend"+$fitJoints[$i]+"3"+$side) ($fitJoints[$i]+$side) 0 1 0 1;
		asAlign ("Bend"+$fitJoints[$i]+"3"+$side) ($fitJointChild[$i]+$childSide) 1 0 0 0;

		//use Child`s BendStart as Bend3 for position
		if (`objExists ("Bend"+$fitJointChild[$i]+"Start"+$childSide)`)
			{
			if ($opm)
				{
				asParentConstraint ("Bend"+$fitJointChild[$i]+"Start"+$childSide) ("Bend"+$fitJoints[$i]+"3"+$side) "-includePickMatrix";
				setAttr ("Bend"+$fitJoints[$i]+"3PM"+$side+".useRotate") 0;
				setAttr ("Bend"+$fitJoints[$i]+"3PM"+$side+".useScale") 0;
				setAttr ("Bend"+$fitJoints[$i]+"3PM"+$side+".useShear") 0;
				}
			else
				pointConstraint ("Bend"+$fitJointChild[$i]+"Start"+$childSide) ("Bend"+$fitJoints[$i]+"3"+$side);
			}
		else if (`objExists ("FKX"+$fitJointChild[$i]+$childSide)`)
			asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJointChild[$i]+$childSide) ("IKX"+$fitJointChild[$i]+$childSide) ("Bend"+$fitJoints[$i]+"3"+$side);

		asParentConstraint ("Bend"+$fitJoints[$i]+"1"+$side) ("Bend"+$fitJoints[$i]+"Start"+$side) "";
		asParentConstraint ("Bend"+$fitJoints[$i]+"2"+$side) ("Bend"+$fitJoints[$i]+"Mid"  +$side) "";
		asParentConstraint ("Bend"+$fitJoints[$i]+"3"+$side) ("Bend"+$fitJoints[$i]+"End"  +$side) "";
		if (!$opm)
			{
			delete ("Bend"+$fitJoints[$i]+"Start"+$side+"_scaleConstraint1");
			delete ("Bend"+$fitJoints[$i]+"Mid"  +$side+"_scaleConstraint1");
			delete ("Bend"+$fitJoints[$i]+"End"  +$side+"_scaleConstraint1");
			}

		//microVis
		addAttr -k 1 -ln microVis -at bool -dv 0 ("Bend"+$fitJoints[$i]+"2"+$side);
		setAttr -k 0 -cb 1 ("Bend"+$fitJoints[$i]+"2"+$side+".microVis");
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			if ($y==0) $part="";
			else $part="Part"+$y;
			connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".microVis") ("MicroOffset"+$fitJoints[$i]+$part+$side+".v");
			}

		//bind curve
		select ("Bend"+$fitJoints[$i]+"Curve"+$side);
		for ($z=0;$z<size($startMidEnd);$z++)
			select -add ("Bend"+$fitJoints[$i]+$startMidEnd[$z]+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 2 -dr 4 -rui false"`;
		rename $tempString[0] ("Bend"+$fitJoints[$i]+"SC"+$side);
		skinPercent -tv ("Bend"+$fitJoints[$i]+"Start"+$side) 1.0 ("Bend"+$fitJoints[$i]+"SC"+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side+".cv[0:2]");
		skinPercent -tv ("Bend"+$fitJoints[$i]+"End"+$side) 1.0 ("Bend"+$fitJoints[$i]+"SC"+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side+".cv[3:4]");
		skinPercent -tv ("Bend"+$fitJoints[$i]+"Mid"+$side) 1.0 ("Bend"+$fitJoints[$i]+"SC"+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side+".cv[2]");
		skinPercent -tv ("Bend"+$fitJoints[$i]+"Mid"+$side) 0.4 ("Bend"+$fitJoints[$i]+"SC"+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side+".cv[1]");
		skinPercent -tv ("Bend"+$fitJoints[$i]+"Mid"+$side) 0.4 ("Bend"+$fitJoints[$i]+"SC"+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side+".cv[3]");

		createNode -n tempNearestPointOnCurve nearestPointOnCurve;
		connectAttr -f ("Bend"+$fitJoints[$i]+"Curve"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;

		//connect to twistJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			if ($y==0)
				{
				$part="";
				$joint=$fitJoints[$i]+$side;
				}
			else
				{
				$part="Part"+$y;
				$joint=$fitJoints[$i]+"Part"+$y+$side;
				if (!$opm)
					delete ($joint+"_orientConstraint1");
				}

			//disconnect Existing DeformJoint connections, to replace with Connections from MicroControllers
			if ($opm)
				{
				$tempString =`listConnections -s 1 -d 0 -p 1 ($joint+".offsetParentMatrix")`;
				$tempString2=`listConnections -s 1 -d 0 -p 0 ($joint+".offsetParentMatrix")`;
				disconnectAttr $tempString[0] ($joint+".offsetParentMatrix");
				if ($y==0)
					rename ($fitJoints[$i]+$part+"MM"+$side) ("Micro"+$fitJoints[$i]+$part+"MM"+$side);
				}
			else
				{
				$tempString =`listConnections -s 1 -d 0 ($joint+".tx")`;
				if (size($tempString))
					delete $tempString;//could be point or parent constraint

				for ($z=0;$z<size($XYZ);$z++)
					{
					$tempString=`listConnections -s 1 -d 0 -p 1 ($joint+".scale"+$XYZ[$z])`;
					if ($tempString[0]!="")
						disconnectAttr $tempString[0] ($joint+".scale"+$XYZ[$z]);
					}
				}

			//MicroControllers override, part1, constraint controller instead of joint
			if ($y==0)
				{
				if (`objExists ($joint+"_pointConstraint1")`) delete ($joint+"_pointConstraint1");
				if (`objExists ($joint+"_orientConstraint1")`)delete ($joint+"_orientConstraint1");
				}

			asParentConstraint ("Micro"+$joint) $joint "";
			if (!$opm)
				parent ($joint+"_parentConstraint1") ($joint+"_scaleConstraint1") ConstraintSystem;

			if ($y==0)
				{
				createNode -n ("ScaleBlendMult"+$fitJoints[$i]+$side) multiplyDivide;
				for ($z=0;$z<size($XYZ);$z++)
					{
					if ($fitJointIK[$i]=="")
						connectAttr ("FK"+$fitJoints[$i]+$side+".scale"+$XYZ[$z]) ("ScaleBlendMult"+$fitJoints[$i]+$side+".input1"+$XYZ[$z]);
					else
						connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output"+$RGB[$z]) ("ScaleBlendMult"+$fitJoints[$i]+$side+".input1"+$XYZ[$z]);
					connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".scale"+$XYZ[$z]) ("ScaleBlendMult"+$fitJoints[$i]+$side+".input2"+$XYZ[$z]);
					connectAttr -f ("ScaleBlendMult"+$fitJoints[$i]+$side+".output"+$XYZ[$z]) ($fitJoints[$i]+$side+".scale"+$XYZ[$z]);
					}

				disconnectAttr ("ScaleBlendMult"+$fitJoints[$i]+$side+".outputX") ($fitJoints[$i]+$side+".scaleX");
				if ($opm)
					{
					disconnectAttr ("ScaleBlendMult"+$fitJoints[$i]+$side+".outputY") ($fitJoints[$i]+$side+".scaleY");
					disconnectAttr ("ScaleBlendMult"+$fitJoints[$i]+$side+".outputZ") ($fitJoints[$i]+$side+".scaleZ");
					}
				}


			//twist
			createNode -n ("BendMPX"+$fitJoints[$i]+$y+$side) -p BendMPX transform;
			createNode -n ("BendyMP"+$fitJoints[$i]+$y+$side) motionPath;
			$pos=`xform -q -ws -t $joint`;
			setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
			$parameter=`getAttr tempNearestPointOnCurve.result.parameter`;
			setAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".uValue") $parameter;
			if (`asMayaVersionAsFloat`>2020)
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".parametric") ("BendyMP"+$fitJoints[$i]+$y+$side+".fractionMode");//parametric
			connectAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+".worldSpace") ("BendyMP"+$fitJoints[$i]+$y+$side+".geometryPath");
			connectAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".allCoordinates") ("BendMPX"+$fitJoints[$i]+$y+$side+".t");
//			connectAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".rotate") ("BendMPX"+$fitJoints[$i]+$y+$side+".r");
			//changing BendyJoints to Aim-at-child, instead of Tangent-on-curve
/*
			setAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".worldUpType") 2;
			if ($side=="_L")
				setAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".inverseFront") 1;
			setAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".frontAxis") 0;
			setAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".upAxis") 1;
			setAttr ("BendyMP"+$fitJoints[$i]+$y+$side+".worldUpVector") 0 1 0;
*/
			//startTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rx")  ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1X");
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2X") (1-(1/($fitJointTwistJoints[$i]+0.00))*$y);
			$plugNr=`getAttr -s ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D")`;
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D["+$plugNr+"]");
			//midTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"2"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Y");
			$hf=(1.0/$fitJointTwistJoints[$i])*$y*2;
			if ($y>$fitJointTwistJoints[$i]/2) $hf=2-$hf;
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Y") $hf;
			$plugNr=`getAttr -s ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D")`;
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputY") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D["+$plugNr+"]");
			//endTwister
			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide)`)
				{
				connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Z");
				setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Z") ((1/($fitJointTwistJoints[$i]+0.00))*$y);
				$plugNr=`getAttr -s ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D")`;
				connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputZ") ("twistAddition"+$fitJoints[$i]+$part+$side+".input1D["+$plugNr+"]");
				}

			if ($opm)
				{
				createNode -n ("twist"+$fitJoints[$i]+$part+"MM"+$side) multMatrix;
				connectAttr ("twistCM"+$fitJoints[$i]+$part+$side+".outputMatrix") ("twist"+$fitJoints[$i]+$part+"MM"+$side+".matrixIn[0]");
				if (`objExists ($fitJoints[$i]+"BM"+$side)`)
					connectAttr -f ($fitJoints[$i]+"BM"+$side+".outputMatrix") ("twist"+$fitJoints[$i]+$part+"MM"+$side+".matrixIn[1]");
				else
					connectAttr -f ("FKX"+$fitJoints[$i]+$side+".worldMatrix") ("twist"+$fitJoints[$i]+$part+"MM"+$side+".matrixIn[1]");
				connectAttr ("twist"+$fitJoints[$i]+$part+"MM"+$side+".matrixSum") ("BendyMP"+$fitJoints[$i]+$y+$side+".worldUpMatrix");
				}
			else
				connectAttr ("Twister"+$fitJoints[$i]+$part+$side+".worldMatrix") ("BendyMP"+$fitJoints[$i]+$y+$side+".worldUpMatrix");

			//scale
			createNode -n ("BendScaleAdd"+$fitJoints[$i]+"1"+"_"+$y+$side) plusMinusAverage;

			//startScale
			createNode -n ("BendScaleMult"+$fitJoints[$i]+"1"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".s") ("BendScaleMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1");
			$factor=1-((1.0/($fitJointTwistJoints[$i]/2.0))*$y);
			$m[0]=$factor;
			if ($factor<0) $m[0]=0;
			setAttr ("BendScaleMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2") -type float3 $m[0] $m[0] $m[0];
			connectAttr ("BendScaleMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".output") ("BendScaleAdd"+$fitJoints[$i]+"1"+"_"+$y+$side+".input3D[0]");

			//midScale
			createNode -n ("BendScaleMult"+$fitJoints[$i]+"2"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".s") ("BendScaleMult"+$fitJoints[$i]+"2"+"_"+$y+$side+".input1");
			$m[1]=1-$factor;
			if ($m[1]>1) $m[1]=2-$m[1];
			setAttr ("BendScaleMult"+$fitJoints[$i]+"2"+"_"+$y+$side+".input2") -type float3 $m[1] $m[1] $m[1];
			connectAttr ("BendScaleMult"+$fitJoints[$i]+"2"+"_"+$y+$side+".output") ("BendScaleAdd"+$fitJoints[$i]+"1"+"_"+$y+$side+".input3D[1]");

			//endScale
			if ($m[0]==0)
				{
				if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide)`)
					{
					createNode -n ("BendScaleMult"+$fitJointChild[$i]+"End"+"_"+$y+$childSide) multiplyDivide;
					connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".s") ("BendScaleMult"+$fitJointChild[$i]+"End"+"_"+$y+$childSide+".input1");
					$m[2]=1-$m[1];
					setAttr ("BendScaleMult"+$fitJointChild[$i]+"End"+"_"+$y+$childSide+".input2") -type float3 $m[2] $m[2] $m[2];
					connectAttr ("BendScaleMult"+$fitJointChild[$i]+"End"+"_"+$y+$childSide+".output") ("BendScaleAdd"+$fitJoints[$i]+"1"+"_"+$y+$side+".input3D[2]");
					}
				else
					setAttr ("BendScaleAdd"+$fitJoints[$i]+"1"+"_"+$y+$side+".input3D[2]") -type float3 (1-$m[1]) (1-$m[1]) (1-$m[1]);
				}

			connectAttr ("BendScaleAdd"+$fitJoints[$i]+"1"+"_"+$y+$side+".output3Dy") ("BendMPX"+$fitJoints[$i]+$y+$side+".sy");
			connectAttr ("BendScaleAdd"+$fitJoints[$i]+"1"+"_"+$y+$side+".output3Dz") ("BendMPX"+$fitJoints[$i]+$y+$side+".sz");


			//scale the MicroCtrl
			if ($y==0)//("ScaleBlendMult"+$fitJoints[$i]+$part+$side) already exists
				for ($z=0;$z<size($XYZ);$z++)
					connectAttr ("ScaleBlendMult"+$fitJoints[$i]+$part+$side+".output"+$XYZ[$z]) ("MicroOffset"+$fitJoints[$i]+$part+$side+".scale"+$XYZ[$z]) ;
			else
				{
				createNode -n ("ScaleBlendMult"+$fitJoints[$i]+$part+$side) multiplyDivide;
				for ($z=0;$z<size($XYZ);$z++)
					{
					if ($fitJointIK[$i]=="")
						connectAttr ("FK"+$fitJoints[$i]+$side+".scale"+$XYZ[$z]) ("ScaleBlendMult"+$fitJoints[$i]+$part+$side+".input1"+$XYZ[$z]);
					else
						connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output"+$RGB[$z]) ("ScaleBlendMult"+$fitJoints[$i]+$part+$side+".input1"+$XYZ[$z]);
					connectAttr ("BendMPX"+$fitJoints[$i]+$y+$side+".scale"+$XYZ[$z]) ("ScaleBlendMult"+$fitJoints[$i]+$part+$side+".input2"+$XYZ[$z]);
					connectAttr ("ScaleBlendMult"+$fitJoints[$i]+$part+$side+".output"+$XYZ[$z]) ("MicroOffset"+$fitJoints[$i]+$part+$side+".scale"+$XYZ[$z]) ;
					}
				}

			if ($opm)
				{
				asParentConstraint ("BendMPX"+$fitJoints[$i]+$y+$side) ("MicroOffset"+$joint) "-includePickMatrix";
				setAttr ("MicroOffset"+$fitJoints[$i]+$part+"PM"+$side+".useScale") 0;
				}
			else
				{
				parentConstraint ("BendMPX"+$fitJoints[$i]+$y+$side) ("MicroOffset"+$joint);
				parent ("MicroOffset"+$joint+"_parentConstraint1") ConstraintSystem;

				//joint scale, mix scale from MiCroCtrl BendyCtrl & FK/IK(ScaleBlend)
				createNode -n ("ScaleBlendMultA"+$fitJoints[$i]+$part+$side) multiplyDivide;
				for ($z=0;$z<size($XYZ);$z++)
					{
					if ($fitJointIK[$i]=="")
						connectAttr ("FK"+$fitJoints[$i]+$side+".scale"+$XYZ[$z]) ("ScaleBlendMultA"+$fitJoints[$i]+$part+$side+".input1"+$XYZ[$z]);
					else
						connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".output"+$RGB[$z]) ("ScaleBlendMultA"+$fitJoints[$i]+$part+$side+".input1"+$XYZ[$z]);
					connectAttr ("BendMPX"+$fitJoints[$i]+$y+$side+".scale"+$XYZ[$z]) ("ScaleBlendMultA"+$fitJoints[$i]+$part+$side+".input2"+$XYZ[$z]);
					connectAttr -f ("ScaleBlendMultA"+$fitJoints[$i]+$part+$side+".output"+$XYZ[$z]) ($fitJoints[$i]+$part+$side+".scale"+$XYZ[$z]);
					}
				//then Also scale from MicroController
				createNode -n ("ScaleBlendMultB"+$fitJoints[$i]+$part+$side) multiplyDivide;
				for ($z=0;$z<size($XYZ);$z++)
					{
					connectAttr ("ScaleBlendMultA"+$fitJoints[$i]+$part+$side+".output"+$XYZ[$z]) ("ScaleBlendMultB"+$fitJoints[$i]+$part+$side+".input1"+$XYZ[$z]);
					connectAttr ("Micro"+$fitJoints[$i]+$part+$side+".scale"+$XYZ[$z]) ("ScaleBlendMultB"+$fitJoints[$i]+$part+$side+".input2"+$XYZ[$z]);
					connectAttr -f ("ScaleBlendMultB"+$fitJoints[$i]+$part+$side+".output"+$XYZ[$z]) ($fitJoints[$i]+$part+$side+".scale"+$XYZ[$z]);
					}
				}
			}

		//bendJoint orientation to aim-at-child
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			if ($y==0)
				{
				$part="";
				$joint=$fitJoints[$i]+$side;
				}
			else
				{
				$part="Part"+$y;
				$joint=$fitJoints[$i]+"Part"+$y+$side;
				}

			if ($y<$fitJointTwistJoints[$i])
				$target="BendMPX"+$fitJoints[$i]+($y+1)+$side;
			else if (`objExists ("BendMPX"+$fitJointChild[$i]+"0"+$childSide)`)
				$target="BendMPX"+$fitJointChild[$i]+"0"+$childSide;
			else
				$target="Bend"+$fitJoints[$i]+"3"+$side;

			if ($opm)
				{
				createNode -n ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side) aimMatrix;
				setAttr ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side+".secondaryMode") 2;
				setAttr ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side+".secondaryInputAxis") -type float3 0 0 1;
				setAttr ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side+".secondaryTargetVector") -type float3 0 0 1;
				connectAttr ($target+".worldMatrix") ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side+".primaryTargetMatrix");
				connectAttr ("twist"+$fitJoints[$i]+$part+"MM"+$side+".matrixSum") ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side+".secondaryTargetMatrix");

				createNode -n ("BendMPX"+$fitJoints[$i]+$y+"CM"+$side) composeMatrix;
				$tempString=`listConnections -p 1 ("BendMPX"+$fitJoints[$i]+$y+$side+".t")`;
				connectAttr $tempString[0] ("BendMPX"+$fitJoints[$i]+$y+"CM"+$side+".inputTranslate");
				connectAttr ("BendMPX"+$fitJoints[$i]+$y+"CM"+$side+".outputMatrix") ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side+".inputMatrix");

				createNode -n ("BendMPX"+$fitJoints[$i]+$y+"DM"+$side) decomposeMatrix;
				connectAttr ("BendMPX"+$fitJoints[$i]+$y+"AM"+$side+".outputMatrix") ("BendMPX"+$fitJoints[$i]+$y+"DM"+$side+".inputMatrix");
				connectAttr ("BendMPX"+$fitJoints[$i]+$y+"DM"+$side+".outputRotate") ("BendMPX"+$fitJoints[$i]+$y+$side+".r");
				}
			else
				{
				$worldUpObject="Twister"+$fitJoints[$i]+$part+$side;
				aimConstraint -offset 0 0 0 -aimVector (1*$c) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject $worldUpObject
					$target ("BendMPX"+$fitJoints[$i]+$y+$side);
				}
			}

		delete tempNearestPointOnCurve;
		}



//Advanced distribution of twistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		$c=$b;
		if ($fitJointNoFlip[$i] && $b==-1) $c=1;

		if ($opm)
			continue;
		if (!$fitJointTwistJoints[$i])
			continue;

		//Seem to work.Nope, makes foot unasable with stretchy leg
//		setAttr ($fitJoints[$i]+"Part"+"1"+$side+".segmentScaleCompensate") 0;

		//if there`s no ("FKX"+$fitJointChild[$i]+$childSide), the skip Advanced distribution
		if (!`objExists ("FKX"+$fitJointChild[$i]+$childSide)`)
			continue;

		$contraintTo="FKX"+$fitJointChild[$i]+$childSide;
		if ($fitJointIK[$i]!="")
			{
			$contraintTo="FKIKMix"+$fitJointChild[$i]+$childSide;
			if (!`objExists $contraintTo`)
				{
				createNode -n $contraintTo -p TwistSystem transform;
				setAttr ($contraintTo+".rotateOrder") `getAttr ($fitJointChild[$i]+$childSide+".rotateOrder")`;
				asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJointChild[$i]+$childSide) ("IKX"+$fitJointChild[$i]+$childSide) $contraintTo;
				}
			}

		//Above Knee(elbow) to follow Knee(elbow)
		if ($fitJointBendyJoints[$i] && !$fitJointUpBendyJoints[$i] && `objExists ("Bend"+$fitJointChild[$i]+"1"+$side)`)
			$contraintTo="Bend"+$fitJointChild[$i]+"1"+$side;

		if (!$fitJointBendyJoints[$i] && `objExists $contraintTo`)
			{
			for ($y=1;$y<$fitJointTwistJoints[$i]+1;$y++)
				{
				$tempString=`pointConstraint $contraintTo ($fitJoints[$i]+$side) ($fitJoints[$i]+"Part"+$y+$side)`;
				$constraint=$tempString[0];
				parent $constraint ConstraintSystem;
				setAttr ($constraint+"."+$contraintTo+"W0") ($y/($fitJointTwistJoints[$i]+1.0));
				setAttr ($constraint+"."+$fitJoints[$i]+$side+"W1") (1-($y/($fitJointTwistJoints[$i]+1.0)));
				if ($fitJointBendyJoints[$i])
					connectAttr ("FK"+$fitJoints[$i]+"Part"+$y+$side+".t") ($fitJoints[$i]+"Part"+$y+$side+"_pointConstraint1.offset");
				}
			}
		}

//bendy Ctrl2 to follow when Moving FK-end (moved to here as non-opm needs FKIKMix from $child generated above)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		$c=$b;
		if ($fitJointNoFlip[$i] && $b==-1) $c=1;


		if (!$fitJointBendyJoints[$i])
			continue;

		if ($opm)
			{
			createNode -n ("Bendy2FollowBM"+$fitJoints[$i]+$side) blendMatrix;
			if (`objExists ("Bend"+$fitJoints[$i]+"1"+$side)`)
				connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".worldMatrix") ("Bendy2FollowBM"+$fitJoints[$i]+$side+".inputMatrix");
			else if (`objExists ($fitJoints[$i]+"BM"+$side)`)
				connectAttr ($fitJoints[$i]+"BM"+$side+".outputMatrix") ("Bendy2FollowBM"+$fitJoints[$i]+$side+".inputMatrix");
			else
				connectAttr ("FKX"+$fitJoints[$i]+$side+".worldMatrix") ("Bendy2FollowBM"+$fitJoints[$i]+$side+".inputMatrix");

			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide)`)
				connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".worldMatrix") ("Bendy2FollowBM"+$fitJoints[$i]+$side+".target[0].targetMatrix");
			else if (`objExists ($fitJointChild[$i]+"BM"+$childSide)`)
				connectAttr ($fitJointChild[$i]+"BM"+$childSide+".outputMatrix") ("Bendy2FollowBM"+$fitJoints[$i]+$side+".target[0].targetMatrix");
			else
				connectAttr ("FKX"+$fitJointChild[$i]+$childSide+".worldMatrix") ("Bendy2FollowBM"+$fitJoints[$i]+$side+".target[0].targetMatrix");
			setAttr ("Bendy2FollowBM"+$fitJoints[$i]+$side+".target[0].weight") 0.5;

			//blend Translate Only, and take rotate from parent, mix it and use as aimMatrix.inMatrix
			createNode -n ("Bendy2FollowTranslatePM"+$fitJoints[$i]+$side) pickMatrix;
			setAttr ("Bendy2FollowTranslatePM"+$fitJoints[$i]+$side+".useRotate") 0;
			setAttr ("Bendy2FollowTranslatePM"+$fitJoints[$i]+$side+".useScale") 0;
			setAttr ("Bendy2FollowTranslatePM"+$fitJoints[$i]+$side+".useShear") 0;
			connectAttr ("Bendy2FollowBM"+$fitJoints[$i]+$side+".outputMatrix") ("Bendy2FollowTranslatePM"+$fitJoints[$i]+$side+".inputMatrix");

			createNode -n ("Bendy2FollowRotatePM"+$fitJoints[$i]+$side) pickMatrix;
			setAttr ("Bendy2FollowRotatePM"+$fitJoints[$i]+$side+".useTranslate") 0;
			setAttr ("Bendy2FollowRotatePM"+$fitJoints[$i]+$side+".useScale") 0;
			setAttr ("Bendy2FollowRotatePM"+$fitJoints[$i]+$side+".useShear") 0;
			connectAttr ("BendParentConstraint"+$fitJoints[$i]+$side+".worldMatrix") ("Bendy2FollowRotatePM"+$fitJoints[$i]+$side+".inputMatrix");

			createNode -n ("Bendy2FollowMixMM"+$fitJoints[$i]+$side) multMatrix;
			connectAttr ("Bendy2FollowRotatePM"+$fitJoints[$i]+$side+".outputMatrix") ("Bendy2FollowMixMM"+$fitJoints[$i]+$side+".matrixIn[0]");
			connectAttr ("Bendy2FollowTranslatePM"+$fitJoints[$i]+$side+".outputMatrix") ("Bendy2FollowMixMM"+$fitJoints[$i]+$side+".matrixIn[1]");

			//and aim
			createNode -n ("Bendy2FollowAM"+$fitJoints[$i]+$side) aimMatrix;
			setAttr ("Bendy2FollowAM"+$fitJoints[$i]+$side+".envelope") 0.5;
			setAttr ("Bendy2FollowAM"+$fitJoints[$i]+$side+".primaryInputAxis") -type float3 $c 0 0;
			setAttr ("Bendy2FollowAM"+$fitJoints[$i]+$side+".secondaryInputAxis") -type float3 0 0 $c;
			setAttr ("Bendy2FollowAM"+$fitJoints[$i]+$side+".secondaryTargetVector") -type float3 0 0 $c;
//			connectAttr ("Bendy2FollowBM"+$fitJoints[$i]+$side+".outputMatrix") ("Bendy2FollowAM"+$fitJoints[$i]+$side+".inputMatrix");
			connectAttr ("Bendy2FollowMixMM"+$fitJoints[$i]+$side+".matrixSum") ("Bendy2FollowAM"+$fitJoints[$i]+$side+".inputMatrix");

			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide)`)
				connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".worldMatrix") ("Bendy2FollowAM"+$fitJoints[$i]+$side+".primaryTargetMatrix");
			else if (`objExists ($fitJointChild[$i]+"BM"+$childSide)`)
				connectAttr ($fitJointChild[$i]+"BM"+$childSide+".outputMatrix") ("Bendy2FollowAM"+$fitJoints[$i]+$side+".primaryTargetMatrix");
			else
				connectAttr ("FKX"+$fitJointChild[$i]+$childSide+".worldMatrix") ("Bendy2FollowAM"+$fitJoints[$i]+$side+".primaryTargetMatrix");

			$tempString=`listRelatives -p ("BendOffset"+$fitJoints[$i]+"2"+$side)`;
			$worldUpObject=$tempString[0];
			connectAttr ($worldUpObject+".worldMatrix") ("Bendy2FollowAM"+$fitJoints[$i]+$side+".secondaryTargetMatrix");

			createNode -n ("Bendy2FollowMM"+$fitJoints[$i]+$side) multMatrix;
			connectAttr ("Bendy2FollowAM"+$fitJoints[$i]+$side+".outputMatrix") ("Bendy2FollowMM"+$fitJoints[$i]+$side+".matrixIn[0]");
			$tempString=`listRelatives -p ("BendOffset"+$fitJoints[$i]+"2"+$side)`;
			connectAttr ($tempString[0]+".worldInverseMatrix") ("Bendy2FollowMM"+$fitJoints[$i]+$side+".matrixIn[1]");

//			connectAttr ("Bendy2FollowMM"+$fitJoints[$i]+$side+".matrixSum") ("BendOffset"+$fitJoints[$i]+"2"+$side+".offsetParentMatrix");
			createNode -n ("Bendy2FollowPM"+$fitJoints[$i]+$side) pickMatrix;
			connectAttr ("Bendy2FollowMM"+$fitJoints[$i]+$side+".matrixSum") ("Bendy2FollowPM"+$fitJoints[$i]+$side+".inputMatrix");
			setAttr ("Bendy2FollowPM"+$fitJoints[$i]+$side+".useScale") 0;
			setAttr ("Bendy2FollowPM"+$fitJoints[$i]+$side+".useShear") 0;
			connectAttr ("Bendy2FollowPM"+$fitJoints[$i]+$side+".outputMatrix") ("BendOffset"+$fitJoints[$i]+"2"+$side+".offsetParentMatrix");

			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 ("BendOffset"+$fitJoints[$i]+"2"+$side);
			}
		else
			{
			$contraintTo="FKX"+$fitJointChild[$i]+$childSide;
			$contraintTo2="FKX"+$fitJoints[$i]+$side;
			if (`objExists ("FKIKMix"+$fitJointChild[$i]+$childSide)`)
				$contraintTo="FKIKMix"+$fitJointChild[$i]+$childSide;
			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide)`)
				$contraintTo="Bend"+$fitJointChild[$i]+"1"+$childSide;
			if (`objExists ("Bend"+$fitJoints[$i]+"1"+$side)`)
				$contraintTo2="Bend"+$fitJoints[$i]+"1"+$side;

			if ($fitJointBendyJoints[$i] && `objExists $contraintTo` && `objExists $contraintTo2`)
				{
				$tempString=`listRelatives -p ("BendOffset"+$fitJoints[$i]+"2"+$side)`;
				$worldUpObject=$tempString[0];
				aimConstraint -offset 0 0 0 -aimVector (1*$c) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject $worldUpObject
					$contraintTo  ("BendOffset"+$fitJoints[$i]+"2"+$side);
				pointConstraint $contraintTo2 $contraintTo ("BendOffset"+$fitJoints[$i]+"2"+$side);
				//only half the rot from aim
				createNode -n ("BendOffset"+$fitJoints[$i]+"2AimMPD"+$side) multiplyDivide;
				for ($z=0;$z<size($XYZ);$z++)
					{
					connectAttr ("BendOffset"+$fitJoints[$i]+"2"+$side+"_aimConstraint1.constraintRotate.constraintRotate"+$XYZ[$z]) ("BendOffset"+$fitJoints[$i]+"2AimMPD"+$side+".input1"+$XYZ[$z]);
					setAttr ("BendOffset"+$fitJoints[$i]+"2AimMPD"+$side+".input2"+$XYZ[$z]) 0.5;
					connectAttr -f ("BendOffset"+$fitJoints[$i]+"2AimMPD"+$side+".output"+$XYZ[$z]) ("BendOffset"+$fitJoints[$i]+"2"+$side+".rotate"+$XYZ[$z]);
					}
				}
			}
		}

//volume (Squash Scaling) - `IK setup` part 
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;

//		if ($opm)
//			continue;

		$ikHandle = ("IK"+$fitJointIK[$i]+$side);
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			$ikHandle = ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $ikHandle;
		createNode -n ("volume"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion; 
		setAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ($ikHandle+".volume") ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("multWithStretchy"+$fitJointIK[$i]+$side) multiplyDivide;
		connectAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input1X");
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ($fitJointIK[$i]+"StretchyUnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input2X");
		createNode -n ("volume1Over"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".operation") 2;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");
		else
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");			
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".input1X") 1;
		createNode -n ("volumepow"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".operation") 3;
		connectAttr ("volume1Over"+$fitJointIK[$i]+$side+".outputX") ("volumepow"+$fitJointIK[$i]+$side+".input1X");
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".input2X") 0.5;
		createNode -n ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side) blendTwoAttr;
		connectAttr ("multWithStretchy"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".attributesBlender");
		setAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[0]") 1;
		connectAttr ("volumepow"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[1]");
		}

//volume (Squash Scaling) - `Connect to scale` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJoints[$i]=="Root")
			continue;
		if ($isIKEnd[$i] || $isIKBelowIKEnd[$i])
			continue;

//		if ($opm)
//			continue;

		$volumeOutPlug="volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output";
//		if (`objExists ("IKScaler"+$fitJoints[$i]+$side)`)
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			createNode -n ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side) plusMinusAverage;
			createNode -n ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side) plusMinusAverage;
			connectAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output") ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[0]");
			setAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[1]") -1;
			setAttr ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[1]") 1;

			createNode -n ("IKSquashDistributer"+$fitJoints[$i]+$side) multiplyDivide;
			connectAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".output1D") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input1X");
			connectAttr ("IKScaler"+$fitJoints[$i]+$side+".scalerWeight") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input2X");

			connectAttr ("IKSquashDistributer"+$fitJoints[$i]+$side+".outputX") ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[0]");
			$volumeOutPlug="IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".output1D";
			}

		if (`objExists ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side)`)//splineIkScaling
			{
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2X");
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Y");
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Z");
			}
//		else if (!$opm)
		else
			{
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1R");
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
			}
		}

//Advanced Ik Fatness
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

//		if ($opm)
//			continue;
		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if ($isIKBelowIKEnd[$i])
			continue;
		if ($fitJointIKSolver[$i]!="ikRPsolver")
			continue;

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			//IkFatnessControl
			$tempString2[0]=`substitute "IKX" $tempString[0] ""`;
			$tempString3=`listConnections -p 1 ("ScaleBlend"+$tempString2[0]+".color1G")`;
			if ($tempString3[0]=="")
				continue;
			connectAttr $tempString3[0] ("fatness"+$tempString[0]+".input1D[1]");
			connectAttr -f ("fatness"+$tempString[0]+".output1D") ("ScaleBlend"+$tempString2[0]+".color1G");
			connectAttr -f ("fatness"+$tempString[0]+".output1D") ("ScaleBlend"+$tempString2[0]+".color1B");

			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}
		}

//Advanced Follow
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M" && $fitJointsFollowSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		if ($fitJointsFollowSide[$i]!="_M" && $side!="_M")
			$fitJointsFollowSide[$i]=$side;

		if ($fitJointsFollow[$i]=="")
			continue;

		//special case Middle controller following both Left & Right controller
		if ($b==-1 && $fitJointSide[$i]=="_M" && $fitJointsFollowSide[$i]!="_M")
			$side="_M";


		$tempString=`listRelatives -c -type transform ("FKOffset"+$fitJoints[$i]+$side)`;
		if (`objExists ("Follow"+$fitJoints[$i]+$side)`)//special case Middle controller following both Left & Right controller
			{
			orientConstraint -mo ($fitJointsFollow[$i]+$fitJointsFollowSide[$i]) ("Follow"+$fitJoints[$i]+$side);
			setAttr ("FKFollow"+$fitJoints[$i]+$side+"_orientConstraint1.interpType") 2;//(swap to average since L & R are opposite oriented)
			}
		else
			{
			createNode -n ("Follow"+$fitJoints[$i]+$side) -p ($fitJointsFollow[$i]+$fitJointsFollowSide[$i]) transform;
			createNode -n ("Static"+$fitJoints[$i]+$side) -p ($fitJointsFollow[$i]+$fitJointsFollowSide[$i]) transform;
			createNode -n ("FKFollow"+$fitJoints[$i]+$side) -p ($fitJointsFollow[$i]+$fitJointsFollowSide[$i]) transform;
			parent ("Follow"+$fitJoints[$i]+$side) ("Static"+$fitJoints[$i]+$side) ("FKFollow"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side);
			if (!$fitJointsFollowPivot[$i])
				xform -os -t 0 0 0 -ro 0 0 0 ("Follow"+$fitJoints[$i]+$side) ("Static"+$fitJoints[$i]+$side) ("FKFollow"+$fitJoints[$i]+$side);
			createNode -n ("FKFollowReOffset"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
			parent ("FKFollowReOffset"+$fitJoints[$i]+$side) ("FKFollow"+$fitJoints[$i]+$side);
			orientConstraint -mo ($fitJointsFollow[$i]+$fitJointsFollowSide[$i]) ("Follow"+$fitJoints[$i]+$side);
			orientConstraint ("Static"+$fitJoints[$i]+$side) ("Follow"+$fitJoints[$i]+$side) ("FKFollow"+$fitJoints[$i]+$side);
			setAttr ("FKFollow"+$fitJoints[$i]+$side+"_orientConstraint1.interpType") 2;//(shortest)

			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 ("FK"+$fitJoints[$i]+$side);
			asUnitConvertAndReverse ("Follow"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side+".follow");
			connectAttr ("Follow"+$fitJoints[$i]+$side+"Reverse.outputX") ("FKFollow"+$fitJoints[$i]+$side+"_orientConstraint1.Static"+$fitJoints[$i]+$side+"W0");
			connectAttr ("Follow"+$fitJoints[$i]+$side+"UnitConversion.output") ("FKFollow"+$fitJoints[$i]+$side+"_orientConstraint1.Follow"+$fitJoints[$i]+$side+"W1");

			for ($y=0;$y<size($tempString);$y++)
				parent $tempString[$y] ("FKFollowReOffset"+$fitJoints[$i]+$side);
			}
		}

//Advanced IkFollow
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		if ($fitJointsIkFollowSide[$i]!="_M")
			$fitJointsIkFollowSide[$i]=$side;

		if ($fitJointsIkFollow[$i]=="")
			continue;
		if ($fitJoints[$i]!=$fitJointIKEndJoint[$i])
			continue;

		$tempString=`listRelatives -c -type transform ("IKOffset"+$fitJointIK[$i]+$side)`;
		createNode -n ("Follow"+$fitJointIK[$i]+$side) -p ("IKOffset"+$fitJointIK[$i]+$side) transform;
		createNode -n ("Static"+$fitJointIK[$i]+$side) -p ("IKOffset"+$fitJointIK[$i]+$side) transform;
		createNode -n ("IKFollow"+$fitJointIK[$i]+$side) -p ("IKOffset"+$fitJointIK[$i]+$side) transform;
		parentConstraint -mo ($fitJointsIkFollow[$i]+$fitJointsIkFollowSide[$i]) ("Follow"+$fitJointIK[$i]+$side);
		parentConstraint ("Static"+$fitJointIK[$i]+$side) ("Follow"+$fitJointIK[$i]+$side) ("IKFollow"+$fitJointIK[$i]+$side);
//		setAttr ("IKFollow"+$fitJointIK[$i]+$side+"_orientConstraint1.interpType") 2;//(shortest)

		addAttr -k 1 -ln ikFollow -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
		asUnitConvertAndReverse ("Follow"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side+".ikFollow");
		connectAttr ("Follow"+$fitJointIK[$i]+$side+"Reverse.outputX") ("IKFollow"+$fitJointIK[$i]+$side+"_parentConstraint1.Static"+$fitJointIK[$i]+$side+"W0");
		connectAttr ("Follow"+$fitJointIK[$i]+$side+"UnitConversion.output") ("IKFollow"+$fitJointIK[$i]+$side+"_parentConstraint1.Follow"+$fitJointIK[$i]+$side+"W1");

		for ($y=0;$y<size($tempString);$y++)
			parent $tempString[$y] ("IKFollow"+$fitJointIK[$i]+$side);
		}

//Advanced Attach
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointsAttachTo[$i]=="")
			continue;

		if (`gmatch $fitJointsAttachTo[$i] "*_R"`)
			if ($side=="_L")
				{
				$tempString[0]=`substitute "_R" $fitJointsAttachTo[$i] "_L"`;
				if (`objExists $tempString[0]`)
					$fitJointsAttachTo[$i]=$tempString[0];
				}

		if (`objExists closestSampler`)
			delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		connectAttr -f ($fitJointsAttachTo[$i]+".outMesh") closestSampler.inMesh;
		$temp=`xform -q -ws -t $fitJoints[$i]`;
		setAttr closestSampler.inPosition ($temp[0]*$b) $temp[1] $temp[2];
		int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
		delete closestSampler;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		$offsetParent=$tempString[0];
		createNode -n ("FKAttach"+$fitJoints[$i]+$side) transform;
		createNode -n ("Attach"+$fitJoints[$i]+$side) transform;
		createNode -n ("Detach"+$fitJoints[$i]+$side) transform;
		createNode -n ("FKAttachOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAttachOffset"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side) 1 1 0 0;
		select -r ($fitJointsAttachTo[$i]+".f["+$closestFaceIndex+"]");
		select -add ("Attach"+$fitJoints[$i]+$side);
		doCreatePointOnPolyConstraintArgList 1 { "0","0","0","1","","1" };
		$tempString=`listConnections ("Attach"+$fitJoints[$i]+$side+".tx")`;
		if ($fitJointsAttachMode[$i]=="point")
			{
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateX") ("Attach"+$fitJoints[$i]+$side+".rx");
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateY") ("Attach"+$fitJoints[$i]+$side+".ry");
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateZ") ("Attach"+$fitJoints[$i]+$side+".rz");
			}
		if ($fitJointsAttachMode[$i]=="orient")
			{
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateX") ("Attach"+$fitJoints[$i]+$side+".tx");
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateY") ("Attach"+$fitJoints[$i]+$side+".ty");
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateZ") ("Attach"+$fitJoints[$i]+$side+".tz");
			}

		asAlign ("FKAttach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side) 1 1 0 0;
		asAlign ("Detach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("FKAttach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side)  ("Detach"+$fitJoints[$i]+$side) $offsetParent;

		parent ("FKAttachOffset"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAttachOffset"+$fitJoints[$i]+$side);
//		parent `listRelatives -c -type transform ("FKOffset"+$fitJoints[$i]+$side)` ("FKAttach"+$fitJoints[$i]+$side);

		parentConstraint ("Attach"+$fitJoints[$i]+$side) ("Detach"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln attach -at double -min 0 -max 10 -dv 10 ("FK"+$fitJoints[$i]+$side);
		createNode -n ("FK"+$fitJoints[$i]+$side+"AttachSetRange") setRange;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.minX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.minY") 1;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.maxX") 1;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.maxY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMinX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMinY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMaxX") 10;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMaxY") 10;
		connectAttr ("FK"+$fitJoints[$i]+$side+".attach") ("FK"+$fitJoints[$i]+$side+"AttachSetRange.value.valueX");
		connectAttr ("FK"+$fitJoints[$i]+$side+".attach") ("FK"+$fitJoints[$i]+$side+"AttachSetRange.value.valueY");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.outValue.outValueX") ("FKAttach"+$fitJoints[$i]+$side+"_parentConstraint1."+"Attach"+$fitJoints[$i]+$side+"W0");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.outValue.outValueY") ("FKAttach"+$fitJoints[$i]+$side+"_parentConstraint1."+"Detach"+$fitJoints[$i]+$side+"W1");
		}

//Advanced AimAt
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		$c=$b;
		if ($fitJointNoFlip[$i] && $b==-1) $c=1;
		$d=$b;

		if ($fitJointIsEndJoint[$i])
			continue;

		if (($fitJointsAimAt[$i]=="" || !`objExists $fitJointsAimAt[$i]`) && $fitJointsAimConstraint[$i]=="")
			continue;

		if ($fitJointsAimAxis[$i]==0) {$aimX=1;$aimY=0;$aimZ=0;}
		if ($fitJointsAimAxis[$i]==1) {$aimX=0;$aimY=1;$aimZ=0;}
		if ($fitJointsAimAxis[$i]==2) {$aimX=0;$aimY=0;$aimZ=1;}
		if ($fitJointsAimUpAxis[$i]==0) {$xUp=1;$yUp=0;$zUp=0;}
		if ($fitJointsAimUpAxis[$i]==1) {$xUp=0;$yUp=1;$zUp=0;}
		if ($fitJointsAimUpAxis[$i]==2) {$xUp=0;$yUp=0;$zUp=1;}

		if ($fitJointsAimConstraint[$i]!="")
			{
			$aimX=`getAttr ($fitJointsAimConstraint[$i]+".aimVectorX")`;
			$aimY=`getAttr ($fitJointsAimConstraint[$i]+".aimVectorY")`;
			$aimZ=`getAttr ($fitJointsAimConstraint[$i]+".aimVectorZ")`;
			$xUp=`getAttr ($fitJointsAimConstraint[$i]+".upVectorX")`;
			$yUp=`getAttr ($fitJointsAimConstraint[$i]+".upVectorY")`;
			$zUp=`getAttr ($fitJointsAimConstraint[$i]+".upVectorZ")`;
			$xOff=`getAttr ($fitJointsAimConstraint[$i]+".offsetX")`;
			$yOff=`getAttr ($fitJointsAimConstraint[$i]+".offsetY")`;
			$zOff=`getAttr ($fitJointsAimConstraint[$i]+".offsetZ")`;
			$xWorldUp=`getAttr ($fitJointsAimConstraint[$i]+".worldUpVectorX")`;
			$yWorldUp=`getAttr ($fitJointsAimConstraint[$i]+".worldUpVectorY")`;
			$zWorldUp=`getAttr ($fitJointsAimConstraint[$i]+".worldUpVectorZ")`;
			$worldUpType=`getAttr -asString ($fitJointsAimConstraint[$i]+".worldUpType")`;
			if ($worldUpType=="Scene Up") $worldUpType="scene";
			if ($worldUpType=="Object Up") $worldUpType="object";
			if ($worldUpType=="Object Rotation Up") $worldUpType="objectrotation";
			if ($worldUpType=="Vector") $worldUpType="vector";
			if ($worldUpType=="None") $worldUpType="none";
			$tempString=`listConnections ($fitJointsAimConstraint[$i]+".worldUpMatrix")`;
			if ($tempString[0]=="")			
				$worldUpObject=$fitJoints[$i];//placeHolder
			else
				$worldUpObject=$tempString[0];
			$tempString=`listConnections ($fitJointsAimConstraint[$i]+".target[0].targetParentMatrix")`;
			$fitJointsAimAt[$i]=$tempString[0];
			}
		else
			{
			$worldUpType="objectrotation";
			$xWorldUp=0;
			$yWorldUp=$b;
			$zWorldUp=0;
			$worldUpObject="AimAt"+$fitJoints[$i]+$side;
			}

		$aimAtSide=$side;
		$pos=`xform -q -ws -t $fitJointsAimAt[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$aimAtSide="_M";
		if (!`objExists ("FK"+$fitJointsAimAt[$i]+$aimAtSide)`)
			{
			warning ("Unable to add aimAt, target not found:\"FK"+$fitJointsAimAt[$i]+$aimAtSide+"\"");
			continue;
			}

		createNode -n ("FKAimAt"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("AimAt"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("Static"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("AimAt"+$fitJoints[$i]+$side) ("FK"+$fitJointsAimAt[$i]+$aimAtSide) 1 1 0 0;
		asAlign ("Static"+$fitJoints[$i]+$side) ("FK"+$fitJointsAimAt[$i]+$aimAtSide) 1 1 0 0;
		$parent="FKExtra"+$fitJoints[$i]+$side;
		if (`objExists ("FKFlip"+$fitJoints[$i]+$side)`)
			$parent="FKFlip"+$fitJoints[$i]+$side;
		parent $parent ("FKAimAt"+$fitJoints[$i]+$side);
		parent ("AimAt"+$fitJoints[$i]+$side) ("FK"+$fitJointsAimAt[$i]+$aimAtSide);

		aimConstraint -offset $xOff $yOff $zOff -aimVector ($aimX*$c) ($aimY*$c) ($aimZ*$c) -upVector ($xUp*$d) ($yUp*$d) ($zUp*$d)
			-worldUpType $worldUpType -worldUpVector $xWorldUp $yWorldUp $zWorldUp -worldUpObject ($worldUpObject+$aimUpSide)
			("AimAt"+$fitJoints[$i]+$side) ("Static"+$fitJoints[$i]+$side) ("FKAimAt"+$fitJoints[$i]+$side);

		addAttr -k 1 -ln aimAt -at double -min 0 -max 10 -dv 10 ("FK"+$fitJoints[$i]+$side);
		createNode -n ("FK"+$fitJoints[$i]+$side+"AimAtSetRange") setRange;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.minX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.minY") 1;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.maxX") 1;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.maxY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMinX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMinY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMaxX") 10;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMaxY") 10;
		connectAttr ("FK"+$fitJoints[$i]+$side+".aimAt") ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.value.valueX");
		connectAttr ("FK"+$fitJoints[$i]+$side+".aimAt") ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.value.valueY");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.outValue.outValueX") ("FKAimAt"+$fitJoints[$i]+$side+"_aimConstraint1."+"AimAt"+$fitJoints[$i]+$side+"W0");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.outValue.outValueY") ("FKAimAt"+$fitJoints[$i]+$side+"_aimConstraint1."+"Static"+$fitJoints[$i]+$side+"W1");
		}

//Advanced CurveGuide
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;
		$c=$b;
		if ($fitJointNoFlip[$i] && $b==-1) $c=1;

		if ($fitJointsCurveGuide[$i]=="" || !`objExists $fitJointsCurveGuide[$i]`)
			continue;

		if (!`objExists CurveGuideSystem`)
			{
			createNode -n CurveGuideSystem -p MotionSystem transform;
			setAttr -l 1 CurveGuideSystem.inheritsTransform 0;
			}
		
		$curveGuide=$fitJointsCurveGuide[$i]+$side;
		$tempString=`listRelatives -p $fitJointsCurveGuide[$i]`;
		if ($tempString[0]=="")
			parent $fitJointsCurveGuide[$i] FitSkeleton;
		if (`attributeExists curveGuide $fitJointsCurveGuide[$i]`) deleteAttr ($fitJointsCurveGuide[$i]+".curveGuide");
		if (!`objExists $curveGuide`)
			{
			duplicate -n $curveGuide $fitJointsCurveGuide[$i];
			makeIdentity -a 1 -t 1 -r 1 -s 1 $curveGuide;
			asLockAttr $curveGuide 1 1 1 1;
			sets -add ControlSet $curveGuide;
			setAttr ($curveGuide+"Shape.overrideEnabled") 1;
			setAttr ($curveGuide+"Shape.overrideColor") 17;
//			setAttr ($curveGuide+".v") 1;
			parent $curveGuide CurveGuideSystem;
			if ($side=="_L")
				scale -r -p 0 0 0 -1 1 1 ($curveGuide+".cv[0:999]");
			}

		$tempString=`listRelatives -p -type transform ("FKOffset"+$fitJoints[$i]+$side)`;
		$offsetParent=$tempString[0];
		createNode -n ("FKCurveGuide"+$fitJoints[$i]+$side) -p $offsetParent transform;
		asAlign ("FKCurveGuide"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 1 0 0;

		createNode -n ("CurveGuideOnCurve"+$fitJoints[$i]+$side) -p ("FK"+$fitJoints[$i]+$side) transform;

		geometryConstraint $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);
		$pos=`xform -q -ws -t ("FK"+$fitJoints[$i]+$side)`;
		$pos2=`xform -q -ws -t ("CurveGuideOnCurve"+$fitJoints[$i]+$side)`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		delete ("CurveGuideOnCurve"+$fitJoints[$i]+$side+"_geometryConstraint1");
		setAttr -type float3 ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".t") ($dist*$c) 0 0;
		geometryConstraint $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);

		for ($y=0;$y<99;$y++)
			{
			setAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".ty") 0;
			setAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".tz") 0;
			}
		delete ("CurveGuideOnCurve"+$fitJoints[$i]+$side+"_geometryConstraint1");
		parent ("CurveGuideOnCurve"+$fitJoints[$i]+$side) CurveGuideSystem;

		extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 $curveGuide;
		createNode -n tempSampler closestPointOnSurface;
		connectAttr tempSurface.worldSpace[0] tempSampler.inputSurface;
		connectAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".translate") tempSampler.inPosition;

		createNode -n ("CurveGuideInfo"+$fitJoints[$i]+$side) pointOnCurveInfo;
		connectAttr -f ($curveGuide+".worldSpace") ("CurveGuideInfo"+$fitJoints[$i]+$side+".inputCurve");
		setAttr ("CurveGuideInfo"+$fitJoints[$i]+$side+".parameter") `getAttr tempSampler.result.parameterU`;

		connectAttr ("CurveGuideInfo"+$fitJoints[$i]+$side+".position") ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".t");
		tangentConstraint -weight 1 -aimVector $c 0 0 -upVector 0 0 1
			-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("FK"+$fitJointParent[$i]+$parentSide) $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);

		createNode -n ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) transform;
		$tempString=`listRelatives -p ("FKCurveGuide"+$fitJoints[$i]+$side)`;
		parent ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) $tempString[0];
		createNode -n ("CurveGuideStatic"+$fitJoints[$i]+$side) -p ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("CurveGuideStatic"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) 1 1 0 0;

		delete tempSurface tempSampler;

		asCreateController "IK" $fitJoints[$i] $side $fitJoints[$i];
		if ($opm)
			parent ("IKOffset"+$fitJoints[$i]+$side) IKHandle;
		else
			parent ("IKOffset"+$fitJoints[$i]+$side) IKHandleFollowMain;
		if (!`attributeExists guideTargetsVis Main`)
			{
			addAttr -k 1 -ln guideTargetsVis -at bool -dv 0 Main;
			setAttr -k 0 -cb 1 Main.guideTargetsVis;
			}
		connectAttr Main.guideTargetsVis ("IKOffset"+$fitJoints[$i]+$side+".v");
		xform -os -t 0 0 0 ("IKOffset"+$fitJoints[$i]+$side);
		scale -r -p 0 0 0 0.3 0.3 0.3 ("IK"+$fitJoints[$i]+$side+".cv[0:99]");
//		asAlign ("IKOffset"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) 1 1 0 0;
		parentConstraint ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideStatic"+$fitJoints[$i]+$side) ("IKOffset"+$fitJoints[$i]+$side);

		aimConstraint -aimVector $c 0 0 -upVector 0 0 1
			-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("IK"+$fitJoints[$i]+$side) ("IK"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 -1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideStatic"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 90 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("FK"+$fitJointParent[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 0 -aimVector (1*$b) 0 0 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("FKCurveGuideUpVec"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

		if (!`attributeExists blend $curveGuide`)
			addAttr -k 1 -ln blend -at double -min 0 -max 10 -dv 10 $curveGuide;
		if (!`objExists ($curveGuide+"BlendUnitConversion")`)
			{
			createNode -n ($curveGuide+"BlendUnitConversion") unitConversion;
			setAttr ($curveGuide+"BlendUnitConversion.conversionFactor") 0.1;
			connectAttr ($curveGuide+".blend") ($curveGuide+"BlendUnitConversion.input");
			createNode -n ($curveGuide+"BlendReverse") reverse;
			connectAttr ($curveGuide+"BlendUnitConversion.output") ($curveGuide+"BlendReverse.inputX");
			}
//		connectAttr ($curveGuide+"BlendUnitConversion.output") ("FKCurveGuide"+$fitJoints[$i]+$side+"_aimConstraint1.CurveGuideOnCurve"+$fitJoints[$i]+$side+"W0");
//		connectAttr ($curveGuide+"BlendReverse.outputX") ("FKCurveGuide"+$fitJoints[$i]+$side+"_aimConstraint1.CurveGuideStatic"+$fitJoints[$i]+$side+"W1");
		connectAttr ($curveGuide+"BlendUnitConversion.output") ("IKOffset"+$fitJoints[$i]+$side+"_parentConstraint1.CurveGuideOnCurve"+$fitJoints[$i]+$side+"W0");
		connectAttr ($curveGuide+"BlendReverse.outputX") ("IKOffset"+$fitJoints[$i]+$side+"_parentConstraint1.CurveGuideStatic"+$fitJoints[$i]+$side+"W1");

		createNode -n ("FKCurveGuideOffset"+$fitJoints[$i]+$side) -p $offsetParent transform;
		asAlign ("FKCurveGuideOffset"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("FKCurveGuide"+$fitJoints[$i]+$side) ("FKCurveGuideOffset"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

//		$tempString=`listRelatives -c -type transform ("FKOffset"+$fitJoints[$i]+$side)`;
//		$tempString=`stringArrayRemove {("FKCurveGuide"+$fitJoints[$i]+$side)} $tempString`;
//		parent $tempString ("FKCurveGuide"+$fitJoints[$i]+$side);

		//CurveGuide controllers
		$spans=`getAttr ($curveGuide+".spans")`;
		$degree=`getAttr ($curveGuide+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$side="_R";
			$pos=`xform -q -ws -t ($curveGuide+".cv["+$y+"]")`;
//			if ($pos[0]==0) $side="_M";
//			if ($pos[0]>0) $side="_L";
			if ($pos[0]>$sideTreshold) $side="_L";
			else if ($pos[0]<($sideTreshold*-1)) $side="_R";
			else $side="_M";
			$ctrl="IK"+$fitJointsCurveGuide[$i]+"Ctrl"+$y+$side;
			if (`objExists $ctrl`)
				continue;

			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] $ctrl;
			$tempString=`listRelatives -s $ctrl`;
			rename $tempString[0] ($ctrl+"Shape");
			setAttr ($ctrl+"Shape.overrideEnabled") 1;
			setAttr ($ctrl+"Shape.overrideColor") 17;
			sets -add ControlSet $ctrl;
			scale -r -p 0 0 0 ($scale/1.0) ($scale/1.0) ($scale/1.0) ($ctrl+".cv[0:4]");
			createNode -n ($ctrl+"Offset") -p CurveGuideSystem transform;
			parent $ctrl ($ctrl+"Offset");
			$tempString=`spaceLocator`;
			rename $tempString[0] ($ctrl+"Loc");
			parent ($ctrl+"Loc") $ctrl;
			setAttr -l 1 ($ctrl+"Loc.v") 0;

			$pos=`xform -q -ws -t ($curveGuide+".cv["+$y+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($ctrl+"Offset");

			connectAttr -f ($ctrl+"Loc.worldPosition[0]") ($curveGuide+".controlPoints["+$y+"]");

			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 $ctrl;
			createNode -n ($ctrl+"FollowSetRange") setRange;
			setAttr ($ctrl+"FollowSetRange.minX") 0;setAttr ($ctrl+"FollowSetRange.minY") 1;
			setAttr ($ctrl+"FollowSetRange.maxX") 1;setAttr ($ctrl+"FollowSetRange.maxY") 0;
			setAttr ($ctrl+"FollowSetRange.oldMinX") 0;setAttr ($ctrl+"FollowSetRange.oldMinY") 0;
			setAttr ($ctrl+"FollowSetRange.oldMaxX") 10;setAttr ($ctrl+"FollowSetRange.oldMaxY") 10;
			connectAttr ($ctrl+".follow") ($ctrl+"FollowSetRange.value.valueX");
			connectAttr ($ctrl+".follow") ($ctrl+"FollowSetRange.value.valueY");

			createNode -n ($ctrl+"FollowOn") -p $ctrl transform;
			createNode -n ($ctrl+"FollowOff") -p $ctrl transform;
			parent ($ctrl+"FollowOn") CurveGuideSystem;
			parent ($ctrl+"FollowOff") GlobalFollowMain;
			parentConstraint -mo `asNearestFeatherParent $ctrl $fitJointsCurveGuide[$i]` ($ctrl+"FollowOn");
			parentConstraint ($ctrl+"FollowOn") ($ctrl+"FollowOff") ($ctrl+"Offset");
			connectAttr ($ctrl+"FollowSetRange.outValue.outValueX") ($ctrl+"Offset_parentConstraint1."+$ctrl+"FollowOnW0");
			connectAttr ($ctrl+"FollowSetRange.outValue.outValueY") ($ctrl+"Offset_parentConstraint1."+$ctrl+"FollowOffW1");
			scaleConstraint Main ($ctrl+"Offset");
			}
		}

//Advanced Wheel / RollingBall
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$fitJointsWheel[$i] && !$fitJointsRollingBall[$i])
			continue;

		if (!`objExists ("FK"+$fitJoints[$i]+$side)`)
			{
			warning ("Found Wheel/RollingBall FitAttribute, but \""+$fitJoints[$i]+"\" does not haev a FK controller, skipping.\n");
			continue;
			}

		if (!`objExists WheelSystem`)
			{
			createNode -n WheelSystem -p MotionSystem transform;
			setAttr -l 1 WheelSystem.inheritsTransform 0;
			}

		xform -os -t 0 -0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[0]");
		xform -os -t 0 0 -1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[1]");
		xform -os -t 0 0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[2]");
		xform -os -t 0 1.108194 0  ("FK"+$fitJoints[$i]+$side+"Shape.cv[3]");
		xform -os -t 0 0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[4]");
		xform -os -t 0 0 1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[5]");
		xform -os -t 0 -0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[6]");
		xform -os -t 0 -1.108194 0 ("FK"+$fitJoints[$i]+$side+"Shape.cv[7]");

		$temp=`xform -q -ws -t $fitJoints[$i]`;
		$diameter=$temp[1]*2;
		if ($diameter<0.01)//avoid divide by zero
			$diameter=1;
//		float $scaleFactor= $diameter * 1.1054;// 1.1054->nurbs
		$scaleFactor=$diameter/2.0;
		xform -ws -s $scaleFactor $scaleFactor $scaleFactor ("FK"+$fitJoints[$i]+$side+"Shape.cv[0:999]");
		addAttr -k 1 -ln "diameter" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln "autoRoll" -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "reset" -at bool -dv 0 ("FK"+$fitJoints[$i]+$side);
//		addAttr -k 1 -ln "ball" -at bool -dv 0 ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosX" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosY" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosZ" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);

		createNode -n ("prevPosOffset"+$fitJoints[$i]+$side) -p WheelSystem transform;
		createNode -n ("prevPos"+$fitJoints[$i]+$side) -p ("prevPosOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("prevPosAngler"+$fitJoints[$i]+$side) -p ("prevPos"+$fitJoints[$i]+$side) transform;
		createNode -n ("nowPos"+$fitJoints[$i]+$side) -p WheelSystem transform;
		pointConstraint ("FK"+$fitJoints[$i]+$side) ("nowPos"+$fitJoints[$i]+$side);
		asAlign ("prevPosOffset"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 0 0 0;
		$temp=`xform -q -ws -ro ("FK"+$fitJoints[$i]+$side)`;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rz") 90;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rx") $temp[1];
		duplicate -n ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		parent ("prevPosSteer"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side);
		orientConstraint ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "vector" -worldUpVector 0 1 0 ("FK"+$fitJoints[$i]+$side) ("prevPos"+$fitJoints[$i]+$side);

		$sideFactor=$b;

		$exp="";
		$exp+="float $diameter = FK"+$fitJoints[$i]+$side+".diameter;\n";
		$exp+="float $autoRoll = FK"+$fitJoints[$i]+$side+".autoRoll;\n";
		$exp+="float $reset = FK"+$fitJoints[$i]+$side+".reset;\n";
//		$exp+="int $ball = FK"+$fitJoints[$i]+$side+".ball;\n";
		$exp+="float $sideAngle=prevPosAngler"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $scale = MainScaleMultiplyDivide.input1Y;\n";
		$exp+="float $prevPosX=FK"+$fitJoints[$i]+$side+".prevPosX;\n";
		$exp+="float $prevPosY=FK"+$fitJoints[$i]+$side+".prevPosY;\n";
		$exp+="float $prevPosZ=FK"+$fitJoints[$i]+$side+".prevPosZ;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateX=$prevPosX;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateY=$prevPosY;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateZ=$prevPosZ;\n";
		$exp+="float $nowPosX=nowPos"+$fitJoints[$i]+$side+".translateX;\n";
		$exp+="float $nowPosY=nowPos"+$fitJoints[$i]+$side+".translateY;\n";
		$exp+="float $nowPosZ=nowPos"+$fitJoints[$i]+$side+".translateZ;\n";
		$exp+="float $distance=`mag<<$nowPosX-$prevPosX,$nowPosY-$prevPosY,$nowPosZ-$prevPosZ>>`;\n";
		$exp+="float $curRotX=FKX"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $piD = 3.14 * $diameter;\n";
		if ($fitJointsRollingBall[$i])
			{
			$exp+="float $x=($distance/$piD)*360 * $autoRoll * -1 * sin(deg_to_rad($sideAngle)) / $scale;\n";
			$exp+="float $z=($distance/$piD)*360 * $autoRoll * -1 * sin(deg_to_rad($sideAngle-90)) / $scale;\n";
			$exp+="rotate -ws -r $x 0 $z FKX"+$fitJoints[$i]+$side+";\n";
			}
		else
			{
			$exp+="if ($reset) $curRotX=0;\n";//Reset currently only for wheel, not ball
			$exp+="\tFKX"+$fitJoints[$i]+$side+".rotateX=$curRotX+($distance/$piD)*360 * $autoRoll * "+($sideFactor*-1)+" * sin(deg_to_rad($sideAngle)) / $scale;\n";
			}
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosX=$nowPosX;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosY=$nowPosY;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosZ=$nowPosZ;\n";

		expression -n ($fitJoints[$i]+"WheelExpression"+$side) -s $exp -o ("FKX"+$fitJoints[$i]+$side) -ae 1 -uc all ;

		}

//Lock FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		if ($fitJointLockTx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".tx");
		if ($fitJointLockTy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".ty");
		if ($fitJointLockTz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".tz");
		if ($fitJointLockRx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".rx");
		if ($fitJointLockRy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".ry");
		if ($fitJointLockRz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".rz");
		if ($fitJointLockSx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sx");
		if ($fitJointLockSy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sy");
		if ($fitJointLockSz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sz");
		}

//Custom controller shapes
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
		$sca=`xform -q -r -s $fitJoints[$i]`;

		//Head 
		if (`gmatch $fitJoints[$i] "*Head*"` && $fitJointChild[$i]!="")
			{
			$pos2=`xform -q -ws -t $fitJointChild[$i]`;
			xform -r -s 2 2 2 ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			xform -r -ws -t ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
//			xform -s (1/$sca[0]) (1/$sca[1]) (1/$sca[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");//restore uniform scale first
//			float $frontAxisScale=`getAttr ($fitJoints[$i]+".s"+$U)`;
//			xform -s $frontAxisScale $frontAxisScale $frontAxisScale ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			}
		//IKLegs
		if (`gmatch $fitJointLabel[$i] "*Foot*"` && `objExists ("IK"+$fitJointIK[$i]+$side)`)
			{
			//First find $toesEnd
			$toesEnd="";
			$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
			for ($y=0;$y<size($tempString);$y++)
				{
				$childLabel=`asLabel $tempString[$y]`;
				if (`gmatch $childLabel "*ToesEnd*"`)
					$toesEnd=$tempString[$y];
				}
			$numCVs=`getAttr ("IK"+$fitJointIK[$i]+$side+".spans")`+`getAttr ("IK"+$fitJointIK[$i]+$side+".degree")`;
			if ($toesEnd!="")
				for ($y=0;$y<$numCVs;$y++)
					{
					$temp=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]")`;
					$temp2=`xform -q -ws -t ("IKX"+$fitJoints[$i]+$side)`;
					if ($fitJointQtoes[$i]!="")
						$temp2=`xform -q -ws -t ("IKX"+$fitJointQtoes[$i]+$side)`;
					$temp3=`xform -q -ws -t ($toesEnd+$side)`;
					if ($temp[1]<$temp2[1])
						{
						xform -ws -t $temp[0] 0 $temp[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						if ($temp[2]>$temp2[2])
							xform -ws -t $temp[0] 0 $temp3[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						}
					}
			$temp=`xform -q -ws -t ($fitJoints[$i]+$side)`;
			if ($fitJointQtoes[$i]!="")
				$temp=`xform -q -ws -t ($fitJointQtoes[$i]+$side)`;
			else
				rotate -r -p $temp[0] $temp[1] $temp[2] -ws 0 ($footRotOut[$i]*$b) 0 ("IK"+$fitJointIK[$i]+$side+".cv[0:99]");
			}
		}

//Default System values
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		if (`gmatch $fitJointLabel[$i] "*Foot*"`)
			{
			//Legs in IK
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") $udMax;
			//Legs have pole follow
			setAttr ("Pole"+$fitJointIK[$i]+$side+".follow") $udMax;
			addAttr -e -dv $udMax ("Pole"+$fitJointIK[$i]+$side+".follow");
			}
		}

delete "iconsGroup";

//Remove endJoints from DeformSet
$deformJoints=`listRelatives -type joint -ad "DeformationSystem"`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		sets -rm DeformSet $deformJoints[$i];
	}

//delete $fitJointNonDef
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==$fitJointNoMirrorCode[$i]) continue;

		if ($fitJointNonDef[$i])
			delete ($fitJoints[$i]+$side);
		}

//Remove tempInbetweeners
for ($i=0;$i<size($fitJoints);$i++)
	if (`attributeExists tempInbetweener $fitJoints[$i]`)
		{
		$tempString=`listRelatives -c $fitJoints[$i]`;
		$tempString2=`listRelatives -p $fitJoints[$i]`;
		parent $tempString[0] $tempString2[0];
		reorder -front $tempString[0];//ensure it`s first child
		delete $fitJoints[$i];
		}

//buildPose
createNode -n "buildPose" dagPose;
select `sets -q ("ControlSet")`;
$controlSetMembers=`ls -sl`;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	int $kT=0;
	int $kR=0;
	int $kS=0;
	if (`getAttr -k ($controlSetMembers[$i]+".tx")`) $kT=1;
	if (`getAttr -k ($controlSetMembers[$i]+".rx")`) $kR=1;
	if (`getAttr -k ($controlSetMembers[$i]+".sx")`) $kS=1;
	if ($kT || $kR || $kS)
		$setAttrCmd+="xform -os ";
	if ($kT)
		{
		$temp=`xform -q -os -t $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-t "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kR)
		{
		$temp=`xform -q -os -ro $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-ro "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kS)
		{
		$temp=`xform -q -r -os -s $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-s "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kT || $kR || $kS)
		$setAttrCmd+=$controlSetMembers[$i]+";";
	$tempString=`listAttr -k -shortNames -ud $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
if (!`attributeExists udAttr buildPose`)
	addAttr -ln udAttr -dt "string"  buildPose;
setAttr -type "string" buildPose.udAttr $setAttrCmd;

//Ensure mirrored controls
//asMirrorControlCurves 0 ControlSet;

//drivingSystems
//first sorting, so that nested DrivingSystem builds from base-level first
int $dsNum,$numUnderS;
int $maxNumUnderS[];
string $DSs[],$sortedDSs[];
$userAttrs=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	{
	if (!`gmatch $userAttrs[$i] "drivingSystem_*"`)
		continue;
	$dsNum=size($DSs);
	$DSs[$dsNum]=`substitute "drivingSystem_" $userAttrs[$i] ""`;
	string $sdks[]=`listConnections ("FitSkeleton."+$userAttrs[$i])`;
	for ($y=0;$y<size($sdks);$y++)
		{
		$numUnderS=`tokenize $sdks[$y] "_" $tempString`;
		if ($numUnderS>$maxNumUnderS[$dsNum])
			$maxNumUnderS[$dsNum]=$numUnderS;
		}
	}
for ($i=0;$i<99;$i++)
	for ($y=0;$y<size($DSs);$y++)
		if ($maxNumUnderS[$y]==$i)
			$sortedDSs[size($sortedDSs)]=$DSs[$y];

for ($i=0;$i<size($sortedDSs);$i++)
	{
	string $ds=$sortedDSs[$i];
	$numChar=size($ds);
	string $dsObjName=`substring $ds 1 ($numChar-2)`;
	string $dsSide=`substring $ds ($numChar-1) 99`;
	string $sdks[]=`listConnections ("FitSkeleton.drivingSystem_"+$sortedDSs[$i])`;
	string $sdkPlugs[]=`listConnections -p 1 ("FitSkeleton.drivingSystem_"+$sortedDSs[$i])`;

	for ($y=0;$y<size($sdks);$y++)
		{
		$newSDK=`substitute "prefix_" $sdks[$y] ""`;
		duplicate -n $newSDK $sdks[$y];
//		sets -add AllSet $newSDK;
		tokenize $sdkPlugs[$y] "." $tempString;
		string $dsAttrName=$tempString[1];

		tokenize $newSDK "_" $tempString;
		string $drivenObj=$tempString[0];
		if (`gmatch $tempString[0] "SDK*"`)
			$drivenObj=`substring $tempString[0] 4 99`;
		for ($z=1;$z<size($tempString)-1;$z++)
			{
			if ($tempString[$z]=="input")
				break;
			$drivenObj+="_"+$tempString[$z];
			}
		if (!`objExists $drivenObj`)
			{
			warning ("DrivingSystem attempting to drive:\""+$drivenObj+"\", but this object is not found.\n");
			continue;
			}
		string $drivenAttr=$tempString[size($tempString)-1];
		if (`gmatch $drivenAttr "[0-9]"` || `gmatch $drivenAttr "[0-9]"`)//number only atts, is probably a index
			$drivenAttr="input["+$drivenAttr+"]";
		while (`gmatch $drivenAttr "*[0-9]"`)
			{
			$numChar=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChar-1)`;
			}
		string $controllerName=$dsObjName+$dsSide;
		if (!`objExists $controllerName`)
			asDsCreateController $controllerName {$drivenObj};

		string $sdkXform;
		if (`gmatch $drivenObj "bw*"`)
			$sdkXform=$drivenObj;
		else
			{
			$sdkXform="SDK"+$drivenObj;
			if (!`objExists $sdkXform`)
				asDsCreateSDKXform $drivenObj;
			}

		if (`attributeExists $drivenAttr $sdkXform` || `gmatch $drivenAttr "input[[]*"`)
			{
			$blendWeighted=`asEnsureBlendWeighted ($sdkXform+"."+$drivenAttr)`;
			$tempString=`listConnections -s 0 -d 1 -scn 1 ($newSDK+".output")`;
			if (!`stringArrayCount $blendWeighted $tempString`)
				{
				connectAttr ($newSDK+".output") ($blendWeighted+".input["+`getAttr -s ($blendWeighted+".input")`+"]");
				refresh;//for the next connection to count `getAttr -s` correctly
				}
			}
		else
			warning ("failed: connectAttr -f "+$newSDK+".output "+$sdkXform+"."+$drivenAttr+";");

		if (!`attributeExists $dsAttrName $ds`)
			{
			string $addAttrCmd="addAttr -k 1 -ln "+$dsAttrName+" -at \"float\"  ";
			if (`addAttr -q -hasMinValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($newSDK+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasMaxValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($newSDK+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMinValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($newSDK+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMaxValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($newSDK+"."+$dsAttrName)`+" ";
			$addAttrCmd+=$ds;
			eval ($addAttrCmd);
			setAttr -type "string" buildPose.udAttr (`getAttr buildPose.udAttr`+";setAttr "+$ds+"."+$dsAttrName+" 0;");
			}
		$bw=`asEnsureOutputBlendWeighted ($ds+"."+$dsAttrName)`;
		if (`attributeExists $dsAttrName $ds` && `attributeExists "output" $bw`)
			if (!`isConnected ($bw+".output") ($newSDK+".input")`)
				connectAttr -f ($bw+".output") ($newSDK+".input");
		}
	}

//delete any remaining un-used SDK`s
if (`attributeExists drivingSystem FitSkeleton`)
	$sdks=`listConnections -s 1 -d 0 FitSkeleton.drivingSystem`;
for ($y=0;$y<size($sdks);$y++)
	{
	$tempString=`listConnections -s 0 -d 1 ($sdks[$y]+".output")`;
	if (!size($tempString))
		delete $sdks[$y];
	}

//AngleSystem update, since `base` rotation might have changed due to user has altered joint
if (`objExists AngleSystem`)
	{
	$tempString=`listRelatives -c -type transform AngleSystem`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listRelatives -c -type transform $tempString[$i]`;
		for ($y=0;$y<size($tempString2);$y++)
			{
			$tempString3[0]=`substitute "AngleSamplerBase" $tempString2[$y] ""`;
			if (!`objExists $tempString3[0]`)
				continue;
			$rot=`xform -q -ws -ro $tempString3[0]`;
			delete `orientConstraint $tempString3[0] $tempString2[$y]`;
			}
		}
	}

asDsOptimizeControllers;

if (`attributeExists axisChanged FitSkeleton`)
	deleteAttr FitSkeleton.axisChanged;

//selectionChildHighlighting
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists "selectionChildHighlighting" $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".selectionChildHighlighting") 0;

//_NonSymmetry
if (`objExists NonSymmetryFitJoints`)
	{
	$tempString=`listRelatives -c -type joint NonSymmetryFitJoints`;
	
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2[0]=`getAttr ($tempString[$i]+".previousParent")`;
		parent $tempString[$i] $tempString2[0];
		}
	delete NonSymmetryFitJoints;
	}

//Run
if (`attributeExists "run" FitSkeleton`)
	{
	string $run=`getAttr FitSkeleton.run`;
//	catch (`eval ($run)`);
	tokenize $run ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		if (catchQuiet (`eval ($tempString[$i])`)) warning ("Failed: "+$tempString[$i]+"\n");
		}
	}

//version
addAttr -ln version -at double Main;
setAttr -l 1 Main.version `asGetScriptVersion`;

//Allset
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;
select $allAfter;
select -d $allSame;
select -ne -d "Sets" "Geometry";
select -d `ls -type ikSolver -type ikSystem`;
sets -add AllSet `ls -sl`;
select -cl;
sets -rm AllSet `listRelatives -ad FitSkeleton`;

//name auto generated unitConversion nodes
$tempString=`ls -type unitConversion`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im AllSet $tempString[$i]` && `gmatch $tempString[$i] "unitConversion*"`)
		{
		$tempString2=`listConnections -s 1 -d 0 -p 1 $tempString[$i]`;
		rename $tempString[$i] (`substitute "[.]" $tempString2[0] "_"`+"UC");
		}

//isHistoricallyInteresting
asSetIsHistoricallyInteresting ControlSet;

if ($upAxisDirection=="z")
	asSceneUpAxisFlip Group z;

asUpdateButtonEnables;

//Post Rebuild : postRebuildScript
$postRebuildScript=`getAttr FitSkeleton.postRebuildScript`;
if ($postRebuildScript!="")
	evalEcho ($postRebuildScript);

print "// Build Complete\n";
}
