//     AdvancedSkeleton
//     Version 5.690
//
//
// AdvancedSkeleton is is a collection of Maya tools for doing character setup.
//
// INSTALLATION:
// drag`n`drop the "install.mel" file into Maya (drop in any viewport).
//
// For detailed instructions read the "install.txt" file
//
// Copyright (C)2019 Animation Studios
//
// email: support@animationstudios.com.au
// Last Modified 12/10/2019

global proc AdvancedSkeleton5 ()
{
global int $asBuilding;
global int $asRebuilding;
global int $asFaceIsResetting;
global string $gMainProgressBar;
global int $asFitModeScriptJobNr4,$asFitModeScriptJobNr5;
global int $asSkipConfirm;
string $evalManagerStats[];
string $m;
string $currentUnitLinear=`currentUnit -q -f`;
$m="Units currently set to: \""+$currentUnitLinear+"\"\nAdvancedSkeleton requires \"cm\".\nClick OK to switch";
if ($currentUnitLinear!="centimeter")
	if (`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`=="Ok")
		currentUnit -l cm;
int $animBlendingOpt=`optionVar -q animBlendingOpt`;
if ($animBlendingOpt!=1)
	{
	optionVar -iv animBlendingOpt 1;
	print "// \"Animation Blending Option\" now switched to On.\n";
	}
if (`asMayaVersionAsFloat`>=2012)
	if (`manipMoveContext -q -ex Move`)
		if (!catchQuiet (`manipMoveContext -q -orientJointEnabled Move`))
			if (`manipMoveContext -q -orientJointEnabled Move`)
				manipMoveContext -e -orientJointEnabled 0 Move;
int $haveRanThisVersion=`optionVar -q asHaveRanThisVersion`;
int $asDock=`optionVar -q asDock`;
if (`exists dockControl`)
	if (!`optionVar -ex asDock`)
		$asDock=1;
int $asWorkspace;
$asBuilding=0;
$asRebuilding=0;
$asFitModeSkip=0;
$asSkipConfirm=0;
int $csm=0;//CorrectiveShapeMode
string $boldFont="smallBoldLabelFont";
if (`asMayaVersionAsFloat`<2012)
	$boldFont="plainLabelFont";
string $asScriptLocation=`asGetScriptLocation`;
string $labels[]={"Root","Chest","Mid","Hip","Foot","Heel","Toes","ToesEnd","BigToe","PinkyToe","LegAim","QToes","Shoulder","Hand","0","1","2","3"};
string $attributes[]={"twist/bendy","inbetween","global","aim","wheel","freeOrient","worldOrient","flipOrient","noMirror","noFlip","noControl","noSkin",
	"ikLocal","centerBtwFeet","hipSwinger","geoAttach","aimAt","curveGuide"};
string $geometry,$allFaceGeoString,$eyeR,$eyeL,$upperTeeth,$lowerTeeth,$tongue,$label,$side,$asgBuffStr,$asgBuffStr1,
	$eyeBrowL,$eyeBrowR,$eyeLashL,$eyeLashR,$headJoint,$skinCluster;
if (`attributeExists Geometry FaceFitSkeleton`)
	$geometry=`getAttr FaceFitSkeleton.Geometry`;
if (`attributeExists AllFaceGeo FaceFitSkeleton`)
	$allFaceGeoString=`getAttr FaceFitSkeleton.AllFaceGeo`;
if (`attributeExists Eye_R FaceFitSkeleton`)
	$eyeR=`getAttr FaceFitSkeleton.Eye_R`;
if (`attributeExists Eye_L FaceFitSkeleton`)
	$eyeL=`getAttr FaceFitSkeleton.Eye_L`;
if (`attributeExists UpperTeeth FaceFitSkeleton`)
	$upperTeeth=`getAttr FaceFitSkeleton.UpperTeeth`;
if (`attributeExists LowerTeeth FaceFitSkeleton`)
	$lowerTeeth=`getAttr FaceFitSkeleton.LowerTeeth`;
if (`attributeExists Tongue FaceFitSkeleton`)
	$tongue=`getAttr FaceFitSkeleton.Tongue`;
if (`attributeExists HeadJoint FaceFitSkeleton`)
	$headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
if (`attributeExists "SkinCluster" FaceFitSkeleton`)
	$skinCluster=`getAttr FaceFitSkeleton.SkinCluster`;

string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		$csm=1;
int $dsm=0;//DrivingSystemMode
$rootLevelObjects=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists sdkDriverValue $rootLevelObjects[$i]`)
		$dsm=1;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
if ($asFitModeScriptJobNr4!=0)
	if (!`scriptJob -ex $asFitModeScriptJobNr4`)
		$asFitModeScriptJobNr4=0;
if ($asFitModeScriptJobNr4==0)
	$asFitModeScriptJobNr4=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;
if ($asFitModeScriptJobNr5!=0)
	if (!`scriptJob -ex $asFitModeScriptJobNr5`)
		$asFitModeScriptJobNr5=0;
if ($asFitModeScriptJobNr5==0)
	$asFitModeScriptJobNr5=`scriptJob -e Undo "asUpdateButtonEnables;asFaceUpdateInfo 1;"`;

if (`exists workspaceControl`)
	if (`workspaceControl -q -ex asWorkspaceControl`)
		{
		if (`formLayout -q -ex asFormLayout`)
			deleteUI -control asFormLayout;
		setParent asWorkspaceControl;
		$asWorkspace=1;
		}
if (`exists dockControl`)
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;

if (!$asWorkspace)
	window -t AdvancedSkeleton5 AdvancedSkeletonWindow;

formLayout asFormLayout;
scrollLayout asScrollLayout;
columnLayout -adj 1 asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pre" asPreFrameLayout;

columnLayout -adj 0;
	text -fn $boldFont -l "This \"Preparation\" section is optional,";
	text -fn $boldFont -l "but recommended for clean file and workflow";
	separator -h 10;
	text -l "Clean :";
	text -l "Group your model, so that you have 1 top node.";
	text -l "And name this group \"geo\"";
	text -l "Then use the model-cleaner tool:";
	rowLayout -nc 4 -cw4 60 114 51 15;
		separator;
		button -w 72 -l "Model Clean" -c asModelCleaner;
		separator;
		button -w 11 -l "?" -c "asHelpImage asPreModelCleaner";
		setParent..;
	separator -h 10;
	text -l "Then save your cleaned model.";
	separator -h 5;
	text -l "Also, you can check the symmetry:";
	rowLayout -nc 4 -cw4 60 114 51 15;
		separator;
		button -w 72 -l "Model Check" -c asModelCheckerUI;
		separator;
		button -w 11 -l "?" -c "asHelpImage asPreModelChecker";
		setParent..;
	separator -h 5;
	separator -w 262;
	separator -h 5;
	if (`asIsMayaLT`)
		{
		separator -w 262 -h 10	;
		text -fn $boldFont -l "Next is to reference model-file into rig-file.";
		text -fn $boldFont -l "But MayaLT does not have referencing.";
		text -fn $boldFont -l "So, just rig the model-file instead.";
		}
	else
		{
		text -l "Create rig file:";
		rowLayout -nc 4 -cw4 60 114 51 15;
			separator;
			button -w 72 -l "New Scene" -c NewScene;
			separator;
			button -w 11 -l "?" -c "asHelpImage asPreNewScene";
			setParent..;
		text -l "Reference-in the model:";
		rowLayout -nc 4 -cw4 60 114 51 15;
			separator;
			button -w 72 -l "Reference" -c asReferenceModelBrowser;
			separator;
			button -w 11 -l "?" -c "asHelpImage asPreReference";
			setParent..;
		}

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Body" asBodyFrameLayout;
columnLayout -adj 1;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asBodyFitFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 1;
				text -h 10 -l "FitSkeletons:";
				setParent..;
			rowLayout -nc 4 -cw4 60 114 49 15;
				separator -st none;
				columnLayout;
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asFitFiles;
						button -l "Import" -c asFitSkeletonImport;
						button -w 11 -l "?" -c "asHelpImage asFitSkeletons";
						setParent..;
					text -l " extra limbs:";
					rowLayout -nc 3 -cw3 114 49 15;
						optionMenu asLimbFiles;
						button -l "Import" -c asFitSkeletonLimbsImport;
						button -w 11 -l "?" -c "asHelpImage asFitLimbs";
						setParent..;
					separator -h 5;
					rowLayout -nc 3 -cw3 114 49 15;
						separator -st none;
						button -h 15 -l "Export" -c asFitSkeletonExport;
						button -h 15 -w 11 -l "?" -c "asHelpImage asFitExport";
						setParent..;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Edit" asBodyEditFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 1;
				text -h 10 -l "IK-Label:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				optionMenu -cc asUpdateLabelHelp asLabelType;
				for ($label in $labels)
					menuItem -l $label;
				separator;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asLabelHelp;
				button -w 11 -l "?" -c "asHelpImage asFitLabels";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointLabel;
				button -w 72 -l "Remove" -c asRemoveFitJointLabel;
				setParent..;
			separator -h 10;
			rowLayout -nc 1;
				text -h 10 -l "Attribute:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
				optionMenu -cc asUpdateAttributeHelp asAttributeType;
				for ($attribute in $attributes)
					menuItem -l $attribute;
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator;
				text -fn $boldFont -en 0 asAttributeHelp;
				button -w 11 -l "?" -c "asHelpImage asFitAttributes";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 79 15;
				separator;
				button -w 72 -l "Add" -c asAddFitJointAttribute;
				button -w 72 -l "Remove" -c asRemoveFitJointAttribute;
				setParent..;
			separator;
			rowLayout -nc 1;
				text -l "Display:";
				setParent..;
			floatSliderGrp -cw3 85 35 20 -l "joint" -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			rowLayout -h 18 -nc 4 -cw4 62 78 85 15;
				separator;
				checkBox -l "geometry" -cc asFitGeometry asVisGeo;
				optionMenu -en 0 -cc asChangeVisGeoType asVisGeoType;
					menuItem -l "cylinders" -data 0;
					menuItem -l "boxes" -data 1;
					menuItem -l "spheres" -data 2;
					menuItem -l "bones" -data 3;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayGeometry";
				setParent..;
			floatSliderGrp -h 18 -cw3 85 35 20 -l "gap" -field 1 -min 0.01 -max 1 -pre 2 -v 0.75 asVisGap;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "pole-vector" -onc "asFitDisplayPoleVector 1" -ofc "asFitDisplayPoleVector 0" asVisPoleVector;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayPoleVector";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "joint-orient" -onc "asFitDisplayJointOrient 1" -ofc "asFitDisplayJointOrient 0" asVisJointOrient;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayJointOrient";
				setParent..;
			rowLayout -h 18 -nc 3 -cw3 62 165 15;
				separator;
				checkBox -l "joint-axis" -onc "asFitDisplayJointAxis 1" -ofc "asFitDisplayJointAxis 0" asVisJointAxis;
				button -w 11 -l "?" -c "asHelpImage asFitDisplayJointAxis";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Placement:";
				setParent..;
			rowLayout -nc 5 -cw5 62 29 40 92 15;
				separator -st none;
				if (`asHaveMeshCenterSnap`)
					{
					text -l "Snap:";
					iconTextCheckBox -w 26 -h 26 -i "snapMeshCenter.png" -cc "snapMode -meshCenter #1" asMeshCenterSnapButton;
					}
				else
					{
					separator -st none;
					separator -st none;
					}
				checkBox -l "Lock middle" -cc asFitModeLockCenterJoints asLockCenterJoints;
				button -w 11 -l "?" -c "asHelpImage asFitPlacement";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Add Joints:";
				setParent..;
			rowLayout -nc 4 -cw4 62 82 81 15;
				separator;
 				$gBuffStr = `toolButton -style iconOnly -doubleClickCommand "toolPropertyWindow" -cl toolCluster `;
    		$gBuffStr1 = `jointCtx -image1 "kinJoint.png" -image2 "vacantCell.png" -image3 "vacantCell.png" -scaleCompensateJ 1
        -degreeOfFreedomJ "xyz" -jointOrientationJ 0 0 0 -scaleOrientationJ 0 0 0 -scaleJ 1 1 1 -autoJointOrient "xyz" 
        -secondaryAxisOrient "yup" -jointAutoLimits 0-createIKHandle 0-solverTypeH "ikSCsolver" -autoPriorityH 0
        -snapHandleH 1 -forceSolverH 1 -stickyH "off" -priorityH 1 -weightH 1 -poWeightH 1`;
				if (`asMayaVersionAsFloat`>=2012)
			    toolButton -edit -tool $gBuffStr1 -toolImage1 $gBuffStr1 "kinJoint.png" $gBuffStr;
		    toolButton -edit -tool $gBuffStr1 $gBuffStr;
		    button -w 72 -l "ReSample" -c asFitResample;
				button -w 11 -l "?" -c "asHelpImage asFitCreate";
				setParent..;
			separator;
			rowLayout -nc 1;
				text -h 10 -l "Auto-Orient:";
				setParent..;
			rowLayout -nc 3 -cw3 62 165 15;
				separator -st none;
				button -w 156 -l FitMode -c asFitMode;
				button -w 11 -l "?" -c "asHelpImage asFitMode";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 82 62 81 15;
				separator -st none;
				text -l "Or, manual:";
				button -w 72 -l "Update Now" -c asFitModeManualUpdate;
				button -w 11 -l "?" -c "asHelpImage asFitUpdateNow";
				setParent..;
			separator;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asBodyBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4;
				separator -w 28 -st none;
				button -m 0 -w 60 -l "Delete Adv" -c asDeleteAdvanced asDelteAdvButton;
				separator -w 15 -st none;
				checkBox -l "Keep All" -v 1
					-onc "columnLayout -e -m 0 asBodyKeepColumnLayout"
					-ofc "columnLayout -e -m 1 asBodyKeepColumnLayout"
					asKeepAllCheckBox;
				setParent..;

			columnLayout -m 0 asBodyKeepColumnLayout;
				rowLayout -nc 2 -cw2 5 100;
					separator -st none;
					columnLayout;
						checkBox -v 1 -l "keep custom control shape and color" asKeepCurveShapesCheckBox;
						checkBox -v 1 -l "keep custom stored buildPose" asKeepBuildPoseCheckBox;
						checkBox -v 1 -l "keep custom parenting" asKeepParentingCheckBox;
						checkBox -v 1 -l "keep custom parentConstraints" asKeepParentConstraintsCheckBox;
						checkBox -v 1 -l "keep custom lock/hide of attributes" asKeepLockHideCheckBox;
						checkBox -v 1 -l "keep custom added attributes" asKeepUserAttrsCheckBox;
						checkBox -v 1 -l "keep custem set transformLimits" asKeepLimitsCheckBox;
						checkBox -v 1 -l "keep deformations (connections)" asKeepSkinningCheckBox;
						setParent..;
					setParent..;
				setParent..;

			rowLayout -nc 4 -cw4 5 85 5 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitAdvancedSkeleton asToggleFitSkeletonButton;
				separator -w 5 -st none;
				button -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton asBuildAdvancedSkeletonButton;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option1)" asBodyDeform1FrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 3 -cw3 100 126 15;
				separator;
				text -l "Skinning:";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinning";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator -st "none";
				columnLayout;
					text -l "Select objects to deform, then:";  
					separator -h 5 -st none;
					button -w 140 -l "+ Select DeformJoints" -c asSelectDeformJoints;
					separator -h 5 -st none;
					button -w 140 -l "Set Smooth Bind Options" -c asSetSmoothBindOptions;
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option2)" asBodyDeform2FrameLayout;
		columnLayout -adj 1;
			text -l "SkinCage:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinCage;
				button -w 60 -l "Delete" -c asDeleteSkinCage;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCage";
				setParent..;
			separator -st "none";
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 SkinCageCurvesSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 SkinCageCurvesSet";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageMirror";
				setParent..;
			separator -h 5 -st "none";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select objects to deform, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Copy weights" -c asCopySkin;
					button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCopyWeights";
					setParent..;
				setParent..;
			separator -h 10 -st none;
				rowLayout -nc 4 -cw4 60 165 64 15;
				text -l "Adjust:";
				button -w 162 -l "\"DeformationWidth\"" -c asSkinCurvesToWidth;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDWidth";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Add wrist details" -c asAddWristDetails;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageAddWristDetails";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Create Groin Locators" -c asCreateGroinLocators;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageCreateGroinLocators";
				setParent..;
			rowLayout -nc 3 -cw3 60 165 15;
				separator;
				button -w 162 -l " Adjust Groin area" -c asAdjustGroinArea;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageAdjustGroinArea";
				setParent..;
			separator -h 10 -st none;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Sliders:";
				button -w 60 -l "Create" -c asCreateSliders;
				button -w 60 -l "Delete" -c asDeleteSliders;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageSliders";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Delete SkinCurves" -c asDeleteSkinCurves;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinCageDeleteCurves";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option3)" asBodyDeform3FrameLayout;
		columnLayout -adj 1;
			text -l "SubWrap:";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Cage:";
				button -w 60 -l "Create" -c asCreateSkinSub;
				button -w 60 -l "Delete" -c asDeleteSkinSub;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapCage";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				text -l "Select objects to deform, then:";  
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Wrap selected mesh" -c asWrapSkin;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapWrap";
				setParent..;
			separator;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Detach" -c asSkinSubDetach;
				button -w 60 -l "Attach" -c asSkinSubAttach;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapAttach";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st "none";
				button -w 162 -l "Exclude selected vertices" -c asWrapExlude;
				button -w 11 -l "?" -c "asHelpImage asDeformSubWrapExlude";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (option4)" asBodyDeform4FrameLayout;
		columnLayout -adj 1;
			text -l "SkinLoops:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select EdgeLoop + FK control, then";
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				separator;
				checkBox -v 1 -l "mirror" asCreateSkinLoopCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Create New SkinLoop" -c "asCreateSkinLoop 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCreate";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Select All SkinLoops" -c asSelectAllSkinLoops;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsSelectAll";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to deform, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Bind" -c "asBindSkinLoops 0";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsBind";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "For cloth over skin, copy weighs.\nSelect cloth, then:"; 
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Copy" -c "asCopySkinLoopWeights";
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCopy";
				setParent..;
			separator -w 242 -h 15;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Select objects to CutUp, then:"; 
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "CutUp:";
				button -w 60 -l "Create" -c "asBindSkinLoops 1";
				button -w 60 -l "Delete" -c asDeleteCutUp;
				button -w 11 -l "?" -c "asHelpImage asDeformSkinLoopsCutUp";
				setParent..;
			separator -w 242 -h 5;
			setParent..;
		setParent..;
		frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Deform      (DeltaMush)" asBodyDeformDeltaMushFrameLayout;
			columnLayout -adj 1;
				text -l "Delta-Mush:";
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select skinned objects, then:";
				setParent..;
			columnLayout;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Harden weights" -c asHardenWeights;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushHarden";
					setParent..;
				rowLayout -nc 3 -cw3 60 165 15;
					separator;
					button -w 162 -l "Apply Delta Mush" -c asApplyDeltaMush;
					button -w 11 -l "?" -c "asHelpImage asDeformDeltaMushApply";
					setParent..;
			if (`asMayaVersionAsFloat`>=2016)
				{
				rowLayout -nc 3 -cw3 80 165 15;
					separator;
					checkBox -l "use wbDeltaMush" wbDeltaMush;
					setParent..;
				}
				rowLayout -nc 3 -cw3 80 165 15;
					separator;
					text -l "Plugin by: Webber Huang\n<xracz.fx@gmail.com>";
					setParent..;
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Skeleton)" asBodyGeometrySkeletonFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateSkeleton;
				button -w 60 -l "Delete" -c asDeleteSkeleton;
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Skeleton 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Skeleton 0";
				button -w 11 -l "?" -c "asHelpImage asGeometrySkeletonMirror";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Muscular)" asBodyGeometryMuscularFrameLayout;
		columnLayout -adj 1;
			text -l "Make sure to create Skeleton first.";
			separator -st none -h 5;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Muscular:";
				button -w 60 -l "Create" -c asCreateMuscular;
				button -w 60 -l "Delete" -c asDeleteMuscular;
				button -w 11 -l "?" -c "asHelpImage asGeometryMuscularCreate";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (PolyBoxes)" asBodyGeometryPolyBoxesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePolyBoxes;
				button -w 60 -l "Delete" -c asDeletePolyBoxes;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorGeometry Boxes 1";
				button -w 60 -l "Right>Left" -c "asMirrorGeometry Boxes 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Boolean:";
				button -w 60 -l "Create" -c asCreateBoolean;
				button -w 60 -l "Delete" -c asDeleteBoolean;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesBoolean";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Warp:";
				button -w 60 -l "Create" -c asCreateWarp;
				button -w 60 -l "Delete" -c asDeleteWarp;
				button -w 11 -l "?" -c "asHelpImage asGeometryPolyBoxesWarp";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Mannequin)" asBodyGeometryMannequinFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateMannequin;
				button -w 60 -l "Delete" -c asDeleteMannequin;
				button -w 11 -l "?" -c "asHelpImage asGeometryMannequinCreate";
				setParent..;
			setParent..;
		setParent..;
	frameLayout -m 1 -cll 1 -cl 1 -cc asFL -ec asFL -l " Geometry (Retopology)" asBodyGeometryRetopologyFrameLayout;
		columnLayout -adj 1;
			text -l "Make sure to create SkinCage or SkinSub first.";
			separator -st none -h 5;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Select Hi-res model, then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Retopo:";
				button -w 60 -l "Create" -c asCreateRetopo;
				button -w 60 -l "Delete" -c asDeleteRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoCreate";
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Make any tweaks needed, then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Update selected" -c asUpdateRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoUpdate";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorRetopo 1";
				button -w 60 -l "Right>Left" -c "asMirrorRetopo 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoMirror";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Normal Map" -c asNormalMapRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoNormalMap";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Bind:";
				button -w 60 -l "Bind" -c asBindRetopo;
				button -w 60 -l "UnBind" -c asUnBindRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryRetopoBind";
				setParent..;

			separator -h 15;
			rowLayout -nc 2 -cw2 130 100;
				separator -st none;
				text -h 20 -l "Face:";
				setParent..;
			rowLayout -nc 2 -cw2 90 100;
				separator -st none;
				optionMenu asCreateFaceRetopoOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
//				text -l "Guides:";
				separator -st none;
				button -w 60 -l "Create" -c asCreateFaceRetopo;
				button -w 60 -l "Delete" -c "asDeleteFaceRetopo 0";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoCreate";
				setParent..;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Make any tweaks needed, then:";
				setParent..;
			separator -h 5 -st none;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Match guides" -c asMatchGuidesFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoMatch";
				setParent..;
			rowLayout -nc 2 -cw2 70 100;
				separator;
				text -l "Tweak further if needed.";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Connect Body" -c asConnectBodyFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoConnect";
				setParent..;
			separator -h 10 -st none;
			rowLayout -nc 2 -cw2 90 100;
				text -l "Eyes:";
				optionMenu asCreateFaceRetopoEyeBallOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Create" -c asCreateEyesFaceRetopo;
				button -w 60 -l "Delete" -c "delete headTopologyEyes";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoEyesCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "bind eyes" -c asBindEyesFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoEyesBind";
				setParent..;

			separator -h 10 -st none;
			rowLayout -nc 2 -cw2 90 100;
				text -l "Teeth:";
				optionMenu asCreateFaceRetopoTeethOptionMenu;
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st none;
				button -w 60 -l "Create" -c asCreateTeethFaceRetopo;
				button -w 60 -l "Delete" -c "delete headTopologyTeeth";
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoTeethCreate";
				setParent..;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "bind teeth" -c asBindTeethFaceRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoTeethBind";
				setParent..;

			separator -h 10 -st none;
			rowLayout -nc 4 -cw4 60 30 134 15;
				separator;
				separator;
				button -w 100 -l "Face rig prep" -c asFaceRigPrepRetopo;
				button -w 11 -l "?" -c "asHelpImage asGeometryFaceRetopoPrep";
				setParent..;
			separator -h 5 -st none;
			text -l "You can now now Build Face Setup";
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " CustomControllers" asBodyCustomControlsFrameLayout;
	// Runs the CustomControllers Twice, once for Body, and once for Face
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Game Skeleton" asBodyGameSkeletonFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				text -l "Unreal Root & IK joints:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateUnrealJoints;
				button -w 60 -l "Delete" -c asDeleteUnrealJoints;
				button -w 11 -l "?" -c "asHelpImage asUnrealCreateJoints";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				text -l "OR:\nUnreal Mannequin Skeleton:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateUnrealMannequinJoints;
				button -w 60 -l "Delete" -c asDeleteUnrealMannequinJoints;
				button -w 11 -l "?" -c "asHelpImage asUnrealCreateMannequinJoints";
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator;
				button -w 162 -l "Transfer Skinning" -c asUnrealMannequinTransferSkin;
				button -w 11 -l "?" -c "asHelpImage asUnrealMannequinTransferSkin";
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Curves" asBodyControlCurvesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Mirror:";
				button -w 60 -l "Left>Right" -c "asMirrorControlCurves 1 ControlSet";
				button -w 60 -l "Right>Left" -c "asMirrorControlCurves 0 ControlSet";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesMirror";
				setParent..;
			separator -h 10;
			rowLayout -nc 4 -cw4 60 100 64 15;
				text -l "Scale:";
				floatField -v 1 -ann "set scale-factor" ScaleCCFloatField;
				button -w 60 -l "Scale" -c "asScaleControlCurves";
				button -w 11 -l "?" -c "asHelpImage asControlCurvesScale";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Swap:";
				text -l "First select Control(s) to replace,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then select (add) any custom curve,";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Then:";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Swap Curve" -c asSwapCurve;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesSwap";
				setParent..;
			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Color:";
				int $cellHeight = 17, $cellWidth = 10;
				int $rows = 2, $columns = 16;
				palettePort -w ($columns * $cellWidth) -h ($rows * $cellHeight) -dim $columns $rows -ced 0 -td 1 asCurveColorPalettePort;
				float $colorComponentArray[];
				palettePort -edit -rgbValue 0 0 0 0 asCurveColorPalettePort;
				for ($index = 1; $index <= 31; $index++) {
					$colorComponentArray = `colorIndex -query $index`;
					palettePort -edit -rgbValue $index
						$colorComponentArray[0]
						$colorComponentArray[1]
						$colorComponentArray[2]
						asCurveColorPalettePort;
						}
				if (`asMayaVersionAsFloat`>=2014)
					palettePort -e -ced 1 asCurveColorPalettePort;
				setParent..;
			rowLayout -nc 3 -cw3 60 90 50;
				separator;
				optionMenu asCurveColorTypeOptionMenu;
					menuItem -l "FK";
					menuItem -l "IK";
					menuItem -l "FKIK";
					menuItem -l "Bend";
					menuItem -l "Selected";
					menuItem -l "*All";
					menuItem -l "Face:A";
					menuItem -l "Face:B";
					menuItem -l "Face:C";
					menuItem -l "Face:Aim";
					menuItem -l "Face:Teeth";
					menuItem -l "Face:Tongue";
					menuItem -l "Face:Region";
					menuItem -l "Face:Squash";
					menuItem -l "Face:Custom";
				optionMenu asCurveColorSideOptionMenu;
					menuItem -l "Right";
					menuItem -l "Left";
					menuItem -l "Middle";
					menuItem -l "*All";
				setParent..;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator -st "none";
				button -w 162 -l "Set Color" -c asSetCurveColor;
				button -w 11 -l "?" -c "asHelpImage asControlCurvesColor";
				setParent..;

			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				text -l "Re-use:";
				text -l "This will print in ScriptEditor:";
				setParent..;
			rowLayout -nc 2 -cw2 60 100;
				separator;
				columnLayout;
					text -l "commands to set control curves to";
					text -l "current shapes and colors.";
					button -w 162 -l "Script Editor" -c "ScriptEditor;";
					button -w 162 -l "Clear History" -c "scriptEditorInfo -clearHistory";
					rowLayout -nc 3;
						checkBox -l "shape" -v 1 asControlCurvesReUseShapeCheckBox;
						checkBox -l "color" -v 1 asControlCurvesReUseColorCheckBox;
						checkBox -l "`catch`" asControlCurvesReUseCatchCheckBox;
						setParent..;
					checkBox -l "SkinCurves" asControlCurvesReUseSkinCurvesCheckBox;
					checkBox -l "Face" asControlCurvesReUseFaceCheckBox;
					button -w 162 -l "Print Commands" -c asControlCurvesPrintInfo;
					setParent..;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Control Mesh" asBodyControlMeshFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 2 -cw2 60 100;
				columnLayout -adj 0;
					text -l "Create:";
					setParent..;	
				columnLayout -adj 0;
					text -l "First select the poly-faces to use";
					text -l "Then select (add) the control,";
					text -l "Then:";
					checkBox -v 1 -l "mirror" asCreateControlMeshMirrorCheckBox;
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create ControlMesh" -c asCreateControlMesh;
						button -w 11 -l "?" -c "asHelpImage asControlMeshCreate";
						setParent..;
					separator -h 5;
					text -l "Or, select mesh and auto-create";
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create ControlMeshes" -c asCreateControlMeshes;
						button -w 11 -l "?" -c "asHelpImage asControlMeshesCreate";
						setParent..;
					separator -h 5;
					text -l "IK controls & driving-systems";
					rowLayout -nc 3 -cw3 100 64 15;
						button -w 162 -l "Create IK ControlMeshes" -c asCreateIKControlMeshes;
						button -w 11 -l "?" -c "asHelpImage asControlMeshesCreateIK";
						setParent..;
					setParent..;	
				setParent..;	

			separator -h 10;
			rowLayout -nc 2 -cw2 60 100;
				columnLayout -adj 0;
					text -l "Delete:";
					setParent..;	
				columnLayout -adj 0;
					button -w 162 -l "Delete Selected" -c asDeleteControlMesh;
					separator -h 5;
					button -w 162 -l "Delete All" -c asDeleteAllControlMesh;
					setParent..;
				setParent..;
			setParent..;
		setParent..;	

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Partial Joints" asBodyPartialJointsFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreatePartialJoints;
				button -w 60 -l "Delete" -c asDeletePartialJoints;
				button -w 11 -l "?" -c "asHelpImage asPartialJoints";
				setParent..;	
			setParent..;	
		setParent..;	

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Joint Groups" asBodyJointGroupFrameLayout;
		columnLayout -adj 0;
			rowLayout -nc 4 -cw4 60 100 64 15;
				separator;
				button -w 60 -l "Create" -c asCreateJointGroups;
				separator;
				button -w 11 -l "?" -c "asHelpImage asJointGroups";
				setParent..;	
			setParent..;	
		setParent..;	

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Face" asFaceFrameLayout;
columnLayout -adj 1 asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Pre" asFacePrepFrameLayout;
		columnLayout -adj 0;
			button -l "Create Face FitSkeleton Node" -c asCreateFaceFitSkeleton;
			rowLayout -nc 2 -cw2 130 15;
				text -l "Then move and scale this:";
				button -w 15 -l "?" -c "asHelpImage fitFaceSkeletonNode";
				setParent..;
			text -l "lower circle just under the character`s jaw";
			text -l "upper circle just above the character`s head";
			separator -h 10;
			text -l "Choose Geometry";
			text -l " * = Optional";
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Face" -c "asChooseInput asFaceGeometryTextField";
				textField -w 100 -ed 0 -tx $geometry asFaceGeometryTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "All Head" -c "asChooseInput asFaceAllFaceGeoTextField";
				textField -w 100 -ed 0 -tx $allFaceGeoString asFaceAllFaceGeoTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Right Eye" -c "asChooseInput asFaceEye_RTextField";
				textField -w 100 -ed 0 -tx $eyeR asFaceEye_RTextField;
				setParent..;
			rowLayout -nc 2 -cw2 120 100;
				button -w 120 -l "Left Eye" -c "asChooseInput asFaceEye_LTextField";
				textField -w 100 -ed 0 -tx $eyeL asFaceEye_LTextField;
				setParent..;
			separator -h 7 -st none;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Upper Teeth" -c "asChooseInput asFaceUpperTeethTextField";
				textField -w 100 -ed 0 -tx $upperTeeth asFaceUpperTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Lower Teeth" -c "asChooseInput asFaceLowerTeethTextField";
				textField -w 100 -ed 0 -tx $lowerTeeth asFaceLowerTeethTextField;
				text -l "*";
				setParent..;
			rowLayout -nc 3 -cw3 120 100 10;
				button -w 120 -l "Tongue" -c "asChooseInput asFaceTongueTextField";
				textField -w 100 -ed 0 -tx $tongue asFaceTongueTextField;
				text -l "*";
				setParent..;
			separator -h 10;
			checkBox -m 1 -l advanced -onc "columnLayout -e -m 1 asFaceAdvancedinputColumnLayout" -ofc "columnLayout -e -m 0 asFaceAdvancedinputColumnLayout";
			columnLayout -m 0 asFaceAdvancedinputColumnLayout;
				separator -h 15;
				text -l "For creating FaceSetup,";
				text -l "without AdvancedSkeleton body rig:";
				separator -h 5;
				rowLayout -nc 2 -cw 1 120;
					button -w 120 -l "Choose Head Joint" -c "asChooseInput asFaceHeadJointTextField";
				textField -w 100 -ed 0 -tx $headJoint asFaceHeadJointTextField;
					setParent..;
				text -l "SkinCluster found on Face Geo:";
				textField -w 150 -m 1 -tx $skinCluster asFaceSkinClusterTextField;
				separator -h 15;
				checkBox -l "Non symmetrical face" -onc "asFaceSwitchSide 1;" -ofc "asFaceSwitchSide 2;" asFaceNonSymCheckBox;
				textField -m 0 asFaceNonSymTextField;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Fit" asFaceFitFrameLayout;
		columnLayout -adj 0 asFaceFitColumnLayout;
		optionMenu -m 0 asFaceReqFitElementsOptionMenu;

		columnLayout -m 0 asFaceNonSymColumnLayout;
			rowLayout -nc 2;
				button -w 120 -l "Right" -c "asFaceSwitchSide 1";
				button -w 120 -l "Left" -c "asFaceSwitchSide 0";
				setParent..;
			rowLayout -nc 2;
				separator -w 70 -st none;
				button -h 18 -l " show both sides " -c asFaceShowBothSides;
				setParent..;
			separator -h 15 -st none;
			setParent..;

		$checkValue=`objExists FaceFitEyeBall`;
		string $sections[]={"EyeBall"};
		for ($c=0;$c<size($sections);$c++)
			{
			rowLayout -nc 7;
				button -w 100 -l $sections[$c] -c ("asBuildFit"+$sections[$c]);
				separator -w 5 -st none;
				checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]) ("asFaceFit"+$sections[$c]);
				button -w 15 -l "?" -c ("asHelpImage fitFace"+$sections[$c]);
				separator -w 10 -st none;
				separator -w 35 -st none;
				button -l "hide" -c ("setAttr FaceFit"+$sections[$c]+".v (!`getAttr FaceFit"+$sections[$c]+".v`)");
				setParent..;
			}
		separator -st none -h 10;
		text -l "Select edgeLoops, then:";

		string $parts[]={"Outer","Main","Inner"};
		int $upAndLo[],$mainAndOuter[],$isSphere[],$req[];
		string $shadingGroup[];

		$c=-1;
		$c++;$sections[$c]="EyeLid";$upAndLo[$c]=1;$mainAndOuter[$c]=1;$isSphere[$c]=0;$shadingGroup[$c]="";$req[$c]=1;
		$c++;$sections[$c]="EyeLidDroopy";$upAndLo[$c]=1;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="";$req[$c]=0;
		$c++;$sections[$c]="Lip";$upAndLo[$c]=1;$mainAndOuter[$c]=1;$isSphere[$c]=0;$shadingGroup[$c]="";$req[$c]=1;
		$c++;$sections[$c]="EyeBrowInner";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asGreenSG";$req[$c]=1;
		$c++;$sections[$c]="EyeBrowOuter";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$req[$c]=1;
		$c++;$sections[$c]="EyeBrowMiddle";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$req[$c]=1;
		$c++;$sections[$c]="EyeBrowMid1";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$req[$c]=0;
		$c++;$sections[$c]="EyeBrowMid2";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$req[$c]=0;
		$c++;$sections[$c]="EyeBrowMid3";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$req[$c]=0;
		$c++;$sections[$c]="ForeHead";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="";$req[$c]=1;
		$c++;$sections[$c]="JawPivot";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$req[$c]=1;
		$c++;$sections[$c]="JawCorner";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$req[$c]=1;
		$c++;$sections[$c]="Jaw";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$req[$c]=1;
		$c++;$sections[$c]="Throat";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$req[$c]=1;
		$c++;$sections[$c]="Cheek";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asGreenSG";$req[$c]=1;
		$c++;$sections[$c]="CheekBone";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlue2SG";$req[$c]=1;
		$c++;$sections[$c]="CheekRaiser";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$req[$c]=1;
		$c++;$sections[$c]="SmileBulge";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$req[$c]=1;
		$c++;$sections[$c]="FrownBulge";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$req[$c]=1;
		$c++;$sections[$c]="Nose";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asGreenSG";$req[$c]=1;
		$c++;$sections[$c]="NoseUnder";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$req[$c]=1;
		$c++;$sections[$c]="NoseCorner";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asRedSG";$req[$c]=1;
		$c++;$sections[$c]="NoseSide";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$req[$c]=0;
		$c++;$sections[$c]="NoseMiddle";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$req[$c]=0;
		$c++;$sections[$c]="Nostril";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=1;$shadingGroup[$c]="asBlueSG";$req[$c]=0;
		$c++;$sections[$c]="Tongue";$upAndLo[$c]=0;$mainAndOuter[$c]=0;$isSphere[$c]=0;$shadingGroup[$c]="asBlueSG";$req[$c]=0;

		int $hideable;
		for ($c=0;$c<size($sections);$c++)
			{
			$hideable=0;
			if ($sections[$c]=="EyeLidDroopy")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra EyeLid controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraEyeLidFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="Lip" || $sections[$c]=="ForeHead" || $sections[$c]=="JawPivot" || $sections[$c]=="Tongue" || $sections[$c]=="EyeBrowInner")
				{
				setParent asFaceFitColumnLayout;
				separator -st none -h 10;
				}
			if ($sections[$c]=="EyeBrowInner")
				text -l "Select 1 vertex, then:";
			if ($sections[$c]=="EyeBrowMid1")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra EyeBrow controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraEyeBrowFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="ForeHead")
				{
				text -l "Select 3 vertices, then:";
				$hideable=1;
				}

			if ($sections[$c]=="NoseSide")
				{
				setParent asFaceFitColumnLayout;
					separator -st none -h 10;
					text -l "(No selection needed)";
					columnLayout;
						$checkValue=`objExists FaceFitJawCurves`;
						rowLayout -nc 4 -cw4 100 5 20 15;
							button -w 100 -l "JawCurves" -c asFaceFitJawCurves;
							separator -w 5 -st none;
							checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc "asFaceDeleteFromCheckBox JawCurves" asFaceFitJawCurves;
							button -w 15 -l "?" -c "asHelpImage fitFaceJawCurves";
							setParent..;
						rowLayout -nc 2 -cw2 129 15;
							text -l "Tweak curves";
							button -w 15 -l "?" -c "asHelpImage fitFaceJawCurvesTweak";
							setParent..;
						setParent..;
					menuItem -l JawCurves -p asFaceReqFitElementsOptionMenu;
					}

			if ($sections[$c]=="NoseSide")
				{
				frameLayout -mw 25 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional extra Nose controls:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitExtraNoseFrameLayout;
					columnLayout;
				}
			if ($sections[$c]=="TeethCollider")
				$hideable=1;
			if ($sections[$c]=="Tongue")
				{
				frameLayout -mw 16 -w 210 -cll 1 -cl 1 -cc asFL -ec asFL -l "*Optional tongue:" -font "tinyBoldLabelFont" -labelIndent 10 asFaceFitTongueTeethFrameLayout;
					columnLayout;
					text -l "(No selection needed)";
				}
			for ($a=0;$a<size($parts);$a++)
				{
				if ($mainAndOuter[$c]==0) $parts[$a]="";
				else $parts={"Outer","Main","Inner"};
				if ($sections[$c]=="EyeBrow" && $parts[$a]=="Inner")
					continue;
				if ($mainAndOuter[$c]==0 && $a>0)
					continue;
				if ($req[$c])
					menuItem -l ($sections[$c]+$parts[$a]) -p asFaceReqFitElementsOptionMenu;
				$checkValue=`objExists ("FaceFit"+$sections[$c]+$parts[$a])`;
				rowLayout -nc 7;
					button -w 100 -l ($sections[$c]+$parts[$a]) -c ("asCreateFaceFit "+$sections[$c]+" \""+$parts[$a]+"\" "+$upAndLo[$c]+" "+$mainAndOuter[$c]+" "+$isSphere[$c]+" \""+$shadingGroup[$c]+"\"");
					popupMenu;
						menuItem -l "re-select" -c ("asFaceReSelect "+$sections[$c]+" \""+$parts[$a]+"\"");//since $parts can be blank
					separator -w 5 -st none;
					checkBox -l "" -w 20 -ed $checkValue -v $checkValue -ofc ("asFaceDeleteFromCheckBox "+$sections[$c]+$parts[$a]) ("asFaceFit"+$sections[$c]+$parts[$a]);
					button -w 15 -l "?" -c ("asHelpImage fitFace"+$sections[$c]+$parts[$a]);
					if ($sections[$c]!="TeethCollider")
						separator -w 10 -st none;
					if ($parts[$a]=="Inner")
						button -w  35 -l "assist" -c ("asFaceAssist "+$sections[$c]);
					else if ($sections[$c]!="TeethCollider")
						separator -w 35 -st "none";
					if ($hideable || (($sections[$c]=="EyeLid" || $sections[$c]=="Lip") && $parts[$a]=="Inner"))
						button -l "hide" -c ("setAttr FaceFit"+$sections[$c]+$parts[$a]+".v (!`getAttr FaceFit"+$sections[$c]+$parts[$a]+".v`)");
					setParent..;
				}
			}

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build" asFaceBuildFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4;
				separator -w 28 -st none;
				button -m 0 -w 60 -l "Delete Adv" -c asDeleteAdvancedFace asDelteAdvFaceButton;
				separator -w 15 -st none;
				checkBox -m 0 -l "Keep All" -v 1
					-onc "columnLayout -e -m 0 asFaceKeepColumnLayout"
					-ofc "columnLayout -e -m 1 asFaceKeepColumnLayout"
					asFaceKeepAllCheckBox;
				setParent..;

			columnLayout -m 0 asFaceKeepColumnLayout;
				rowLayout -nc 2 -cw2 5 100;
					separator -st none;
					columnLayout;
						checkBox -v 1 -l "keep Skin weights" asFaceKeepSkinWeightsCheckBox;
						checkBox -v 1 -l "keep Pupil setup" asFaceKeepPupilCheckBox;
						checkBox -v 1 -l "keep EyeBrow setup" asFaceKeepEyeBrowCheckBox;
						checkBox -v 1 -l "keep EyeLash setup" asFaceKeepEyeLashCheckBox;
//						checkBox -v 1 -l "keep DeltaMush setup" asFaceKeepDeltaMushCheckBox;
						checkBox -v 1 -l "keep HeadSquash setup" asFaceKeepHeadSquashCheckBox;
						checkBox -v 1 -l "keep BlendShapes setup" asFaceKeepBlendShapesCheckBox;
						checkBox -v 1 -l "keep DrivingSystems setup" asFaceKeepDrivingSystemsCheckBox;
						checkBox -v 1 -l "keep custom control shape and color" asFaceKeepCurveShapesCheckBox;
						setParent..;
					setParent..;
				setParent..;


			rowLayout -nc 4 -cw4 5 85 20 100;
				separator -w 5 -st none;
				button -l "Toggle Fit/Adv" -c asToggleFitFace asToggleFitFaceButton;
				separator -w 20 -st none;
				button -l "Build AdvancedFace" -c asBuildAdvancedFace asBuildAdvancedFaceButton;
				setParent..;
			setParent..;
		setParent..;

	string $stepBuildText[];
	$stepBuildText[size($stepBuildText)]="";
	$stepBuildText[size($stepBuildText)]="Prep";
	$stepBuildText[size($stepBuildText)]="CtrlBox";
//	$stepBuildText[size($stepBuildText)]="FaceTargets";
	$stepBuildText[size($stepBuildText)]="EyeBall";
	$stepBuildText[size($stepBuildText)]="EyeLid";
	$stepBuildText[size($stepBuildText)]="Squint";
	$stepBuildText[size($stepBuildText)]="EyeBrow";
	$stepBuildText[size($stepBuildText)]="Lip";
//	$stepBuildText[size($stepBuildText)]="LipFalloffDistanceCenter";
//	$stepBuildText[size($stepBuildText)]="LipFalloffDistanceSide";
	$stepBuildText[size($stepBuildText)]="LipFalloff";
	$stepBuildText[size($stepBuildText)]="Jaw";
	$stepBuildText[size($stepBuildText)]="JawFinish";
	$stepBuildText[size($stepBuildText)]="ZipperLips";
	$stepBuildText[size($stepBuildText)]="Nose";
//	$stepBuildText[size($stepBuildText)]="MouthSculpt";
//	$stepBuildText[size($stepBuildText)]="MouthSculptFinish";
	$stepBuildText[size($stepBuildText)]="SmilePull";
	$stepBuildText[size($stepBuildText)]="SmileBulge";
	$stepBuildText[size($stepBuildText)]="CheekRaiser";
//	$stepBuildText[size($stepBuildText)]="FrownPull";
//	$stepBuildText[size($stepBuildText)]="FrownBulge";
	$stepBuildText[size($stepBuildText)]="Frown";
//	$stepBuildText[size($stepBuildText)]="MouthWide";
	$stepBuildText[size($stepBuildText)]="MouthNarrow";
	$stepBuildText[size($stepBuildText)]="SmileFinish";
	$stepBuildText[size($stepBuildText)]="Cheek";
	$stepBuildText[size($stepBuildText)]="JawOpen";
	$stepBuildText[size($stepBuildText)]="Tongue";
	$stepBuildText[size($stepBuildText)]="Regions";
	$stepBuildText[size($stepBuildText)]="EyeAim";
	$stepBuildText[size($stepBuildText)]="UpMidLo";
	$stepBuildText[size($stepBuildText)]="Phonemes";
//	$stepBuildText[size($stepBuildText)]="OnFacePlacement";
	$stepBuildText[size($stepBuildText)]="Finish";
	$stepBuildText[size($stepBuildText)]="RebuildRestore";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Build ..." asFaceStepBuildFrameLayout;
		columnLayout -adj 0 asStepBuildColumnLayout;
			separator -h 5;
			columnLayout ("asStepBuildColumnLayout0");
				text -l "Step Builder:";
				text -fn $boldFont -l "Use this section if normal Build had errors,";
				text -fn $boldFont -l "or to modify the build result.";
				separator -h 5;
				rowLayout -nc 2 -cw2 159 80 ("asStepBuildRowLayout0");
					setParent..;
				setParent..;
			for ($i=1;$i<size($stepBuildText);$i++)
				{
				setParent asStepBuildColumnLayout;
				columnLayout;
				rowLayout -nc 2 -cw2 159 80 ("asStepBuildRowLayout"+$i);
					text -l ($i+" : "+$stepBuildText[$i]) ("stepBuild"+$i+"Text");
					button -w 80 -h 15 -l "Build" -c ("asStepBuildPrep;asFace"+$stepBuildText[$i]+";asStepBuildComplete "+$i+";");
					setParent..;
					columnLayout ("asStepBuildColumnLayout"+$i);

				if ($stepBuildText[$i]=="EyeBall")
					text -l "   You can now test eye rotation.";

				if ($stepBuildText[$i]=="CtrlBox")
					text -l "   You can postition the CtrlBox.";

				if ($stepBuildText[$i]=="EyeLid")
					{
					text -l "   You can now test blink & fleshy-eye.";
					}

				if ($stepBuildText[$i]=="Squint")
					{
					text -al left -l "   Scrub time-slider to check Squint.\n   Tweak any lattice point if needed.\n      (do this at frame 30)";
					separator -st none -h 3;
					}

				if ($stepBuildText[$i]=="LipFalloff")
					{
					text -l "   You can now test the controller.";
					text -l "   If the area is to small or too big,";
					rowLayout -nc 5 -cw 1 10 ;
						separator -st none;
						text -l "Outside:";
						intField -w 22 -v 3 -min 0 -cc ("setAttr FaceFitSkeleton.vtxsFromLipToNose `intField -q -v lipFalloffOuterIntField`") lipFalloffOuterIntField;
						text -l "Inside:";
						intField -w 22 -v 2 -min 0 lipFalloffInnerIntField;
						setParent..;
					rowLayout -nc 5 -cw 1 10 ;
						separator -st none;
						checkBox -v 1 -l "mouthcorner weightfade" asFaceLipFalloffSideFadeCheckBox;
						floatField -min 1.01 -v 2.0 -pre 2 asFaceLipFalloffSideFadeFloatField;
						setParent..;
					separator -st none -h 5;
					rowLayout -nc 5 -cw 1 20 -cw 3 10;
						separator -st none;
						button -w 40 -l "test" -c "createNode -n asFaceLipFalloffTest transform;asFaceLipFalloff;";
						separator -st none;
						button -w 40 -l "update" -c "asFaceLipFalloff;print \"// Updated\\n\"";
						setParent..;
					}
				if ($stepBuildText[$i]=="Jaw")
					{
					text -l "   Scrub time-slider to check Jaw.\n";
					rowLayout -nc 2 -cw2 200 80;
						text -al left -l "   1: Set shape of lips by SoftMod.\n       (do this at frame 30)";
						setParent..;
					rowLayout -nc 4 -cw4 50 50 95 15;
						separator;
						button -h 15 -l "Edit" -c asFaceEditLipShapeBySoftMod;
						button -h 15 -l "Ok, Update" -c asFaceUpdateLipShapeBySoftMod;
						button -w 15 -h 12 -l "?" -c "asHelpImage asStepBuildLipShape";
						setParent..;
					rowLayout -nc 2 -cw2 200 80;
						text -al left -l "   2: Move and rotate the jaw-control,\n       to the \"mouth-open\" shape.\n       (do this at frame 30)";
						setParent..;
					separator -h 5;
					rowLayout -nc 2 -cw2 200 80;
						text -al left -l "   3:Edit curves to define weighting.\n       (do this at frame 0)";
						button -w 15 -h 12 -l "?" -c "asHelpImage fitFaceJawCurvesTweak";
						setParent..;
					rowLayout -nc 2 -cw2 190 80;
						text -l "   4:Set number of weight-smooths";
						intField -w 35 -v 50 asFaceNumJawSmooths;
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "       After any adjustments, then:";
						button -w 40 -h 12 -l "update" -c "asFaceWeightLips;asFaceUpdateJawCurvesWeights;print \"// Updated\\n\"";
						setParent..;
					rowLayout -nc 2 -cw2 190 80;
						text -l "   5:You can also paint Jaw-weights:";
						shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" -dcc "ArtPaintSkinWeightsTool;toolPropertyWindow;"
			        -image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c "ArtPaintSkinWeightsTool;";
						setParent..;
					}
				if ($stepBuildText[$i]=="SmilePull")
					text -l "   Adjust controller, to shape the SmilePull.";
				if ($stepBuildText[$i]=="SmileBulge")
					text -l "   Adjust controller, to shape the SmileBulge.";
				if ($stepBuildText[$i]=="CheekRaiser")
					text -l "   Adjust controller, to shape the CheekRaiser.";
				if ($stepBuildText[$i]=="Frown")
					text -l "   Adjust controller, to shape the Frown.";
				if ($stepBuildText[$i]=="JawOpen")
					{
					text -al left -l "   Scrub time-slider to check JawOpen.\n   Tweak controllers if needed.\n      (do this at frame 30)";
					separator -st none -h 3;
					}
				if ($stepBuildText[$i]=="UpMidLo")
					{
					text -l "   You can move the locators,";
					rowLayout -nc 2 -cw2 190 80;
						text -l "   and set number of weight-smooths";
						intField -w 35 -v 6 asFaceNumUpMidLomooths;
						setParent..;
					rowLayout -nc 2 -cw2 180 80;
						text -l "       After any adjustments, then:";
						button -w 40 -h 12 -l "update" -c "asFaceUpMidLo;print \"// Updated\\n\"";
						setParent..;
					}
//				if ($stepBuildText[$i]=="OnFacePlacement")
//					text -l "   Red controls can be used for placement.";			

				if ($stepBuildText[$i]=="Nose" || $stepBuildText[$i]=="SmilePull" || $stepBuildText[$i]=="SmileBulge"
				 || $stepBuildText[$i]=="CheekRaiser" || $stepBuildText[$i]=="Frown" || $stepBuildText[$i]=="Cheek")
					{
					if ($stepBuildText[$i]=="Nose") $side="_M";
					else $side="_R";
					rowLayout -nc 4;
						separator -st none -w 18;
						text -l "radius:";
//						button -h 15 -l "softMod" -c ("select "+$stepBuildText[$i]+$side+";asFaceConvertControlToSoftMod;");
//						button -h 15 -l "done" -c ("select convertedSoftModHandle_"+$stepBuildText[$i]+$side+";asFaceConvertSoftModBackToControl;");
						button -h 15 -l "softMod" -c asFaceConvertControlToSoftMod;
						button -h 15 -l "done" -c asStepBuildPrep;
						setParent..;
					}

				separator -w 240;
				}

			setParent..;
		rowLayout -nc 2;
			separator -w 90 -st none;
			button -h 15 -l "reset" -c asFaceResetBuildStep;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Layers" asFaceSkinLayersFrameLayout;
		rowLayout -nc 2 -cw2 15 500;
			separator;
		columnLayout asFaceSkinLayersColumnLayout;
			rowLayout -nc 2 -cw2 209 18;
				text -l "  Show SkinLayer:";
				button -w 11 -l "?" -c "asHelpImage asShowLayer";
				setParent..;
			button -w 100 -l "Normal" -c "asShowLayer Normal";
			separator -h 5;
			button -w 100 -l "EyeLid" -c "asShowLayer EyeLid";
			button -w 100 -l "Squint" -c "asShowLayer Squint";
			button -w 100 -l "EyeBrow" -c "asShowLayer EyeBrow";
			button -w 100 -l "Lip" -c "asShowLayer Lip";
			button -w 100 -l "Jaw" -c "asShowLayer Jaw";
			button -w 100 -l "Nose" -c "asShowLayer Nose";
			button -w 100 -l "SmilePull" -c "asShowLayer SmilePull";
			button -w 100 -l "SmileBulge" -c "asShowLayer SmileBulge";
			button -w 100 -l "CheekRaiser" -c "asShowLayer CheekRaiser";
			button -w 100 -l "MouthNarrow" -c "asShowLayer MouthNarrow";
			button -w 100 -l "Cheek" -c "asShowLayer Cheek";
			button -w 100 -l "Regions" -c "asShowLayer Regions";
			button -w 100 -l "UpMidLo" -c "asShowLayer UpMidLo";
			rowLayout -nc 2 -cw2 130 80;

				text -l "Paint weights on layer:  ";
				shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" 
	        -image paintSkinWeights.png
	        -image1 paintSkinWeights.png
	        -style "iconOnly" 
	        -dcc "ArtPaintSkinWeightsTool;toolPropertyWindow;"
	        -c "ArtPaintSkinWeightsTool" ;
	       setParent..;

			separator -w 220;
			separator -h 5;
			button -w 100 -l "Create New Layer" -c "asCreateLayer";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Tweaks" asFaceTweaksFrameLayout;
		columnLayout;

		separator -h 5 -w 240 -st none;
		text -al left -l "Swap controllers to Spheres:";
		checkBox -l "keep offset" asFaceSwapControlsKeepOffsetCheckBox;
		button -w 80 -l "Swap" -c asFaceSwapControlsToSpheres;

		separator -h 15 -w 240;
		text -al left -l "Edit weights by using SoftMod:";
		text -al left -l "First select a controller, then";
		button -l "convert to softMod" -c asFaceConvertControlToSoftMod;
		text -al left -l "After editing the SoftMod radius, then";
		button -l "convert back to control" -c asStepBuildPrep;

		separator -h 15 -w 240;
		text -al left -l "For custom oriented controllers:";
		rowLayout -nc 2 -cw2 228 15;
			button -w 150 -l "Detach controllers" -c asFaceDetachControllers;
			button -w 11 -l "?" -c "asHelpImage asFaceDetachControllers";
			setParent..;
		text -al left -l "Orient controllers, then";
		button -w 150 -l "Attach controllers" -c asFaceAttachControllers;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeBalls" asFaceEyeBallsFrameLayout;
		columnLayout;
		text -l "Select edgeLoops, then:";
		separator -h 5;
		rowLayout -nc 4;
			button -w 100 -l "Right Pupil" -c ("asEyeBallsChooseInput asFacePupil_RTextField");
			textField -w 100 -ed 0 asFacePupil_RTextField;
			separator -w 24 -st none;
			button -w 11 -l "?" -c "asHelpImage asEyeBallsPupil";
			setParent..;
		rowLayout -nc 4;
			button -w 100 -l "Right  Iris" -c ("asEyeBallsChooseInput asFaceIris_RTextField");
			textField -w 100 -ed 0 asFaceIris_RTextField;
			separator -w 24 -st none;
			button -w 11 -l "?" -c "asHelpImage asEyeBallsIris";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 4;
			button -w 100 -l "Left Pupil" -c ("asEyeBallsChooseInput asFacePupil_LTextField");
			textField -w 100 -ed 0 asFacePupil_LTextField;
			setParent..;
		rowLayout -nc 4;
			button -w 100 -l "Left  Iris" -c ("asEyeBallsChooseInput asFaceIris_LTextField");
			textField -w 100 -ed 0 asFaceIris_LTextField;
			setParent..;
		separator -h 10;
		checkBox -l "include Iris-size attribute" asFaceIrisCheckBox;
		rowLayout -nc 3;
			button -w 100 -l "Setup EyeBall" -c asFaceEyeBallBuild;
			separator -w 50 -st none;
			button -h 15 -w 50 -l "Edit SDK" -c asFaceEditEyeBallSDK;
			setParent..;
		setParent..;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeBrows" asFaceBrowsFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				columnLayout;
					text -l "Select EyeBrows, then:";
					separator -h 5;
					button -w 150 -l "SkinWeights to face" -c "asFaceCopyWeightsToFace";
					text -l "or:";
					button -w 150 -l "WrapDeform to face" -c "asFaceWrapDeformToFace";
					text -l "or:";
					button -w 150 -l "WireDeform to face" -c "asFaceWireDeformToFace";


	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EyeLashes" asFaceLashesFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				text -l "Select EyeLashes, then:";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Attach" -c "asFaceAttachEyeLashes";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " FaceExtras"  asFaceExtrasFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 2 -cw2 20 100;
				separator -st none -w 15;
				columnLayout;
					text -l "For beard, mustache, mask, etc:";
					separator -h 5;
					button -w 150 -l "Add to all SkinLayers" -c "asFaceCopyWeightsToFaceAllLayers";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " DeltaMush" asFaceDeltaMushFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Create DeltaMush" -c asFaceDeltaMush;
				setParent..;
			separator -st "none" -h 15;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Select eyeLidArea" -c "select eyeLidArea";
				setParent..;
			separator -st "none" -h 5;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Select lipArea" -c "select lipArea";
				setParent..;
			separator -st "none" -h 15;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "zero weight selected" -c asFaceDeltaMushZeroWeight;
				setParent..;

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " HeadSquash" asFaceSquashFrameLayout;
		columnLayout -adj 1;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Create HeadSquash" -c "asAdvancedSquash";
				setParent..;
			separator -st "none" -h 10;
			rowLayout -nc 3 -cw3 15 211 18;
				separator -st none;
				button -w 150 -l "Optimize HeadSquash" -c "asOptimizeSquash";
				setParent..;
			text -fn $boldFont -l "To make sure only head";
			text -fn $boldFont -l "and no other parts of body gets squashed";


	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " BlendShapes" asFaceBlendShapesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 4 -cw4 15 200 9 18;
				separator -st none;
				checkBox -v 0 -l "keep blendShape target objects" asKeepBSTargetsCheckBox;
				separator -st none;
				button -w 11 -l "?" -c "asHelpImage asConvertKeepBSTargets";
				setParent..;
			separator -st "none" -h 5;
			text -l "Convert to BlendShapes:";
			separator -st "none" -h 2;
//			string $controls[]={"boxCtrls","squint","fleshyEye","blink","ctrlMouth","ctrlPhonemes"};
			string $controls[]={"boxCtrls","squint","fleshyEye","blink"};
			for($i=0;$i<size($controls);$i++)
				{
				rowLayout -nc 4 -cw4 15 200 9 18;
					separator -st none;
					button -w 200 -l $controls[$i] -c ("asBSConvertControlsToBlendShapes "+$controls[$i]);
					separator -st none;
					button -w 11 -l "?" -c ("asHelpImage asConvert"+$controls[$i]+"ToBlendShapes");
					setParent..;
				separator -st "none" -h 5;
				}
	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " EditBlendShapes" asFaceEditBlendShapesFrameLayout;
		columnLayout -adj 1;
			text -l "Set controls to the shape for adjustment, then:";
			floatFieldGrp -v1 1.0 -cw2 65 50 -l "multiplier" asCreateTargetShapeMultiplier;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "extract blendShape target" -c "asBSAdjustTarget";
				separator -st none;
				button -h 18 -w 40 -l "reset" -c "asBSResetTarget";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesCreate";
				setParent..;
			rowLayout -nc 2;
				separator -w 15 -st none;
				floatSlider -en 0 -w 130 -min 0 -max 1 -value 0 -step 0.1 asFaceBSFloatSlider;
				setParent..;
			rowLayout -nc 3 -cw3 15 162 18;
				separator -st none;
				text -l "Delete the targets when finished:";
				button -h 18 -w 40 -l delete -c "delete deleteThis";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				columnLayout -adj 0;
					text -l "Or step through ALL the BlendShape targets,";
					text -l "with the blendShapes wizard:";
					setParent..;
				setParent..;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "start blendShapes wizard" -c "asBSWizard" asBSWizardButton;
				separator -st none;
				button -en 0 -w 40 -l "next.." -c "asBSWizardNext" asBSWizardNextButton;
				button -w 11 -en 0 -l "?" -c "asHelpImage asBSWizardStep0" asBSWizardHelpButton;
				setParent..;
			rowLayout -nc 4 -cw4 15 30 140 50;
				separator -st none;
				text -en 0 -w 30 -l "0/19" asBSWizardStepText;
				text -en 0 -w 140 -l "..." asBSWizardObjAttrText;
				text -en 0 -w 50 -l "..." asBSWizardValueText;
				setParent..;
			rowLayout -nc 2 -cw2 15 200;
				separator -st none;
				button -w 150 -l "stop blendShapes wizard" -c "asBSWizardStop";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				text -l "Or extract All targets:";
				setParent..;
			rowLayout -nc 3 -cw3 15 211 15;
				separator;
				button -w 150 -l "extract All targets" -c "asBSExtractAll";
				button -w 11 -l "?" -c "asHelpImage asEditBlendShapesExtractAll";
				setParent..;
			separator -h 20 -w 242;
			rowLayout -nc 2 -cw2 20 200;
				separator -st none;
				text -l "Or smooth all targets using DeltaMush:";
				setParent..;
			floatFieldGrp -v1 1.3 -cw2 65 50 -l "multiplier" asDeltaMushShapeMultiplier;
			rowLayout -nc 3 -cw3 15 211 15;
				separator;
				button -w 150 -l "DeltaMush All targets" -c "asBSDeltaMushAll";
				button -w 11 -l "?" -c "asHelpImage asDeltaMushAll";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " NewBlendShapes" asFaceNewBlendShapesFrameLayout;
		columnLayout -adj 1;
			rowLayout -nc 5 -cw5 15 150 10 47 18;
				separator -st none;
				button -w 150 -l "Create New BlendShape" -c "asBSNewTarget";
				separator -st none;
				separator -st none;
				button -w 11 -l "?" -c "asHelpImage asCreateNewBlendShape";
				setParent..;
//			setParent..;
			rowLayout -nc 3 -cw3 15 182 18;
				separator -st none;
				text -l "Delete the targets when finished:";
				button -h 18 -w 40 -l delete -c "delete deleteThis";

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " CustomControllers" asFaceCustomControlsFrameLayout;
	string $faceBody;
	for ($a=0;$a<2;$a++)
		{
		// Runs the CustomControllers Twice, once for Body, and once for Face
		if ($a==0) {setParent asBodyCustomControlsFrameLayout;$faceBody="Body";}
		if ($a==1) {setParent asFaceCustomControlsFrameLayout;$faceBody="Face";}

		columnLayout -adj 0;
			text -l "Create:";
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					text -l "First create a SoftMod:";
					iconTextButton -w 35 -h 35 -i "softMod.png" -c SoftModTool;
					text -l "Then:";
					rowLayout -nc 3;
						checkBox -l "mirror  " -v 1 -onc ("checkBox -e -v 0 as"+$faceBody+"ClusterControlMiddleCheckBox") ("as"+$faceBody+"ClusterControlMirrorCheckBox");
						checkBox -l "middle  " -v 0 -onc ("checkBox -e -v 0 as"+$faceBody+"ClusterControlMirrorCheckBox") ("as"+$faceBody+"ClusterControlMiddleCheckBox");
						checkBox -l "local" -v 0 ("as"+$faceBody+"ClusterControlLocalCheckBox");
						if ($faceBody=="Face")
							checkBox -e -m 0 asFaceClusterControlLocalCheckBox;//Local on face not supported (causes pose mirroring issues)
						setParent..;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create Cluster SoftMod" -c ("asConvertSoftModToClusterControl "+$a);
						button -w 11 -l "?" -c "asHelpImage asClusterControlCreate";
						setParent..;
					text -l "Or:";
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Create SoftMod Control" -c ("asConvertSoftModToSoftModControl "+$a);
						button -w 11 -l "?" -c "asHelpImage asSoftModControlCreate";
						setParent..;
					setParent..;
				setParent..;

			separator -st none -h 10;
			text -l "Edit Cluster Control:";
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					button -w 190 -l "Paint weights for selected Control" -c asPaintClusterControlWeights;
					setParent..;
				setParent..;
			separator -st none -h 5;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					button -w 190 -l "Mirror weights for selected Control" -c asMirrorClusterControlWeights;
					setParent..;
				setParent..;
			separator -st none -h 10;
			text -l "Edit SoftMod Control:";
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout -adj 0;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Add influenced object" -c asAddSoftModInfluencedObject;
						button -w 11 -l "?" -c "asHelpImage asSoftModControlAddInfluencedObject";
					setParent..;
				setParent..;

			setParent..;
		setParent..;
		}

	setParent asFaceColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Simplified-FaceSetup" asFaceSimplifiedFrameLayout;
		columnLayout;
			rowLayout -nc 2;
				separator -w 25 -st none;
				columnLayout;
					rowLayout -nc 2 -cw2 198 15;
						button -w 190 -l "Convert FaceSetup" -c "asFaceConvertFaceSetup";
						button -w 11 -l "?" -c "asHelpImage asFaceSetupSimplified";

setParent asColumnLayout;
frameLayout -w 270 -mw 10 -cll 1 -cl 1 -cc asFL -ec asFL -l "Pose" asPoseFrameLayout;
columnLayout -adj 1 asPoseColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Driving Systems" asBodyDrivingSystemsFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout -adj 0;
					text -l "First make the pose to be driven";
					text -l "(e.g. folded wings, hand guesture..)";
					text -l "Then:";
					setParent..;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st none;
				button -w 162 -l"Create Driving System" -c asDsCreate;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator;
				text -l "Right Click on any of these buttons,\nto access existing Driving Systems.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
//				separator -st none;
				separator -st none;
				button -w 50 -en (!$dsm) -l "Edit" -c asDsAutoFindAndEdit asDsEditButton;
				popupMenu -pmc "asDsPopulatePopupMenu Edit" asDsEditPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDsDeleteButton;
				popupMenu -pmc "asDsPopulatePopupMenu Delete" asDsDeletePopupMenu;
				button -w 50 -en (!$dsm) -l "Graph" asDsGraphButton;
				popupMenu -pmc "asDsPopulatePopupMenu Graph" asDsGraphPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asDrivingSystemsEdit";
				setParent..;
			separator -st none -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "After editing pose, then:";
				setParent..;
			rowLayout -en 0 -nc 5 -cw5 60 55 55 52 15 asDSEditChoicesRowLayout;
				separator -st none;
				button -w 50 -l "Apply" -c asDsEditApply;
				button -w 50 -l "Cancel" -c asDsEditCancel;

	setParent asPoseColumnLayout;
	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes" asBodyCorrectiveFrameLayout;
		columnLayout -adj 0;
			text -l "Create:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				columnLayout -adj 0;
					text -l "Go to pose to correct, then:";
					text -l "Select mesh to correct, then:";
					setParent..;
				setParent..;
			rowLayout -nc 2 -cw2 80 100;
				separator -st none;
				checkBox -v 1 -l "Angle Rotations" asCorrectiveAngleCheckBox;
				setParent..;
			rowLayout -nc 3 -cw3 60 166 15;
				separator -st none;
				button -w 162 -en (!$csm) -l "Create Corrective Shape" -c asCreateCorrectiveShape asCreateCorrectiveButton;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCreate";
				setParent..;
			separator -w 242 -h 5;
			text -l "Edit:";
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "Right Click on any of these buttons,\nto access existing Corrective Shapes.";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15;
				separator -st none;
				button -w 50 -en (!$csm) -l "Edit" asEditCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Edit" asEditCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Delete" asDeleteCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Delete" asDeleteCorrectiveShapesPopupMenu;
				button -w 50 -en (!$csm) -l "Graph" asGraphCorrectiveButton;
				popupMenu -pmc "asPopulateCorrectivePopupMenu Graph" asGraphCorrectiveShapesPopupMenu;
				button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesEdit";
				setParent..;
			separator -st none -h 20;
			rowLayout -nc 2 -cw2 60 100;
				separator -st none;
				text -l "After sculpted shape, then:";
				setParent..;
			rowLayout -nc 5 -cw5 60 55 55 52 15 asCorrectiveEditChoicesRowLayout;
				separator -st none;
				button -l "Apply" -c asConnectCorrectiveShape;
				checkBox -v 1 -l "mirror" asCorrectiveMirrorCheckBox;
				button -l "Cancel" -c asCancelCorrectiveShape;
				setParent..;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl 1 -cc asFL -ec asFL -l " Corrective Shapes - Advanced" asBodyCorrectiveAdvancedFrameLayout;
		
			rowLayout -nc 2;
				separator -w 10 -st none;
				columnLayout -adj 0;
			frameLayout -cll 1 -cl 1 -w 225 -cc asFL -ec asFL -l " Bake" asBodyCorrectiveBakeFrameLayout;
//			checkBox -l advanced -onc "columnLayout -e -m 1 asCorrectiveAdvancedColumnLayout" -ofc "columnLayout -e -m 0 asCorrectiveAdvancedColumnLayout";
				columnLayout -m 0 asCorrectiveAdvancedColumnLayout;
	//				separator -h 15 -st none;
					rowLayout -nc 2 -cw2 209 100;
						text -l "Bake Deformations to Corrective Shapes:";
						button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesBake";
						setParent..;
					rowLayout -nc 2;
						button -w 120 -l "Source" -c "textField -e -tx `ls -sl` asBakeToCorrective1TextField";
						textField -w 100 -ed 0 asBakeToCorrective1TextField;
						setParent..;
					rowLayout -nc 2;
						button -w 120 -l "Destination" -c "textField -e -tx `ls -sl` asBakeToCorrective2TextField";
						textField -w 100 -ed 0 asBakeToCorrective2TextField;
						setParent..;
					text -l "rotations:";
					rowLayout -nc 6 asBakeAxisRowLayout;
						checkBox -l "+x" -v 1 asBakeX1CheckBox;
						checkBox -l "+y" -v 1 asBakeY1CheckBox;
						checkBox -l "+z" -v 1 asBakeZ1CheckBox;
						checkBox -l "-x" -v 1 asBakeX2CheckBox;
						checkBox -l "-y" -v 1 asBakeY2CheckBox;
						checkBox -l "-z" -v 1 asBakeZ2CheckBox;
						setParent..;
					text -l "Select FK controller, then:";
					rowLayout -nc 3 -cw3 80 50 100;
						button -w 50 -l "Bake" -c asBakeIntoCorrectiveShapes;
	//					text "or";
	//					button -l "Create Source" -c asCurveBasedAutoCorrectiveShapes;
							setParent..;
						setParent..;
					setParent..;

				frameLayout -cll 1 -cl 1 -w 225 -cc asFL -ec asFL -l " CurveBased deformations" asBodyCorrectiveCBDFrameLayout;
				columnLayout;
				rowLayout -nc 2 -cw2 209 100;
					text -l "Create Curve Based Deformation objects,\nto use as Corrective Shape targets";
					button -w 11 -l "?" -c "asHelpImage asCorrectiveShapesCurveBased";
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "Mesh" -c "textField -e -tx `ls -sl` asBodyCorrectiveCBDMeshTextField";
					textField -w 100 -ed 0 asBodyCorrectiveCBDMeshTextField;
					setParent..;
				rowLayout -nc 2;
					button -w 120 -l "FK control" -c "textField -e -tx `ls -sl` asBodyCorrectiveCBDFKControlTextField";
					textField -w 100 -ed 0 asBodyCorrectiveCBDFKControlTextField;
					setParent..;
				button -l "Create Curves" -c asCBDCreateCurves;
				button -l "Create test animation" -c asCBDCreateTestAnim;
				text -l "Tweak curves to match geo, if needed";
				button -l "Hide original mesh" -c asCBDHideMesh;
				button -l "Create new deformation mesh" -c asCBDCreateDeformMesh;
//				button -l "Update deformation mesh" -c asCBUpdateDeformMesh;
				rowLayout -nc 4;
					separator -w 30 -st none;
					button -l "Show original" -c asCBDShowOriginal;
					separator -w 10 -st none;
					button -l "Show new" -c asCBDShowNew;
					setParent..;
				text -l "\"Slide\" attributecan be adjusted, if needed.";
				separator -h 5;
				text -l "When finished:";
				rowLayout -nc 4;
					separator -w 10 -st none;
					button -l "Bake as Corrective" -c asCBBakeDeformMesh;
					text -w 30  -l "or";
					button -l "Cancel" -c asCBCleanup;


setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Tools" asToolsFrameLayout;
columnLayout -adj 1;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "SelectorDesigner" -c asSelectorDesigner;
		button -w 11 -l "?" -c "asHelpImage asSelectorDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "PoserDesigner" -c asPoserDesigner;
		button -w 11 -l "?" -c "asHelpImage asPoserDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "WalkDesigner" -c asWalkDesigner;
		button -w 11 -l "?" -c "asHelpImage asWalkDesigner";
		setParent..;
	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "AnimationTester" -c asAnimationTesterUI;
		button -w 11 -l "?" -c "asHelpImage asAnimationTester";
		setParent..;

	separator -st none -h 5;
	rowLayout -nc 3 -cw3 60 168 15;
		separator -st none;
		button -w 140 -l "NameMatcher" -c asNameMatcherUI;
		button -w 11 -l "?" -c "asHelpImage asNameMatcher";
		setParent..;

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Display" asDisplayFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "MotionSystem:";
			button -w 60 -l "Hide" -c "setAttr MotionSystem.v 0";
			button -w 60 -l "Show" -c "setAttr MotionSystem.v 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joints:";
			button -w 60 -l "Hide" -c "asJointsVisibility 0";
			button -w 60 -l "Show" -c "asJointsVisibility 1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			text -l "Joint axis:";
			button -w 60 -l "Hide" -c "asDisplayRigRLA 0";
			button -w 60 -l "Show" -c "asDisplayRigRLA 1";
			setParent..;
		rowLayout -nc 2 -cw2 73 100;
			text "Joint Size:";
			floatSliderGrp -cw2 35 130 -field 1 -min 0.01 -max 10.0 -pre 2 -v `jointDisplayScale -q` -dc "jointDisplayScale #1" -cc "jointDisplayScale #1";
			setParent..;
		rowLayout -nc 3 -cw3 73 100 100;
			separator;
			button -w 150 -l "Select jointLayer" -c "select jointLayer;AttributeEditor";
			setParent..;

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Optimize" asOptimizeFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused Nodes" -c "hyperShadePanelMenuCommand(\"\", \"deleteUnusedNodes\");print \"// Unused nodes deleted.\\n\"";
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Remove Unused Influences" -c asRemoveAllUnusedInfluences;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete saved UIs" -c asSaveUIs;
			setParent..;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Delete Unused joints" -c asDeleteUnusedJoints;
			setParent..;

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Publish" asPublishFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Set DisplayLayers to \"R\"" -c asSetDisplayLayersToR;
			setParent..;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Set Joints to hidden" -c "asJointsVisibility 0";
			setParent..;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			button -w 140 -l "Go to Build Pose" -c "asGoToBuildPose bodySetup;if (`objExists FaceControlSet`)asGoToBuildPose faceSetup;";
			setParent..;
		separator -st none -h 10;
		rowLayout -nc 3 -cw3 60 168 15;
			separator -st none;
			button -w 140 -l "Publish" -c asPublish;
			button -w 11 -l "?" -c "asHelpImage asPublish";

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Export" asExportFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 2 -cw2 60 100;
			separator -st none;
			columnLayout;
				text -l "For Game-Engine Export:";
				separator -st none -h 5;
				button -w 140 -l "Delete Unused Endjoints" -c asDeleteUnusedJoints;
				separator -st none -h 5;
				button -w 140 -l "Delete Static channels" -c "evalEcho \"delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1\";";
				separator -st none -h 5;
				button -w 140 -l "Rebuild dagPose nodes" -c asReBuildDagPose;
				separator -st none -h 5;
				button -w 140 -l "FBX export" -c asFbxExport;
				setParent..;
			setParent..;

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "Demo" asDemoFrameLayout;
	columnLayout -adj 1;
		separator -h 10 -st none;
		rowLayout -nc 3 -cw3 50 178 15;
			separator -st none;
			button -l "Check online for Demo updates" -c asCheckForDemoUpdates;
			button -w 11 -l "?" -c "asHelpImage asDemoCheckOnline";
			setParent..;
		separator -h 10 -st none;
		rowLayout -nc 4;
			separator -w 50 -st none;
			optionMenu asDemoOptionMenu;
			separator -w 25 -st none;
			button -l "Open" -c asOpenDemoFile;
			setParent..;

setParent asColumnLayout;
frameLayout -w 270 -cll 1 -cl 1 -cc asFL -ec asFL -l "About" asAboutFrameLayout;
columnLayout -adj 1;
	image -h 83 -i ($asScriptLocation+"/AdvancedSkeleton5Files/icons/asLogo.png") asHelpImage;
	if (`asIsMayaLT`)
		text -l "\nNote:\nRunning Maya LT,\n so not all AdvancedSkeleton features enabled.\n";
	button -l "visit AdvancedSkeleton website" -c "showHelp -a \"http://www.animationstudios.com.au/advancedskeleton\"";
	separator -h 15;
	if (`asMayaVersionAsFloat`>=2012)
		{
		rowLayout -nc 4 -cw4 60 50 70 100;
			text -l " Window:";
			button -c "asDockWindow 1" -l " Dock ";
			button -c "asDockWindow 0" -l " UnDock ";
			button -c asCreateWorkspaceControl -l "Workspace" asWorkspaceButton;
			if (`asMayaVersionAsFloat`<2017)
				button -e -en 0 -ann "Workspace-controller requires Maya2017 or higher" asWorkspaceButton;
			setParent..;
		}
	separator -h 15;
	rowLayout -nc 5 -cw5 110 40 30 54 15;
		button -l "Check For Updates" -c asCheckForUpdates;
		text -l "found:";
		text -m 1 -l "x.xxx" asUpdateFoundVersion;
		button -en 0 -l "Update" -c asUpdateVersion asUpdateVersionButton;
		button -w 11 -l "?" -c "asHelpImage asAboutUpdate";
		setParent..;
	checkBox -m 0 -v 0 asBetaCheckBox;	
	separator -h 15;
	rowLayout -nc 3 -cw3 80 158 15;
		text -l "current version:";
		button -l `asGetScriptVersionAsString` -c "print \"// right click on button to change version.\\n\"";
			popupMenu asVersionsPopupMenu;
		button -w 11 -l "?" -c "asHelpImage asAboutCurrentVersion";
		setParent..;
	separator -h 5;

	rowLayout -nc 3 -cw3 80 158 15;
		text -l "version history:";
		button -l "download version history info" -c asVersionHistory;
		setParent..;
	separator -h 5;


	columnLayout -adj 0;
		text -l "For support, go to:\nwww.facebook.com/AdvancedSkeleton\nOr email: support@animationstudios.com.au\n\nFor license information, read the eula.txt file.";

setParent asFormLayout;
rowLayout -nc 2 -cw2 120 100 asRowLayout;
columnLayout;
	rowLayout -nc 5 -cw5 30 90 10 30 90;
		text -l "body:" asBodyText;
		button -c "asGoToBuildPose bodySetup" -l "Go to Build Pose";
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose bodySetup";
		separator -w 10 -st none;
		text -l "face:" asFaceText;
		button -c "asGoToBuildPose faceSetup" -l "Go to Build Pose" asGoToBuildPoseFaceButton;
		popupMenu;
		menuItem -l "set build pose" -c "asSetBuildPose faceSetup";
		setParent..;
	setParent..;
formLayout -e
	-af asScrollLayout "right" 0
	-af asScrollLayout "left" 0
	-af asScrollLayout "top" 0
	-ac asScrollLayout "bottom" 0 asRowLayout
	-af asRowLayout "bottom" 0
	asFormLayout;

if (!`control -q -ex asWorkspaceControl`)
	{
	if($asDock)
		{
		if (`asMayaVersionAsFloat`>=2012)
			dockControl -l AdvancedSkeleton -w 288 -fl 0 -floatChangeCommand asDockWindowChangeFloatingState -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
		else
			dockControl -l AdvancedSkeleton -w 288 -fl 0 -a "left" -con AdvancedSkeletonWindow -aa "left" -aa "right" AdvancedSkeletonDockControl;
		if (`asMayaVersionAsFloat`>=2016)
			{
			//force left docking area to be matching size, as it might be bigger, if a crash-report has auto-docked
			dockControl -e -fixedWidth 1 AdvancedSkeletonDockControl;
			refresh;
			dockControl -e -fixedWidth 0 AdvancedSkeletonDockControl;
			}
		evalDeferred "dockControl -e -r AdvancedSkeletonDockControl;";
		}
	else
		showWindow;
	}
asUpdateLabelHelp;
asUpdateAttributeHelp;
asEnsureFitSkeletonAttributes;
asUpdateButtonEnables;
if (`window -q -ex AdvancedSkeletonWindow`)
	{
	window -e -w 296 AdvancedSkeletonWindow;
	if (`asMayaVersionAsFloat`<2012)
		window -e -w 309 AdvancedSkeletonWindow;
	if (!`windowPref -q -ex AdvancedSkeletonWindow`)
		window -e -h 500 AdvancedSkeletonWindow;
	}
if ($asFaceIsResetting)
	$asFaceIsResetting=0;
else
	asFaceUpdateInfo 1;

//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		if (`optionVar -ex $framLayouts[$i]`)
			frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];

//populate fitSkeletonFiles optionMenu
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";
string $fitSkeletonFiles[]=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asFitFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

//populate Retopology optionMenus
string $headTopologyDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopology/";
string $headTopoFiles[]=`getFileList -fld $headTopologyDir`;
setParent -menu asCreateFaceRetopoOptionMenu;
for ($i=0;$i<size($headTopoFiles);$i++)
	{
	if (`gmatch $headTopoFiles[$i] "[.]*"` || $headTopoFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoFiles[$i];
	}
string $headTopologyEyeBallDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyEyeBall/";
string $headTopoEyeBallFiles[]=`getFileList -fld $headTopologyEyeBallDir`;
setParent -menu asCreateFaceRetopoEyeBallOptionMenu;
for ($i=0;$i<size($headTopoEyeBallFiles);$i++)
	{
	if (`gmatch $headTopoEyeBallFiles[$i] "[.]*"` || $headTopoEyeBallFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoEyeBallFiles[$i];
	}
string $headTopologyTeethDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyTeeth/";
string $headTopoTeethFiles[]=`getFileList -fld $headTopologyTeethDir`;
setParent -menu asCreateFaceRetopoTeethOptionMenu;
for ($i=0;$i<size($headTopoTeethFiles);$i++)
	{
	if (`gmatch $headTopoTeethFiles[$i] "[.]*"` || $headTopoTeethFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $headTopoTeethFiles[$i];
	}

//populate Demo optionMenu
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeleton5Files/exampleFiles/downloads/";
string $exampleFolders[]=`getFileList -fld $exampleFoldersDir`;
setParent -menu asDemoOptionMenu;
for ($i=0;$i<size($exampleFolders);$i++)
	{
	string $exampleFile=$exampleFoldersDir+$exampleFolders[$i]+"/"+$exampleFolders[$i]+".mb";
	if (`file -q -ex $exampleFile`)
		menuItem -l $exampleFolders[$i];
	}

$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
$fitSkeletonFiles=`getFileList -fld $fitSkeletonsDir`;
setParent -menu asLimbFiles;
for ($i=0;$i<size($fitSkeletonFiles);$i++)
	{
	if (`gmatch $fitSkeletonFiles[$i] "[.]*"` || $fitSkeletonFiles[$i]=="incrementalSave")
		continue;
	menuItem -l $fitSkeletonFiles[$i];
	}

//Exist EditDrivingSystemMode (if stuck)
if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;

//Set 0.2 jointDisplayScale if first run of AdvancedSkeleton
if (!`optionVar -ex asBodyFrameLayout`)
	jointDisplayScale 0.2;

//populate asVersionsPopupMenu
string $oldVersionsDir=$asScriptLocation+"/AdvancedSkeleton5Files/oldVersions/";
int $latestLocal;
setParent -menu asVersionsPopupMenu;
string $oldVersions[];
if (`file -q -ex $oldVersionsDir`)
	$oldVersions=`getFileList -fld $oldVersionsDir`;
$oldVersions=`sort $oldVersions`;
for ($i=size($oldVersions);$i>-1;$i--)
	{
	if ($i==size($oldVersions))
		{
		$label=`asGetLatestLocalVersionAsString`;
		$latestLocal=1;
		}
	else
		{
		$label=$oldVersions[$i];
		$latestLocal=0;
		}
	$label=`substitute "AdvancedSkeleton_v" $label ""`;
	menuItem -l $label -c ("asSourceVersion \""+$label+"\" "+$latestLocal);
	}

//Maya less than2012 limitations
if (`asMayaVersionAsFloat`<2012)
	{
	string $childArray[]=`columnLayout -q -ca asFaceColumnLayout`;
	for ($i=0;$i<size($childArray);$i++)
		layout -e -m 0 $childArray[$i];
	setParent asFaceColumnLayout;
	text -l "FaceSetup requires Maya2012 or higher";
//	frameLayout -e -m 0 asFaceTweakControlsFrameLayout;
	}

//Maya LT limitations
if (`asIsMayaLT`)
	{
	frameLayout -e -en 0 asBodyDeform2FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDeform3FrameLayout;//no wire deformer
	frameLayout -e -en 0 asBodyDrivingSystemsFrameLayout;//no sdk
	frameLayout -e -en 0 asFaceFrameLayout;//no nCloth
	}

if (!$haveRanThisVersion) asFirstRunOfNewVersion;//First time running this version

progressBar -e -ep $gMainProgressBar;
}

global proc asScriptLocatorProc (){}

global proc string asGetScriptLocation ()
{
string $whatIs=`whatIs asScriptLocatorProc`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder-1)`;
return $scriptLocation;
}

global proc float asGetScriptVersion ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
float $version=`asGetScriptVersionFromFile $file`;
return $version;
}

global proc string asGetScriptVersionAsString ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $file=$asScriptLocation+"/AdvancedSkeleton5.mel";
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
return $versionAsString;
}

global proc float asGetScriptVersionFromFile (string $file)
{
string $versionAsString=`asGetScriptVersionFromFileAsString $file`;
float $version=$versionAsString;
return $version;
}

global proc string asGetScriptVersionFromFileAsString (string $file)
{
string $versionString;
string $tempString[];
int $lineNr;
if (`file -q -ex $file`)
	{
	int $fileId=`fopen $file "r"`;
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$lineNr++;
		$nextLine = `fgetline $fileId`;
		if (`gmatch $nextLine "*Version*"`)
			{
			tokenize $nextLine $tempString;
			tokenize $tempString[2] "[.]" $tempString;
			for ($i=0;$i<size($tempString);$i++)
				{
				$versionString+=$tempString[$i];
				if ($i==0)
					$versionString+=".";
				}
//			$version=$versionString;
			}
		if($lineNr>10)
			break;
		}
	fclose $fileId;
	}
else
	warning "Unable to determine AdvancedSkeleton version number";
return $versionString;
}

global proc asSourceVersion (string $versionAsString, int $latestLocal)
{
global string $gShelfTopLevel;
int $sucess;
string $buttons[];

string $asFile,$iol,$image;
string $latestLocalScriptLocation=`asGetLatestLocalScriptLocation`;
if ($latestLocal)
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5.mel";
else
	{
	$asFile=$latestLocalScriptLocation+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$versionAsString+"/AdvancedSkeleton5.mel";
	$iol=$versionAsString;
	if (!`file -q -ex $asFile`)
		{
		warning ("attempted to source version: "+$versionAsString+", but could not find file:\""+$asFile+"\", so using latest installed version instead");
		optionVar -iv asUseVersionLatestLocal 1;
		return;
		}
	}

string $cmd="source \""+$asFile+"\";AdvancedSkeleton5;";
string $shelves[]=`tabLayout -q -ca $gShelfTopLevel`;
for ($i=0;$i<size($shelves);$i++)
	{
	$buttons=`layout -q -ca $shelves[$i]`;
	for ($y=0;$y<size($buttons);$y++)
		{
		if (!`shelfButton -q -ex $buttons[$y]`)
			continue;
		string $ann=`shelfButton -q -ann $buttons[$y]`;
		if ($ann=="AdvancedSkeleton5")
			{
			$image=`shelfButton -q -i $buttons[$y]`;
			if ($iol=="")
				$image=`substitute "AS4version" $image "AS4"`;
			else
				$image=`substitute "AS4" $image "AS4version"`;
			shelfButton -e -c $cmd -iol $iol -i $image -i1 $image $buttons[$y];
			$sucess=1;
			}
		}
	}
if ($sucess)
	{
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		evalDeferred -lp ("deleteUI -control AdvancedSkeletonDockControl");
	else if (`window -q -ex AdvancedSkeletonWindow`)
	    evalDeferred -lp ("deleteUI AdvancedSkeletonWindow");
	if (`exists workspaceControl`)
		if (`workspaceControl -q -ex asWorkspaceControl`)
			deleteUI asWorkspaceControl;
	print ("// Shelf button updated, Click on the button to launch choosen version of AdvancedSkeleton\n");
	}
}

global proc int asIsMayaLT ()
{
int $isMayaLT=0;
if (!`exists CreateWrap`)
	$isMayaLT=1;
return $isMayaLT;
}

global proc int asHaveMeshCenterSnap ()
{
int $haveSnap;
string $helpString=`help snapMode`;
string $tempString[];
tokenize $helpString $tempString;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]=="-meshCenter")
		$haveSnap=1;
return $haveSnap;
}

global proc asFirstRunOfNewVersion ()
{
global string $gShelfTopLevel;
int $hasAS,$hasPicker;
string $currentShelf = `tabLayout -query -selectTab $gShelfTopLevel`;
string $asScriptLocation=`asGetScriptLocation`;
string $shelfButtons[]=`shelfLayout -q -ca $currentShelf`;
for ($i=0;$i<size($shelfButtons);$i++)
	{
	if (!`shelfButton -q -ex $shelfButtons[$i]`)
		continue;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="AdvancedSkeleton5") $hasAS=1;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="picker") $hasPicker=1;
	if (`shelfButton -q -ann $shelfButtons[$i]`=="Selector:picker") $hasPicker=1;
	}
if ($hasAS && !$hasPicker)
	if (`confirmDialog -title "Add tool ?" -message 
	("This version have a new tool for your shelf (Picker)\n"
	+"Add this to your shelf now ?")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`=="Yes")
    {
		evalEcho ("source \""+$asScriptLocation+"/AdvancedSkeleton5Files/picker/install.mel\"");
		SavePreferences;
		}
optionVar -iv asHaveRanThisVersion 1;
}

global proc asUpdateLabelHelp ()
{
string $type=`optionMenu -q -v asLabelType`;
string $help="";
if ($type=="Hand" || $type=="Shoulder")
	$help="Hand + Shoulder = Arm IK";
if ($type=="Hip" || $type=="Foot")
	$help="Hip + Foot = Leg IK";
if ($type=="LegAim")
	$help="LegAim + Hip + Foot = 3 bone Leg IK";
if ($type=="Heel" || $type=="Toes" || $type=="ToesEnd")
	$help="Heel + Toes + ToesEnd = FootRoll";
if ($type=="BigToe" || $type=="PinkyToe")
	$help="BigToe + PinkyToe = FootRock";
if ($type=="QToes")
	$help="Quadped toes";
if ($type=="Root" || $type=="Chest" || $type=="Mid")
	$help="Root + Chest (+ Mid) = Spine IK";
if ($type=="0" || $type=="1" || $type=="2" || $type=="3")
	$help="0,1,2, etc.. = Spline IK (tail)";


text -e -l $help asLabelHelp;
}

global proc asUpdateAttributeHelp ()
{
string $type=`optionMenu -q -v asAttributeType`;
string $help="";
if ($type=="twist/bendy")
	$help="TwistJoints & Bendy-limbs";
if ($type=="inbetween")
	$help="Creates extra inbetween joints";
if ($type=="global")
	$help="Keeps limbs orientation fixed";
if ($type=="aim")
	$help="LookAt (AimConstraint)";
if ($type=="wheel")
	$help="Wheel Roller";
if ($type=="freeOrient")
	$help="Free limb orientation";
if ($type=="worldOrient")
	$help="Orient limb to world-space";
if ($type=="flipOrient")
	$help="Reverse up-vector";
if ($type=="noMirror")
	$help="For non-symmetrical limbs";
if ($type=="noFlip")
	$help="Ignore Mirror behaviour";
if ($type=="noControl")
	$help="Skips creating FK-control";
if ($type=="ikLocal")
	$help="Local oriented IK-control";
if ($type=="centerBtwFeet")
	$help="Makes Root follow IK legs";
if ($type=="geoAttach")
	$help="Controller sticks to geometry";
if ($type=="aimAt")
	$help="Aim at another control";
if ($type=="curveGuide")
	$help="For feather setup";

text -e -l $help asAttributeHelp;
}

global proc asFitResample ()
{
if (`window -q -ex asFitResample`)
	deleteUI asFitResample;
window -t Resample asFitResample;

int $numJoints=2;
string $allDescendents[],$tempString[];
string $selJoints[]=`ls -sl -type joint`;
string $startJoint=$endJoint="none";
if (size($selJoints)==1)
	{
	string $asFitJointIKInfo[]=`asFitJointIKInfo $selJoints[0]`;
	if ($asFitJointIKInfo[1]!="")
		$startJoint=$asFitJointIKInfo[1];
	if ($asFitJointIKInfo[3]!="")
		$endJoint=$asFitJointIKInfo[3];
	}
if (size($selJoints)==2)
	{
	$allDescendents=`listRelatives -ad $selJoints[0]`;
	if (`stringArrayCount $selJoints[1] $allDescendents`)
		{
		$startJoint=$selJoints[0];
		$endJoint=$selJoints[1];
		}
	$allDescendents=`listRelatives -ad $selJoints[1]`;
	if (`stringArrayCount $selJoints[0] $allDescendents`)
		{
		$startJoint=$selJoints[1];
		$endJoint=$selJoints[0];
		}
	}
//Find current $numJoints
if (`objExists $startJoint` && `objExists $endJoint` )
	{
	string $countJoint=$endJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`listRelatives -p $countJoint`;
		$countJoint=$tempString[0];
		if ($countJoint=="" || $countJoint==$startJoint)
			break;
		$numJoints++;
		}
	}

columnLayout -adj 1;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "StartJoint:" -ed 0 -tx $startJoint asFitResampleStartJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleStartJointtextFieldGrp";
	setParent..;
rowLayout -nc 2;
	textFieldGrp -cw2 60 100 -l "EndJoint" -ed 0 -tx $endJoint asFitResampleEndJointtextFieldGrp;
	button -h 15 -l "pick" -c "asFitResamplePick asFitResampleEndJointtextFieldGrp";
	setParent..;
intFieldGrp -v1 $numJoints -cw2 60 50 -l "joints" asFitResampleNumJoints;
button -l "ReSample" -c asFitResampleJoints;
showWindow asFitResample;
}

global proc asFitResampleJoints ()
{
global string $gSelect;
setToolTo $gSelect;
string $sel[]=`ls -sl`;
string $tempString[],$joints[],$parentJoints[];
string $newJoint;
string $startJoint=`textFieldGrp -q -tx asFitResampleStartJointtextFieldGrp`;
string $endJoint=`textFieldGrp -q -tx asFitResampleEndJointtextFieldGrp`;
int $numJoints=`intFieldGrp -q -v1 asFitResampleNumJoints`;
$tempString=`ls -l $endJoint`;
tokenize $tempString[0] "|" $parentJoints;
int $reachedStart=0;
for ($i=0;$i<size($parentJoints);$i++)
	{
	if ($parentJoints[$i]==$startJoint)
		$reachedStart=1;
	if ($reachedStart)
		$joints[size($joints)]=$parentJoints[$i];	
	}
if (!`objExists $startJoint`)
	error ("startJoint :\""+$startJoint+"\" does not exists");
if (!`objExists $endJoint`)
	error ("endJoint :\""+$endJoint+"\" does not exists");
if ($numJoints<2)
	error "Can not ReSample to less than 2";
if (!`stringArrayCount $startJoint $joints`)
	error ("endJoint:\""+$endJoint+"\" is not a child of startJoint:\""+$startJoint+"\"");
if ($startJoint==$endJoint)
	error "StartJoint and EndJoint can not be the same";

select $startJoint $endJoint;
$tempString=`ikHandle -sol ikSplineSolver -scv false -pcv false`;
duplicate -n tempIKCurve $tempString[2];
delete $tempString[0] $tempString[2];
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f tempIKCurveShape.worldSpace[0] tempPointOnCurveInfo.inputCurve;
select tempIKCurve;refresh;

int $startJointLocks[]=`asUnLockAttrs $startJoint`;
int $endJointLocks[]=`asUnLockAttrs $endJoint`;

float $startJointFat=1;
float $startJointFatY=1;
float $startJointFatZ=1;
float $endJointFat=1;
float $endJointFatY=1;
float $endJointFatZ=1;
if (`attributeExists fat $startJoint`) $startJointFat=`getAttr ($startJoint+".fat")`;
if (`attributeExists fatY $startJoint`) $startJointFatY=`getAttr ($startJoint+".fatY")`;
if (`attributeExists fatZ $startJoint`) $startJointFatZ=`getAttr ($startJoint+".fatZ")`;
if (`attributeExists fat $endJoint`) $endJointFat=`getAttr ($endJoint+".fat")`;
if (`attributeExists fatY $endJoint`) $endJointFatY=`getAttr ($endJoint+".fatY")`;
if (`attributeExists fatZ $endJoint`) $endJointFatZ=`getAttr ($endJoint+".fatZ")`;

$tempString=`listRelatives -p $startJoint`;
string $startJointParent=$tempString[0];
if ($startJointParent!="")
	parent -w $startJoint;
parent -w $endJoint;
float $radius=`getAttr ($startJoint+".radius")`;
rename $endJoint tempRename;
if (`objExists $joints[1]`) delete $joints[1];
string $parent=$startJoint;
string $newJointName=$joints[0];
if ($joints[0]=="Root")
	{
	createNode -n Spine transform;
	$newJointName="Spine";
	}
for ($i=1;$i<$numJoints-1;$i++)
	{
	select -cl;
	$newJoint=`joint -n $newJointName -rad $radius`;
	setAttr tempPointOnCurveInfo.parameter ((1.0/($numJoints-1))*$i);
	$pos=`getAttr tempPointOnCurveInfo.position`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $newJoint;
	parent $newJoint $parent;
	$parent=$newJoint;
	asEnsureFitJointAttrs $newJoint;
	setAttr ($newJoint+".fat") ($startJointFat+(($i/($numJoints-1.0))*($endJointFat-$startJointFat)));
	setAttr ($newJoint+".fatY") ($startJointFatY+(($i/($numJoints-1.0))*($endJointFatY-$startJointFatY)));
	setAttr ($newJoint+".fatZ") ($startJointFatZ+(($i/($numJoints-1.0))*($endJointFatZ-$startJointFatZ)));
	asFitModeUpdateJoints $newJoint 0;
	refresh;
	}
if ($joints[0]=="Root" && `objExists |Spine`) delete |Spine;
if (`objExists $endJoint`)
	rename $endJoint ($endJoint+"_2");
rename tempRename $endJoint;
parent $endJoint $parent;
if ($startJointParent!="")
	parent $startJoint $startJointParent;

asReLockAttrs $startJoint $startJointLocks;
asReLockAttrs $endJoint $endJointLocks;

asFitModeUpdateJoints $endJoint 0;
delete tempIKCurve;
if (`checkBox -q -ex asLockCenterJoints`)
	if (`checkBox -q -v asLockCenterJoints`)
		asFitModeLockCenterJoints;

print ("// Joints Resampled\n");
catchQuiet (`select $sel`);
}

global proc int[] asUnLockAttrs (string $obj)
{
int $lockedAttrs[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		$lockedAttrs[size($lockedAttrs)]=`getAttr -l ($obj+"."+$trs[$y]+$xyz[$z])`;
		setAttr -l 0 ($obj+"."+$trs[$y]+$xyz[$z]);
		}
return $lockedAttrs;
}

global proc asReLockAttrs (string $obj, int $lockedAttrs[])
{
int $attrNr=0;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		setAttr -l $lockedAttrs[$attrNr] ($obj+"."+$trs[$y]+$xyz[$z]);
		$attrNr++;
		}
}

global proc asFitResamplePick (string $textFieldGrp)
{
string $selJoints[]=`ls -sl -type joint`;
if (!size($selJoints))
	error "No joint selected";
textFieldGrp -e -tx $selJoints[0] $textFieldGrp;
}

global proc asAddFitJointLabel ()
{
string $labelType=`optionMenu -q -v asLabelType`;
string $sel[]=`ls -sl -type joint`;
int $labelCode;
for ($i=0;$i<size($sel);$i++)
	{
	setAttr ($sel[$i]+".drawLabel") 1;
	$labelCode=`asLabelCodeLookup $labelType 1`;
	setAttr ($sel[$i]+".type") $labelCode;
	if ($labelCode==18)
		setAttr -type "string" ($sel[$i]+".otherType") $labelType;
	}
}

global proc asRemoveFitJointLabel ()
{
string $sel[]=`ls -sl -type joint`;
for ($i=0;$i<size($sel);$i++)
	setAttr ($sel[$i]+".drawLabel") 0;
}

global proc string asLabelCodeLookup (string $labelCode, int $labelToCode)
{
int $codes[]={0,1,2,4,18,10,12,15,16,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18};
string $labels[]={"None","Root","Hip","Foot","ToesEnd","Shoulder","Hand","PropA","PropB","PropC","Other","Chest","Mid","Toes","Heel","BigToe","PinkyToe","LegAim","QToes","Eye","Wheel","0","1","2","3"};

for ($i=0;$i<size($labels);$i++)
	{
	if ($labelToCode)
		if ($labels[$i]==$labelCode)
			return $codes[$i];
	if (!$labelToCode)
		if ($codes[$i]==$labelCode)
			return $labels[$i];
	}
return "";
}

global proc string asLabel (string $obj)
{
string $label;
if (size(`ls -ap $obj`)>1)
	error ("More than one object matches name: "+$obj+"\n");
if (!`objExists $obj`)
	return "AA";
if (!`attributeExists "type" $obj`)
	return "BB";
int $labelNum=`getAttr ($obj+".type")`;
if (!`getAttr ($obj+".drawLabel")`)
	return "";

$label=`asLabelCodeLookup $labelNum 0`;
if ($labelNum==18)
	{
	$label=`getAttr ($obj+".otherType")`;
	}

return $label;
}

global proc int asComponentToNr (string $component)
{
int $nr;
string $tempString[];
tokenize $component "[" $tempString;
tokenize $tempString[1] "]" $tempString;
$nr=$tempString[0];
return $nr;
}

global proc asAddFitJointAttribute ()
{
string $attr=`optionMenu -q -v asAttributeType`;
string $sel[]=`ls -sl`;
float $dv=1;
string $meshObject,$curveObject;
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]` && `objectType $sel[$i]`!="joint")
		continue;
	if (`attributeExists $attr $sel[$i]` && `objectType $sel[$i]`=="joint")
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}
	if ($attr=="twist/bendy" && `attributeExists twistJoints $sel[$i]`)
		{warning ("Skipping "+$sel[$i]+", it has the attribute already added!\n");continue;}

	if ($attr=="twist/bendy")
		{
		if (`attributeExists inbetweenJoints $sel[$i]`) error "\"inbetweenJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "twistJoints" -at long -min 0 -max 10 -dv 2 $sel[$i];
		addAttr -k 1 -ln "bendyJoints" -at bool -dv 0 $sel[$i];
		//Update geo, if in FitMode
		global int $asFitModeScriptJobNr1;
		if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
			if (`checkBox -q -ex asVisGeo`)
				if (`checkBox -q -v asVisGeo`)
					asFitModeUpdateAllGeometry;
		}
	else if ($attr=="inbetween")
		{
		if (`attributeExists twistJoints $sel[$i]`) error "\"twistJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		if (`attributeExists bendyJoints $sel[$i]`) error "\"bendyJoints\" attribute already exists, can not mix `Twist` and `Inbetween`";
		addAttr -k 1 -ln "inbetweenJoints" -at long -min 0 -dv 2 $sel[$i]; 
		addAttr -k 1 -ln "unTwister" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="global")
		{
		addAttr -k 1 -ln $attr -at double -min 0 -max 10 -dv 0 $sel[$i];
		addAttr -k 1 -ln "globalTranslate" -at bool -dv 0 $sel[$i];
		}
	else if ($attr=="worldOrient")
		addAttr -k 1 -ln $attr -at "enum" -en "xUp:yUp:zUp:xDown:yDown:zDown:" -dv 0 $sel[$i];
	else if ($attr=="ikLocal")
		addAttr -k 1 -ln $attr -at "enum" -en "addCtrl:nonZero:localOrient:" -dv 0 $sel[$i];
	else if ($attr=="geoAttach")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			$tempString=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="mesh")
					$meshObject=$sel[$y];
			}
		if (size($sel)<2 || $meshObject=="")
			error "Select both FitJoint AND Geometry to attach to";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $meshObject ":" "__"` $sel[$i];
		addAttr -k 1 -ln ($attr+"Mode") -at "enum" -en "point:orient:parent" -dv 2 $sel[$i];
		select $sel[$i];
		}
	else if ($attr=="aimAt")
		{
		for ($y=0;$y<size($sel);$y++)
			if (`objectType $sel[$y]`!="joint")
				error "Only joints must be selected.";
		if ($i==1)
			{
			addAttr -k 1 -ln $attr -at "enum" -en $sel[0] $sel[1];
			addAttr -k 1 -ln "aimAxis" -at "enum" -en "x:y:z:" -dv 0 $sel[1];
			addAttr -k 1 -ln "aimUpAxis" -at "enum" -en "x:y:z:" -dv 1 $sel[1];
			}
		select $sel[$i];
		}
	else if ($attr=="curveGuide")
		{
		for ($y=0;$y<size($sel);$y++)
			{
			string $tempString[]=`listRelatives -s $sel[$y]`;
			if ($tempString[0]!="")
				if (`objectType $tempString[0]`=="nurbsCurve")
					$curveObject=$sel[$y];
			}
		if (size($sel)<2 || $curveObject=="")
			error "Select both FitJoint AND Curve";
		addAttr -k 1 -ln $attr -at "enum" -en `substituteAllString $curveObject ":" "__"` $sel[$i];
		addAttr -k 1 -ln ($attr+"Mode") -at "enum" -en "point:aim" -dv 1 $sel[$i];
		select $sel[$i];
		}
	else
		addAttr -k 1 -ln $attr -at bool -dv $dv $sel[$i];
	}
}

global proc asRemoveFitJointAttribute ()
{
string $sel[]=`ls -sl -type joint`;
string $attr=`optionMenu -q -v asAttributeType`;
for ($i=0;$i<size($sel);$i++)
	{
	if (`attributeExists $attr $sel[$i]`)
		deleteAttr ($sel[$i]+"."+$attr);
	if ($attr=="twist/bendy" && `attributeExists "twistJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".twistJoints");
	if ($attr=="twist/bendy" && `attributeExists "bendyJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".bendyJoints");
	if ($attr=="inbetween" && `attributeExists "inbetweenJoints" $sel[$i]`)
		deleteAttr ($sel[$i]+".inbetweenJoints");
	if ($attr=="inbetween" && `attributeExists "unTwister" $sel[$i]`)
		deleteAttr ($sel[$i]+".unTwister");
	if ($attr=="geoAttach" && `attributeExists "geoAttachMode" $sel[$i]`)
		deleteAttr ($sel[$i]+".geoAttachMode");
	if ($attr=="global" && `attributeExists "globalTranslate" $sel[$i]`)
		deleteAttr ($sel[$i]+".globalTranslate");
	if ($attr=="curveGuide" && `attributeExists "curveGuideMode" $sel[$i]`)
		deleteAttr ($sel[$i]+".curveGuideMode");
	}
}

global proc asFitDisplayJointAxis  (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $fitJoints[$i]`;
	string $child=$tempString[0];
	if ($child=="")
		continue;
	setAttr ($fitJoints[$i]+".displayLocalAxis") $onOff;
	}
if (`attributeExists visJointAxis FitSkeleton`)
	setAttr FitSkeleton.visJointAxis $onOff;
}

global proc asFitDisplayPoleVector (int $onOff)
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
float $ikLenght;
float $pos1[],$pos2[],$pos3[];
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKNumCtrls;
string $tempString[],$asFitJointIKInfo[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
if ($onOff==0)
	{
	if (`objExists FitSkeletonPoleVectors`) delete FitSkeletonPoleVectors;
	if (`objExists FitSkeletonVisualizers`)
		{
		$tempString=`listRelatives -c FitSkeletonVisualizers`;
		if ($tempString[0]=="")
			delete FitSkeletonVisualizers;
		if (`attributeExists visPoleVector FitSkeleton`)
			setAttr FitSkeleton.visPoleVector 0;
		}
	return;
	}

for ($i=0;$i<size($fitJoints);$i++)
	{
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	if (!size($asFitJointIKInfo))
		continue;

	$ik=$asFitJointIKInfo[0];
	$IKParentJoint=$asFitJointIKInfo[1];
	$IKMiddleJoint=$asFitJointIKInfo[2];
	$IKChildJoint=$asFitJointIKInfo[3];
	$IKSolver=$asFitJointIKInfo[4];
	$IKNumCtrls=$asFitJointIKInfo[5];

	if ($fitJoints[$i]!=$IKParentJoint)
		continue;
	if ($IKSolver!="ikRPsolver")
		continue;

	if (!`objExists FitSkeletonVisualizers`)
		createNode -n FitSkeletonVisualizers transform;
	if (!`objExists FitSkeletonPoleVectors`)
		createNode -n FitSkeletonPoleVectors -p FitSkeletonVisualizers transform;
	asFitModeEnsureShaders;
	asEnsureFitSkeletonAttributes;
	setAttr FitSkeleton.visPoleVector 1;

	//Analyze $ikLenght
	$ikLenght=0;
	$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
	for ($y=size($tempString)-1;$y>-1;$y--)
		{
		$ikLenght+=`getAttr ($tempString[$y]+".tx")`;
		if ($tempString[$y]==$IKChildJoint)
			break;
		}
	$ikLenght=abs($ikLenght);

	createNode -n tempPoleVecPlacer1 transform;
	createNode -n tempPoleVecPlacer2 -p tempPoleVecPlacer1 transform;
	createNode -n tempPoleVecPlacer3 -p tempPoleVecPlacer2 transform;
	$tempString=`pointConstraint $IKParentJoint $IKChildJoint tempPoleVecPlacer1`;
	setAttr ($tempString[0]+"."+$IKParentJoint+"W0") `getAttr ($IKChildJoint+".tx")`;
	setAttr ($tempString[0]+"."+$IKChildJoint+"W1") `getAttr ($IKMiddleJoint+".tx")`;
	aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $IKParentJoint $IKMiddleJoint tempPoleVecPlacer2;
	setAttr tempPoleVecPlacer3.tx $ikLenght;

	$pos1=`xform -q -ws -t $IKParentJoint`;
	$pos2=`xform -q -ws -t $IKChildJoint`;
	$pos3=`xform -q -ws -t tempPoleVecPlacer3`;
	delete tempPoleVecPlacer1;
	if (`objExists ("VisualizePoleVector_"+$ik)`) delete ("VisualizePoleVector_"+$ik);
	polyCreateFacet -n ("VisualizePoleVector_"+$ik) -ch 0 -tx 1 -s 1 -p $pos1[0] $pos1[1] $pos1[2] -p $pos2[0] $pos2[1] $pos2[2] -p $pos3[0] $pos3[1] $pos3[2];
	parent ("VisualizePoleVector_"+$ik) FitSkeletonPoleVectors;
	sets -e -forceElement asRedSG ("VisualizePoleVector_"+$ik);
	setAttr ("VisualizePoleVector_"+$ik+".overrideEnabled") 1;
	setAttr ("VisualizePoleVector_"+$ik+".overrideDisplayType") 2;
	}
catchQuiet (`select $sel`);
}

global proc asFitDisplayJointOrient (int $onOff)
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientX");
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientY");
	setAttr -k $onOff ($fitJoints[$i]+".jointOrientZ");
	}
if (`attributeExists visJointOrient FitSkeleton`)
	setAttr FitSkeleton.visJointOrient $onOff;
}

global proc asFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr3;
string $sel[]=`ls -sl`;
int $onOff=1;
if ($asFitModeScriptJobNr1 && `scriptJob -ex $asFitModeScriptJobNr1`)
	$onOff=0;
//asByPassSDK $onOff;
select -cl;
if ($onOff)
	{
	asFitModeManualUpdate;
	$asFitModeScriptJobNr1=`scriptJob -cu 1 -killWithScene -e SelectionChanged asFitModeSelectionChanged`;
	if (`objExists FitSkeleton`)
		$asFitModeScriptJobNr3=`scriptJob -cu 1 -killWithScene -ac FitSkeleton.s asFitModeUpdateScale`;
	headsUpDisplay -s 2 -b 0 -bs "medium" -l "FitMode" -lfs "large" HUDFitMode;
	print "// Entered FitMode\n";
	}
else
	{
	if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr1;
		$asFitModeScriptJobNr1=0;
		}
	if (`scriptJob -ex $asFitModeScriptJobNr3`  && $asFitModeScriptJobNr3!=0)
		{
		scriptJob -kill $asFitModeScriptJobNr3;
		$asFitModeScriptJobNr3=0;
		}
	asFitModeSelectionChanged;
	if (`headsUpDisplay -ex HUDFitMode`)
		headsUpDisplay -rem HUDFitMode;
	print "// Exited FitMode\n";
	}
select $sel;
}

global proc asToggleFitAdvancedSkeleton  ()
{
int $fitSkeletonVis=`getAttr FitSkeleton.visibility`;
setAttr -l 0 FitSkeleton.visibility;
setAttr -l 1 FitSkeleton.visibility (!$fitSkeletonVis);
setAttr MotionSystem.visibility $fitSkeletonVis;
setAttr DeformationSystem.visibility $fitSkeletonVis;
if (!$fitSkeletonVis)
	asDsToFitSkeleton;
asUpdateButtonEnables;
}

global proc asDsToFitSkeleton ()
{
int $attrNr;
string $tempString[],$drivingSystems[],$userAttrs[],$sdks[],$sortedSdks[];
string $addAttrCmd;

if (!`objExists DrivingSystem`)
	return;

if (`attributeExists drivingSystem FitSkeleton`)
	deleteAttr FitSkeleton.drivingSystem;
addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;

$userAttrs=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	if (`gmatch $userAttrs[$i] "drivingSystem_*"`)
		deleteAttr ("FitSkeleton."+$userAttrs[$i]);

$drivingSystems=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	addAttr -k 0 -ln ("drivingSystem_"+$drivingSystems[$i]) -at bool -dv true -multi FitSkeleton;
	$attrNr=0;
	$userAttrs=`listAttr -ud -s -k $drivingSystems[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$sdks=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$userAttrs[$y])`;
		//sort translate before rotate
		clear $sortedSdks;
		for ($z=0;$z<size($sdks);$z++)
			if (`gmatch $sdks[$z] "*_translate*"`)
				$sortedSdks[size($sortedSdks)]=$sdks[$z];
		for ($z=0;$z<size($sdks);$z++)
			if (`gmatch $sdks[$z] "*_rotate*"`)
				$sortedSdks[size($sortedSdks)]=$sdks[$z];
		for ($z=0;$z<size($sdks);$z++)
			if (!`stringArrayCount $sdks[$z] $sortedSdks`)
				$sortedSdks[size($sortedSdks)]=$sdks[$z];
		for ($z=0;$z<size($sortedSdks);$z++)
			{
			if (!`attributeExists drivingSystemOut $sortedSdks[$z]`) addAttr -k 0 -ln drivingSystemOut -at message $sortedSdks[$z];
			if (`attributeExists $userAttrs[$y] $sortedSdks[$z]`)
				deleteAttr ($sortedSdks[$z]+"."+$userAttrs[$y]);
			$addAttrCmd="addAttr -k 0 -ln "+$userAttrs[$y]+" -at \"float\" ";
			if (`addAttr -q -hasMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			if (`addAttr -q -hasSoftMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($drivingSystems[$i]+"."+$userAttrs[$y])`+" ";
			$addAttrCmd+=$sortedSdks[$z];
			eval ($addAttrCmd);

			connectAttr -f ("FitSkeleton.drivingSystem_"+$drivingSystems[$i]+"["+$attrNr+"]") ($sortedSdks[$z]+"."+$userAttrs[$y]);
			$tempString=`listConnections ($sortedSdks[$z]+".drivingSystemOut")`;
			if ($tempString[0]!="FitSkeleton")
				connectAttr -na ($sortedSdks[$z]+".drivingSystemOut") FitSkeleton.drivingSystem;
			$attrNr++;
			}
		}
	}
}

global proc string asUniqueName (string $obj)
{
string $newName=$obj;
string $tempString[]=`ls $obj`;
if (size($tempString)>1)
	for ($i=1;$i<99;$i++)
		if (!`objExists ($obj+$i)`)
			{
			$newName=$obj+$i;
			rename $tempString[0] $newName;
			break;
			}
return $newName;
}

global proc asFitModeManualUpdate ()
{
int $labelClash;
string $label,$newLabel;
string $labelArray[];
string $sel[]=`ls -sl`;
//asByPassSDK 1;
if (!`objExists FitSkeleton`)
	return;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	$fitJoints[$i]=`asUniqueName $fitJoints[$i]`;

//Also ensure uniqueLabel
for ($i=0;$i<size($fitJoints);$i++)
	{
	$label=`asLabel $fitJoints[$i]`;
	if ($label=="")
		continue;
	$labelArray[size($labelArray)]=$label;
	}

for ($i=0;$i<size($fitJoints);$i++)
	{
	$label=`asLabel $fitJoints[$i]`;

	if (!`gmatch $label "*Shoulder*"` && !`gmatch $label "*Hip*"` && !`gmatch $label "*Root*"` && !`gmatch $label "0*"`)
		continue;
	$labelClash=0;

	if (`stringArrayCount $label $labelArray`>1)
		{
		$labelClash=1;
		for ($a=1;$a<99;$a++)
			{
			if (`gmatch $label "0*"`)
				$newLabel=$label+`asNrToLetter $a`;
			else
				$newLabel=$label+$a;
			if (!`stringArrayCount $newLabel $labelArray`)
				break;
			}
		}

	if ($labelClash)
		{
		setAttr ($fitJoints[$i]+".type") 18;
		setAttr -type "string" ($fitJoints[$i]+".otherType") $newLabel;
		$labelArray[size($labelArray)]=$newLabel;
		}
	}

asFitModeUpdateScale;

for ($i=0;$i<size($fitJoints);$i++)
	{
	asFitModeUpdateJoints $fitJoints[$i] 0;
	asFitModeUpdateFat $fitJoints[$i];
	}
catchQuiet (`select $sel`);
//asByPassSDK 0;
print "// Updated Orientations\n";
}

global proc asFitModeSelectionChanged ()
{
global int $asFitModeScriptJobNr2[];
global string $asFitModeOffRLA[];
for ($i=0;$i<size($asFitModeOffRLA);$i++)
	if (`objExists $asFitModeOffRLA[$i]`)
		setAttr ($asFitModeOffRLA[$i]+".displayLocalAxis") 0;

clear $asFitModeOffRLA;
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
string $sel[]=`ls -sl -type joint`;
string $tempString[];
string $rlaParent,$rlaChild;
float $pos[];
string $aimParents;
for ($i=0;$i<size($sel);$i++)
	{
	//Parent
//	if (size(`ls -ap $sel[$i]`)>1)
//		continue;
	$rlaParent=`asRlaParent $sel[$i]`;
	if (!`objExists $rlaParent`)
		continue;
//	string $parentOtherChildren[]=`listRelatives -c -type joint $rlaParent`;
//	$parentOtherChildren=`stringArrayRemove {$sel[$i]} $parentOtherChildren`;
//	if (size($parentOtherChildren) && $sel[$i]!="BackA")
//		continue;

	if (!`getAttr ($rlaParent+".displayLocalAxis")`)
		$asFitModeOffRLA[$i]=$rlaParent;
	setAttr ($rlaParent+".displayLocalAxis") 1;
	if ($aimParents!="")
		$aimParents+="@";
	$aimParents+=$sel[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	//Child
	$rlaChild=`asRlaChild $sel[$i]`;
//	if (size(`ls -ap $rlaChild`)!=1)
//		continue;
	$aimParents+="@"+$rlaChild;
	if (`attributeExists fatYabs $sel[$i]`)
		$asFitModeScriptJobNr2[2]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatYabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists fatZabs $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".fatZabs") ("asFitModeUpdateFat \""+$sel[$i]+"\"")`;
	if (`attributeExists twistJoints $sel[$i]`)
		$asFitModeScriptJobNr2[3]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".twistJoints") ("asFitModeUpdateAllGeometry")`;

	}
if ($aimParents!="")
	{
	$asFitModeScriptJobNr2[0]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".translate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	$asFitModeScriptJobNr2[1]=`scriptJob -cu 1 -killWithScene -ac ($sel[0]+".rotate") ("asFitModeUpdateJoints \""+$aimParents+"\" 0")`;
	}
}

global proc asFitModeLockCenterJoints ()
{
string $sel[]=`ls -sl`;
if (!`objExists FitSkeleton`)
	return;
int $lock=`getAttr FitSkeleton.lockCenterJoints`;
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
float $pos[],$pos2[];
string $fitSkeletonJoints[]=`listRelatives -f -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitSkeletonJoints);$i++)
	{
	$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
	if ($lock)
		if ($pos[0]<-$centerTolerance || $pos[0]>$centerTolerance)
			continue;

	$tempString=`listRelatives -p -f $fitSkeletonJoints[$i]`;
	$parent=$tempString[0];
	createNode -n transformSampler -p $parent transform;

	setAttr -type float3 transformSampler.t 1 0 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tx");

	setAttr -type float3 transformSampler.t 0 1 0;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".ty");

	setAttr -type float3 transformSampler.t 0 0 1;
	$pos2=`xform -q -ws -t transformSampler`;
	if ($pos2[0]>0.5 || $pos2[0]<-0.5)
		setAttr -l $lock ($fitSkeletonJoints[$i]+".tz");

	delete transformSampler;
	setAttr -l $lock ($fitSkeletonJoints[$i]+".rx");
	setAttr -l $lock ($fitSkeletonJoints[$i]+".ry");
	}
select -ne $sel;
}

global proc asPlacementCopy ()
{
global string $gMove;
setToolTo $gMove;
float $pos[]=`manipMoveContext -q -position "Move"`;
button -e -en 1 -ann ($pos[0]+" "+$pos[1]+" "+$pos[2]) asPlacementPasteButton;
}

global proc asPlacementPaste ()
{
int $editPivotMode=`manipMoveContext -q -editPivotMode Move`;
string $sel[]=`ls -sl`;
string $ann=`button -q -ann asPlacementPasteButton`;
string $buffer[];
tokenize $ann $buffer;

for ($i=0;$i<size($sel);$i++)
	if ($editPivotMode)
		move -a $buffer[0] $buffer[1] $buffer[2] ($sel[$i]+".scalePivot") ($sel[$i]+".rotatePivot");
	else
		move -a $buffer[0] $buffer[1] $buffer[2] $sel[$i];
}

global proc asFitModeUpdateFat (string $joint)
{
string $rlaParent=`asRlaParent $joint`;
//update flare
if (`objExists ($rlaParent+"GapBlenderA")`)
	if (`attributeExists dummyInput1 ($rlaParent+"GapBlenderA")`)
		{
		setAttr ($rlaParent+"GapBlenderA"+".input[1]") `getAttr ($rlaParent+"GapBlenderA"+".dummyInput1")`;
		setAttr ($rlaParent+"GapBlenderB"+".input[1]") `getAttr ($rlaParent+"GapBlenderB"+".dummyInput1")`;
		}
}

global proc asFitModeUpdateAllGeometry ()
{
checkBox -e -v 0 asVisGeo;
asFitGeometry;
checkBox -e -v 1 asVisGeo;
asFitGeometry;
}

global proc asFitModeUpdateScale ()
{
if (!`objExists FitSkeleton`)
	return;
int $foundGeneratedTransforms;
int $lockTxs[],$lockTys[],$lockTzs[];
float $fitSkeletonScale[3]=`getAttr FitSkeleton.s`;
float $pos[];
string $sel[]=`ls -sl`;
string $fitJointsParent[],$tempString[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
string $fitSkeletonChildren[]=`listRelatives -ad -type transform FitSkeleton`;
string $generatedTransform;

for ($i=0;$i<size($fitSkeletonChildren);$i++)
	if (`objectType $fitSkeletonChildren[$i]`=="transform" && `gmatch $fitSkeletonChildren[$i] "transform*"`)
		{
		$foundGeneratedTransforms=1;
		break;
		}


//if (($fitSkeletonScale[0]==1 && $fitSkeletonScale[1]==1 && $fitSkeletonScale[2]==1) && !$foundGeneratedTransforms)
//	return;
//removed, as we also want to find any non-1 scaled joints

setAttr -type float3 FitSkeleton.s 1 1 1;
for ($i=0;$i<size($fitJoints);$i++)
	{
	$lockTxs[$i]=`getAttr -l ($fitJoints[$i]+".tx")`;$lockTys[$i]=`getAttr -l ($fitJoints[$i]+".ty")`;$lockTzs[$i]=`getAttr -l ($fitJoints[$i]+".tz")`;
	setAttr -l 0 ($fitJoints[$i]+".tx");setAttr -l 0 ($fitJoints[$i]+".ty");setAttr -l 0 ($fitJoints[$i]+".tz");
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$generatedTransform="";
	if ($tempString[0]!="" && `objectType $tempString[0]`=="transform" && $tempString[0]!="FitSkeleton")
		{
		$generatedTransform=$tempString[0];
		$tempString=`listRelatives -p $generatedTransform`;
		}
	$fitJointsParent[$i]=$tempString[0];
	parent -w $fitJoints[$i];
	if ($generatedTransform!="")
		delete $generatedTransform;
	$tempString=`listRelatives -p $fitJoints[$i]`;
	$generatedTransform=$tempString[0];
	if ($generatedTransform!="")//generated Xform
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		setAttr -type float3 ($generatedTransform+".s") 1 1 1;
		parent -w $fitJoints[$i];
		xform -ws -t $pos[0] $pos[1] $pos[2] $fitJoints[$i];
		delete $generatedTransform;
		}
	}
for ($i=0;$i<size($fitJoints);$i++)
	{
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	xform -ws -t ($pos[0]*$fitSkeletonScale[0]) ($pos[1]*$fitSkeletonScale[1]) ($pos[2]*$fitSkeletonScale[2]) $fitJoints[$i];
	setAttr ($fitJoints[$i]+".s") -type float3 1 1 1;
	setAttr ($fitJoints[$i]+".inverseScale") -type float3 1 1 1;
	if (`attributeExists fat $fitJoints[$i]`) setAttr ($fitJoints[$i]+".fat") (`getAttr ($fitJoints[$i]+".fat")`*$fitSkeletonScale[1]);
	}
for ($i=0;$i<size($fitJoints);$i++)
	if (`objExists $fitJointsParent[$i]`)
		parent $fitJoints[$i] $fitJointsParent[$i];
for ($i=0;$i<size($fitJoints);$i++)
	{
	setAttr -l $lockTxs[$i] ($fitJoints[$i]+".tx");setAttr -l $lockTys[$i] ($fitJoints[$i]+".ty");setAttr -l $lockTzs[$i] ($fitJoints[$i]+".tz");
	}

if ($fitSkeletonScale[0]==1 && $fitSkeletonScale[1]==1 && $fitSkeletonScale[2]==1)
	return;

scale -r -p 0 0 0 $fitSkeletonScale[1] $fitSkeletonScale[1] $fitSkeletonScale[1] FitSkeletonShape.cv[0:7] ;
//asFitModeManualUpdate; is cycle ?
select $sel;
}

global proc asFitModeUpdateJoints (string $jointsString, int $recursive)
{
int $upV[3]={0,1,0};
int $childNr,$newChildNr,$reachedKneeJoint,$flipOrient,$aimAxis,$aimUpAxis,$x,$y,$z,$xUp,$yUp,$zUp;
int $editPivotMode=`manipMoveContext -q -editPivotMode Move`;
float $scale=1;
float $pos[],$pos2[];
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[],$joints[],$jointAllDescendents[],$otherJointsInIK[];
string $connectCmds[],$rlaParentChildren[],$newRlaParentChildren[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $generatedTransform1,$generatedTransform2,$IKParentJoint,$IKChildJoint,$jointLongName,$worldOrient,$upVecObj;
string $rlaParent,$rlaParentLabel,$rlaChild,$rlaParentRlaChild,$label,$tempLabel,$joint,$aimAt;
tokenize $jointsString "@" $joints;
for ($joint in $joints)
	{
	if (size(`ls -ap $joint`)!=1)
		continue;
	$label=`asLabel $joint`;
	$rlaParent=`asRlaParent $joint`;
	$rlaParent=`asUniqueName $rlaParent`;
	$rlaParentLabel=`asLabel $rlaParent`;
	string $rlaChild=`asRlaChild $joint`;
	$rlaChild=`asUniqueName $rlaChild`;

	int $childNr=0;
	clear $rlaParentChildren;
	if ($rlaParent!="")
		{
		$rlaParentRlaChild=`asRlaChild $rlaParent`;
		$rlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		if (size($rlaParentChildren)>1)
			for ($i=0;$i<size($rlaParentChildren);$i++)
				{
				if ($joint==$rlaParentChildren[$i])
					$childNr=$i;
				}
		}
	if (!`objExists $rlaParent`)
		continue;
	if (`attributeExists freeOrient $rlaParent`)
		continue;
	if (`asRlaChild $rlaParent`!=$joint && $rlaParent!="Cup")
		continue;
	$worldOrient="";
	if (`attributeExists worldOrient $rlaParent`)
		$worldOrient=`getAttr ($rlaParent+".worldOrient")`;
	$flipOrient=0;
	if (`attributeExists flipOrient $joint`)
		if (`getAttr ($joint+".flipOrient")`)
			$flipOrient=!$flipOrient;
	string $rlaParentParent=`asRlaParent $rlaParent`;
	clear $otherJointsInIK;
	$tempString=`ls -l $joint`;
	$jointLongName=$tempString[0];
	$jointAllDescendents=`listRelatives -allDescendents -type joint $joint`;
	$jointAllDescendents[size($jointAllDescendents)]=$joint;
	string $parentOtherChildren[]=`listRelatives -c $rlaParent`;
	$parentOtherChildren=`stringArrayRemove {$joint} $parentOtherChildren`;
	int $center=0;
	$pos=`xform -q -ws -t $joint`;
	if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;

	//IK-plane ($flip)
	tokenize $jointLongName "|" $tempString;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $tempString[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$tempString[$i];
		if (`attributeExists flipOrient $tempString[$i]`)
			if (`getAttr ($tempString[$i]+".flipOrient")`)
				$flipOrient=!$flipOrient;
		$tempLabel=`asLabel $tempString[$i]`;
		if (`gmatch $tempLabel "*Shoulder*"` || `gmatch $tempLabel "*Hip*"`)
			{
			$IKParentJoint=$tempString[$i];
			break;
			}
		}
	for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
		{
		if (!$recursive)
			if (!`stringArrayCount $jointAllDescendents[$i] $joints`)
				$otherJointsInIK[size($otherJointsInIK)]=$jointAllDescendents[$i];
		$tempLabel=`asLabel $jointAllDescendents[$i]`;
		if (`gmatch $tempLabel "*Hand*"` || `gmatch $tempLabel "*Foot*"`)
			{$IKChildJoint=$jointAllDescendents[$i];break;}
		}

	int $lockTX=`getAttr -l ($joint+".tx")`;int $lockTY=`getAttr -l ($joint+".ty")`;int $lockTZ=`getAttr -l ($joint+".tz")`;
	int $lockRX=`getAttr -l ($joint+".rx")`;int $lockRY=`getAttr -l ($joint+".ry")`;int $lockRZ=`getAttr -l ($joint+".rz")`;
	int $lockPTX=`getAttr -l ($rlaParent+".tx")`;int $lockPTY=`getAttr -l ($rlaParent+".ty")`;int $lockPTZ=`getAttr -l ($rlaParent+".tz")`;
	int $lockPRX=`getAttr -l ($rlaParent+".rx")`;int $lockPRY=`getAttr -l ($rlaParent+".ry")`;int $lockPRZ=`getAttr -l ($rlaParent+".rz")`;
	setAttr -l 0 ($joint+".tx");setAttr -l 0 ($joint+".ty");setAttr -l 0 ($joint+".tz");
	setAttr -l 0 ($joint+".rx");setAttr -l 0 ($joint+".ry");setAttr -l 0 ($joint+".rz");
	setAttr -l 0 ($rlaParent+".tx");setAttr -l 0 ($rlaParent+".ty");setAttr -l 0 ($rlaParent+".tz");
	setAttr -l 0 ($rlaParent+".rx");setAttr -l 0 ($rlaParent+".ry");setAttr -l 0 ($rlaParent+".rz");

	if (size($parentOtherChildren))
		{
		createNode -n otherChildrenPlaceHolder -p $rlaParent transform;
		parent -w otherChildrenPlaceHolder;
		}
	for ($i=0;$i<size($parentOtherChildren);$i++)
		{
		$tempString=`parent $parentOtherChildren[$i] otherChildrenPlaceHolder`;
		$parentOtherChildren[$i]=$tempString[0];
		}
		
	$tempString=`parent -w $joint`;
	$joint=$tempString[0];
	$tempString=`listRelatives -p $joint`;
	if (size($tempString))
		$generatedTransform1=$tempString[0];

	//remove any `rotateAxis`
	setAttr ($rlaParent+".rotateAxis") -type float3 0 0 0;

	//disconnect connections
	clear $connectCmds;
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$tempString=`listConnections -p 1 ($rlaParent+"."+$trs[$y]+$xyz[$z])`;
			if ($tempString[0]!="")
				{
				$connectCmds[size($connectCmds)]="connectAttr -f "+$tempString[0]+" "+$rlaParent+"."+$trs[$y]+$xyz[$z]+";";
				disconnectAttr $tempString[0] ($rlaParent+"."+$trs[$y]+$xyz[$z]);
				}
			}

	if ($center && $joint==$rlaParentRlaChild) // Center
		{
		$upV={0,0,1}; if ($flipOrient) $upV={0,0,-1};
		$tempString=`aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "vector" -worldUpVector 1 0 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	if (($IKParentJoint=="" || $IKChildJoint=="") && !$center) // Non-IK (side)
		{
		$upV={0,1,0}; // if ($flipOrient) $upV={0,-1,0}; These are free oriented, so no flip
		$upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0] $upVecObj;
		}

	if (($IKParentJoint!="" && $IKChildJoint!="") && !$center) // IK
		{
		$upV={0,1,0}; if ($flipOrient) $upV={0,-1,0};
		$tempLabel=`asLabel $IKParentJoint`;
		if (`gmatch $tempLabel "*Hip*"`)
			$upV={0,-1,0};
			$upVecObj=`createNode joint`;
		parent -r $upVecObj $rlaParent;
		setAttr ($upVecObj+".translate") 0 3 0;
		parent -w $upVecObj;
		$tempString=`listRelatives -p $upVecObj`;
		if (size($tempString))
			$generatedTransform2=$tempString[0];
		pointConstraint $IKParentJoint $IKChildJoint $upVecObj;
		if ($rlaParent==$IKParentJoint)
			{
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "object" -worldUpObject $upVecObj $joint $rlaParent`;
			//All Legs should have Y forwards, even `reverse-legs`.
			createNode -n tempTransform -p $rlaParent transform;
			setAttr tempTransform.ty 1;
			$pos=`xform -q -ws -t $rlaParent`;
			$pos2=`xform -q -ws -t tempTransform`;
			delete tempTransform;
			if ($pos2[2]<$pos[2])
				setAttr ($tempString[0]+".upVectorY") (`getAttr ($tempString[0]+".upVectorY")`*-1);
			}
		else
			{
			delete `orientConstraint $IKParentJoint $upVecObj`;
			$tempString=`aimConstraint -aimVector 1 0 0 -upVector $upV[0] $upV[1] $upV[2] -worldUpType "objectrotation" -worldUpVector $upV[0] $upV[1] $upV[2] -worldUpObject $upVecObj $joint $rlaParent`;
			}
		delete $tempString[0];
		delete $upVecObj;
		}
	else
		clear $otherJointsInIK;

	//Special case, $worldOrient
	if ($worldOrient!="" && `objExists $rlaParentParent`)
		{
		$upVecObj=$rlaParentParent;
		$upVecObj=`createNode -n tempUpVector -p $joint transform`;
		parent -w $upVecObj;
		move -r -ws 0 1 0 $upVecObj;
		float $upVec=1;
		parent $upVecObj $rlaParentParent;
/* was re-introduced in 5.242 to improve on twisted skinCage, but caused reversed Roll. re-removed in 5.321
		//Could be `reverse-knee`
		if (!`attributeExists reverseKnee $rlaParent`)
			addAttr -k 0 -ln reverseKnee -at bool -dv 0 $rlaParent;
		if (`getAttr ($upVecObj+".ty")`<0)
			{
			$upVec=-1;
			setAttr ($rlaParent+".reverseKnee") 1;
			}
*/
		createNode -n tempAimAt -p $rlaParent transform;
		parent -w tempAimAt;
		move -r -ws 0 -1 0 tempAimAt;
		if ($worldOrient==0) $tempString=`aimConstraint -aimVector -1 0 0 -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==1) $tempString=`aimConstraint -aimVector 0 -1 0 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==2) $tempString=`aimConstraint -aimVector 0 0 -1 -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==3) $tempString=`aimConstraint -aimVector 1 0 0  -upVector 0 $upVec 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==4) $tempString=`aimConstraint -aimVector 0 1 0  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;
		if ($worldOrient==5) $tempString=`aimConstraint -aimVector 0 0 1  -upVector $upVec 0 0 -worldUpType "object" -worldUpObject $upVecObj tempAimAt $rlaParent`;

		delete $tempString[0] $upVecObj tempAimAt;
		}

	//Special case, Scapula
	if (`gmatch $rlaParent "Scapula*"` && $IKParentJoint!="")
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, LegAim
	if (`gmatch $rlaParentLabel "LegAim*"`)
		{
		$upVecObj=$IKParentJoint;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Cup
	if ($rlaParent=="Cup" && `objExists RingFinger1` && `objExists MiddleFinger1`)
		{
		$upVecObj=`asRlaParent $rlaParent`;
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $upVecObj RingFinger1 MiddleFinger1 $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Eyes
	if (`gmatch $rlaParent "Eye*"`)
		{
		$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 -1 0 -worldUpType "vector" -worldUpVector 0 1 0 $joint $rlaParent`;
		delete $tempString[0];
		}
	//Special case, Root with no centered child
	if ($rlaParent=="Root" && !$center)
		{
		setAttr -type float3 ($rlaParent+".rotate") 0 0 0;
		setAttr -type float3 ($rlaParent+".jointOrient") 90 0 90;
		}
	//Special case, AimAt
	if (`attributeExists aimAt $rlaParent`)
		{
		$aimAt=`getAttr -asString($rlaParent+".aimAt")`;
		$aimAxis=`getAttr ($rlaParent+".aimAxis")`;
		$aimUpAxis=`getAttr ($rlaParent+".aimUpAxis")`;

		if ($aimAxis==0) {$x=1;$y=0;$z=0;}
		if ($aimAxis==1) {$x=0;$y=1;$z=0;}
		if ($aimAxis==2) {$x=0;$y=0;$z=1;}
		if ($aimUpAxis==0) {$xUp=1;$yUp=0;$zUp=0;}
		if ($aimUpAxis==1) {$xUp=0;$yUp=1;$zUp=0;}
		if ($aimUpAxis==2) {$xUp=0;$yUp=0;$zUp=1;}

		$tempString=`listRelatives -c $joint`;
		if (!size($tempString))
			parent $joint $rlaParent;
		if (`objExists $aimAt`)
			delete `aimConstraint -offset 0 0 0 -aimVector $x $y $z -upVector $xUp $yUp $zUp -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $aimAt $aimAt $rlaParent`;
		if (!size($tempString))
			parent -w $joint;
		}

	makeIdentity -a 1 -t 0 -r 1 -s 0 $rlaParent;

	if (size($parentOtherChildren))
		{
		parent $parentOtherChildren $rlaParent;
		delete otherChildrenPlaceHolder;
		}

	parent $joint $rlaParent;
	//restore sibiling order
	if (size($rlaParentChildren)>1)
		{
		$newRlaParentChildren=`listRelatives -type joint -c $rlaParent`;
		for ($i=0;$i<size($newRlaParentChildren);$i++)
			{
			if ($joint==$newRlaParentChildren[$i])
				$newChildNr=$i;
			}
		if ($newChildNr!=$childNr)
			reorder -relative ($childNr-$newChildNr) $joint;
		}
	if (`objExists $generatedTransform1`) delete $generatedTransform1;
	if (`objExists $generatedTransform2`) delete $generatedTransform2;

	//restore connections
	for ($i=0;$i<size($connectCmds);$i++)
		if (catchQuiet (`eval ($connectCmds[$i])`)) 
			warning ("Failed: "+$connectCmds[$i]+"\n");

	//update lenght
	if (`objExists ($rlaParent+"ScaleYMultiDiv1")`)
		setAttr ($rlaParent+"ScaleYMultiDiv1.input1Y") (`getAttr ($rlaParent+"ScaleYMultiDiv1.dummyInput1Y")`*(1.0/$scale));

	//update skeleton scale
	if (`objExists ($rlaParent+"Bone")` && `objExists ($rlaParent+"Distance")`)
		{
		float $lenght=`getAttr ($rlaParent+"Distance.distance")`*(1.0/$scale);
		setAttr ($rlaParent+"Bone.sx") $lenght;
		}

	setAttr -l $lockTX ($joint+".tx");setAttr -l $lockTY ($joint+".ty");setAttr -l $lockTZ ($joint+".tz");
	setAttr -l $lockRX ($joint+".rx");setAttr -l $lockRY ($joint+".ry");setAttr -l $lockRZ ($joint+".rz");
	setAttr -l $lockPTX ($rlaParent+".tx");setAttr -l $lockPTY ($rlaParent+".ty");setAttr -l $lockPTZ ($rlaParent+".tz");
	setAttr -l $lockPRX ($rlaParent+".rx");setAttr -l $lockPRY ($rlaParent+".ry");setAttr -l $lockPRZ ($rlaParent+".rz");
	}

//Update the other joints in the same IK to ensure IK-plane
for ($i=0;$i<size($otherJointsInIK);$i++)
	asFitModeUpdateJoints $otherJointsInIK[$i] 1;
if (`objExists FitSkeletonPoleVectors`) {asFitDisplayPoleVector 0;asFitDisplayPoleVector 1;}
select $sel;
//Restore `insert-mode`, as newer version of Maya will drop this when:createNode
if ($editPivotMode)
	if (!`manipMoveContext -q -editPivotMode Move`)
		EnterEditMode;
}

global proc string[] asFitJointIKInfo (string $joint)
{
int $IKNumCtrls=2;
string $ik,$IKParentJoint,$IKMiddleJoint,$IKChildJoint,$IKSolver,$IKParentJointLabel;
string $asFitJointIKInfo[],$tempString[];
$tempString=`ls -l $joint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$label=`asLabel $tempString[$i]`;
//	if ($i<size($tempString)-1)
//		if (`gmatch $label "*Hand*"` || `gmatch $label "*Foot*"` || `gmatch $label "*Chest*"`)
//			break;
	if (`gmatch $label "*Shoulder*"` || `gmatch $label "*Hip*"` || `gmatch $label "*Root*"` || `gmatch $label "0*"`)
		{
		$IKParentJoint=$tempString[$i];
		$IKParentJointLabel=$label;
		break;
		}
	}

string $jointAllDescendents[]=`listRelatives -allDescendents -type joint $joint`;
string $anotherSpineIkJoints[];
$jointAllDescendents[size($jointAllDescendents)]=$joint;
for ($i=size($jointAllDescendents)-1;$i>-1;$i--)
	{
	$label=`asLabel $jointAllDescendents[$i]`;
	int $validLabelHit=0;
	if (`gmatch $label "*Hand*"` && `gmatch $IKParentJointLabel "*Shoulder*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Foot*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Toes*"` && `gmatch $IKParentJointLabel "*Hip*"`)
		$validLabelHit=1;
	if (`gmatch $label "*Chest*"` && `gmatch $IKParentJointLabel "*Root*"`)
		$validLabelHit=1;
	if ($validLabelHit)
		{
		$IKChildJoint=$jointAllDescendents[$i];
		break;
		}
	if (`gmatch $label "0*"` && $jointAllDescendents[$i]!=$joint)//track $anotherSpineIkJoints, so $IKChildJoint is not from another SplineIK
		{
		$tempString=`listRelatives -allDescendents -type joint $jointAllDescendents[$i]`;
		$anotherSpineIkJoints=`stringArrayCatenate $anotherSpineIkJoints $tempString`;
		}
	if (`gmatch $label "*[1-9]*"` && `gmatch $IKParentJointLabel "*0*"` && !`stringArrayCount $jointAllDescendents[$i] $anotherSpineIkJoints`)
		$IKChildJoint=$jointAllDescendents[$i];
	}

if ($IKParentJoint!= "" && $IKChildJoint!="")
	{
	//Find $IKMiddleJoint
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	int $numIkJoints=0;
	for ($i=size($tempString)-1;$i>-1;$i--)
		{
		$numIkJoints++;
		if ($tempString[$i]==$IKParentJoint)
		break;
		}
	int $middleNr=$numIkJoints/2;
	$IKMiddleJoint=$tempString[size($tempString)-1-$middleNr];
	//Find $IKNumCtrls
	$tempString=`ls -l $IKChildJoint`;
	tokenize $tempString[0] "|" $tempString;
	for ($i=size($tempString)-2;$i>-1;$i--)
		{
		if ($tempString[$i]==$IKParentJoint)
		break;
		$label=`asLabel $tempString[$i]`;
		if (`gmatch $label "*Mid*"` || `gmatch $label "[0-9]*"`)
			$IKNumCtrls++;
		}

	$IKSolver="ikRPsolver";
	$label=`asLabel $IKParentJoint`;
	if (`gmatch $label "*Shoulder*"`)
		$ik="Arm"+`substitute "Shoulder" $label ""`;
	if (`gmatch $label "*Hip*"`)
		$ik="Leg"+`substitute "Hip" $label ""`;
	if (`gmatch $label "*Root*"`)
		{
		$ik="Spine"+`substitute "Root" $label ""`;
		$IKSolver="ikSplineSolver";
		}
	if (`gmatch $label "*0*"`)
		{
		$ik="Spline"+`substitute "[0-9]*" $label ""`;
		$IKSolver="ikSplineSolver";
		}

	$asFitJointIKInfo[0]=$ik;
	$asFitJointIKInfo[1]=$IKParentJoint;
	$asFitJointIKInfo[2]=$IKMiddleJoint;	
	$asFitJointIKInfo[3]=$IKChildJoint;	
	$asFitJointIKInfo[4]=$IKSolver;
	$asFitJointIKInfo[5]=$IKNumCtrls;
	}

return $asFitJointIKInfo;
}

global proc string[] asGetIKJoints (string $IKStartJoint, string $IKEndJoint)
{
string $IKJoints[];
string $tempString[]=`ls -l $IKEndJoint`;
tokenize $tempString[0] "|" $tempString;
int $foundStartJoint=0;
for ($i=0;$i<size($tempString);$i++)
	{
    if ($tempString[$i]==$IKStartJoint)
        $foundStartJoint=1;
    if ($foundStartJoint)
    	$IKJoints[size($IKJoints)]=$tempString[$i];
	}
return $IKJoints;
}

global proc asFitSDKCreateAttribute ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$drivenObjs[],$drivenAttrs[];
float $drivenDefaultValue[],$drivenValue[];
if (!size($sel))
	warning "Nothing selected, you should select a SDK Object first\n";
else
	$tempString=`listRelatives -c $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not a nurbsCurve\n";
if (`objectType $tempString[0]`!="nurbsCurve")
	error "Selected Object is not a nurbsCurve\n";
$existingDefaultPoseCmdString=`getAttr ($sel[0]+".defaultPose")`;
$existingDefaultPoseCmds=`stringToStringArray $existingDefaultPoseCmdString ";"`;

string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $cmd;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
		{
		$objAttr=$fitJoints[$i]+"."+$trs[$y]+$xyz[$z];
		float $value=`getAttr $objAttr`;
		for ($a=0;$a<size($existingDefaultPoseCmds);$a++)
			if (`gmatch $existingDefaultPoseCmds[$a] ("setAttr "+$objAttr+" *")`)
				{
				tokenize $existingDefaultPoseCmds[$a] $tempString;
				float $defaultValue=$tempString[2];
				if ($value>$defaultValue+0.001 || $value<$defaultValue-0.001)
					{
					tokenize $tempString[1] "." $tempString2;
					$drivenObjs[size($drivenObjs)]=$tempString2[0];
					$drivenAttrs[size($drivenAttrs)]=$tempString2[1];
					$drivenDefaultValue[size($drivenDefaultValue)]=$defaultValue;
					$drivenValue[size($drivenValue)]=$value;
					}
				}
		}
if (!size($drivenObjs))
	error "Found No attributes changed from Default Pose";

string $suggestAttrName;
if (`gmatch $drivenObjs[0] "*Finger*"` || `gmatch $drivenObjs[0] "*Toe*"`)
	{
	$suggestAttrName=`substitute "[0-9]" $drivenObjs[0] ""`;
	$suggestAttrName=`substitute "Finger" $suggestAttrName ""`;
	$suggestAttrName=`substitute "Toe" $suggestAttrName ""`;
	$suggestAttrNameFirstLetter=`substring $suggestAttrName 1 1`;
	$suggestAttrName=`tolower $suggestAttrNameFirstLetter`+`substring $suggestAttrName 2 99`+"Curl";
	}

$asFitSDKMessage="Create Set-Driven-Key for these ?\n\n";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $value=`getAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i])`;
	float $roundFactor=0.5;
	if ($value<0) $roundFactor=-0.5;
	$value=(trunc($value*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
	$asFitSDKMessage+=$drivenObjs[$i]+"."+$drivenAttrs[$i]+" = "+$value+"\n";
	}
$asFitSDKAttrName=$suggestAttrName;
$asFitSDKObjName=$sel[0];
$asFitSDKDriverValue=10;

string $dialogResult=`layoutDialog -t "Confirm" -ui asFitSDKCreateAttributeLayout`;
if ($dialogResult!="OK")
	return;

string $attrName=$asFitSDKAttrName;
if ($attrName=="" || `gmatch $attrName "* *"`)
	error "Not a valid attribute name";	
if (`attributeExists $attrName $sel[0]`)
	deleteAttr ($sel[0]+"."+$attrName);
addAttr -k 1 -ln $attrName -at double $sel[0];
if ($asFitSDKDriverHasMin) addAttr -e -softMinValue $asFitSDKDriverMin ($sel[0]+"."+$attrName);
if ($asFitSDKDriverHasMax) addAttr -e -softMaxValue $asFitSDKDriverMax ($sel[0]+"."+$attrName);

for ($i=0;$i<size($drivenObjs);$i++)
	{
	float $driverValue=10;
	$objAttr=$drivenObjs[$i]+"."+$drivenAttrs[$i];
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenDefaultValue[$i] -dv 0 -cd ($sel[0]+"."+$attrName) $objAttr;
	setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValue[$i] -dv $asFitSDKDriverValue -cd ($sel[0]+"."+$attrName) $objAttr;
//	setAttr ($sel[0]+"."+$attrName) $driverValue;
	}
select $drivenObjs;
setInfinity -pri cycleRelative -poi cycleRelative;

select $sel;
}

global proc asFitSDKCreateAttributeLayout ()
{
global string $asFitSDKMessage;
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
string $tempString[];
tokenize $asFitSDKMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asFitSDKMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asFitSDKMessage+=$tempString[$i]+"\n";
	$asFitSDKMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout;
	text -l $asFitSDKMessage;
	separator -h 10 -st none;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 -tx $asFitSDKAttrName asFitSDKAttrNameTextField;
		setParent..;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Value:";
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverValueFloatField;
		setParent..;
	separator -st none -h 3;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		checkBox -l "Min" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMinFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMinFloatField" asFitSDKDriverHasMinCheckBox;
		checkBox -l "Max" -v 1 -onc "floatField -e -en 1 asFitSDKDriverMaxFloatField" -ofc "floatField -e -en 0 asFitSDKDriverMaxFloatField" asFitSDKDriverHasMaxCheckBox;
		setParent..;
	rowLayout -nc 3 -cw3 10 85 85;
		separator;
		floatField -w 50 -v 0 -pre 1 asFitSDKDriverMinFloatField;
		floatField -w 50 -v $asFitSDKDriverValue -pre 1 asFitSDKDriverMaxFloatField;
		setParent..;
	separator -h 10 -st none;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asFitSDKCreateAttributeGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;
}

global proc asFitSDKCreateAttributeGetName ()
{
global string $asFitSDKAttrName;
global float $asFitSDKDriverValue;
global int $asFitSDKDriverHasMin;
global int $asFitSDKDriverHasMax;
global float $asFitSDKDriverMin;
global float $asFitSDKDriverMax;
$asFitSDKAttrName=`textField -q -tx asFitSDKAttrNameTextField`;
$asFitSDKDriverValue=`textField -q -tx asFitSDKDriverValueFloatField`;
$asFitSDKDriverHasMin=`checkBox -q -v asFitSDKDriverHasMinCheckBox`;
$asFitSDKDriverHasMax=`checkBox -q -v asFitSDKDriverHasMaxCheckBox`;
$asFitSDKDriverMin=`floatField -q -v asFitSDKDriverMinFloatField`;
$asFitSDKDriverMax=`floatField -q -v asFitSDKDriverMaxFloatField`;
}

global proc string asRlaParent (string $joint)
{
string $tempString[]=`listRelatives -p -type joint $joint`;
string $rlaParent=$tempString[0];
return $rlaParent;
}

global proc string asRlaChild (string $joint)
{
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
float $centerTolerance=0.01*$scale;
string $children[]=`listRelatives -type joint -c $joint`;
string $rlaChild="";
float $pos[3]=`xform -q -ws -t $joint`;
int $center=0;
if ($pos[0]>-$centerTolerance && $pos[0]<$centerTolerance) $center=1;
for ($y=0;$y<size($children);$y++)
	{
	float $childPos[3]=`xform -q -ws -t $children[$y]`;
	int $childCenter=0;
	if ($childPos[0]>-$centerTolerance && $childPos[0]<$centerTolerance) $childCenter=1;
	if ($center && $childCenter) $rlaChild=$children[$y];
	if (!$center && !$childCenter) $rlaChild=$children[$y];
	//Use `first` child as $rlaChild
	if ($rlaChild!="")
	 break;
	}

//if (!$center && size($children)>1)
//	$rlaChild="";

//Preferred $rlaChild
if (`gmatch $joint "*Head*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Head*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Ankle*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Toes*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Toes*"`)
			$rlaChild=$children[$y];
if (`gmatch $joint "*Root*"`)
	for ($y=0;$y<size($children);$y++)
		if (`gmatch $children[$y] "*Spine*"`)
			$rlaChild=$children[$y];

return $rlaChild;
}

global proc string asCreateWrap (string $name,float $threshold, float $maxDistance, int $exclusiveBind, int $autoWeightThreshold, int $falloffMode)
{//asCreateWrap (0,0,0,1,0);
string $sel[]=`ls -sl`;
string $tempString[];
string $wrapNode;
string $surfaceShape=$sel[1];
string $driverTrans=$sel[0];
select $driverTrans;

$tempString=`deformer -n $name -type wrap`;
$wrapNode=$tempString[0];

setAttr ($wrapNode + ".weightThreshold") $threshold;
setAttr ($wrapNode + ".maxDistance") $maxDistance;
setAttr ($wrapNode + ".exclusiveBind") $exclusiveBind;
setAttr ($wrapNode + ".autoWeightThreshold") $autoWeightThreshold;
setAttr ($wrapNode + ".falloffMode") $falloffMode;

//connectAttr ($surfaceShape+".worldMatrix[0]") ($wrapNode+".geomMatrix");
//addInfluence ({$wrapNode}, $driverTrans, $inflType, $renderInfl);
select $sel;
AddWrapInfluence;

return $wrapNode;
}

global proc asFitGeometry ()
{
if (!`objExists FitSkeleton`) {print ("// No FitSkeleton found\n");return;}
asEnsureFitSkeletonAttributes;
string $sel[]=`ls -sl`;
int $displayGeometry=`checkBox -q -v asVisGeo`;
int $visPoleVector;
if (`attributeExists visPoleVector FitSkeleton`) $visPoleVector=`getAttr FitSkeleton.visPoleVector`;
if (`objExists FitSkeletonVisualizers`) delete FitSkeletonVisualizers;
if (`objExists Mannequin_Geometry`) delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`) delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`) delete SkinCage_Geometry;
if ($displayGeometry==0)
	{
	asUpdateButtonEnables;
	if ($visPoleVector) asFitDisplayPoleVector 1;
	return;
	}
asFitModeEnsureShaders;
int $twistJoints,$inbetweenJoints;
float $aimV[3]={1,0,0};
float $upV[3]={0,1,0};
string $part;

createNode -n FitSkeletonVisualizers transform;
connectAttr FitSkeleton.s FitSkeletonVisualizers.s;
createNode -n Aims -p FitSkeletonVisualizers transform;
string $tempString[],$geoObjs[];
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
string $templateBones[]=`listRelatives -c Skeleton_Geometry`;
for ($i=0;$i<size($templateBones);$i++)
	rename $templateBones[$i] ($templateBones[$i]+"_template");

for ($i=size($fitJoints)-1;$i>-1;$i--) // Reverse order, so endJoints can copy `fat` value from parent
	asEnsureFitJointAttrs $fitJoints[$i];

for ($i=0;$i<size($fitJoints);$i++)
	{
	clear $geoObjs;
	string $rlaChild=`asRlaChild $fitJoints[$i]`;
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($rlaChild=="" && $fitJoints[$i]=="Root" && $tempString[0]!="") // Root to use sideChild, if no middleChild
		$rlaChild=$tempString[0];
	if ($rlaChild=="")
		continue;
	if (`attributeExists worldOrient $fitJoints[$i]`)
		continue;
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	if ($fitJoints[$i]=="*Jaw*" || `gmatch $fitJoints[$i] "*Eye*"`)
		continue;	

	createNode -n ($fitJoints[$i]+"Aim") -p Aims transform;
	$twistJoints=0;
	if (`attributeExists twistJoints  $fitJoints[$i]`)
		$twistJoints=`getAttr ($fitJoints[$i]+".twistJoints")`;
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints  $fitJoints[$i]`)
		$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+$part+"Geo") -p ($fitJoints[$i]+"Aim") transform;
	
		//box
		$tempString=`polyCube -n ($fitJoints[$i]+$part+"Box") -w 1.75 -h 1 -d 1.75 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
		$box=$tempString[0];
		$geoObjs[size($geoObjs)]=$box;
		move -r 0 0.5 0 ($box+".vtx[0:7] ");
		sets -e -forceElement asRedSG ($box+".f[1]");
		sets -e -forceElement asRed2SG ($box+".f[3]");
		sets -e -forceElement asGreenSG ($box+".f[0]");
		sets -e -forceElement asGreen2SG ($box+".f[2]");
		sets -e -forceElement asBlueSG ($box+".f[4]");
		sets -e -forceElement asBlue2SG ($box+".f[5]");
		connectAttr FitSkeleton.visBoxes ($box+".v");
		setAttr ($box+"Shape.overrideEnabled") 1;
		setAttr ($box+"Shape.overrideDisplayType") 2;
		parent $box ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($box+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($box+".vtx[0:7]");
	
		
		//cylinder
		$tempString=`cylinder -n ($fitJoints[$i]+$part+"Cyl") -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -hr 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 0`;
		$cyl=$tempString[0];
		$geoObjs[size($geoObjs)]=$cyl;
		move -r 0 0.5 0 ($cyl+".cv[0:3][0:7]");
		sets -e -forceElement asBlueSG ($cyl+".sf[0][7]") ($cyl+".sf[0][0]");//sf[0][1:2]
		sets -e -forceElement asGreenSG ($cyl+".sf[0][1:2]");//sf[0][3:4]
		sets -e -forceElement asBlue2SG ($cyl+".sf[0][3:4]");//sf[0][5:6]
		sets -e -forceElement asGreen2SG ($cyl+".sf[0][5:6]");//sf[0][7]
		connectAttr FitSkeleton.visCylinders ($cyl+".v");
		setAttr ($cyl+"Shape.overrideEnabled") 1;
		setAttr ($cyl+"Shape.overrideDisplayType") 2;
		parent $cyl ($fitJoints[$i]+$part+"Geo");
		setAttr -type float3 ($cyl+".s") 1 1 1;
		rotate -r -p 0 0 0 -os 0 -90 -90 ($cyl+".cv[0:3][0:7]");	
		}

	//sphere
	$tempString=`polyCube -n ($fitJoints[$i]+"Sphere") -w 2.5 -h 2.5 -d 2.5 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0`;
	$sphere=$tempString[0];
	sets -e -forceElement asRedSG ($sphere+".f[1]");
	sets -e -forceElement asRed2SG ($sphere+".f[3]");
	sets -e -forceElement asGreenSG ($sphere+".f[0]");
	sets -e -forceElement asGreen2SG ($sphere+".f[2]");
	sets -e -forceElement asBlueSG ($sphere+".f[4]");
	sets -e -forceElement asBlue2SG ($sphere+".f[5]");
	polySmooth  -mth 0 -dv 2 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 0 $sphere;
	connectAttr FitSkeleton.visSpheres ($sphere+".v");
	setAttr ($sphere+"Shape.overrideEnabled") 1;
	setAttr ($sphere+"Shape.overrideDisplayType") 2;
	parent $sphere ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($sphere+".s") 1 1 1;
	rotate -r -p 0 0 0 -os 0 -90 -90 ($sphere+".vtx[0:999]");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sy");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sz");
	connectAttr ($fitJoints[$i]+".fat") ($sphere+".sx");

	//bones
	$bone=$fitJoints[$i]+"Bone";
	if ($fitJoints[$i]!="Scapula")
		{
		if (`objExists ($fitJoints[$i]+"Bone_template")`){
		duplicate -n $bone ($fitJoints[$i]+"Bone_template");}
		else if ($fitJoints[$i]=="Root" || $fitJoints[$i]=="Chest" || `gmatch $fitJoints[$i] "Neck*"` || `gmatch $fitJoints[$i] "Spine*"`)
			duplicate -n $bone SpineBone_template;
		else if (`gmatch $fitJoints[$i] "*Finger*"`)
			duplicate -n $bone DigitBone_template;
		else
			duplicate -n $bone GenericBone_template;
		sets -e -forceElement asBonesSG $bone;
		parent $bone ($fitJoints[$i]+"Aim");
		connectAttr FitSkeleton.visBones ($bone+".v");
		connectAttr ($fitJoints[$i]+".fat") ($bone+".sy");
		connectAttr ($fitJoints[$i]+".fat") ($bone+".sz");
		}

	//Flare
	select $geoObjs;
	$tempString=`nonLinear -type flare  -lowBound 0 -highBound 1 -startFlareX 1 -startFlareZ 1 -endFlareX 1 -endFlareZ 1 -curve 0`;
	string $flare=`rename $tempString[0] ($fitJoints[$i]+"Flare")`;
	string $flareHandle=`rename $tempString[1]  ($fitJoints[$i]+"FlareHandle")`;
	parent $flareHandle ($fitJoints[$i]+"Aim");
	setAttr -type float3 ($flareHandle+".s") 1 1 1;
	setAttr -type float3 ($flareHandle+".t") 0 0 0;
	setAttr -type float3 ($flareHandle+".r") 0 0 -90;
	setAttr -l 1 ($flareHandle+".v") 0;
	
	connectAttr ($fitJoints[$i]+".fatYabs") ($flare+".startFlareX");
	connectAttr ($fitJoints[$i]+".fatZabs") ($flare+".startFlareZ");
	
	//Gap
	if (`objExists ($fitJoints[$i]+"GapBlenderA")`) delete ($fitJoints[$i]+"GapBlenderA");
	if (`objExists ($fitJoints[$i]+"GapBlenderB")`) delete ($fitJoints[$i]+"GapBlenderB");
	string $gapBlenderA=`createNode -n ($fitJoints[$i]+"GapBlenderA") blendTwoAttr`;
	string $gapBlenderB=`createNode -n ($fitJoints[$i]+"GapBlenderB") blendTwoAttr`;
	connectAttr FitSkeleton.visGap ($gapBlenderA+".attributesBlender");
	connectAttr FitSkeleton.visGap ($gapBlenderB+".attributesBlender");
	connectAttr ($fitJoints[$i]+".fatYabs") ($gapBlenderA+".input[0]");
	connectAttr ($fitJoints[$i]+".fatZabs") ($gapBlenderB+".input[0]");
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderA;
	addAttr -k 0 -ln dummyInput1 -at double $gapBlenderB;
	connectAttr ($rlaChild+".fatYabs") ($gapBlenderA+".dummyInput1");
	connectAttr ($rlaChild+".fatZabs") ($gapBlenderB+".dummyInput1");
	setAttr ($gapBlenderA+".input[1]") `getAttr ($rlaChild+".fatYabs")`;
	setAttr ($gapBlenderB+".input[1]") `getAttr ($rlaChild+".fatZabs")`;

	connectAttr ($gapBlenderA+".output") ($flare+".endFlareX");
	connectAttr ($gapBlenderB+".output") ($flare+".endFlareZ");

	//Distance
	if (`objExists ($fitJoints[$i]+"Distance")`) delete ($fitJoints[$i]+"Distance");
	createNode -n ($fitJoints[$i]+"Distance") distanceBetween;
	connectAttr ($fitJoints[$i]+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix1");
	connectAttr ($rlaChild+".worldMatrix[0]") ($fitJoints[$i]+"Distance.inMatrix2");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv1")`) delete ($fitJoints[$i]+"ScaleYMultiDiv1");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv1") multiplyDivide;
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.operation") 2;
//	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y");

	addAttr -ln dummyInput1Y -at double ($fitJoints[$i]+"ScaleYMultiDiv1");
	connectAttr ($fitJoints[$i]+"Distance.distance") ($fitJoints[$i]+"ScaleYMultiDiv1.dummyInput1Y");
	setAttr ($fitJoints[$i]+"ScaleYMultiDiv1.input1Y") `getAttr ($fitJoints[$i]+"Distance.distance")`;

//	connectAttr FitSkeleton.sx ($fitJoints[$i]+"ScaleYMultiDiv1.input2Y");
	if (`objExists ($fitJoints[$i]+"ScaleYMultiDiv2")`) delete ($fitJoints[$i]+"ScaleYMultiDiv2");
	createNode -n ($fitJoints[$i]+"ScaleYMultiDiv2") multiplyDivide;
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv2.input1Y");
	connectAttr FitSkeleton.visGap ($fitJoints[$i]+"ScaleYMultiDiv2.input2Y");
	
	connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($flareHandle+".sy");

	parentConstraint $fitJoints[$i] ($fitJoints[$i]+"Aim");

	for ($y=0;$y<$twistJoints+$inbetweenJoints+1;$y++)
		{
		$part="";
		if ($y>0)
			$part="Part"+$y;

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y) multiplyDivide;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv1.outputY") ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".input2Y") ($y*(1.0/($twistJoints+$inbetweenJoints+1)));
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv4_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo.tx");

		createNode -n ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y) multiplyDivide;
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".operation") 2;
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv2.outputY") ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input1Y");
		setAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".input2Y") ($twistJoints+$inbetweenJoints+1);
		connectAttr ($fitJoints[$i]+"ScaleYMultiDiv5_"+$y+".outputY") ($fitJoints[$i]+$part+"Geo"+".sx");
		}
	}

if (`objExists PelvisBone`)
	{
	parent PelvisBone FitSkeletonVisualizers;
	setAttr PelvisBone.tx 0;
	setAttr -type float3 PelvisBone.r 0 0 0;
	pointConstraint -skip x Hip PelvisBone;
	}

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;
asFitModeManualUpdate;
asUpdateButtonEnables;
asChangeVisGeoType;
if ($visPoleVector) asFitDisplayPoleVector 1;
catchQuiet (`select $sel`);
}

global proc asChangeVisGeoType ()
{
string $geoType=`optionMenu -q -v asVisGeoType`;
setAttr FitSkeleton.visCylinders 0;
setAttr FitSkeleton.visBoxes 0;
setAttr FitSkeleton.visSpheres 0;
setAttr FitSkeleton.visBones 0;
if ($geoType=="cylinders")
	setAttr FitSkeleton.visCylinders 1;
if ($geoType=="boxes")
	setAttr FitSkeleton.visBoxes 1;
if ($geoType=="spheres")
	setAttr FitSkeleton.visSpheres 1;
if ($geoType=="bones")
	setAttr FitSkeleton.visBones 1;
}

global proc asEnsureFitJointAttrs (string $fitJoint)
{
if (!`attributeExists fat $fitJoint`)
	{
	float $dv=1;
	string $rlaChild=`asRlaChild $fitJoint`;
	if ($rlaChild!="")
		{
		$dv=`getAttr ($rlaChild+".tx")`;
		$dv=`abs($dv)`;
		}
	else
		{
		string $tempString[]=`listRelatives -p -type joint $fitJoint`;
		if ($tempString[0]!="" && `attributeExists fat $tempString[0]`)
			$dv=`getAttr ($tempString[0]+".fat")`;
		}
	addAttr -k 1 -min 0 -dv $dv -ln fat -at double $fitJoint;
	}
if (!`attributeExists fatY $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatY -at double $fitJoint;
if (!`attributeExists fatZ $fitJoint`)
	addAttr -k 1 -min 0 -dv 1 -ln fatZ -at double $fitJoint;
if (!`attributeExists fatYabs $fitJoint`)
	addAttr -k 0 -ln fatYabs -at double $fitJoint;
if (!`attributeExists fatZabs $fitJoint`)
	addAttr -k 0 -ln fatZabs -at double $fitJoint;
if (`objExists ($fitJoint+"Fat")`) delete ($fitJoint+"Fat");
createNode -n ($fitJoint+"Fat") multiplyDivide;
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Y");
connectAttr -f ($fitJoint+".fat") ($fitJoint+"Fat.input1Z");
connectAttr -f ($fitJoint+".fatY") ($fitJoint+"Fat.input2Y");
connectAttr -f ($fitJoint+".fatZ") ($fitJoint+"Fat.input2Z");
connectAttr -f ($fitJoint+"Fat.outputY") ($fitJoint+".fatYabs");
connectAttr -f ($fitJoint+"Fat.outputZ") ($fitJoint+".fatZabs");
}

global proc asRemoveUnusedfromBuildPose (string $uiName)
{
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	$buildPose="faceBuildPose";
string $newBuildPoseCmd;
string $cmds[],$tempString[];
string $buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $cmds;
for ($i=0;$i<size( $cmds);$i++)
	{
	tokenize $cmds[$i] $tempString;
	string $ctrl=$tempString[size($tempString)-1];
	if (`gmatch $cmds[$i] "*[.]*"`)
		$ctrl=$tempString[size($tempString)-2];
	if (`objExists $ctrl`)
		$newBuildPoseCmd+=$cmds[$i]+";";
	}
setAttr -type "string" ($buildPose+".udAttr") $newBuildPoseCmd;
}

global proc asUpdateASToolsProcsInSelectors ()
{
string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
string $fDet,$fDet2;
string $files[];
int $fileId=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId;

string $selectorsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/";
string $selectorFiles[]=`getFileList -fs "*.mel" -fld $selectorsDir`;
for ($i=0;$i<size($selectorFiles);$i++)
	$files[size($files)]=$selectorsDir+$selectorFiles[$i];
$files[size($files)]=`asGetScriptLocation`+"/AdvancedSkeleton5Files/picker/picker.mel";

for ($i=0;$i<size($files);$i++)
	{
	int $fileId=`fopen $files[$i] "r"`;
	string $nextLine = `fgetline $fileId`;
	int $copyLines=0;
	$fDet2="";
	while (size($nextLine)>0)
		{
		$fDet2+=$nextLine;
		$nextLine=`fgetline $fileId`;
		if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
			break;
		}
	fclose $fileId;

	int $fileId2=`fopen $files[$i] "w"`;
	fprint $fileId2 ($fDet2+$fDet);
	fclose $fileId2;
print ("// Updated:"+$files[$i]+"\n");
	}
}

global proc float asRoundOff (float $value, int $decimals)
{
float $rounded;
if ($value>=0) $rounded=(trunc($value*`pow 10 $decimals`+0.5)/`pow 10 $decimals`);
else $rounded=(trunc(abs($value)*`pow 10 $decimals`+0.5)/`pow 10 $decimals`)*-1;
return $rounded;
}

global proc asSetFixedWrapOptions ()
{
optionVar -intValue autoWeightThreshold 1;
optionVar -intValue exclusiveBind 0;
optionVar -intValue renderInfl 1;
optionVar -stringValue falloffMode "volume";
}

global proc asSwapCurve ()
{
string $side,$oppositeSide,$allSet;
string $tempString[],$tempString2[];
string $sel[]=`ls -sl`;
int $last=`size($sel)`-1;
string $selShapes[];
if (size($sel)<2)
	error "Selected both controls to replace, and the new curve to use";
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	$selShapes[$i]=$tempString[0];
	if (!`objExists $selShapes[$i]`)
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objectType $selShapes[$i]`!="nurbsCurve" && `objectType $selShapes[$i]`!="nurbsSurface")
		error ("selected object:\""+$sel[$i]+"\" is not a nurbsCurve");
//	if ($i==$last && `sets -im ControlSet $sel[$i]`)
//		error ("\""+$sel[$i]+"\" is a control. The new curve must be select last, and must not be a existing control");
	}
select $sel[$last];
DeleteHistory;
		
for ($i=0;$i<size($sel)-1;$i++)
	{
	delete `listRelatives -s $sel[$i]`;
	duplicate -n tempXform $sel[$last];
	$tempString=`listRelatives -f -s tempXform`;
	for ($y=0;$y<size($tempString);$y++)
		rename $tempString[$y] ($sel[$i]+"Shape");
	$allSet="AllSet";
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $sel[$i]`)
			$allSet="FaceAllSet";
	$tempString=`listRelatives -s tempXform`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`parent -add -s $tempString[$y] $sel[$i]`;
		$tempString[$y]=$tempString2[0];
		float $rot[]=`xform -q -ws -ro $sel[$i]`;
//		if(!(`gmatch $sel[0] "IK*"` || `gmatch $sel[0] "Pole*"` || `gmatch $sel[0] "RootX*"`))
		if (!($rot[0]==0 && $rot[1]==0 && $rot[2]==0))
			rotate -r -os -90 -90 0 ($tempString[$y]+".cv[0:9999]");
		sets -add $allSet $tempString[$y];
		}
	delete tempXform;
	}
	dgdirty -a;
}

global proc asSetCurveColor ()
{
int $curveColor=`palettePort -q -setCurCell asCurveColorPalettePort`;
int $useOverrideRGBColors=0;
float $rgb[];
string $type;
string $controllers[],$controlSetMembers[];
string $curveColorType=`optionMenu -q -v asCurveColorTypeOptionMenu`;
string $curveColorSide=`optionMenu -q -v asCurveColorSideOptionMenu`;

if (`asMayaVersionAsFloat`>=2014)
	{
	//Maya2015 onwards have "overrideRGBColors"
	$rgb=`palettePort -q -rgb asCurveColorPalettePort`;
	$storedRgb=`colorIndex -query $curveColor`;
	if ($storedRgb[0]!=$rgb[0] || $storedRgb[1]!=$rgb[1] || $storedRgb[2]!=$rgb[2])
		{
		print "// Non default index color, using \"overrideRGBColors\".\n";
		$useOverrideRGBColors=1;
		}
	}

if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;
//if (`gmatch $curveColorType "Face:*"` && `objExists FaceControlSet`)
//	$controlSetMembers=`sets -q FaceControlSet`;
	
string $sel[]=`ls -sl`;
string $tempString[];
string $side;
if ($curveColorSide=="Right") $side="_R";
if ($curveColorSide=="Left") $side="_L";
if ($curveColorSide=="Middle") $side="_M";

if ($curveColorType=="Selected")
	$controllers=$sel;
else
	for ($i=0;$i<size($controlSetMembers);$i++)
		{
		if ($curveColorType!="*All")
			if (!`gmatch $controlSetMembers[$i] ($curveColorType+"*")`)
				continue;
		if ($curveColorSide!="*All")
			if (!`gmatch $controlSetMembers[$i] ("*"+$side)`)
				continue;
		$controllers[size($controllers)]=$controlSetMembers[$i];
		}

//different way to find the controllers for Face:
if (`gmatch $curveColorType "Face:*"` && `objExists ctrlBox`)
	{
	$type=`substitute "Face:" $curveColorType ""`;
	$tempString=`listConnections -s 0 -d 1 ("ctrlBox."+$type+"CtrlVis")`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($curveColorSide!="*All")
			if (!`gmatch $tempString[$i] ("*"+$side)`)
				continue;
		$controllers[size($controllers)]=$tempString[$i];
		}
	}

for ($i=0;$i<size($controllers);$i++)
	{
	$tempString=`listRelatives -s $controllers[$i]`;
	if ($tempString[0]!="")
		{
		setAttr ($tempString[0]+".overrideColor") $curveColor;
		if ($useOverrideRGBColors)
			{
			setAttr ($tempString[0]+".overrideRGBColors") 1;
			setAttr -type float3 ($tempString[0]+".overrideColorRGB") $rgb[0] $rgb[1] $rgb[2];
			}
		}
	}
}

global proc asControlCurvesPrintInfo ()
{
string $controlSetMembers[]=`sets -q ControlSet`;
string $curveShape;
string $tempString[],$cmds[],$skinCurves1[],$skinCurves2[];
int $spans,$degree,$numCVs;
float $cvPos[3],$pos[],$rot[],$sca[];
int $reuseShape=`checkBox -q -v asControlCurvesReUseShapeCheckBox`;
int $reuseColor=`checkBox -q -v asControlCurvesReUseColorCheckBox`;
int $reuseCatch=`checkBox -q -v asControlCurvesReUseCatchCheckBox`;
int $reuseSkinCurves=`checkBox -q -v asControlCurvesReUseSkinCurvesCheckBox`;
int $reuseFace=`checkBox -q -v asControlCurvesReUseFaceCheckBox`;

if ($reuseSkinCurves)
	{
	$skinCurves1=`listConnections SkinCurves1.drawInfo`;
	$skinCurves2=`listConnections SkinCurves2.drawInfo`;
	$controlSetMembers=`stringArrayCatenate $skinCurves1 $skinCurves2`;
	}
if ($reuseFace)
	$controlSetMembers=`sets -q FaceControlSet`;

for ($i=0;$i<size($controlSetMembers);$i++)
	{
	//SkinCurves also use xform
	if ($reuseSkinCurves)
		{
		$pos=`getAttr ($controlSetMembers[$i]+".t")`;
		$rot=`getAttr ($controlSetMembers[$i]+".r")`;
		$sca=`getAttr ($controlSetMembers[$i]+".s")`;
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".t "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".r "+$rot[0]+" "+$rot[1]+" "+$rot[2];
		$cmds[size($cmds)]="setAttr -type float3 "+$controlSetMembers[$i]+".s "+$sca[0]+" "+$sca[1]+" "+$sca[2];
		}

	$tempString=`listRelatives -s $controlSetMembers[$i]`;
	for ($z=0;$z<size($tempString);$z++)
		{
		$curveShape=$tempString[$z];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		if ($reuseShape)
			for ($y=0;$y<$numCVs;$y++)
				{
				$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
				$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2];
				}
		//color
		if ($reuseColor)
			$cmds[size($cmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($curveShape+".overrideColor")`;
		}
	}
for ($i=0;$i<size($cmds);$i++)
	if ($reuseCatch)
		$cmds[$i]="catch (`"+$cmds[$i]+"`)";

for ($i=0;$i<size($cmds);$i++)
	print ($cmds[$i]+";\n");
}

global proc asCreateControlMesh ()
{
string $sel[]=`ls -sl`;
float $pos[];
string $tempString[],$tempString2[];
int $mirror=`checkBox -q -v asCreateControlMeshMirrorCheckBox`;
if (size($sel)<2)
	error "Select polyFaces And Control";
string $control=$sel[size($sel)-1];
if (`gmatch $control "*.*"`)
	error "Control must be selected last";
if (!`gmatch $sel[0] "*.f*"`)
	error "Poly-faces must be selected";
string $sourceMeshes[]=`ls -sl -o -type mesh`;
if (size($sourceMeshes)>1)
	error "select faces from only 1 object at the time";
int $numLetters=size($control);
string $mirrorControl=`substring $control 1 ($numLetters-2)`+"_L";
if (`gmatch $control "*_L"`)
	$mirrorControl=`substring $control 1 ($numLetters-2)`+"_R";
select -d $control;
string $faces[]=`ls -sl`;
string $meshControl;
asEnsureMainCtrlVisAttrs;
for ($y=0;$y<99;$y++)
	{
	if ($y==0) $meshControl=$control+"MeshCtrl";
	else $meshControl=$control+"MeshCtrl"+$y;
	if (!`objExists $meshControl`)
		break;
	}
createNode -n $meshControl mesh;
//$tempString=`polySphere -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0`;
$tempString=`listRelatives -p $meshControl`;
string $generatedXform=$tempString[0];
parent -add -s $meshControl $control;
delete $generatedXform;

$tempString=`listRelatives -p $faces[0]`;
string $sourceMesh=$tempString[0];
$tempString=`listRelatives -p $sourceMesh`;
string $sourceXform=$tempString[0];

string $transformGeometry=`createNode -n ($control+"MCTransformGeometry") transformGeometry`;
connectAttr ($control+".worldInverseMatrix[0]") ($transformGeometry+".transform");
connectAttr -f ($sourceMesh+".outMesh") ($transformGeometry+".inputGeometry");
connectAttr -f ($transformGeometry+".outputGeometry") ($meshControl+".inMesh");

//ReAssign Shading
string $shaderCmd;
string $shadingEngines[]=`ls -type shadingEngine`;
for ($i=0;$i<size($shadingEngines);$i++)
	{
	hyperShade -o $shadingEngines[$i];
	$tempString=`ls -sl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString[$y] ($sourceXform+"[.]*")`)
			{
			select `substitute $sourceXform $tempString[$y] $meshControl`;
			sets -e -forceElement $shadingEngines[$i];
			}
		}
	}

select -cl;
for ($i=0;$i<size($faces);$i++)
	{
	tokenize $faces[$i] "." $tempString;
	select -add ($meshControl+"."+$tempString[1]);
	}
asInvertSelection;
int $allFacesSelected=0;
$tempString=`ls -sl`;
if ($tempString[0]=="")
	$allFacesSelected=1;
if ($allFacesSelected) select ($meshControl+".f[0]");
delete;
$tempString=`listConnections -s 1 -d 0 ($meshControl+".inMesh")`;
string $deleteComponent=`rename $tempString[0] ($control+"MCDeleteComponent")`;
if ($allFacesSelected) setAttr ($deleteComponent+".nodeState") 1;

if ($mirror && !`objExists controlMeshMirroring` && !`objExists controlMeshBatch` && `objExists $mirrorControl`)
	{
	createNode -n controlMeshMirroring transform;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($sourceMesh+".outMesh") closestSampler.inMesh;

	select $faces;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	select -cl;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr -type float3 closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		select -add ($sourceMesh+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");	
		}
	ConvertSelectionToContainedFaces;
	select -add $mirrorControl;
	asCreateControlMesh;
	delete controlMeshMirroring;
	}

//setAttr ($meshControl+".overrideEnabled") 1;
//setAttr ($meshControl+".overrideShading") 0;
setAttr ($meshControl+".castsShadows") 0;
setAttr ($meshControl+".receiveShadows") 0;
setAttr ($meshControl+".motionBlur") 0;
setAttr ($meshControl+".primaryVisibility") 0;
setAttr ($meshControl+".smoothShading") 0;
setAttr ($meshControl+".visibleInReflections") 0;
setAttr ($meshControl+".visibleInRefractions") 0;

connectAttr -f Main.ctrlMeshVis ($meshControl+".v");
$tempString=`listRelatives -s -type nurbsCurve $control`;
if ($tempString[0]!="")
	{
	$tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
	if ($tempString2[0]=="")
		connectAttr -f Main.ctrlCurveVis ($tempString[0]+".v");
	}

select -cl;
print ("// "+$meshControl+" created.\n");
}

global proc asCreateControlMeshes ()
{
global string $gMainProgressBar;
string $joint;
string $tempString[],$infs[],$weightJoints[],$faceVtxs[];
string $sel[]=`ls -sl`;
float $jointWeights[];
float $biggestJointWeight;
if ($sel[0]=="")
	error "Nothing selected";
if (`gmatch $sel[0] "*.*"`)
	error "Found components selected, Makes sure to select a object";
string $historyNodes[]=`listHistory -pdo 1 -il 2 $sel[0]`;
string $skinCluster,$faceCtrlName;
for ($i=0;$i<size($historyNodes);$i++)
	if (`nodeType $historyNodes[$i]`=="skinCluster")
		$skinCluster=$historyNodes[$i];
if ($skinCluster=="")
	error "No SkinCluster found on selected object";
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;
string $infJointCtrls[];

int $tempInts[]=`polyEvaluate -f $sel[0]`;
int $numFaces=$tempInts[0];
int $isFaceCtrl;
clear $infs;
if (`objExists controlMeshBatch`) delete controlMeshBatch;
createNode -n controlMeshBatch transform;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "working" -bp -ii 1 -min 0 -max $numFaces $gMainProgressBar;
for ($y=0;$y<$numFaces;$y++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	select -r ($sel[0]+".f["+$y+"]");
	ConvertSelectionToVertices;
	$weightJoints=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster`;
	$faceVtxs=`ls -sl -fl`;
	for ($a=0;$a<size($faceVtxs);$a++)
		{
		select $faceVtxs[$a];
		for ($z=0;$z<size($weightJoints);$z++)
			{
			if ($z==0) clear $jointWeights;
			$jointWeights[$z]+=`skinPercent -ignoreBelow 0.001 -t $weightJoints[$z] -q -v $skinCluster`;
			}
		}

	$biggestJointWeight=0;
	for ($z=0;$z<size($weightJoints);$z++)
		{
		if ($jointWeights[$z]>$biggestJointWeight)
			{
			$biggestJointWeight=$jointWeights[$z];
			$infs[$y]=$weightJoints[$z];
			}
		}
	}
select -cl;

for ($i=0;$i<size($infJoints);$i++)
	{
	$faceCtrlName=`substitute "Joint" $infJoints[$i] ""`;
	$isFaceCtrl=0;
	if (`objExists $faceCtrlName`)
		if (`objExists FaceControlSet`)
			if (`sets -im FaceControlSet $faceCtrlName`)
				$isFaceCtrl=1;
	if (`objExists ("FK"+$infJoints[$i])` && !`gmatch $infJoints[$i] "*Part[0-9]*"`)
		$infJointCtrls[$i]="FK"+$infJoints[$i];
	else if ($isFaceCtrl)
		$infJointCtrls[$i]=$faceCtrlName;
	else
		{
		$joint=$infJoints[$i];
		for ($y=0;$y<99;$y++)
			{
			if (!`objExists $joint`)
				{
				print ("// Found no ctrl for:"+$infJoints[$i]+"\n");
				stringArrayRemove {$infJoints[$i]} $infJoints;
				break;
				}
			$tempString=`listRelatives -p $joint`;
			$joint=$tempString[0];
			if (`objExists ("FK"+$joint)` && !`gmatch $joint "*Part[0-9]*"`)
				{
				$infJointCtrls[$i]="FK"+$joint;
				$y=99;
				}
			}
		}
	}
string $infJointCtrls2[]=`stringArrayRemoveDuplicates $infJointCtrls`;
for ($i=0;$i<size($infJointCtrls2);$i++)
	{
	select -cl;
	for ($q=0;$q<size($infJoints);$q++)
		{
		if ($infJointCtrls[$q]!=$infJointCtrls2[$i])
			continue;
		for ($y=0;$y<$numFaces;$y++)
			{
			if ($infs[$y]==$infJoints[$q])
				select -add ($sel[0]+".f["+$y+"]");
			}
		}
	$tempString=`ls -sl`;
	if ($tempString[0]=="")
		continue;
	select -add $infJointCtrls2[$i];
	refresh;
	asCreateControlMesh;

	}

if (`objExists controlMeshBatch`) delete controlMeshBatch;
}

global proc asCreateIKControlMeshes ()
{
if (!`objExists ControlSet`)
	error "ControlSet not found";
float $scale=`asGetScale`;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[],$curveShapes[];
string $controlSetMembers[]=`sets -q ControlSet`;
string $meshCtrl;
asFitModeEnsureShaders;
if (`objExists tempTG`) delete tempTG;
createNode -n tempTG transformGeometry;
setAttr tempTG.invertTransform 1;
asEnsureMainCtrlVisAttrs;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (`gmatch $controlSetMembers[$i] "FK*"` && !`gmatch $controlSetMembers[$i] "FKIK*"`)
		continue;
	$curveShapes=`listRelatives -s -type nurbsCurve $controlSetMembers[$i]`;
	for ($y=0;$y<size($curveShapes);$y++)
		{
		if (`gmatch $curveShapes[$y] "Pole*"`)
			$tempString=`extrude -ch 0 -rn false -po 0 -et 0 -upn 0 -d 0 0 1 -length ($scale*0.1) -rotation 0 -scale 1 -dl 3 $curveShapes[$y]`;
		else
			$tempString=`extrude -ch 0 -rn false -po 0 -et 0 -upn 1 -length ($scale*0.1) -rotation 0 -scale 1 -dl 3 $curveShapes[$y]`;
		$tempString2=`nurbsToPoly -mnd 1 -ch 0 -f 3 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0.01 -es 0 -ntr 0 -mrt 0 -uss 1 $tempString[0]`;
		delete $tempString[0];
		$tempString3=`listRelatives -s $tempString2[0]`;
		$tempString4[0]=`createNode mesh`;
		$tempString5=`listRelatives -p $tempString4[0]`;
		connectAttr -f ($tempString3[0]+".outMesh") tempTG.inputGeometry;
		if (!`isConnected ($controlSetMembers[$i]+".worldMatrix[0]") tempTG.transform`)
			connectAttr -f ($controlSetMembers[$i]+".worldMatrix[0]") tempTG.transform;
		connectAttr -f tempTG.outputGeometry ($tempString4[0]+".inMesh");
		for ($z=0;$z<99;$z++)
			{
			if ($z==0) $meshCtrl=$controlSetMembers[$i]+"MeshCtrl";
			else $meshCtrl=$controlSetMembers[$i]+"MeshCtrl"+$z;
			if (!`objExists $meshCtrl`)
				break;
			}
		rename $tempString4[0] $meshCtrl;
		parent -add -s $meshCtrl $controlSetMembers[$i];
		delete $tempString5[0];
		delete $tempString2[0];
		sets -e -forceElement initialShadingGroup $meshCtrl;

		setAttr ($meshCtrl+".castsShadows") 0;
		setAttr ($meshCtrl+".receiveShadows") 0;
		setAttr ($meshCtrl+".motionBlur") 0;
		setAttr ($meshCtrl+".primaryVisibility") 0;
		setAttr ($meshCtrl+".smoothShading") 0;
		setAttr ($meshCtrl+".visibleInReflections") 0;
		setAttr ($meshCtrl+".visibleInRefractions") 0;

		connectAttr -f Main.ctrlMeshVis ($meshCtrl+".v");
		$tempString=`listRelatives -s -type nurbsCurve $controlSetMembers[$i]`;
		if ($tempString[0]!="")
			{
			$tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
			if ($tempString2[0]=="")
				connectAttr -f Main.ctrlCurveVis ($tempString[0]+".v");
			}
		$overrideColor=`getAttr ($curveShapes[$y]+".overrideColor")`;
		if ($overrideColor==13) sets -e -forceElement asRedSG $meshCtrl;
		if ($overrideColor==15 || $overrideColor==6) sets -e -forceElement asBlueSG $meshCtrl;
		if ($overrideColor==17 || $overrideColor==22) sets -e -forceElement asGreen2SG $meshCtrl;

		}
	}
if (`objExists tempTG`) delete tempTG;
}

global proc asEnsureMainCtrlVisAttrs ()
{
if (!`attributeExists ctrlCurveVis Main`)
	{
	addAttr -k 1 -ln ctrlCurveVis -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.ctrlCurveVis;
	}
if (!`attributeExists ctrlMeshVis Main`)
	{
	addAttr -k 1 -ln ctrlMeshVis -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.ctrlMeshVis;
	}
}

global proc asDeleteControlMesh ()
{
string $sel[]=`ls -sl`;
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -type mesh -s $sel[$i]`;
	if (size($tempString))
		delete $tempString;
	}
}

global proc asDeleteAllControlMesh ()
{
string $tempString[]=`ls "*MeshCtrl*" "FK*_*MCTransformGeometry*" "FK*_*MCDeleteComponent*"`;
if (size($tempString))
	delete $tempString;
}

global proc asSetBuildPose (string $uiName)
{
string $controlsSet="ControlSet";
string $fitSkeleton="FitSkeleton";
string $buildPose="buildPose";
if ($uiName=="faceSetup")
	{
	$controlsSet="FaceControlSet";
	$fitSkeleton="FaceFitSkeleton";
	$buildPose="faceBuildPose";
	}
string $controlSetMembers[]=`sets -q $controlsSet`;
string $objAttr,$runCmd,$buildPoseCmd,$newRunCmds;
float $poseValue,$currentValue;
float $runValues[];
string $tempString[],$tempString2[],$runObjAttrs[],$checkObjAttr[];
if (`objExists $fitSkeleton`)
	if (`attributeExists run $fitSkeleton`)
		{
		$runCmd=`getAttr ($fitSkeleton+".run")`;
		$runCmd=`substituteAllString $runCmd "\"" ""`;
		}
if ($runCmd!="")
	tokenize $runCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
	$runValues[size($runValues)]=$tempString2[2];
	}

$buildPoseCmd=`getAttr ($buildPose+".udAttr")`;
tokenize $buildPoseCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	int $loopTimes=0;
	if ($tempString2[0]=="setAttr")
		{
		$objAttr=$tempString2[1];
		$poseValue=$tempString2[2];
		$loopTimes=1;
		$checkObjAttr[0]=$objAttr;
		}
	else if ($tempString2[0]=="xform")
		{
		$loopTimes=9;
		$obj=$tempString2[size($tempString2)-1];
		$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
		$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
		$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
		$poseValue=0;
		}
	for ($z=0;$z<$loopTimes;$z++)
		{
		$currentValue=`getAttr $checkObjAttr[$z]`;
		if($z>5) $poseValue=1;//scale
		//actual poseValue might come from the run attribute//
		for ($y=0;$y<size($runObjAttrs);$y++)
			if ($checkObjAttr[$z]==$runObjAttrs[$y])
				$poseValue=$runValues[$y];

		if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
			$newRunCmds+="setAttr "+$checkObjAttr[$z]+" "+$currentValue+";";
		}
	}

if ($newRunCmds=="")
	{
	print "// No changes to the build pose detected\n";
	return;
	}

string $m="Set the following as default values ?\n\n"+`substituteAllString $newRunCmds ";" "\n"`;
string $confirmResult=`confirmDialog -t Confirm -m $m -b "Ok" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Ok")
	return;
if (!`attributeExists run $fitSkeleton`)
	addAttr -ln run -dt "string" $fitSkeleton;
setAttr -type "string" ($fitSkeleton+".run") ($runCmd+";"+$newRunCmds);
}

global proc asfileBrowse (string $tool, string $action)
{
string $fc,$ft;
int $mode=0;
if ($action=="Open")
	{
	$fc="asOpen "+$tool;
	$ft="mel";
	}
if ($action=="SaveAs")
	{
	$fc="asSaveAs "+$tool;
	$ft="mel";
	$mode=1;
	}
if ($action=="Import")
	{
	$fc="as"+$tool+"BackgroundImport";
	$ft="*";
	}
if (`asMayaVersionAsFloat`>=2011)
	eval ($fc+" \""+`fileDialog -dm ("*."+$ft) -m $mode`+"\" "+"fileType");
else
	{
	if (`about -win`)
		fileBrowserDialog -m $mode -fc $fc -ft $ft -an $action;
	else
		fileBrowser $fc $action $ft $mode;
	}
}

global proc astoShelf (string $tool)
{
global string $gShelfTopLevel;
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
if ($projectName=="untitled")
	error "Can not put \"untitled\" on shelf, save your project first\n";

string $cmd="source \""+$projectPath+$projectName+".mel\";";
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
$icon=$projectPath+$projectName+"/"+$projectName+"_background32"+$ext;
string $setParent=`setParent -q`;
if (`tabLayout -exists $gShelfTopLevel`)
	{
	string $currentShelf=`tabLayout -query -selectTab $gShelfTopLevel`;
	setParent $currentShelf;
	shelfButton -c $cmd -ann ($tool+":"+$projectName) -label ($tool+":"+$projectName) -i1 $icon
		-st`shelfLayout -query -style $currentShelf`
		-width `shelfLayout -query -cellWidth $currentShelf`
		-height `shelfLayout -query -cellHeight $currentShelf`;
	}
setParent $setParent;
}

global proc string asUniqueFile (string $file)
{
// Copies given file to a random named file, to avoid fileNode cache
string $buffer[];
int $numTok=`tokenize $file "/" $buffer`;
string $path="";
if (`gmatch $file "/*"`)
	$path="/";
for ($i=0;$i<($numTok-1);$i++)
	$path+=$buffer[$i]+"/";
$numTok=`tokenize $file "." $buffer`;
string $ext=$buffer[$numTok-1];
string $randNumber=`rand 42`;
string $uniqueFile=$path+"unique"+`substituteAllString $randNumber "." ""`+"."+$ext;
sysFile -cp $uniqueFile $file;
return $uniqueFile;
}

global proc string[] asGetControlSets ()
{
string $controlSets[];
string $sets[]=`ls -type objectSet`;
for ($i=0;$i<size($sets);$i++)
	{
	if (!`sets -q -r $sets[$i]` && !`sets -q -v $sets[$i]` && !`sets -q -eg $sets[$i]` && !`sets -q -fc $sets[$i]` && !`sets -q -ep $sets[$i]`)
		if (`gmatch $sets[$i] "*[c-C]ontrol[s-S]et*"`)
			$controlSets[size($controlSets)]=$sets[$i];
	}
return $controlSets;
}


//-- AS IO Procedures (for tools) Starts Here --//
global proc int asOpen (string $tool, string $fileName, string $fileType)
{
global int $asfileLoading;
string $sel[]=`ls -sl`;
select -cl;
string $projectName=`basename $fileName ".mel"`;
string $projectPath=`dirname $fileName`+"/";
string $asIconLocation=$projectPath+$projectName+"/";
int $anim;
string $bgExt=".tga";
if (`about -mac`)
	$bgExt=".iff";

//if ($tool=="Poser")
//	asPoserDesigner;

evalEcho ("source \""+$fileName+"\";\n"
	+"as"+$tool+$projectName);
window -e -i 1 ("as"+$tool+$projectName);

if ($tool=="Poser")
	{
	$asfileLoading=1;
	string $gridOrder[]=`gridLayout -q -go ("asPoser"+$projectName+"GridLayout")`;
	int $nc=`gridLayout -q -nc ("asPoser"+$projectName+"GridLayout")`;
	int $nr=`gridLayout -q -nr ("asPoser"+$projectName+"GridLayout")`;
	intField -e -v $nc asPoserNc;
	intField -e -v $nr asPoserNr;
	asPoserUpdateGrid;
	int $childNum,$lenght;
	string $uiName="asPoserDefault";
	string $loadData[];
	$loadData[0]=$uiName;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] ("asPoser"+$projectName+"ColumnLayout*")`)
			{
			$image=`iconTextButton -q -i ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$loadData[1]=$image;
//			$label=`iconTextButton -q -l ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$label=`text -q -l ("asPoser"+$projectName+"Text"+$childNum)`;
			$loadData[2]=$label;
			$cmd=`iconTextButton -q -c ("asPoser"+$projectName+"IconTextButton"+$childNum)`;
			$cmd=`substitute ("asPoser"+$projectName)  ("\""+$cmd+"\"") $uiName`;
			$lenght=size($cmd);
			$loadData[3]=`substring $cmd 2 ($lenght-1)`;
			$loadData[4]=$childNum;
			$anim=0;
			if (!`gmatch $cmd "*asSetAttrs *"`)
				$anim=1;
			$loadData[5]=$anim;
			asNewPose $loadData $anim;
			}
		}
	evalDeferred ("deleteUI as"+$tool+$projectName);
	}
if ($tool=="Selector")
	{
	asSelectorDesigner;
	$asfileLoading=1;
	
	window -e -w `window -q -w ("asSelector"+$projectName)` -h `window -q -h ("asSelector"+$projectName)` asSelectorDefault;
	asSelectorBackgroundImport ($asIconLocation+$projectName+"_background"+$bgExt) "image";
	
	int $width,$height,$msg0AsInt,$msg1AsInt;
	string $iol;
	string $buffer[],$msgs[];
	//restore controlSets
	string $controlSetsText,$controlSets[];
	if (`text -q -ex ("asSelector"+$projectName+"ControlSetsText")`)
		{
		$controlSetsText=`text -q -l ("asSelector"+$projectName+"ControlSetsText")`;
		$controlSets=`stringToStringArray $controlSetsText " "`;
		if (`menuItem -q -ex ControlSet`)
			menuItem -e -cb 0 ControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if (`menuItem -q -ex $controlSets[$i]`)
				menuItem -e -cb 1 $controlSets[$i];
		}

	string $ctls[]=`formLayout -q -ca ("asSelector"+$projectName+"FormLayout")`;
	int $mirrorButtons=`optionVar -q asSelectorMirrorButtons`;
	optionVar -iv asSelectorMirrorButtons 0;
	for ($ctl in $ctls)
		if (`iconTextButton -q -ex $ctl` && !`gmatch $ctl "*BGPicture"`)
			{
			tokenize $ctl ":" $buffer;
			$msg0AsInt=$msgs[0]=$buffer[size($buffer)-2];
			$msg1AsInt=$msgs[1]=$buffer[size($buffer)-1];
			$width=`iconTextButton -q -w $ctl`;
			$height=`iconTextButton -q -h $ctl`;
			$iol=`iconTextButton -q -iol $ctl`;
			$cmd=`iconTextButton -q -c $ctl`;
			$cmd=`substitute ("\""+$projectName+"\"") (""+$cmd) "\"Default\""`;
			$buttonName=`substitute $projectName $ctl ""`;
			$ann=`iconTextButton -q -ann $ctl`;
			$msgs[2]=$iol;
			$msgs[3]=$cmd;
			$msgs[4]=$buttonName;
			$msgs[6]=$ann;
			renameUI $ctl ("deleteMeUI"+$ctl);
			asSelectorDpc "asSelectorBGImage"  "asSelectorBGImage" $msgs ($msg0AsInt+$width-4) ($msg1AsInt+$height-5) 2;
			}
	optionVar -iv asSelectorMirrorButtons $mirrorButtons;
	evalDeferred -lp asSelectorRefresh;
	}

//evalDeferred ("deleteUI as"+$tool+$projectName);
text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");
$asfileLoading=0;
select $sel;

return 1;
}

global proc int asSaveAs (string $tool, string $fileName, string $fileType)
{
if ($fileName=="")
	return 0;
string $sel[]=`ls -sl`;
string $projectName;
string $buffer[];
int $numFileNameChar=size ($fileName);
tokenize $fileName "/" $buffer;
string $file=$buffer[size($buffer)-1];
int $numFileChar=size ($file);
tokenize $file "." $buffer;
$projectName=$buffer[0];
string $tempTrn=`createNode transform`;
$projectName=`createNode -p $tempTrn -n $projectName transform`;
delete $tempTrn;
tokenize $projectName "|" $buffer;
$projectName=$buffer[size($buffer)-1];
string $projectPath=`substring $fileName 1 ($numFileNameChar-$numFileChar)`;

string $previousProjectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $previousProjectName=`text -q -l ("as"+$tool+"ProjectName")`;

text -e -l $projectPath ("as"+$tool+"ProjectPath");
text -e -l $projectName ("as"+$tool+"ProjectName");
asSave $tool;

select $sel;
return 1;
}

global proc asSave (string $tool)
{
if (`text -q -l ("as"+$tool+"ProjectName")`=="untitled")
	{
	asfileBrowse $tool "SaveAs";
	return;
	}
string $projectPath=`text -q -l ("as"+$tool+"ProjectPath")`;
string $projectName=`text -q -l ("as"+$tool+"ProjectName")`;
string $projectFile=$projectPath+$projectName+".mel";
string $installFile=$projectPath+$projectName+"/install.mel";
string $asIconLocation=$projectPath+$projectName+"/";
string $ext=".xpm";
string $bgExt=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=$bgExt=".png";
if (`about -linux`)
	$ext=".xpm";
string $tmpDir=`asGetTempDirectory`;
string $tmpIconDir=$tmpDir+"AdvancedSkeleton/"+$tool+"/untitled/";
string $uiName="as"+$tool+$projectName;
string $bgc;
string $buffer[];
string $fDet="";
$fDet+="//This file has been generated by AdvancedSkeleton"+$tool+"//\n";
$fDet+="//Using AdvancedSkeleton Version: "+`asGetScriptVersion`+"//\n";
$fDet+="\n";
$fDet+="global proc "+$uiName+" ()\n";
$fDet+="{\n";
$fDet+="if (`window -q -ex "+$uiName+"`)\n";
$fDet+="\tdeleteUI "+$uiName+";\n";
$fDet+="\n";
$fDet+="string $asSelectorScriptLocation=`asSelectorScriptLocation`;\n";
$fDet+="string $asIconLocation=$asSelectorScriptLocation+\""+$projectName+"/\";\n";
$fDet+="window -rtf 1 -mb 1 -t "+$projectName+" "+$uiName+";\n";
$fDet+="menu -l Edit;\n";
$fDet+="\tmenuItem -l Refresh -c \"asPopulateNameSpaceMenu "+$uiName+"\";\n";
$fDet+="\tmenuItem -l Filter -c \"asFilterNameSpaceMenuUI "+$uiName+"\";\n";
$fDet+="\tsetParent..;\n";
if ($tool=="Selector")
	{
	$fDet+="menu -l Display;\n";
	$fDet+="\tmenuItem -l Controls -c asControlsVisibilityToggle;\n";
	$fDet+="\tmenuItem -l \"Set HotKey\" -c asSetupControlVisibilityHotKeyDialog;\n";
	$fDet+="\tmenuItem -l Joints -c \"asJointsVisibilityToggle "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l GimbalLock -c \"asVisualizeGimbalLock "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Pose -aob 1;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"PosePaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Reset -c \"asGoToBuildPose "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l Mirror -c \"asMirror "+$uiName+"\";\n";
	$fDet+="\tmenuItem -optionBox 1 -c \"asMirrorOptions "+$uiName+"\";\n";
	$fDet+="\tsetParent..;\n";
	$fDet+="menu -l Anim;\n";
	$fDet+="\tmenuItem -l Copy -c \"asCopyToClipBoard "+$uiName+" 1\";\n";
	$fDet+="\tmenuItem -l Paste -en 0 "+$uiName+"AnimPaste;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Clean -c \"asDeleteStaticChannels "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asAnimBake "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l SwitchFKIK -c asAutoSwitchFKIK;\n";
	$fDet+="\tmenuItem -l SwitchPivot -c asAutoSwitchPivot;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l QuickIK -c asQuickIK;\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l TwistFlip -c \"asTwistFlipUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l MoCapMatcher -c \"asMoCapMatcherUI "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Connect FaceCap\" -c \"asConnectFaceCap "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Connect MocapX\" -c \"asConnectMocapX "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Auto lipsync\" -c \"asAutoLipSyncUI "+$uiName+"\";\n";
	$fDet+="menu -l Dynamics;\n";
	$fDet+="\tmenuItem -l \"Add to selected\" -c \"asDynAdd "+$uiName+"\";\n";
	$fDet+="\tmenuItem -l \"Remove from selected\" -c \"asDynRemove "+$uiName+"\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l \"Set Initial State\" -c \"evalEcho saveInitialState -all\";\n";
	$fDet+="\tmenuItem -l \"Interactive Playback\" -c \"evalEcho InteractivePlayback\";\n";
	$fDet+="\tmenuItem -d 1;\n";
	$fDet+="\tmenuItem -l Bake -c \"asDynBake "+$uiName+"\";\n";
	$fDet+="menu -l Parent;\n";
	$fDet+="\tmenuItem -l \"Add parent constraint\" -c \"asParentAdd "+$uiName+" 0\";\n";
	$fDet+="\tmenuItem -l \"Add parent constraint (Extra)\" -c \"asParentAdd "+$uiName+" 1\";\n";
	}
$fDet+="\n";

//controlsets
string $controlSetsText;
string $menuItems[];
if (`menu -q -ex ("as"+$tool+"ControlSetsMenu")`)
	{
	$menuItems=`menu -q -ia ("as"+$tool+"ControlSetsMenu")`;
	for ($i=0;$i<size($menuItems);$i++)
		if (`menuItem -q -cb $menuItems[$i]`)
			$controlSetsText+=`menuItem -q -l $menuItems[$i]`+" ";
	}

//remove old files & copy files from `untitled`
string $fileList[];
if (`file -q -ex ($projectPath+$projectName)`)
	{
	$fileList=`getFileList -fld ($projectPath+$projectName+"/")`;
	for ($file in $fileList)
		sysFile -del ($projectPath+$projectName+"/"+$file);
	}
else
	sysFile -md ($projectPath+$projectName);
$fileList=`getFileList -fld $tmpIconDir`;
for ($file in $fileList)
	if (!`gmatch $file "*.tif"`)
		sysFile -cp ($projectPath+$projectName+"/"+`substitute ("untitled_") $file ($projectName+"_")`) ($tmpIconDir+$file);

window -e -t ($tool+"Designer :"+$projectName) ("as"+$tool+"Default");

if ($tool=="Poser")
	{
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="optionMenu -cc \"asCharChange "+$uiName+"\" "+$uiName+"OptionMenu;\n";
	$fDet+="scrollLayout "+$uiName+"ScrollLayout;\n";
	int $cw=`gridLayout -q -cw asPoserDefaultGridLayout`;
	int $ch=`gridLayout -q -ch asPoserDefaultGridLayout`;
	int $nc=`intField -q -v asPoserNc`;
	int $nr=`intField -q -v asPoserNr`;
	$fDet+="gridLayout -cw "+$cw+" -ch "+$ch+" -nc "+$nc+" -nr "+$nr+" "+$uiName+"GridLayout;\n";


	$fDet+="formLayout -e\n";
	$fDet+="	-af "+$uiName+"OptionMenu \"top\" 0\n";
	$fDet+="	-ac "+$uiName+"ScrollLayout \"top\" 0 "+$uiName+"OptionMenu\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"bottom\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"left\" 0\n";
	$fDet+="	-af "+$uiName+"ScrollLayout \"right\" 0\n";
	$fDet+="	"+$uiName+"FormLayout;\n";
	$fDet+="\n";
	$fDet+="\n";

	string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
	int $childNum,$doConnectControl;
	string $cmd,$label,$ann,$animAnn;
	for ($i=0;$i<size($gridOrder);$i++)
		{
		$childNum=$i+1;
		if (`gmatch $gridOrder[$i] "asPoser*"`)
			{
			$iconTextButton=("asPoserDefaultIconTextButton"+$childNum);
			$floatSlider=("asPoserDefaultFloatSlider"+$childNum);
			$text=("asPoserDefaultText"+$childNum);
			$label=`text -q -l $text`;
			$doConnectControl=`floatSlider -q -m $floatSlider`;
			$ann=`floatSlider -q -ann $floatSlider`;
			$cmd=`iconTextButton -q -c $iconTextButton`;
			$cmd=`substitute  "asPoserDefault" $cmd $uiName`;
			$cmd=`substitute  "untitled_" $cmd ($projectName+"_")`;
			$cmd=`encodeString $cmd`;
			$bgc="";
			if (!`gmatch $cmd "asSetAttrs *"`)
				$bgc=" -bgc 1 0 0";
			$fDet+="string $cmd=\""+$cmd+"\";\n";
			$image=`iconTextButton -q -i $iconTextButton`;
			tokenize ("\""+$image+"\"") "/" $buffer;
			tokenize $buffer[size($buffer)-1] "." $buffer;
			$imageNr=`match "[0-9]+$" $buffer[0]`;
			$animAnn=`rowColumnLayout -q -ann ("asPoserDefaultRowColumnLayout"+$childNum)`;

			$fDet+="setParent "+$uiName+"GridLayout;\n";
			$fDet+="columnLayout "+$uiName+"ColumnLayout"+$childNum+";\n";
			$fDet+="rowColumnLayout -ann "+$animAnn+" -nc 2 -cw 1 100 -cw 2 15 "+$uiName+"RowColumnLayout"+$childNum+";\n";
			$fDet+="iconTextButton -w 100 -h 75 -i ($asIconLocation+\""+$projectName+"_"+$imageNr+$ext+"\") -c $cmd "+$uiName+"IconTextButton"+$childNum+";\n";
			float $min=`floatSlider -q -min $floatSlider`;
			float $max=`floatSlider -q -max $floatSlider`;
			$fDet+="floatSlider -ann \""+$ann+"\" -m "+$doConnectControl+" -min "+$min+" -max "+$max+" -w 10 -h 75 -hr 0 "+$uiName+"FloatSlider"+$childNum+";\n";
			$fDet+="text -h 15 -al \"center\" -fn \"smallBoldLabelFont\" -l \""+$label+"\""+$bgc+" "+$uiName+"Text"+$childNum+";\n";

			//place it
			$fDet+="gridLayout -e -pos "+$uiName+"ColumnLayout"+$childNum+" "+$childNum+" "+$uiName+"GridLayout;\n";

			//popups
			$fDet+="asPoserupdateGridBlock "+$uiName+" "+$childNum+";\n";

			$fDet+="\n";
			}
		}

	$fDet+="\n";
	$fDet+="asPopulateNameSpaceMenu as"+$tool+$projectName+";\n";
	$fDet+="asCharChange "+$uiName+";\n";
	$fDet+="evalDeferred \"showWindow;\";\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}
if ($tool=="Selector")
	{
	int $pictureWidth=`text -q -l asSelectorBackgroundWidth`;
	int $pictureHeight=`text -q -l asSelectorBackgroundHeight`;
	
	string $allCtls[]=`formLayout -q -ca asSelectorDefaultFormLayout`;
	string $ctlName[],$ctlType[],$ctlWidth[],$ctlHeight[],$ctlLeft[],$ctlTop[],$ctlImage[],$ctlCmd[],$ctlIol[],$ctlAnn[];
	string $ctlKeyCmd[],$ctlLinearKeyCmd[];
	string $ctlAlignFK2IKCmd[],$ctlAlignIK2FKCmd[],$ctlSwitchFK2IKCmd[],$ctlSwitchIK2FKCmd[];
	string $buffer[],$tempString[],$menuItems[];
	int $numTok;
	string $shortImageFileName,$oldProjectName;
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$ctlName[$i]=`substitute "asSelector" $allCtls[$i] $uiName`;
		if (`image -q -ex $allCtls[$i]`)
			$ctlType[$i]="image";
		if (`iconTextButton -q -ex $allCtls[$i]`)
			$ctlType[$i]="iconTextButton";
		$ctlWidth[$i]=`control -q -w $allCtls[$i]`;
		$ctlHeight[$i]=`control -q -h $allCtls[$i]`;
		$numTok=`tokenize $allCtls[$i] ":" $buffer`;
		$ctlLeft[$i]=$buffer[$numTok-2];
		$ctlTop[$i]=$buffer[$numTok-1];
		if ($ctlType[$i]=="iconTextButton")
			{
			$ctlImage[$i]=`eval ($ctlType[$i]+" -q -i \""+$allCtls[$i]+"\"")`;
			tokenize $ctlImage[$i] "/" $buffer;
			$shortImageFileName=$buffer[size($buffer)-1];
			tokenize $shortImageFileName "_" $buffer;
			$oldProjectName=$buffer[0];
			for ($b=1;$b<size($buffer)-3;$b++)
				$oldProjectName+="_"+$buffer[$b];
			$ctlImage[$i]=`substitute ($oldProjectName+"_") $shortImageFileName ($projectName+"_")`;
			$ctlCmd[$i]=`eval ($ctlType[$i]+" -q -c \""+$allCtls[$i]+"\"")`;
			$ctlCmd[$i]=`substitute "\"Default\"" $ctlCmd[$i] ("\""+$projectName+"\"")`;
			$ctlCmd[$i]="\""+`encodeString $ctlCmd[$i]`+"\"";
			$ctlAnn[$i]=`eval ($ctlType[$i]+" -q -ann \""+$allCtls[$i]+"\"")`;
			$ctlIol[$i]=`eval ($ctlType[$i]+" -q -iol \""+$allCtls[$i]+"\"")`;
			$tempString=`eval ($ctlType[$i]+" -q -pma \""+$allCtls[$i]+"\"")`;
			$menuItems=`popupMenu -q -ia $tempString[0]`;
			$ctlKeyCmd[$i]=`menuItem -q -c $menuItems[0]`;
			$ctlKeyCmd[$i]=`substitute "\"Default\"" $ctlKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlKeyCmd[$i]="\""+`encodeString $ctlKeyCmd[$i]`+"\"";
			$ctlLinearKeyCmd[$i]=`menuItem -q -c $menuItems[1]`;
			$ctlLinearKeyCmd[$i]=`substitute "\"Default\"" $ctlLinearKeyCmd[$i] ("\""+$projectName+"\"")`;
			$ctlLinearKeyCmd[$i]="\""+`encodeString $ctlLinearKeyCmd[$i]`+"\"";
			if (size($menuItems)>6)
				{
				$subMenuItems=`menu -q -ia $menuItems[5]`;
				$ctlAlignFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlAlignFK2IKCmd[$i]=`substitute "\"Default\"" $ctlAlignFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignFK2IKCmd[$i]="\""+`encodeString $ctlAlignFK2IKCmd[$i]`+"\"";
				$ctlAlignIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlAlignIK2FKCmd[$i]=`substitute "\"Default\"" $ctlAlignIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlAlignIK2FKCmd[$i]="\""+`encodeString $ctlAlignIK2FKCmd[$i]`+"\"";
				$subMenuItems=`menu -q -ia $menuItems[6]`;
				$ctlSwitchFK2IKCmd[$i]=`menuItem -q -c $subMenuItems[0]`;
				$ctlSwitchFK2IKCmd[$i]=`substitute "\"Default\"" $ctlSwitchFK2IKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchFK2IKCmd[$i]="\""+`encodeString $ctlSwitchFK2IKCmd[$i]`+"\"";
				$ctlSwitchIK2FKCmd[$i]=`menuItem -q -c $subMenuItems[1]`;
				$ctlSwitchIK2FKCmd[$i]=`substitute "\"Default\"" $ctlSwitchIK2FKCmd[$i] ("\""+$projectName+"\"")`;
				$ctlSwitchIK2FKCmd[$i]="\""+`encodeString $ctlSwitchIK2FKCmd[$i]`+"\"";
				}
			}
		}

	$fDet+="columnLayout -adj 1;\n";
	$fDet+="text -m 0 -l \""+$controlSetsText+"\" "+$uiName+"ControlSetsText;\n";
	$fDet+="rowLayout -nc 5 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 65 -cw 4 50 -cw 5 60;\n";
	$fDet+="optionMenu -cc asSelChange "+$uiName+"OptionMenu;\n";
	$fDet+="button -l set -c \"asSetNameSpaceFromSelection "+$uiName+"\";\n";
	$fDet+="checkBox -v `optionVar -q asShowSelection` -onc \"optionVar -iv asShowSelection 1;asSelChangeToggle;\" -ofc \"optionVar -iv asShowSelection 0;asSelChangeToggle;\" -l Selection "+$uiName+"SelectionCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowKeyed` -onc \"optionVar -iv asShowKeyed 1;asSelChangeToggle;\" -ofc \"optionVar -iv asShowKeyed 0;asSelChangeToggle;\" -l Keyed "+$uiName+"KeyedCheckBox;\n";
	$fDet+="checkBox -v `optionVar -q asShowExtra` -onc \"optionVar -iv asShowExtra 1;asSelChangeToggle;\" -ofc \"optionVar -iv asShowExtra 0;asSelChangeToggle;\" -l Extra "+$uiName+"ExtraCheckBox;\n";
	$fDet+="setParent..;\n";
	$fDet+="formLayout "+$uiName+"FormLayout;\n";
	$fDet+="\n";

	$fDet+="//Controls Begin//\n";
	if (`about -mac` || `about -linux`)
		$fDet+="iconTextButton -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	else
		$fDet+="image -en 0 -w "+$pictureWidth+" -h "+$pictureHeight+" -i ($asIconLocation+\""+$projectName+"_background"+$bgExt+"\") \""+$uiName+"BGPicture\";\n";
	for ($i=0;$i<size($allCtls);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+=$ctlType[$i]+" -w "+$ctlWidth[$i]+" -h "+$ctlHeight[$i];
		if ($ctlImage[$i]!="")
			$fDet+=" -i ($asIconLocation+\""+$ctlImage[$i]+"\")";
		if ($ctlImage[$i]!="")
			$fDet+=" -iol \""+$ctlIol[$i]+"\"";
		if ($ctlCmd[$i]!="")
			$fDet+=" -c "+$ctlCmd[$i];
		if ($ctlAnn[$i]!="")
			$fDet+=" -ann \""+$ctlAnn[$i]+"\"";
		$fDet+=" \""+$ctlName[$i]+"\";\n";
		$fDet+="popupMenu;\n";
		$fDet+="\tmenuItem -l Key -c "+$ctlKeyCmd[$i]+";\n";
		$fDet+="\tmenuItem -l LinearKey -c "+$ctlLinearKeyCmd[$i]+";\n";
		if ($ctlAlignFK2IKCmd[$i]!="")
			{
			$fDet+="\tmenuItem -d 1;\n";
			$fDet+="\tmenuItem -l Align -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlAlignFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlAlignIK2FKCmd[$i]+";\n";
			$fDet+="\t\tsetParent -menu ..;\n";
			$fDet+="\tmenuItem -l Switch -sm 1;\n";
			$fDet+="\t\tmenuItem -l FK2IK -c "+$ctlSwitchFK2IKCmd[$i]+";\n";
			$fDet+="\t\tmenuItem -l IK2FK -c "+$ctlSwitchIK2FKCmd[$i]+";\n";
			}
		}
	$fDet+="//Controls End//\n";
	$fDet+="\n";
	$fDet+="formLayout -e\n";
	for ($i=0;$i<size($ctlType);$i++)
		{
		if ($allCtls[$i]=="asSelectorDefaultBGPicture")
			continue;
		$fDet+="\t-af \""+$ctlName[$i]+"\" left "+$ctlLeft[$i]+"\n";
		$fDet+="\t-af \""+$ctlName[$i]+"\" top "+$ctlTop[$i]+"\n";
		}
	$fDet+="\t"+$uiName+"FormLayout;\n";
	
	$fDet+="\n\n\n\n";
	
	$fDet+="asPopulateNameSpaceMenu \"asSelector"+$projectName+"\";\n";
	$fDet+="asShowSelJob;\n";
	$fDet+="asSelChange;\n";
	$fDet+="showWindow;\n";
	$fDet+="}\n"+$uiName+";\n\n";
	}

string $AdvancedSkeleton5File=`asGetScriptLocation`+"/AdvancedSkeleton5.mel";
int $fileId2=`fopen $AdvancedSkeleton5File "r"`;
string $nextLine = `fgetline $fileId2`;
int $copyLines=0;
while (size($nextLine)>0)
	{
	$nextLine=`fgetline $fileId2`;
	if ($nextLine=="//-- ASTools Procedures Starts Here --//\n")
		$copyLines=1;
	if (!$copyLines)
		continue;
	$fDet+=$nextLine;
	if ($nextLine=="//-- ASTools Procedures Ends Here --//\n")
		break;
	}
fclose $fileId2;

int $fileId=`fopen $projectFile "w"`;
fprint $fileId $fDet;
fclose $fileId;

//$installFile
$fDet="";
string $AdvancedSkeletonInstallFile=`asGetScriptLocation`+"/install.mel";
if (!`file -q -ex $AdvancedSkeletonInstallFile`)
	return;
$fileId=`fopen $AdvancedSkeletonInstallFile "r"`;
$nextLine = `fgetline $fileId`;
int $installTemplatePause;
while ( size( $nextLine ) > 0 )
	{
	$nextLine = `fgetline $fileId`;
	if ($nextLine=="//--installTemplate pause--//\n")
		$installTemplatePause=1;
	if ($nextLine=="//--installTemplate resume--//\n")
		{
		$installTemplatePause=0;
		continue;
		}
	if ($installTemplatePause)
		continue;
	if (`gmatch $nextLine "string $scriptName=*"`)
		{
		$fDet+=("string $scriptName=\""+$projectName+"\";\n");
		}
	else if (`gmatch $nextLine "string $sourceFile=*"`)
		{
		$fDet+=("string $sourceFile=$asInstallScriptLocation+\"../\"+$scriptName+\".mel\";\n");
		}
	else if (`gmatch $nextLine "string $icon=*"`)
		{
		$fDet+=("string $icon=$asInstallScriptLocation+\""+$projectName+"_background32.png\";\n");
		}
	else if (`gmatch $nextLine "string $command=*"`)
		{
		$fDet+=("string $command=\"source \\\"\"+$sourceFile+\"\\\"\";\n");
		}
	else
		$fDet+=$nextLine;
	}
fclose $fileId;

$fileId=`fopen $installFile "w"`;
fprint $fileId $fDet;
fclose $fileId;
}
//-- AS IO Procedures (for tools) Ends Here --//


//-- ASTools Procedures Starts Here --//
global proc asSelChange ()
{
global int $asfileLoading;
global int $asSelChangeSwitching;
if ($asfileLoading)
	return;
if (!`optionVar -q asShowSelection` && !`optionVar -q asShowKeyed` && !$asSelChangeSwitching)
	return;
int $undoState=`undoInfo -q -state`;
string $sel[]=`ls -sl`;
string $name,$obj,$nodeType,$projectName,$ann;
string $ctls[],$buffer[],$connections[];
int $numLetters,$numTok,$keyed;
string $ext=".xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext=".png";
if (`about -linux`)
	$ext=".xpm";
string $currImage,$buttonImageFile,$buttonImageFileOnK0,$buttonImageFileOnK1,$buttonImageFileOffK0,$buttonImageFileOffK1;
string $windows[]=`lsUI -windows`;
string $layout;
for ($window in $windows)
	{
	$layout="";
	if (size($window)>11)
		$layout="asSelector"+`substring $window 11 999`+"FormLayout";
	if (!`formLayout -q -ex $layout`)
		continue;
	$numLetters=size($layout);
	$name=`substring $layout 11 ($numLetters-10)`;
	$ctls=`formLayout -q -ca $layout`;
	for ($ctl in $ctls)
		{
		if (!`iconTextButton -q -ex $ctl`)
			continue;
		if (`optionVar -q asShowSelection` && !$asSelChangeSwitching)
			$selState="On";
		else
			$selState="Off";
		$keyed=0;
		$ann=`iconTextButton -q -ann $ctl`;
		$numTok=`tokenize $ann ";" $buffer`;
		for ($i=0;$i<$numTok;$i++)
			{
			$obj=`asSelectorResolveNameSpace $name $buffer[$i]`;
			if (!`stringArrayCount $obj $sel`)
				$selState="Off";
			if (`optionVar -q asShowKeyed` && !$asSelChangeSwitching && `objExists $obj`)
				{
				$connections=`listConnections -s 1 -d 0 $obj`;
				for ($node in $connections)
					{
					$nodeType=`objectType $node`;
					if (`gmatch $nodeType "animCurve*"`)
						$keyed=1;
					}
				}
			}

		$currImage=`iconTextButton -q -i1 $ctl`;
		if ($currImage=="")
			return;
		$numTok=`tokenize $currImage "_" $buffer`;
		if ($numTok<3)
			continue;
		$projectName=$buffer[0];
		for ($b=1;$b<size($buffer)-3;$b++)
			$projectName+="_"+$buffer[$b];
		$buttonImageFile=$projectName+"_"+$buffer[$numTok-3]+"_"+$buffer[$numTok-2]+"_"+$selState+"K"+$keyed+$ext;

		if ($buttonImageFile!=$currImage)
			iconTextButton -e -i $buttonImageFile $ctl;		
		}
	}

//PickerSelChange
if (!`optionMenu -q -ex asPickerOptionMenu`)
	return;
int $selectedTabIndex,$overrideColor;
string $picCtrls[],$selPicCtrls[],$selChrCtrls[],$tabLabels[];
string $picNs,$chrNs,$picCtrl,$chrCtrl;

if (`optionMenu -q -ex asPickerOptionMenu`)
	$chrNs=`optionMenu -q -v asPickerOptionMenu`;
if ($chrNs==":")
	$chrNs="";
if (`tabLayout -q -ex asPickerTabLayout`)
	{
	$tabLabels=`tabLayout -q -tl asPickerTabLayout`;
	$selectedTabIndex=`tabLayout -q -selectTabIndex asPickerTabLayout`;
	$picNs="picker_"+$tabLabels[$selectedTabIndex-1]+":";
	}
$picCtrls=`ls -type transform ($picNs+"*")`;
$selPicCtrls=`ls -sl -type transform ($picNs+"*")`;
$selChrCtrls=`ls -sl -type transform ($chrNs+"*")`;

//All .overrideColor==0 off first
if ($undoState) undoInfo -stateWithoutFlush 0;

for ($i=0;$i<size($picCtrls);$i++)
	{
	$overrideColor=0;
	$chrCtrl=`substitute $picNs $picCtrls[$i] $chrNs`;
	if (`optionVar -q asShowExtra`) $chrCtrl=`substitute "FK" $chrCtrl "FKExtra"`;
	if (`objExists $chrCtrl`)
		if (`optionVar -q asShowKeyed` && `asHaveAnimation $chrCtrl`)
			$overrideColor=13;
	setAttr ($picCtrls[$i]+".overrideColor") $overrideColor;
	}

if (!size($selPicCtrls) && !size($selChrCtrls))
	{
	if ($undoState) undoInfo -stateWithoutFlush 1;
	return;
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (`optionVar -q asShowSelection`)
		$overrideColor=14;
	if (`gmatch $sel[$i] ($picNs+"*")`) // $picNs > $chrNs
		{
		$chrCtrl=`substitute $picNs $sel[$i] $chrNs`;
		if (`optionVar -q asShowExtra`) $chrCtrl=`substitute "FK" $chrCtrl "FKExtra"`;
		if (`objExists $chrCtrl` && `optionVar -q asShowSelection`)
			{
			select -d  $sel[$i];
			select -add $chrCtrl;
			if (`optionVar -q asShowKeyed` && `asHaveAnimation $chrCtrl`)
				$overrideColor=13;
			setAttr ($sel[$i]+".overrideColor") $overrideColor;
			}
		else
			print ("// "+$chrCtrl+" not found.\n");
		}
	if (`gmatch $sel[$i] ($chrNs+"*")`) // $chrNs > $picNs
		{
		if ($chrNs=="")
			$picCtrl=$picNs+$sel[$i];
		else
			$picCtrl=`substitute $chrNs $sel[$i] $picNs`;
		if (`optionVar -q asShowExtra`)
			{
			if (!`gmatch $picCtrl "*Extra*"`) continue;
			$picCtrl=`substitute "FKExtra" $picCtrl "FK"`;
			}
		if (`objExists $picCtrl`)
			setAttr ($picCtrl+".overrideColor") $overrideColor;
		}
	}
if ($undoState) undoInfo -stateWithoutFlush 1;
}

global proc asFL ()
{
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "as*FrameLayout"`)
		optionVar -iv $framLayouts[$i] `frameLayout -q -cl $framLayouts[$i]`;
}

global proc asLockAttr (string $object, int $trans, int $rot, int $scale, int $vis)
{
setAttr -l $trans -k (!$trans) ($object+".translateX");
setAttr -l $trans -k (!$trans) ($object+".translateY");
setAttr -l $trans -k (!$trans) ($object+".translateZ");
setAttr -l $rot -k (!$rot) ($object+".rotateX");
setAttr -l $rot -k (!$rot) ($object+".rotateY");
setAttr -l $rot -k (!$rot) ($object+".rotateZ");
setAttr -l $scale -k (!$scale) ($object+".scaleX");
setAttr -l $scale -k (!$scale) ($object+".scaleY");
setAttr -l $scale -k (!$scale) ($object+".scaleZ");
setAttr -l $vis -k (!$vis) ($object+".visibility");
}

global proc float asMayaVersionAsFloat ()
{
float $version=2012;
if (`about -v`=="2016 Extension 2")
	return 2016.5;
if (`exists getApplicationVersionAsFloat`)
	return `getApplicationVersionAsFloat`;
string $versionString=`about -v`;
string $tempString[];
string $char;
tokenize $versionString $tempString;
//default to 2012, if versionString is not all numbers
for ($i=0;$i<size($tempString[0]);$i++)
	{
	$char=`substring $tempString[0] ($i+1) ($i+1)`;
	if (!`gmatch $char "[0-9]"`)
		return 2012;
	}
$version=$tempString[0];
return $version;
}

global proc asSelChangeToggle ()
{
global int $asSelChangeSwitching;
$asSelChangeSwitching=1;
string $sel[]=`ls -sl`;
select -cl;
asSelChange;
$asSelChangeSwitching=0;
select $sel;
}

global proc asCharChange (string $uiName)
{
string $gridOrder[];
if (`gridLayout -q -ex ($uiName+"GridLayout")`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`floatSlider -q -ex ($uiName+"FloatSlider"+$i)`)
			{
			$ann=`floatSlider -q -ann ($uiName+"FloatSlider"+$i)`;
			$resolvedName=`asPoserResolveNameSpace $uiName $ann`;
			if (`objExists $resolvedName`)
				connectControl ($uiName+"FloatSlider"+$i) $resolvedName;
			}
	}
asSelChange;
}

global proc asShowSelJob ()
{
global int $asSelChangeScripJobNr;
if ($asSelChangeScripJobNr)
	return;
$asSelChangeScripJobNr=`scriptJob -e "SelectionChanged" "asSelChange"`;
}

global proc string asSelectorResolveNameSpace (string $name, string $obj)
{
string $nameSpace;
string $tempString[];
if (`optionMenu -q -ex ("asSelector"+$name+"OptionMenu")`)
	$nameSpace=`optionMenu -q -v ("asSelector"+$name+"OptionMenu")`;
else if (`optionMenu -q -ex ("asPickerOptionMenu")`)
	$nameSpace=`optionMenu -q -v ("asPickerOptionMenu")`;
else if (`gmatch $name "*:*"`)
	{
	tokenize $name ":" $tempString;
	for ($i=0;$i<size($tempString)-1;$i++)
		$nameSpace+=$tempString[$i]+":";
	}
if ($nameSpace==":")
	$nameSpace="";
string $extraObj;
//Extra control
if (`checkBox -q -ex ("asSelector"+$name+"ExtraCheckBox")`)
	if (`checkBox -q -v ("asSelector"+$name+"ExtraCheckBox")`)
		if (size($obj)>2)
			{
			$extraObj=`substring $obj 1 2`+"Extra"+`substring $obj 3 99`;
			if (`gmatch $obj "*RootX*"`)
				$extraObj=`substring $obj 1 4`+"Extra"+`substring $obj 5 99`;
			if (`objExists ($nameSpace+$extraObj)`)
				return ($nameSpace+$extraObj);
			}
return ($nameSpace+$obj);
}

global proc asSelect (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

int $modifier=`getModifiers`;
if (($modifier %  2)==0)
	select -cl;
if ($objs[0]=="")
	{
	select -cl;
	return;
	}
for ($obj in $objs)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
for ($obj in $objs)
	select -tgl $obj;
//enable hotKeys
string $formLayout="asSelector"+$name+"FormLayout";
if (`formLayout -q -ex $formLayout`)
	setFocus $formLayout;
}

global proc asKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe $obj;
select `ls -sl`;
asSelChange;
}

global proc asLinearKey (string $name, string $objs[])
{
for ($i=0;$i<size($objs);$i++)
	$objs[$i]=`asSelectorResolveNameSpace $name $objs[$i]`;

for ($obj in $objs)
	setKeyframe -itt linear -ott linear $obj;
select `ls -sl`;
asSelChange;
}

global proc asAlignIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "IK2FK";
}

global proc asAlignFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asAlignFKIK" "FK2IK";
}

global proc asSwitchIK2FK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "IK2FK";
}

global proc asSwitchFK2IK (string $name, string $objs[])
{
asAssembleAlignSwitchCmd $name $objs "asSwitchFKIK" "FK2IK";
}

global proc asAssembleAlignSwitchCmd (string $name, string $objs[], string $alignSwitchCmd, string $W2K)
{
global int $asBakeFKIK;
$asBakeFKIK=0;
int $numLetters=size($objs[0]);
string $IK=`substring $objs[0] 5 ($numLetters-2)`;
string $side=`substring $objs[0] ($numLetters-1) $numLetters`;
eval ($alignSwitchCmd+" "+$name+" "+$IK+" "+$side+" "+$W2K);
}

global proc asAlignFKIK (string $name, string $IK, string $side, string $W2K)
{
global int $asBakeFKIK;
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $curveCmd,$roo,$childLabel,$toesJoint,$qToesJoint,$legAimJoint;
string $tempLoc1[],$tempLoc2[],$tempConstraint[],$tempConstraintAttrs[],$chainJoints[],$tempString[],$tempString2[];
int $isSplineIK,$numIkCtrls,$cvNr,$ikNr;
float $IKCurveLenght,$dist,$stiff,$middleJointLenght,$endJointLenght;
float $pos[],$rot[],$posA[],$posB[],$tempFloat[],$alignIkToFloat[];
if (!`objExists ($nameSpace+"Pole"+$IK+$side)`)
	$isSplineIK=1;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
if ($isSplineIK)
	{
	$chainJoints=`asgetChainJoints ($nameSpace+$startJoint+$side) ($nameSpace+$endJoint+$side)`;
	for ($i=0;$i<size($chainJoints);$i++)
		$chainJoints[$i]=`substitute $nameSpace $chainJoints[$i] ""`;
	for ($i=1;$i<99;$i++)
		{
		if (!`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
			break;
		$numIkCtrls=$i;
		}
	}
else
	$requiredObj=`stringArrayCatenate $requiredObj {($nameSpace+"Pole"+$IK+$side),($nameSpace+"FKX"+$endJoint+$side)}`;
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
float $charsize=`getAttr ($nameSpace+"Main.height")`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;
if ($asBakeFKIK)
	autoKeyframe -st 1;

string $deleteObjs[]={"IK2FKTempCurve","IK2FKTempXform1","IK2FKTempXform2","IK2FKTempCurveInfo"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

//$toesJoint
if (`objExists $endJoint`)
	{
	$tempString=`listRelatives -type joint -ad $endJoint`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`getAttr ($tempString[$y]+".drawLabel")`)
			{
			$childLabel=`getAttr ($tempString[$y]+".otherType")`;
			if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*QToes*"` && !`gmatch $childLabel "*ToesEnd*"`)
				{
				$tempString2[0]=`substitute ($nameSpace+":") $tempString[$y] ""`;
				if (`objExists ($nameSpace+"FK"+$tempString2[0]+$side)`)
					$toesJoint=$tempString2[0];
				}
			}
		}
	}

if ($W2K=="FK2IK" && !$isSplineIK)
	{
	//Qtoes
	if (`objExists $endJoint`)
		{
		$tempString=`listRelatives -type joint -ad $endJoint`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`getAttr ($tempString[$y]+".drawLabel")`)
				{
				$childLabel=`getAttr ($tempString[$y]+".otherType")`;
				if (`gmatch $childLabel "*QToes*"`)
					{
					$tempString2[0]=`substitute ($nameSpace+":") $tempString[$y] ""`;
					if (`objExists ($nameSpace+"FK"+$tempString2[0]+$side)`)
						$qToesJoint=$tempString2[0];
					}
				}
			}
		}

	//Default values for RollHeel, RollToes, RollToesEnd, and UD attrs such as roll,etc
	$tempString=`listAttr -ud ($nameSpace+"IK"+$IK+$side)`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`getAttr -type ($nameSpace+"IK"+$IK+$side+"."+$tempString[$i])`=="string")
			continue;//skip any custom added string attributes
		$tempFloat=`attributeQuery -listDefault -n ($nameSpace+"IK"+$IK+$side) $tempString[$i]`;
		setAttr ($nameSpace+"IK"+$IK+$side+"."+$tempString[$i]) $tempFloat[0];
		}
	$tempString=`listRelatives -ad -type transform ($nameSpace+"IK"+$IK+$side)`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im ($nameSpace+"ControlSet") $tempString[$i]`)
			{
			setAttr ($tempString[$i]+".t") -type float3 0 0 0;
			setAttr ($tempString[$i]+".r") -type float3 0 0 0;
			}
	//zero out leg-aim & toes-aim, for easier alignment
	if (`attributeExists toesAim ($nameSpace+"IK"+$IK+$side)`) setAttr ($nameSpace+"IK"+$IK+$side+".toesAim") 0;
	if (`attributeExists legAim ($nameSpace+"IK"+$IK+$side)`) setAttr ($nameSpace+"IK"+$IK+$side+".legAim") 0;

	$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$endJoint+$side)`;
	if ($qToesJoint!="")
		$tempFloat=`xform -q -ws -t ($nameSpace+"FK"+$qToesJoint+$side)`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	$tempLoc1=`spaceLocator`;
	$tempConstraint=`pointConstraint ($nameSpace+"FKX"+$startJoint+$side) ($nameSpace+"FKX"+$endJoint+$side) $tempLoc1[0]`;
	$tempConstraintAttrs=`listAttr -ud $tempConstraint`;

	$middleJointLenght=`getAttr ($nameSpace+"FKOffset"+$middleJoint+$side+".tx")`;
	$endJointLenght=`getAttr ($nameSpace+"FKOffset"+$endJoint+$side+".tx")`;
	setAttr ($tempLoc1[0]+"_pointConstraint1."+$tempConstraintAttrs[0]) `abs($endJointLenght)`;
	setAttr ($tempLoc1[0]+"_pointConstraint1."+$tempConstraintAttrs[1]) `abs($middleJointLenght)`;
	delete $tempConstraint[0];
	$tempConstraint=`aimConstraint -aimVector 1 0 0 ($nameSpace+"FKX"+$middleJoint+$side) $tempLoc1[0]`;
	$tempLoc2=`spaceLocator`;
	parent $tempLoc2[0] $tempLoc1[0];
	setAttr -type float3 ($tempLoc2[0]+".translate") ($charsize/3.333) 0 0;
	$tempFloat=`xform -q -ws -t $tempLoc2[0]`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"Pole"+$IK+$side);
	delete $tempLoc1;
	$roo=`xform -q -roo ($nameSpace+"IK"+$IK+$side)`;
	xform -p 1 -roo $roo ($nameSpace+"AlignIKTo"+$endJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$endJoint+$side)`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$side);
	if (`objExists $toesJoint` && `objExists ($nameSpace+"AlignIKToToes"+$side)`)
		{
		if (`attributeExists "roll" ($nameSpace+"IK"+$IK+$side)`)
			setAttr ($nameSpace+"IK"+$IK+$side+".roll") 0;
		$rot=`xform -q -ws -ro ($nameSpace+"AlignIKToToes"+$side)`;
		xform -ws -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"IKToes"+$side);
		}
	}
if ($W2K=="FK2IK" && $isSplineIK)
	{
	//first do Start and End IkCtrls
	$tempFloat=`xform -q -ws -t ($nameSpace+"AlignIKTo"+$chainJoints[0])`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+"1"+$side);
	$roo=`xform -q -roo ($nameSpace+"IK"+$IK+"1"+$side)`;
	xform -p 1 -roo $roo ($nameSpace+"AlignIKTo"+$chainJoints[0]);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$chainJoints[0])`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+"1"+$side);

	$tempFloat=`xform -q -ws -t ($nameSpace+"AlignIKTo"+$chainJoints[size($chainJoints)-1])`;
	xform -ws -t $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$numIkCtrls+$side);
	$roo=`xform -q -roo ($nameSpace+"IK"+$IK+$numIkCtrls+$side)`;
	xform -p 1 -roo $roo ($nameSpace+"AlignIKTo"+$chainJoints[size($chainJoints)-1]);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"AlignIKTo"+$chainJoints[size($chainJoints)-1])`;
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"IK"+$IK+$numIkCtrls+$side);

	$curveCmd="curve -n FK2IKCurve -d 3";
	for ($i=0;$i<size($chainJoints);$i++)
		{
		$pos=`xform -q -ws-t ($nameSpace+$chainJoints[$i])`;
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		}
	eval ($curveCmd);
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 FK2IKCurve;
	if (`objExists tempPointOnCurveInfo`) delete tempPointOnCurveInfo;
	createNode -n tempPointOnCurveInfo pointOnCurveInfo;
	setAttr tempPointOnCurveInfo.turnOnPercentage 1;
	connectAttr -f FK2IKCurve.worldSpace[0] tempPointOnCurveInfo.inputCurve;

	//then do `inbeween` IkCtrls
	for ($i=2;$i<$numIkCtrls;$i++)
		{
		setAttr tempPointOnCurveInfo.parameter (($i-1.0)/($numIkCtrls-1.0));
		$pos=`getAttr tempPointOnCurveInfo.position`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($nameSpace+"IK"+$IK+$i+$side);
		}
	delete FK2IKCurve;

	//then do  IKcvCtrls
	for ($i=1;$i<size($chainJoints)-1;$i++)
		{
		$pos=`xform -q -ws -t ($nameSpace+"FKX"+$chainJoints[$i])`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($nameSpace+"IKcv"+$IK+$i+$side);
		}

	print "// Switching from FK to Curve-Based-IK, Target might not fully Align.\n";
	}
if ($W2K=="IK2FK" && !$isSplineIK)
	{
	if (`attributeExists legAim ($nameSpace+"IK"+$IK+$side)`)
		{
		$tempString=`listConnections -s 0 -d 1 ($nameSpace+"IK"+$IK+"LegAimReverse"+$side)`;
		$legAimJoint=`substitute "LegAim" $tempString[0] ""`;
		$legAimJoint=`substitute ($side+"_orientConstraint1") $legAimJoint ""`;
		if (`getAttr ($nameSpace+"IK"+$IK+$side+".legAim")`>0)
			print ("// "+$nameSpace+"IK"+$IK+$side+".legAim is On, The FKIK will not correctly Align, for better results, turn Off the \"legAim\" attribute.\n");
		}
	if (`attributeExists toesAim ($nameSpace+"IK"+$IK+$side)`)
		if (`getAttr ($nameSpace+"IK"+$IK+$side+".toesAim")`>0)
			print ("// "+$nameSpace+"IK"+$IK+$side+".toesAim is On, The FKIK will not correctly Align, for better results, turn Off the \"toesAim\" attribute.\n");

	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$startJoint+$side)`;
	xform -os -t 0 0 0 ($nameSpace+"FK"+$startJoint+$side);
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$startJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$middleJoint+$side)`;
	xform -os -t 0 0 0 ($nameSpace+"FK"+$middleJoint+$side);
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$middleJoint+$side);
	$tempFloat=`xform -q -ws -ro ($nameSpace+"IKX"+$endJoint+$side)`;
	xform -os -t 0 0 0 ($nameSpace+"FK"+$endJoint+$side);
	xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FK"+$endJoint+$side);
	if (`objExists $toesJoint` && `objExists ($nameSpace+"IKXToes"+$side)`)
		{
		$tempFloat=`xform -q -ws -ro ($nameSpace+"IKXToes"+$side)`;
		xform -os -t 0 0 0 ($nameSpace+"FKToes"+$side);
		xform -ws -ro $tempFloat[0] $tempFloat[1] $tempFloat[2] ($nameSpace+"FKToes"+$side);
		}
	}
if ($W2K=="IK2FK" && $isSplineIK)
	{
	for ($i=0;$i<size($chainJoints);$i++)
		{
		if (!`objExists ($nameSpace+"IKX"+$chainJoints[$i])` || !`objExists ($nameSpace+"FK"+$chainJoints[$i])`)
			continue;
		if (!`sets -im ($nameSpace+"ControlSet") ($nameSpace+"FK"+$chainJoints[$i])`)
			continue;
		// RootX_M.legLock warning
		if ($chainJoints[$i]=="Root")
			if (`attributeExists legLock RootX_M`)
				if (`getAttr RootX_M.legLock`!=10)
					print ("// Switching from IK to FK for the Spine, Set RootX_M.legLock to 10, for more accurate switching.\n");
		$pos=`xform -q -ws -t ($nameSpace+"IKX"+$chainJoints[$i])`;
		$rot=`xform -q -ws -ro ($nameSpace+"IKX"+$chainJoints[$i])`;
		//inbetween, to use last inbetweener`s rot
//		for ($numParts=0;$numParts<99;$numParts++)
//			if (!`objExists ($chainJoints[$i]+"Part"+($numParts+1)+$side)`)
//				break;
//		if ($numParts>0)
//			$rot=`xform -q -ws -roo $roo -ro ($nameSpace+$chainJoints[$i]+"Part"+$numParts+$side)`;
		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ($nameSpace+"FK"+$chainJoints[$i]);
		}
	}

if ($autoKey)
	autoKeyframe -st 1;
if (!$autoKey && $asBakeFKIK)
	autoKeyframe -st 0;
select $sel;
}

global proc asSwitchFKIK (string $name, string $IK, string $side, string $W2K)
{
string $sel[]=`ls -sl`;
string $nameSpace=`asSelectorResolveNameSpace $name ""`;
string $controlCurve=$nameSpace+"FKIK"+$IK+$side;
string $poleCurve=$nameSpace+"Pole"+$IK+$side;
if (!`objExists $controlCurve`)
	error ("Object:\""+$controlCurve+"\" does not exists !");
string $startJoint=`getAttr ($controlCurve+".startJoint")`;
string $middleJoint=`getAttr ($controlCurve+".middleJoint")`;
string $endJoint=`getAttr ($controlCurve+".endJoint")`;
string $chainJoints[],$tempString[],$tempString2[];
string $toesJoint,$childLabel;
int $isSplineIK,$numIkCtrls;
if (!`objExists ($nameSpace+"Pole"+$IK+$side)`)
	$isSplineIK=1;
string $requiredObj[]={($nameSpace+"Main"),($nameSpace+"FKX"+$startJoint+$side),($nameSpace+"IKX"+$startJoint+$side),($nameSpace+"IKX"+$middleJoint+$side)};
if ($isSplineIK)
	{
	$chainJoints=`asgetChainJoints ($nameSpace+$startJoint) ($nameSpace+$endJoint)`;
	for ($i=0;$i<size($chainJoints);$i++)
		$chainJoints[$i]=`substitute $nameSpace $chainJoints[$i] ""`;
	for ($i=1;$i<99;$i++)
		{
		if (!`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
			break;
		$numIkCtrls=$i;
		}
	}
else
	$requiredObj=`stringArrayCatenate $requiredObj {($nameSpace+"Pole"+$IK+$side),($nameSpace+"FKX"+$endJoint+$side)}`;
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Object:\""+$obj+"\" does not exists !");
int $Blend;
int $BlendInverse=10;
int $onOff;
if ($W2K=="FK2IK")
	{
	$Blend=10;
	$BlendInverse=0;
	$onOff=1;
	}

if ($W2K=="FK2IK" && `getAttr ($controlCurve+".FKIKBlend")`>0)
	{
	warning ("Could not switch FK2IK, because \"FKIKBlend\" is not \"0\"\n");
	return;
	}
if ($W2K=="IK2FK" && `getAttr ($controlCurve+".FKIKBlend")`<10)
	{
	warning ("Could not switch IK2FK, because \"FKIKBlend\" is not \"10\"\n");
	return;
	}

//$toesJoint
if (`objExists $endJoint`)
	{
	$tempString=`listRelatives -type joint -ad $endJoint`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`getAttr ($tempString[$y]+".drawLabel")`)
			{
			$childLabel=`getAttr ($tempString[$y]+".otherType")`;
			if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*QToes*"` && !`gmatch $childLabel "*ToesEnd*"`)
				{
				$tempString2[0]=`substitute ($nameSpace+":") $tempString[$y] ""`;
				if (`objExists ($nameSpace+"FK"+$tempString2[0]+$side)`)
					$toesJoint=$tempString2[0];
				}
			}
		}
	}

int $autoKey=`autoKeyframe -q -st`;

currentTime (`currentTime -q` -1);
setAttr ($controlCurve+".FKIKBlend") $BlendInverse;
if ($autoKey)
	{
	if (!$isSplineIK)
		{
		setKeyframe ($controlCurve+".FKIKBlend");
		setKeyframe ($poleCurve+".follow");	

		setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
		setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
		setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
		if (`objExists $toesJoint` && `objExists ($nameSpace+"FKToes"+$side)`)
			setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
		setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
		setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
		setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");
		$tempString=`listAttr -ud ($nameSpace+"IK"+$IK+$side)`;
		for ($i=0;$i<size($tempString);$i++)
			setKeyframe ($nameSpace+"IK"+$IK+$side+"."+$tempString[$i]);
		if (`objExists $toesJoint` && `objExists ($nameSpace+"IKToes"+$side)`)
			setKeyframe ($nameSpace+"IKToes"+$side+".rotate");
		//also key all child-controls (ik heel/toes/toesEnd
		$tempString=`listRelatives -ad -type transform ($nameSpace+"IK"+$IK+$side)`;
		for ($i=0;$i<size($tempString);$i++)
			if (`sets -im ($nameSpace+"ControlSet") $tempString[$i]`)
				setKeyframe ($tempString[$i]+".r");
		}
	if ($isSplineIK)
		{
		setKeyframe ($controlCurve+".FKIKBlend");
		for ($i=0;$i<size($chainJoints);$i++)
			if (`objExists ($nameSpace+"FK"+$chainJoints[$i]+$side)`)
				{
				setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".t");
				setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".r");
				}
		for ($i=1;$i<$numIkCtrls+1;$i++)
			if (`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
				{
				setKeyframe ($nameSpace+"IK"+$IK+$i+$side+".t");
				setKeyframe ($nameSpace+"IK"+$IK+$i+$side+".r");
				}
		}
	}

currentTime (`currentTime -q` +1);
asAlignFKIK $name $IK $side $W2K;
setAttr ($controlCurve+".FKIKBlend") $Blend;

if ($autoKey)
	{
	if (!$isSplineIK)
		{
		setAttr ($poleCurve+".follow") 0;

		setKeyframe ($controlCurve+".FKIKBlend");
		setKeyframe ($poleCurve+".follow");

		setKeyframe ($nameSpace+"FK"+$startJoint+$side+".rotate");
		setKeyframe ($nameSpace+"FK"+$middleJoint+$side+".rotate");
		setKeyframe ($nameSpace+"FK"+$endJoint+$side+".rotate");
		if (`objExists $toesJoint` && `objExists ($nameSpace+"FKToes"+$side)`)
			setKeyframe ($nameSpace+"FKToes"+$side+".rotate");
		setKeyframe ($nameSpace+"IK"+$IK+$side+".translate");
		setKeyframe ($nameSpace+"IK"+$IK+$side+".rotate");
		setKeyframe ($nameSpace+"Pole"+$IK+$side+".translate");
		$tempString=`listAttr -ud ($nameSpace+"IK"+$IK+$side)`;
		for ($i=0;$i<size($tempString);$i++)
			setKeyframe ($nameSpace+"IK"+$IK+$side+"."+$tempString[$i]);
		if (`objExists $toesJoint` && `objExists ($nameSpace+"IKToes"+$side)`)
			setKeyframe ($nameSpace+"IKToes"+$side+".rotate");
		//also key all child-controls (ik heel/toes/toesEnd
		$tempString=`listRelatives -ad -type transform ($nameSpace+"IK"+$IK+$side)`;
		for ($i=0;$i<size($tempString);$i++)
			if (`sets -im ($nameSpace+"ControlSet") $tempString[$i]`)
				setKeyframe ($tempString[$i]+".r");
		}
	if ($isSplineIK)
		{
		setKeyframe ($controlCurve+".FKIKBlend");
		for ($i=0;$i<size($chainJoints);$i++)
			if (`objExists ($nameSpace+"FK"+$chainJoints[$i]+$side)`)
				{
				setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".t");
				setKeyframe ($nameSpace+"FK"+$chainJoints[$i]+$side+".r");
				}
		for ($i=1;$i<$numIkCtrls+1;$i++)
			if (`objExists ($nameSpace+"IK"+$IK+$i+$side)`)
				{
				setKeyframe ($nameSpace+"IK"+$IK+$i+$side+".t");
				setKeyframe ($nameSpace+"IK"+$IK+$i+$side+".r");
				}
		}
	}

//select ($nameSpace+"ControlSet");
//delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1;
//removed, since this sometimes deletes non-static channels e..g IKLeg_L animation
select $sel;
}

global proc string[] asgetChainJoints (string $startJoint, string $endJoint)
{
int $startJointIsParentNr;
string $chainJoints[];
string $tempString[]=`ls -l $endJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$startJointIsParentNr=$i;
	if ($tempString[$i]==$startJoint)
		{
		break;
		}
	}
for ($i=$startJointIsParentNr;$i<size($tempString);$i++)
	$chainJoints[size($chainJoints)]=$tempString[$i];
return $chainJoints;
}

global proc asPopulateNameSpaceMenu (string $name)
{
string $optionMenu=$name+"OptionMenu";
string $nameSpacesList[]=`namespaceInfo -r -lon`;
$nameSpacesList=`stringArrayRemove {"UI"} $nameSpacesList`;
$nameSpacesList[size($nameSpacesList)]="";
string $itemList[]=`optionMenu -q -ils $optionMenu`;
$nameSpacesList=`sort $nameSpacesList`;
for ($item in $itemList)
	deleteUI $item;

for ($nameSpace in $nameSpacesList)
	if (`attributeExists "version" ($nameSpace+":Main")` || `attributeExists "version" ($nameSpace+":FaceGroup")`)
		if (`asFilterCheck $name $nameSpace`)
			menuItem -p $optionMenu -l ($nameSpace+":");

if (!`optionMenu -q -ni ($name+"OptionMenu")`)
	{
	if ($name=="bodySetup" || `gmatch $name "asPoser*"`)
		menuItem -p $optionMenu -l "None";
	else
		menuItem -p $optionMenu -l ":";
	}
}

global proc int asFilterCheck (string $name, string $nameSpace)
{
int $return=0;
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="" || $filterString=="0")
	return 1;
string $references[]=`file -q -r`;
for ($i=0;$i<size($references);$i++)
	{
	$refNameSpace=`file -q -ns $references[$i]`;
	if ($refNameSpace==$nameSpace)
		if (`gmatch $references[$i] $filterString`)
			$return=1;
	}
return $return;
}

global proc asFilterNameSpaceMenuUI (string $name)
{
string $filterString=`optionVar -q ("asSelectorFilter_"+$name)`;
if ($filterString=="0")
	$filterString="";
if (`window -q -ex ("SelectorFilter_"+$name)`)
	deleteUI ("SelectorFilter_"+$name);
window ("SelectorFilter_"+$name);
columnLayout;
textFieldGrp -tx $filterString -cc ("asSetFilterNameSpaceMenu "+$name) -l "Reference File Filter. (e.g. *characters*)" -cw 1 200 ("asSelectorFilterTextFieldGrp_"+$name);
showWindow;
}

global proc asSetFilterNameSpaceMenu (string $name)
{
string $filterString=`textFieldGrp -q -tx ("asSelectorFilterTextFieldGrp_"+$name)`;
optionVar -sv ("asSelectorFilter_"+$name) $filterString;
asPopulateNameSpaceMenu $name;
}

global proc asSetNameSpaceFromSelection (string $uiName)
{
asPopulateNameSpaceMenu $uiName;
string $sel[]=`ls -sl`;
string $tempString[],$ils[];
if (size($sel))
	{
	tokenize $sel[0] ":" $tempString;
	$ils=`optionMenu -q -ils ($uiName+"OptionMenu")`;
	for ($i=0;$i<size($ils);$i++)
		if (`menuItem -q -l $ils[$i]`==($tempString[0]+":"))
			{
			optionMenu -e -sl ($i+1) ($uiName+"OptionMenu");
			asSelChange;
			}
	}
print "// Setting nameSpace from selected object\n";
}

global proc asCopyToClipBoard (string $uiName, int $anim)
{
string $cmd=`asPoserGetCmd $uiName $anim`;
if (!$anim)
	menuItem -e -en 1 -c $cmd ($uiName+"PosePaste");
else
	menuItem -e -en 1 -c ($cmd+" 0") ($uiName+"AnimPaste");
}

global proc string[] asGetControlSetsFromUI (string $uiName)
{
int $selectedTabIndex;
string $controlSets[];
string $tempString[],$tabLabels[];
string $controlSetsText;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (`text -q -ex ($uiName+"ControlSetsText")`)//Selector
	{
	$controlSetsText=`text -q -l ($uiName+"ControlSetsText")`;
	tokenize $controlSetsText $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (`objExists ($nameSpace+$tempString[$i])`)
			$controlSets[size($controlSets)]=$nameSpace+$tempString[$i];
	}
else if ($uiName=="asPicker" && `tabLayout -q -ex asPickerTabLayout`)//Picker
	{
	$tabLabels=`tabLayout -q -tl asPickerTabLayout`;
	$selectedTabIndex=`tabLayout -q -selectTabIndex asPickerTabLayout`;
	if (`gmatch $tabLabels[$selectedTabIndex-1] "*face*"`)
		$controlSets[0]=$nameSpace+"FaceControlSet";
	else
		$controlSets[0]=$nameSpace+"ControlSet";
	}
else if ($uiName=="asPoserDefault" && `menuItem -q -ex asPoserControlSetsMenu`)//PoserDesigner
	{
	$tempString=`menu -q -ia asPoserControlSetsMenu`;
	for ($i=0;$i<size($tempString);$i++)
		if (`menuItem -q -cb $tempString[$i]`)
			$controlSets[size($controlSets)]=$nameSpace+`menuItem -q -l $tempString[$i]`;
	}
else
	$controlSets[0]=$nameSpace+"ControlSet";

return $controlSets;
}

global proc asDeleteStaticChannels (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Clean animation ?\n"
	+"This will delete static channels,\n"
	+"which means remove all animation where the value is not changing")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
select $controlSets;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
print ("// Static channels cleaned\n");
select $sel;
}
	
global proc string asPoserGetCmd (string $uiName, int $anim)
{
global string $gChannelBoxName;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selectedMainAttrs[]=`channelBox -q -sma $gChannelBoxName`;
string $selectedShapeAttrs[]=`channelBox -q -ssa $gChannelBoxName`;
string $selectedHistoryAttrs[]=`channelBox -q -sha $gChannelBoxName`;
string $selectedOutputAttrs[]=`channelBox -q -soa $gChannelBoxName`;
string $selectedAttrs[];
$selectedAttrs=`stringArrayCatenate $selectedMainAttrs $selectedShapeAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedHistoryAttrs`;
$selectedAttrs=`stringArrayCatenate $selectedAttrs $selectedOutputAttrs`;
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
int $onlySel;
if ($uiName=="asPoserDefault")
	{
	if (`checkBox -q -ex asPoserOnlySel`)
		$onlySel=`checkBox -q -v asPoserOnlySel`;
	}
else if ($altButton || $ctrlButton)
	$onlySel=1;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $cmd;
string $controls[],$buffer[];
int $weightedTangents[];
int $onlyOneObj,$onlyOneAttr;
string $connectObj;
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
if (!$onlySel && !size($controlSets))
	error "No ControlSets";

//determine the name for poserAnimFile
string $animationFile,$animationFilePath;
string $gridOrder[];
int $childNum;
if (`gmatch $uiName "asPoser*"`)
	{
	$gridOrder=`gridLayout -q -go ($uiName+"GridLayout")`;
	for ($i=1;$i<size($gridOrder)+1;$i++)
		if (`gmatch $gridOrder[$i-1] "asPoser*"`)
			$childNum=$i;
	$childNum++;

	$animationFile="untitled_"+$childNum;
	$animationFilePath=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
	}
else
	{
	$animationFile="ClipBoard";
	$animationFilePath=`asGetTempDirectory`+"AdvancedSkeleton/Selector/";
	}

string $animCurves[];

if ($onlySel)
	{
	for ($i=$y=0;$i<size($sel);$i++)
		{
		if (`gmatch $sel[$i] ($nameSpace+"*")`)
			{
			tokenize $sel[$i] ":" $buffer;
			$controls[$y]=$buffer[size($buffer)-1];
			$y++;
			}
		}
	}
else
	{
	if (!`objExists $controlSets[0]`)
		error ("Object :\""+$controlSets[0]+"\" does not exists !\n");
	$controls=`sets -q $controlSets`;
	for ($i=0;$i<size($controls);$i++)
		$controls[$i]=`substitute  $nameSpace $controls[$i] ""`;
	}
string $attrs[];
if (size($controls)<1)
	error "No Controls Available!";
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Storing Data" -bp -ii 1 -min 0 -max (size($controls)) $gMainProgressBar;
select -cl;

if ($anim)
	{
	createNode -n poserAnimationInfo transform;
	addAttr -ln "cmd" -dt "string" poserAnimationInfo;
	select poserAnimationInfo;
	}

	{
for ($obj in $controls)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	$allKeyableAttrs=`listAttr -k -m -sn ($nameSpace+$obj)`;
	if ($onlySel && (size($selectedAttrs)>0))
		$attrs=$selectedAttrs;
	else
		$attrs=$allKeyableAttrs;
	for ($attr in $attrs)
		for ($allKeyableAttr in $allKeyableAttrs)
			{
			if (`getAttr -l ($nameSpace+$obj+"."+$attr)`)
				continue;
			if ($attr==$allKeyableAttr)
				{
				if (!$anim)
					$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+";";
				else
					{
					//Animation
					$animCurves=`listConnections -type animCurve -s 1 -d 0 ($nameSpace+$obj+"."+$attr)`;
					for ($y=0;$y<size($animCurves);$y++)
						{
						select -add $animCurves[$y];
						$cmd+=$obj+"."+$attr+" "+`getAttr ($nameSpace+$obj+"."+$attr)`+" "+$animCurves[$y]+";";
						}
					}
				}
			}
		}
	}

if ($anim)
	{
	setAttr -type "string" poserAnimationInfo.cmd $cmd;
	if (!`file -q -ex $animationFilePath`)
		sysFile -md $animationFilePath;
	file -f -op "v=0" -typ "mayaAscii" -es ($animationFilePath+$animationFile+".ma");
	delete poserAnimationInfo;
	}

if ($cmd!="")
	{
	if (!$anim)
		$cmd="asSetAttrs "+$uiName+" \""+$cmd+"\"";
	else
		$cmd="asLoadAttrs "+$uiName;
	}

select $sel;
return $cmd;
}

global proc asSetAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[];
string $objAttr;
float $value;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";

for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asLoadAttrs (string $uiName, int $childNum)
{
string $sel[]=`ls -sl`;
int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -e -st 0;
createNode -n tempXform transform;
int $shiftButton,$ctrlButton,$altButton;
if (`getModifiers` %  2)
	$shiftButton=1;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
float $timeOffset=0;
if ($shiftButton)
	$timeOffset=`currentTime -q`;
string $buffer[],$buffer2[],$buffer3[],$tempString[];
string $obj,$attr,$objAttr,$animCurve,$newAnimCurve;
float $value;

string $animationFile,$projectName;

if ($childNum==0)
	{
	$projectName="Selector";
	$animationFile=`asGetTempDirectory`+"AdvancedSkeleton/Selector/ClipBoard.ma";
	}
else
	{
	string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
	string $tempString[];
	tokenize $icon "/" $tempString;
	$projectName=$tempString[size($tempString)-2];
	$animationFile=`substitute "[.][a-z][a-z][a-z]" $icon ".ma"`;
	}
file -r -type "mayaAscii" -namespace $projectName -options "v=0;p=17" $animationFile;

string $cmds=`getAttr ($projectName+":poserAnimationInfo.cmd")`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning;
string $warningMsg="The following attributes can not be set:";
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	tokenize $objAttr "." $buffer3;
	$obj=$buffer3[0];
	$attr=$buffer3[1];
	$value=$buffer2[1];
	$animCurve=$buffer2[2];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	if (($ctrlButton||$altButton) && `gmatch $objAttr "*Main.*"`)
		continue;
	if (`objExists $objAttr`)
		{
		catch (`eval ("setAttr "+$objAttr+" "+$value)`);
		if (!`attributeExists $attr tempXform`)
			addAttr -k 1 -ln $attr -at double tempXform;
		connectAttr -f ($projectName+":"+$animCurve+".output") ("tempXform."+$attr);
		copyKey -time ":" -hierarchy none -at $attr tempXform;
		pasteKey -option merge -copies 1 -connect 0 -timeOffset $timeOffset -floatOffset 0 -valueOffset 0 {$objAttr};
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;

if (`objExists tempXform`)
	delete tempXform;
file -rr  $animationFile;
select $sel;
if ($autoKey)
	autoKeyframe -e -st 1;
}

global proc asKeyAttrs (string $uiName, string $cmds)
{
int $ctrlButton,$altButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
if ((`getModifiers`/8) %  2)
	$altButton=1;
string $buffer[],$buffer2[],$spaceBuffer[];
string $objAttr,$previousObjAttr,$restOfBuffers;
float $time,$value,$currentValue;
float $currentTime=`currentTime -q`;
int $numTok=`tokenize $cmds ";" $buffer`;
int $showWarning,$firstValueSet;
string $warningMsg="The following attributes can not be keyed:";
float $firstValue;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$objAttr=`asPoserResolveNameSpace $uiName $objAttr`;
	$restOfBuffers="";
	if ($objAttr!=$previousObjAttr)
		$firstValueSet=0;
	$previousObjAttr=$objAttr;
	for ($y=1;$y<size($buffer2);$y++)
		$restOfBuffers+=$buffer2[$y]+" ";
	if (`objExists $objAttr`)
		{
		tokenize $restOfBuffers $spaceBuffer;
		for ($y=0;$y<size($spaceBuffer);$y++)
			{
			//TimeOffset
			if ($spaceBuffer[$y]=="-t" && ($ctrlButton||$altButton))
				{
				$time=$spaceBuffer[$y+1];
				$spaceBuffer[$y+1]=$time+$currentTime;
				}
			//ValueOffset
			if ($spaceBuffer[$y]=="-v" && $ctrlButton)
				{
				$value=$spaceBuffer[$y+1];
				$currentValue=`getAttr $objAttr`;
				if (!$firstValueSet)
				$firstValue=$value;
				$firstValueSet=1;
				$spaceBuffer[$y+1]=$value+$currentValue-$firstValue;
				}
			}
		$restOfBuffers="";
		for ($y=0;$y<size($spaceBuffer);$y++)
			$restOfBuffers+=$spaceBuffer[$y]+" ";
		eval ($restOfBuffers+$objAttr);
		}
	else
		{
		$showWarning=1;
		$warningMsg+=$objAttr+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asPoseView (string $uiName, int $childNum)
{
string $icon=`iconTextButton -q -i ($uiName+"IconTextButton"+$childNum)`;
int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $tempString[];
tokenize $icon "/" $tempString;
string $projectName=$tempString[size($tempString)-2];

string $mediaFile;
if ($anim)
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".avi"`;
else
	$mediaFile=`substitute "[.][a-z][a-z][a-z]" $icon ".jpg"`;
print ("// "+$mediaFile+"\n");
system ("load "+$mediaFile);
}

global proc asPoseObjects (string $uiName, string $button,string $action)
{
string $cmd=`iconTextButton -q -c $button`;
string $buffer[],$buffer2[];
string $objAttr,$value;
tokenize $cmd "\"" $buffer;
$cmd=$buffer[1];
int $numTok=`tokenize $cmd ";" $buffer`;
int $showWarning;
string $warningMsg="The following objects can not be found:";
if ($action==" select -add")
select -cl;
for ($i=0;$i<$numTok;$i++)
	{
	tokenize $buffer[$i] $buffer2;
	$objAttr=$buffer2[0];
	$value=$buffer2[1];
	tokenize $objAttr "." $buffer2;
	$obj=$buffer2[0];
	if ($action!=" select -add")
		$obj=$objAttr;
	$obj=`asPoserResolveNameSpace $uiName $obj`;
	if (`objExists $obj`)
		eval ($action+" "+$obj);
	else
		{
		$showWarning=1;
		$warningMsg+=$obj+",";
		}
	}
if ($showWarning)
	warning $warningMsg;
}

global proc asMirrorOptions (string $uiName)
{
if (`window -q -ex asMirrorOptions`)
	deleteUI asMirrorOptions;
window -t "Mirror Options" asMirrorOptions;
columnLayout -adj 1;
	separator -h 25 -st "none";
	rowLayout -nc 4 -cw 1 40;
		text -l "side:";
		radioCollection asMOSideRadioCollection;
		radioButton -label "Swap" asMOSideFlip;
		radioButton -label "Right To Left" asMOSideR2L;
		radioButton -label "Left To Right" asMOSideL2R;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "axis:";
		radioCollection asMOAxisRadioCollection;
		radioButton -label "X" asMOAxisX;
		radioButton -label "Y" asMOAxisY;
		radioButton -label "Z" asMOAxisZ;
		radioCollection -e -sl "asMOAxisX" asMOAxisRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "space:";
		radioCollection asMOSpaceRadioCollection;
		radioButton -label "World" asMOSpaceWorld;
		radioButton -label "Main" asMOSpaceMain;
		radioButton -label "RootX_M" asMOSpaceCenter;
		radioCollection -e -sl "asMOSpaceWorld" asMOSpaceRadioCollection;
		setParent..;
	rowLayout -nc 4 -cw 1 40;
		text -l "control:";
		radioCollection asMOSelOnlyRadioCollection;
		radioButton -label "All" asMOSelOnlyAll;
		radioButton -label "Selected" asMOSelOnlySel;
		radioCollection -e -sl "asMOSelOnlyAll" asMOSelOnlyRadioCollection;
		setParent..;

separator -st "none" -h 25;
button -w 100 -l "Mirror" -c ("asMirror "+$uiName);
showWindow;

string $optionVars[]={"asMOSide","asMOSpace","asMOAxis","asMOSelOnly"};
string $cia[];
string $radioCollection,$selected,$optionVarString;
for ($i=0;$i<size($optionVars);$i++)
	{
	$radioCollection=$optionVars[$i]+"RadioCollection";
	$cia=`radioCollection -q -cia $radioCollection`;
	$selected=$cia[0];
	if (`optionVar -ex $optionVars[$i]`)
		{
		$optionVarString=`optionVar -q $optionVars[$i]`;
		for ($y=0;$y<size($cia);$y++)
			if (`gmatch $cia[$y] ("*"+$optionVarString)`)
				$selected=`optionVar -q $optionVars[$i]`;
		}
	radioCollection -e -sl $selected $radioCollection;
	}
}

global proc asMirror (string $uiName)
{
string $side="asMOSideR2L";
string $space="asMOSpaceMain";
string $axis="asMOAxisX";
string $selOnly="asMOSelOnlyAll";
if (`window -q -ex asMirrorOptions`)
	{
	$side=`radioCollection -q -sl asMOSideRadioCollection`;
	$space=`radioCollection -q -sl asMOSpaceRadioCollection`;
	$axis=`radioCollection -q -sl asMOAxisRadioCollection`;
	$selOnly=`radioCollection -q -sl asMOSelOnlyRadioCollection`;
	optionVar -sv asMOSide $side;
	optionVar -sv asMOSpace $space;
	optionVar -sv asMOAxis $axis;
	optionVar -sv asMOSelOnly $selOnly;
	}
if (`optionVar -ex asMOSide`)
	$side=`optionVar -q asMOSide`;
if (`optionVar -ex asMOSpace`)
	$space=`optionVar -q asMOSpace`;
if (`optionVar -ex asMOAxis`)
	$axis=`optionVar -q asMOAxis`;
if (`optionVar -ex asMOSelOnly`)
	$selOnly=`optionVar -q asMOSelOnly`;
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $sortedControls[];

for ($i=0;$i<size($controls);$i++)
	if ($controls[$i]==($nameSpace+"Main"))
		$sortedControls={($nameSpace+"Main"),($nameSpace+"RootX_M"),($nameSpace+"RootExtraX_M")};

for ($i=0;$i<size($controls);$i++)
	if (`attributeExists "stiff" $controls[$i]`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`attributeExists "followEnd" $controls[$i]`)
		$sortedControls[size($sortedControls)]=$controls[$i];	

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Spine*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Leg*")` || `gmatch $controls[$i] ($nameSpace+"IK*Arm*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Pole*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Roll*Heel*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Roll*ToesEnd*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"Roll*Toes*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($x=10;$x>0;$x--)
	for ($i=0;$i<size($controls);$i++)
		if (`gmatch $controls[$i] ($nameSpace+"Roll*"+$x+"*")`)
			$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"IK*Toes_*")`)
		$sortedControls[size($sortedControls)]=$controls[$i];

for ($i=0;$i<size($controls);$i++)
	if (!`stringArrayCount $controls[$i] $sortedControls`)
		$sortedControls[size($sortedControls)]=$controls[$i];

$controls=$sortedControls;
if ($selOnly=="asMOSelOnlySel")
	$controls=$sel;
string $allKeyableAttrs[],$tempString[];
string $source,$dest,$destAttr,$cmd,$loc1,$loc2;
float $pos[3],$rot[3],$pos2[3],$rot2[3];
int $wsXform[];
int $flip,$isFaceControl,$isClusterControl,$isClusterLocalOrientControl,$wsXformAttr;
string $flipAxis,$t0;
if ($axis=="asMOAxisX")
	{$flipAxis="X";$t0="tx";}
if ($axis=="asMOAxisY")
	{$flipAxis="Y";$t0="ty";}
if ($axis=="asMOAxisZ")
	{$flipAxis="Z";$t0="tz";}

createNode -n flipGroup transform;
if ($space=="asMOSpaceCenter")
	parent flipGroup ($nameSpace+"RootX_M");
if ($space=="asMOSpaceMain")
	parent flipGroup ($nameSpace+"Main");
xform -os -t 0 0 0 -ro 0 0 0 flipGroup;
if ($space=="asMOSpaceCenter" || $space=="asMOSpaceMain")
	parent -w flipGroup;
for ($i=0;$i<size($controls);$i++)
	{
	if ($side!="asMOSideFlip")
		if (`gmatch $controls[$i] "*_M"` || `gmatch $controls[$i] "*Main"`)
			continue;
	if ($side=="asMOSideR2L")
		{
		if (`gmatch $controls[$i] "*_L"`)
			continue;
		$dest=`substitute "_R" $controls[$i] "_L"`;
		}
	else if ($side=="asMOSideL2R")
		{
		if (`gmatch $controls[$i] "*_R"`)
			continue;
		$dest=`substitute "_L" $controls[$i] "_R"`;
		}
	else if ($side=="asMOSideFlip")
		{
		if (!`gmatch $controls[$i] "*_L"` && !`gmatch $controls[$i] "*_R"` && !`gmatch $controls[$i] "*_M"`)
			continue;
		if (`gmatch $controls[$i] "*FKExtraSpine1_M"`)
			continue;
		if (`gmatch $controls[$i] "*_L"`)
			$dest=`substitute "_L" $controls[$i] "_R"`;
		if (`gmatch $controls[$i] "*_R"`)
			$dest=`substitute "_R" $controls[$i] "_L"`;
		if (`gmatch $controls[$i] "*_M"`)
			$dest=$controls[$i];
		}
	if (!`objExists $dest`)
		continue;
	$isFaceControl=0;
	if (`objExists ($nameSpace+"FaceControlSet")`)
		if (`sets -im ($nameSpace+"FaceControlSet") $controls[$i]`)
			$isFaceControl=1;
	$isClusterControl=$isClusterLocalOrientControl=0;
	$tempString=`ls -l $controls[$i]`;
	if (`gmatch $tempString[0] "*CustomSystem|*"`)
		$isClusterControl=1;
	if ($isClusterControl)
		if (`attributeExists localOrient $controls[$i]`)
			$isClusterLocalOrientControl=1;
	$source=$controls[$i];
	$allKeyableAttrs=`listAttr -k -m -sn $controls[$i]`;
	for ($y=0;$y<size($allKeyableAttrs);$y++)
		{
		$destAttr=$allKeyableAttrs[$y];
		if			(`gmatch $destAttr "*_R*"`) $destAttr=`substitute "_R" $destAttr "_L"`;
		else if (`gmatch $destAttr "*_L*"`) $destAttr=`substitute "_L" $destAttr "_R"`;		
		$flip=1;
		if (`gmatch $controls[$i] ($nameSpace+"FK*_L")` || `gmatch $controls[$i] ($nameSpace+"FK*_R")`
		 || `gmatch $controls[$i] ($nameSpace+"Bend*_L")` || `gmatch $controls[$i] ($nameSpace+"Bend*_R")`
		 || $isClusterLocalOrientControl)
		 	{
		 	if ($destAttr=="tx" || $destAttr=="ty" || $destAttr=="tz")
		 		$flip=-1;
		 	}
		else
			if ($destAttr=="tz" || $destAttr=="rx" || $destAttr=="ry")
				$flip=-1;
		if ($isFaceControl)
			$flip=1;
		$wsXformAttr=0;
		if (`gmatch $controls[$i] ($nameSpace+"IK*")` || `gmatch $controls[$i] ($nameSpace+"Pole*")`
		|| `gmatch $controls[$i] ($nameSpace+"Roll*")`
		|| `gmatch $controls[$i] ($nameSpace+"RootX_M*")` || ($isClusterControl && !$isClusterLocalOrientControl))
			if (!`gmatch $controls[$i] ($nameSpace+"IKLocal*")`)
				$wsXform[$i]=1;
		if (`gmatch $controls[$i] ($nameSpace+"Aim*")`)
			continue;
		if ($destAttr=="tx" || $destAttr=="ty" || $destAttr=="tz"
			||$destAttr=="rx" || $destAttr=="ry" || $destAttr=="rz")
			if ($wsXform[$i])
				$wsXformAttr=1;
		if (!$wsXformAttr)
			if (`getAttr -se ($dest+"."+$destAttr)`)
				$cmd+="setAttr "+$dest+"."+$destAttr+" "+(`getAttr ($source+"."+$allKeyableAttrs[$y])`*$flip)+";";
		}

	if ($wsXform[$i])
		{
		$tempString=`spaceLocator`;
		$loc1=$tempString[0];
		$tempString=`spaceLocator`;
		$loc2=$tempString[0];
		parent $loc2 $loc1;
		parent $loc1 $source;
		xform -os -t 0 0 0 -ro 0 0 0 $loc1;
		setAttr ($loc1+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ($loc2+".rotateOrder") `getAttr ($source+".rotateOrder")`;
		setAttr ("flipGroup.scale"+$flipAxis) 1;
		parent $loc1 flipGroup;
		setAttr ("flipGroup.scale"+$flipAxis) -1;
		setAttr ($loc1+".scaleX") -1;
		$pos=`xform -q -ws -t $loc2`;
		$rot=`xform -q -ws -ro $loc2`;
		$pos2=`getAttr ($source+".t")`;
		$rot2=`getAttr ($source+".r")`;
		$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" -ro "+$rot[0]+" "+$rot[1]+" "+$rot[2]+" "+$dest+";";
		}

	if (`attributeExists "mirror" $controls[$i]`)
		setAttr ($controls[$i]+".mirror") 0;
	}
delete flipGroup;
if ($cmd!="")
	eval ($cmd);
select $sel;
}

global proc asGoToBuildPose (string $uiName)
{
int $ctrlButton;
if ((`getModifiers`/4) %  2)
	$ctrlButton=1;
string $nameSpace;
string $controlSets[];
if ($uiName=="bodySetup")
	{
	$nameSpace="";
	$controlSets[0]="ControlSet";
	}
else if ($uiName=="faceSetup")
	{
	$nameSpace="";
	$controlSets[0]="FaceControlSet";
	}
else
	{
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
	$controlSets=`asGetControlSetsFromUI $uiName`;
	}
if ($nameSpace==":")
	$nameSpace="";

string $buildPose="buildPose";
if (`gmatch $controlSets[0] "*FaceControlSet"`)
    $buildPose="faceBuildPose";

string $tempString[],$tempString2[],$buffer[];
string $setAttrCmd,$cmd;


$setAttrCmd=`getAttr ($nameSpace+$buildPose+".udAttr")`;
tokenize $setAttrCmd ";" $tempString;
for ($y=0;$y<size($tempString);$y++)
	{
	$cmd=$tempString[$y];
	if ($cmd=="")
		continue;
	if ($nameSpace!="")
		{
		tokenize $cmd $buffer;
		if (`gmatch $cmd "xform*"`)
			$substituteWordNr=size($buffer)-1;
		else
			$substituteWordNr=1;
		$cmd="";
		for ($z=0;$z<size($buffer);$z++)
			{
			if ($z==$substituteWordNr)
				$cmd+=$nameSpace;
			$cmd+=$buffer[$z]+" ";
			}
		}
	if ($ctrlButton)
		if (`gmatch $cmd "*Main.*"`)
			continue;
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

//run
string $run,$fitTopNode,$objAttr;
for ($i=0;$i<size($controlSets);$i++)
	{
	if (`gmatch $controlSets[$i] "*ControlSet"`)
		if (`objExists ($nameSpace+"FitSkeleton")`)
			$fitTopNode=$nameSpace+"FitSkeleton";
	if (`gmatch $controlSets[$i] "*FaceControlSet"`)
		$fitTopNode=($nameSpace+"FaceFitSkeleton");
	}

if (`objExists $fitTopNode`)
	if (`attributeExists "run" $fitTopNode`)
		{
		$run=`getAttr ($fitTopNode+".run")`;
		if ($run!="")
			{
			if ($nameSpace=="")
				catch (`eval ($run)`);
			else
				{
				tokenize $run ";" $tempString;
				for ($i=0;$i<size($tempString);$i++)
					{
					tokenize $tempString[$i] $tempString2;
					$objAttr=`substitute "\"" $tempString2[1] ""`;
					$objAttr=`substitute "\"" $objAttr ""`;
					$cmd=$tempString2[0]+" "+$nameSpace+$objAttr+" "+$tempString2[2]+";";
					catch (`eval ($cmd)`);
					}
				}
			}
		}
}

global proc asPoserupdateGridBlock (string $uiName, int $childNum)
{
string $existingPopUpMenus[]=`control -q -pma ($uiName+"IconTextButton"+$childNum)`;
for ($pop in $existingPopUpMenus)
	deleteUI $pop;

int $anim=`rowColumnLayout -q -ann ($uiName+"RowColumnLayout"+$childNum)`;
string $button=$uiName+"IconTextButton"+$childNum;
string $viewCmd="asPoseView "+$uiName+" "+$childNum;
string $selectCmd="asPoseObjects "+$uiName+" "+$button+"\" select -add\"";
string $keyCmd="asPoseObjects "+$uiName+" "+$button+" setKeyframe";
string $linearKeyCmd="asPoseObjects "+$uiName+" "+$button+" \"setKeyframe -itt linear -ott linear\"";

popupMenu -p ($uiName+"IconTextButton"+$childNum);
	menuItem -l "View" -c $viewCmd;
	if (!$anim)
		{
		menuItem -d 1;
		menuItem -l "Select" -c $selectCmd;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		}
	if ($uiName=="asPoserDefault")
		{
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asPoserRename "+$childNum);
		menuItem -l "Remove Button" -c ("asPoserDeletePose "+$uiName+" "+$childNum);
		menuItem -l "Update icon" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 1 0");
		if ($anim)
			menuItem -l "Update movie" -c ("asPoserSnapShoot "+$uiName+" "+$childNum+" "+$anim+" 0 1");
		}
}

global proc string asPoserResolveNameSpace (string $uiName, string $obj)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
return ($nameSpace+$obj);
}

global proc asDynRemove (string $uiName)
{
string $sel[]=`ls -sl`;
string $dynAttrs[]={"blend","baseGoal","tipGoal","conserve"};
string $tempString[];
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
string $dynObj;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
for ($i=0;$i<size($sel);$i++)
	if (!`gmatch $sel[$i] ($nameSpace+"FK*")`)
		error ($sel[$i]+" is not a FK control");
for ($i=0;$i<size($sel);$i++)
	{
	$dynObj="dynamics"+`substitute ($nameSpace) $sel[$i] ""`;
	if(`objExists $dynObj`)
		{
		delete $dynObj;
		for ($y=0;$y<size($dynAttrs);$y++)
			if (`attributeExists $dynAttrs[$y] $sel[$i]`)
				deleteAttr ($sel[$i]+"."+$dynAttrs[$y]);
		$tempString=`listRelatives -c Dynamics`;
		if (!size($tempString))
			delete Dynamics;
		print ("// Dynamics for "+$sel[$i]+" removed\n");
		}
	else
		print ("// No dynamics for "+$sel[$i]+" found\n");
	}
}

global proc asDynAdd (string $uiName)
{
int $numCv,$form,$spans,$degrees,$numChar;
float $pos[],$posA[],$posB[];
string $sel[]=`ls -sl`;
string $selLong[]=`ls -sl -l`;
string $tempString[],$dynJoints[],$sorted[],$defJoints[],$dynJoints[],$deleteObjs[];
string $defJoint,$connectTo,$side,$sideLess,$curveCmd;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!size($sel))
	error ("nothing selected");
string $name=`substitute $nameSpace $sel[0] ""`;
string $dynTopNode="dynamics"+$name;
if (`objExists $dynTopNode`)
	error ("Object \""+$dynTopNode+"\" already exists. Delete this first, if you wish to make a new one.");

//sort by lenght of `long` name, to sort by parents befor children
for ($y=0;$y<9999;$y++)
	{
	for ($i=0;$i<size($sel);$i++)
		if (size($selLong[$i])==$y)
			$sorted[size($sorted)]=$sel[$i];
	if (size($sorted)==size($sel))
		break;
	}

for ($i=0;$i<size($sorted);$i++)
	{
	$defJoint="";
	if (`gmatch $sorted[$i] ($nameSpace+"FK*")`)
		$defJoint=`substitute ($nameSpace+"FK") $sorted[$i] ($nameSpace)`;
	if (!`objExists $defJoint`)
		error ("Unable to find DeformJoint for:\""+$sorted[$i]+"\".\n");
	$defJoints[size($defJoints)]=$defJoint;

	//include part joints
	$numChar=size($defJoint);
	$side=`substring $defJoint ($numChar-1) $numChar`;
	$sideLess=`substring $defJoint 1 ($numChar-2)`;
	for ($y=1;$y<99;$y++)
		{
		if (`objExists ($sideLess+"Part"+$y+$side)`)
			$defJoints[size($defJoints)]=($sideLess+"Part"+$y+$side);
		else
			break;
		}
	}
//include `end joint`
$tempString=`listRelatives -c -type joint $defJoints[size($defJoints)-1]`;
if ($tempString[0]!="")
	$defJoints[size($defJoints)]=$tempString[0];

$deleteObjs={("DynParticleArrayMapper"+$name),("DynParticleRamp"+$name),("DynIKEffector"+$name)};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists ($nameSpace+$deleteObjs[$i])`)
		delete ($nameSpace+$deleteObjs[$i]);

if (!`objExists "Dynamics"`)
	createNode -n Dynamics transform;
createNode -n $dynTopNode -p Dynamics transform;

$curveCmd="curve -d 1 ";
for ($i=0;$i<size($defJoints);$i++)
	{
	$pos=`xform -q -ws -t $defJoints[$i]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
	}
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] ("DynCurve"+$name);
parent ("DynCurve"+$name) $dynTopNode;

//soft
$tempString=`soft -d -g 1 -c ("DynCurve"+$name)`;
rename $tempString[0] ("DynParticle"+$name);
$tempString=`listRelatives -p ("DynParticle"+$name)`;
rename $tempString[0] ("DynCurveSoft"+$name);
rename ("copyOfDynCurve"+$name)  ("DynCurve"+$name);
parent ("DynCurveSoft"+$name) $dynTopNode;
setAttr ("DynCurve"+$name+".v") 0;
setAttr ("DynCurveSoft"+$name+".dispCV") 1;

parentConstraint -mo ($nameSpace+$name) ("DynCurve"+$name);

//$numCv
$form=`getAttr ("DynCurve"+$name+".form")`;
$spans=`getAttr ("DynCurve"+$name+".spans")`;
$degrees=`getAttr ("DynCurve"+$name+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;

//mass
for ($i=0;$i<$numCv;$i++)
	{
	$massPP = (1-((1.0/$numCv)*$i));
	particle -e -or $i -at mass -fv $massPP ("DynParticle"+$name);
	}

//arrayMapper
$tempString=`arrayMapper -target ("DynParticle"+$name) -destAttr goalPP -inputV mass -type ramp`;
rename $tempString[0] ("DynParticleArrayMapper"+$name);

$tempString=`listConnections -s 1 -d 0 ("DynParticleArrayMapper"+$name+".computeNodeColor")`;
rename $tempString[0] ("DynParticleRamp"+$name);
removeMultiInstance -break true ("DynParticleRamp"+$name+".colorEntryList[1]");
setAttr ("DynParticleRamp"+$name+".colorEntryList[0].position") 0;
setAttr ("DynParticleRamp"+$name+".colorEntryList[1].position") 1;
setAttr ("DynParticleRamp"+$name+".colorEntryList[0].color") -type double3 0 0 0;
setAttr ("DynParticleRamp"+$name+".colorEntryList[1].color") -type double3 1 1 1;

if (!`attributeExists blend $sorted[0]`) addAttr -k 1 -ln blend -at double -min 0 -max 1 -dv 1 $sorted[0];
if (!`attributeExists baseGoal $sorted[0]`) addAttr -k 1 -ln baseGoal -at double -min 0 -max 1 -dv 1 $sorted[0];
if (!`attributeExists tipGoal $sorted[0]`) addAttr -k 1 -ln tipGoal -at double -min 0 -max 1 -dv 0.6 $sorted[0];
if (!`attributeExists conserve $sorted[0]`) addAttr -k 1 -ln conserve -at double -min 0 -max 1 -dv 0.75 $sorted[0];
connectAttr ($sorted[0]+".baseGoal") ("DynParticleArrayMapper"+$name+".maxValue");
connectAttr ($sorted[0]+".tipGoal") ("DynParticleArrayMapper"+$name+".minValue");
connectAttr ($sorted[0]+".conserve") ("DynParticle"+$name+".conserve");

//splineIK
createNode -n ($defJoints[0]+"Offset") -p $dynTopNode transform;
$tempString=`listRelatives -p $defJoints[0]`;
parentConstraint $tempString[0] ($defJoints[0]+"Offset");
select $defJoints[0];
for ($i=0;$i<$numCv;$i++)
	{
	$dynJoints[$i]="dyn"+`substitute $nameSpace $defJoints[0] ""`+$i;
	joint -n $dynJoints[$i];
	$pos=`xform -q -ws -t ("DynCurveSoft"+$name+".cv["+$i+"]")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $dynJoints[$i];
	}
parent $dynJoints[0] ($defJoints[0]+"Offset");
$tempString=`ikHandle -n ("DynIKHandle"+$name) -ns 2 -sol ikSplineSolver -sj $dynJoints[0] -ee $dynJoints[size($dynJoints)-1]`;
rename $tempString[1] ("DynIKEffector"+$name);
string $ikCurve=`rename $tempString[2] ("DynIKCurve"+$name)`;
parent ("DynIKHandle"+$name) ("DynIKCurve"+$name) $dynTopNode;
connectAttr -f ("DynCurveSoft"+$name+".worldSpace[0]") ("DynIKCurve"+$name+".create");

//pairBlend
for ($i=0;$i<size($defJoints);$i++)
	{
	$connectTo=$defJoints[$i];
	if ($i>0)
		{
		$tempString[0]=`pairBlend -nd $connectTo -at tx -at ty -at tz`;
		rename $tempString[0] ("parBlendT"+$dynJoints[$i]);
		connectAttr -f ($dynJoints[$i]+".translate") ("parBlendT"+$dynJoints[$i]+".inTranslate2");
		connectAttr ($sorted[0]+".blend") ("parBlendT"+$dynJoints[$i]+".weight");
		}
	$tempString[0]=`pairBlend -nd $connectTo -at rx -at ry -at rz`;
	rename $tempString[0] ("parBlendR"+$dynJoints[$i]);
	connectAttr -f ($dynJoints[$i]+".rotate") ("parBlendR"+$dynJoints[$i]+".inRotate2");
	connectAttr ($sorted[0]+".blend") ("parBlendR"+$dynJoints[$i]+".weight");
	}

setAttr -l 1 ("DynIKHandle"+$name+".v") 0;

print "// Dynamics added.\n";
select $sorted[0];
}

global proc asParentAdd (string $uiName, int $extra)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $tempString[];
string $child;

if (size($sel)<2) error "Select at least 2 objects";

string $parent=$sel[size($sel)-1];
print ("$parent="+$parent+"\n");
for ($i=0;$i<size($sel)-1;$i++)
	{
	$child=$sel[$i];
	if ($extra)
		{
		$tempString=`listRelatives -p $child`;
		if (`gmatch $tempString[0] "*Extra*"`)
			$child=$tempString[0];
		else
			print ("// No Extra control found for \""+$child+"\".\n");
		}
	$tempString=`parentConstraint -mo $parent $child`;
	parent -w $tempString[0];
	}
}

global proc asAutoSwitchFKIK ()
{
string $sel[]=`ls -sl`;
string $name,$nameSpace,$fkIkCtrl,$side,$ik2fk;
float $curFKIKBlend;
string $tempString[],$tempString2[],$fkIkCtrls[];
print "asAutoSwitchFKIK;\n";
for ($i=0;$i<size($sel);$i++)
	{
    if (`gmatch $sel[$i] "*FKIK*"`)
        {
        $fkIkCtrls[size($fkIkCtrls)]=$sel[$i];
        break;
        }
    $tempString[0]=$sel[$i];
    for ($y=0;$y<99;$y++)
        {
        $tempString=`listRelatives -p $tempString[0]`;
        if ($tempString[0]=="") break;
        $tempString2=`listConnections -s 1 -d 0 ($tempString[0]+".v")`;
        if ($tempString2[0]=="") continue;
        if (`objectType $tempString2[0]`!="condition") continue;
        $tempString2=`listConnections -s 1 -d 0 ($tempString2[0]+".firstTerm")`;
        if ($tempString2[0]=="") continue;
        $fkIkCtrls[size($fkIkCtrls)]=$tempString2[0];
        }
	}
if (size($fkIkCtrls)==0)
    error "First select a control that is part of FK/IK setup";
for ($i=0;$i<size($fkIkCtrls);$i++)
    {
		$nameSpace="";
		$fkIkCtrl="";
		$side="";
		$name=$fkIkCtrls[$i];
		tokenize $fkIkCtrls[$i] ":" $tempString;
		if (size($tempString)>1)
			{
			for ($y=0;$y<size($tempString)-1;$y++)
				$nameSpace+=$tempString[$y]+":";
			$name=$tempString[size($tempString)-1];
			}
		tokenize $name "_" $tempString;
		$fkIkCtrl=$tempString[0];
		$side="_"+$tempString[1];
		$curFKIKBlend=`getAttr ($fkIkCtrls[$i]+".FKIKBlend")`;
		if ($curFKIKBlend>0 && $curFKIKBlend<5) setAttr ($fkIkCtrls[$i]+".FKIKBlend") 0;
		if ($curFKIKBlend>5 && $curFKIKBlend<10) setAttr ($fkIkCtrls[$i]+".FKIKBlend") 10;
		if ($curFKIKBlend>5) $ik2fk="IK2FK";
		else $ik2fk="FK2IK";
    asSwitchFKIK $fkIkCtrls[$i] `substitute "FKIK" $fkIkCtrl ""` $side $ik2fk;
    }
}

global proc asAutoSwitchPivot ()
{
string $sel[]=`ls -sl`;
if (size($sel)!=2)
	error "Select 1 target object + 1 control";
string $tempString[];
string $target=$sel[0];
string $control=$sel[1];
string $extraControl;
if (!`gmatch $control "*_*"` && `gmatch $target "*_*"`)//selection order was reversed
	{
	$target=$sel[1];
	$control=$sel[0];
	}
if (`gmatch $control "*Extra*"`)//extraControl was selected
	{
	$tempString=`listRelatives -c -type transform $control`;
	$control=$tempString[0];
	}
$tempString=`listRelatives -p $control`;
$extraControl=$tempString[0];
if (!`objExists $extraControl`)
	error ("parent of \""+$control+"\" is not a valid ExtraControl");
float $pos[]=`xform -q -ws -t $control`;
float $rot[]=`xform -q -ws -ro $control`;
float $extraPos[]=`xform -q -ws -t $extraControl`;
float $extraRot[]=`xform -q -ws -ro $extraControl`;
float $targetPos[]=`xform -q -ws -t $target`;
float $targetRot[]=`xform -q -ws -ro $target`;

print "asAutoSwitchPivot;\n";

int $autoKey=`autoKeyframe -q -st`;
if ($autoKey)
	autoKeyframe -st 0;
currentTime (`currentTime -q` -1);
setKeyframe ($extraControl+".t") ($extraControl+".r") ($control+".t") ($control+".r");

currentTime (`currentTime -q` +1);
xform -ws -t $targetPos[0] $targetPos[1] $targetPos[2] -ro $targetRot[0] $targetRot[1] $targetRot[2] $extraControl;
xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] $control;
setKeyframe ($extraControl+".t") ($extraControl+".r") ($control+".t") ($control+".r");

if ($autoKey)
	autoKeyframe -st 1;

select $extraControl;
print ("// \""+$extraControl+"\" aligned to \""+$target+"\".\n");
}

global proc asQuickIK ()
{
int $otherEndJointAssumed;
float $dist;
float $posA[],$posB[];
string $startJoint,$endJoint,$ctrlPrefix,$startJointParent,$rotateAxis,$name,$ctrl;
string $sel[]=`ls -sl`;
string $joints[],$tempString[],$chainJointsReverse[],$chainJoints[],$chainJointNames[];
if (size($sel)!=2)
	error "Select Start control + End control";

for ($i=0;$i<2;$i++)
	{
	$joints[$i]=$sel[$i];
	$tempString[0]=`substitute "FK" $joints[$i] ""`;//Fk control
	if (`objExists $tempString[0]`)
		{
		$joints[$i]=$tempString[0];
		$ctrlPrefix="FK";
		}
	$tempString[0]=`substitute "_" $joints[$i] "Joint_"`;// Face control e.g tongue
	if (`objExists $tempString[0]`)
		{
		$joints[$i]=$tempString[0];
		$ctrlPrefix="";
		}
	}

$tempString=`listRelatives -ad -type joint $joints[0]`;
if (`stringArrayCount $joints[1] $tempString`)
	{
	$startJoint=$joints[0];
	$endJoint=$joints[1];
	}

$tempString=`listRelatives -ad -type joint $joints[1]`;
if (`stringArrayCount $joints[0] $tempString`)
	{
	$startJoint=$joints[1];
	$endJoint=$joints[0];
	}
if ($startJoint=="" || $endJoint=="")
	error "Unable to find Start & End joint for the IK, make sure to select 2 control that are in the same hierarchy.\n";

$name=`substituteAllString $startJoint ":" "_"`;
$tempString=`listRelatives -p $startJoint`;
$startJointParent=$tempString[0];

//if childJoint of $endJoint is a `actual` endJoint, then assume this was meant to be used.
$tempString=`listRelatives -ad -type joint $endJoint`;
if (size ($tempString)==1)
	{
	$endJoint=$tempString[0];
	$otherEndJointAssumed=1;
	}

//determine $chainJoints
$tempString=`ls -l $endJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	$chainJointsReverse[size($chainJointsReverse)]=$tempString[$i];
	if ($tempString[$i]==$startJoint)
		break;
	}
for ($i=size($chainJointsReverse)-1;$i>-1;$i--)
	$chainJoints[size($chainJoints)]=$chainJointsReverse[$i];

for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ("QuickIKjoint_"+$chainJoints[$i])`)
		error ("Another QuickIK already using the Joint:\"QuickIKjoint_"+$chainJoints[$i]+"\"\n");

$rotateAxis="z";
if (`gmatch $startJoint "*Finger*"`)
	$rotateAxis="y";

print ("StartJoint: "+$startJoint+", EndJoint: "+$endJoint+"\n");
if (!`objExists QuickIK`)
	createNode -n QuickIK transform;
if (`objExists ("QuickIK_"+$name+"Group")`)
	delete ("QuickIK_"+$name+"Group");
createNode -n ("QuickIK_"+$name+"Group") -p $startJoint transform;
parent ("QuickIK_"+$name+"Group") QuickIK;

for ($i=0;$i<size($chainJoints);$i++)
	$chainJointNames[$i]=`substituteAllString $chainJoints[$i] ":" "_"`;

for ($i=0;$i<size($chainJoints);$i++)
	{
	select $chainJoints[$i];
	joint -n ("QuickIKjoint_"+$chainJointNames[$i]);
	setAttr ("QuickIKjoint_"+$chainJointNames[$i]+".rotateOrder") `getAttr ($chainJoints[$i]+".rotateOrder")`;
	if ($rotateAxis=="y")
		setAttr ("QuickIKjoint_"+$chainJointNames[$i]+".preferredAngle") -type float3 0 10 0;
	if ($i>0)
		parent ("QuickIKjoint_"+$chainJointNames[$i]) ("QuickIKjoint_"+$chainJointNames[$i-1]);
	}

parent ("QuickIKjoint_"+$name) ("QuickIK_"+$name+"Group");
parentConstraint -mo $startJointParent ("QuickIKjoint_"+$name);

$posA=`xform -q -ws -t $startJoint`;
$posB=`xform -q -ws -t $endJoint`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

spaceLocator -n ("QuickIK_"+$name);
parent ("QuickIK_"+$name) ("QuickIK_"+$name+"Group");
setAttr ("QuickIK_"+$name+"Shape.overrideEnabled") 1;
setAttr ("QuickIK_"+$name+"Shape.overrideColor") 13;
setAttr ("QuickIK_"+$name+"Shape.localScale") -type float3 ($dist/2.0) ($dist/2.0) ($dist/2.0);
duplicate -n ("QuickPoleVector_"+$name) ("QuickIK_"+$name);
setAttr ("QuickPoleVector_"+$name+"Shape.localScale") -type float3 ($dist/4.0) ($dist/4.0) ($dist/4.0);
xform -ws -t $posB[0] $posB[1] $posB[2] ("QuickIK_"+$name);

ikHandle -n ("QuickIK_"+$name+"Handle") -ns 2 -sol "ikRPsolver" -sj ("QuickIKjoint_"+$chainJointNames[0]) -ee ("QuickIKjoint_"+$chainJointNames[size($chainJointNames)-1]);
parent ("QuickIK_"+$name+"Handle") ("QuickIK_"+$name);
setAttr ("QuickIK_"+$name+"Handle.v") 0;

parent ("QuickPoleVector_"+$name) $startJoint;
xform -os -t 0 0 0 -ro 0 0 0 ("QuickPoleVector_"+$name);
if ($rotateAxis=="y")
	setAttr ("QuickPoleVector_"+$name+".tz") $dist;
if ($rotateAxis=="z")
	setAttr ("QuickPoleVector_"+$name+".ty") $dist;

//poleVector
poleVectorConstraint ("QuickPoleVector_"+$name) ("QuickIK_"+$name+"Handle");
$tempString[0]=`createNode annotationShape`;
$tempString=`listRelatives -p $tempString[0]`;
rename $tempString[0] ("QuickPoleAnnotation_"+$name);
setAttr ("QuickPoleAnnotation_"+$name+"Shape.overrideEnabled") 1;
setAttr ("QuickPoleAnnotation_"+$name+"Shape.overrideDisplayType") 2;
parent ("QuickPoleAnnotation_"+$name) ("QuickIK_"+$name);
xform -os -t 0 0 0 -ro 0 0 0  ("QuickPoleAnnotation_"+$name);
connectAttr ("QuickPoleVector_"+$name+"Shape.worldMatrix[0]") ("QuickPoleAnnotation_"+$name+"Shape.dagObjectMatrix[0]");
//move forward to match IkHandle pos
setAttr ("QuickPoleVector_"+$name+".tx") `getAttr ("QuickIK_"+$name+".tx")`;

//Offsets
createNode -n ("QuickIKOffset_"+$name) -p ("QuickIK_"+$name) transform;
parent ("QuickIKOffset_"+$name) ("QuickIK_"+$name+"Group");
parent ("QuickIK_"+$name) ("QuickIKOffset_"+$name);
createNode -n ("QuickPoleVectorOffset_"+$name) -p ("QuickPoleVector_"+$name) transform;
parent ("QuickPoleVectorOffset_"+$name) ("QuickIK_"+$name);
parent ("QuickPoleVector_"+$name) ("QuickPoleVectorOffset_"+$name);


//connect
for ($i=0;$i<size($chainJoints);$i++)
	{
	if ($i==(size($chainJoints)-1) && $otherEndJointAssumed)
		continue;
	if (`gmatch $chainJoints[$i] "*:*"`)//have nameSpace
		{
		tokenize $chainJoints[$i] ":" $tempString;
		$ctrl=$tempString[0]+":"+$ctrlPrefix+$tempString[1];
		}
	else
		$ctrl=$ctrlPrefix+$chainJoints[$i];
	if ($ctrlPrefix=="")
		$ctrl=`substitute "Joint" $chainJoints[$i] ""`;
	if (!`objExists $ctrl`)
		{
		warning ("Could not find controller:\""+$ctrl+"\"\n");
		continue;
		}
	orientConstraint ("QuickIKjoint_"+$chainJointNames[$i]) $ctrl;
	}

select ("QuickIK_"+$name);
}

global proc asTwistFlipUI (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";

if (`window -q -ex asTwistFlip`)
    deleteUI asTwistFlip;
window -t TwistFlip asTwistFlip;
columnLayout;
separator -h 5 -st none;
text -l "Sets the amount of X-rotation, before `flipping` occours";
text -l "(e.g. twisting of the wrist)\n";
text -l "Note for 360, Constraint-Caching is needed for reliable results";
separator -h 20 -st none;
rowLayout -nc 4;
	text -w 80 -l "X-rotation:";
	optionMenu asTwistFlipOptionMenu;
		menuItem -l "180";
		menuItem -l "360";
	separator -w 10;
	button -w 100 -l "Ok, Set" -c ("asTwistFlipSet "+$uiName+" set");
	setParent..;
separator -h 10 -st none;
rowLayout -en 0 -nc 4 asTwistFlipCacheRowLayout;
	text -w 80 -l "Cache:";
	button -w 80 -l "Create" -c ("asTwistFlipSet "+$uiName+" cacheCreate");
	separator -w 10 -st none;
	button -w 80 -l "Delete" -c ("asTwistFlipSet "+$uiName+" cacheDelete");
showWindow;

//detect current option, and set OptionMenu accordingly
string $twistConstraints[]=`ls -type parentConstraint ($nameSpace+"TwistBalancer*")`;
if (size($twistConstraints))
	if (`getAttr ($twistConstraints[0]+".interpType")`!=1)
		{
		optionMenu -e -v "360" asTwistFlipOptionMenu;
		rowLayout -e -en 1 asTwistFlipCacheRowLayout;
		}
}

global proc asTwistFlipSet (string $uiName, string $action)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";

string $asTwistFlipOption=`optionMenu -q -v asTwistFlipOptionMenu`;
int $interpType=1;
if ($asTwistFlipOption=="360")
	$interpType=0;
string $twistConstraints[]=`ls -type parentConstraint ($nameSpace+"TwistBalancer*")`;
for ($i=0;$i<size($twistConstraints);$i++)
	{
	if ($action=="set")
		{
		setAttr ($twistConstraints[$i]+".interpType") $interpType;
		setAttr MainTwistFlipSetRange.value -type float3 (!$interpType) (!$interpType) (!$interpType);
		if (`rowLayout -q -ex asTwistFlipCacheRowLayout`)
			rowLayout -e -en (!$interpType) asTwistFlipCacheRowLayout;
		}
	if ($action=="cacheCreate")
		evalEcho ("parentConstraint -e -cc "+`playbackOptions -q -min`+" "+`playbackOptions -q -max`+" "+$twistConstraints[$i]);
	if ($action=="cacheDelete")
		evalEcho ("parentConstraint -e -dc "+$twistConstraints[$i]);
	}
dgdirty -a;
refresh;
}

global proc asAnimBake (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $tempString[]=`ls -type transform ($nameSpace+"FKIK*")`;
string $FkIks[];
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists FKIKBlend $tempString[$i]`)
//		if (!`gmatch $tempString[$i] "FKIKSp*ine*"`)
			$FkIks[size($FkIks)]=`substitute ($nameSpace+"FKIK") $tempString[$i] ""`;

if (`window -q -ex asAnimBake`)
    deleteUI asAnimBake;
window -t Bake asAnimBake;
formLayout asAnimBakeFormLayout;
columnLayout;
text -l "Bake:";
optionMenu asAnimBakeOptionMenu;
	menuItem -l "AnimationControls to BakeSkeleton";
//	menuItem -l "MotionCapture to FKControls";
	menuItem -l "ExtraControls to Controls";
	menuItem -l "QuickIK to FKControls";
	for ($i=0;$i<size($FkIks);$i++)
		menuItem -l ("FK to IK : "+$FkIks[$i]);
	for ($i=0;$i<size($FkIks);$i++)
		menuItem -l ("IK to FK : "+$FkIks[$i]);

separator -h 10;
setParent..;
button -l "Ok, Bake" -c ("asAnimBakeGo "+$uiName) asAnimBakeOkButton;

formLayout -e
	-af asAnimBakeOkButton "bottom" 0
	-af asAnimBakeOkButton "left" 0
	-af asAnimBakeOkButton "right" 0
	asAnimBakeFormLayout;

showWindow;
}

global proc asAnimBakeGo (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $bake=`optionMenu -q -v asAnimBakeOptionMenu`;
string $limb;

if ($bake=="AnimationControls to BakeSkeleton")
	asAnimBakeSkeleton $uiName;
if ($bake=="MotionCapture to FKControls")
	asAnimBakeMoCapToFk $uiName;
if ($bake=="ExtraControls to Controls")
	asAnimBakeExtra $uiName;
if ($bake=="QuickIK to FKControls")
	asAnimBakeQuickIK $uiName;
if (`gmatch $bake "FK to IK : *"`)
	{
	$limb=`substitute "FK to IK : " $bake ""`;
	asAnimBakeFKIK $limb 1 $uiName;
	}
if (`gmatch $bake "IK to FK : *"`)
	{
	$limb=`substitute "IK to FK : " $bake ""`;
	asAnimBakeFKIK $limb 0 $uiName;
	}
}

global proc asAnimBakeExtra (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
float $curTime=`currentTime -q`;

string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $tempString[],$tempString2[],$tempString3[],$extraControls[],$bakeControls[],$animCurves[];
for ($i=0;$i<size($controls);$i++)
	if (`gmatch $controls[$i] ($nameSpace+"FKExtra*")` || `gmatch $controls[$i] ($nameSpace+"RootExtraX*")`)
		$extraControls[size($extraControls)]=$controls[$i];

for ($i=0;$i<size($extraControls);$i++)
	{
	$controls[$i]=`substitute "Extra" $extraControls[$i] ""`;
	$bakeControls[$i]=$extraControls[$i]+"BAKER";
	$tempString=`listRelatives -p $extraControls[$i]`;
	createNode -n $bakeControls[$i] -p $tempString[0] transform;
	setAttr ($bakeControls[$i]+".rotateOrder") `getAttr ($controls[$i]+".rotateOrder")`;
	$tempString=`listRelatives -c -type transform $extraControls[$i]`;
	parentConstraint $tempString[0] $bakeControls[$i];
	scaleConstraint $tempString[0] $bakeControls[$i];
	}

//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
currentTime $curTime;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";

//remove existing animation
for ($i=0;$i<size($extraControls);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $extraControls[$i]`;
	if (size($animCurves)) delete $animCurves;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $extraControls[$i];
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $controls[$i]`;
	if (size($animCurves)) delete $animCurves;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $controls[$i];
	}
//asGoToBuildPose bodySetup;

//Use baked animCurves
for ($i=0;$i<size($extraControls);$i++)
	{
	$animCurves=`listConnections -s 1 -d 0 -type animCurve $bakeControls[$i]`;
	for ($y=0;$y<size($animCurves);$y++)
		{
		$tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $animCurves[$y]`;
		tokenize $tempString[1] "[.]" $tempString2;
		connectAttr $tempString[0] ($controls[$i]+"."+$tempString2[1]);
		tokenize $tempString[0] "[.]" $tempString3;
		rename $tempString3[0] ($controls[$i]+"_"+$tempString2[1]);
		}
	}
delete $bakeControls;
}

global proc asAnimBakeQuickIK (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";

string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;
string $bakeControls[],$tempString[];
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listConnections -type constraint $controls[$i]`;
	if (size($tempString))
		$bakeControls[size($bakeControls)]=$controls[$i];
	}

//Bake
select $bakeControls;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys true -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";

if (`objExists QuickIK`)
	delete QuickIK;
select -cl;
}

global proc asAnimBakeFKIK (string $limb, int $Fk2Ik, string $uiName)
{
global int $asBakeFKIK;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
int $numChar=size($limb);
string $side=`substring $limb ($numChar-1) $numChar`;
string $sideLessLimb=`substring $limb 1 ($numChar-2)`;
float $curTime=`currentTime -q`;
float $start=`playbackOptions -q -min`;
float $end=`playbackOptions -q -max`;

int $autoKeyState=`autoKeyframe -q -state`;
if (!$autoKeyState)
	autoKeyframe -state 1;

currentTime $start;
if ($Fk2Ik)
	{
	setAttr ($nameSpace+"FKIK"+$limb+".FKIKBlend") 0;
	asSwitchFK2IK `substitute "asSelector" $uiName ""` {("FKIK"+$limb)};
	}
else
	{
	setAttr ($nameSpace+"FKIK"+$limb+".FKIKBlend") 10;
	asSwitchIK2FK `substitute "asSelector" $uiName ""` {("FKIK"+$limb)};
	}
$asBakeFKIK=1;
for ($i=$start;$i<$end+1;$i++)
	{
	currentTime $i;
	if ($Fk2Ik)
		asAlignFKIK `substitute "asSelector" $uiName ""` $sideLessLimb $side FK2IK;
	else
		asAlignFKIK `substitute "asSelector" $uiName ""` $sideLessLimb $side IK2FK;
	}
currentTime $curTime;
$asBakeFKIK=0;
if (!$autoKeyState)
	autoKeyframe -state 0;
}

global proc asAnimBakeSkeleton (string $uiName)
{
if (`confirmDialog -title "Confirm" -message 
	("Bake character ?\n"
	+"This creates a single joint chain for game engine export\n"
	+"The rig controllers will no longer work")
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $name=`substitute ":" $nameSpace ""`;
string $bakeNameSpace=$name+"Bake:";
namespace -add ($name+"Bake");
namespace -set ($name+"Bake");
$tempString=`listRelatives -c ($nameSpace+"DeformationSystem")`;
$tempString=`duplicate $tempString[0]`;
string $topBakeJoint=$tempString[0];
parent -w $topBakeJoint;
$tempString=`listRelatives -ad $topBakeJoint`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`!="joint")
		delete $tempString[$i];
string $allBakeJoints[]=`listRelatives -ad -type joint $topBakeJoint`;
$allBakeJoints[size($allBakeJoints)]=$topBakeJoint;
sets -rm ($nameSpace+"DeformSet") $allBakeJoints;
//Disable Skincluster
string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 1;
//Constraint bakeSkeleton
string $deformJoints[]=`listRelatives -ad -type joint ($nameSpace+"DeformationSystem")`;
for ($i=0;$i<size($deformJoints);$i++)
    {
		if ($nameSpace=="")
			$bakeDeformJoint=$bakeNameSpace+$deformJoints[$i];
		else
			$bakeDeformJoint=`substitute $nameSpace $deformJoints[$i] $bakeNameSpace`;
    parentConstraint $deformJoints[$i] $bakeDeformJoint;
    scaleConstraint $deformJoints[$i] $bakeDeformJoint;
    setAttr ($bakeDeformJoint+".segmentScaleCompensate") 0;
    }
//Bake
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $allBakeJoints;
//Transfer deformation to bake skeleton
for ($i=0;$i<size($deformJoints);$i++)
{
    $tempString=`listConnections -s 0 -d 1 -p 1 -c 1 $deformJoints[$i]`;
    for ($y=0;$y<size($tempString);$y=$y+2)
        {        
        if ($nameSpace=="")
        	$newSource=$bakeNameSpace+$tempString[$y];
				else
	        $newSource=`substitute $nameSpace $tempString[$y] $bakeNameSpace`;
        catch (`connectAttr -f $newSource $tempString[$y+1]`);
        }
}
//Enable Skincluster
for ($i=0;$i<size($skinClusters);$i++)
    setAttr ($skinClusters[$i]+".nodeState") 0;

namespace -set ":";
select $allBakeJoints;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
select $topBakeJoint;
print ("// Selected joint chain is ready for export, add geometry to selection and export\n");
}

global proc asCreateMoCap (string $uiName)
{
string $sel[]=`ls -sl`;
string $deformJoints[],$keyDeformJoints[],$tempString[],$tempString2[],$parent[],$names[],$extra[];
string $extr;
string $nameSpace;
if (`optionMenu -q -ex ($uiName+"OptionMenu")`)
	$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
float $charHeight=`getAttr ($nameSpace+"Main.height")`;
if (`objExists ($nameSpace+"MoCap")`)
	error "MoCap skeleton already exists !";
if (!`objExists ($nameSpace+"Main")`)
	error "No AdvancedSKeleton In Scene!";
if (!`objExists ($nameSpace+"HipSwingerStabilizerTarget2")`)
	{
	string $dialog=`confirmDialog -t "Confirm"
	-m "HipSwinger controllers needs \"stabilize\" attribute for Mocap.\nAdd this now ?"
	-b "OK" -b "Skip" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
	if ($dialog=="Cancel")
		return;
	if ($dialog=="OK")
		{
		//Added for MoCap to rotate Root joint
		duplicate -n ($nameSpace+"HipSwingerStabilizerTarget2") ($nameSpace+"HipSwingerStabilizerTarget");
		parent ($nameSpace+"HipSwingerStabilizerTarget2") ($nameSpace+"FKExtraRoot_M");
		orientConstraint ($nameSpace+"HipSwingerStabilizerTarget2") ($nameSpace+"HipSwingerStabilizer");
		if (!`attributeExists stabilize ($nameSpace+"HipSwinger_M")`)
			addAttr -k 1 -ln stabilize -at double -min 0 -max 10 -dv 10 ($nameSpace+"HipSwinger_M");
		if (`objExists ($nameSpace+"HipSwingerStabilizerUnitConversion")`) delete ($nameSpace+"HipSwingerStabilizerUnitConversion");
		createNode -n ($nameSpace+"HipSwingerStabilizerUnitConversion") unitConversion;
		setAttr ($nameSpace+"HipSwingerStabilizerUnitConversion.conversionFactor") 0.1;
		connectAttr ($nameSpace+"HipSwinger_M.stabilize") ($nameSpace+"HipSwingerStabilizerUnitConversion.input");
		connectAttr ($nameSpace+"HipSwingerStabilizerUnitConversion.output") ($nameSpace+"HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTargetW0");
		createNode -n ($nameSpace+"HipSwingerStabilizerReverse") reverse;
		connectAttr ($nameSpace+"HipSwingerStabilizerUnitConversion.output") ($nameSpace+"HipSwingerStabilizerReverse.inputX");
		connectAttr ($nameSpace+"HipSwingerStabilizerReverse.outputX") ($nameSpace+"HipSwingerStabilizer_orientConstraint1.HipSwingerStabilizerTarget2W1");
		}
	}

$deformJoints=`listRelatives -type joint -ad ($nameSpace+"DeformationSystem")`;
for ($a=$i=0;$a<size($deformJoints);$a++)
	{
	if (`gmatch $deformJoints[$a] "*_50"`)
		continue;
	if (`gmatch $deformJoints[$a] "*Slider[0-9]*"`)
		continue;
	if (`objExists FaceAllSet`)
		if (`sets -im FaceAllSet $deformJoints[$a]`)
			continue;
	tokenize $deformJoints[$a] "_" $tempString;
	$extr=`substitute $nameSpace ("FKExtra"+$tempString[0]+"_"+$tempString[1]) ""`;
	if (`gmatch $deformJoints[$a] "*Part[0-9]*"`)
		continue;
	$keyDeformJoints[$i]=$deformJoints[$a];
	$extra[$i]=$extr;
	$tempString[0]=$keyDeformJoints[$i];
	for ($y=0;$y<99;$y++)
		{
		$tempString=`listRelatives -p $tempString[0]`;
		if (!`gmatch $tempString[0] "*Part[0-9]*"`)
			{
			tokenize $tempString[0] "_" $tempString;
			$parent[$i]=`substitute $nameSpace ($tempString[0]+"_MoCap_"+$tempString[1]) ""`;
			break;
			}
		}
	tokenize $keyDeformJoints[$i] "_" $tempString;
	string $name=$tempString[0]+"_MoCap_"+$tempString[1];
	if (!`stringArrayCount $name $names`)
		{
		$names[$i]=`substitute $nameSpace $name ""`;
		$i++;
		}
	}

string $topJoint;
for ($i=0;$i<size($names);$i++)
	{
	select -cl;
	joint -n $names[$i];
	if ($i==size($names)-1)
		{
		createNode -n "MoCap" transform;
		createNode -n "CenterOffset" transform;
		asAlign "CenterOffset" ($nameSpace+"RootExtraX_M") 1 0 0 0;
//		parent "MoCap" "Group";
		parent "CenterOffset" "MoCap";
		parent $names[$i] "CenterOffset";
		connectAttr ($names[$i]+".translate") ($nameSpace+"RootExtraX_M.translate");
		$topJoint=$names[$i];
		}
	asAlign $names[$i] $keyDeformJoints[$i] 1 1 1 0;
	setAttr ($names[$i]+".rotateOrder") 1;
	if (`objExists $extra[$i]`)
		setAttr ($extra[$i]+".rotateOrder") 1;
	}

for ($i=0;$i<size($names);$i++)
	{
	if (`objExists $parent[$i]`)
		parent $names[$i] $parent[$i];
	}
for ($i=0;$i<size($names);$i++)
	{
	if (`objExists ($names[$i]+"_blendColor")`)
		delete ($names[$i]+"_blendColor");
	createNode -n ($names[$i]+"_blendColor") blendColors;
	connectAttr ($names[$i]+".rotate") ($names[$i]+"_blendColor.color1");
	addAttr -k 1 -ln "blend" -at double -min 0 -max 1 -dv 1 $names[$i];
	connectAttr ($names[$i]+".blend") ($names[$i]+"_blendColor.blender");
	if (`objExists ($nameSpace+$extra[$i])`)
		connectAttr ($names[$i]+"_blendColor.output") ($nameSpace+$extra[$i]+".rotate");
	}
setAttr "MoCap.translateZ" ($charHeight/-3);
//orientConstraint -mo $topJoint "RootExtraX_M";
select $sel;
}

global proc asDeleteMocap (string $uiName)
{
if (`objExists MoCap`)
	delete MoCap;
delete `ls -type blendColors "*_MoCap_*_blendColor"`;
}

global proc asSetAllFK (string $nameSpace)
{
string $controlSetMembers[]=`sets -q ($nameSpace+"ControlSet")`;
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".FKIKBlend") 0;

if (`attributeExists stabilize ($nameSpace+"HipSwinger_M")`)
	setAttr ($nameSpace+"HipSwinger_M.stabilize") 0;
}

global proc asConnectFaceCap (string $uiName)
{
string $side,$leftRight;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $requiredObj[]={"grp_scale","grp_transform","shapes","grp_eyeLeft","grp_eyeRight"};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Required object:\""+$obj+"\" does not exists. Import FBX from the \"Face Cap\" iPhone app first.");

createNode -n AdvancedSkeletonHeadOffset -p grp_transform transform;
setAttr AdvancedSkeletonHeadOffset.r -type float3 90 0 90;
orientConstraint AdvancedSkeletonHeadOffset ($nameSpace+"FKHead_M");

setAttr ($nameSpace+"ctrlBox.limits") 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$leftRight="Right";}
	if ($b==-1) {$side="_L";$leftRight="Left";}

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("grp_eye"+$leftRight+".ry") ($nameSpace+"ctrlEye"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 30 -cd ("grp_eye"+$leftRight+".ry") ($nameSpace+"ctrlEye"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("grp_eye"+$leftRight+".rx") ($nameSpace+"ctrlEye"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv -30 -cd ("grp_eye"+$leftRight+".rx") ($nameSpace+"ctrlEye"+$side+".ty");
	setAttr ("ctrlEye"+$side+"_translateX.preInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateX.postInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateY.preInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateY.postInfinity") 4;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.eyeBlink"+$side) ($nameSpace+"ctrlEye"+$side+".blink");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 1 -cd ("shapes.eyeBlink"+$side) ($nameSpace+"ctrlEye"+$side+".blink");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.browInnerUp ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd shapes.browInnerUp ($nameSpace+"EyeBrowInner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("shapes.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("shapes.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.browOuterUp"+$side) ($nameSpace+"EyeBrowOuter"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("shapes.browOuterUp"+$side) ($nameSpace+"EyeBrowOuter"+$side+".ty");

	if (`attributeExists EyeBrowMid2Joint ($nameSpace+"EyeBrowOuter"+$side)`)
		setAttr ($nameSpace+"EyeBrowOuter"+$side+".EyeBrowMid2Joint") .75;
	if (`attributeExists EyeBrowMid1Joint ($nameSpace+"EyeBrowInner"+$side)`)
		setAttr ($nameSpace+"EyeBrowInner"+$side+".EyeBrowMid1Joint") .75;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.eyeSquint"+$side) ($nameSpace+"lowerLid"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("shapes.eyeSquint"+$side) ($nameSpace+"lowerLid"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.eyeWide"+$side) ($nameSpace+"ctrlEye"+$side+".blink");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd ("shapes.eyeWide"+$side) ($nameSpace+"ctrlEye"+$side+".blink");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.cheekPuff ($nameSpace+"Cheek"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd shapes.cheekPuff ($nameSpace+"Cheek"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.cheekPuff ($nameSpace+"Cheek"+$side+".tz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd shapes.cheekPuff ($nameSpace+"Cheek"+$side+".tz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.cheekSquint"+$side) ($nameSpace+"ctrlEye"+$side+".squint");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 3 -dv 1 -cd ("shapes.cheekSquint"+$side) ($nameSpace+"ctrlEye"+$side+".squint");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd ("shapes.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.2 -dv 1 -cd ("shapes.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.noseSneer"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("shapes.noseSneer"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.jawForward ($nameSpace+"Jaw_M.tz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd shapes.jawForward ($nameSpace+"Jaw_M.tz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.jawLeft ($nameSpace+"Jaw_M.tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd shapes.jawLeft ($nameSpace+"Jaw_M.tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.jawRight ($nameSpace+"Jaw_M.tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd shapes.jawRight ($nameSpace+"Jaw_M.tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouth"+$leftRight) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("shapes.mouth"+$leftRight) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouth"+$leftRight) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.3 -dv 1 -cd ("shapes.mouth"+$leftRight) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	if (`attributeExists ("zipLips"+$side) ($nameSpace+"ctrlMouth_M")`)
		{
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.mouthClose ($nameSpace+"ctrlMouth_M.zipLips"+$side);
		setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 1 -cd shapes.mouthClose ($nameSpace+"ctrlMouth_M.zipLips"+$side);
		}

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthSmile"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.75 -dv 1 -cd ("shapes.mouthSmile"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthFrown"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.75 -dv 1 -cd ("shapes.mouthFrown"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthDimple"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.75 -dv 1 -cd ("shapes.mouthDimple"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".tx");

	if (`objExists ($nameSpace+"upperLipA"+$side)`) //does not exist for Simplified FaceSetup
		{
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthUpperUp"+$side) ($nameSpace+"upperLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd ("shapes.mouthUpperUp"+$side) ($nameSpace+"upperLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthLowerDown"+$side) ($nameSpace+"lowerLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("shapes.mouthLowerDown"+$side) ($nameSpace+"lowerLipA"+$side+".ty");
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthUpperUp"+$side) ($nameSpace+"upperLip_M.ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.2 -dv 1 -cd ("shapes.mouthUpperUp"+$side) ($nameSpace+"upperLip_M.ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthLowerDown"+$side) ($nameSpace+"lowerLip_M.ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.2 -dv 1 -cd ("shapes.mouthLowerDown"+$side) ($nameSpace+"lowerLip_M.ty");

//	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthPress"+$side) ?;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("shapes.mouthStretch"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.75 -dv 1 -cd ("shapes.mouthStretch"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	}

//setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.mouthFunnel ?;

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.mouthPucker ($nameSpace+"ctrlMouth_M.tx");
setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd shapes.mouthPucker ($nameSpace+"ctrlMouth_M.tx");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.jawOpen ($nameSpace+"ctrlMouth_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v -2 -dv 1 -cd shapes.jawOpen ($nameSpace+"ctrlMouth_M.ty");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.mouthRollUpper ($nameSpace+"ctrlMouth_M.upperRoll");
setDrivenKeyframe -itt "linear" -ott "linear" -v -5 -dv 1 -cd shapes.mouthRollUpper ($nameSpace+"ctrlMouth_M.upperRoll");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.mouthRollLower ($nameSpace+"ctrlMouth_M.lowerRoll");
setDrivenKeyframe -itt "linear" -ott "linear" -v -5 -dv 1 -cd shapes.mouthRollLower ($nameSpace+"ctrlMouth_M.lowerRoll");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.mouthShrugUpper ($nameSpace+"upperLip_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd shapes.mouthShrugUpper ($nameSpace+"upperLip_M.ty");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd shapes.mouthShrugLower ($nameSpace+"lowerLip_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd shapes.mouthShrugLower ($nameSpace+"lowerLip_M.ty");

print ("// FaceCap connected.\n");
}

global proc asConnectMocapX (string $uiName)
{
string $side,$leftRight,$LeftRight;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
string $requiredObj[]={"MocapX"};
for ($obj in $requiredObj)
	if (!`objExists $obj`)
		error ("Required object:\""+$obj+"\" does not exists. Import FBX from the \"Face Cap\" iPhone app first.");

createNode -n AdvancedSkeletonHeadOffset transform;
//setAttr AdvancedSkeletonHeadOffset.r -type float3 90 0 90;
orientConstraint -mo AdvancedSkeletonHeadOffset ($nameSpace+"FKHead_M");

setAttr ($nameSpace+"ctrlBox.limits") 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$leftRight="right";$LeftRight="Right";}
	if ($b==-1) {$side="_L";$leftRight="left";$LeftRight="Left";}

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX."+$leftRight+"EyeTransformRotateY") ($nameSpace+"ctrlEye"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 30 -cd ("MocapX."+$leftRight+"EyeTransformRotateY") ($nameSpace+"ctrlEye"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX."+$leftRight+"EyeTransformRotateX") ($nameSpace+"ctrlEye"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv -30 -cd ("MocapX."+$leftRight+"EyeTransformRotateX") ($nameSpace+"ctrlEye"+$side+".ty");

	setAttr ("ctrlEye"+$side+"_translateX.preInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateX.postInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateY.preInfinity") 4;
	setAttr ("ctrlEye"+$side+"_translateY.postInfinity") 4;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.eyeBlink"+$side) ($nameSpace+"ctrlEye"+$side+".blink");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 1 -cd ("MocapX.eyeBlink"+$side) ($nameSpace+"ctrlEye"+$side+".blink");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.browInnerUp ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.browInnerUp ($nameSpace+"EyeBrowInner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.browDown"+$side) ($nameSpace+"EyeBrowInner"+$side+".tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.browOuterUp"+$side) ($nameSpace+"EyeBrowOuter"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("MocapX.browOuterUp"+$side) ($nameSpace+"EyeBrowOuter"+$side+".ty");

	if (`attributeExists EyeBrowMid2Joint ($nameSpace+"EyeBrowOuter"+$side)`)
		setAttr ($nameSpace+"EyeBrowOuter"+$side+".EyeBrowMid2Joint") .75;
	if (`attributeExists EyeBrowMid1Joint ($nameSpace+"EyeBrowInner"+$side)`)
		setAttr ($nameSpace+"EyeBrowInner"+$side+".EyeBrowMid1Joint") .75;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.eyeSquint"+$side) ($nameSpace+"lowerLid"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("MocapX.eyeSquint"+$side) ($nameSpace+"lowerLid"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.eyeWide"+$side) ($nameSpace+"ctrlEye"+$side+".blink");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd ("MocapX.eyeWide"+$side) ($nameSpace+"ctrlEye"+$side+".blink");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.cheekPuff ($nameSpace+"Cheek"+$side+".tz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.cheekSquint"+$side) ($nameSpace+"ctrlEye"+$side+".squint");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 3 -dv 1 -cd ("MocapX.cheekSquint"+$side) ($nameSpace+"ctrlEye"+$side+".squint");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.2 -dv 1 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"NoseCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.noseSneer"+$side) ($nameSpace+"EyeBrowInner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawForward ($nameSpace+"Jaw_M.tz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.jawForward ($nameSpace+"Jaw_M.tz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawLeft ($nameSpace+"Jaw_M.tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd MocapX.jawLeft ($nameSpace+"Jaw_M.tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawRight ($nameSpace+"Jaw_M.tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd MocapX.jawRight ($nameSpace+"Jaw_M.tx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv 1 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.3 -dv 1 -cd ("MocapX.mouth"+$LeftRight) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	if (`attributeExists ("zipLips"+$side) ($nameSpace+"ctrlMouth_M")`)
		{
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthClose ($nameSpace+"ctrlMouth_M.zipLips"+$side);
		setDrivenKeyframe -itt "linear" -ott "linear" -v 10 -dv 1 -cd MocapX.mouthClose ($nameSpace+"ctrlMouth_M.zipLips"+$side);
		}

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthSmile"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.75 -dv 1 -cd ("MocapX.mouthSmile"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthFrown"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.75 -dv 1 -cd ("MocapX.mouthFrown"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthDimple"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".tx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.75 -dv 1 -cd ("MocapX.mouthDimple"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".tx");

	if (`objExists ($nameSpace+"upperLipA"+$side)`) //does not exist for Simplified FaceSetup
		{
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLipA"+$side+".ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -v -0.5 -dv 1 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLipA"+$side+".ty");
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLip_M.ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0.2 -dv 1 -cd ("MocapX.mouthUpperUp"+$side) ($nameSpace+"upperLip_M.ty");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLip_M.ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.2 -dv 1 -cd ("MocapX.mouthLowerDown"+$side) ($nameSpace+"lowerLip_M.ty");

//	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthPress"+$side) ?;

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ("MocapX.mouthStretch"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	setDrivenKeyframe -itt "linear" -ott "linear" -v -0.75 -dv 1 -cd ("MocapX.mouthStretch"+$side) ($nameSpace+"ctrlMouthCorner"+$side+".ty");
	}

//setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthFunnel ?;

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthPucker ($nameSpace+"ctrlMouth_M.tx");
setDrivenKeyframe -itt "linear" -ott "linear" -v -1 -dv 1 -cd MocapX.mouthPucker ($nameSpace+"ctrlMouth_M.tx");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.jawOpen ($nameSpace+"ctrlMouth_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v -2 -dv 1 -cd MocapX.jawOpen ($nameSpace+"ctrlMouth_M.ty");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthRollUpper ($nameSpace+"ctrlMouth_M.upperRoll");
setDrivenKeyframe -itt "linear" -ott "linear" -v -5 -dv 1 -cd MocapX.mouthRollUpper ($nameSpace+"ctrlMouth_M.upperRoll");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthRollLower ($nameSpace+"ctrlMouth_M.lowerRoll");
setDrivenKeyframe -itt "linear" -ott "linear" -v -5 -dv 1 -cd MocapX.mouthRollLower ($nameSpace+"ctrlMouth_M.lowerRoll");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthShrugUpper ($nameSpace+"upperLip_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd MocapX.mouthShrugUpper ($nameSpace+"upperLip_M.ty");

setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd MocapX.mouthShrugLower ($nameSpace+"lowerLip_M.ty");
setDrivenKeyframe -itt "linear" -ott "linear" -v 0.5 -dv 1 -cd MocapX.mouthShrugLower ($nameSpace+"lowerLip_M.ty");

connectAttr MocapX.transformRotateX AdvancedSkeletonHeadOffset.rx;
connectAttr MocapX.transformRotateY AdvancedSkeletonHeadOffset.ry;
connectAttr MocapX.transformRotateZ AdvancedSkeletonHeadOffset.rz;

print ("// MocapX connected.\n");
}

global proc asAutoLipSyncDownload (string $uiName)
{
string $zipFileUrl="https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/releases/download/v1.1.0-beta.2/montreal-forced-aligner_win64.zip";
if (`about -mac`)
	$zipFileUrl="https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/releases/download/v1.1.0-beta.2/montreal-forced-aligner_macosx.zip";
string $libriSpeechLexiconUrl="http://www.openslr.org/resources/11/librispeech-lexicon.txt";
string $sLoc=`asGetScriptLocation`;
string $curl=$sLoc+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeleton5Files/bin/7za.e";
string $binDir=$sLoc+"/AdvancedSkeleton5Files/bin";
string $downloadDir=$sLoc+"/AdvancedSkeleton5Files/bin/download";
string $tempString[];
tokenize $zipFileUrl "/" $tempString;
string $downloadedZipFile=$tempString[size($tempString)-1];
string $downloadedZipFilePath=$downloadDir+"/"+$downloadedZipFile;
string $cmd;

if (!`file -q -ex $downloadDir`) sysFile -md $downloadDir;

//download Montreal-Forced-Aligner
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -L -o "+$downloadDir+"/"+$downloadedZipFile+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -L -o \""+$downloadDir+"/"+$downloadedZipFile+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+"\n");
	system ($cmd);
	}

//download librispeech-lexicon
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -L -o "+$downloadDir+"/librispeech-lexicon.txt "+$libriSpeechLexiconUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -L -o \""+$downloadDir+"/librispeech-lexicon.txt\" "+$libriSpeechLexiconUrl;
	print ("// Starting Download:"+$cmd+";\n");
	system ($cmd);
	}

//confirm downloads
if (`file -q -ex $downloadedZipFilePath`)
	print ("// Downloaded sucessfully:"+$downloadedZipFilePath+";\n");
else
	error ("// Download failed, could not find:"+$downloadedZipFilePath+";\n");
if (`file -q -ex ($downloadDir+"/librispeech-lexicon.txt")`)
	print ("// Downloaded sucessfully:"+$downloadDir+"/librispeech-lexicon.txt;\n");
else
	error ("// Download failed, could not find:"+$downloadDir+"/librispeech-lexicon.txt;\n");

//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$downloadedZipFilePath+" -d "+$binDir;
else
	$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x \""+$downloadedZipFilePath+"\" -o\""+$binDir+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($binDir+"/montreal-forced-aligner")`)
	print ("// Unzipped sucessfully:"+$downloadedZipFile+";\n");
else
	error ("// Unzipp failed, could not find:"+$binDir+"/montreal-forced-aligner\n");

//Delete download
if (`filetest -f $downloadedZipFilePath`)
	sysFile -del $downloadedZipFilePath;
//Delete montreal-forced-aligner_win64.zip (1kb file that comes with the zip)
if (`filetest -f ($binDir+"/montreal-forced-aligner_win64.zip")`)
	sysFile -del ($binDir+"/montreal-forced-aligner_win64.zip");

//Move librispeech-lexicon.txt
sysFile -ren ($binDir+"/montreal-forced-aligner/bin/librispeech-lexicon.txt") ($downloadDir+"/librispeech-lexicon.txt");

asAutoLipSyncUI $uiName;
}

global proc asAutoLipSyncFfmpegDownload ()
{
//ffmpeg for $segmentReplacing
string $zipFileUrl="http://www.advancedskeleton.com/download/div/ffmpeg.7z";
string $ffmpegFile="ffmpeg.e";
if (`about -mac`)
	{
	$zipFileUrl="http://www.advancedskeleton.com/download/div/ffmpeg_mac.7z";
	$ffmpegFile="ffmpeg";
	}
string $sLoc=`asGetScriptLocation`;
string $curl=$sLoc+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeleton5Files/bin/7za.e";
string $forceAlignerBinDir=$sLoc+"/AdvancedSkeleton5Files/bin/montreal-forced-aligner/bin";
string $downloadDir=$sLoc+"/AdvancedSkeleton5Files/bin/download";
string $tempString[];
tokenize $zipFileUrl "/" $tempString;
string $downloadedZipFile=$tempString[size($tempString)-1];
string $downloadedZipFilePath=$downloadDir+"/"+$downloadedZipFile;
string $cmd;

if (!`file -q -ex $downloadDir`) sysFile -md $downloadDir;

//download
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -k -o "+$downloadedZipFilePath+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -o \""+$downloadedZipFilePath+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+";\n");
	system ($cmd);
	}

//confirm downloads
if (`file -q -ex $downloadedZipFilePath`)
	print ("// Downloaded sucessfully:"+$downloadedZipFilePath+";\n");
else
	error ("// Download failed, could not find:"+$downloadedZipFilePath+"\n");

//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$downloadedZipFilePath+" -d "+$forceAlignerBinDir;
else
	$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x \""+$downloadedZipFilePath+"\" -o\""+$forceAlignerBinDir+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($forceAlignerBinDir+"/"+$ffmpegFile)`)
	print ("// Unzipped sucessfully:"+$downloadedZipFile+";\n");
else
	error ("// Unzipp failed, could not find:"+$forceAlignerBinDir+"/"+$ffmpegFile+"\n");

//Delete download
if (`filetest -f $downloadedZipFilePath`)
	sysFile -del $downloadedZipFilePath;
}

global proc asAutoLipSyncUI (string $uiName)
{
string $nameSpace,$alignerDir;
//If we `have` AdvancedSkeleton, then location will be "AdvancedSkeleton5Files/bin"
//otherwise this is run by animator, that only have Selector (or Picker) tool, and location will be "Selector/bin"
if (`exists asGetScriptLocation`)
	$alignerDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/bin/montreal-forced-aligner";
else if (`exists asSelectorScriptLocation`)
	{
	$alignerDir=`asSelectorScriptLocation`+"bin/montreal-forced-aligner_win64";
	//Could be that we `have` AdvancedSkeleton, it was just not sourced, then used the `standard` dir
	if (`gmatch $alignerDir "*/AdvancedSkeleton5Files/*"`)
		error "Seems AdvancedSkeleton is installed, please open the AdvancedSkeleton tool first";
	else
		error ("Seems AdvancedSkeleton is not installed (only running Selector or Picker)\n"
		+"To get AutoLipSync working, download Montreal-Forced-Aligner from:\n"
		+"https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/releases/download/v1.1.0-beta.2/montreal-forced-aligner_win64.zip\n"
		+"download and extract the files, so you get this available file-path:\n"
		+$alignerDir+"/bin/mfa_align.exe");
	}
else
	error "Unable to run `asGetScriptLocation`, and unable to run `asSelectorScriptLocation`, so unable to determine directory for force-aligner.";
string $aligner=$alignerDir+"/bin/mfa_align";
if (`about -win`)
	$aligner=$alignerDir+"/bin/mfa_align.exe";
int $haveAligner=`file -q -ex $aligner`;

if ($uiName!="")
	if (`optionMenu -q -ex ($uiName+"OptionMenu")`)
		$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";

if (`window -q -ex asAutoLipSyncUI`)
    deleteUI asAutoLipSyncUI;
window -t AutoLipSync -w 300 -h 200 asAutoLipSyncUI;
formLayout asAutoLipSyncUIFormLayout;
columnLayout asAutoLipSyncUIColumnLayout;
if (!$haveAligner)
	{
	separator -h 5 -st none;
	text -l "To run AutoLipSync,";
	text -l "first download \"Montreal-Forced-Aligner\"";
	separator -h 5 -st none;
	button -l "Download Montreal-Forced-Aligner" -c ("asAutoLipSyncDownload "+$uiName);
	showWindow;
	print ("// Montreal-Forced-Aligner tool must be downloaded first\n");
	print ("// If the automatic download does not work, you can manually download from:\n");
	print ("// https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/releases\n");
	print ("// download and extract the files, so you get this available file-path:\n");
	print ("// "+$aligner+"\n");
	print ("\n");
	return;
	}

text -m 0 -l $aligner asAutoLipSyncAlignerText;
separator -h 10 -st none;
columnLayout;
	text -l "Add Idle motions:";
	rowLayout -nc 5;
		checkBox -l "Blink" -v 1 asAutoLipSyncBlinkCheckBox;
		checkBox -l "EyeBrows" -v 1 asAutoLipSyncEyeBrowsCheckBox;
		checkBox -l "Head" -v 1 asAutoLipSyncHeadCheckBox;
		setParent..;
	setParent..;

separator -h 20 -st none;
setParent..;
scrollField -wordWrap false -text "Dialog text here" asAutoLipSyncUIScrollField;
frameLayout -w 300 -cll 1 -cl 1 -l "advanced options" asAutoLipSyncUIFrameLayout;
	columnLayout -adj 1;
		rowLayout -nc 3;
			text -l "phoneme  fadeIn   ";
			floatField -pre 3 -v 0.05 -min 0.001 asAutoLipSyncPhonemeInFloatField;
			text -l "seconds";
			setParent..;
		rowLayout -nc 3;
			text -l "phoneme  fadeOut";
			floatField -pre 3 -v 0.05 -min 0.001 asAutoLipSyncPhonemeOutFloatField;
			text -l "seconds";
			setParent..;
		rowLayout -nc 3;
			checkBox -l "always re-code audio file" asAutoLipSyncAlwaysReCodeCheckBox;		
			setParent..;
		rowLayout -nc 6;
			separator -w 5 -st none;
			button -l "import example voice" -c asAutoLipSyncImportExampleVoice;
			separator -w 5 -st none;
			button -l "visit ibm.com/watson" -c "showHelp -a \"https://www.ibm.com/watson/services/text-to-speech/\"";
			separator -w 5 -st none;
			button -l "enable mp3" -c "asAutoLipSyncEnableMp3";
			setParent..;
		separator;
		setParent..;
	setParent..;
columnLayout asAutoLipSyncUIColumnLayout2;
separator -h 5 -st none;

rowLayout -nc 3;
	separator -w 50 -st none;
	button -w 100 -l "Run Auto LipSync" -c ("asAutoLipSyncForceAlign \""+$nameSpace+"\"");

formLayout -e 
	-ac asAutoLipSyncUIScrollField "top" 0 asAutoLipSyncUIColumnLayout
	-af asAutoLipSyncUIScrollField "left" 0
	-af asAutoLipSyncUIScrollField "right" 0
	-ac asAutoLipSyncUIScrollField "bottom" 0 asAutoLipSyncUIFrameLayout

	-ac asAutoLipSyncUIFrameLayout "bottom" 0 asAutoLipSyncUIColumnLayout2

	-af asAutoLipSyncUIColumnLayout2 "bottom" 5
	-af asAutoLipSyncUIFrameLayout "left" 0
	-af asAutoLipSyncUIFrameLayout "right" 0
	asAutoLipSyncUIFormLayout;

showWindow;
}

global proc asAutoLipSyncForceAlign (string $nameSpace)
{
global string $gPlayBackSlider;
int $segmentReplacing=0;
int $alwaysReCode=`checkBox -q -v asAutoLipSyncAlwaysReCodeCheckBox`;
float $timeRangeArray[]=`timeControl -q -rangeArray $gPlayBackSlider`;
if (($timeRangeArray[1]-$timeRangeArray[0])>1)
	$segmentReplacing=1;
float $currentTimeUnitToFPS=`currentTimeUnitToFPS`;
if ($currentTimeUnitToFPS<1) $currentTimeUnitToFPS=1;
string $tempString[];
string $aligner=`text -q -l asAutoLipSyncAlignerText`;
tokenize $aligner "/" $tempString;
string $lexicon=`substitute $tempString[size($tempString)-1] $aligner "librispeech-lexicon.txt"`;
string $ffmpeg=`substitute $tempString[size($tempString)-1] $aligner "ffmpeg.e"`;
if (`about -mac`)
	$ffmpeg=`substitute $tempString[size($tempString)-1] $aligner "ffmpeg"`;
string $tempDir=`asGetTempDirectory`+"AdvancedSkeleton/autoLipSync/";
string $audioNode = `timeControl -q -s $gPlayBackSlider`;
if (!`objExists $audioNode`)
	error "No sound found. Make sure to import a sound file first";
string $soundFile=`getAttr ($audioNode+".filename")`;
tokenize $soundFile "/" $tempString;
string $soundFileBaseName=$tempString[size($tempString)-1];
tokenize $soundFile "." $tempString;
string $soundFileExt=$tempString[size($tempString)-1];
string $forceSoundFile=$tempDir+"input/align."+$soundFileExt;
string $forceTextFile=$tempDir+"input/align.txt";
string $textGridFile=$tempDir+"output/align.TextGrid";
string $forceText=`scrollField -q -tx asAutoLipSyncUIScrollField`;
string $cmd="start\/wait/I \"Force Aligning\" \""+$aligner+"\" -c \""+$tempDir+"input/\" \""+$lexicon+"\" english \""+$tempDir+"output/\"";
string $ffMpegCmd="start\/wait/I \"Coding Audio\" "+$ffmpeg+" -y -i \""+$soundFile+"\"";
string $acusticModelFile;

if (!`file -q -ex $soundFile`)
	error "Not a valid sound file";

$forceText=`substituteAllString $forceText "`" ""`;

//Remove old results
$tempString=`getFileList -fld ($tempDir+"output")`;
for ($i=0;$i<size($tempString);$i++)
	sysFile -del ($tempDir+"output/"+$tempString[$i]);

if (!`file -q -ex ($tempDir+"input")`) sysFile -md ($tempDir+"input");
if (!`file -q -ex ($tempDir+"output")`) sysFile -md ($tempDir+"output");
sysFile -cp $forceSoundFile $soundFile;

if ($segmentReplacing || $alwaysReCode)
	if (!`file -q -ex $ffmpeg`)
		asAutoLipSyncFfmpegDownload;
	
if ($segmentReplacing)
	{//If range in the timeLine is highlighted, then we assume to run "Correction" for this segment
	print ("// Segment selection found on Timeline-slider, trimming audio to selection.\n");
	$ffMpegCmd+=" -ss "+($timeRangeArray[0]/$currentTimeUnitToFPS)+" -to "+($timeRangeArray[1]/$currentTimeUnitToFPS)+" "+$forceSoundFile;
	print ("// Starting Trimming Audio:"+$ffMpegCmd+"\n");
	system ($ffMpegCmd);
	}
else if ($alwaysReCode)
	{
	$ffMpegCmd+=" "+$forceSoundFile;
	print ("// Starting ReCode Audio:"+$ffMpegCmd+"\n");
	system ($ffMpegCmd);	
	}

$fileId=`fopen $forceTextFile "w"`;
fprint $fileId $forceText;
fclose $fileId;

if ($forceText!="")
	{
	print ("// Starting Force Aligning:"+$cmd+"\n");
	system ($cmd);
	}
else
	{
	$fileId=`fopen $textGridFile "w"`;
	fprint $fileId "";
	fclose $fileId;
	}

if (`file -q -ex $textGridFile`)
	print ("// Successfully created:\""+$textGridFile+"\".\n");
else
	{
	if (`file -q -ex ($tempDir+"output/unaligned.txt")`)
		{
		$fileId=`fopen ($tempDir+"output/unaligned.txt") "r"`;
		$tempString[0]=`fread $fileId $tempString[0]`;
		print ($tempString[0]+"\n");
		fclose $fileId;
		}
	//Try with ffmpeg
	if (!$alwaysReCode)
		{
		if (`confirmDialog -title "Confirm" -message "Force Align Failed.\nThis could be a compatibility issues with the sound-file.\nTry to re-code sound-file?"
  	  -button "Yes" -button "No" -defaultButton "Yes"
    	-cancelButton "No" -dismissString "No"`=="Yes")
    		{
    		checkBox -e -v 1 asAutoLipSyncAlwaysReCodeCheckBox;
    		asAutoLipSyncForceAlign $nameSpace;
    		return;
    		}
		}
	error ("Failed to create:\""+$textGridFile+"\".\n");
	}

asAutoLipSyncImport $nameSpace;
}

global proc asAutoLipSyncImport (string $nameSpace)
{
global string $gMainProgressBar;
global string $gPlayBackSlider;
int $segmentReplacing=0;
float $timeRangeArray[]=`timeControl -q -rangeArray $gPlayBackSlider`;
int $wordsSection,$phonesSection,$fileId;
int $autoBlink=`checkBox -q -v asAutoLipSyncBlinkCheckBox`;
int $autoEyeBrows=`checkBox -q -v asAutoLipSyncEyeBrowsCheckBox`;
int $autoHead=`checkBox -q -v asAutoLipSyncHeadCheckBox`;
int $lastKeyFrameNr,$nextBlinkTriggFrameNr,$nextHeadTriggFrameNr,$wordNr;
if (!`objExists ($nameSpace+"FKHead_M")`) $autoHead=0;
float $prePhoneTime=`floatField -q -v asAutoLipSyncPhonemeInFloatField`;
float $postPhoneTime=`floatField -q -v asAutoLipSyncPhonemeOutFloatField`;
float $sequenceStart=-1;
float $sequenceEnd=-1;
float $wordSpace=0.25;
float $scale=`asFaceGetScale`;
float $currentTimeUnitToFPS=`currentTimeUnitToFPS`;
if ($currentTimeUnitToFPS<1) $currentTimeUnitToFPS=1;
float $xMin,$xMax,$segRepOffset,$keyValue,$previousKeyTime;
float $wordStarts[],$wordEnds[],$phoneStarts[],$phoneEnds[],$bb[],$keyTimes[],$pos[];
string $aligner=`text -q -l asAutoLipSyncAlignerText`;
string $tempDir=`asGetTempDirectory`+"AdvancedSkeleton/autoLipSync/";
string $textGridFile=$tempDir+"output/align.TextGrid";
string $nextLine,$para,$value;
string $tempString[],$words[],$phones[],$missingPhoneParts[],$letters[],$deleteObjs[],$texts[],$chars[];
string $currentTimeUnit=`currentUnit -q -t`;
string $audioNode = `timeControl -q -s $gPlayBackSlider`;
float $offset=`getAttr ($audioNode+".offset")`/$currentTimeUnitToFPS;

if (!`objExists ($nameSpace+"ctrlPhonemes_M")`)
	error ($nameSpace+"ctrlPhonemes_M not found");

if (($timeRangeArray[1]-$timeRangeArray[0])>1 && `objExists ($nameSpace+"subTitles")`)
	$segmentReplacing=1;

if ($segmentReplacing)
	{
	//Remove all subtitles in segment (and onwards
	select -cl;
	$pos=`xform -q -ws -t ($nameSpace+"subTitlesArrowShape.cv[3]")`;
	$texts=`listRelatives -c ($nameSpace+"subTitlesRoller")`;
	currentTime $timeRangeArray[0];
	$previousKeyTime=`findKeyframe -which previous ($nameSpace+"subTitlesRoller.tx")`;

	for ($i=0;$i<size($texts);$i++)
		{
		$chars=`listRelatives -c $texts[$i]`;
		for ($y=0;$y<size($chars);$y++)
			if ((`getAttr -t $previousKeyTime ($nameSpace+"subTitlesRoller.tx")`*-1)<=`getAttr ($texts[$i]+".tx")`)
				select -add $texts[$i];
		}

	if (size(`ls -sl`))
		delete;

	//Remove subTitlesRoller keyframes as well
	if (`objExists ($nameSpace+"subTitlesRoller")`)
		cutKey -time ($timeRangeArray[0]+":99999") -attribute translateX -option keys ($nameSpace+"subTitlesRoller");
	cutKey -time ($timeRangeArray[0]+":99999") -option keys ($nameSpace+"ctrlPhonemes_M");
	}

currentUnit -t "sec";
evalDeferred ("catchQuiet(`currentUnit -t "+$currentTimeUnit+"`)");

if ($segmentReplacing)
	$segRepOffset=`currentTime -q`;

if ($segmentReplacing)
	{
	if (`objExists subTitles_parentConstraint1`)
		delete subTitles_parentConstraint1;
	if (`objExists ($nameSpace+"subTitles")`)
		xform -ws -t 0 0 0 -ro 0 0 0 -s 1 1 1 ($nameSpace+"subTitles");
	}
else
	{
	$deleteObjs={"subTitles","subTitlesExp","subTitlesBox","subTitlesArrow","subTitlesBoxMPD"};
	for ($i=0;$i<size($deleteObjs);$i++)
		if (`objExists ($nameSpace+$deleteObjs[$i])`)
			delete ($nameSpace+$deleteObjs[$i]);

	createNode -n ($nameSpace+"subTitles") transform;
	createNode -n ($nameSpace+"subTitlesRoller") -p ($nameSpace+"subTitles") transform;
	$tempString[0]=`curve -d 1 -p -4 1.25 0 -p -4 -0.5 0 -p 4 -0.5 0 -p 4 1.25 0 -p -4 1.25 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
	rename $tempString[0] ($nameSpace+"subTitlesBox");
	setAttr ($nameSpace+"subTitlesBoxShape.overrideEnabled") 1;
	setAttr ($nameSpace+"subTitlesBoxShape.overrideColor") 13;
	$tempString[0]=`curve -d 1 -p 0 0.65 0 -p 0.127 1.2 0 -p -0.127 1.2 0 -p 0 0.65 0 -k 0 -k 1 -k 2 -k 3`;
	parent ($nameSpace+"subTitlesBox") ($nameSpace+"subTitles");
	addAttr -k 1 -ln textVisCenter -at double -dv 4.5 ($nameSpace+"subTitlesBox");
	addAttr -k 1 -ln textVisLenght -at double -dv 8 ($nameSpace+"subTitlesBox");
	createNode -n ($nameSpace+"subTitlesBoxMPD") multiplyDivide;
	connectAttr ($nameSpace+"subTitlesBox.sx") ($nameSpace+"subTitlesBoxMPD.input1X");
	connectAttr ($nameSpace+"subTitlesBox.sx") ($nameSpace+"subTitlesBoxMPD.input1Y");
	setAttr ($nameSpace+"subTitlesBoxMPD.input2") -type float3 4 8 0;
	connectAttr ($nameSpace+"subTitlesBoxMPD.outputX") ($nameSpace+"subTitlesBox.textVisCenter");
	connectAttr ($nameSpace+"subTitlesBoxMPD.outputY") ($nameSpace+"subTitlesBox.textVisLenght");

	rename $tempString[0] ($nameSpace+"subTitlesArrow");
	setAttr ($nameSpace+"subTitlesArrowShape.overrideEnabled") 1;
	setAttr ($nameSpace+"subTitlesArrowShape.overrideColor") 13;
	parent -add -s ($nameSpace+"subTitlesArrowShape") ($nameSpace+"subTitlesBox");
	delete ($nameSpace+"subTitlesArrow");

	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"ctrlPhonemes_M")`;
	if (size($tempString)) delete $tempString;
	$tempString=`listAttr -ud ($nameSpace+"ctrlPhonemes_M")`;
	for ($i=0;$i<size($tempString);$i++)
		if (!`getAttr -l ($nameSpace+"ctrlPhonemes_M."+$tempString[$i])`)
			setAttr ($nameSpace+"ctrlPhonemes_M."+$tempString[$i]) 0;
	if (`attributeExists jaw ($nameSpace+"ctrlPhonemes_M")`)//could have converted to SimplifiedFaceSetup
		{
		setAttr ($nameSpace+"ctrlPhonemes_M.jaw") 0.25;
		setAttr ($nameSpace+"ctrlPhonemes_M.lip") 0.25;
		}
	}

$fileId=`fopen $textGridFile "r"`;
$nextLine = `fgetline $fileId`;
while (size($nextLine)>0)
	{
	$line=`strip $nextLine`;
	tokenize $line " = " $tempString;
	$para=$tempString[0];
	$value=$tempString[1];
	if ($sequenceStart==-1 && $para=="xmin") $sequenceStart=$value;
	if ($sequenceEnd==-1 && $para=="xmax") $sequenceEnd=$value;
	if ($para=="name" && $value=="\"words\"") $wordsSection=1;
	if ($para=="name" && $value=="\"phones\"") {$phonesSection=1;$wordsSection=0;}
	if ($para=="xmin") $xMin=$value;
	if ($para=="xmax") $xMax=$value;
	if ($wordsSection && $para=="text")
		{
		$tempString[0]=`substituteAllString $value "\"" ""`;
		if ($tempString[0]!="")
			{
			$words[size($words)]=$tempString[0];
			$wordStarts[size($wordStarts)]=$xMin+$segRepOffset+$offset;
			$wordEnds[size($wordEnds)]=$xMax+$segRepOffset+$offset;
			}
		}
	if ($phonesSection && $para=="text")
		{
		$tempString[0]=`substituteAllString $value "\"" ""`;
		if ($tempString[0]!="")
			{
			$phones[size($phones)]=$tempString[0];
			$phoneStarts[size($phoneStarts)]=$xMin+$segRepOffset+$offset;
			$phoneEnds[size($phoneEnds)]=$xMax+$segRepOffset+$offset;
			}
		}
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

for ($i=0;$i<size($words);$i++)
	if ($words[$i]=="<unk>")
		$words[$i]="***";

if (!$segmentReplacing)
	playbackOptions -min ($sequenceStart+$offset) -ast ($sequenceStart+$offset) -aet ($sequenceEnd+$offset) -max ($sequenceEnd+$offset);

//ensure key of value 0 at frame 0
setKeyframe -itt linear -ott linear -t 0 -v 0 ($nameSpace+"subTitlesRoller.tx");

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Reading Data" -bp -ii 1 -min 0 -max (size($words)+1) $gMainProgressBar;
for ($i=0;$i<9999;$i++)
	if (!`objExists ($nameSpace+"text"+$i)`)
		break;
$wordNr=$i;
for ($i=0;$i<size($words);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		error "Interrupted";
	currentTime $wordStarts[$i];
	$tempString=`textCurves -f "Times New Roman|wt:50|sz:28" -t $words[$i]`;
	delete `ls -type makeTextCurves`;
	rename $tempString[0] ($nameSpace+"text"+$wordNr);

	setAttr ($nameSpace+"text"+$wordNr+".tx") $wordSpace;//word spacing
	parent ($nameSpace+"text"+$wordNr) ($nameSpace+"subTitlesRoller");
	setKeyframe -itt linear -ott linear -t $wordStarts[$i] -v (`getAttr ($nameSpace+"subTitlesRoller.tx")`-$wordSpace) ($nameSpace+"subTitlesRoller.tx");
	$bb=`xform -q -ws -bb ($nameSpace+"text"+$wordNr)`;
	$keyValue=`getAttr ($nameSpace+"subTitlesRoller.tx")`-($bb[0]+$bb[3]);
	setKeyframe -itt linear -ott linear -t $wordEnds[$i] -v $keyValue ($nameSpace+"subTitlesRoller.tx");
	$wordNr++;
	}

for ($i=0;$i<size($phones);$i++)
	{
	$phoneme=`asAutoLipSyncPhonemeMapping $phones[$i]`;

	if ($phoneme=="")
		{
		if (!`stringArrayCount $phones[$i] $missingPhoneParts`)
			if ($phones[$i]!="sil" && $phones[$i]!="sp" && $phones[$i]!="spn")
				$missingPhoneParts[size($missingPhoneParts)]=$phones[$i];
		continue;
		}

	setKeyframe -v 0 -t ($phoneStarts[$i]-$prePhoneTime) ($nameSpace+"ctrlPhonemes_M."+$phoneme);
	setKeyframe -v 10 -t (($phoneStarts[$i]+$phoneEnds[$i])/2.0) ($nameSpace+"ctrlPhonemes_M."+$phoneme);
	setKeyframe -v 0 -t ($phoneEnds[$i]+$postPhoneTime) ($nameSpace+"ctrlPhonemes_M."+$phoneme);
	}

if (size($missingPhoneParts))
	{
	print "Found the following phonemes, that are not mapped to the current FaceSetup:\n";
	print $missingPhoneParts;
	}
progressBar -e -ep $gMainProgressBar;

currentTime 0;
currentUnit -t $currentTimeUnit;

//Find each letter`s offset, and animate visibility to be visible only inside box
//currentUnit -t "pal";
currentTime 0 ;
$tempString=`listRelatives -ad ($nameSpace+"subTitles")`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] "Char_*"`)
		continue;
	$letters[size($letters)]=$tempString[$i];
	}
$bb=`xform -q -ws -bb ($nameSpace+"subTitlesBox")`;
$boxWidth=($bb[3]-$bb[0])/`getAttr ($nameSpace+"subTitles.sx")`;
if ($nameSpace!="" && `objExists subTitlesRoller_translateX`)
	rename subTitlesRoller_translateX ($nameSpace+"subTitlesRoller_translateX");
$keyTimes=`keyframe -q -tc ($nameSpace+"subTitlesRoller_translateX")`;
$lastKeyFrameNr=$keyTimes[size($keyTimes)-1];
progressBar -e -st "Animating text visibility" -bp -ii 1 -min 0 -max ($lastKeyFrameNr+1) $gMainProgressBar;
for ($y=0;$y<size($letters);$y++)
	{
	if (`objExists ($letters[$y]+"PMA")`)
		continue;
	createNode -n ($letters[$y]+"PMA") plusMinusAverage;
	connectAttr -f ($nameSpace+"subTitlesRoller_translateX.output") ($letters[$y]+"PMA.input1D[1]");
	connectAttr -f ($nameSpace+"subTitlesBox.textVisCenter") ($letters[$y]+"PMA.input1D[2]");
	$bb=`xform -q -ws -bb $letters[$y]`;
	setAttr ($letters[$y]+"PMA.input1D[0]") ($bb[0]+0.5);
	createNode -n ($letters[$y]+"Clamp") clamp;
	connectAttr -f ($letters[$y]+"PMA.output1D") ($letters[$y]+"Clamp.inputR");
	setAttr ($letters[$y]+"Clamp.maxR") 1000;
	createNode -n ($letters[$y]+"Condition") condition;
	setAttr ($letters[$y]+"Condition.operation") 2;
	connectAttr -f ($letters[$y]+"Clamp.outputR") ($letters[$y]+"Condition.firstTerm");
	connectAttr -f ($letters[$y]+"Clamp.outputR") ($letters[$y]+"Condition.colorIfFalseR");
	connectAttr -f ($nameSpace+"subTitlesBox.textVisLenght") ($letters[$y]+"Condition.secondTerm");
	connectAttr -f ($letters[$y]+"Condition.outColorR") ($letters[$y]+".v");
	}

//Place subTitles
$bb=`xform -q -ws -bb ($nameSpace+"subTitles")`;
setAttr ($nameSpace+"subTitles.s") -type float3 ($scale/10.0) ($scale/10.0) ($scale/10.0);
$bb=`xform -q -ws -bb ($nameSpace+"ctrlBox")`;
$bb2=`xform -q -ws -bb ($nameSpace+"ctrlPhonemes_M")`;
$bb3=`xform -q -ws -bb ($nameSpace+"subTitlesBox")`;
xform -ws -t ($bb[3]+$bb3[3]*1.2) $bb2[1] $bb[5] ($nameSpace+"subTitles");
parentConstraint -mo ($nameSpace+"ctrlBox") ($nameSpace+"subTitles");

if ($segmentReplacing)
	{
	select -r ($nameSpace+"subTitles");
	currentTime $timeRangeArray[0];
	dgdirty -a;
	return;
	}

//Remove existing animation, if Idle animations is to be added
if ($autoBlink)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"ctrlEye_R") ($nameSpace+"ctrlEye_L")`;
	if (size($tempString)) delete $tempString;
	}
if ($autoEyeBrows)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"ctrlBrow_R") ($nameSpace+"ctrlBrow_L")`;
	if (size($tempString)) delete $tempString;
	}
if ($autoHead)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve ($nameSpace+"FKHead_M")`;
	if (size($tempString)) delete $tempString;
	}


//Add Idle animations
if ($autoHead)
	setAttr ($nameSpace+"AimEye_M.follow") 0;
$nextBlinkTriggFrameNr=$keyTimes[0]+`rand 25 40`;
$nextHeadTriggFrameNr=$keyTimes[0]+`rand 80 100`;
for ($i=1;$i<`playbackOptions -q -max`;$i++)
	{
	if ($i<$keyTimes[0])
		continue;//no Idle-anim before first word
	if ($autoBlink && $i==$nextBlinkTriggFrameNr)
		{
		$nextBlinkTriggFrameNr=$i+`rand 50 250`;
		setKeyframe -t $i -v 1.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+1) -v 10 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+3) -v 10 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+6) -v 1.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");

		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*1/4)) -v 2.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*3.8/4)) -v 2.5 ($nameSpace+"ctrlEye_L.blink") ($nameSpace+"ctrlEye_R.blink");
		//squint
		$tempFloat[0]=`rand 1 5`;
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*1.5/4)) -v 0 ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*2/4)) -v $tempFloat[0] ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*3.8/4)) -v $tempFloat[0] ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");
		setKeyframe -t ($i+(($nextBlinkTriggFrameNr-$i)*4/4)) -v 0 ($nameSpace+"ctrlEye_L.squint") ($nameSpace+"ctrlEye_R.squint");

		}
	if ($autoHead && $i==$nextHeadTriggFrameNr)
		{
		$nextHeadTriggFrameNr=$i+`rand 25 300`;
		$moveDur=`rand 5 20`;
		$tempFloat=`getAttr -t $i ($nameSpace+"FKHead_M.r")`;
		setKeyframe -t $i -v $tempFloat[0] ($nameSpace+"FKHead_M.rx");
		setKeyframe -t $i -v $tempFloat[1] ($nameSpace+"FKHead_M.ry");
		setKeyframe -t $i -v $tempFloat[2] ($nameSpace+"FKHead_M.rz");
			setKeyframe -t ($i+($moveDur/2.0)) -v ($tempFloat[2]-4) ($nameSpace+"FKHead_M.rz");
		setKeyframe -t ($i+$moveDur) -v `rand -8 8` ($nameSpace+"FKHead_M.rx");
		setKeyframe -t ($i+$moveDur) -v `rand -4 4` ($nameSpace+"FKHead_M.ry");
		setKeyframe -t ($i+$moveDur) -v `rand -2 2` ($nameSpace+"FKHead_M.rz");
		if ($autoEyeBrows)
			{
			$tempFloat=`getAttr -t $i ($nameSpace+"ctrlBrow_R.t")`;
			setKeyframe -t ($i+($moveDur/2.0)) -v $tempFloat[0] ($nameSpace+"ctrlBrow_R.tx") ($nameSpace+"ctrlBrow_L.tx");
			setKeyframe -t ($i+($moveDur/2.0)) -v $tempFloat[1] ($nameSpace+"ctrlBrow_R.ty") ($nameSpace+"ctrlBrow_L.ty");
			setKeyframe -t ($i+$moveDur) -v `rand -0.8 0.8` ($nameSpace+"ctrlBrow_R.tx") ($nameSpace+"ctrlBrow_L.tx");
			setKeyframe -t ($i+$moveDur) -v `rand -0.8 0.8` ($nameSpace+"ctrlBrow_R.ty") ($nameSpace+"ctrlBrow_L.ty");
			}
		}
	}

select -r ($nameSpace+"subTitles");
dgdirty -a;
}

global proc string asAutoLipSyncPhonemeMapping (string $phone)
{
string $phoneme;
if ($phone=="EY1") $phoneme="aaa";
if ($phone=="Z") $phoneme="sss";
if ($phone=="B") $phoneme="mbp";
if ($phone=="AA2") $phoneme="aaa";
if ($phone=="D") $phoneme="lntd";
if ($phone=="IY0") $phoneme="tth";//
if ($phone=="K") $phoneme="gk";
if ($phone=="AO2") $phoneme="ohh";
if ($phone=="R") $phoneme="rrr";
if ($phone=="T") $phoneme="lntd";
if ($phone=="G") $phoneme="gk";
if ($phone=="AH0") $phoneme="ahh";//
if ($phone=="OY1") $phoneme="ohh";
if ($phone=="N") $phoneme="lntd";
if ($phone=="L") $phoneme="lntd";
if ($phone=="M") $phoneme="mbp";
if ($phone=="AY1") $phoneme="ahh";//
if ($phone=="OW2") $phoneme="ohh";
if ($phone=="S") $phoneme="sss";
if ($phone=="P") $phoneme="mbp";
if ($phone=="EH2") $phoneme="eh";
if ($phone=="IY1") $phoneme="iee";
if ($phone=="AY2") $phoneme="aaa";
if ($phone=="OW1") $phoneme="ohh";
if ($phone=="ER0") $phoneme="schwa";//
if ($phone=="UW1") $phoneme="ohh";
if ($phone=="W") $phoneme="www";
if ($phone=="DH") $phoneme="lntd";
if ($phone=="JH") $phoneme="ssh";//
if ($phone=="IH1") $phoneme="iee";
if ($phone=="IH0") $phoneme="iee";
if ($phone=="NG") $phoneme="gk";
if ($phone=="IH2") $phoneme="eh";
if ($phone=="V") $phoneme="schwa";//
if ($phone=="AA1") $phoneme="ohh";
if ($phone=="TH") $phoneme="lntd";
if ($phone=="ZH") $phoneme="ssh";
if ($phone=="AE2") $phoneme="aaa";
if ($phone=="SH") $phoneme="ssh";
if ($phone=="EH1") $phoneme="eh";
if ($phone=="AA0") $phoneme="aaa";
if ($phone=="F") $phoneme="fff";
if ($phone=="AW1") $phoneme="www";
if ($phone=="AE1") $phoneme="aaa";
if ($phone=="OW0") $phoneme="ohh";
if ($phone=="AW2") $phoneme="aaa";
if ($phone=="EY2") $phoneme="eh";
if ($phone=="EY0") $phoneme="aaa";
if ($phone=="AE0") $phoneme="aaa";
if ($phone=="IY2") $phoneme="iee";
if ($phone=="CH") $phoneme="ssh";
if ($phone=="ER1") $phoneme="ahh";
if ($phone=="EH0") $phoneme="ahh";//
if ($phone=="UW2") $phoneme="ohh";
if ($phone=="AH1") $phoneme="ohh";
if ($phone=="HH") $phoneme="schwa";//
if ($phone=="AH2") $phoneme="ahh";
if ($phone=="AO0") $phoneme="ahh";
if ($phone=="OY2") $phoneme="ohh";
if ($phone=="OY0") $phoneme="ohh";
if ($phone=="UH1") $phoneme="ohh";
if ($phone=="AO1") $phoneme="ohh";
if ($phone=="UW0") $phoneme="ohh";
if ($phone=="Y") $phoneme="uuu";//
if ($phone=="AW0") $phoneme="aaa";
if ($phone=="AY0") $phoneme="ahh";
if ($phone=="ER2") $phoneme="ohh";
if ($phone=="UH0") $phoneme="uuu";
if ($phone=="UH2") $phoneme="ohh";
return $phoneme;
}

global proc asAutoLipSyncImportExampleVoice ()
{
string $soundFile,$text;
string $asScriptLocation;
if (`exists asGetScriptLocation`)
	$asScriptLocation=`asGetScriptLocation`;
else if (`exists asSelectorScriptLocation`)
	error "Seems AdvancedSkeleton is installed, please open the AdvancedSkeleton tool first";

$soundFile=$asScriptLocation+"/AdvancedSkeleton5Files/div/sound/exampleVoice.wav";
if (!`file -q -ex $soundFile`)
	error ("Unable to find the file:\""+$soundFile+"\"");
if (`objExists exampleVoice`)
	delete exampleVoice;
file -import -type "audio" -ignoreVersion -mergeNamespacesOnClash false -rpr "exampleVoice" -options "o=0" $soundFile;

$text="Conscious of its spiritual and moral heritage, the Union is founded on the indivisible, universal values of human dignity,\n";
$text+="freedom, equality and solidarity; it is based on the principles of democracy and the rule of law. It places the individual\n";
$text+="at the heart of its activities, by establishing the citizenship of the Union and by creating an area of freedom, security and justice.";
scrollField -e -tx $text asAutoLipSyncUIScrollField;

print ("// Example voice imported, you can now Run Auto LipSync.\n");
}

global proc asAutoLipSyncEnableMp3 ()
{
string $cmd;
if (`whatIs performFileDropAction`=="Unknown")
	error "\"performFileDropAction\" function not avaiable in this version of Maya. A newer version of Maya is reuired for this to work.";

$cmd+="global proc int performFileDropAction (string $theFile)\n";
$cmd+="{\n";
$cmd+="if (`gmatch $theFile \"*.mp3\"`)\n";
$cmd+="	{\n";
$cmd+="	asAutoLipSyncConvertMp3 $theFile;\n";
$cmd+="	return 0;\n";
$cmd+="	}\n";

$cmd+="return( performFileImportAction( $theFile ) );\n";
$cmd+="}\n";
evalEcho ($cmd);
print ("// mp3 files will not automatically get converted to wav, when dropped into Maya.\n");
}

global proc asAutoLipSyncConvertMp3 (string $theFile)
{
string $aligner=`text -q -l asAutoLipSyncAlignerText`;
string $ffmpeg=`substitute "mfa_align.exe" $aligner "ffmpeg.e"`;
if (`about -mac`)
	$ffmpeg=`substitute "mfa_align" $aligner "ffmpeg"`;
string $convertedFile=`substitute ".mp3" $theFile ".wav"`;
string $ffMpegCmd="start\/wait/I \"Converting Audio\" "+$ffmpeg+" -y -i \""+$theFile+"\" \""+$convertedFile+"\"";
print ("// Starting Converting Audio:"+$ffMpegCmd+"\n");
system ($ffMpegCmd);
if (!`file -q -ex $convertedFile`)
	error ("Failed to create:\""+$convertedFile+"\"");
file -import -type "audio" -ignoreVersion -mergeNamespacesOnClash false -options "o=0" $convertedFile;
}

global proc asDynBake (string $uiName)
{
float $pos[],$rot[];
string $tempString[],$dynJoints[],$fkCtrls[];

if (`confirmDialog -title "Confirm" -message "Bake all dynamics ?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`!="Yes")
	return;

if (!`objExists Dynamics`)
	error "Dynamics not found";
$dynJoints=`listRelatives -type joint -ad Dynamics`;
	string $softDynCurves[]=`ls -type nurbsCurve "DynCurveSoft*"`;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 0 -sparseAnimCurveBake false -controlPoints true -shape false $softDynCurves;

for ($y=0;$y<size($dynJoints);$y++)
	{
	$tempString=`listConnections ($dynJoints[$y]+".r")`;
	if (`objectType $tempString[0]`=="pairBlend")
		$tempString=`listConnections ($tempString[0]+".outRotate.outRotateX")`;
	$fkCtrl="FK"+$tempString[0];
	if (!`objExists $fkCtrl`)
		continue;
	parentConstraint $dynJoints[$y] $fkCtrl;
	$fkCtrls[size($fkCtrls)]=$fkCtrl;
	}

bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl 0 -preserveOutsideKeys 1 -sparseAnimCurveBake false -controlPoints false -shape false $fkCtrls;
delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 0 $fkCtrls;
delete Dynamics;
select -cl;
print ("// Dynamics bake complete.\n");
}

global proc asJointsVisibilityToggle (string $uiName)
{
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	return;
string $joints[]=`listRelatives -type joint -ad ($nameSpace+"Main")`;
int $onOff=1;
string $tempString[]=`listRelatives -type joint -c ($nameSpace+"DeformationSystem")`;
if (`objExists $tempString[0]`)
	if (`getAttr ($tempString[0]+".drawStyle")`==0)
		$onOff=0;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;
}

global proc asControlsVisibilityToggle ()
{
int $vis;
string $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;
for ($i=0;$i<size($motionSystems);$i++)
    {
    if ($i==0)
        $vis=!(`getAttr ($motionSystems[$i]+".v")`);
    setAttr ($motionSystems[$i]+".v") $vis;
    }
}

global proc asSetupControlVisibilityHotKeyDialog ()
{
if (`confirmDialog -title "Confirm Control Visibility HotKey"
	-message ("Add toggle of control-visibility to the \"~\" hotkey.\n"
	+"For easy toggling visibility of controls.\n"
	+"Holding down the \"~\" key (next to the \"number 1\" on the keyboard) to see and select controls.\n"
	+"As you let go, controls will again be hidden.\n"
	+"The idea is to work without the `visual clutter` of the controls.\n"
	+"Tip: Ctrl+\"\~\" will leave the controls visible")
	-button "Confirm" -button "Cancel" -defaultButton "Confirm"
	-cancelButton "Cancel" -dismissString "Cancel"`!="Confirm")
	return;
asSetupControlVisibilityHotKey;
}

global proc asSetupControlVisibilityHotKey ()
{
if (!`runTimeCommand -q -ex advancedSkeletonVisibilitySwitch`)
	{
	nameCommand -ann "advancedSkeletonVisibilitySwitch" -c "advancedSkeletonVisibilitySwitch" advancedSkeletonVisibilitySwitchNameCommand;
	runTimeCommand -annotation "switches the visibility of controls" -category "User"
		-command ("int $vis;\nstring $motionSystems[]=`ls -r 1 MotionSystem FaceMotionSystem`;\nfor ($i=0;$i<size($motionSystems);$i++)\n    {\n    if ($i==0)\n        $vis=!(`getAttr ($motionSystems[$i]+\".v\")`);\n    setAttr ($motionSystems[$i]+\".v\") $vis;\n    }")
		advancedSkeletonVisibilitySwitch;
	}
hotkey -keyShortcut "`"  -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "\`" -name "advancedSkeletonVisibilitySwitchNameCommand" -releaseName "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "`"  -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
hotkey -keyShortcut "\`" -ctrlModifier -name "advancedSkeletonVisibilitySwitchNameCommand";
}

global proc asVisualizeGimbalLock (string $uiName)
{
string $sel[]=`ls -sl`;
string $nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";
int $fromSelection;
int $buildGimbal[];
float $scale;
float $bb[];
string $name,$lookForVisConnectionOnObject;
string $tempString[];
string $controlSets[]=`asGetControlSetsFromUI $uiName`;
string $controls[]=`sets -q $controlSets`;

if (`objExists GimbalLockVisualizers`)
	{
	delete GimbalLockVisualizers;
	return;
	}
createNode -n GimbalLockVisualizers transform;
if ($sel[0]!="")
	if (`stringArrayCount $sel[0] $controls`)
		$fromSelection=1;
for ($i=0;$i<size($controls);$i++)
	{
	if ($controls[$i]==$nameSpace+"Main")
		continue;
	$tempString=`listRelatives -s $controls[$i]`;
	if ($tempString[0]!="")
		if (`objectType $tempString[0]`=="nurbsCurve")
			{
			if ($fromSelection)
				if (`stringArrayCount $controls[$i] $sel`)
					$buildGimbal[$i]=1;
			if (!$fromSelection)
				$buildGimbal[$i]=1;
			}
	}
for ($i=0;$i<size($controls);$i++)
	{
	if (!$buildGimbal[$i])
		continue;
	$name=$controls[$i];
	createNode -n ($name+"Constraint") -p GimbalLockVisualizers transform;
	createNode -n ($name+"Offset") -p ($name+"Constraint") transform;

	polyCylinder -n ($name+"Cones") -r 0.3 -h 2.5 -sx 10 -sy 2 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	scale -r -p 0 0 0 0 0 0 ($name+"Cones.vtx[10:19]");
	parent ($name+"Cones") ($name+"Offset");
	if (`objExists asGreenSG`)
		sets -e -forceElement asGreenSG ($name+"Cones");

	polyTorus -n ($name+"Torus") -r 1 -sr 0.03 -tw 0 -sx 30 -sy 6 -ax 0 1 0 -cuv 1 -ch 0;
	parent ($name+"Torus") ($name+"Offset");
	if (`objExists asRedSG`)
		sets -e -forceElement asRedSG ($name+"Torus");

	polyCylinder -n ($name+"Arrow") -r 0.06 -h 2 -sx 10 -sy 3 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 0;
	rotate -r 0 0 90 ($name+"Arrow.vtx[0:41]");
	move -r 1 0 0 ($name+"Arrow.vtx[0:41]");
	scale -r -p 0 0 0 1 0 0 ($name+"Arrow.vtx[0:9]") ($name+"Arrow.vtx[40]");
	move -r 0.35 0 0 ($name+"Arrow.vtx[10:19]");
	scale -r -p 0 0 0 1 1.75 1.75 ($name+"Arrow.vtx[10:19]");
	move -r 1 0 0 ($name+"Arrow.vtx[20:29]");
	parent ($name+"Arrow") ($name+"Offset");
	if (`objExists asGreen2SG`)
		sets -e -forceElement asGreen2SG ($name+"Arrow");
	orientConstraint $name ($name+"Arrow");

	$tempString=`listRelatives -p $name`;
	parentConstraint $tempString[0] ($name+"Constraint");
	$tempString=`listRelatives -s $name`;
	$bb=`xform -q -bb ($tempString[0]+".cv[0:999]")`;
	$scale=(($bb[3]-$bb[0])+($bb[4]-$bb[1])+($bb[5]-$bb[2]))/5.0;
	setAttr -type float3 ($name+"Offset.s") $scale $scale $scale;
	$lookForVisConnectionOnObject=$name;
	$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
	for ($y=0;$y<20;$y++)
		{
		if ($tempString[0]!="")
			{
			connectAttr $tempString[0] ($name+"Offset.v");
			break;
			}
		$tempString=`listRelatives -p $lookForVisConnectionOnObject`;
		if ($tempString[0]=="")
			break;
		$lookForVisConnectionOnObject=$tempString[0];
		$tempString=`listConnections -p 1 ($lookForVisConnectionOnObject+".v")`;
		}
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 4 -cd ($name+".rotateOrder") ($name+"Cones.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Cones.rz");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rx");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rx");

	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 0 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 1 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 2 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 90 -dv 3 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 4 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv 5 -cd ($name+".rotateOrder") ($name+"Torus.rz");
	}
select $sel;
}

global proc int asHaveAnimation (string $node)
{
int $haveAnimation=0;
string $nodeType;
string $tempString[]=`listConnections -s 1 -d 0 $node`;

for ($i=0;$i<size($tempString);$i++)
	{
	$nodeType=`objectType $tempString[$i]`;
	if (`gmatch $nodeType "animCurve*"`)
		{
		$haveAnimation=1;
		break;
		}
	}
return $haveAnimation;
}

global proc asNameMatcherUI ()
{
asMappingUI NameMatcher "";
}

global proc asMoCapMatcherUI (string $uiName)
{
asMappingUI moCapMatcher $uiName;
}


global proc asMappingUI (string $tool, string $uiName)
{
int $cw=150;
int $sep=10;
string $name,$nameSpace;
string $tempString[];
if ($uiName!="")
	if (`optionMenu -q -ex ($uiName+"OptionMenu")`)
		$nameSpace=`optionMenu -q -v ($uiName+"OptionMenu")`;
if ($nameSpace==":")
	$nameSpace="";

if (`window -q -ex asMappingUI`)
    deleteUI asMappingUI;
window -t $tool asMappingUI;
formLayout asMappingUIFormLayout;
scrollLayout asMappingUIScrollLayout;
columnLayout asMappingUIColumnLayout1;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Templates" asMappingUITemplatesFrameLayout;
	columnLayout;
		rowLayout -nc 4 -cw4 10 25 200 100;
			separator -st none;
			text -l "files:";
			optionMenu -cc ("asMappingUIFileOptionMenuChanged "+$tool) asMappingUIFiles;
//			button -w 80 -l "New" -c asMappingUIClearAll;
			setParent..;
		rowLayout -nc 2 -cw2 40 200;
			separator -st none;
			text -en 0 -l "" -fn smallBoldLabelFont asMappingUIWWW;
			setParent..;
		separator -h 15 -st none;
		rowLayout -nc 3 -cw3 86 150 200;
			separator -st none;
			text -al right -l "save current configutation:";
			button -h 15 -w 80 -l "Export" -c ("asMappingUIExport "+$tool);
			setParent..;		

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Side" asMappingUISideFrameLayout;
	columnLayout;
		textFieldGrp -cw2 45 60 -l "Right:" -ed 1 -tx "Right" -cc asMappingUISideOptionChanged asMappingUISideRightTextFieldGrp;
		textFieldGrp -cw2 45 60 -l "Left:" -ed 1 -tx "Left" asMappingUISideLeftTextFieldGrp;
		textFieldGrp -cw2 45 60 -l "Middle:" -ed 1 -tx "" asMappingUISideMiddleTextFieldGrp;
		separator -st none -h 5;
		rowLayout -nc 2 -cw2 10 50;
			separator -st none;
			checkBox -l "%Side% before name" -v 1 -cc asMappingUISideOptionChanged asMappingUISideBeforeNameCheckBox;
			setParent..;
		rowLayout -nc 2 -cw2 10 50;
			separator -st none;
			checkBox -l "Use _ (underscore)" -cc asMappingUISideOptionChanged asMappingUISideUnderScoreCheckBox;
			setParent..;
		separator -h 10 -st none;
		rowLayout -nc 3 -cw3 10 100 100;
			separator -st none;
			text -l "Result example:";
			text -fn boldLabelFont -l "RightArm" asMappingUISideResultExampleText;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Joints" asMappingUIJointsFrameLayout;
	formLayout asMappingUIJointsFormLayout;
		columnLayout -adj 1 asMappingUIJointsColumnLayout1;
			rowLayout -nc 3 -cw3 $cw $sep $cw;
				text -l "   AdvancedSkeleton:";
				text -l "|";
				text -l "   Other:";
				setParent..;
			separator -w ($cw*2);
			columnLayout asMappingUIJointsColumnLayout;
				setParent..;
			setParent..;

		columnLayout asMappingUIJointsColumnLayout2;
			separator -w 320 -h 10;
			separator -w 320 -h 5 -st none;
			rowLayout -nc 3 -cw3 10 80 80;
				separator -st none;
				button -l "Add joint" -c asMappingUIAddJoint;
				button -l "Clear all" -c asMappingUIClearAll;
				setParent..;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "NameSpaces" asMappingUINameSpacesFrameLayout;
	formLayout asMappingUINameSpacesFormLayout;
		columnLayout -adj 1 asMappingUINameSpacesColumnLayout1;
			rowLayout -nc 3 -cw3 $cw $sep $cw;
				text -l "   AdvancedSkeleton:";
				text -l "|";
				text -l "   Other:";
				setParent..;
			separator -w ($cw*2);
			columnLayout asMappingUINameSpacesColumnLayout;
				rowLayout -nc 3 -cw3 $cw $sep $cw;
					textField -w ($cw-$sep-10) asMappingUINameSpacesTextFieldA1;
					if ($nameSpace!="")
						textField -e -tx $nameSpace asMappingUINameSpacesTextFieldA1;
					text -l "|";
					textField -w ($cw-$sep-10) asMappingUINameSpacesTextFieldB1;
				setParent..;
				rowLayout -nc 3 -cw3 $cw $sep $cw;
					separator -st none;
					separator -st none;
					button -h 15 -l "detect from selected" -c asMoCapMatcherNameSpaceDetect;

formLayout -e
	-ac asMappingUIJointsColumnLayout2 "top" 0 asMappingUIJointsColumnLayout1
	asMappingUIJointsFormLayout;

frameLayout -p asMappingUIColumnLayout1 -w 320 -cll 1 -cl 1 -cc asFL -ec asFL -l "Functions" asMappingUIFunctionsFrameLayout;
	columnLayout;
		if ($tool=="NameMatcher")
			{
			separator -st none -h 10;
			rowLayout -adj 2 -nc 2 -cw2 80 150;
				separator -st none;
				button -w 150 -l "Create + Place FitSkeleton" -c asNameMatcherAutoRigFit;
				setParent..;

			separator -st none -h 10;
			rowLayout -adj 2 -nc 2 -cw2 80 150;
				separator -st none;
				button -w 150 -l "Build AdvancedSkeleton" -c asReBuildAdvancedSkeleton;
				setParent..;

			separator -st none -h 10;
			rowLayout -adj 2 -nc 2 -cw2 80 150;
				separator -st none;
				button -w 150 -l "Constraint to Joints" -c "asMappingUIFunction AutoRigConstraint";
				setParent..;

			if (size(`ls -type blendShape`))
				{
				separator -st none -h 10;
				rowLayout -adj 2 -nc 2 -cw2 80 150;
					separator -st none;
					button -w 150 -l "Create BlendShapes Control" -c "asMappingUIFunction CreateBSControl";
					setParent..;
				}
			}
		if ($tool=="moCapMatcher")
			{
			separator -st none -h 10;
			rowLayout -adj 2 -nc 2 -cw2 80 150;
				separator -st none;
				columnLayout;
					text -l "1: Import MoCap-skeleton.";
					separator -st none -h 10;
					text -l "2: Select MoCap-skeleton";
					button -w 150 -l "Scan MoCap-skeleton" -c asMoCapMatcherScan;
					separator -st none -h 10;
					text -al "left" -l "3: Scale the MoCap-skeleton,\n    to match your character.";
					separator -st none -h 10;
					text -al "left" -l "4: Go to start of animation,\n    and `zero-out` MoCap-joints.";
					button -w 150 -l "`zero-out` MoCap-joints" -c "asMappingUIFunction MoCapZeroOut";
					text -al "left" -l "And align skeletons (if needed)";
					separator -st none -h 20;
					button -w 150 -l "Set rig to all FK" -c ("asSetAllFK \""+$nameSpace+"\"");
					rowLayout -nc 2 -cw2 160 10;
						button -w 150 -l "Connect MoCap Skeleton" -c "asMappingUIFunction MoCapConnect";
						checkBox -l "FKExtra" asMappingUIFKExtraCheckBox;
						setParent..;
					button -w 150 -l "Disconnect MoCap Skeleton" -c asMoCapMatcherDisconnect;
					button -w 150 -l "Bake" -c asMoCapMatcherBake;
			}

formLayout -e
	-af asMappingUIScrollLayout "top" 0
	-af asMappingUIScrollLayout "bottom" 0
	-af asMappingUIScrollLayout "left" 0
	-af asMappingUIScrollLayout "right" 0
asMappingUIFormLayout;

showWindow;

//populate $tool`s optionMenu
string $asScriptLocation=`asGetScriptLocationFromSelector`;
string $toolDir=$asScriptLocation+"/AdvancedSkeleton5Files/"+$tool+"s/";
string $toolFiles[]=`getFileList -fld $toolDir`;
setParent -menu asMappingUIFiles;
for ($i=0;$i<size($toolFiles);$i++)
	{
	if (`gmatch $toolFiles[$i] "[.]*"` || $toolFiles[$i]=="incrementalSave")
		continue;
	tokenize $toolFiles[$i] "." $tempString;
	$name=$tempString[0];
	menuItem -l $name;
	}
//defaults to "MotionBuilder"
if (`stringArrayCount "MotionBuilder.txt" $toolFiles`)
	optionMenu -e -v MotionBuilder asMappingUIFiles;
menuItem -l "*New";

//update UI from optionVars
string $framLayouts[]=`lsUI -type frameLayout`;
for ($i=0;$i<size($framLayouts);$i++)
	if (`gmatch $framLayouts[$i] "asMappingUI*FrameLayout"`)
		if (`optionVar -ex $framLayouts[$i]`)
			frameLayout -e -cl `optionVar -q $framLayouts[$i]` $framLayouts[$i];

//auto-guess source App from scene nodes
if (size(`ls |master`)) catchQuiet(`optionMenu -e -v AutodeskCharacterGenerator asMappingUIFiles`);
if (size(`ls "*BoneRoot"`)) catchQuiet(`optionMenu -e -v CharacterCreator asMappingUIFiles`);
if (size(`ls ik_foot_root`)) catchQuiet(`optionMenu -e -v Unreal asMappingUIFiles`);
if (size(`ls Abdomen`)) catchQuiet(`optionMenu -e -v Poser asMappingUIFiles`);
if (size(`ls abdomenLower`)) catchQuiet(`optionMenu -e -v Daz3d asMappingUIFiles`);
if (size(`ls RightFinger5Proximal`)) catchQuiet(`optionMenu -e -v Rokoko asMappingUIFiles`);

asMappingUIFileOptionMenuChanged $tool;
}

global proc asMappingUIFileOptionMenuChanged (string $tool)
{
string $text="";
string $file=`optionMenu -q -v asMappingUIFiles`;
if ($file=="AutodeskCharacterGenerator") $text="charactergenerator.autodesk.com";
if ($file=="CharacterCreator") $text="www.reallusion.com/character-creator";
if ($file=="Daz3d") $text="www.daz3d.com";
if ($file=="iPiSoft") $text="www.ipisoft.com";
if ($file=="Mixamo") $text="www.mixamo.com";
if ($file=="MotionBuilder") $text="www.autodesk.com";
if ($file=="Poser") $text="smithmicro.com/poser";
if ($file=="Unreal") $text="www.unrealengine.com";
if ($file=="Rokoko") $text="www.rokoko.com";

text -e -l $text asMappingUIWWW;

asMappingUIClearAll;
if ($file!="*New")
	asMappingUILoad $tool;
}

global proc asMappingUISideOptionChanged ()
{
string $joint="Arm";
string $side=`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`;
string $underS="";
if (`checkBox -q -v asMappingUISideUnderScoreCheckBox`)
	$underS="_";
string $text=$text=$joint+$underS+$side;
if (`checkBox -q -v asMappingUISideBeforeNameCheckBox`)
	$text=$side+$underS+$joint;
text -e -l $text asMappingUISideResultExampleText;
}

global proc asMappingUIAddJoint ()
{
int $cw=150;
int $sep=10;
string $rowLayouts[]=`columnLayout -q -ca asMappingUIJointsColumnLayout`;
int $nr=size($rowLayouts)+1;

setParent asMappingUIJointsColumnLayout;
rowLayout -nc 3 -cw3 $cw $sep $cw ("asMappingUIJointsRowLayout"+$nr);
	textField -w ($cw-$sep-10) ("asMappingUIJointsTextFieldA"+$nr);
	text -l "|";
	textField -w ($cw-$sep-10) ("asMappingUIJointsTextFieldB"+$nr);
}

global proc asMappingUIClearAll ()
{
string $rowLayouts[]=`columnLayout -q -ca asMappingUIJointsColumnLayout`;
for ($i=0;$i<size($rowLayouts);$i++)
	deleteUI $rowLayouts[$i];

textFieldGrp -e -tx "Right" asMappingUISideRightTextFieldGrp;
textFieldGrp -e -tx "Left"  asMappingUISideLeftTextFieldGrp;
textFieldGrp -e -tx "" 			asMappingUISideMiddleTextFieldGrp;
checkBox -e -v 1 asMappingUISideBeforeNameCheckBox;
checkBox -e -v 0 asMappingUISideUnderScoreCheckBox;
}

global proc asMappingUILoad (string $tool)
{
int $section=1;
int $nr=1;
string $line,$para,$value;
string $asScriptLocation=`asGetScriptLocationFromSelector`;
string $file=$asScriptLocation+"/AdvancedSkeleton5Files/"+$tool+"s/"+`optionMenu -q -v asMappingUIFiles`+".txt";
string $tempString[];

if (!`file -q -ex $file`)
	error ("Unable to find the file:\""+$file+"\".\n");

print ("// Loading:\""+$file+"\".\n");
asMappingUIClearAll;
int $fileId=`fopen $file "r"`;
string $nextLine = `fgetline $fileId`;
while (size($nextLine)>0)
	{
	$line=`strip $nextLine`;
	tokenize $line "=" $tempString;
	$para=$tempString[0];
	$value=$tempString[1];

	if ($para=="sideRight")
		textFieldGrp -e -tx $value asMappingUISideRightTextFieldGrp;
	if ($para=="sideLeft")
		textFieldGrp -e -tx $value asMappingUISideLeftTextFieldGrp;
	if ($para=="sideMiddle")
		textFieldGrp -e -tx $value asMappingUISideMiddleTextFieldGrp;
	if ($para=="sideBeforeName")
		eval ("checkBox -e -v "+$value+" asMappingUISideBeforeNameCheckBox");
	if ($para=="sideUnderScore")
		eval ("checkBox -e -v "+$value+" asMappingUISideUnderScoreCheckBox");


	if ($section==2)
		{
		if ($para=="")
			{
			$nextLine=`fgetline $fileId`;
			continue;
			}

		asMappingUIAddJoint;
		textField -e -tx $para ("asMappingUIJointsTextFieldA"+$nr);
		textField -e -tx $value ("asMappingUIJointsTextFieldB"+$nr);
		$nr++;
		}

	if ($para=="" && $value=="")
		$section++;
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;
asMappingUISideOptionChanged;
}

global proc asMappingUIExport (string $tool)
{
string $fDet,$a,$b;
string $asScriptLocation=`asGetScriptLocationFromSelector`;
string $tempString[],$existingMenuItems[],$existingFiles[];

string $return[] = `fileDialog2 -fileFilter "*.txt" -dialogStyle 2 -dir ($asScriptLocation+"/AdvancedSkeleton5Files/"+$tool+"s/")`;
string $file=$return[0];
if ($file=="")
	return;

$fDet+="sideRight="+`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`+"\n";
$fDet+="sideLeft="+`textFieldGrp -q -tx asMappingUISideLeftTextFieldGrp`+"\n";
$fDet+="sideMiddle="+`textFieldGrp -q -tx asMappingUISideMiddleTextFieldGrp`+"\n";
$fDet+="sideBeforeName="+`checkBox -q -v asMappingUISideBeforeNameCheckBox`+"\n";
$fDet+="sideUnderScore="+`checkBox -q -v asMappingUISideUnderScoreCheckBox`+"\n";
$fDet+="\n";
for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$a=`textField -q -tx ("asMappingUIJointsTextFieldA"+$nr)`;
	$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
	$fDet+=$a+"="+$b+"\n";
	}

int $fileId=`fopen $file "w"`;
fprint $fileId $fDet;
fclose $fileId;

tokenize $return[0] "/" $tempString;
tokenize $tempString[size($tempString)-1] "." $tempString;

$existingMenuItems=`optionMenu -q -ill asMappingUIFiles`;
for ($i=0;$i<size($existingMenuItems);$i++)
	$existingFiles[$i]=`menuItem -q -l $existingMenuItems[$i]`;
if (!`stringArrayCount $tempString[0] $existingFiles`)
	{
	setParent -menu asMappingUIFiles;
	menuItem -l $tempString[0];
	optionMenu -e -v $tempString[0] asMappingUIFiles;
	}
}

global proc asNameMatcherAutoRigFit ()
{
int $isMiddleJoint,$numChilJoInts,$maxNumChildJoints;
int $sideBeforeName=`checkBox -q -v asMappingUISideBeforeNameCheckBox`;
int $sideUnderScore=`checkBox -q -v asMappingUISideUnderScoreCheckBox`;
float $scale;
float $pos[],$bb[];
string $a,$b,$aLong,$bResolved,$otherTopNode,$underS,$bs,$suffix,$part,$longHipToKeep,$baseName;
string $sideRight=`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`;
string $sideLeft=`textFieldGrp -q -tx asMappingUISideLeftTextFieldGrp`;
string $sideMiddle=`textFieldGrp -q -tx asMappingUISideMiddleTextFieldGrp`;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$tempString5[],$fitJoints[],$allReservedNames[];
string $reservedNames[]={"Root","Spine1","Spine2","Chest","Scapula","Shoulder","Elbow","Wrist","Cup",
	"ThumbFinger1","ThumbFinger2","ThumbFinger3","ThumbFinger4",
	"IndexFinger1","IndexFinger2","IndexFinger3","IndexFinger4",
	"MiddleFinger1","MiddleFinger2","MiddleFinger3","MiddleFinger4",
	"RingFinger1","RingFinger2","RingFinger3","RingFinger4",
	"PinkyFinger1","PinkyFinger2","PinkyFinger3","PinkyFinger4",
	"Neck","Head","HeadEnd","Eye","EyeEnd","Jaw","JawEnd",
	"Hip","Knee","Ankle","Toes","ToesEnd"};

for ($i=0;$i<size($reservedNames);$i++)
	for ($p=0;$p<3;$p++)
		{
		if ($p==0) $part="";
		if ($p==1) $part="Part1";
		if ($p==2) $part="Part2";
		$allReservedNames[size($allReservedNames)]=$reservedNames[$i]+$part;
		}

//Remove any animation that might be on joints (iclone seem to have test-animation by default)
$tempString=`ls -type joint`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -type animCurve -s 1 -d 0 $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		delete $tempString2[$y];
	}

//resolve Daz non-unique names
$longHipToKeep="hip";
$tempString=`ls hip`;
if (size($tempString)>1)
	{
	warning "Found multiple objects called \"hip\", this is probably a export from DAZ, now attemting to merge all the DAZ skeletons..";
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listRelatives -ad -c $tempString[$i]`;
		$numChilJoints=size($tempString2);
		if ($numChilJoints>$maxNumChildJoints)
			{
			$longHipToKeep=$tempString[$i];
			$maxNumChildJoints=$numChilJoints;
			}
		}
	}
//rename to unique names
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]==$longHipToKeep)
		continue;
	$tempString2=`listRelatives -p $tempString[$i]`;
	$baseName=$tempString2[0];
	$tempString2=`listRelatives -ad -c -f $baseName`;
	$tempString3=`listRelatives -ad -c $baseName`;
	$tempString4=`listRelatives -ad -c -f $longHipToKeep`;
	$tempString5=`listRelatives -ad -c $longHipToKeep`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		rename $tempString2[$y] ($baseName+"_"+$tempString3[$y]);
		for ($z=0;$z<size($tempString5);$z++)//constraint to `keepJoint`
			if ($tempString5[$z]==$tempString3[$y])
				{
				parentConstraint $tempString4[$z] ($baseName+"_"+$tempString3[$y]);
				scaleConstraint $tempString4[$z] ($baseName+"_"+$tempString3[$y]);
				}
		}
	}

//turning Off "segmentScaleCompensate" for all joints, for better scale behaviour
$tempString=`ls -type joint`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".segmentScaleCompensate") 0;


//Unique naming requirements workaround, rename the "Other"
for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;

	for ($z=0;$z<4;$z++)
		{
		if ($z==0) $suffix="_R";
		if ($z==1) $suffix="_L";
		if ($z==2) $suffix="_M";
		if ($z==3) $suffix="";

		$bs=$b+$suffix;

		if (`objExists $bs`)
			for ($i=0;$i<size($allReservedNames);$i++)
				if ($bs==$allReservedNames[$i]+$suffix)
					{
					print ("Renaming \""+$bs+"\" to \""+$b+"TMP"+$suffix+"\", to avoid name clashing.\n");
					rename $bs ($b+"TMP"+$suffix);
					textField -e -tx ($b+"TMP") ("asMappingUIJointsTextFieldB"+$nr);
					}

		}
	}

//find $otherTopNode
for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
	$tempString=`ls $b`;
	if (size($tempString)!=1)
		continue;
	$tempString=`ls -l $b`;
	tokenize $tempString[0] "|" $tempString;
	$otherTopNode="|"+$tempString[0];
	break;
	}

//find $otherTopNode. part2, migh require sidePrefix (checking for middle only)
if ($otherTopNode=="")
	for ($nr=1;$nr<999;$nr++)
		{
		if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
			break;
		$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
		$underS="";
		if ($sideUnderScore)
			$underS="_";
		if ($sideBeforeName)
			$bResolved=$sideMiddle+$underS+$b;
		else
			$bResolved=$b+$underS+$sideMiddle;
		$tempString=`ls $bResolved`;
		if (size($tempString)!=1)
			continue;
		$tempString=`ls -l $bResolved`;
		tokenize $tempString[0] "|" $tempString;
		$otherTopNode="|"+$tempString[0];
		break;
		}

if ($otherTopNode=="")
	error ("Unable to find Top-Node of the \"Other\" Skeleton,\n"
		+"Possible reasones:\n"
		+"-No joints in the list in the \"joints\" section.\n"
		+"-None of the joints in the list have unique names, meaning they have same name as other objects in the scene.\n");

if (!`optionMenu -q -ex asFitFiles`)
	AdvancedSkeleton5;
optionMenu -e -v "biped.ma" asFitFiles;
asFitSkeletonImport;

$bb=`xform -q -bb $otherTopNode`;
$scale=$bb[4]/17.0;
setAttr FitSkeleton.s -type float3 $scale $scale $scale;

for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$a=`textField -q -tx ("asMappingUIJointsTextFieldA"+$nr)`;
	$b=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;

	if (!`objExists $a`)
		{
		warning ("AdvancedSkeleton FitJoint \""+$a+"\" not found");
		continue;
		}

	//find $aLong
	$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
	$tempString=`listRelatives -fullPath -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($fitJoints);$i++)
		if ($fitJoints[$i]==$a)
			$aLong=$tempString[$i];

	$isMiddleJoint=1;
	$pos=`xform -q -ws -t $aLong`;
	if ($pos[0]>0.001 || $pos[0]<-0.001)
		$isMiddleJoint=0;

	//find $bResolved
	$underS="";
	if ($sideUnderScore)
		$underS="_";
	if ($isMiddleJoint && $sideMiddle=="")//special case, no middleSuffix, so no underscore
		$underS="";

	if ($sideBeforeName)
		{
		if ($isMiddleJoint) $bResolved=$sideMiddle+$underS+$b;
		else 								$bResolved=$sideRight+$underS+$b;
		}
	else
		{
		if ($isMiddleJoint) $bResolved=$b+$underS+$sideMiddle;
		else 								$bResolved=$b+$underS+$sideRight;
		}

	if (!`objExists $bResolved`)
		{
		warning ("Other Joint \""+$bResolved+"\" not found");
		continue;
		}

	$pos=`xform -q -ws -t $bResolved`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $aLong;
	}

asFitModeManualUpdate;
select FitSkeleton;
}

global proc asMappingUIFunction (string $function)
{
int $sideBeforeName=`checkBox -q -v asMappingUISideBeforeNameCheckBox`;
int $sideUnderScore=`checkBox -q -v asMappingUISideUnderScoreCheckBox`;
int $numChar,$numChar2,$numConnectedJoints;
float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $fk="FK";
if (`checkBox -q -ex asMappingUIFKExtraCheckBox`)
	if (`checkBox -q -v asMappingUIFKExtraCheckBox`)
		$fk="FKExtra";
string $target,$source,$dest;
string $underS="";
string $sideRight=`textFieldGrp -q -tx asMappingUISideRightTextFieldGrp`;
string $sideLeft=`textFieldGrp -q -tx asMappingUISideLeftTextFieldGrp`;
string $sideMiddle=`textFieldGrp -q -tx asMappingUISideMiddleTextFieldGrp`;
string $nameSpaceA=`textField -q -tx asMappingUINameSpacesTextFieldA1`;
string $nameSpaceB=`textField -q -tx asMappingUINameSpacesTextFieldB1`;
string $tempString[],$as[],$bs[];
string $deformJoints[]=`listRelatives -type joint -ad ($nameSpaceA+"DeformationSystem")`;

if ($function=="MoCapConnect" && `objExists MoCapConstraints`)
	error "MoCapConstraints object already exists, which means MoCap skeleton is already connected";

for ($nr=1;$nr<999;$nr++)
	{
	if (!`rowLayout -q -ex ("asMappingUIJointsRowLayout"+$nr)`)
		break;
	$as[$nr-1]=`textField -q -tx ("asMappingUIJointsTextFieldA"+$nr)`;
	$bs[$nr-1]=`textField -q -tx ("asMappingUIJointsTextFieldB"+$nr)`;
	}

for ($i=0;$i<size($deformJoints);$i++)
	{
	$target="";
	if ($sideUnderScore) $underS="_";
	$numChar=size($deformJoints[$i]);
	for ($y=0;$y<size($as);$y++)
		if (`substring $deformJoints[$i] 1 ($numChar-2)`==$nameSpaceA+$as[$y])
			{
			if (`gmatch $deformJoints[$i] "*_R"`)
				{
				if ($sideBeforeName)
					$target=$sideRight+$underS+$bs[$y];
				else
					$target=$bs[$y]+$underS+$sideRight;
				}
			if (`gmatch $deformJoints[$i] "*_L"`)
				{
				if ($sideBeforeName)
					$target=$sideLeft+$underS+$bs[$y];
				else
					$target=$bs[$y]+$underS+$sideLeft;
				}
			if (`gmatch $deformJoints[$i] "*_M"`)
				{
				if ($sideMiddle=="")//special case, no middleSuffix, so no underscore
					$underS="";
				if ($sideBeforeName)
					$target=$sideMiddle+$underS+$bs[$y];
				else
					$target=$bs[$y]+$underS+$sideMiddle;
				}
			if ($nameSpaceB!="")
				$target=$nameSpaceB+":"+$target;
			}
	if ($target=="")
		continue;

	//AutoRigConstraint
	if ($function=="AutoRigConstraint")
		{
		//some packages makes locked or limited atrributes, so open up these first
		transformLimits -erx 0 0 -ery 0 0 -erz 0 0 -etx 0 0 -ety 0 0 -etz 0 0 -esx 0 0 -esy 0 0 -esz 0 0 $target;
		asLockAttr $target 0 0 0 0;

		print ($deformJoints[$i]+" -> "+$target+"\n");
		select $target;
		if (`objExists ($target+"_parentConstraint1")`) delete ($target+"_parentConstraint1");
		if (`objExists ($target+"_scaleConstraint1")`) delete ($target+"_scaleConstraint1");
		parentConstraint -mo $deformJoints[$i] $target;
		scaleConstraint $deformJoints[$i] $target;
		}

	//MoCapConnect
	if ($function=="MoCapConnect")
		{
		if ($nameSpaceA!="")
			$dest=`substitute $nameSpaceA $deformJoints[$i] ($nameSpaceA+$fk)`;
		else
			$dest=$fk+$deformJoints[$i];
		if (`gmatch $dest "*Root_M"`)
			{//Use RootX instead of Root, as Root may have `inbetween` joint
			$dest=`substitute "FKRoot_M" $dest "RootX_M"`;
			if ($fk=="FKExtra")
				$dest=`substitute "FKExtraRoot_M" $dest "RootExtraX_M"`;
			}
		if (!`objExists $dest`)
			continue;
		if (!`objExists $target`)
			{
			if (!`objExists MoCapConstraints`)
				error ("Unable to find \""+$target+"\", Maybe the NameSpace is not defined ?\n");
			else
				{
				print ("\""+$target+"\" not found, Skipping.\n");
				continue;
				}
			}

		print ($target+" -> "+$dest+"\n");

		//if MoCap-joint-name clashes with FitSkeleton-joint-name (e.g Head, Neck)
		//we will update $target to have `fullPath`
		$tempString=`ls -l $target`;
		if (size($tempString)>1)
			{
			for ($y=0;$y<size($tempString);$y++)
				{
				if (`gmatch $tempString[$y] "*|Group|*"`)
					continue;
				$target=$tempString[$y];
				}
			print ("non-unique name update:"+$target+" -> "+$dest+"\n");
			}

		if (!`objExists MoCapConstraints`)
			{
			createNode -n MoCapConstraints transform;
			asLockAttr MoCapConstraints 1 1 1 1;
			}
		if (!`attributeExists disableConstraints MoCapConstraints`)
			addAttr -k 1 -ln "disableConstraints"  -at bool MoCapConstraints;
		if ($deformJoints[$i]==$nameSpaceA+"Root_M")
			{
			$tempString=`pointConstraint -mo $target $dest`;
//			parent $tempString[0] MoCapConstraints;
			connectAttr MoCapConstraints.disableConstraints ($tempString[0]+".nodeState");
			}
		$tempString=`orientConstraint -mo $target $dest`;
//		parent $tempString[0] MoCapConstraints;
		connectAttr MoCapConstraints.disableConstraints ($tempString[0]+".nodeState");
		$numConnectedJoints++;
		}

	//MoCapZeroOut
	if ($function=="MoCapZeroOut")
		{
		if (!`objExists $target`)
			continue;
		catchQuiet (`setAttr ($target+".r") -type float3 0 0 0`);
		$numConnectedJoints++;
		}
	}

//blendShapes
if ($function=="CreateBSControl")
	{
	$tempString=`ls -type blendShape`;
	for ($i=0;$i<size($tempString);$i++)
		{
		circle -n ($tempString[$i]+"Ctrl") -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
		parentConstraint Head_M ($tempString[$i]+"Ctrl");
		setAttr ($tempString[$i]+"Ctrl_parentConstraint1.target[0].targetOffsetTranslateX") (($height/40.0)*$i);
		setAttr ($tempString[$i]+"Ctrl_parentConstraint1.target[0].targetOffsetTranslateZ") ($height/-10.0);
		setAttr ($tempString[$i]+"CtrlShape.overrideEnabled") 1;
		setAttr ($tempString[$i]+"CtrlShape.overrideColor") 17;
		asLockAttr ($tempString[$i]+"Ctrl") 1 1 1 1;
		$tempString2=`listAttr -m ($tempString[$i]+".weight")`;
		if (size($tempString2)==0)
			delete ($tempString[$i]+"Ctrl");
		for ($y=0;$y<size($tempString2);$y++)
			{
			addAttr -k 1 -ln $tempString2[$y] -at double ($tempString[$i]+"Ctrl");
			connectAttr -f ($tempString[$i]+"Ctrl."+$tempString2[$y]) ($tempString[$i]+"."+$tempString2[$y]);
			}
		}
	}

select -cl;
if ($function=="MoCapConnect")
	print ("// "+$numConnectedJoints+" joints connected.\n");
if ($function=="MoCapZeroOut")
	print ("// "+$numConnectedJoints+" joints `zeroed out`.\n");
}

global proc asMoCapMatcherNameSpaceDetect ()
{
string $sel[]=`ls -sl`;
string $tempString[];
string $nameSpace;
for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] ":" $tempString;
	if (size($tempString)>1)
		$nameSpace=$tempString[0];
	}
print ("// nameSpace \""+$nameSpace+"\" detected, and updated in the  \"NameSpaces\" section.\n");
textField -e -tx $nameSpace asMappingUINameSpacesTextFieldB1;
}

global proc asMoCapMatcherScan ()
{
asMoCapMatcherNameSpaceDetect;
}

global proc asMoCapMatcherDisconnect ()
{
string $tempString[];

if (`objExists MoCapConstraints`)
	{
	if (`attributeExists disableConstraints MoCapConstraints`)
		$tempString=`listConnections -s 0 -d 1 MoCapConstraints.disableConstraints`;
	for ($i=0;$i<size($tempString);$i++)
		delete $tempString[$i];
	delete MoCapConstraints;
	}
print ("// MoCap Skeleton disconnected.\n");
}

global proc asMoCapMatcherBake ()
{
string $tempString[],$bakeControls[];

if (!`objExists MoCapConstraints`) error "MoCapConstraints object not found";
if (!`attributeExists disableConstraints MoCapConstraints`) error "MoCapConstraints.disableConstraints attribute not found";

string $moCapConstraints[]=`listConnections -s 0 -d 1 MoCapConstraints.disableConstraints`;
for ($i=0;$i<size($moCapConstraints);$i++)
	{
	$tempString=`listConnections ($moCapConstraints[$i]+".constraintParentInverseMatrix")`;
	$bakeControls[size($bakeControls)]=$tempString[0];
	}
select $bakeControls;
bakeResults -simulation true -t (`playbackOptions -q -min`+":"+`playbackOptions -q -max`) -sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false -removeBakedAttributeFromLayer false 
	-bakeOnOverrideLayer false -controlPoints false -shape false $bakeControls;
select $bakeControls;
evalEcho "delete -staticChannels -unitlessAnimationCurves false -hierarchy none -controlPoints 0 -shape 1";
}

global proc string asGetTempDirectory ()
{
string $tempDirectory=`internalVar -utd`;
string $folders[];

//resolve userNames that has beeen `truncated` with Tilde symbol
if (`gmatch $tempDirectory "*~*"`)
	{
	tokenize $tempDirectory "/" $folders;
	$tempDirectory="";
	for ($i=0;$i<size($folders);$i++)
		{
		if (`gmatch $folders[$i] "*~*"`)
			$folders[$i]=`getenv USERNAME`;
		$tempDirectory+=$folders[$i];
		if ($i<(size($folders)-1))
			$tempDirectory+="/";
		}
	}
return $tempDirectory;
}

global proc string asGetScriptLocationFromSelector ()
{
//simulates `asGetScriptLocation`, but can run in `standalone` mode.
string $asScriptLocation;
string $tempString[];
if (`exists asGetScriptLocation`)
	$asScriptLocation=`asGetScriptLocation`;
else//can run `standalone`
	{
	$tempString[0]=`asSelectorScriptLocation`;
	tokenize $tempString[0] "/" $tempString;
	for ($i=0;$i<size($tempString)-2;$i++)
		{
		$asScriptLocation+=$tempString[$i];
		if ($i<size($tempString)-3)
			$asScriptLocation+="/";
		}
	}
return $asScriptLocation;
}

global proc string asSelectorScriptLocation ()
{
string $whatIs=`whatIs asSelectorScriptLocation`;
string $fullPath=`substring $whatIs 25 999`;
string $buffer[];
int $numTok=`tokenize $fullPath "/" $buffer`;
if ($numTok<2)
	if (`about -win`)
		$numTok=`tokenize $fullPath "\\" $buffer`;
int $numLetters=size($fullPath);
int $numLettersLastFolder=size($buffer[$numTok-1]);
string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;
return $scriptLocation;
}
//-- ASTools Procedures Ends Here --//

//-- ASSelector Procedures Starts Here --//
global proc asSelectorDesigner ()
{
asShowSelJob;
string $controlSets[]=`asGetControlSets`;
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Selector/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");

if (`window -q -ex asSelectorDefault`)
	deleteUI asSelectorDefault;
window -w 640 -h 480 -mb 1 -t "SelectorDesigner :untitled" asSelectorDefault;

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`asGetTempDirectory`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	intField -v 640 asSelectorWidth;
	intField -v 480 asSelectorHeight;
	setParent..;

menu "File";
	menuItem -sm 1 -l ControlSets asSelectorControlSetsMenu;
		menuItem -cb 1 -l ControlSet asSelectorControlSetsMenuItemControlSet;
		menuItem -cb 0 -l FaceControlSet asSelectorControlSetsMenuItemFaceControlSet;
		setParent -menu ..;
	menuItem -c "asSave Selector" "Save";
	menuItem -c "asfileBrowse Selector SaveAs" "Save As";
	menuItem -c "astoShelf Selector" "Put on shelf";

menu "Edit";
	menuItem -sm 1 "Colors";
		menuItem -c "asSelectorBackgroundSetColor asSelectorSelColor" "set Selected Color";
		menuItem -c "asSelectorBackgroundSetColor asSelectorKeyColor" "set Keyed Color";

menu "Layout";
	menuItem -c "asSDNewLayout 0" -l "New Empty Layout";
	menuItem -c "asSDNewLayout 1" -l "New Biped Layout";
	menuItem -c "asSDNewLayout 2" -l "New Face Layout";

menu "Buttons";
	menuItem -c "asSDNewButtton Object 50 50 100 100" -l "Create New Button";

menu "Render";
	menuItem -c "asSDRender 1" -l "Render Background";
	menuItem -c "asfileBrowse Selector Import" -l "Import  Background";
	menuItem -d 1;
	menuItem -c "asSDRender 0" -l "Render Buttons";

columnLayout -adj 1;
rowLayout -nc 5 -adj 1 -cat 1 right 0 -cw 2 30 -cw 3 65 -cw 4 50 -cw 5 60;
optionMenu -cc asSelChange asSelectorDefaultOptionMenu;
button -l "set" -c "asSetNameSpaceFromSelection asSelectorDefault";
checkBox -v `optionVar -q asShowSelection` -onc "optionVar -iv asShowSelection 1;asSelChangeToggle;" -ofc "optionVar -iv asShowSelection 0;asSelChangeToggle;" -l Selection asSelectorSelectionCheckBox;
checkBox -v `optionVar -q asShowKeyed` -onc "optionVar -iv asShowKeyed 1;asSelChangeToggle;" -ofc "optionVar -iv asShowKeyed 0;asSelChangeToggle;" -l Keyed asSelectorKeyedCheckBox;
checkBox -v `optionVar -q asShowExtra` -onc "optionVar -iv asShowExtra 1;asSelChangeToggle;" -ofc "optionVar -iv asShowExtra 0;asSelChangeToggle;" -l Extra asSelectorbipedExtraCheckBox;
setParent..;

formLayout asSelectorDefaultFormLayout;
setParent..;
asPopulateNameSpaceMenu "asSelectorDefault";

columnLayout -m 0 asSelectorColumnLayout;
	text -l (`asGetTempDirectory`+"AdvancedSkeleton/Selector/") asSelectorProjectPath;
	text -l "untitled" asSelectorProjectName;
	text -l "640" asSelectorBackgroundWidth;
	text -l "480" asSelectorBackgroundHeight;

showWindow;
}

global proc asSDNewLayout (int $LayoutType)
{
if (`objExists SelectorLayout`)
	if (`confirmDialog -t "Confirm"
	-m "SelectorLayout already exists, this will replace the current Layout"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;

float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
string $tempString[];

select -cl;
string $deleteObjs[]={"SelectorLayout","Template","SelectorLayoutShader","SelectorLayoutSG","SelectorIcons"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

createNode -n SelectorLayout transform;
polyCube -n Button_Template -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
addAttr -ln label -dt "string" Button_Template;
addAttr -ln multiObjs -dt "string" Button_Template;
polyProjection -ch 0 -type Planar -ibd on -md z Button_Template.f[0];
setAttr Button_Template.sz 0.001;
parent Button_Template SelectorLayout;
setAttr SelectorLayout.tz ($height/2);
setAttr -l 1 -k 0 Button_Template.tz;
setAttr -l 1 -k 0 Button_Template.rx;
setAttr -l 1 -k 0 Button_Template.ry;
setAttr -l 1 -k 0 Button_Template.rz;
setAttr -l 1 -k 0 Button_Template.sz;
//setAttr -l 1 -k 0 Button_Template.v;

shadingNode -n SelectorLayoutShader -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name SelectorLayoutSG;
connectAttr -f SelectorLayoutShader.outColor SelectorLayoutSG.surfaceShader;
setAttr SelectorLayoutShader.transparency -type double3 0.8 0.8 0.8; 
sets -e -forceElement SelectorLayoutSG Button_Template;

setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.overrideColor 15;
setAttr Button_TemplateShape.primaryVisibility 0;
//setAttr Button_TemplateShape.overrideShading 0;
setAttr Button_TemplateShape.castsShadows 0;
setAttr Button_TemplateShape.receiveShadows 0;
setAttr Button_TemplateShape.visibleInReflections 0;
setAttr Button_TemplateShape.visibleInRefractions 0;
setAttr Button_TemplateShape.overrideEnabled 1;
setAttr Button_TemplateShape.motionBlur 0;
setAttr Button_TemplateShape.smoothShading 0;
//setAttr Button_TemplateShape.doubleSided 0;

//SelectorWindow
duplicate -n SelectorWindow Button_Template;
setAttr SelectorWindowShape.overrideShading 0;
setAttr SelectorWindow.sx 640;
setAttr SelectorWindow.sy 480;
move -r 0 240 0 SelectorWindow.vtx[0:7];
setAttr -type float3 SelectorLayout.s ($height*0.002083) ($height*0.002083) ($height*0.002083);

//WindowCorner
createNode -n WindowCorner -p SelectorWindow transform;
setAttr -type float3 WindowCorner.t -0.5 1 0;
setAttr -type float3 WindowCorner.s (1.0/640) (-1.0/480) 1;

//Prep Button_Template
move -r (`getAttr SelectorLayout.sx`/2.0) (`getAttr SelectorLayout.sy`/2.0) 0 Button_Template.vtx[0:7];
parent Button_Template WindowCorner;
setAttr Button_Template.tx -150;
setAttr Button_Template.ty 50;
setAttr Button_Template.sx 100;
setAttr Button_Template.sy 100;
setAttr Button_Template.v 0;

createNode -n LoadingSelectorLayout transform;
select -cl;
if ($LayoutType==1)
	{
	asSDNewButtton FKElbow_R 136 78 72 27;
	asSDNewButtton FKShoulder_R 210 75 64 32;
	asSDNewButtton FKWrist_R 92 68 43 43;
	asSDNewButtton RootX_M 188 228 70 24;
		setAttr -type "string" Button_RootX_M.label Root;
	asSDNewButtton FKRoot_M 270 190 100 38;
	asSDNewButtton FKSpine1_M 270 149 100 38;
	asSDNewButtton FKChest_M 270 108 100 38;
	asSDNewButtton FKHip_R 267 234 48 106;
	asSDNewButtton FKKnee_R 275 346 39 104;
	asSDNewButtton FKAnkle_R 275 451 39 26;
	asSDNewButtton FKToes_R 243 461 30 14;
	asSDNewButtton FKScapula_R 277 67 25 41;
	asSDNewButtton FKNeck_M 304 79 30 26;
	asSDNewButtton FKHead_M 291 3 56 56;

	asSDNewButtton IKArm_R 92 10 43 43;
	asSDNewButtton PoleArm_R 160 22 30 30;
	asSDNewButtton FKIKArm_R 216 21 30 30;
	asSDNewButtton IKLeg_R 205 405 43 43;
	asSDNewButtton PoleLeg_R 210 333 30 30;
	asSDNewButtton FKIKLeg_R 210 261 30 30;
	asSDNewButtton RollHeel_R 215 452 24 24;
	asSDNewButtton RollToes_R 188 452 24 24;
	asSDNewButtton RollToesEnd_R 160 452 24 24;

	asSDNewButtton HipSwinger_M 205 161 43 43;

	asSDNewButtton Main 20 10 43 20;
		setAttr -type "string" Button_Main.label Main;

	asSDNewButtton FKWrist_R 6 330 140 100;
	asSDNewButtton FKIndexFinger1_R 114 268 32 58;
	asSDNewButtton FKMiddleFinger1_R 78 268 32 58;
	asSDNewButtton FKRingFinger1_R 43 268 32 58;
	asSDNewButtton FKPinkyFinger1_R 6 268 32 58;
	asSDNewButtton FKIndexFinger2_R 114 211 32 52;
	asSDNewButtton FKMiddleFinger2_R 78 211 32 52;
	asSDNewButtton FKRingFinger2_R 43 211 32 52;
	asSDNewButtton FKPinkyFinger2_R 6 211 32 52;
	asSDNewButtton FKIndexFinger3_R 114 167 32 40;
	asSDNewButtton FKMiddleFinger3_R 78 167 32 40;
	asSDNewButtton FKRingFinger3_R 43 167 32 40;
	asSDNewButtton FKPinkyFinger3_R 6 167 32 40;
	asSDNewButtton FKThumbFinger1_R 149 330 32 66;
	asSDNewButtton FKThumbFinger2_R 149 272 32 52;
	asSDNewButtton FKThumbFinger3_R 149 225 32 41;
	asSDNewButtton Fingers_R 31 436 91 24;
		setAttr -type "string" Button_Fingers_R.label Fingers;

	asSDNewButtton FKSpine 188 129 70 24;
		setAttr -type "string" Button_FKSpine.label Spine;
		setAttr -type "string" Button_FKSpine.multiObjs "FKChest_M FKSpine1_M FKRoot_M";
	asSDNewButtton IKSpine1_M 390 204 30 30;
	asSDNewButtton IKSpine2_M 390 164 30 30;
	asSDNewButtton IKSpine3_M 390 127 30 30;
	asSDNewButtton FKIKSpine_M 425 163 30 30;
	}
if ($LayoutType==2)
	{
	asSDNewButtton squashTop_M 44 59 73 22;
	asSDNewButtton squashMiddle_M 44 85 73 22;
	asSDNewButtton squashBase_M 44 111 73 22;
	asSDNewButtton EyeBrowRegion_R 120 116 35 30;
	asSDNewButtton EyeRegion_R 117 161 41 51;
	asSDNewButtton AimEye_M 61 200 44 101;
	asSDNewButtton AimEye_R 36 220 23 19;
	asSDNewButtton AimEye_L 108 220 23 19;
	asSDNewButtton FaceUpper_M 139 236 48 28;
	asSDNewButtton FaceMiddle_M 147 275 48 28;
	asSDNewButtton FaceLower_M 150 310 57 28;
	asSDNewButtton upperLipRegion_M 129 344 77 17;
	asSDNewButtton LipRegion_M 129 362 77 17;
	asSDNewButtton lowerLipRegion_M 129 380 77 17;
	asSDNewButtton FaceControlSet 79 8 67 47;
	asSDNewButtton Tongue0_M 43 326 77 17;
	asSDNewButtton Tongue1_M 43 358 77 17;
	asSDNewButtton Tongue2_M 43 389 77 17;
	asSDNewButtton Tongue3_M 43 419 77 17;
	asSDNewButtton Jaw_M 241 449 156 28;
	asSDNewButtton TeethUpper_M 427 348 69 20;
	asSDNewButtton TeethLower_M 427 377 69 20;
	asSDNewButtton ctrlBrow_R 534 75 41 48;
	asSDNewButtton ctrlBrow_L 588 75 41 48;
	asSDNewButtton ctrlEye_R 534 130 41 48;
	asSDNewButtton ctrlEye_L 588 130 41 48;
	asSDNewButtton ctrlCheek_R 534 188 41 48;
	asSDNewButtton ctrlCheek_L 588 188 41 48;
	asSDNewButtton ctrlNose_R 534 245 41 48;
	asSDNewButtton ctrlNose_L 588 245 41 48;
	asSDNewButtton ctrlMouth_M 555 302 54 65;
	asSDNewButtton ctrlMouthCorner_R 534 377 41 48;
	asSDNewButtton ctrlMouthCorner_L 588 377 41 48;
	asSDNewButtton ctrlBox 512 432 125 21;
	asSDNewButtton EyeBrowInner_R 280 102 24 30;
	asSDNewButtton EyeBrowMid1_R 256 99 19 23;
	asSDNewButtton EyeBrowMid2_R 237 100 19 23;
	asSDNewButtton EyeBrowMid3_R 217 106 19 23;
	asSDNewButtton EyeBrowOuter_R 203 121 19 23;
	asSDNewButtton upperLid_R 247 138 24 30;
	asSDNewButtton upperOuterLid_R 226 152 17 21;
	asSDNewButtton lowerOuterLid_R 229 197 17 21;
	asSDNewButtton lowerLid_R 247 198 24 30;
	asSDNewButtton lowerInnerLid_R 275 197 17 21;
	asSDNewButtton upperInnerLid_R 277 152 17 21;
	asSDNewButtton outerLid_R 217 179 15 18;
	asSDNewButtton innerLid_R 289 179 15 18;
	asSDNewButtton CheekRaiser_R 232 232 24 30;
	asSDNewButtton Cheek_R 211 277 24 30;
	asSDNewButtton NoseCorner_R 276 266 20 25;
	asSDNewButtton Nostril_R 297 256 14 17;
	asSDNewButtton Nose_M 310 267 19 24;
	asSDNewButtton NoseUnder_M 310 294 19 19;
	asSDNewButtton NoseSide_R 283 234 14 17;
	asSDNewButtton NoseMiddle_M 310 216 19 19;
	asSDNewButtton upperLip_M 310 333 19 24;
	asSDNewButtton lowerLip_M 310 365 19 24;
	asSDNewButtton Lip_R 260 337 19 24;
	asSDNewButtton upperLipA_R 294 330 15 18;
	asSDNewButtton upperLipB_R 277 330 15 18;
	asSDNewButtton lowerLipA_R 292 364 15 18;
	asSDNewButtton lowerLipB_R 275 356 15 18;
	asSDNewButtton Line_R 244 326 15 18;
	asSDNewButtton EyeBrowMiddle_M 310 112 19 19;
	}

//SelectorIcons
asFitModeEnsureShaders;
createNode -n SelectorIcons transform;
setAttr SelectorIcons.tz ($height/2.2);
connectAttr SelectorLayout.s SelectorIcons.s;
createNode -n SelectorIconsWindow -p SelectorIcons transform;
connectAttr SelectorWindow.t SelectorIconsWindow.t;
connectAttr SelectorWindow.s SelectorIconsWindow.s;
createNode -n WindowIconsCorner -p SelectorIconsWindow transform;
connectAttr WindowCorner.t WindowIconsCorner.t;
connectAttr WindowCorner.s WindowIconsCorner.s;
createNode -n MirroredIcons -p WindowIconsCorner transform;
setAttr MirroredIcons.tx `getAttr SelectorWindow.sx`;
setAttr MirroredIcons.sx -1;

if ($LayoutType==1)
	{
	asSDNewIcon IKArm_R asRedSG sphere;
	asSDNewIcon PoleArm_R asRedSG cross;
	asSDNewIcon FKIKArm_R asBlueSG cross;
	asSDNewIcon IKLeg_R asRedSG sphere;
	asSDNewIcon PoleLeg_R asRedSG cross;
	asSDNewIcon FKIKLeg_R asBlueSG cross;
	asSDNewIcon RollHeel_R asRedSG torus;
	asSDNewIcon RollToes_R asRedSG torus;
	asSDNewIcon RollToesEnd_R asRedSG torus;
	asSDNewIcon HipSwinger_M asGreen2SG torus;
	asSDNewIcon IKSpine1_M asRedSG sphere;
	asSDNewIcon IKSpine2_M asRedSG sphere;
	asSDNewIcon IKSpine3_M asRedSG sphere;
	asSDNewIcon FKIKSpine_M asBlueSG cross;
	}

if (`objExists LoadingSelectorLayout`) delete LoadingSelectorLayout;

select SelectorLayout;
}

global proc asSDNewIcon (string $name, string $shader, string $shape)
{
string $buttonIcon="ButtonIcon_"+$name;
int $numLetters=`size($buttonIcon)`;
string $buttonIconLeft=`substring $buttonIcon 1 ($numLetters-2)`+"_L";
if ($shape=="sphere")
	polySphere -n $buttonIcon -r 1 -sx 20 -sy 20 -ax 0 1 0 -cuv 2 -ch 0;
if ($shape=="cross")
	{
	polyCube -n $buttonIcon -w 1 -h 1 -d 1 -sx 3 -sy 3 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	scale -r -p 0 0 0 0.333 0.333 0.333 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3]") ($buttonIcon+".vtx[12]")
		($buttonIcon+".vtx[15:16]") ($buttonIcon+".vtx[19]") ($buttonIcon+".vtx[28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 2.5 2.5 2.5 ($buttonIcon+".vtx[0:99]");
	scale -r -p 0 0 0 1 0.5 1 ($buttonIcon+".vtx[0]") ($buttonIcon+".vtx[3:12]") ($buttonIcon+".vtx[15:16]")
		($buttonIcon+".vtx[19:28]") ($buttonIcon+".vtx[31]");
	scale -r -p 0 0 0 0.5 1 1 ($buttonIcon+".vtx[0:3]") ($buttonIcon+".vtx[5:6]") ($buttonIcon+".vtx[9:10]")
		($buttonIcon+".vtx[12:19]") ($buttonIcon+".vtx[21:22]") ($buttonIcon+".vtx[25:26]") ($buttonIcon+".vtx[28:31]");
	}
if ($shape=="torus")
	polyTorus -n $buttonIcon -r 1 -sr 0.1 -tw 0 -sx 20 -sy 20 -ax 0 0 1 -cuv 1 -ch 0;
parent $buttonIcon WindowIconsCorner;
sets -e -forceElement $shader $buttonIcon;
move -r 1 -1 0 ($buttonIcon+".vtx[0:999]");
scale -r -p 0 0 0 0.5 0.5 0.5 ($buttonIcon+".vtx[0:999]");
scale -r -p 0.5 -0.5 0 0.75 0.75 0.75 ($buttonIcon+".vtx[0:999]");
connectAttr ("Button_"+$name+".t") ($buttonIcon+".t");
connectAttr ("Button_"+$name+".sx") ($buttonIcon+".sx");
connectAttr ("Button_"+$name+".sy") ($buttonIcon+".sy");
setAttr ($buttonIcon+".sz") 1000;
if (`gmatch $buttonIcon "*_R"`)
	{
	instance -n $buttonIconLeft $buttonIcon;
	parent $buttonIconLeft MirroredIcons;
	connectAttr ($buttonIcon+".t") ($buttonIconLeft+".t");
	connectAttr ($buttonIcon+".sy") ($buttonIconLeft+".sy");
	connectAttr ($buttonIcon+".sz") ($buttonIconLeft+".sz");
	createNode -n ($buttonIcon+"Reverse") reverse;
	connectAttr ($buttonIcon+".sx") ($buttonIcon+"Reverse.inputX");
	connectAttr ($buttonIcon+"Reverse.outputX") ($buttonIconLeft+".sx");
	}
	
}

global proc asSDNewButtton (string $name,int $x, int $y, int $width, int $height)
{
if (!`objExists Button_Template`)
	error "\"Button_Template\" Not found";
string $multiObjString;
string $sel[]=`ls -sl`;
string $buttonName="Button_"+$name;
if ($sel[0]!="" && !`gmatch $sel[0] "Button*"` && $sel[0]!="SelectorWindow" && $sel[0]!="SelectorLayout")
	{
	string $nameSpace=`optionMenu -q -v asSelectorDefaultOptionMenu`;
	if ($nameSpace==":")
		$buttonName="Button_"+$sel[0];
	else
		$buttonName="Button_"+`substitute $nameSpace $sel[0] ""`;
	createNode -n SelectorSampler -p WindowCorner transform;
	pointConstraint $sel[0] SelectorSampler;
	dgdirty -a;
	$x=`getAttr SelectorSampler.tx`-($width/2);
	$y=`getAttr SelectorSampler.ty`-($height/2);
	delete SelectorSampler;
	if (size($sel)>1)
		for ($i=0;$i<size($sel);$i++)
			$multiObjString+=`substitute $nameSpace $sel[$i] ""`+" ";
	}
//unique buttonName
if (`objExists $buttonName`)
	for ($i=1;$i<10;$i++)
		{
		$buttonName=`substitute "Button" $buttonName ""`;
		if (`gmatch $buttonName "[1-9]*"`)
			$buttonName=`substring $buttonName 2 99`;
		$buttonName="Button"+$i+$buttonName;
		if (!`objExists $buttonName`)
			break;
		}

string $tempString[]=`duplicate -n $buttonName Button_Template`;
$buttonName=$tempString[0];
if (!`attributeExists mirror $buttonName`)
	addAttr -k 1 -ln mirror -at bool -dv 1 $buttonName;
setAttr ($buttonName+".v") 1;
setAttr ($buttonName+".tx") $x;
setAttr ($buttonName+".ty") $y;
setAttr ($buttonName+".sx") $width;
setAttr ($buttonName+".sy") $height;
if ($multiObjString!="")
	setAttr -type "string" ($buttonName+".multiObjs") $multiObjString;

//Middle Constraint
if (`gmatch $buttonName "*_M"` && !`objExists LoadingSelectorLayout`)
	{
	if (`objExists ($buttonName+"MultiplyDivide")`) delete ($buttonName+"MultiplyDivide");
	if (`objExists ($buttonName+"PlusMinusAverage")`) delete ($buttonName+"PlusMinusAverage");
	createNode -n ($buttonName+"MultiplyDivide") multiplyDivide;
	createNode -n ($buttonName+"PlusMinusAverage") plusMinusAverage;
	setAttr ($buttonName+"PlusMinusAverage.operation") 2;
	connectAttr ($buttonName+".scale.scaleX") ($buttonName+"MultiplyDivide.input1Y");
	setAttr -type float3 ($buttonName+"MultiplyDivide.input2") 2 2 2;
	setAttr ($buttonName+"MultiplyDivide.operation") 2;
	connectAttr ($buttonName+"MultiplyDivide.outputY") ($buttonName+"PlusMinusAverage.input1D[1]");
//	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") (`getAttr SelectorWindow.scale.scaleX`/2.0);
	setAttr ($buttonName+"PlusMinusAverage.input1D[0]") 320;
	connectAttr ($buttonName+"PlusMinusAverage.output1D") ($buttonName+".tx");
	}

select $buttonName;
}

global proc int asSelectorBackgroundImport (string $fileName, string $fileType)
{
eval ("renderWindowEditor -e -loadImage \""+$fileName+"\" renderView");
asSDRender 2;
return 1;
}

global proc asSDRender (int $background)
{
global string $gMove;
setToolTo $gMove;
if (!`objExists SelectorWindow`)
	{
	if (`confirmDialog -t "Confirm"
	-m "No Layout found. Create New one ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
	asSDNewLayout 0;
	}
if (`objExists SelectorCamera`)
	delete SelectorCamera;
int $renderViewIconized=1;
if (`window -q -ex renderViewWindow`)
	$renderViewIconized=`window -q -i renderViewWindow`;
else if ($background)
	RenderViewWindow;
int $x,$y,$width,$height,$numLetters;
int $windowWidth=`getAttr SelectorWindow.sx`;
int $windowHeight=`getAttr SelectorWindow.sy`;
float $widthFloat,$heightFloat;
float $windowCornerWidth=`getAttr WindowCorner.sx`;
float $windowCornerHeight=`getAttr WindowCorner.sy`;
$windowCornerHeight=`abs($windowCornerHeight)`;
int $doMirrorBox[];
float $pos[];
string $sel[]=`ls -sl`;
string $projectName=`text -q -l asSelectorProjectName`;
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Selector/untitled/";
//string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Selector/"+$projectName+"/";
//string $iconDir=`text -q -l asSelectorProjectPath`+$projectName+"/";
string $bgImageFile=$iconDir+"untitled_background.png";
string $bgImageFile32=$iconDir+"untitled_background32.png";
string $cmd,$keyCmd,$linearKeyCmd,$labelAttr,$iol,$multiObjAttr,$ann,$fileName;
string $alignFK2IKCmd,$alignIK2FKCmd,$switchFK2IKCmd,$switchIK2FKCmd;
string $annBuffer[],$tempString[];
string $renderBoxes[]=`listRelatives -c WindowCorner`;
string $renderBoxObjs[]=$renderBoxes;
for ($i=0;$i<size($renderBoxes);$i++)
	{
	if (`gmatch $renderBoxes[$i] "Button_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 8 999`;
	if (`gmatch $renderBoxes[$i] "Button?_*"`)
		$renderBoxObjs[$i]=`substring $renderBoxes[$i] 9 999`;
//	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<$windowWidth/2)
	if (`gmatch $renderBoxes[$i] "*_R"` && `getAttr ($renderBoxes[$i]+".tx")`<320)
		{
		$numLetters=`size($renderBoxes[$i])`;
		$mirrorBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_L";
		if (`objExists $mirrorBox`)
			continue;
		if (`attributeExists mirror $renderBoxes[$i]`)
			if (`getAttr ($renderBoxes[$i]+".mirror")`==0)
				continue;

		$doMirrorBox[$i]=1;
		$doMirrorBox[size($renderBoxes)]=1;
		$renderBoxes[size($renderBoxes)]=$mirrorBox;
		}
	}

string $deleteObjs[]={"SelectorScaleSampler","SelectorCamera","SelectorFileNode","SelectorFilePlace",
	"SelectorRampU","SelectorRampV","SelectorLayeredTexture"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

float $color[3]=`displayRGBColor -q "background"`;
if (!`optionVar -ex asSelectorBGColor`)
	{
	optionVar -fv asSelectorBGColor $color[0];
	optionVar -fva asSelectorBGColor $color[1];
	optionVar -fva asSelectorBGColor $color[2];
	}
if (!`optionVar -ex asSelectorDefaultColor`)
	{
	optionVar -fv asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	optionVar -fva asSelectorDefaultColor 1;
	}
if (!`optionVar -ex asSelectorSelColor`)
	{
	optionVar -fv asSelectorSelColor 0.2;
	optionVar -fva asSelectorSelColor 0.8;
	optionVar -fva asSelectorSelColor 0.2;
	}
if (!`optionVar -ex asSelectorKeyColor`)
	{
	optionVar -fv asSelectorKeyColor 1;
	optionVar -fva asSelectorKeyColor 0.4;
	optionVar -fva asSelectorKeyColor 0.4;
	}
float $bgColor[3]=`optionVar -q asSelectorBGColor`;
float $selColor[3]=`optionVar -q asSelectorSelColor`;
float $keyColor[3]=`optionVar -q asSelectorKeyColor`;

$tempString=`formLayout -q -ca asSelectorDefaultFormLayout`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!$background && $tempString[$i]=="asSelectorDefaultBGPicture")
		continue;
	deleteUI $tempString[$i];
	}

if ($background)
	{
	if (`text -q -l asSelectorBackgroundWidth`) text -e -l $windowWidth asSelectorBackgroundWidth;
	if (`text -q -l asSelectorBackgroundHeight`) text -e -l $windowHeight asSelectorBackgroundHeight;

	createNode -n SelectorScaleSampler transform;
	$tempString=`camera -centerOfInterest 5 -focalLength 35 -lensSqueezeRatio 1 -cameraScale 1 -horizontalFilmAperture 1.4173 -horizontalFilmOffset 0 -verticalFilmAperture 0.9449 -verticalFilmOffset 0 -filmFit Fill -overscan 1 -motionBlur 0 -shutterAngle 144 -nearClipPlane 0.1 -farClipPlane 10000 -orthographic 1 -orthographicWidth 30 -panZoomEnabled 0 -horizontalPan 0 -verticalPan 0 -zoom 1`;
	rename $tempString[0] SelectorCamera;
	float $restoreRenderWidth=`getAttr defaultResolution.width`;
	float $restoreRenderHeight=`getAttr defaultResolution.height`;
	float $restoreRenderAspectLock=`getAttr defaultResolution.aspectLock`;
	int $restoreFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
	setAttr defaultRenderGlobals.imageFormat 32;
	
	setAttr "defaultResolution.aspectLock" 0;
	setAttr defaultResolution.width $windowWidth;
	setAttr defaultResolution.height $windowHeight;
	setAttr "defaultResolution.aspectLock" 1;
	setAttr defaultResolution.deviceAspectRatio ($windowWidth/($windowHeight+0.00));
	
	select SelectorWindow.vtx[0:99];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] SelectorCamera;
	move -r 0 0 1.1 SelectorCamera;
	delete `scaleConstraint SelectorWindow SelectorScaleSampler`;
	setAttr SelectorCameraShape.orthographicWidth `getAttr SelectorScaleSampler.sx`;
	if ($background==1)
		renderWindowRenderCamera render renderView SelectorCamera;
	eval ("renderWindowEditor -e -wi \""+$bgImageFile+"\" renderView");
	setParent asSelectorDefaultFormLayout;

	image -en 0 -w $windowWidth -h $windowHeight -i $bgImageFile asSelectorDefaultBGPicture;
	reloadImage $bgImageFile asSelectorDefaultBGPicture;
	formLayout -e -af asSelectorDefaultBGPicture "left" 0 -af asSelectorDefaultBGPicture "top" 0 asSelectorDefaultFormLayout;
	//32
	string $fileNode=`createNode file`;
	setAttr -type "string" ($fileNode+".fileTextureName") $bgImageFile;
	select $fileNode;
	eval ("convertSolidTx -sp 1 -al 1 -rx 32 -ry 32 -n asTempSolidTx32 -fil \"png\" -fin \""+$bgImageFile32+"\"");
	delete $fileNode asTempSolidTx32;
	evalDeferred -lp ("window -e -w "+$windowWidth+" -h "+$windowHeight+" asSelectorDefault");
	
	setAttr defaultResolution.width $restoreRenderWidth;
	setAttr defaultResolution.height $restoreRenderHeight;
	setAttr defaultResolution.aspectLock $restoreRenderAspectLock;
	setAttr defaultRenderGlobals.imageFormat $restoreFormat;
	delete SelectorCamera SelectorScaleSampler;
	if ($renderViewIconized)
		window -e -i 1 renderViewWindow;
	}

for ($i=0;$i<size($renderBoxes);$i++)
	{
	$guiBox=$renderBoxes[$i];
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		{
		$numLetters=`size($renderBoxes[$i])`;
		$guiBox=`substring $renderBoxes[$i] 1 ($numLetters-2)`+"_R";
		}
	$x=`getAttr ($guiBox+".tx")`*$windowWidth*$windowCornerWidth;
	$y=`getAttr ($guiBox+".ty")`*$windowHeight*$windowCornerHeight;
	
	$widthFloat=`getAttr ($guiBox+".sx")`*$windowWidth*$windowCornerWidth;
	$width=`asRoundOff $widthFloat 0`;
	$heightFloat=`getAttr ($guiBox+".sy")`*$windowHeight*$windowCornerHeight;
	$height=`asRoundOff $heightFloat 0`;
	if (`gmatch $renderBoxes[$i] "*_L"` && $doMirrorBox[$i])
		$x=$windowWidth-$x-$width;
	if ($x<0 || $x>$windowWidth || $y<0 || $y>$windowHeight)
		continue;
	if ($background)
		continue;
	if ($bgImageFile=="" || !`file -q -ex $bgImageFile`)
		error "No background image, Render a background first";
	$iol="";
	$labelAttr=`getAttr ($guiBox+".label")`;
	if ($labelAttr!="")
		$iol=$labelAttr;
	$ann=$renderBoxObjs[$i];
	$fileName=$ann;
	$multiObjAttr=`getAttr ($guiBox+".multiObjs")`;
	if ($multiObjAttr!="")
		{
		$ann=$multiObjAttr;
		if (`gmatch $renderBoxes[$i] "*_L"`)
			{
			tokenize $ann $tempString;
			$ann="";
			for ($z=0;$z<size($tempString);$z++)
				$ann+=`substitute "_R" $tempString[$z] "_L"`+" ";
			}
		$fileName="combo"+$x+$y;
		}

	createNode -n SelectorFileNode file;
	setAttr -type "string" SelectorFileNode.fileTextureName $bgImageFile;
	float $pictureWidth=`getAttr SelectorFileNode.outSizeX`;
	float $pictureHeight=`getAttr SelectorFileNode.outSizeY`;
	createNode -n SelectorFilePlace place2dTexture;
	connectAttr SelectorFilePlace.outUV SelectorFileNode.uvCoord; connectAttr -f SelectorFilePlace.outUvFilterSize SelectorFileNode.uvFilterSize; 
	connectAttr -f SelectorFilePlace.coverage SelectorFileNode.coverage; connectAttr -f SelectorFilePlace.translateFrame SelectorFileNode.translateFrame; 
	connectAttr -f SelectorFilePlace.rotateFrame SelectorFileNode.rotateFrame; connectAttr -f SelectorFilePlace.mirrorU SelectorFileNode.mirrorU; 
	connectAttr -f SelectorFilePlace.mirrorV SelectorFileNode.mirrorV; connectAttr -f SelectorFilePlace.stagger SelectorFileNode.stagger; 
	connectAttr -f SelectorFilePlace.wrapU SelectorFileNode.wrapU; connectAttr -f SelectorFilePlace.wrapV SelectorFileNode.wrapV; 
	connectAttr -f SelectorFilePlace.repeatUV SelectorFileNode.repeatUV; connectAttr -f SelectorFilePlace.vertexUvOne SelectorFileNode.vertexUvOne; 
	connectAttr -f SelectorFilePlace.vertexUvTwo SelectorFileNode.vertexUvTwo; connectAttr -f SelectorFilePlace.vertexUvThree SelectorFileNode.vertexUvThree; 
	connectAttr -f SelectorFilePlace.vertexCameraOne SelectorFileNode.vertexCameraOne; connectAttr -f SelectorFilePlace.noiseUV SelectorFileNode.noiseUV; 
	connectAttr -f SelectorFilePlace.offset SelectorFileNode.offset; connectAttr -f SelectorFilePlace.rotateUV SelectorFileNode.rotateUV;
	setAttr SelectorFilePlace.offsetU (($x+1)/$pictureWidth);
	setAttr SelectorFilePlace.offsetV (($pictureHeight-($y-1+$height))/$pictureHeight);
	setAttr SelectorFilePlace.repeatV (($height-2)/$pictureHeight);
	setAttr SelectorFilePlace.repeatU (($width-2)/$pictureWidth);

	createNode -n SelectorRampU ramp;
	createNode -n SelectorRampV ramp;
	setAttr SelectorRampU.type 1;
	setAttr SelectorRampU.interpolation 0;
	setAttr SelectorRampU.colorEntryList[1].color -type double3 0.75 0.75 0.75;
//	if ($width>2)
		setAttr SelectorRampU.colorEntryList[1].position (1-(1.00000/$width));
	setAttr SelectorRampU.colorEntryList[0].color -type double3 0 0 0;
	setAttr SelectorRampV.type 0;
	setAttr SelectorRampV.interpolation 0;
	setAttr SelectorRampV.colorEntryList[0].color -type double3 0.75 0.75 0.75;
//	if ($height>2)
		setAttr SelectorRampV.colorEntryList[1].position (1.00000/$height);
	connectAttr SelectorRampU.outColor SelectorRampV.colorEntryList[1].color;
	setAttr SelectorRampU.colorEntryList[0].position (1.00000/$width);
	setAttr SelectorRampU.colorEntryList[2].color -type double3 0.75 0.75 0.75;
	setAttr SelectorRampV.colorEntryList[0].position (1-(1.00000/$height));
	setAttr SelectorRampV.colorEntryList[2].color -type double3 0.75 0.75 0.75;


	createNode -n SelectorLayeredTexture layeredTexture;
	setAttr SelectorLayeredTexture.inputs[0].color -type double3 1 1 1 ;
	connectAttr SelectorRampV.outColorR SelectorLayeredTexture.inputs[0].alpha;
	connectAttr -f SelectorFileNode.outAlpha SelectorLayeredTexture.inputs[1].alpha;
	connectAttr -f SelectorFileNode.outColor SelectorLayeredTexture.inputs[1].color;

	string $buttonImageFileOffK0=$iconDir+$projectName+"_"+$fileName+"_OffK0.png";
	string $buttonImageFileOffK1=$iconDir+$projectName+"_"+$fileName+"_OffK1.png";
	string $buttonImageFileOnK0=$iconDir+$projectName+"_"+$fileName+"_OnK0.png";
	string $buttonImageFileOnK1=$iconDir+$projectName+"_"+$fileName+"_OnK1.png";
	
	//Off K0 version
	select SelectorLayeredTexture;
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK0+"\"");
	delete asTempSolidTx;

	//add tint now, so that selection/keyed buttons (with blank space background) are also visible
	setAttr SelectorLayeredTexture.inputs[2].alpha 0.3;
	
	//Off K1 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOffK1+"\"");
	delete asTempSolidTx;
	
	//On K0 version
	setAttr SelectorFileNode.colorOffset -type double3 0.27 0.27 0.27;
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 $selColor[0] $selColor[1] $selColor[2];
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK0+"\"");
	delete asTempSolidTx;
	
	//On K1 version
	setAttr SelectorFileNode.colorOffset -type double3 $keyColor[0] $keyColor[1] $keyColor[2];
	setAttr SelectorFileNode.colorGain -type double3 $selColor[0] $selColor[1] $selColor[2];
	setAttr SelectorLayeredTexture.inputs[2].color -type double3 ($selColor[0]+$keyColor[0]) ($selColor[1]+$keyColor[1]) ($selColor[2]+$keyColor[2]);
	eval ("convertSolidTx -aa 0 -sp 1 -al 1 -rx "+$width+" -ry "+$height+" -n asTempSolidTx -fil \"png\" -fin \""+$buttonImageFileOnK1+"\"");
	delete asTempSolidTx;
	for ($q=0;$q<size($deleteObjs);$q++)
		if (`objExists $deleteObjs[$q]`)
			delete $deleteObjs[$q];


	if (`control -q -ex $renderBoxes[$i]`)
		deleteUI $renderBoxes[$i];
	setParent asSelectorDefaultFormLayout;

	//Update cmd, popUp
	$alignFK2IKCmd=$alignIK2FKCmd=$switchFK2IKCmd=$switchIK2FKCmd="";
	if (`gmatch $renderBoxObjs[$i] "FKIK*"`)
		{
		$alignFK2IKCmd="asAlignFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$alignIK2FKCmd="asAlignIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchFK2IKCmd="asSwitchFK2IK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		$switchIK2FKCmd="asSwitchIK2FK \"Default\" {\""+$renderBoxObjs[$i]+"\"}";
		}
	$cmd="asSelect \"Default\" {\""+$ann+"\"};";
	if (`gmatch $ann "* *"`)
		{
		tokenize $ann $annBuffer;
		$cmd="asSelect \"Default\" {";
		for ($q=0;$q<size($annBuffer);$q++)
			{
			$cmd+="\""+$annBuffer[$q]+"\"";
			if ($q<size($annBuffer)-1)
				$cmd+=",";
			}
		$cmd+="};";
		}
	$keyCmd="asKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";
	$linearKeyCmd="asLinearKey \"Default\" {\""+$renderBoxObjs[$i]+"\"};";

	$buttonName=$renderBoxObjs[$i]+":"+$x+":"+$y;
	iconTextButton -w $width -h $height -i $buttonImageFileOffK0 -iol $iol -c $cmd -ann $ann $buttonName;
	reloadImage $buttonImageFileOffK0 $buttonName;
	formLayout -e -af $buttonName "left" $x -af $buttonName "top" $y asSelectorDefaultFormLayout;

	popupMenu -p $buttonName;
		menuItem -l "Key" -c $keyCmd;
		menuItem -l "LinearKey" -c $linearKeyCmd;
		menuItem -d 1;
		menuItem -l "Label Button" -c ("asLabelButton \""+$buttonName+"\"");
//		menuItem -l "Remove Button" -c ("asDeleteButton \""+$buttonName+"\"");
		if ($alignFK2IKCmd!="")
			{
			menuItem -d 1;
			menuItem -sm 1 -l "Align";
				menuItem -l "FK2IK" -c $alignFK2IKCmd;
				menuItem -l "IK2FK" -c $alignIK2FKCmd;
				setParent -menu ..;
			menuItem -sm 1 -l "Switch";
				menuItem -l "FK2IK" -c $switchFK2IKCmd;
				menuItem -l "IK2FK" -c $switchIK2FKCmd;
			}
	}


select $sel;
}

global proc asLabelButton (string $button)
{
string $return=`promptDialog -t "Label" -b "Ok"  -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($return!="Ok")
	return;
iconTextButton -e -iol (`promptDialog -q -tx`) $button;
if (`promptDialog -q -tx`=="All")
	iconTextButton -e -ann "ControlSet" $button;
//asSelectorRefresh;
}
//-- ASSelectorDesigner Procedures Ends Here --//

//-- ASPoserDesigner Procedures Starts Here --//
global proc asPoserDesigner ()
{
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $fileList[]=`getFileList -fld ($iconDir+"/")`;
for ($file in $fileList)
	eval ("sysFile -del \""+$iconDir+"/"+$file+"\"");
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
int $nc=`optionVar -q asPoserNc`;
if ($nc<1)
	$nc=4;
int $nr=`optionVar -q asPoserNr`;
if ($nr<1)
	$nr=2;
string $poserText=`optionVar -q asPoserText`;
if ($poserText=="0")
	$poserText="Pose";
int $onlySel=`optionVar -q asPoserOnlySel`;
int $anim=`optionVar -q asPoserAnim`;
int $renderView=`optionVar -q asPoserRenderView`;
string $controlSets[]=`asGetControlSets`;

if (`window -q -ex asPoserDefault`)
	deleteUI asPoserDefault;
window -mb 1 -t "PoserDesigner :untitled" asPoserDefault;
menu "File";
	menuItem -c "evalDeferred asPoserDesigner" "New";
	menuItem -c "asfileBrowse Poser Open" "Open";
	menuItem -sm 1 -l "ControlSets" asPoserControlSetsMenu;
		menuItem -cb 1 -l ControlSet asPoserControlSetsMenuItemControlSet;
		for ($i=0;$i<size($controlSets);$i++)
			if ($controlSets[$i]!="ControlSet")
				menuItem -cb 0 -l $controlSets[$i] ("asPoserControlSetsMenuItem"+$controlSets[$i]);
		setParent -menu ..;
	menuItem -d 1;
	menuItem -c "asSave Poser" "Save";
	menuItem -c "asfileBrowse Poser SaveAs" "Save As";
	menuItem -c "astoShelf Poser" "Put on shelf";
	setParent -menu ..;
	menuItem -d 1;
	menuItem -c "deleteUI asPoserDefault" "Close";
	setParent -menu ..;
formLayout asPoserDefaultFormLayout;
	text -vis 0 -l (`asGetTempDirectory`+"AdvancedSkeleton/Poser/") asPoserProjectPath;
	text -vis 0 -l ("untitled") asPoserProjectName;
	rowLayout -adj 1 -nc 8 -cw 2 90 -cw 3 80 -cw 4 90 -cw 5 50 -cw 6 20 -cw 7 25 asPoserDefaultRowLayout;
		optionMenu asPoserDefaultOptionMenu;
		button -l "    New Pose    " -c "asNewPose {} 0";
		textField -w 70 -tx $poserText -cc asPoserUpdateGrid asPoserTextField;
		checkBox -v $onlySel -l "only selected" -cc asPoserUpdateGrid asPoserOnlySel;
		checkBox -v $anim -l "anim" -cc asPoserUpdateGrid asPoserAnim;
		intField -w 20 -v $nc -cc asPoserUpdateGrid asPoserNc;
		intField -w 20 -v $nr -cc asPoserUpdateGrid asPoserNr;
		checkBox -v $renderView -l "renderView" -cc asPoserUpdateGrid asPoserRenderView;
		setParent..;
//	scrollLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
//	cannot use scrollLayout cause it returns incorrect drop coordinates when scrolled.
	columnLayout -dgc asPoserDgc -dpc asPoserDpc asPoserDefaultScrollayout;
		gridLayout -h (90*$nr) -nc $nc -nr $nr -cw 110 -ch 90 asPoserDefaultGridLayout;

formLayout -e
	-af asPoserDefaultRowLayout "top" 0
	-ac asPoserDefaultScrollayout "top" 0 asPoserDefaultRowLayout
	-af asPoserDefaultScrollayout "bottom" 0
	-af asPoserDefaultScrollayout "left" 0
	-af asPoserDefaultScrollayout "right" 0
	asPoserDefaultFormLayout;

asPopulateNameSpaceMenu "asPoserDefault";

//Remove Old Icons
string $oldFilesList[]=`getFileList -fld $iconDir`;
for ($file in $oldFilesList)
	sysFile -del ($iconDir+$file);

showWindow asPoserDefault;
}

global proc asNewPose (string $loadData[], int $anim)
{
global int $asfileLoading;
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;
string $setParent=`setParent -q`;
string $uiName,$image,$label,$cmd,$mayaFile,$loadingMayaFile;
int $nc,$nr,$numTok,$singleAttr;
float $range[2]={0,1};
string $buffer[];
if ($loadData[0]=="" || $asfileLoading)
	{
	$nc=`intField -q -v asPoserNc`;
	$nr=`intField -q -v asPoserNr`;
	$uiName="asPoserDefault";
	}
else
	$uiName=$loadData[0];
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
string $gridOrder[]=`gridLayout -q -go ($uiName+"GridLayout")`;
int $lastFilled,$childNum;
//Find Last filled
for ($i=1;$i<size($gridOrder)+1;$i++)
	if (`gmatch $gridOrder[$i-1] "asPoser*"`)
		$lastFilled=$i;
$childNum=$lastFilled+1;

//Total full
if ($childNum>($nc*$nr) && $loadData[0]=="")
	error "Grid is full, extend rows or columns !\n";

if ($loadData[0]=="")
	{
	if (`optionMenu -q -v asPoserDefaultOptionMenu`=="None")
		error "No Character In The Scene\n";
	$anim=`checkBox -q -v asPoserAnim`;
	$cmd=`asPoserGetCmd $uiName $anim`;
	if ($cmd=="")
		error "No valid objects !\n";
	$image=`asPoserSnapShoot $uiName $childNum $anim 1 1`;
	if ($anim && $cmd!="")
		$cmd+=" "+$childNum;
	if (`about -mac`)
		showWindow asPoserDefault;
	$label=`textField -q -tx asPoserTextField`;
	}
else
	{
	$childNum=$loadData[4];
	$numTok=`tokenize $loadData[1] "/" $buffer`;
	$image=$iconDir+"untitled_"+$childNum+"."+$ext;
	sysFile -cp $image $loadData[1];
	$mayaFile=`substitute "[.][a-z][a-z][a-z]" $image ".ma"`;
	$loadingMayaFile=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".ma"`;
	if (`file -q -ex $loadingMayaFile`)
		sysFile -cp $mayaFile $loadingMayaFile;
	$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
	$loadingJpg=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".jpg"`;
	if (`file -q -ex $loadingJpg`)
		sysFile -cp $jpg $loadingJpg;
	$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
	$loadingAvi=`substitute "[.][a-z][a-z][a-z]" $loadData[1] ".avi"`;
	if (`file -q -ex $loadingAvi`)
		sysFile -cp $avi $loadingAvi;
	$label=$loadData[2];
	$cmd=$loadData[3];
	if ($asfileLoading)
		$cmd=`substitute $loadData[0] $cmd $uiName`;
	$anim=$loadData[5];
	}
$numTok=`tokenize $cmd ";" $buffer`;
if ($numTok==2)
	$singleAttr=1;
setParent ($uiName+"GridLayout");
columnLayout ($uiName+"ColumnLayout"+$childNum);
gridLayout -e -pos ($uiName+"ColumnLayout"+$childNum) $childNum ($uiName+"GridLayout");
rowColumnLayout -ann $anim -nc 2 -cw 1 100 -cw 2 15 ($uiName+"RowColumnLayout"+$childNum);
	iconTextButton -w 100 -h 75 -i $image -c $cmd ($uiName+"IconTextButton"+$childNum);
	floatSlider -m 0 -w 10 -h 75 -hr 0 ($uiName+"FloatSlider"+$childNum);
	text -h 15 -al "center" -fn "smallBoldLabelFont" -l $label ($uiName+"Text"+$childNum);
if ($anim)
	text -e -bgc 1 0 0 ($uiName+"Text"+$childNum);
if ($loadData[0]=="" || $asfileLoading)
	{
	asPoserupdateGridBlock $uiName $childNum;
	iconTextButton -e -dgc asPoserDgc -dpc asPoserDpc ($uiName+"IconTextButton"+$childNum);
	}

//connectControl
string $connectToObj,$connectToAttr,$resolvedDestination;
string $allKeyableAttrs[];
if ($singleAttr)
	{
	tokenize $cmd "\"" $buffer;
	tokenize $buffer[1]  $buffer;
	tokenize $buffer[0] "." $buffer;
	$connectToObj=$buffer[0];
	$connectToAttr=$buffer[1];
	$resolvedObj=`asPoserResolveNameSpace $uiName $connectToObj`;
	if (`objExists $resolvedObj`)
		$allKeyableAttrs=`listAttr -k -m -sn $resolvedObj`;

	for ($allKeyableAttr in $allKeyableAttrs)
		if ($connectToAttr==$allKeyableAttr)
			if (`getAttr -se ($resolvedObj+"."+$connectToAttr)`)
					{
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						if (!`attributeQuery -n $resolvedObj -re $connectToAttr`)
							break;
					if (`attributeQuery -n $resolvedObj -ex $connectToAttr`)
						$range=`attributeQuery -n $resolvedObj -r $connectToAttr`;
					else
						//probably a muli attr  e.g. blenShape target..using range 0->1
						$range={0,1};
					floatSlider -ann ($connectToObj+"."+$connectToAttr) -e -m 1 -min $range[0] -max $range[1] ($uiName+"FloatSlider"+$childNum);
					connectControl ($uiName+"FloatSlider"+$childNum) ($resolvedObj+"."+$connectToAttr);
					text -e -l $connectToAttr ($uiName+"Text"+$childNum);
					}
	}
setParent $setParent;
}

global proc asPoserUpdateGrid ()
{
int $nc=`intField -q -v asPoserNc`;
optionVar -iv asPoserNc $nc;
int $nr=`intField -q -v asPoserNr`;
optionVar -iv asPoserNr $nr;
string $poserText=`textField -q -tx asPoserTextField`;
optionVar -sv asPoserText $poserText;
int $onlySel=`checkBox -q -v asPoserOnlySel`;
optionVar -iv asPoserOnlySel $onlySel;
int $anim=`checkBox -q -v asPoserAnim`;
optionVar -iv asPoserAnim $anim;
int $renderView=`checkBox -q -v asPoserRenderView`;
optionVar -iv asPoserRenderView $renderView;

if ($nc<1)
	{
	intField -e -v 1 asPoserNc;
	asPoserUpdateGrid;
	return;
	}
if ($nr<1)
	{
	intField -e -v 1 asPoserNr;
	asPoserUpdateGrid;
	return;
	}
gridLayout -e -nc $nc -nr $nr -w (110*$nc) -h (90*$nr) asPoserDefaultGridLayout;
}

global proc asPoserRename (int $childNum)
{
if (!`text -q -ex ("asPoserDefaultText"+$childNum)`)
	error "Cant find `text` uiElement\n";
string $oldname=`text -q -l ("asPoserDefaultText"+$childNum)`;
string $return=`promptDialog -m "Name:" -tx $oldname -t ("AdvancedSkeleton") -b "Ok" -b "Cancel" -db "Ok" -cb "Cancel" -ds "Cancel"`;
if ($return=="Cancel")
	return;
string $newName=`promptDialog -q -tx`;
text -e -l $newName ("asPoserDefaultText"+$childNum);
}

global proc asPoserDeletePose (string $uiName, int $num)
{
string $image=`iconTextButton -q -i ($uiName+"IconTextButton"+$num)`;
$jpgImage=`substitute "[.]png" $image ".jpg"`;
$jpgImage=`substitute "[.]xpm" $jpgImage ".jpg"`;
sysFile -del $image;
sysFile -del $jpgImage;

evalDeferred ("deleteUI "+$uiName+"ColumnLayout"+$num);
}

global proc string asPoserSnapShoot (string $uiName, int $childNum, int $anim, int $updateIcon, int $updateMovie)
{
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
int $renderView=`checkBox -q -v asPoserRenderView`;
if (!`file -q -ex $iconDir`)
	sysFile -md $iconDir;

int $curFrame=`currentTime -q`;
int $startFrame=$endFrame=$curFrame;
int $currFormat=`getAttr "defaultRenderGlobals.imageFormat"`;
string $huds[]=`headsUpDisplay -listHeadsUpDisplays`;
int $hudStates[];
for ($i=0;$i<size($huds);$i++)
	{
	$hudStates[$i]=`headsUpDisplay -q -vis $huds[$i]`;
	headsUpDisplay -e -vis 0 $huds[$i];
	}
string $ext;
if (`asMayaVersionAsFloat`>=2011)
	{
	$ext="png";
	setAttr "defaultRenderGlobals.imageFormat" 32;
	}
else
	{
	$ext="xpm";
	setAttr -type "string" defaultRenderGlobals.imfPluginKey "xpm";
	setAttr defaultRenderGlobals.imageFormat 50;
	}
string $fileName=$iconDir+"untitled_"+$childNum;
string $iconImage=$fileName+"."+$ext;
string $blastImage=$fileName+"."+`asDoPadd $curFrame 4`;
string $blastMovie=$fileName+".avi";
string $largeImage=$fileName+".jpg";
string $bgImageFile32=$iconDir+"untitled_background32."+$ext;
int $iconExists;
if (`file -q -ex $iconImage`)
	$iconExists=1;
		
if ($renderView && $updateIcon)
	{
	if (`renderWindowEditor -q -nim renderView`<0)
		error ("No Image In RenderView\n");
	eval ("renderWindowEditor -e -wi \""+$iconImage+"\" renderView");
	asPoserResizeImage 100 75 $iconImage $iconImage;
	setAttr defaultRenderGlobals.imageFormat 8;
	evalEcho ("renderWindowEditor -e -wi \""+$largeImage+"\" renderView");
	}
if (!$renderView && $updateIcon)
	{
	playblast -w 100 -h 75 -compression "png" -p 100 -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $iconImage ($blastImage+"."+$ext);
	}

setAttr defaultRenderGlobals.imageFormat 8;

if ($anim && $updateMovie)
	playblast -p 100 -st `playbackOptions -q -min` -et `playbackOptions -q -max` -f $fileName -fmt movie -fo -clearCache 0 -viewer 0 -showOrnaments 0;
else if ($updateIcon)
	{
	playblast -p 100 -compression "png" -st $curFrame -et $curFrame -f $fileName -fmt image -fo -clearCache 0 -viewer 0 -showOrnaments 0;
	sysFile -ren $largeImage ($blastImage+".jpg");
	}
setAttr defaultRenderGlobals.imageFormat $currFormat;
for ($i=0;$i<size($huds);$i++)
	headsUpDisplay -e -vis $hudStates[$i] $huds[$i];


if (`about -linux`)
	$iconImage=`asConvertToXpm $iconImage`;

//32x32
if (!`file -q -ex $bgImageFile32`)
	{
	asPoserResizeImage 32 32 $iconImage $bgImageFile32;
	if (`about -linux`)
		asConvertToXpm $bgImageFile32;
	}

if ($iconExists)
	reloadImage $iconImage ($uiName+"IconTextButton"+$childNum);
return $iconImage;
}

global proc asPoserResizeImage (int $x, int $y, string $inputImage, string $outputImage)
{
string $sel[]=`ls -sl`;
string $buttonImageFileExt="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$buttonImageFileExt="png";
string $uniqueFileName=`asUniqueFile $inputImage`;
string $fileNode=`createNode file`;
setAttr -type "string" ($fileNode+".fileTextureName") $uniqueFileName;
eval ("convertSolidTx -sp 1 -al 1 -rx "+$x+" -ry "+$y+" -n asTempSolidTx32 -fil \""+$buttonImageFileExt+"\" -fin \""+$outputImage+"\"");
delete $fileNode asTempSolidTx32;
sysFile -del $uniqueFileName;
select $sel;
}

global proc string asDoPadd (int $frameNr,int $padding)
{
string $frameName;
string $padd="";
string $neg="";
string $frameNrAsString=$frameNr;
for ($i=0;$i<$padding;$i++)
	$padd=$padd+"0";
//move the negative symbol to start of string//
if ($frameNr<0)
	$neg="-";
int $nr=`size ($frameNrAsString)`;
if ($padding>$nr)
	$frameName=$neg+`substring $padd ($nr+1) 999`+abs($frameNr);
else
	$frameName=$frameNr;
return $frameName;
}

global proc string[] asPoserDgc (string $dragControl, int $x, int $y, int $mods) 
{
string $return[];
$return[0]=$x;
$return[1]=$y;
$return[2]=$mods;
return $return;
}

global proc asPoserDpc (string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) 
{
string $iconDir=`asGetTempDirectory`+"AdvancedSkeleton/Poser/untitled/";
if (`gmatch $dropControl "*IconTextButton*"`)
	return;
int $left=$msgs[0];
int $top=$msgs[1];

int $nc=`intField -q -v asPoserNc`;
int $nr=`intField -q -v asPoserNr`;
	
string $match=`match "[0-9]+$" $dragControl`;
int $oldChildNum=$match;
int $newRowNum=ceil(($x+0.00)/110);
int $newColNum=ceil(($y+0.00)/90);
int $newChildNum=$newRowNum+(($newColNum-1)*$nc);
if ($newChildNum==$oldChildNum)
	return;
if ($newChildNum>($nc*$nr))
	error "out of grid, extend rows or columns !\n";
string $gridOrder[]=`gridLayout -q -go asPoserDefaultGridLayout`;
if (`gmatch $gridOrder[$newChildNum-1] "asPoser*"`)
	error "grid position is occupied !\n";
gridLayout -e -pos ("asPoserDefaultColumnLayout"+$oldChildNum) $newChildNum asPoserDefaultGridLayout;

//rename UI elements
string $children[]=`layout -q -ca ("asPoserDefaultColumnLayout"+$oldChildNum)`;
$children[size($children)]="asPoserDefaultColumnLayout"+$oldChildNum;
string $grandChildren[]=`layout -q -ca $children[0]`;
string $allChildren[]=`stringArrayCatenate $children $grandChildren`;
string $tempString[];
string $cmd;
int $numDigitsInIldChildNum=size($match);
int $numDigitsInChild;
int $numDigitsInImage;
string $newChildName,$image,$animFile,$newAnimFile;
string $ext="xpm";
if (`asMayaVersionAsFloat`>=2011)
	$ext="png";
for ($child in $allChildren)
	{
	$numDigitsInChild=size($child);
	string $newChildName=`substring $child 1 ($numDigitsInChild-$numDigitsInIldChildNum)`+$newChildNum;
	renameUI $child $newChildName;

	//rename bitmaps
	if (!`iconTextButton -q -ex $newChildName`)
		continue;
	$image=`iconTextButton -q -i $newChildName`;
	$numDigitsInImage=size($image);
	$newImage=`substring ("\""+$image+"\"") 2 ($numDigitsInImage-3-$numDigitsInIldChildNum)`+$newChildNum+"."+$ext;
	if (`file -q -ex $image` && $newImage!=$image)
		{
		eval ("sysFile -ren \""+$newImage+"\"  \""+$image+"\"");
		iconTextButton -e -i $newImage $newChildName;
		reloadImage $newImage $newChildName;
		$jpg=`substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		if (`file -q -ex $jpg`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".jpg"` `substitute "[.][a-z][a-z][a-z]" $image ".jpg"`;
		$avi=`substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		if (`file -q -ex $avi`)
			sysFile -ren `substitute "[.][a-z][a-z][a-z]" $newImage ".avi"` `substitute "[.][a-z][a-z][a-z]" $image ".avi"`;
		}
	//rename anim files
	$animFile=$iconDir+"untitled_"+$oldChildNum+".ma";
	$newAnimFile=$iconDir+"untitled_"+$newChildNum+".ma";
	if (`file -q -ex $animFile` && $newAnimFile!=$animFile)
		eval ("sysFile -ren \""+$newAnimFile+"\"  \""+$animFile+"\"");
	//update animation command
	$cmd=`iconTextButton -q -c $newChildName`;
	tokenize $cmd $tempString;
	if ($tempString[0]=="asLoadAttrs")
		{
		$cmd=$tempString[0]+" "+$tempString[1]+" "+$newChildNum;
		iconTextButton -e -c $cmd $newChildName;
		}
	}
string $uiName="asPoserDefault";
asPoserupdateGridBlock $uiName $newChildNum;
}
//-- ASPoserDesigner Procedures Ends Here --//
//-- ASWalkDesigner Procedures Start Here --//
global proc asWalkDesigner ()
{
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
//create, connectControl, and delete, to disable.
int $mixerExisted=1;
if (!`objExists WalkDesignerMotionMixer`)
	{
	createNode -n WalkDesignerMotionMixer transform;
	addAttr -k 1 -dv 1 -ln "speed" -at double WalkDesignerMotionMixer;
	$mixerExisted=0;
	}
if (`window -q -ex asWalkDesigner`)
	deleteUI asWalkDesigner;
window -mb 1 -t WalkDesigner asWalkDesigner;
formLayout asWDFormLayout;
columnLayout;
optionMenu -w 200 asWalkDesignerOptionMenu;
button -l "Start" -c asWDStart;
columnLayout asWDMixerColumnLayout;
for($i=0;$i<size($motions);$i++)
	{
	if(!$mixerExisted)
		addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	rowLayout -nc 2 -cw2 240 100;
		floatSliderGrp -label $motions[$i] -field true -cw 1 80 -cw 2 50 -cw 3 100 -min 0 -max 1 ("asWDField"+$i);
		connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
		button -l "solo" -c ("asWDSolo "+$i);
		setParent..;
	}
floatSliderGrp -cc asWDSpeedChange -pre 2 -v 1 -label "speed" -field true -cw 1 40 -cw 2 40 -cw 3 180 -min 0.01 -max 2 asWDSpeedField;
connectControl asWDSpeedField WalkDesignerMotionMixer.speed;
if (`asIsMayaLT`)
	floatSliderGrp -e -en 0 asWDSpeedField;
setParent..;

frameLayout -w 279 -cll 1 -cl 1 -l "Baking";
columnLayout;
//text -l "baking:";
checkBox -cc asWDSpeedChange -l "loop animation (curves > post infinity > cycle)" -v 1 -onc "intField -e -en 0 asWDLoopsIntField" -ofc "intField -e -en 1 asWDLoopsIntField" asWDLoopCheckBox;
text -l "or";
rowLayout -nc 3;
	text -l "loop animation";
	intField -cc asWDSpeedChange -en 0 -w 30 -min 1 -v 1 asWDLoopsIntField;
	text -l "times";
	setParent..;
button -l "Ok, Bake keys onto character" -c asWDBake;
setParent..;
setParent..;
setParent..;
button -l "Cancel and Close" -c asWDFinish asWDClose;
formLayout -e 
	-attachForm asWDClose "bottom" 0
	-attachForm asWDClose "left" 0
	-attachForm asWDClose "right" 0
	asWDFormLayout;

asPopulateNameSpaceMenu "asWalkDesigner";
if(!$mixerExisted)
	delete WalkDesignerMotionMixer;
showWindow;
}

global proc asWDBake ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
select -cl;
string $allFkControls[];
for($i=0;$i<size($consts);$i++)
	{
	string $fkControl=$nameSpace+"FK"+$consts[$i];
	if ($consts[$i]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	$allFkControls[size($allFkControls)]=$fkControl;
	select -add $fkControl;
	}

if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}

bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "rx" -at "ry" -at "rz";
select ($nameSpace+"RootX_M");
bakeResults -simulation true -t ("0:"+$endTime)
	-sampleBy 1 -disableImplicitControl true -preserveOutsideKeys false -sparseAnimCurveBake false 
	-removeBakedAttributeFromLayer false -bakeOnOverrideLayer false -at "tx" -at "ty" -at "tz";
if (`checkBox -q -v asWDLoopCheckBox`)
	{
	select $allFkControls;
	setInfinity -poi cycle;
	}
asWDFinish;
}

global proc asWDSpeedChange ()
{
if (!`objExists WalkDesignerMotionMixer` || !`objExists walkDesignerClip`)
	return;
float $defaultEndTime=`getAttr WalkDesignerMotionMixer.defaultEndTime`;
float $speed=`getAttr WalkDesignerMotionMixer.speed`;
float $endTime=$defaultEndTime*(1.0/$speed);
if (!`checkBox -q -v asWDLoopCheckBox`)
	{
	setAttr "walkDesignerClip.postCycle" 9999;
	$endTime=$endTime*`intField -q -v asWDLoopsIntField`;
	}
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr walkDesignerClip.scale (1.0/$speed);
}

global proc asWDStart ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";
if (!`objExists ($nameSpace+"Main")`)
	error ("AdvancedSkeleton not found in your scene");
float $charHeight=`getAttr ($nameSpace+"Main.height")`;

string $motionFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asMotion.ma";
if (!`file -q -ex $motionFile`)
	error ("Not found:"+$motionFile);
if (`objExists WalkDesignerMotionMixer`)
	error ("\"WalkDesignerMotionMixer\", already exists, delete this object, before starting again");
if (!`file -q -ex $motionFile`)
	error ("Required motion file not found:\""+$motionFile+"\"");
string $tempString[]=`ls "asMotion:*"`;
if (size($tempString))
	delete $tempString;
if (`namespace -ex "asMotion"`)
	if (catchQuiet (`namespace -dnc -rm "asMotion"`))
		{ 
		//Maya2012 and older dont have namespace -dnc, so we work around the problems of empty nameSpaces not agknowlowdge their empty
		for($i=0;$i<99;$i++)
			if (!`namespace -ex ("tempNameSpace"+$i)`)
				break;
		namespace -ren asMotion ("tempNameSpace"+$i);
		}
if (`namespace -ex "asMotion"`)
	error "Unable to remove namespace \"asMotion\", try restarting Maya";

file -ns "asMotion" -i $motionFile;
setAttr asMotion:Group.v 0;
setAttr -type float3 asMotion:Group.s ($charHeight/12.0) ($charHeight/12.0) ($charHeight/12.0);

createNode -n WalkDesignerMotionMixer transform;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.tx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ty;setAttr -l 1 -k 0 WalkDesignerMotionMixer.tz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.rx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.ry;setAttr -l 1 -k 0 WalkDesignerMotionMixer.rz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.sx;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sy;setAttr -l 1 -k 0 WalkDesignerMotionMixer.sz;
setAttr -l 1 -k 0 WalkDesignerMotionMixer.v;
addAttr -k 1 -ln "speed" -dv 1 -at double WalkDesignerMotionMixer;
addAttr -k 0 -ln defaultEndTime -at double WalkDesignerMotionMixer;
parent "asMotion:Group" WalkDesignerMotionMixer;

select -hi "asMotion:Group";
select -d "asMotion:Group";
if (!`asIsMayaLT`)
	{
	character -name walkDesignerSet -excludeVisibility -excludeScale;
	clip -name walkDesignerClip -sc 1 -allAbsolute -animCurveRange walkDesignerSet;
	setAttr walkDesignerClip.postCycle 9999;
	}

if (`objExists ($nameSpace+"FKIKLeg_R")`) setAttr ($nameSpace+"FKIKLeg_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKLeg_L")`) setAttr ($nameSpace+"FKIKLeg_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_R")`) setAttr ($nameSpace+"FKIKArm_R.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKArm_L")`) setAttr ($nameSpace+"FKIKArm_L.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKIKSpine_M")`) setAttr ($nameSpace+"FKIKSpine_M.FKIKBlend") 0;
if (`objExists ($nameSpace+"FKShoulder_R")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_R")`) setAttr ($nameSpace+"FKShoulder_R.Global") 0;
if (`objExists ($nameSpace+"FKShoulder_L")`) if (`attributeExists "Global"  ($nameSpace+"FKShoulder_L")`) setAttr ($nameSpace+"FKShoulder_L.Global") 0;
if (`objExists ($nameSpace+"FKWrist_R")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_R")`) setAttr ($nameSpace+"FKWrist_R.Global") 0;
if (`objExists ($nameSpace+"FKWrist_L")`) if (`attributeExists "Global"  ($nameSpace+"FKWrist_L")`) setAttr ($nameSpace+"FKWrist_L.Global") 0;
if (`objExists ($nameSpace+"FKHead_M")`) if (`attributeExists "Global"  ($nameSpace+"FKHead_M")`) setAttr ($nameSpace+"FKHead_M.Global") 0;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
string $orientConstraint,$pointConstraint;

for($i=0;$i<size($motions);$i++)
	{
	addAttr -k 1 -ln $motions[$i] -at double WalkDesignerMotionMixer;
	for($y=0;$y<size($consts);$y++)
		{
		$fkControl=$nameSpace+"FK"+$consts[$y];
		if ($consts[$y]=="Root_M")
			{
			$fkControl=$nameSpace+"RootX_M";
			$tempString=`pointConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
			$pointConstraint=$tempString[0];
			}
		if (!`objExists $fkControl`)
			continue;
		$tempString=`orientConstraint ("asMotion:"+$motions[$i]+":"+$consts[$y]) $fkControl`;
		$orientConstraint=$tempString[0];
		setAttr ($orientConstraint+".interpType") 2;

		if ($consts[$y]=="Root_M")
			{
			setAttr RootX_M_orientConstraint1.offsetX -90;
			setAttr RootX_M_orientConstraint1.offsetY -90;
			connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($pointConstraint+"."+$consts[$y]+"W"+$i);
			}
		connectAttr ("WalkDesignerMotionMixer."+$motions[$i]) ($orientConstraint+"."+$consts[$y]+"W"+$i);
		}
	connectControl ("asWDField"+$i) ("WalkDesignerMotionMixer."+$motions[$i]);
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  $side="_R";
	if ($b==-1) $side="_L";
	setAttr ("FKHip"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKKnee"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKAnkle"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKToes"+$side+"_orientConstraint1.offsetX") 180;
	setAttr ("FKShoulder"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKElbow"+$side+"_orientConstraint1.offsetX") -90;
	setAttr ("FKWrist"+$side+"_orientConstraint1.offsetX") -90;
	}

connectControl asWDSpeedField WalkDesignerMotionMixer.speed;

if (`attributeExists walk_male WalkDesignerMotionMixer`)
	setAttr WalkDesignerMotionMixer.walk_male 1;
currentTime 0;
if (`objExists ($nameSpace+"FKAnkle_R")` && `objExists ($nameSpace+"Ankle")`)
	{
	float $anklePos[3]=`xform -q -ws -t ($nameSpace+"FKAnkle_R")`;
	float $fitAnklePos[3]=`xform -q -ws -t ($nameSpace+"Ankle")`;
	float $offset=$anklePos[1]-$fitAnklePos[1];
	setAttr asMotion:Group.ty ($offset*-1);
	}
float $tempFloats[]=`keyframe -index 1 -q  -tc asMotion:Group.timing`;
float $endTime=$tempFloats[0];
playbackOptions -min 0 -ast 0 -aet $endTime -max $endTime;
setAttr WalkDesignerMotionMixer.defaultEndTime $endTime;
select -cl;
}

global proc asWDSolo (int $num)
{
if (!`objExists WalkDesignerMotionMixer`)
	error ("WalkDesignerMotionMixer not found");
float $value;
string $motions[]={"run_female","run_male","walk_angry","walk_cool","walk_cute","walk_female","walk_macho","walk_male","walk_proud","walk_sad","walk_sneak"};
for($i=0;$i<size($motions);$i++)
	{
	if ($i==$num)
		$value=1;
	else
		$value=0;
	floatSliderGrp -e -v $value ("asWDField"+$i);
	setAttr ("WalkDesignerMotionMixer."+$motions[$i]) $value;
	}
}

global proc asWDFinish ()
{
string $nameSpace=`optionMenu -q -v asWalkDesignerOptionMenu`;
if ($nameSpace==":")
	$nameSpace="";

if (`objExists walkDesignerSet`)
	delete walkDesignerSet;
if (`objExists WalkDesignerMotionMixer`)
	delete WalkDesignerMotionMixer;

string $consts[]={"Root_M","Spine1_M","Spine2_M","Chest_M","Chest_M","Chest_M","Chest_M","Neck_M","Head_M",
									"Shoulder_R","Elbow_R","Wrist_R","Hip_R","Knee_R","Ankle_R","Toes_R",
									"Shoulder_L","Elbow_L","Wrist_L","Hip_L","Knee_L","Ankle_L","Toes_L"};
string $tempString[];
string $attrs[]={"tx","ty","tz","rx","ry","rz"};
for($y=0;$y<size($consts);$y++)
	{
	$fkControl=$nameSpace+"FK"+$consts[$y];
	if ($consts[$y]=="Root_M")
		$fkControl=$nameSpace+"RootX_M";
	if (!`objExists $fkControl`)
		continue;
	for($i=0;$i<size($attrs);$i++)
		{
		$tempString=`listConnections ($fkControl+"."+$attrs[$i])`;
		if (!size($tempString))
			setAttr ($fkControl+"."+$attrs[$i]) 0;
		}
	}
deleteUI asWalkDesigner;
}
//-- ASWalkDesigner Procedures Ends Here --//
//-- ASModelCleaner Procedures Starts Here --//
global proc asModelCleaner ()
{
if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

window -s 1 -title "Model Cleaner" modelCleaner;
columnLayout;
	separator -st none -h 10;
	text -l "This will cleanup your model.\n";
	if (!`pluginInfo -q -l objExport`)
		{
		text -l "The objExport plugin must be loaded:";
		button -l "load objExport plugin" -c "loadPlugin objExport;print (\"// OK, objExport plugin loaded\\n\")";
		separator -h 10 -st none;
		}
	text -l "Create top level group, called \"geo\":";
	button -c modelCleanGreateGeo -label "Create";
	separator -st none -h 10;
	text -l "Now ready for Clean.";
	text -fn "smallBoldLabelFont" -l "(Save your scene first, for safe keeping)\n";
	button -w 230 -c modelCleanGo -ann "clean model" -label "Clean";
showWindow modelCleaner;
}

global proc modelCleanGreateGeo ()
{
if (!`objExists |geo`)
	createNode -n geo transform;
string $tempString[];
string $topLevXforms[]=`ls -as -l`;
for($i=0;$i<size($topLevXforms);$i++)
	{
	if ($topLevXforms[$i]=="|geo")
		continue;
	$tempString=`listRelatives -s $topLevXforms[$i]`;
	if (`size ($tempString)`==0 || `objectType $tempString[0]`=="mesh")
		parent $topLevXforms[$i] |geo;
	}
select |geo;
}

global proc modelCleanGo ()
{
global string $gMainProgressBar;
global string $gMainPane;
string $sceneName=`file -q -sn`;
string $references[];
string $allReferences[]=`file -q -r`;
for ($i=0;$i<size($allReferences);$i++)
	if (!`file -q -deferReference $allReferences[$i]`)
		$references[size($references)]=$allReferences[$i];

select -cl;

string $sceneFile=`file -q -sn`;
string $tmpFile=`asGetTempDirectory`+"AdvancedSkeleton/modelCleaner/tmp.ma";
if (`asIsMayaLT`)
	$tmpFile=`asGetTempDirectory`+"AdvancedSkeleton/modelCleaner/tmp.mlt";
int $eyeCandy=0;
int $moreThanOneWithSameName;
string $plugins[]=`pluginInfo -q -ls`;
string $parent[],$tempString[],$longNames[],$buffer[],$oldShapeName[],$partitionPlugs[],$creaseMembers[],$objFileName[];
float $temp[];
float $perspPos[]=`getAttr persp.translate`;
float $perspRot[]=`getAttr persp.rotate`;
int $isGroup[];
int $doubleSided[];
for ($plug in $plugins)
	if (!`stringArrayCount "objExport" $plugins`)
	error "You Must Load the \"objExport\" plugin !";

string $tempDir=`asGetTempDirectory`+"AdvancedSkeleton/modelCleaner/";
if (!`file -q -ex $tempDir`)
	sysFile -md $tempDir;

//Pre Flight Check
if (!`objExists geo`)
	error "group \"geo\" does not exists !\n";
string $all[]=`ls -noIntermediate`;
for ($obj in $all)
	{
	if (`gmatch $obj "*|*"`)
		{
		$tempString=`listRelatives -ap $obj`;
		if (size($tempString)==1)
			{
			select -add $obj;
			$moreThanOneWithSameName=1;
			}
		}
	}
if ($moreThanOneWithSameName)
	modelCleanMakeUniqueNames;
if (`objExists "polySurface1"`)
	{
	select "polySurface1";
	error "Illegal objectName \"polySurface1\"";
	}

//delete imagePlanes
string $imagePlanes[]=`ls -type imagePlane`;
if (size($imagePlanes))
	delete $imagePlanes;

//delete unused refNodes
deleteUnusedRefNodes;

//unParent all place3dTextures
string $place3ds[]=`ls -type place3dTexture`;
for ($i=0;$i<size($place3ds);$i++)
{
$tempString=`listRelatives -p $place3ds[$i]`;
if(size($tempString))
	parent -w $place3ds[$i];
}

//remove old files
string $fileList[]=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size( $fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Remove nameSpaces
$all=`ls -type transform`;
for ($i=0;$i<size($all);$i++)
    if (`gmatch $all[$i] "*:*"`)
        {
        tokenize $all[$i] ":" $tempString;
        rename $all[$i] $tempString[size($tempString)-1];
        }

//rename Shapes to match name of their Xform
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
    	$tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"TEMPShape");
    	}
$meshes=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
    if (`objExists $meshes[$i]`)
    	{
	    $tempString=`listRelatives -p $meshes[$i]`;
    	rename $meshes[$i] ($tempString[0]+"Shape");
    	}

DeleteAllHistory;

//createShaderAssigner
string $assigned[], $shadingEngines[], $namespaces[];
string $allTrns[]=`ls -type transform`;
string $place3dTextures[]=`ls -type place3dTexture`;
if (`objExists shaderAssign`) 
	delete shaderAssign;
createNode -n shaderAssign transform;
addAttr -ln notes -dt "string" shaderAssign;
$shadingEngines=`ls -type shadingEngine`;
string $connections = ("global proc cleanConnectFileNodes(string $namespace1, string $namespace2) {\n");
for ($i=0;$i<size($shadingEngines);$i++) {
	if (`gmatch $shadingEngines[$i] "initial*"`)
		continue;
	$assigned=`sets -q $shadingEngines[$i]`;
	for ($z=0;$z<size($assigned);$z++)
		{
		//per face assigment
//		tokenize $assigned[$z] "." $tempString;
//		$assigned[$z]=$tempString[0];
		}
	$assigned=`stringArrayRemoveDuplicates $assigned`;
	for ($z=0;$z<size($assigned);$z++) 
		{
//		$tempString=`listRelatives -p $assigned[$z]`;
//		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$tempString[0]+"\")`);\n");
		$connections+=("catch(`sets -e -fe ($namespace1 + \"" +$shadingEngines[$i]+"\") ($namespace2 + \""+$assigned[$z]+"\")`);\n");
		}
}
for ($z=0;$z<size($place3dTextures);$z++) {
	$tempString=`listConnections -p 1 ($place3dTextures[$z]+".worldInverseMatrix")`;
	$connections+=("catch(`connectAttr ($namespace2 + \"" +$place3dTextures[$z]+".worldInverseMatrix\") ($namespace1 + \""+$tempString[0]+"\")`);\n");
}
$connections += ("}\n");
setAttr -type "string" shaderAssign.notes $connections;

//exportShaders
string $hyperShadePanelMelFile="C:/Program Files/Autodesk/Maya2012/scripts/others/hyperShadePanel.mel";
if (`file -q -ex$hyperShadePanelMelFile `)
eval ("source \""+$hyperShadePanelMelFile+"\"");
hyperShadePanelMenuCommand("", "deleteUnusedNodes");
string $shadingNodes[]=`lsThroughFilter -na DefaultAllShadingNodesFilter`;
string $objectType;
select -cl;
for ($i=0;$i<size($shadingNodes);$i++)
	{
	$objectType=`objectType $shadingNodes[$i]`;
	if ($objectType=="camera" || `gmatch $objectType "*Light"`)
		continue;
	select -add -ne $shadingNodes[$i];
	}
select -add shaderAssign;
lockNode -l 0 renderPartition;
if (`file -q -ex $tmpFile`)
	sysFile -del $tmpFile;
if (`asIsMayaLT`)
	file -op "v=0;" -typ "mayaLT" -es $tmpFile;
else
	file -op "v=0;p=17" -typ "mayaAscii" -es $tmpFile;

//delete intermediateObjects meshes
$tempString=`ls -intermediateObjects -type mesh`;
if (size($tempString))
	delete $tempString;

// SelectAllPolygonGeometry;
select geo;
select -hi;
string $selAll[]=`ls -l -sl -type transform`;

// read all attribute + their values, to restore after obj import
 string $userAttrs[],$addAttrCmds[];
string $cmd,$sn,$ln,$at,$kk,$dv,$minMax;
float $range[2];
string $shapes[];
string $selAllInclShapes[]=$selAll;
for ($i=0;$i<size($selAll);$i++)
	{
	$tempString=`listRelatives -s $selAll[$i]`;
	if (`objExists $tempString[0]`)
		$shapes[`size($shapes)`]=$tempString[0];
	}
appendStringArray $selAllInclShapes $shapes `size($shapes)`;
for ($i=0;$i<size($selAllInclShapes);$i++)
	{
 	$userAttrs=`listAttr -ud -s $selAllInclShapes[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		if (`getAttr -type ($selAllInclShapes[$i]+"."+$userAttrs[$y])`=="message")
			continue;
		$tempString=`listAttr -sn ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if (`gmatch $at "*Array"` || `gmatch $at "*dataCompound"`)
			continue;
		$dv=`getAttr ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$kk=`getAttr -k ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		$l=`getAttr -l ($selAllInclShapes[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		$minMax="";
		if (`attributeQuery -re -n $selAllInclShapes[$i] $ln`)
			{
			$range=`attributeQuery -r -n $selAllInclShapes[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		if ($at=="string")
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -dt \""+$at+"\" "+$minMax+" "+$selAllInclShapes[$i]+";"
					+"setAttr -l "+$l+" -type \"string\" "+$selAllInclShapes[$i]+"."+$sn+" \""+`encodeString $dv`+"\";";
		else
			$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$selAllInclShapes[$i]+"`)"
					+"	addAttr -k "+$kk+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$selAllInclShapes[$i]+";";
		}
	}

// read smooth level
$shapes=`ls -ni -type mesh`;
for ($y=0;$y<size($shapes);$y++)
	{
	if (!`attributeExists "displaySmoothMesh" $shapes[$y]`)
		continue;
	if (!`getAttr -l ($shapes[$y]+".displaySmoothMesh")`)
		continue;
	$smoothLevel=`getAttr ($shapes[$y]+".smoothLevel")`;
	$smoothLock=`getAttr -l ($shapes[$y]+".smoothLevel")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$smoothLock+" "+$shapes[$y]+".smoothLevel "+$smoothLevel+";";
	$dispResolution=`getAttr ($shapes[$y]+".dispResolution")`;
	$displaySmoothMesh=`getAttr ($shapes[$y]+".displaySmoothMesh")`;
	$displaySmoothMeshLock=`getAttr -l ($shapes[$y]+".displaySmoothMesh")`;
	$addAttrCmds[size($addAttrCmds)]="setAttr "+$shapes[$y]+".dispResolution "+$dispResolution+";";
	$addAttrCmds[size($addAttrCmds)]="setAttr -l "+$displaySmoothMeshLock+" "+$shapes[$y]+".displaySmoothMesh "+$displaySmoothMesh+";";
	}

// select non-instanced geometry
select geo;
select -hi;
string $sel[]=`ls -sl -type transform`;
string $selLong[]=`ls -l -sl -type transform`;
string $selShort[]=$sel;
string $children[];

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "ObjExporting" -bp -ii 1 -min 0 -max (size($sel)) $gMainProgressBar;
for ($i=0;$i<size($sel);$i++)
{
	if (`progressBar -q -ic $gMainProgressBar`)
	{
		break;progressBar -e -ep $gMainProgressBar;
	}
	progressBar -e -s 1 $gMainProgressBar;

	if (`gmatch $obj "*:*"`)
		continue;

	if (`gmatch $selShort[$i] "*|*"`)
		{
		tokenize $selShort[$i] "|" $tempString;
		$selShort[$i]=$tempString[size($tempString)-1];
		}
	select $sel[$i];
	$tempString=`listRelatives -s $sel[$i]`;
	$oldShapeName[$i]=$tempString[0];
	makeIdentity -a 1 -t 1 -r 1 -s 1 $sel[$i];
//		polySetToFaceNormal -setUserNormal;
	DeleteAllHistory;
	if (size(`ls -type nurbsCurve`))
		delete `ls -type nurbsCurve`;
	$tempString=`listRelatives -f -s $sel[$i]`;
	if (size($tempString)==0)
		$isGroup[$i]=1;
	$doubleSided[$i]=1;
	if (`objExists $tempString[0]`)
		if (`attributeExists doubleSided $tempString[0]`)
			$doubleSided[$i]=`getAttr ($tempString[0]+".doubleSided")`;
	$tempString=`listRelatives -p $sel[$i]`;
	if ($tempString[0]!="")
		$parent[$i]=$tempString[0];

	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		sysFile -del ($tempDir+$sel[$i]+".obj");
	if (`file -q -ex ($tempDir+$sel[$i]+".obj")`)
		print ("// Unable to delete "+$tempDir+$sel[$i]+".obj!\n");
	clear $children;
	$children=`listRelatives -f -type transform -c $sel[$i]`;
	if (size($children))
		$children=`parent -w $children`;
	select $sel[$i];
	$objFileName[$i]=`substituteAllString $selLong[$i] "|" "!"`;
	if (`gmatch $objFileName[$i] "!*"`)
		$objFileName[$i]=`substring $objFileName[$i] 2 999`;
	print ("// Exporting: "+$tempDir+$objFileName[$i]+".obj\n");
//		if ($eyeCandy)
//			FrameSelected;
	file -op "groups=0;ptgroups=0;materials=0;smoothing=1;normals=1;" -typ "OBJexport" -pr -es ($tempDir+$objFileName[$i]+".obj");
	if (size($children))
		parent $children $sel[$i];
}
progressBar -e -ep $gMainProgressBar;

//NewScene;
// select -all;delete;
string $filename = `file -q -exn`;
$mayaFileType = `file -q -type`;
file -f -new;
file -type $mayaFileType;
file -rn $filename;
setAttr -type float3 persp.translate $perspPos[0] $perspPos[1] $perspPos[2];
setAttr -type float3 persp.rotate $perspRot[0] $perspRot[1] $perspRot[2];
if ($eyeCandy)
	{
	setNamedPanelLayout "Single Perspective View";
	string $modelPanel=`paneLayout -q -p1 $gMainPane`;
	modelEditor -e -da "smoothShaded" $modelPanel;
	}

//Create groups
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		createNode -n $sel[$i] transform;
}
for ($i=0;$i<size($sel);$i++)
{
	if ($isGroup[$i])
		{
		if (`objExists $parent[$i]`)
			parent $sel[$i] $parent[$i];
		continue;
		}
print ("// importing: "+$tempDir+$objFileName[$i]+".obj\n");
file -i -type "OBJ" -rpr "DUP" -options "mo=0;lo=1" ($tempDir+$objFileName[$i]+".obj");
$existing[0]="polySurfaceShape1";
$tempString=`listRelatives -p $existing[0]`;
rename $tempString[0] $selShort[$i];

if (`objExists $parent[$i]`)
	parent ("|"+$selShort[$i]) $parent[$i];
if (!$doubleSided[$i])
	setAttr ($sel[$i]+".doubleSided") $doubleSided[$i];
select $sel[$i];
if ($eyeCandy)
	FrameSelected;

// restore original shape name
if (`objExists $sel[$i]`)
	{
	$tempString=`listRelatives -s $sel[$i]`;
	if (`objExists $tempString[0]`)
		{
		setAttr ($tempString[0]+".visibleInReflections") 1;
		setAttr ($tempString[0]+".visibleInRefractions") 1;
		if ($tempString[0]!=$oldShapeName[$i])
			{
			print ("// Renaming "+$tempString[0]+" to "+$oldShapeName[$i]+"\n");
			rename $tempString[0] $oldShapeName[$i];
			}
		}
	}
}

// restore added attributes
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

// restore bits in sets
if (`gmatch $sceneName "*/library/set/*"`)
	file -import -type "mayaAscii" -ra false -rpr "export" -options "v=0"  -pr -loadReferenceDepth "all" ($tempDir+"setReferences.ma");

//remove files
$fileList=`getFileList -fs "*.obj" -fld $tempDir`;
for($i=0;$i<size($fileList);$i++)
{
	if (`file -q -ex ($tempDir+$fileList[$i])`)
		sysFile -del ($tempDir+$fileList[$i]);
}

//Import & Assign texturess
file -i $tmpFile;
eval `getAttr shaderAssign.notes`;
cleanConnectFileNodes "" "";
delete shaderAssign;

//set default UI
select -cl;
setNamedPanelLayout "Four View";
FrameAllInAllViews;

if (`window -ex modelCleaner`)
	deleteUI modelCleaner;

print ("// Cleaning finished.\n");
}


global proc deleteUnusedRefNodes ()
{
string $allReferences[]=`file -q -r`;

string $realRefNodes[];
for ($y=0;$y<size($allReferences);$y++)
    $realRefNodes[size($realRefNodes)]=`file -q -rfn $allReferences`;
string $refNodes[]=`ls -type reference`;
for ($y=0;$y<size($refNodes);$y++)
    if (!`stringArrayCount $refNodes[$y] $realRefNodes`)
        {
        lockNode -l 0 $refNodes[$y];
        delete $refNodes[$y];
        }
}

global proc modelCleanMakeUniqueNames ()
{
SelectAllGeometry;
string $alls[]=`ls -sl`;
string $alls2[],$tempString[];
string $suffix;
int $clash;
for ($i=0;$i<size($alls);$i++)
    {
    $break=0;
    SelectAllGeometry;
    select -d $alls[$i];
    $alls2=`ls -sl -sn`;
    $suffix="";
    $clash=0;
    tokenize $alls[$i] "|" $tempString;
    $newName=$tempString[size($tempString)-1]+$suffix;
    for ($z=0;$z<size($alls2);$z++)
        {
        tokenize $alls2[$z] "|" $tempString;
        if ($newName==$tempString[size($tempString)-1])
            {
            for ($aa=0;$aa<999;$aa++)
            if (!`objExists ($newName+$aa)`)
                {
                print("// rename "+$alls[$i]+" "+$alls[$i]+"1\n");                
                rename $alls[$i] ($newName+$aa);
                $break=1;
                break;         
                }
            if ($break)
                break;
            }
        if ($break)
            break;
        }
    }
}
//-- ASModelCleaner Procedures Ends Here --//
//-- ASFace Procedures Starts Here --//
global proc asCreateFaceFitSkeleton ()
{
if (`objExists FaceGroup`)
	if (`confirmDialog -t "Confirm"
	-m "FaceFitSkeleton already exists, this will reset the FaceFitSkeleton"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`!="OK")
		return;
if (`objExists FaceGroup`)
	delete FaceGroup;
createNode -n FaceGroup transform;
setAttr -l 1 FaceGroup.inheritsTransform 0;
if (`objExists "|Group"`)
	parent FaceGroup "|Group";
if (`objExists FaceFitSkeleton`)
	delete FaceFitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FaceFitSkeleton;
parent FaceFitSkeleton FaceGroup;
setAttr FaceFitSkeletonShape.overrideEnabled 1;
setAttr FaceFitSkeletonShape.overrideColor 13;
scale -r -p 0 0 0 0.5 0.5 0.5 FaceFitSkeleton.cv[0:7];
duplicate -n FaceFitSkeletonHeight FaceFitSkeleton;
parent FaceFitSkeletonHeight FaceFitSkeleton;
parent -add -s FaceFitSkeletonHeightShape FaceFitSkeleton;
delete FaceFitSkeletonHeight;
move -r 0 1.5 0 FaceFitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FaceFitSkeleton.tx;setAttr -k 1 -l 0 FaceFitSkeleton.ty 8;setAttr -k 0 -l 1 FaceFitSkeleton.tz;
setAttr -k 0 -l 1 FaceFitSkeleton.rx;setAttr -k 0 -l 1 FaceFitSkeleton.ry 0;setAttr -k 0 -l 1 FaceFitSkeleton.rz;
setAttr -k 0 FaceFitSkeleton.sx;setAttr -k 0 FaceFitSkeleton.rz;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sx;
connectAttr FaceFitSkeleton.sy FaceFitSkeleton.sz;
if (`objExists Head_M` && `objExists Neck_M`)
	{
	float $temp1[]=`xform -q -ws -t Head_M`;
	float $temp2[]=`xform -q -ws -t Neck_M`;
	setAttr FaceFitSkeleton.ty (($temp1[1]+$temp2[1])/2.0);
	}
if (`objExists Main`)
	if (`attributeExists height Main`)
		setAttr FaceFitSkeleton.sy (`getAttr Main.height`/5.0);

asFaceEnsureFitBase;
select FaceFitSkeleton;
}

global proc asFaceFitJawCurves ()
{
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`+1;
float $pos[],$posA[],$posB[],$posC[];
float $scale=`asFaceGetScale`;
string $curveCmd;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

createNode -n FaceFitJawCurves -p FaceFitSkeleton transform;

//create Jaw weight-curves : JawCurve
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t Jaw`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurve;
setAttr JawCurveShape.overrideEnabled 1;
setAttr JawCurveShape.overrideColor 14;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 3 -d 3 -tol 0.01 JawCurve;
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t JawCurve.cv[1]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[1];
$posA=`xform -q -ws -t Cheek`;
$posB=`xform -q -ws -t JawCurve.cv[3]`;
xform -ws -t $posA[0] $posB[1] $posA[2] JawCurve.cv[3];
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawCurve.cv[4]`;
xform -ws -t $posB[0] $posB[1] $posA[2] JawCurve.cv[4];
asCurveOffsetMesh JawCurve $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurve50
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t Cheek`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveMid;
setAttr JawCurveMidShape.overrideEnabled 1;
setAttr JawCurveMidShape.overrideColor 13;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 JawCurveMid;

asCurveOffsetMesh JawCurveMid $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveTop
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t NoseCorner`;
$posC=`xform -q -ws -t Cheek`;
$posD=`xform -q -ws -t CheekBone`;
$curveCmd+=" -p "+(($posA[0]+$posC[0])/2.0)+" "+(($posA[1]+$posD[1])/2.0)+" "+(($posA[2]+$posC[2])/2.0)+" ";
$posA=`xform -q -ws -t CheekRaiser`;
$curveCmd+=" -p "+$posD[0]+" "+$posD[1]+" "+$posD[2]+" ";
$pos=`xform -q -ws -t NoseCorner`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t NoseUnder`;
$curveCmd+=" -p 0 "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveTop;
setAttr JawCurveTopShape.overrideEnabled 1;
setAttr JawCurveTopShape.overrideColor 6;
asCurveOffsetMesh JawCurveTop $geometry ($scale/150.0);

//create Jaw weight-curves : JawCurveBottom
$curveCmd="curve -d 1 ";
$pos=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$pos=`xform -q -ws -t JawCurve.cv[1]`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+($pos[2]-($scale/20.0))+" ";
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t JawPivot`;
$curveCmd+=" -p "+$posB[0]+" "+$posA[1]+" "+($pos[2]-($scale/20.0))+" ";
$pos=`xform -q -ws -t Throat`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" ";
$tempString[0]=`eval ($curveCmd)`;
rename $tempString[0] JawCurveBottom;
setAttr JawCurveBottomShape.overrideEnabled 1;
setAttr JawCurveBottomShape.overrideColor 6;
asCurveOffsetMesh JawCurveBottom $geometry ($scale/150.0);

parent JawCurve JawCurveMid JawCurveTop JawCurveBottom FaceFitJawCurves;

if (`checkBox -q -ex asFaceFitJawCurves`)
	checkBox -e -ed 1 -v 1 asFaceFitJawCurves;
select -cl;
}

global proc asFaceDesignMouthOpen ()
{
int $lowerLipMainNumCVs=`getAttr lowerLipMainCurve.spans`+1;
float $scale=`asFaceGetScale`;
float $lipCnrPercentage;
float $posA[]=`xform -q -ws -t lowerLipMainCurve.cv[0]`;
float $posB[]=`xform -q -ws -t lowerLipMainCurve.cv[$lowerLipMainNumCVs]`;
float $posC[],$posD[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $topVtx,$cnrVtx;
string $tempString[];

createNode -n LipDeformations -p FaceBuildInProgress transform;
duplicate -n LipDeform templateLayer;
//setAttr LipDeform.v 1;
sets -e -forceElement initialShadingGroup LipDeform;
//setAttr LipDeform.tx $posA[0];

select -r LipDeform;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
rename $tempString[0] mouthOpenSoftMod;
rename $tempString[1] mouthOpenSoftModHandle;
$tempString=`listConnections mouthOpenSoftMod.message`;
rename $tempString[0] mouthOpenSoftModSet;
setAttr -type float3 mouthOpenSoftModHandleShape.origin $posA[0] $posA[1] $posA[2];
setAttr mouthOpenSoftMod.falloffCenter $posA[0] $posA[1] $posA[2];
xform -piv $posA[0] $posA[1] $posA[2] mouthOpenSoftModHandle;
setAttr mouthOpenSoftMod.falloffMode 1;
setAttr mouthOpenSoftMod.falloffRadius ((0-$posB[0])*2);

//topVtx pos before move softMod
createNode -n closestSampler2 closestPointOnMesh;
connectAttr -f LipDeform.outMesh closestSampler2.inMesh;
$posA=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
setAttr -type float3 closestSampler2.inPosition $posA[0] $posA[1] $posA[2];
$topVtx="LipDeform.vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]";
$posA=`xform -q -ws -t $topVtx`;
setAttr -type float3 closestSampler2.inPosition $posB[0] $posB[1] $posB[2];
$cnrVtx="LipDeform.vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]";
$posC=`xform -q -ws -t $cnrVtx`;
delete closestSampler2;

setAttr mouthOpenSoftModHandle.ty ($scale/-10.0);
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 1;

//increase radius, until topVtx is included
setAttr mouthOpenSoftMod.falloffRadius 0;
$posA=`xform -q -ws -t $topVtx`;
float $radius=(0-$posB[0])*2;
setAttr mouthOpenSoftMod.falloffRadius $radius;
for ($i=0;$i<99;$i++)
	{
	$posB=`xform -q -ws -t $topVtx`;
	if ($posB[1]-$posA[1]!=0)
		break;
	$radius+=($scale/1000.0)*$i;
	setAttr mouthOpenSoftMod.falloffRadius $radius;
	}
setAttr "mouthOpenSoftMod.falloffCurve[1].falloffCurve_FloatValue" 0.05;
setAttr "mouthOpenSoftMod.falloffCurve[0].falloffCurve_FloatValue" 0.95;

//Determine % at which the lipCnr is at (as this might not be excatly at 50%)
$posD=`xform -q -ws -t $cnrVtx`;
$lipCnrPercentage=1.0-(($posC[1]-$posD[1])/($scale/10.0));

setAttr "mouthOpenSoftMod.falloffCurve[2].falloffCurve_Position" $lipCnrPercentage;
setAttr "mouthOpenSoftMod.falloffCurve[2].falloffCurve_FloatValue" 0.5;

//updated for rounder shape
setAttr "mouthOpenSoftMod.falloffCurve[3].falloffCurve_Position" ($lipCnrPercentage-0.15);
setAttr "mouthOpenSoftMod.falloffCurve[3].falloffCurve_FloatValue" 0.8;

setAttr "mouthOpenSoftMod.falloffCurve[4].falloffCurve_Position" ($lipCnrPercentage+0.15);
setAttr "mouthOpenSoftMod.falloffCurve[4].falloffCurve_FloatValue" 0.2;

for ($i=0;$i<5;$i++)
	setAttr ("mouthOpenSoftMod.falloffCurve["+$i+"].falloffCurve_Interp") 3;

//Delete `all-except-lips` from LipDeform
select lipArea;
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString LipDeform`;
$tempString=`ls -sl -fl`;
ConvertSelectionToContainedFaces;
//InvertSelection;
asInvertSelection;
delete;

setAttr mouthOpenSoftModHandle.ty 0;
parentConstraint -mo Jaw_M mouthOpenSoftModHandle;
scaleConstraint -mo Jaw_M mouthOpenSoftModHandle;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;

setKeyframe -v 0 -t 0 ctrlMouth_M.ty;setKeyframe -v -1 -t 30 ctrlMouth_M.ty;

setKeyframe -v 0 -t 0 Jaw_M.ty;setKeyframe -v -0.5 -t 30 Jaw_M.ty;
setKeyframe -v 0 -t 0 Jaw_M.tz;setKeyframe -v 0.5 -t 30 Jaw_M.tz;
setKeyframe -v 0 -t 0 Jaw_M.rx;setKeyframe -v 15 -t 30 Jaw_M.rx;

setKeyframe -v 1 -t 0 Jaw_M.sx;setKeyframe -v 1 -t 0 Jaw_M.sx;
setKeyframe -v 1 -t 0 Jaw_M.sy;setKeyframe -v 1 -t 0 Jaw_M.sy;
setKeyframe -v 1 -t 0 Jaw_M.sz;setKeyframe -v 1 -t 0 Jaw_M.sz;

setAttr -l 1 Jaw_M.tx;
setAttr -l 1 Jaw_M.ry;
setAttr -l 1 Jaw_M.rz;
}

global proc asFaceAssist (string $section)
{
int $spans,$degree,$numCVs;
float $scale=`asFaceGetScale`;
float $posA[],$posB[];
string $tempString[];
string $leftSuffix;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $part="Main";
if ($section=="Lip") $part="Outer";
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSym`=="Left")
		$leftSuffix="Left";

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$spans=`getAttr ($upperLower+$section+$part+"Curve.spans")`;
	$degree=`getAttr ($upperLower+$section+$part+"Curve.degree")`;
	$numCVs=$spans+$degree;
	$middleCvNr=($numCVs-1)/2;
	$posA=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+$middleCvNr+"]")`;
	if ($section=="Lip")
		$posA=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv[0]")`;
	$posB=`xform -q -ws -t ($upperLower+$section+$part+"Curve.cv["+($numCVs-1)+"]")`;
	if ($leftSuffix=="Left")
		{
		$posA[0]=$posA[0]*-1;
		$posB[0]=$posB[0]*-1;
		}
	select -r $geometry;
	$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
	rename $tempString[0] ($upperLower+"TempSoftMod");
	rename $tempString[1] ($upperLower+"TempSoftModHandle");
	setAttr -type float3 ($upperLower+"TempSoftModHandleShape.origin") $posA[0] $posA[1] $posA[2];
	setAttr ($upperLower+"TempSoftMod.falloffCenter") $posA[0] $posA[1] $posA[2];
	xform -piv $posA[0] $posA[1] $posA[2] ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffMode") 1;
	setAttr ($upperLower+"TempSoftMod.falloffRadius") `abs($posA[0]-$posB[0])`;
	move -r 0 ($scale/30.0*$upperLowerFactor) ($scale/10.0) ($upperLower+"TempSoftModHandle");
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_FloatValue") 1;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Position") 0.5;
	setAttr ($upperLower+"TempSoftMod.falloffCurve[3].falloffCurve_Interp") 2;
	}
}

global proc asCreateFaceFit (string $section,string $part,int $upAndLo,int $mainAndOuter,int $isSphere,string $shadingGroup)
{
int $nr,$sideVtxNr,$topVtxNr,$noseVtxNr,$lidInnerVtxNr,$lidOuterVtxNr,$numSel,$previousNumSel,$condition;
int $selCompNrs[];
float $scale=`asFaceGetScale`;
float $dist,$dist2,$maxDist,$minPosX,$maxPosY,$teethColliderScaleFactor,$falloffRadius,$tol,$minPosX,$maxPosY;
float $pos[],$posA[],$posB[],$selPosX[],$selPosY[],$bb[];
string $upperLower,$growStartPos,$areaMeshShader,$closestSampler,$nearestVtx,$leftSuffix;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$borderVtxs[],$edgesLidInnerNose[],$edgesNoseTop[];
string $edgesTopSide[],$edgesSideLidOuter[],$lipStartVtxs[],$selVtxs[],$leftLipSelection[];
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSym`=="Left")
		$leftSuffix="Left";
if (`objExists asRunningFaceLipLeft`)
	$leftSuffix="Left";

if (`objExists ("FaceFit"+$section+$part+$leftSuffix)`)
	error ("FaceFit"+$section+$part+$leftSuffix+" Already Exists");

string $geometry=`textField -q -tx asFaceGeometryTextField`;

if ($section=="Tongue" || $section=="TeethCollider")
	select -cl;

string $sel[]=`ls -sl -fl`;
int $numSelEdges[];
if (!`gmatch $sel[0] "*[.]*"` && $section!="Tongue" && $section!="TeethCollider")
	{
	error "No edge or vertex selected";
	$numSelEdges=`polyEvaluate -edgeComponent`;
	}

if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

int $edgeSelection,$vertexSelection,$startVtxSelected,$endVtxSelected;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*[.]e*"`)
		$edgeSelection=1;
	if (`gmatch $sel[$i] "*[.]vtx*"`)
		{
		$vertexSelection=1;
		if ($startVtxSelected)
			$endVtxSelected=1;
		$startVtxSelected=1;
		}
	}

if ($section=="Jaw" && `objExists FKJaw_M`)
	if (!`asFaceRemoveBodyJaw`)
		return;

if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;

asFitModeEnsureShaders;

spaceLocator -n templateLoc;
setAttr -type float3 templateLocShape.localScale (0.035*$scale) (0.035*$scale) (0.035*$scale);
setAttr templateLocShape.overrideEnabled 1;
setAttr templateLocShape.overrideColor 17;

createNode -n ("FaceFit"+$section+$part+$leftSuffix) -p FaceFitSkeleton transform;
addAttr -k 1 -min 0 -dv 1 -ln radius -at double ("FaceFit"+$section+$part+$leftSuffix);
if ($section=="EyeBrow")
	setAttr ("FaceFit"+$section+$part+$leftSuffix+".radius") 2.5;
createNode -n ("FaceFit"+$section+$part+"Geo"+$leftSuffix) -p ("FaceFit"+$section+$part+$leftSuffix) transform;
if (!$isSphere)
	setAttr ("FaceFit"+$section+$part+"Geo"+$leftSuffix+".inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Curve"+$leftSuffix) -p ("FaceFit"+$section+$part+$leftSuffix) transform;
setAttr ("FaceFit"+$section+$part+"Curve"+$leftSuffix+".inheritsTransform") 0;
createNode -n ("FaceFit"+$section+$part+"Loc"+$leftSuffix) -p ("FaceFit"+$section+$part+$leftSuffix) transform;

if ($isSphere)
	{
	duplicate -n ($section+$leftSuffix) templateLoc;
	parent ($section+$leftSuffix) ("FaceFit"+$section+$part+$leftSuffix);

	sphere -n ($section+"Sphere"+$leftSuffix) -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (0.02*$scale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0;
	parent ($section+"Sphere"+$leftSuffix) ("FaceFit"+$section+$part+$leftSuffix);
	connectAttr ($section+$leftSuffix+".t") ($section+"Sphere"+$leftSuffix+".t");
	connectAttr ($section+$leftSuffix+".r") ($section+"Sphere"+$leftSuffix+".r");
	connectAttr ($section+$leftSuffix+".s") ($section+"Sphere"+$leftSuffix+".s");
	setAttr ($section+"Sphere"+$leftSuffix+"Shape.overrideEnabled") 1;
	setAttr ($section+"Sphere"+$leftSuffix+"Shape.overrideDisplayType") 2;

	addAttr -k 1 -min 0 -dv 1 -ln "falloffRadius" -at double ($section+$leftSuffix);
	addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv 1 ($section+$leftSuffix);
	}

if (`checkBox -q -ex ("asFaceFit"+$section+$part)`)
	checkBox -e -ed 1 -v 1 ("asFaceFit"+$section+$part);

if ($section=="Tongue")
	{
	$pos=`xform -q -ws -t FaceFitSkeleton`;
	$tempString[0]=`curve -d 1 
		-p 0 ($pos[1]+$scale/10.0) 0
		-p 0 ($pos[1]+$scale/5.0) ($scale/5.0)
		-p 0 ($pos[1]+$scale/5.0) ($scale/3.0)
		-p 0 ($pos[1]+$scale/5.5) ($scale/2.5)
		-p 0 ($pos[1]+$scale/7.0) ($scale/2.2)`;
	rename $tempString[0] TongueCurve;
	parent TongueCurve FaceFitTongueCurve;
	setAttr TongueCurve.inheritsTransform 0;
//	setAttr TongueCurveShape.dispCV 1;
	setAttr TongueCurveShape.overrideEnabled 1;
	setAttr TongueCurveShape.overrideColor 13;//Yellow
	for ($i=0;$i<5;$i++)
		{
		duplicate -n ("Tongue"+$i) templateLoc;
		parent ("Tongue"+$i) FaceFitTongueLoc;
		$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i);
		connectAttr -f ("Tongue"+$i+"Shape.worldPosition[0]") ("TongueCurveShape.controlPoints["+$i+"]");
		}
	select -cl;
	for ($i=0;$i<5;$i++)
		select -add ("Tongue"+$i);
	//autoplace
	if ($tongue!="")
		{
		eval ("select "+$tongue);
		$bb=`xform -q -ws -bb $tongue`;
		for ($i=0;$i<5;$i++)
			xform -ws -t 0 (($bb[1]+$bb[4])/2.0) ($bb[2]+((($bb[2]+$bb[5])/6.0)*$i)) ("Tongue"+$i);
		}
	}

delete templateLoc;

//EdgeSelection based placement
if (!$edgeSelection && !$vertexSelection)
	return;

addAttr -ln selection -dt "string" ("FaceFit"+$section+$part+$leftSuffix);
$tempString[0]="";
for ($i=0;$i<size($sel);$i++)
	$tempString[0]=$tempString[0]+$sel[$i]+" ";
setAttr -type "string" ("FaceFit"+$section+$part+$leftSuffix+".selection") $tempString[0];

int $around;
float $minPos[3]={999,999,999};
float $maxPos[3]={-999,-999,-999};
string $minXVtx,$maxXVtx,$minYVtx,$maxYVtx,$minZVtx,$maxZVtx;

if ($isSphere)
	{
	for ($i=0;$i<size($sel);$i++)
		{
		if (!$vertexSelection && `gmatch $sel[$i] "*[.]e*"`)
			{
			select $sel[$i];ConvertSelectionToVertices;$tempString=`ls -sl`;
			$pos=`xform -q -ws -t $tempString[0]`;
			}
		if ($vertexSelection && `gmatch $sel[$i] "*[.]vtx*"`)
			$pos=`xform -q -ws -t $sel[$i]`;
		}
	if ($section=="Nose" || $section=="Jaw" || $section=="NoseUnder" || $section=="Throat")
		$pos[0]=0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($section+$part+$leftSuffix);
	sets -e -forceElement $shadingGroup ($section+"Sphere"+$leftSuffix);
	select -cl;
	return;
	}

select $sel;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;

if ($section=="Lip" && $part=="Outer")//special case, Outer Lip: deselect `lowest half` of vtx, to ensure $maxXVtx not found on lowerLip
	asFaceDeselectLowestHalfOfVtx;

$tol=0.001;
if ($leftSuffix=="Left")
	$tol=9999;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	if ($pos[0]<$minPos[0]) {$minPos[0]=$pos[0];$minXVtx=$tempString[$y];}
	if ($pos[1]<$minPos[1]) {$minPos[1]=$pos[1];$minYVtx=$tempString[$y];}
	if ($pos[2]<$minPos[2]) {$minPos[2]=$pos[2];$minZVtx=$tempString[$y];}
	if ($pos[0]>$maxPos[0] && $pos[0]<$tol) {$maxPos[0]=$pos[0];$maxXVtx=$tempString[$y];}
	if ($pos[1]>$maxPos[1] && $pos[0]<$tol) {$maxPos[1]=$pos[1];$maxYVtx=$tempString[$y];}
	if ($pos[2]>$maxPos[2] && $pos[0]<$tol) {$maxPos[2]=$pos[2];$maxZVtx=$tempString[$y];}
	}

//special case, LipMain, cleanup assist
if (`objExists upperTempSoftModHandle`) delete upperTempSoftModHandle;
if (`objExists lowerTempSoftModHandle`) delete lowerTempSoftModHandle;

string $startVtx=$maxXVtx;
string $endVtx=$minXVtx;
if ($leftSuffix=="Left")
	{
	$startVtx=$minXVtx;
	$endVtx=$maxXVtx;
	}
if (`objExists asRunningFaceLipLeft`)
	{
	$startVtx=`getAttr asRunningFaceLipLeft.startVtx`;
	$endVtx=`getAttr asRunningFaceLipLeft.endVtx`;
	}

//fake a `spesified vtx`, for `Main` & `Inner` & `EyeLidDroopy` to match `Outer`.
$alignWithCurve="upper"+$section+"OuterCurve";
if ($section=="EyeLidDroopy")
	$alignWithCurve="upperEyeLidOuterCurve";
if (($part=="Main" || $part=="Inner" || $section=="EyeLidDroopy") && `objExists $alignWithCurve` && !$startVtxSelected)
	{
	$closestSampler=`createNode -n closestSampler closestPointOnMesh`;
	connectAttr ($geometry+".outMesh") ($closestSampler+".inMesh");
	$posA=`xform -q -ws -t ($alignWithCurve+".cv[0]")`;
	setAttr -type float3 ($closestSampler+".inPosition") $posA[0] $posA[1] $posA[2];
	string $outerStartVtx=$geometry+".vtx["+`getAttr ($closestSampler+".result.closestVertexIndex")`+"]";
	delete $closestSampler;
	float $closestDist=999;//$closestDist is numEdges to reach
	select $sel;
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl -fl`;
	for ($i=0;$i<size($loopVtxs);$i++)
		{
		select $loopVtxs[$i];
		for ($y=0;$y<10;$y++)
			{
			ConvertSelectionToEdges;
			ConvertSelectionToVertices;
			select -d $loopVtxs[$i];
			$tempString=`ls -sl -fl`;
			for ($z=0;$z<size($tempString);$z++)
				{
				if ($tempString[$z]==$outerStartVtx)
					{
					if ($y<$closestDist)
						{
						$startVtx=$loopVtxs[$i];
						$closestDist=$y;
						}
					break;
					}
				}
			}
		}
	select $sel;
	select -add $startVtx;
	$startVtxSelected=1;
	$sel=`ls -sl -fl`;//Update $sel, as if the vtx was selected to start with
	}

//$startVtx(& end) spesified as a vtx selected ( For EyeLid )
if ($section=="EyeLid")
	{
	for ($i=0;$i<size($sel);$i++)
		if (`gmatch $sel[$i] "*[.]vtx*"`)
			{
			if ($startVtx!="" && $endVtxSelected)
				$endVtx=$startVtx;
			if ($startVtxSelected)
				$startVtx=$sel[$i];
			}
	//Ensure start&end are not swapped
	if ($startVtx!="" && $endVtx!="")
		{
		$posA=`xform -q -ws -t $startVtx`;
		$posB=`xform -q -ws -t $endVtx`;
		$condition=0;
		if ($posA[0]<$posB[0]) $condition=1;
		if ($leftSuffix=="Left") $condition=!$condition;
		if ($condition)
			{
			$tempString[0]=$startVtx;
			$startVtx=$endVtx;
			$endVtx=$tempString[0];
			}
		}
	string $vtxs[],$previousVtxs[];
	$around=0;
	if ($startVtx!="")
		{
		//find new $endVtx, by traversing the edge-selection
		select $startVtx;
		for ($y=0;$y<99;$y++)
			{
			ConvertSelectionToEdges;
			$tempString=`ls -sl -fl`;
			for ($z=0;$z<size($tempString);$z++)
				if (!`stringArrayCount $tempString[$z] $sel`)
					select -d $tempString[$z];
			if (size(`ls -sl -fl`)==$numSelEdges[0])
				$around=1;
			
			ConvertSelectionToVertices;
			$vtxs=`ls -sl -fl`;

			if ($around)
				{
				select $vtxs;
				select -d $previousVtxs;
				$tempString=`ls -sl -fl`;
				$endVtx=$tempString[0];
				break;
				}
			$previousVtxs=$vtxs;
			}
		}
	}

// mouth corner spesified as a vtx selected, this ( For Lip )
$minPosX=999;
$maxPosY=-999;
if ($section=="Lip" && !`objExists asRunningFaceLipLeft`)
	{
	for ($i=0;$i<size($sel);$i++)
		if (`gmatch $sel[$i] "*[.]vtx*"` && $sel[$i]!=$startVtx)
			{
			$pos=`xform -q -ws -t $sel[$i]`;
			if ($pos[0]<$minPosX)
				{
				$minPosX=$pos[0];
				$endVtx=$sel[$i];
				}
			$selVtxs[size($selVtxs)]=$sel[$i];
			}
	//Could be `startVtxs` selected, to overRide that start is at scene tx==0
	for ($i=0;$i<size($sel);$i++)
		if (`gmatch $sel[$i] "*[.]vtx*"`)
			if ($sel[$i]!=$endVtx)
				$lipStartVtxs[size($lipStartVtxs)]=$sel[$i];
	}
	//if (3 vtx selected), we assume the MaxY vtx is the $startVtx (2 vtx selected is ignored)
	if (size($lipStartVtxs)==1)
		clear $lipStartVtxs;
	if (size($lipStartVtxs)>1)
		for ($i=0;$i<size($lipStartVtxs);$i++)
			{
			$pos=`xform -q -ws -t $lipStartVtxs[$i]`;
			if ($pos[1]>$maxPosY)
				{
				$maxPosY=$pos[1];
				$startVtx=$lipStartVtxs[$i];
				}
	}

select $startVtx;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
for ($y=0;$y<size($tempString);$y++)
	{
	if (!`stringArrayCount $tempString[$y] $sel`)
		select -d $tempString[$y];
	}
$tempString=`ls -sl -fl`;
string $edge1=$tempString[0];
string $edge2=$tempString[1];

//start leftwards
if ($edge2!="")
	{
	$posA=`xform -q -ws -t $edge1`;
	$posB=`xform -q -ws -t $edge2`;
	$condition=0;
	if (($posA[0]+$posA[3]) > ($posB[0]+$posB[3])) $condition=1;
	if ($leftSuffix=="Left") $condition=!$condition;
	if ($condition)
		{
		$tempString[0]=$edge1;
		$edge1=$edge2;
		$edge2=$tempString[0];
		}
	}

string $prevVtxs[],$vtxs1[],$vtxs2[];

//get $edges1[]
$curveCmd="curve -n faceLoopCurve1 -d 1 ";
$pos=`xform -q -ws -t $startVtx`;
$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
select $startVtx;
$prevVtxs[0]=$startVtx;
$vtxs1[size($vtxs1)]=$startVtx;
string $coveredEdges[];

$around=0;
for ($i=0;$i<199;$i++)
	{
	ConvertSelectionToEdges;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge2)
			select -d $tempString[$y];
		}
	$tempString=`ls -sl -fl`;
	$coveredEdges[size($coveredEdges)]=$tempString[0];
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	if ($endVtx=="")
		{
		if  (size($coveredEdges)==size($sel))
			$around=1;
		}
	else
		{
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVtx $tempString`)
				$around=1;
		}
	select -d $prevVtxs;
	$prevVtxs=$tempString;
	$tempString2=`ls -sl -fl`;
	if ($tempString2[0]=="")
		break;
	$vtxs1[size($vtxs1)]=$tempString2[0];
	$pos=`xform -q -ws -t $tempString2[0]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	select $tempString;
	if ($around)
		{
		if ($endVtx=="")
			$endVtx=$tempString2[0];
		break;
		}
	}

ConvertSelectionToContainedEdges;
string $edges1[]=`ls -sl -fl`;
eval $curveCmd;

if ($section=="ForeHead")
	{
	if (`objExists ForeHeadFromEdges`)
		{
		select -cl;
		for ($i=0;$i<size($sel);$i++)
			if (`gmatch $sel[$i] "*[.]vtx*"`)
				select -add $sel[$i];
		}

	if (size($sel)!=3 && !`objExists ForeHeadFromEdges`)
		error "Exactly 3 vertices must be selected";
	$closestSampler=`createNode -n closestSampler closestPointOnMesh`;
	connectAttr ($geometry+".outMesh") ($closestSampler+".inMesh");
	for ($i=0;$i<size($sel);$i++)
		{
		tokenize $sel[$i] "[" $tempString;
		tokenize $tempString[1] "]" $tempString;
		$selCompNrs[$i]=$tempString[0];
		$pos=`xform -q -ws -t $sel[$i]`;
		$selPosX[$i]=$pos[0];
		$selPosY[$i]=$pos[1];
		}

	//find $sideVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selPosX[$i]<$minPosX)
			{
			$sideVtxNr=$selCompNrs[$i];
			$minPosX=$selPosX[$i];
			}
		}
	//find $topVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selCompNrs[$i]==$sideVtxNr) continue;
		if ($selPosY[$i]>$maxPosY)
			{
			$topVtxNr=$selCompNrs[$i];
			$maxPosY=$selPosY[$i];
			}
		}
	//find $noseVtxNr
	for ($i=0;$i<size($sel);$i++)
		{
		if ($selCompNrs[$i]==$sideVtxNr) continue;
		if ($selCompNrs[$i]==$topVtxNr) continue;
		$noseVtxNr=$selCompNrs[$i];
		}
	//find $lidInnerVtxNr
	$pos=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
	setAttr -type float3 ($closestSampler+".inPosition") $pos[0] $pos[1] $pos[2];
	$lidInnerVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	//find $lidOuterVtxNr
	int $upperEyeLidOuterSpans=`getAttr upperEyeLidOuterCurve.spans`;
	$pos=`xform -q -ws -t ("upperEyeLidOuterCurve.cv["+$upperEyeLidOuterSpans+"]")`;
	setAttr -type float3 ($closestSampler+".inPosition") $pos[0] $pos[1] $pos[2];
	$lidOuterVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	if (!`objExists ForeHeadFromEdges`)
		{
		select `ls -o $sel[0]`;
//		select `polySelect -q -asSelectString -shortestEdgePath $lidInnerVtxNr $noseVtxNr`;
		asSelectLeastEdgesPath $geometry $lidInnerVtxNr $noseVtxNr;
		$edgesLidInnerNose=`ls -sl -fl`;
		if (!size(`ls -sl`))
			{
			delete FaceFitForeHead faceLoopCurve1;
			error ("Unable to determine ForeHead area, try selecting the complete edgeBorder manually\n"
				+"and select the 3 vertices,\n"
				+"and then type:asForeHeadFromEdges;");
			}
//		select `polySelect -q -asSelectString -shortestEdgePath $noseVtxNr $topVtxNr`;
		asSelectLeastEdgesPath $geometry $noseVtxNr $topVtxNr;
		$edgesNoseTop=`ls -sl -fl`;
//		select `polySelect -q -asSelectString -shortestEdgePath $topVtxNr $sideVtxNr`;
		asSelectLeastEdgesPath $geometry $topVtxNr $sideVtxNr;
		$edgesTopSide=`ls -sl -fl`;
//		select `polySelect -q -asSelectString -shortestEdgePath $sideVtxNr $lidOuterVtxNr`;
		asSelectLeastEdgesPath $geometry $sideVtxNr $lidOuterVtxNr;
		$edgesSideLidOuter=`ls -sl -fl`;

		//Edges that are in more then 1 path, are unneccecary detours
		//4 way check
		for ($i=0;$i<size($edgesLidInnerNose);$i++)
			{
			if (`stringArrayCount $edgesLidInnerNose[$i] $edgesNoseTop`)
				{
				$edgesNoseTop=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesNoseTop`;
				$edgesLidInnerNose=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesLidInnerNose`;
				}
			if (`stringArrayCount $edgesLidInnerNose[$i] $edgesTopSide`)
				{
				$edgesTopSide=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesTopSide`;
				$edgesLidInnerNose=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesLidInnerNose`;
				}
			if (`stringArrayCount $edgesLidInnerNose[$i] $edgesSideLidOuter`)
				{
				$edgesSideLidOuter=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesSideLidOuter`;
				$edgesLidInnerNose=`stringArrayRemove {$edgesLidInnerNose[$i]} $edgesLidInnerNose`;
				}
			}
		//3 way check
		for ($i=0;$i<size($edgesNoseTop);$i++)
			{
			if (`stringArrayCount $edgesNoseTop[$i] $edgesTopSide`)
				{
				$edgesTopSide=`stringArrayRemove {$edgesNoseTop[$i]} $edgesTopSide`;
				$edgesNoseTop=`stringArrayRemove {$edgesNoseTop[$i]} $edgesNoseTop`;
				}
			if (`stringArrayCount $edgesNoseTop[$i] $edgesSideLidOuter`)
				{
				$edgesSideLidOuter=`stringArrayRemove {$edgesNoseTop[$i]} $edgesSideLidOuter`;
				$edgesNoseTop=`stringArrayRemove {$edgesNoseTop[$i]} $edgesNoseTop`;
				}
			}
		//2 way check
		for ($i=0;$i<size($edgesTopSide);$i++)
			if (`stringArrayCount $edgesTopSide[$i] $edgesSideLidOuter`)
				{
				$edgesSideLidOuter=`stringArrayRemove {$edgesTopSide[$i]} $edgesSideLidOuter`;
				$edgesTopSide=`stringArrayRemove {$edgesTopSide[$i]} $edgesTopSide`;
				}

		select $edgesLidInnerNose $edgesNoseTop $edgesNoseTop $edgesTopSide $edgesSideLidOuter;
		$sel=`ls -sl -fl`;
		}
	delete $closestSampler;

	if (`objExists ForeHeadFromEdges`)
		select $sel;

	delete faceLoopCurve1;
	DuplicateCurve;
	$tempString=`ls -sl`;
	catchQuiet (`attachCurve -n faceLoopCurve1 -ch 1 -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1`);
	delete $tempString;

	//store info which CV aligns with original vtx selection, so we can re-find these later, even if topology changes
	createNode -n tempNearestPointOnCurve nearestPointOnCurve;
	connectAttr -f faceLoopCurve1.worldSpace[0] tempNearestPointOnCurve.inputCurve;
	$pos=`xform -q -ws -t ($geometry+".vtx["+$noseVtxNr+"]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	addAttr -ln noseCvNr -at long -dv (`getAttr tempNearestPointOnCurve.result.parameter`-1) FaceFitForeHead;
	$pos=`xform -q -ws -t ($geometry+".vtx["+$topVtxNr+"]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	addAttr -ln topCvNr -at long -dv (`getAttr tempNearestPointOnCurve.result.parameter`-1) FaceFitForeHead;
	$pos=`xform -q -ws -t ($geometry+".vtx["+$sideVtxNr+"]")`;
	setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
	addAttr -ln sideCvNr -at long -dv (`getAttr tempNearestPointOnCurve.result.parameter`-1) FaceFitForeHead;
	delete tempNearestPointOnCurve;
	}


if ($upAndLo)
	{
	if (`objExists asRunningFaceLipLeft`)
		$posA=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
	//get $edges2[]
	$curveCmd="curve -n faceLoopCurve2 -d 1 ";
	$around=0;
	select $startVtx;
	$pos=`xform -q -ws -t $startVtx`;
	if ($section!="Lip")
		{
		$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
		$prevVtxs[0]=$startVtx;
		$vtxs2[size($vtxs2)]=$startVtx;
		}
	$hitSecondLipStartVtxs=0;
	for ($i=0;$i<199;$i++)
		{
		ConvertSelectionToEdges;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			if (!`stringArrayCount $tempString[$y] $sel` || $tempString[$y]==$edge1)
				select -d $tempString[$y];
			}
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $endVtx $tempString`)
				$around=1;
		select -d $prevVtxs;
		$prevVtxs=$tempString;
		$tempString2=`ls -sl -fl`;
		if (!`size($tempString2)`)
			error "Not a complete edgeloop";
		$pos=`xform -q -ws -t $tempString2[0]`;
		if ($pos[0]<0.001 && !`objExists asRunningFaceLipLeft`)
			$vtxs2[size($vtxs2)]=$tempString2[0];
		if ($pos[0]>0.001 && `objExists asRunningFaceLipLeft`)
			$vtxs2[size($vtxs2)]=$tempString2[0];
		if ($i>0 && size($lipStartVtxs) && `stringArrayCount $tempString2[0] $lipStartVtxs`)
			$hitSecondLipStartVtxs=1;
		if (size($lipStartVtxs) && $hitSecondLipStartVtxs==0)
			;
		else if ($section=="Lip" && $pos[0]>0.001 && size($lipStartVtxs)==0 && !`objExists asRunningFaceLipLeft`) //only rightSide for Lip-curve
			;
		else if ($section=="Lip" && $pos[0]<($posA[0]-0.001) && size($lipStartVtxs)==0 && `objExists asRunningFaceLipLeft`) //only rightSide for Lip-curve
			;
		else
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];

		select $tempString;
		if ($around)
			break;
		}

	ConvertSelectionToContainedEdges;
	eval $curveCmd;

	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	$tempString=`listRelatives -s faceLoopCurve2`;
	rename $tempString[0] faceLoopCurve2Shape;

	int $OneIsUpper;
	select $edges1;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	for ($y=0;$y<size($tempString);$y++)
		if (`stringArrayCount $maxYVtx $tempString`)
			$OneIsUpper=1;

	//Special case detection of $OneIsUpper, on LipOuter
	if ($section=="Lip" && $part=="Outer")
		{
		$posA=`xform -q -ws -t $vtxs1[0]`;
		$posB=`xform -q -ws -t $vtxs2[0]`;
		if ($posA[1]>$posB[1])
			$OneIsUpper=1;
		else
			$OneIsUpper=0;
		}

	//Special case detection of $OneIsUpper, on LipMain, as LowerVtx can be higher than UpperVtx
	if ($section=="Lip" && $part=="Main" && `objExists ("upperLipOuterCurve"+$leftSuffix)`)
		{
		$tempString[0]=`asGetFaceFitSelection ("upperLipOuterCurve"+$leftSuffix)`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		string $upperOuterLipVtxZero=$tempString[0];
		select $upperOuterLipVtxZero;
		for ($y=0;$y<10;$y++)
			{
			polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
			$tempString=`ls -sl -fl`;
			if (`stringArrayCount $vtxs1[0] $tempString`)
				{
				$OneIsUpper=1;
				break;
				}
			if (`stringArrayCount $vtxs2[0] $tempString`)
				{
				$OneIsUpper=0;
				break;
				}
			}
		}

	//Same Special case detection for LipInner, but refering looking for LipMain
	if ($section=="Lip" && $part=="Inner" && `objExists ("upperLipMainCurve"+$leftSuffix)`)
		{
		$tempString[0]=`asGetFaceFitSelection ("upperLipMainCurve"+$leftSuffix)`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		string $upperOuterLipVtxZero=$tempString[0];
		select $upperOuterLipVtxZero;
		for ($y=0;$y<10;$y++)
			{
			polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
			$tempString=`ls -sl -fl`;
			if (`stringArrayCount $vtxs1[0] $tempString`)
				{
				$OneIsUpper=1;
				break;
				}
			if (`stringArrayCount $vtxs2[0] $tempString`)
				{
				$OneIsUpper=0;
				break;
				}
			}
		}

	string $upperVtxs[],$lowerVtxs[];
	if ($OneIsUpper)
		{
		$upperVtxs=$vtxs1;
		$lowerVtxs=$vtxs2;
		rename faceLoopCurve1 ("upper"+$section+$part+"Curve"+$leftSuffix);
		rename faceLoopCurve2 ("lower"+$section+$part+"Curve"+$leftSuffix);
		}
	else
		{
		$upperVtxs=$vtxs2;
		$lowerVtxs=$vtxs1;
		rename faceLoopCurve1 ("lower"+$section+$part+"Curve"+$leftSuffix);
		rename faceLoopCurve2 ("upper"+$section+$part+"Curve"+$leftSuffix);
		}
	}
if (!$upAndLo)
	{
	$tempString=`listRelatives -s faceLoopCurve1`;
	rename $tempString[0] faceLoopCurve1Shape;
	rename faceLoopCurve1 ($section+$part+"Curve"+$leftSuffix);
	}


for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if (!$upAndLo) $upperLower="";
	if (!$upAndLo && $upperLowerFactor==-1) continue;

	parent ($upperLower+$section+$part+"Curve"+$leftSuffix) ("FaceFit"+$section+$part+"Curve"+$leftSuffix);
	makeIdentity -a 1 -t 1 -r 1 -s 1 ("FaceFit"+$section+$part+$leftSuffix);
//	setAttr ($upperLower+$section+$part+"CurveShape.dispCV") 1;
	setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideEnabled") 1;
	setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 17;//Yellow

	//Colors
	if ($part=="Main")
		setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 13;//Red
	if ($part=="Outer")
		setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 14;//Green
	if ($part=="Inner")
		setAttr ($upperLower+$section+$part+"Curve"+$leftSuffix+"Shape.overrideColor") 15;//Blue

	}


if ($mainAndOuter==0) $part="";
else $parts={"Main","Outer"};
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	if ($upAndLo==0) $upperLower="";
	if ($upAndLo==0 && $upperLowerFactor==-1)
		continue;
	if ($isSphere)
		continue;

	if ($upperLower=="upper" || !$upAndLo)
		{
		$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r ($scale/400.0) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] ($section+"Profile"+$part+$leftSuffix);
		parent ($section+"Profile"+$part+$leftSuffix) ("FaceFit"+$section+$part+"Curve"+$leftSuffix);
		connectAttr -f ("FaceFit"+$section+$part+$leftSuffix+".radius") ($section+"Profile"+$part+$leftSuffix+".sx");
		connectAttr -f ("FaceFit"+$section+$part+$leftSuffix+".radius") ($section+"Profile"+$part+$leftSuffix+".sy");
		connectAttr -f ("FaceFit"+$section+$part+$leftSuffix+".radius") ($section+"Profile"+$part+$leftSuffix+".sz");
		}
	extrude -n ($upperLower+$section+"Cylinder"+$part+$leftSuffix) -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 0 ($section+"Profile"+$part+$leftSuffix) ($upperLower+$section+$part+"Curve"+$leftSuffix);
	setAttr ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".overrideEnabled") 1;
	setAttr ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".overrideDisplayType") 2;

	setAttr ($upperLower+$section+"Cylinder"+$part+$leftSuffix+"Shape.curvePrecisionShaded") 4;
	parent ($upperLower+$section+"Cylinder"+$part+$leftSuffix) ("FaceFit"+$section+$part+"Geo"+$leftSuffix);

	//ensure outwards normals
	$posA=`xform -q -ws -t ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".cv[6][0]")`;
	$posB=`xform -q -ws -t ($upperLower+$section+"Cylinder"+$part+$leftSuffix+".cv[6][1]")`;
	if ($posA[1]>$posB[1])
		reverseSurface -d 0 -ch 1 -rpo 1 ($upperLower+$section+"Cylinder"+$part+$leftSuffix);

	//Colors
	if ($part=="Main")
		{
		sets -e -forceElement "asRedSG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		if ($upperLower=="lower")
			sets -e -forceElement "asRed2SG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		}

	if ($part=="Outer")
		{
		sets -e -forceElement "asGreenSG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		if ($upperLower=="lower")
			sets -e -forceElement "asGreen2SG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		}

	if ($part=="Inner" || $section=="EyeLidDroopy")
		{
		sets -e -forceElement "asBlueSG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		if ($upperLower=="lower")
			sets -e -forceElement "asBlue2SG" ($upperLower+$section+"Cylinder"+$part+$leftSuffix);
		}

	if ($section=="Tongue")
		sets -e -forceElement "asRedSG" ($section+"Cylinder"+$part+$leftSuffix);
	}

if ($section=="ForeHead" || ($section=="EyeLid" && $part=="Inner") || ($section=="Lip" && $part=="Inner"))
	{
	select $sel;
	$tempString=`ls -sl -fl`;
	if ($section=="ForeHead")
		{
		$areaMeshShader="asGreenSG";
		sets -e -forceElement "asGreenSG" ($section+"Cylinder"+$part+$leftSuffix);
		asFaceReSelect EyeLid Outer;
		$growStartPos="EyeBrowInner"+$leftSuffix;
		}
	if (($section=="EyeLid" && $part=="Inner") || ($section=="Lip" && $part=="Inner"))
		{
		$areaMeshShader="asRedSG";
		loft -n tempLoft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true ("upper"+$section+"OuterCurve"+$leftSuffix) ("upper"+$section+"MainCurve"+$leftSuffix) ("upper"+$section+"InnerCurve"+$leftSuffix);
		$growStartPos="upper"+$section+"MainCurve"+$leftSuffix+".cv["+(`getAttr ("upper"+$section+"MainCurve"+$leftSuffix+".spans")`/2)+"]";
		asFaceReSelect $section Outer;
		}
	select -add $tempString;
	ConvertSelectionToVertices;
	$borderVtxs=`ls -sl -fl`;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($geometry+".outMesh") closestSampler.inMesh;
	$pos=`xform -q -ws -t $growStartPos`;

	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	if (`objExists tempLoft`) delete tempLoft;
	select ($geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
	for ($i=0;$i<199;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $borderVtxs;
		$previousNumSel=$numSel;
		$tempString=`ls -sl -fl`;
		$numSel=size($tempString);
		if ($numSel==$previousNumSel)
			break;
		}
	delete closestSampler;
	ConvertSelectionToFaces;
	$tempString=`ls -sl -fl`;
	polyCube -n ($section+$part+"AreaMesh"+$leftSuffix) -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
	sets -e -forceElement $areaMeshShader ($section+$part+"AreaMesh"+$leftSuffix);
	connectAttr ($geometry+".outMesh") ($section+$part+"AreaMesh"+$leftSuffix+".inMesh");
	refresh;
	disconnectAttr ($geometry+".outMesh") ($section+$part+"AreaMesh"+$leftSuffix+".inMesh");
	parent ($section+$part+"AreaMesh"+$leftSuffix) ("FaceFit"+$section+$part+"Geo"+$leftSuffix);
	select `asobjSetCast "" $tempString ($section+$part+"AreaMesh"+$leftSuffix)`;
	asInvertSelection;
	setAttr ("FaceFit"+$section+$part+"Geo"+$leftSuffix+".inheritsTransform") 1;//temp switch On, to avoid Delete cmd switching this On
	delete;
	setAttr ("FaceFit"+$section+$part+"Geo"+$leftSuffix+".inheritsTransform") 0;
	refresh;
	}

//Non-symmetrical Lip
if ($section=="Lip" && `objExists FaceFitEyeLidMainLeft` && !`objExists asRunningFaceLipLeft`)
	{
	clear $tempString;
	if (`objExists closestSampler`) delete closestSampler;
	createNode -n closestSampler closestPointOnMesh;
	connectAttr ($geometry+".outMesh") closestSampler.inMesh;

	$pos=`xform -q -ws -t ("upperLip"+$part+"Curve.cv[0]")`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$tempString[0]=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	$tempString2[0]=$tempString[0];
	$pos=`xform -q -ws -t ("upperLip"+$part+"Curve.cv[1]")`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$tempString[1]=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	$pos=`xform -q -ws -t ("lowerLip"+$part+"Curve.cv[0]")`;
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$tempString[1]=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
	delete closestSampler;
	asFaceReSelect Lip $part;
	select -d ($geometry+".vtx[0:999999]");
	select -add $tempString;
	$leftLipSelection=`ls -sl`;

	$nr=`getAttr ("upperLip"+$part+"Curve.spans")`;

	eval ("select "+`asGetFaceFitSelection ("FaceFitLip"+$part+"Curve")`);
	$tempString=`ls -sl -fl`;

	asFaceReSelect Lip $part;
	ConvertSelectionToVertices;	
	select -d $tempString;

	$tempString=`ls -sl -fl`;
	select $tempString2[0];
	for ($i=0;$i<$nr-1;$i++)
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
	$tempString3=`ls -sl -fl`;
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
	$tempString4=`ls -sl -fl`;
	for ($i=0;$i<size($tempString4);$i++)
		{
		if (!`stringArrayCount $tempString4[$i] $tempString`)
			continue;
		if (`stringArrayCount $tempString4[$i] $tempString3`)
			continue;
		$tempString2[1]=$tempString4[$i];
		}
	createNode -n asRunningFaceLipLeft transform;
	addAttr -ln startVtx -dt "string" asRunningFaceLipLeft;
	addAttr -ln endVtx -dt "string" asRunningFaceLipLeft;
	setAttr -type "string" asRunningFaceLipLeft.startVtx $tempString2[0];
	setAttr -type "string" asRunningFaceLipLeft.endVtx $tempString2[1];
	select $tempString2[1] $leftLipSelection;
	asCreateFaceFit $section $part $upAndLo $mainAndOuter $isSphere $shadingGroup;
	}
if (`objExists asRunningFaceLipLeft`) delete asRunningFaceLipLeft;

select ("FaceFit"+$section+$part+$leftSuffix);
print ("// FaceFit"+$section+$part+$leftSuffix+" created.\n");
}

global proc asFaceDeselectLowestHalfOfVtx ()
{
$tempString=`ls -sl -fl`;
float $tys[];
float $tysAverage;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	$tys[$y]=$pos[1];
	$tysAverage+=$tys[$y];
	}
$tysAverage=$tysAverage/size($tempString);
select -cl;
for ($y=0;$y<size($tempString);$y++)
	if ($tys[$y]>$tysAverage)
		select -add $tempString[$y];
}

global proc asForeHeadFromEdges ()
{
string $sel[]=`ls -sl`;
createNode -n ForeHeadFromEdges transform;
select $sel;
asCreateFaceFit ForeHead "" 0 0 0 asGreenSG;
delete ForeHeadFromEdges;
}

global proc asSelectLeastEdgesPath (string $geometry, int $startVtxNr, int $endVtxNr)
{
string $sel[]=`ls -sl`;
string $tempString[];

select $geometry;
//First check for Loop or Ring, as this might be the "Path of Less Edges", which is prefferd over `shortest Path`
select ($geometry+".vtx["+$startVtxNr+"]") ($geometry+".vtx["+$endVtxNr+"]");
$tempString=`polySelectSp -q -loop`;

//must contain start & end vtx in path
if (size($tempString))
	{
	select $tempString;
	$tempString=`ls -sl -fl`;
	if (!`stringArrayCount ($geometry+".vtx["+$startVtxNr+"]") $tempString`)
		{
		select -cl;
		clear $tempString;
		}
	if (!`stringArrayCount ($geometry+".vtx["+$endVtxNr+"]") $tempString`)
		{
		select -cl;
		clear $tempString;
		}
	}

if (!size($tempString))//try edgeRing instead of edgeLoop
	$tempString=`polySelectSp -q -ring`;
//must contain end vtx in path
if (size($tempString))
	{
	select $tempString;
	$tempString=`ls -sl -fl`;
	if (!`stringArrayCount ($geometry+".vtx["+$endVtxNr+"]") $tempString`)
		{
		select -cl;
		clear $tempString;
		}
	}

if (size($tempString))
	{
	select $tempString;
	ConvertSelectionToContainedEdges;
	}
else
	{
	select $geometry;
	select `polySelect -q -asSelectString -shortestEdgePath $startVtxNr $endVtxNr`;
	}
}

global proc int asFaceRemoveBodyJaw ()
{
int $return=0;
string $dialog="OK";
if (!`objExists headTopology`)
	$dialog=`confirmDialog -t "Confirm"
	-m "This will replace the Jaw from the Body-setup"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog=="OK")
	$return=1;

string $skinClusters[]=`ls -type skinCluster`;
for ($i=0;$i<size($skinClusters);$i++)
	if (`objExists Jaw_M`) asRemoveInfluence Jaw_M $skinClusters[$i];

if (`objExists FKOffsetJaw_M`) delete FKOffsetJaw_M;
if (`objExists Jaw_M`) delete Jaw_M;
if (`objExists Jaw`) delete Jaw;

asRemoveUnusedfromBuildPose bodySetup;
return $return;
}

global proc asDeleteAdvancedFace ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $keepBuildPoseInfo;
string $tempString[],$tempString2[],$faceSCs[];
if (!`objExists FaceMotionSystem`)
	return;

//versions before 5.531, migh have run the "FitEyeBall from older version of AdvancedSkeleton, this will now be automatically replaced with new FitEyeBall"
//function, and therefor have FitEyeBall in the FaceAllSet
if (`objExists FaceAllSet` && `objExists FaceFitEyeBall`)
	{
	select -hi FaceFitEyeBall;
	sets -rm FaceAllSet `ls -sl`;
	select -cl;
	}

//Add headJoint as inf, if all bound joints will be deleted, to keep skinCluster.
int $haveKeepJoint;
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		$faceSCs[size($faceSCs)]=$tempString[$i];
for ($i=0;$i<size($faceSCs);$i++)
	{
	$tempString=`listConnections ($faceSCs[$i]+".matrix")`;
	$haveKeepJoint=0;
	for ($y=0;$y<size($tempString);$y++)
		if (!`sets -im FaceAllSet $tempString[$y]`)
			$haveKeepJoint=1;
	if (!$haveKeepJoint)
		{
		skinCluster -e -ai $headJoint -lw false -wt 1 $faceSCs[$i];
		}
	}

//lockWeights all but headJoint
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$headJoint)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 1;
//remove previous inf`s
//select `listRelatives -ad -type joint $headJoint`;
//$tempString=`ls -sl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im FaceAllSet $tempString[$i]`)
		{
		select $geometry $tempString[$i];
		RemoveInfluence;
		skinPercent -normalize 1 $skinCluster $geometry;
		}
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists lockInfluenceWeights $tempString[$i]`)
		setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
delete `sets -q -nodesOnly FaceAllSet`;
if (`objExists FaceAllSet`)
	delete `sets -q -nodesOnly FaceAllSet`;

//Normalize SkinClusters
$tempString=`ls -type skinCluster`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 0 -d 1 ($tempString[$i]+".outputGeometry[0]")`;
	if (`objExists $tempString2[0]`)
		catchQuiet (`skinPercent -normalize 1 $tempString[$i] $tempString2[0]`);
	}

if (!`checkBox -q -v asFaceKeepAllCheckBox`)
	if (`attributeExists run FaceFitSkeleton`)
		setAttr -type "string" FaceFitSkeleton.run "";
if (`checkBox -q -v asFaceKeepAllCheckBox`)
	$keepBuildPoseInfo=", and build pose stored in the \"FaceFitSkeleton.run\" attribute";

if (`objExists asFaceDeltaMush`)
	delete asFaceDeltaMush;

asFaceUpdateFitFace;

if (`attributeExists buildStep FaceFitSkeleton`)
	setAttr FaceFitSkeleton.buildStep 0;
asUpdateButtonEnables;
asFaceUpdateInfo 1;
print ("// Existing AdvancedFace removed"+$keepBuildPoseInfo+".\n");
}

global proc asFaceUpdateFitFace ()
{
//v5.351 to v5.352
if (`attributeExists version FaceGroup`)
	if (`getAttr FaceGroup.version`<5.352 && `asGetScriptVersion`>=5.352)
		{
		if (`objExists FaceFitEyeBrowOuter` && `objExists EyeBrowOuterCurve`) delete FaceFitEyeBrowOuter;
		if (`objExists FaceFitEyeBrowMain`) delete FaceFitEyeBrowMain;
		if (`objExists FaceFitEyeLidInner`)
			{
			asFaceReSelect EyeLid "Inner";
			delete FaceFitEyeLidInner;
			asCreateFaceFit EyeLid "Inner" 1 1 0 asGreenSG;
			}
		if (`objExists FaceFitLipInner`)
			{
			asFaceReSelect Lip "Inner";
			delete FaceFitLipInner;
			asCreateFaceFit Lip "Inner" 1 1 0 asGreenSG;
			}
		if (`objExists FaceFitAnimateFit`) delete FaceFitAnimateFit;
		}

//v5.354 to v5.355
if (`asGetScriptVersion`>=5.355)
	{
	string $oldNames[]={"cheek","line","cheekRaiser","noseCorner"};
	string $newNames[]={"Cheek","Line","CheekRaiser","NoseCorner"};
	for ($i=0;$i<size($oldNames);$i++)
		if (`objExists ("FaceFit"+$oldNames[$i])`)
			{
			asFaceReSelect $oldNames[$i] "";
			delete ("FaceFit"+$oldNames[$i]);
			asCreateFaceFit $newNames[$i] "" 0 0 1 asGreenSG;
			}
	}
select -cl;
}

global proc asStepBuildPrep ()
{
string $tempString[],$controls[];

//ensure any controls coverted to softMod, is converted back to control
string $softModHandle;
string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`gmatch $rootLevelObjects[$i] "convertedSoftModHandle_*"`)
		{
		$softModHandle=$rootLevelObjects[$i];
		select $softModHandle;
		asFaceConvertSoftModBackToControl;
		}

//zero out controls, as they might have been moved for testing (unless the control has keyFrames)
if (`objExists FaceControlSet`)
	$controls=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listConnections -s 1 -d 0 -type animCurve $controls[$i]`;
	if (size($tempString))
		continue;
	xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $controls[$i];
	}
}

global proc asStepBuildComplete (int $stepBuild)
{
if ($stepBuild==0)
	return;

if (`objExists FaceFitSkeleton`)
	{
	if (!`attributeExists buildStep FaceFitSkeleton`)
		addAttr -ln "buildStep" -at long -dv 0 FaceFitSkeleton;
	setAttr FaceFitSkeleton.buildStep $stepBuild;
	}

print ("// Face step:"+$stepBuild+" complete.\n");
asFaceUpdateInfo 1;
}

global proc asBuildAdvancedFace ()
{
string $tempString[];
string $stepBuildText;

if (`objExists FaceFitSkeleton`)
	if (!`attributeExists buildStep FaceFitSkeleton`)
		addAttr -ln "buildStep" -at long -dv 0 FaceFitSkeleton;

for ($i=1;$i<99;$i++)
	{
	if (!`text -q -ex ("stepBuild"+$i+"Text")`)
		break;
	$stepBuildText=`text -q -l ("stepBuild"+$i+"Text")`;
	tokenize $stepBuildText ":" $tempString;
	$proc="asFace"+`strip $tempString[1]`;
	asStepBuildPrep;
	print ("// Execute Step:"+$stepBuildText+"\n");
	eval ($proc);
	asStepBuildComplete $i;
	}
print "// Face Build Complete\n";
}

global proc asFacePrep ()
{
int $keepAll=`checkBox -q -v asFaceKeepAllCheckBox`;
int $keepSkinWeighting=`checkBox -q -v asFaceKeepSkinWeightsCheckBox`;
int $keepBlendShapes=`checkBox -q -v asFaceKeepBlendShapesCheckBox`;
int $vtxNrA,$vtxNrB,$vtxNrC,$vtxNrD,$numVtx,$upperLipOuterNumCVs,$lowerEyeLidOuterNumCVs,$boundToOtherJoints,$hasConvertedToBlendShapes;
int $tempInts[];
float $pos[],$rot[],$sca[];
float $scale=`asFaceGetScale`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $rightEye=`textField -q -tx asFaceEye_RTextField`;
string $leftEye=`textField -q -tx asFaceEye_LTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $faceFitElement,$sc,$newSc;
string $tempString[],$tempString2[],$deleteObjs[],$allSetMembers[],$allFaceGeo[],$teethTongueEyes[],$historyNodes[],$infJoints[],$geos[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//check the required FaceFit elements exists
$tempString=`optionMenu -q -ill asFaceReqFitElementsOptionMenu`;
for ($i=0;$i<size($tempString);$i++)
	{
	$faceFitElement=`menuItem -q -l $tempString[$i]`;
	if (!`objExists ("FaceFit"+$faceFitElement)`)
		error ("Missing Face Fit Element:\""+$faceFitElement+"\", makes sure all checkBoxes in the Fit-section are checked.\n");
	}

if (`objExists "prefix_FaceGroup"`)
	error "Object \"prefix_FaceGroup\" found, which means a previous build failed. Try to Undo previous build, to restore functional FaceSetup";

$upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
$lowerEyeLidOuterNumCVs=`getAttr lowerEyeLidOuterCurve.spans`+1;

//check that names are avaiable
string $names[]={"Face","Face_M"};
for ($i=0;$i<size($names);$i++)
	if (`objExists $names[$i]` && !`objExists "FaceGroup"`)
		{
		select `ls $names[$i]`;
		error ("A object with the name:\""+$names[$i]+"\" already exists, rename this to something else, before running the Build.\n");
		}

if (`objExists "FaceMotionSystem"` && !`objExists DeformationLayers`)
	error "This FaceRig seem to have been converted to Simplified-FaceSetup.\nReBuild for Simplified-FaceSetup is not yet supported.";

//Re-building ?
if (`objExists "FaceMotionSystem"`)
	{
	createNode -n prefix_FaceGroup transform;
	setAttr prefix_FaceGroup.v 0;
	addAttr -ln version -at double prefix_FaceGroup;
	setAttr -l 1 prefix_FaceGroup.version `getAttr FaceGroup.version`;

	//blendShapes
	if (`objExists asFaceBS` && $keepBlendShapes)
		{
		$tempString=`listAttr -ud asFaceBS`;
		for ($i=0;$i<size($tempString);$i++)
			if (`gmatch $tempString[$i] "converted*ToBlendShapes"`)
				{
				$hasConvertedToBlendShapes=1;
				addAttr -ln $tempString[$i] -at bool -dv 1 prefix_FaceGroup;
				}
		if ($hasConvertedToBlendShapes)
			{
			asBSExtractAll;
			select -hi asBlendShapes;
			sets -add FaceAllSet;
			setAttr asBlendShapes.v 0;
			}
		}

	if (`getAttr FaceGroup.v`)
		asToggleFitFace;
	//Some DrivingSystem SDK`s might not be part of FaceAllSet, so adding these
	$tempString=`ls "bwSDK*"`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$animCurves=`listConnections -scn 1 -s 1 -d 0 -type animCurve $tempString[$i]`;
		for ($y=0;$y<size($animCurves);$y++)
			if (!`sets -im FaceAllSet $animCurves[$y]`)
				sets -add FaceAllSet $animCurves[$y];
		}

	$allSetMembers=`sets -q FaceAllSet`;
	$allSetMembers[size($allSetMembers)]="FaceAllSet";
	$allSetMembers[size($allSetMembers)]="FaceControlSet";
	$allSetMembers[size($allSetMembers)]="FaceAreas";

	for ($i=0;$i<size($allSetMembers);$i++)
		if (`objExists $allSetMembers[$i]`)
			$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
		else
			$allSetMembers[$i]="";
	parent prefix_FaceMotionSystem prefix_FaceDeformationSystem prefix_FaceGroup;
	$tempString=`listRelatives -ad -type transform prefix_FaceGroup`;
	for ($i=0;$i<size($tempString);$i++)
		if (!`gmatch $tempString[$i] "prefix_*"`)
			rename $tempString[$i] ("prefix_"+$tempString[$i]);
	if (`objExists SquintLayerFFDSet_R`) rename SquintLayerFFDSet_R prefix_SquintLayerFFDSet_R;
	if (`objExists SquintLayerFFDSet_L`) rename SquintLayerFFDSet_L prefix_SquintLayerFFDSet_L;
	if (`objExists squashFfdSet`) rename squashFfdSet prefix_squashFfdSet;

	delete prefix_asFaceBS;
	delete prefix_LipSetup;

	//keep info about what `post build` steps have been done previously
	if (`objExists IrisFfd_R`)
		addAttr -k 1 -ln "previousIris" -at bool -dv true prefix_FaceGroup;
	if (`objExists PupilFfd_R`)
		addAttr -k 1 -ln "previousPupil" -at bool -dv true prefix_FaceGroup;

	//DeleteHistory and Re-bind for eye, teeth, tongue, hair, eyeBrows etc
	createNode -n prefix_FaceGeometry -p prefix_FaceGroup transform;
	setAttr prefix_FaceGeometry.v 0;
	//$teethTongueEyes, since it can be multiple objs, e.g eye+lens 
	$tempString={$upperTeeth,$lowerTeeth,$tongue,$leftEye,$rightEye};
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		for ($y=0;$y<size($tempString2);$y++)
			if ($tempString2[$y]!="")
				$teethTongueEyes[size($teethTongueEyes)]=$tempString2[$y];
		}
	$tempString=`stringArrayCatenate $allFaceGeo $teethTongueEyes`;
	$tempString=`stringArrayRemoveDuplicates $tempString`;
	$tempString=`stringArrayRemove {$geometry} $tempString`;
	$geos=$tempString;
	for ($i=0;$i<size($geos);$i++)
		{
		$boundToOtherJoints=0;
		$sc="";
		$historyNodes=`listHistory -pdo 1 -il 2 $geos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				$sc=$historyNodes[$y];
		if ($sc!="")
			{
			$infJoints=`listConnections ($sc+".matrix")`;
			for ($y=0;$y<size($infJoints);$y++)
				if ($infJoints[$y]!=$headJoint)
					if (!`gmatch $infJoints[$y] "prefix_Pupil_*"` && !`gmatch $infJoints[$y] "prefix_Iris_*"`)
						if (!`sets -im prefix_FaceAllSet $infJoints[$y]`)
						{
						//non-FaceSetup joints. e.g Hat weighted to a hat-joint
						print ("// Restoring skinning :\""+$geos[$i]+"\" bound to \""+$infJoints[$y]+"\".\n");
						duplicate -n asFaceRebuildTempGeo $geos[$i];
						asLockAttr asFaceRebuildTempGeo 0 0 0 0;
						parent asFaceRebuildTempGeo prefix_FaceGroup;
						$boundToOtherJoints=1;
						}
			if ($boundToOtherJoints)
				{
				select $infJoints asFaceRebuildTempGeo;
				$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
				rename $tempString[0] tempSC;
				select $geos[$i] asFaceRebuildTempGeo;
				copySkinWeights -ss $sc -ds tempSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
				}
			}

		select $geos[$i];
		DeleteHistory;

		if ($boundToOtherJoints)
			select $geos[$i] $infJoints;
		else
			select $geos[$i] $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$newSc=$tempString[0];
		if ($boundToOtherJoints)
			{
			select asFaceRebuildTempGeo $geos[$i];
			copySkinWeights -ss tempSC -ds $newSc -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
			delete asFaceRebuildTempGeo;
			}
		}
	}

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;

//could have "leftover Lip/lid assist-softmods"
$deleteObjs={"upperTempSoftModHandle1","lowerTempSoftModHandle1","upperTempSoftModHandle2","lowerTempSoftModHandle2"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];

if (!`attributeExists version FitEyeBall`)//5.494 -> 5.495
	{
	warning "FitEyeBall from older version of AdvancedSkeleton, this will now be automatically replaced with new FitEyeBall";
	$pos=`xform -q -ws -t FitEyeBall`;
	$rot=`xform -q -ws -ro FitEyeBall`;
	$sca=`getAttr FitEyeBall.s`;
	delete FaceFitEyeBall;
	asBuildFitEyeBall;
	xform -ws -t $pos[0] $pos[1] $pos[2] FitEyeBall;
	xform -ws -ro ($rot[2]-180) ($rot[1]-90) 0 FitEyeBall;
	setAttr FitEyeBall.s -type float3 $sca[0] $sca[1] $sca[2];
	}

select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
sets -n allBeforeFaceBuild;
select -cl;
asSetFixedWrapOptions;
asFaceEnsureAdvancedBase;

duplicate -n templateLayer $geometry;
asLockAttr templateLayer 0 0 0 0;
parent templateLayer DeformationLayers;
sets -e -forceElement initialShadingGroup templateLayer;
$tempString=`listRelatives -s -f templateLayer`; 
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
setAttr templateLayer.v 0;

select $geometry;
blendShape -n asFaceBS -frontOfChain;

//Face_M joint 
select -cl;
joint -n Face_M;
asAlign Face_M $headJoint 1 0 0 0;
move -r 0 0 ($scale*0.1) Face_M;
parent Face_M FaceDeformationSystem;
setAttr Face_M.segmentScaleCompensate 0;

parent FaceDeformationSystemFollowHead Face_M;

//Make sure defined skinCluster is correct
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="skinCluster")
		if ($tempString[$y]!=$skinCluster)
			{
			print ("// Updated SkinCluster info, used to be:\""+$skinCluster+"\", now it is:\""+$tempString[$y]+"\".\n");
			$skinCluster=$tempString[$y];
			textField -e -tx $skinCluster asFaceSkinClusterTextField;
			}

//Disable any deltaMush
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
		setAttr ($tempString[$y]+".envelope") 0;

//teethSets, for tracking on cut-out objects
sets -em -n upperTeethSet;
sets -em -n lowerTeethSet;
sets -add FaceBuildingSets upperTeethSet lowerTeethSet;
if ($upperTeeth!="") {eval ("select "+$upperTeeth);sets -add upperTeethSet;}
if ($lowerTeeth!="") {eval ("select "+$lowerTeeth);sets -add lowerTeethSet;}

// Unlock All SkinInfluences
if (`objExists DeformSet`)
	{
	$deformJointsList=`sets -q "DeformSet"`;
	for ($i=0;$i<size($deformJointsList);$i++)
		if (`attributeExists lockInfluenceWeights $deformJointsList[$i]`)
			if (`getAttr ($deformJointsList[$i]+".lockInfluenceWeights")`)
				setAttr ($deformJointsList[$i]+".lockInfluenceWeights") 0;
	}

select $geometry;
//blendShape -n asFaceBS -frontOfChain;

createNode -n closestSamplerFitSelection closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection.inMesh;

//vtxsFromLipToNose
if (!`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	addAttr -ln "vtxsFromLipToNose" -at long -dv 3 FaceFitSkeleton;
$pos=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrA=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t NoseUnder`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrB=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$vtxsFromLipToNose=1;
select ($geometry+".vtx["+$vtxNrA+"]");
for ($i=0;$i<25;$i++)
	{
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
	$tempString=`ls -sl -fl`;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrB+"]") $tempString`)
		break;
	if ($i>0)
		$vtxsFromLipToNose++;
	}
$vtxsFromLipToNose++;

select -cl;
setAttr FaceFitSkeleton.vtxsFromLipToNose $vtxsFromLipToNose;

//vtxsFromLipCornerToNoseCorner (or to lowerEyeLid or to JawPivot)
if (!`attributeExists vtxsFromLipCornerToNoseCorner FaceFitSkeleton`)
	addAttr -ln "vtxsFromLipCornerToNoseCorner" -at long -dv 3 FaceFitSkeleton;
$pos=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs-1]`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrA=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t NoseCorner`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrB=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t lowerEyeLidOuterCurve.cv[($lowerEyeLidOuterNumCVs-1)/2]`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrC=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$pos=`xform -q -ws -t JawPivot`;
setAttr -type float3 closestSamplerFitSelection.inPosition $pos[0] $pos[1] $pos[2];
$vtxNrD=`getAttr closestSamplerFitSelection.result.closestVertexIndex`;
$vtxsFromLipCornerToNoseCorner=1;
select ($geometry+".vtx["+$vtxNrA+"]");
for ($i=0;$i<25;$i++)
	{
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion;
	$tempString=`ls -sl -fl`;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrB+"]") $tempString`)
		break;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrC+"]") $tempString`)
		break;
	if (`stringArrayCount ($geometry+".vtx["+$vtxNrD+"]") $tempString`)
		break;
	if ($i>0)
		$vtxsFromLipCornerToNoseCorner++;
	}

delete closestSamplerFitSelection;

$vtxsFromLipCornerToNoseCorner++;
select -cl;
setAttr FaceFitSkeleton.vtxsFromLipCornerToNoseCorner $vtxsFromLipCornerToNoseCorner;

setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v 0;

//some `auto-updates` for building with older Face-Fit
if (!`attributeExists noseCvNr FaceFitForeHead`)//5.426 -> 5.427
	{
	asFaceReSelect ForeHead "";
	delete FaceFitForeHead;
	asCreateFaceFit ForeHead "" 0 0 0 "";
	}

asUpdateButtonEnables;
select FaceGroup;
}

global proc asFaceCtrlBox ()
{
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
if (`objExists ctrlBoxOffset`)
	delete ctrlBoxOffset;
float $scale=`asFaceGetScale`/3.0;
float $temp[],$matrix[];
string $tempString[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $midHeadPos[]=`asGetMidHeadPos`;
float $boxTZ=($midHeadPos[2]+($scale*1.3));
if (`objExists FitEyeBall`)
	{
	$temp=`xform -q -ws -t FitEyeBall`;
	$boxTZ=$temp[2];
	}

$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBox;
createNode -n ctrlBoxOffset transform;
parent ctrlBox ctrlBoxOffset;
parent ctrlBoxOffset FaceMotionFollowHead;
//parentConstraint -mo $headJoint ctrlBoxOffset;
//scaleConstraint -mo $headJoint ctrlBoxOffset;

addAttr -k 1 -ln "limits" -at bool -dv true ctrlBox;

addAttr -k 1 -ln "ACtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.ACtrlVis Acontrols.v;//needed for faster fps (not compute wrap-attach)
addAttr -k 1 -ln "BCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.BCtrlVis Bcontrols.v;
addAttr -k 1 -ln "CCtrlVis" -at bool -dv true ctrlBox;
connectAttr ctrlBox.CCtrlVis Ccontrols.v;
addAttr -k 1 -ln "AimCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "TeethCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "TongueCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "RegionsCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "UpMidLoCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "SquashCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "CustomCtrlVis" -at bool -dv true ctrlBox;
addAttr -k 1 -ln "jointsVis" -at bool -dv false ctrlBox;
connectAttr ctrlBox.jointsVis Face_M.v;
if (`objExists TeethCollider`)
	addAttr -k 0 -ln "TeethColliderVis" -at bool -dv false ctrlBox;

setAttr ctrlBox.AimCtrlVis 0;
setAttr ctrlBox.RegionsCtrlVis 0;
setAttr ctrlBox.UpMidLoCtrlVis 0;

setAttr ctrlBox.overrideEnabled 1;
setAttr ctrlBox.overrideColor 17;

//Expand length down
move -r 0 -0.4 0 ctrlBoxShape.cv[2:3];
xform -ws -t ($scale*1.8) ($midHeadPos[1]-(0.3*$scale)) $boxTZ ctrlBox;
xform -s ($scale/2.0) $scale ($scale/2.0) ctrlBox;
makeIdentity -a 1 -t 0 -r 0 -s 1 ctrlBox;

if (`objExists prefix_ctrlBox`)
	{
	$temp=`getAttr prefix_ctrlBox.t`;
	setAttr ctrlBox.t -type float3 $temp[0] $temp[1] $temp[2];
	$temp=`getAttr prefix_ctrlBox.s`;
	setAttr ctrlBox.s -type float3 $temp[0] $temp[1] $temp[2];
	}

//ctrlBoxTemplate
$tempString[0]=`curve -d 1 -p -1 1 0 -p 1 1 0 -p 1 -1 0 -p -1 -1 0 -p -1 1 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ctrlBoxTemplate;
parent ctrlBoxTemplate ctrlBox;
setAttr -type float3 ctrlBoxTemplate.t 0 0 0;
setAttr -type float3 ctrlBoxTemplate.s ($scale/6.0) ($scale/6.0) ($scale/6.0);
setAttr ctrlBoxTemplateShape.overrideEnabled 1;
setAttr ctrlBoxTemplateShape.overrideDisplayType 2;

//ctrlTemplate
duplicate -n ctrlTemplate ctrlBoxTemplate;
parent ctrlTemplate ctrlBoxTemplate;
transformLimits -tx -1 1 -ty -1 1 -tz 0 0 -etx 1 1 -ety 1 1 -etz 1 1 ctrlTemplate;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.minTransYLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransXLimitEnable`);
catchQuiet (`connectAttr -f ctrlBox.limits ctrlTemplate.maxTransYLimitEnable`);
setAttr ctrlTemplateShape.overrideDisplayType 0;
setAttr ctrlTemplate.rz 45;
setAttr -type float3 ctrlTemplate.s 0.2 0.2 0.2;
setAttr ctrlTemplateShape.overrideEnabled 0;
//setAttr ctrlTemplateShape.overrideColor 17;
makeIdentity -a 1 -t 0 -r 1 -s 1 ctrlTemplate;
setAttr -l 1 -k 0 ctrlTemplate.tz;
setAttr -l 1 -k 0 ctrlTemplate.rx;
setAttr -l 1 -k 0 ctrlTemplate.ry;
setAttr -l 1 -k 0 ctrlTemplate.rz;
setAttr -l 1 -k 0 ctrlTemplate.sx;
setAttr -l 1 -k 0 ctrlTemplate.sy;
setAttr -l 1 -k 0 ctrlTemplate.sz;
setAttr -l 1 -k 0 ctrlTemplate.v;
sets -add FaceControlSet ctrlTemplate;

asFaceCreateCtrlBox "Brow_R" ($scale*-0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Brow_L" ($scale*0.25) ($scale*0.75) 0;
asFaceCreateCtrlBox "Eye_R" ($scale*-0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Eye_L" ($scale*0.25) ($scale*0.38) 0;
asFaceCreateCtrlBox "Cheek_R" ($scale*-0.25) 0 1;
asFaceCreateCtrlBox "Cheek_L" ($scale*0.25) 0 1;
asFaceCreateCtrlBox "Nose_R" ($scale*-0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Nose_L" ($scale*0.25) ($scale*-0.22) 1;
asFaceCreateCtrlBox "Mouth_M" 0 ($scale*-0.4) 2;
asFaceCreateCtrlBox "MouthCorner_R" ($scale*-0.25) ($scale*-1) 0;
asFaceCreateCtrlBox "MouthCorner_L" ($scale*0.25) ($scale*-1) 0;

scale -r 2 2 2 ctrlBoxMouth_M;

setAttr -l 0 -k 1 ctrlEye_L.sx;setAttr -l 0 -k 1 ctrlEye_L.sy;setAttr -l 0 -k 1 ctrlEye_L.sz;
setAttr -l 0 -k 1 ctrlEye_R.sx;setAttr -l 0 -k 1 ctrlEye_R.sy;setAttr -l 0 -k 1 ctrlEye_R.sz;

$tempString=`listAttr -k ctrlBox`;
for ($i=0;$i<size($tempString);$i++)
	setAttr -k 0 -cb 1 ("ctrlBox."+$tempString[$i]);

delete ctrlBoxTemplate;

//Phonemes
$tempString[0]=`curve -d 1 -p -0.922009 0 1 -p -0.176985 0 -0.989507 -p 0.194834 0 -0.989507 -p 0.934309 0 1 -p 0.572202 0 1 -p 0.39323 0 0.493605 -p -0.389254 0 0.493605 -p -0.56129 0 1 -p -0.922009 0 1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8`;
rename $tempString[0] ctrlPhonemes_M;
sets -add FaceControlSet ctrlPhonemes_M;
$tempString[0]=`curve -d 1 -p -0.303236 0 0.224453 -p -0.00217431 0 -0.693995 -p 0.305825 0 0.224453 -p -0.303236 0 0.224453 -k 0 -k 1 -k 2 -k 3`;
rename $tempString[0] ctrlPhonemes_M1;
parent -add -s ctrlPhonemes_MShape1 ctrlPhonemes_M;
delete ctrlPhonemes_M1;
rotate -r -p 0 0 0 -os 90 0 0 ctrlPhonemes_M.cv[0:99];
scale -r -p 0 0 0 ($scale*0.06) ($scale*0.06) ($scale*0.06) ctrlPhonemes_M.cv[0:99];
parent ctrlPhonemes_M ctrlBox;
setAttr ctrlPhonemes_M.t -type float3 0 0 0;
setAttr ctrlPhonemes_MShape.overrideEnabled 1;
setAttr ctrlPhonemes_MShape.overrideColor 17;
move -r 0 ($scale*-0.81) 0 ;
asLockAttr ctrlPhonemes_M 1 1 1 1;
reorder -relative -2 ctrlPhonemes_M;

spaceLocator -n tempLoc;
setAttr tempLoc.v 0;
createNode -n tempLocFlip -p FaceMotionSystem transform;
parent tempLoc tempLocFlip;
select ctrlBox;
}

global proc asFaceEyeBall ()
{
int $lowerEyeLidMainNumCVs=`getAttr lowerEyeLidMainCurve.spans`+1;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $eyeBallPos[3]=`xform -q -ws -t FitEyeBall`;
float $posA[],$posB[];
float $pos[3];
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
string $tempString[],$ffds[];
string $ffdLattice,$ffdBase;	

//create FaceUpperLower first
for ($a=0;$a<3;$a++)
	{
	if ($a==0) $upperLower="upper";
	if ($a==1) $upperLower="middle";
	if ($a==2) $upperLower="lower";

	createNode -n ($upperLower+"FaceJointOffset_M") -p Face_M transform;
	joint -n ($upperLower+"FaceJoint_M");
	setAttr -type float3 ($upperLower+"FaceJointOffset_M.s") ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
	$posA=`xform -q -ws -t lowerEyeLidMainCurve.cv[$lowerEyeLidMainNumCVs/2]`;
	$posB=`xform -q -ws -t JawPivot`;
	xform -ws -t 0 $posA[1] $posB[2] ($upperLower+"FaceJointOffset_M");
	move -r 0 (($faceFitScale/-10.0)*$a) 0 ($upperLower+"FaceJointOffset_M");

	$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 180 -r 4 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
	rename $tempString[0] ($upperLower+"Face"+"_M");
	connectAttr ctrlBox.UpMidLoCtrlVis ($upperLower+"Face"+"_MShape.overrideVisibility");
	scale -r -p 0 0 0 (-3.2*$posB[0]/$faceFitScale) (-3.2*$posB[0]/$faceFitScale) (-3.2*$posB[0]/$faceFitScale) ($upperLower+"Face"+"_M.cv[0:99]");
	rotate -r 0 -90 0 ($upperLower+"Face"+"_M.cv[0:99]");
	sets -add FaceControlSet ($upperLower+"Face"+"_M");
	setAttr ($upperLower+"Face"+"_MShape.overrideEnabled") 1;
	setAttr ($upperLower+"Face"+"_MShape.overrideColor") 17;
	createNode -n ($upperLower+"FaceOffset_M") transform;
	parent ($upperLower+"Face"+"_M") ($upperLower+"FaceOffset_M");
	parent ($upperLower+"FaceOffset_M") Regionscontrols;
	asAlign ($upperLower+"FaceOffset_M") ($upperLower+"FaceJoint_M") 1 0 0 0;
//	parentConstraint ($upperLower+"Face"+"_M") ($upperLower+"FaceJoint_M");
	connectAttr ($upperLower+"Face"+"_M.t") ($upperLower+"Face"+"Joint_M.t");
	connectAttr ($upperLower+"Face"+"_M.r") ($upperLower+"Face"+"Joint_M.r");
	connectAttr ($upperLower+"Face"+"_M.s") ($upperLower+"Face"+"Joint_M.s");
	setAttr -type float3 ($upperLower+"FaceOffset_M.s") ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);

//	skinCluster -e -dr 4 -lw false -wt 0 -ai ($upperLower+"FaceJoint_M") $skinCluster;
	}



createNode -n EyeSetup -p FaceDeformationSetups transform;
string $eye,$eyeBallSkinCluster;
string $eyeGeos[];

//EyeAimSetup
createNode -n EyeAimSetup -p EyeSetup transform;
createNode -n EyeAimFollowHead -p EyeAimSetup transform;
createNode -n EyeAimStatic -p EyeAimSetup transform;
parentConstraint $headJoint EyeAimFollowHead;
asAlign EyeAimStatic $headJoint 1 1 0 0;
//scaleConstraint $headJoint EyeAimFollowHead;
connectAttr MainAndHeadScaleMultiplyDivide.output EyeAimFollowHead.s;
$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] AimEye_M;
setAttr AimEye_MShape.overrideEnabled 1;
connectAttr ctrlBox.AimCtrlVis AimEye_MShape.overrideVisibility;
//connectAttr ctrlBox.AimCtrlColor AimEye_MShape.overrideColor;
setAttr AimEye_MShape.overrideColor 17;
sets -add FaceControlSet AimEye_M;
//scale -r -p 0 0 0 ($scale/10.0) ($scale/10.0) ($scale/10.0) AimEye_M.cv[0:4];
createNode -n AimAimAt -p EyeAimSetup transform;
xform -ws -t 0 $eyeBallPos[1] $eyeBallPos[2] AimAimAt;
//aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject AimAimAt AimAimAt AimEye_M;
//setAttr -k 0 AimEye_M.rx;setAttr -k 0 AimEye_M.ry;setAttr -k 0 AimEye_M.rz;
createNode -n AimEyeOffset_M transform;
createNode -n AimEyeFollow_M transform;
parent AimEyeFollow_M Aimcontrols;
asAlign AimEyeFollow_M $headJoint 1 1 0 0;
parent AimEye_M AimEyeOffset_M;
setAttr -type float3 AimEyeOffset_M.s ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
asAlign AimEyeOffset_M AimEyeFollow_M 1 0 0 0;
parent AimEyeOffset_M AimEyeFollow_M;
xform -ws -t 0 $eyeBallPos[1] ($eyeBallPos[2]+$scale) AimEyeOffset_M;
createNode -n AimEyeUpVec transform;
parent AimEyeUpVec EyeAimFollowHead;

addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 AimEye_M;
createNode -n eyeAimFollowSetRange setRange;
setAttr eyeAimFollowSetRange.minX 0;setAttr eyeAimFollowSetRange.minY 1;
setAttr eyeAimFollowSetRange.maxX 1;setAttr eyeAimFollowSetRange.maxY 0;
setAttr eyeAimFollowSetRange.oldMinX 0;setAttr eyeAimFollowSetRange.oldMinY 0;
setAttr eyeAimFollowSetRange.oldMaxX 10;setAttr eyeAimFollowSetRange.oldMaxY 10;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueX;
connectAttr AimEye_M.follow eyeAimFollowSetRange.value.valueY;
//parentConstraint -mo $headJoint FaceGroup AimEyeFollow_M;
parentConstraint $headJoint EyeAimStatic AimEyeFollow_M;
connectAttr eyeAimFollowSetRange.outValue.outValueY AimEyeFollow_M_parentConstraint1.EyeAimStaticW1;
connectAttr eyeAimFollowSetRange.outValue.outValueX ("AimEyeFollow_M_parentConstraint1."+$headJoint+"W0");
//scaleConstraint $headJoint AimEyeFollow_M;
//connectAttr MainAndHeadScaleMultiplyDivide.output AimEyeFollow_M.s;

for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) $side="_R"; else $side="_L";

	select FaceDeformationSystemFollowHead;
	joint -n ("Eye"+$side);
	setAttr ("Eye"+$side+".rotateOrder") 2;
	xform -ws -t ($eyeBallPos[0]*$b) $eyeBallPos[1] $eyeBallPos[2] ("Eye"+$side);
	delete `orientConstraint FitEyeBall  ("Eye"+$side)`;
	makeIdentity -a 1 -t 0 -r 1 -s 0 ("Eye"+$side);
	if ($side=="_L")
		setAttr Eye_L.jointOrientY (`getAttr Eye_L.jointOrientY`*-1);
//	setAttr ("Eye"+$side+".segmentScaleCompensate") 0;
	$eyeJoint="Eye"+$side;

	if ($side=="_L" && `objExists FitEyeBallLeft`)
		{
		$pos=`xform -q -ws -t FitEyeBallLeft`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("Eye"+$side);
		}

	$eye=`textField -q -tx ("asFaceEye"+$side+"TextField")`;
	if ($eye=="")
		continue;
	tokenize $eye " " $tempString;
	clear $eyeGeos;
	for ($i=0;$i<size($tempString);$i++)
		$eyeGeos[$i]=$tempString[$i];

	for ($i=0;$i<size($eyeGeos);$i++)
		{
		$haveSkinCluster=0;
		$historyNodes=`listHistory $eyeGeos[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$eyeBallSkinCluster=$historyNodes[$y];
				}
	
		if ($haveSkinCluster)
			{
			skinCluster -e -lw true -wt 0 -ai $eyeJoint $eyeBallSkinCluster;
			if (`attributeExists lockInfluenceWeights $eyeJoint`)
				setAttr ($eyeJoint+".lockInfluenceWeights") 0;
			skinPercent -tv $eyeJoint 1 $eyeBallSkinCluster $eyeGeos[$i];
			}
		else
			{
			select $eyeJoint $eyeGeos[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			for ($y=0;$y<size($tempString);$y++)
				rename $tempString[$y] ("eyeSC"+$side);
			}
		}

	addAttr -k 0 -ln eyeRotateSideFactor -at double -dv 30 ("ctrlEye"+$side);
	addAttr -k 0 -ln eyeRotateUpDownFactor -at double -dv -30 ("ctrlEye"+$side);
	createNode -n ("eyeRotateMDP"+$side) multiplyDivide;
	connectAttr ("ctrlEye"+$side+".tx") ("eyeRotateMDP"+$side+".input1X");
	connectAttr ("ctrlEye"+$side+".eyeRotateSideFactor") ("eyeRotateMDP"+$side+".input2X");
	connectAttr ("ctrlEye"+$side+".ty") ("eyeRotateMDP"+$side+".input1Y");
	connectAttr ("ctrlEye"+$side+".eyeRotateUpDownFactor") ("eyeRotateMDP"+$side+".input2Y");

	//Look-at
	createNode -n ("EyeOffset"+$side) -p ("Eye"+$side) transform;
	parent ("EyeOffset"+$side) EyeAimFollowHead;

	createNode -n ("AimOffsetEye"+$side) -p AimEye_M transform;
	setAttr ("AimOffsetEye"+$side+".tx") (-1*$b);

	duplicate -n ("AimEye"+$side) AimEye_M;
	delete `listRelatives -c -fullPath -type transform ("AimEye"+$side)`;
	parent -r ("AimEye"+$side) ("AimOffsetEye"+$side);
	connectAttr ctrlBox.AimCtrlVis ("AimEye"+$side+"Shape.overrideVisibility");
//	connectAttr ctrlBox.AimCtrlColor ("AimEye"+$side+"Shape.overrideColor");

	$pos=`xform -q -ws -t AimEye_MShape.cv[4]`;
	$pos[0]*=$b;
	xform -ws -t $pos[0] ($pos[1]+($scale*0.03)) $pos[2] ("AimEye"+$side+".cv[0]");
	xform -ws -t $pos[0] ($pos[1]+($scale*-0.03)) $pos[2] ("AimEye"+$side+".cv[1]");
	xform -ws -t $pos[0] $pos[1] $pos[2] ("AimEye"+$side+".cv[2]");
	xform -ws -t ($pos[0]+($scale*0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[3]");
	xform -ws -t ($pos[0]+($scale*-0.03)) $pos[1] $pos[2] ("AimEye"+$side+".cv[4]");

	duplicate -n ("EyeAim"+$side) ("EyeOffset"+$side);
//	setAttr ("EyeAim"+$side+".rotateOrder") `getAttr ("Eye"+$side+".rotateOrder")`;
	parent ("EyeAim"+$side) ("EyeOffset"+$side);

	createNode -n ("EyeAimAdd"+$side) plusMinusAverage;
	connectAttr ("EyeAim"+$side+".rx") ("EyeAimAdd"+$side+".input3D[0].input3Dx");
	connectAttr ("EyeAim"+$side+".ry") ("EyeAimAdd"+$side+".input3D[0].input3Dy");
	connectAttr ("EyeAim"+$side+".rz") ("EyeAimAdd"+$side+".input3D[0].input3Dz");
	connectAttr ("eyeRotateMDP"+$side+".outputY") ("EyeAimAdd"+$side+".input3D[1].input3Dx");
	connectAttr ("eyeRotateMDP"+$side+".outputX") ("EyeAimAdd"+$side+".input3D[1].input3Dy");
	connectAttr -f ("EyeAimAdd"+$side+".output3D.output3Dx") ("Eye"+$side+".rx");
	connectAttr -f ("EyeAimAdd"+$side+".output3D.output3Dy") ("Eye"+$side+".ry");
	connectAttr -f ("EyeAimAdd"+$side+".output3D.output3Dz") ("Eye"+$side+".rz");

	aimConstraint -aimVector 0 0 1 -worldUpType objectrotation -worldUpObject AimEyeUpVec -worldUpVector 0 1 0 ("AimEye"+$side) ("EyeAim"+$side);
	parent -w ("EyeAim"+$side);
	asAlign ("EyeOffset"+$side) ("EyeAim"+$side) 1 1 0 0;
	parent ("EyeAim"+$side) ("EyeOffset"+$side);
//	connectAttr eyeAimSetRange.outValue.outValueX ("EyeAimBlend"+$side+".blender");
	}

//LatticeGroups for non-spherical eyes
$ffds=`ls -type ffd`;
for ($b=1;$b>-2;$b=$b-2)
	{
	if (!`objExists FitEyeBall`)
		continue;
	if ($b==1) $side="_R"; else $side="_L";

	createNode -n ("EyeLattices"+$side) -p EyeSetup transform;
	pointConstraint ("Eye"+$side) ("EyeLattices"+$side);
	scaleConstraint ("Eye"+$side) ("EyeLattices"+$side);
	orientConstraint $headJoint ("EyeLattices"+$side);

	for ($i=0;$i<size($ffds);$i++)
		if (`attributeExists ("asNonSphereLattice"+$side) $ffds[$i]`)
			{
			$tempString=`listConnections -s 1 -d 0 ($ffds[$i]+".deformedLattice.deformedLatticeMatrix")`;
			$ffdLattice=$tempString[0];
			$tempString=`listConnections -s 1 -d 0 ($ffds[$i]+".baseLattice.baseLatticeMatrix")`;
			$ffdBase=$tempString[0];
			parent $ffdLattice $ffdBase ("EyeLattices"+$side);
			}
	}

select -r ctrlEye_R ctrlEye_L;
}

global proc asFaceEyeLid ()
{
global string $gMainProgressBar;
int $tempInts[];
int $numSelVtx,$prevNumSelVtx,$twoWayVtxInside,$lidMainVtxNr,$lidInnerVtxNr,$lidOuterVtxNr,$spans;
float $pos[],$posA[],$posB[],$values[];
float $maxValue,$maxValue2,$lidFollowMultiplier,$previousMag,$mag,$tyValueForCloseLid,$upperTyValueForCloseLid,$lowerTyValueForCloseLid;
string $upperLower,$upperLowerOpposite,$mainDroopy,$droopySuffix,$lidJoint,$eyeJoint,$maxTransform,$maxTransform2,$cmd,$leftSuffix;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$infs[],$transforms[];
string $outerVtxs[],$mainVtxs[],$innerVtxs[],$droopyVtxs[],$drivenJoints[],$rowVtxs[],$previousVtxs[];
string $upLoOuterVtxs[],$upLoMainVtxs[],$upLoInnerVtxs[],$upLoDroopyVtxs[],$innerOuterVtx[],$rowWeightedVtxs[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $skinCluster="EyeLidSC";
float $scale=`asFaceGetScale`;

setAttr ctrlEye_L.tx 0;setAttr ctrlEye_L.ty 0;
setAttr ctrlEye_R.tx 0;setAttr ctrlEye_R.ty 0;

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
duplicate -n EyeLidLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` EyeLidLayer 1 asFaceBS;
setAttr EyeLidLayer.v 1;
select Face_M EyeLidLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] EyeLidSC;
setAttr EyeLidSC.skinningMethod 1;
asReuseIntermediateMesh $geometry EyeLidLayer;

createNode -n LidSetup -p FaceDeformationSetups transform;
createNode -n TempPos transform;

//EyeRegion
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	asCreateFaceController "EyeRegion" $side 4;
	asFaceAddDrive "EyeRegionJoint" $side "EyeRegion" $side 1 {} {};
	asFaceAddDrive "EyeRegionJoint" $side "SDKEyeRegion" $side 1 {} {};
//	parent ("EyeRegionOffset"+$side) upperFace_M;
	$pos=`xform -q -ws -t ("Eye"+$side)`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeRegionOffset"+$side);
	scale -r -p $pos[0] $pos[1] $pos[2] 6 6 6 ("EyeRegion"+$side+".cv[0:7]");
//	$posB=`xform -q -ws -t NoseCorner`;
//	select ("EyeRegion"+$side+".cv[0:7]");
//	move -z $posB[2];
	asFacePlaceCtrlByProjection ("EyeRegion"+$side);
	asAlign ("EyeRegionJointOffset"+$side) ("EyeRegion"+$side) 1 0 0 0;
	parent ("EyeRegionOffset"+$side) upperFace_M;

	pointConstraint ("EyeRegion"+$side) ("Eye"+$side);
//	connectAttr ("EyeRegion"+$side+".sx") ("Eye"+$side+".sz");
//	connectAttr ("EyeRegion"+$side+".sy") ("Eye"+$side+".sy");
//	connectAttr ("EyeRegion"+$side+".sz") ("Eye"+$side+".sx");
	createNode -n ("EyeRegionScale"+$side) transform;
	parent ("EyeRegionScale"+$side) ("EyeRegion"+$side);
	setAttr -type float3 ("EyeRegionScale"+$side+".t") 0 0 0; 
	scaleConstraint ("EyeRegionScale"+$side) ("Eye"+$side);
	if (`objExists FaceFitEyeLidDroopy`)
		{
		createNode -n ("LidDroopyDrive"+$side) -p ("EyeRegion"+$side) transform;
		createNode -n ("LidDroopy"+$side) -p ("LidDroopyDrive"+$side) transform;
		}
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	createNode -n ("LidSetup"+$side) transform;
	asAlign ("LidSetup"+$side) ("Eye"+$side) 1 1 0 0;
//	parentConstraint ("EyeRegion"+$side) ("LidSetup"+$side);
//	scaleConstraint ("EyeRegion"+$side) ("LidSetup"+$side);
	parent ("LidSetup"+$side) FaceDeformationSetups;
	}

//createNode -n tempNearestPointOnCurve nearestPointOnCurve;

//Setup Lid
int $numLid;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
progressBar -e -st ("Setup EyeLid") -bp -ii 0 -min 0 -max 4 $gMainProgressBar;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($side=="_L" && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	$eyeJoint="Eye"+$side;

	select -cl;
	joint -n ("LidJoints"+$side);
	setAttr ("LidJoints"+$side+".segmentScaleCompensate") 0;
	asAlign ("LidJoints"+$side) $eyeJoint 1 0 0 0;
	parent ("LidJoints"+$side) Face_M;
//	parentConstraint ("EyeRegion"+$side) ("LidJoints"+$side);

//	scaleConstraint ("EyeRegion"+$side) ("LidJoints"+$side);
	skinCluster -e -dr 4 -lw true -wt 0 -ai ("LidJoints"+$side) $skinCluster;

	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blink"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("blinkCenter"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLid"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidOut"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidOut"+$side) -at double LidSetup;
//	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidFollow"+$side) -at double LidSetup;
//	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidFollow"+$side) -at double LidSetup;
//	if (`objExists FaceFitEyeLidDroopy`)
//		addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lidDroopyFollow"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("upperLidOutAuto"+$side) -at double LidSetup;
	addAttr -dv 0.0 -k 1 -smn 0 -hsn 1 -smx 1 -hsx 1 -ln ("lowerLidOutAuto"+$side) -at double LidSetup;

	createNode -n ("blinkCenterReverse"+$side) reverse;
	connectAttr ("LidSetup.blinkCenter"+$side) ("blinkCenterReverse"+$side+".inputX");

	createNode -n ("LidLocs"+$side) transform;
	setAttr ("LidLocs"+$side+".inheritsTransform") 0;
	parent ("LidLocs"+$side) LidSetup;
//	setAttr -l 1 ("LidLocs"+$side+".v") 0;
	createNode -n ("LidCurves"+$side) transform;
//	parent ("LidCurves"+$side) LidSetup;//nope, will not work with headscaling
//	parent ("LidCurves"+$side) ("LidSetup"+$side);//nope, will not work with EyeRegion
	parent ("LidCurves"+$side) FaceDeformationSetups;
	for ($a=0;$a<2;$a++)
		{
		if ($a==0) {$mainDroopy="Main";$droopySuffix="";}
		if ($a==1) {$mainDroopy="Droopy";$droopySuffix="Droopy";}
		if ($mainDroopy=="Droopy" && !`objExists FaceFitEyeLidDroopy`)
			continue;

		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			progressBar -e -s 1 $gMainProgressBar;
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			duplicate -n ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) ($upperLower+"EyeLid"+$mainDroopy+"Curve"+$leftSuffix);
			rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.004 ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side);	

			//rebuild another curve, for getting good placements for the cv`s
			rebuildCurve -n ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurve"+$leftSuffix) -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.0001 ($upperLower+"EyeLid"+$mainDroopy+"Curve"+$leftSuffix);
			connectAttr -f ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurve"+$leftSuffix+"Shape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
			setAttr tempPointOnCurveInfo.parameter 0.25;
			$pos=`getAttr tempPointOnCurveInfo.position`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[1]");
			setAttr tempPointOnCurveInfo.parameter 0.75;
			$pos=`getAttr tempPointOnCurveInfo.position`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[3]");
			disconnectAttr ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurve"+$leftSuffix+"Shape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
			delete ($upperLower+"EyeLid"+$mainDroopy+"RebuiltSamplerCurve"+$leftSuffix);

			//Might need to flip over Left curve here
			if ($side=="_L" && $leftSuffix=="")
				scale -r -p 0 0 0 -1 1 1 ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[0:4]");
			parent ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) ("LidCurves"+$side);

			//make Tweaked-Shape, so each cv is zero position at the correct place
			createNode -n ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"TweakedShape") -p ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) nurbsCurve;
			connectAttr -f ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"Shape.worldSpace[0]") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"TweakedShape.create");
			setAttr ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+"Shape.intermediateObject") 1;

			duplicate -n ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side) ($upperLower+"EyeLid"+$mainDroopy+"Curve"+$leftSuffix);
			parent -w ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side);
			if ($side=="_L" && $leftSuffix=="")
				scale -r -p 0 0 0 -1 1 1 ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+".cv[0:999]");

			duplicate -n ($upperLower+"EyeLid"+$mainDroopy+"Curve1"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side);
			parent ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side) ("LidCurves"+$side);

			if ($mainDroopy=="Main")
				{
				duplicate -n ($upperLower+"EyeLidOuterCurve1"+$side) ($upperLower+"EyeLidOuterCurve"+$leftSuffix);
				parent -w ($upperLower+"EyeLidOuterCurve1"+$side);
				if ($side=="_L" && $leftSuffix=="")
					scale -r -p 0 0 0 -1 1 1 ($upperLower+"EyeLidOuterCurve1"+$side+".cv[0:999]");
				}

			$numLid=`getAttr ($upperLower+"EyeLid"+$mainDroopy+"Curve"+$leftSuffix+".spans")`+1;
			for ($i=0;$i<$numLid;$i++)
				{
				select -cl;
				joint -n ($upperLower+"Lid"+$mainDroopy+$i+$side);
				setAttr ($upperLower+"Lid"+$mainDroopy+$i+$side+".radius") ($scale/10.0);
				$pos=`xform -q -ws -t ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+".cv["+$i+"]")`;
				xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+$i+$side);
				parent ($upperLower+"Lid"+$mainDroopy+$i+$side) ("LidJoints"+$side);

				spaceLocator -n ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side);
				setAttr -type float3 ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side+".localScale") ($scale/100.0) ($scale/100.0) ($scale/100.0);
				parent ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side) ("LidLocs"+$side);
				createNode -n ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side) pointOnCurveInfo;
				setAttr ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".turnOnPercentage") 1;
				setAttr ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".parameter") ($i/($numLid-1.00));
				connectAttr ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".position") ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side+".translate");
				connectAttr ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+"Shape.worldSpace[0]") ($upperLower+"Lid"+$mainDroopy+"Poci"+$i+$side+".inputCurve");

				if ($mainDroopy=="Main")
					{
					createNode -n ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side) transform;
					parent ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side) ("LidSetup"+$side);
					setAttr -type float3 ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side+".t") 0 0 0;
					aimConstraint -worldUpType objectrotation -worldUpObject ("LidSetup"+$side) -worldUpVector 0 1 0 ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side) ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side);
					createNode -n ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side) -p ($upperLower+"Lid"+$mainDroopy+$i+"Aim"+$side) transform;
					xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side);
					parentConstraint ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side) ($upperLower+"Lid"+$mainDroopy+$i+$side);
					}
				else
					pointConstraint ($upperLower+"Lid"+$mainDroopy+"Loc"+$i+$side) ($upperLower+"Lid"+$mainDroopy+$i+$side);
				}

			if ($mainDroopy=="Main")
				{
				for ($i=0;$i<$numLid;$i++)
					{
					//LidOut
					if ($i>0 && $i<$numLid-1)
						{
						createNode -n ($upperLower+"LidOutMult"+$i+$side) multiplyDivide;
						float $factor;
						if ($i<($numLid/2)) $factor=`smoothstep 0 $numLid $i`;
						else $factor=`smoothstep 0 $numLid ($numLid-1-$i)`;
						$factor=$factor*($scale/3.0);
						setAttr ($upperLower+"LidOutMult"+$i+$side+".input1X") $factor;
						connectAttr ("LidSetup."+$upperLower+"LidOut"+$side) ($upperLower+"LidOutMult"+$i+$side+".input2X");

						createNode -n ($upperLower+"LidOutMultAutoA"+$i+$side) multiplyDivide;
						setAttr ($upperLower+"LidOutMultAutoA"+$i+$side+".input1X") $factor;
						connectAttr ("LidSetup."+$upperLower+"LidOutAuto"+$side) ($upperLower+"LidOutMultAutoA"+$i+$side+".input2X");

						createNode -n ($upperLower+"LidOutMultAutoB"+$i+$side) multiplyDivide;
						connectAttr ($upperLower+"LidOutMultAutoA"+$i+$side+".outputX") ($upperLower+"LidOutMultAutoB"+$i+$side+".input1X");
						connectAttr ("LidSetup.blink"+$side) ($upperLower+"LidOutMultAutoB"+$i+$side+".input2X");

						createNode -n ($upperLower+"LidOut"+$i+$side) plusMinusAverage;
						setAttr ($upperLower+"LidOut"+$i+$side+".input1D[0]") `getAttr ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side+".tx")`;
						connectAttr ($upperLower+"LidOutMult"+$i+$side+".outputX") ($upperLower+"LidOut"+$i+$side+".input1D[1]");
						connectAttr ($upperLower+"LidOutMultAutoB"+$i+$side+".outputX") ($upperLower+"LidOut"+$i+$side+".input1D[2]");

						connectAttr ($upperLower+"LidOut"+$i+$side+".output1D") ($upperLower+"Lid"+$mainDroopy+$i+"AimEnd"+$side+".tx");
						}
					}
			
				if ($upperLower=="upper")
					duplicate -n ("closedLid"+$mainDroopy+"Curve2"+$side) ("upperLid"+$mainDroopy+"Curve2"+$side);
				if ($upperLower=="lower")
					{
					select -r ("upperLid"+$mainDroopy+"Curve2"+$side) ("lowerLid"+$mainDroopy+"Curve2"+$side) ("closedLid"+$mainDroopy+"Curve2"+$side);
					blendShape -n ("closedLidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;
					connectAttr ("LidSetup.blinkCenter"+$side) ("closedLidCurveCloseBS"+$side+".upperLid"+$mainDroopy+"Curve2"+$side);
					connectAttr ("blinkCenterReverse"+$side+".outputX") ("closedLidCurveCloseBS"+$side+".lowerLid"+$mainDroopy+"Curve2"+$side);
					}
				duplicate -n ($upperLower+"LidCurveClose"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side);
				select -r ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side) ("closedLid"+$mainDroopy+"Curve2"+$side) ($upperLower+"LidCurveClose"+$side);
				blendShape -n ($upperLower+"LidCurveCloseBS"+$side) -frontOfChain -w 0 0.5 -w 1 0.5;

				createNode -n ($upperLower+"CloseLidCurveMixer"+$side) plusMinusAverage;
				connectAttr ("LidSetup.blink"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[0]");
				connectAttr ("LidSetup."+$upperLower+"Lid"+$side) ($upperLower+"CloseLidCurveMixer"+$side+".input1D[1]");
				connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"LidCurveCloseBS"+$side+".closedLid"+$mainDroopy+"Curve2"+$side);

				createNode -n ($upperLower+"blinkReverse"+$side) reverse;
				connectAttr ($upperLower+"CloseLidCurveMixer"+$side+".output1D") ($upperLower+"blinkReverse"+$side+".inputX");
				connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"LidCurveCloseBS"+$side+"."+$upperLower+"Lid"+$mainDroopy+"Curve2"+$side);
				}

			//wireDeform in WorldSpace, since wireDefomer does not work well with 180 rotation, and extreme scaling.
			createNode -n ("LidWireWS"+$side) -p ("LidCurves"+$side) transform;
			duplicate -n ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side);
			parent ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side) ("LidWireWS"+$side);
			if ($mainDroopy=="Main")
				{
				wire -n ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side) -dds 0 $scale -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"LidCurveClose"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side);
				connectAttr ($upperLower+"blinkReverse"+$side+".outputX") ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side+".scale[0]");
				}
			else
				wire -n ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side) -dds 0 $scale -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ($upperLower+"LidDroopyCurve2"+$side) ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side);
//			setAttr ($upperLower+"Lid"+$mainDroopy+"CurveWire"+$side+".dropoffDistance[0]") 20;
			connectAttr ($upperLower+"Lid"+$mainDroopy+"Curve1OS"+$side+"Shape.worldSpace[0]") ($upperLower+"Lid"+$mainDroopy+"Curve1"+$side+"Shape.create");

			//inner & Outer Lid
			if ($upperLower=="upper")
				{
				asPingPong ("upperLid"+$mainDroopy+"Curve2"+$side+".ep[0]") ("innerLid"+$droopySuffix) 1 $side 3 1 0;
				setAttr -type float3 ("innerLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;

				asPingPong ("upperLid"+$mainDroopy+"Curve2"+$side+".ep[2]") ("outerLid"+$droopySuffix) 1 $side 3 1 0;
				setAttr -type float3 ("outerLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;
				}

			//Lid
			$pos=`xform -q -ws -t ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".ep[1]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
			delete `geometryConstraint ($upperLower+"EyeLid"+$mainDroopy+"Curve1"+$side) TempPos`;
			asPingPong TempPos ($upperLower+"Lid"+$droopySuffix) 1 $side 1 1 0;
			if ($mainDroopy=="Main" && $upperLower=="upper")
				asFaceHalfMoonCurve ($upperLower+"Lid"+$droopySuffix+$side) 90;
			if ($mainDroopy=="Main" && $upperLower=="lower")
				asFaceHalfMoonCurve ($upperLower+"Lid"+$droopySuffix+$side) -90;

			setAttr -type float3 ($upperLower+"Lid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;

			//inner (inbetween) Lid
			$pos=`xform -q -ws -t ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[1]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
			delete `geometryConstraint ($upperLower+"EyeLid"+$mainDroopy+"Curve1"+$side) TempPos`;
			asPingPong TempPos ($upperLower+"InnerLid"+$droopySuffix) 1 $side 2 1 0;
			setAttr -type float3 ($upperLower+"InnerLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;
			createNode -n ($upperLower+"InnerLid"+$droopySuffix+"ConstrainedOffset"+$side) -p LidSetup transform;
			createNode -n ($upperLower+"InnerLid"+$droopySuffix+"Constrained"+$side) -p ($upperLower+"InnerLid"+$droopySuffix+"ConstrainedOffset"+$side) transform;
			asAlign ($upperLower+"InnerLid"+$droopySuffix+"ConstrainedOffset"+$side) ($upperLower+"InnerLid"+$droopySuffix+$side) 1 0 0 0;
			asFaceAddDrive ($upperLower+"InnerLid"+$droopySuffix+"Joint") $side ($upperLower+"InnerLid"+$droopySuffix+"Constrained") $side 1 {} {};
			parentConstraint -mo ($upperLower+"Lid"+$droopySuffix+"Joint"+$side) ("innerLid"+$droopySuffix+"Joint"+$side) ($upperLower+"InnerLid"+$droopySuffix+"Constrained"+$side);
//			parentConstraint -mo ($upperLower+"Lid"+$droopySuffix+"Joint"+$side) ($upperLower+"InnerLid"+$droopySuffix+"Constrained"+$side);
			setAttr ($upperLower+"InnerLid"+$droopySuffix+"Constrained"+$side+"_parentConstraint1.innerLid"+$droopySuffix+"Joint"+$side+"W1") 0.5;

			//outer (inbetween) Lid
			$pos=`xform -q -ws -t ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[3]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
			delete `geometryConstraint ($upperLower+"EyeLid"+$mainDroopy+"Curve1"+$side) TempPos`;
			asPingPong TempPos ($upperLower+"OuterLid"+$droopySuffix) 1 $side 2 1 0;
			setAttr -type float3 ($upperLower+"OuterLid"+$droopySuffix+"Joint"+$side+".jointOrient") 0 0 0;

			createNode -n ($upperLower+"OuterLid"+$droopySuffix+"ConstrainedOffset"+$side) -p LidSetup transform;
			createNode -n ($upperLower+"OuterLid"+$droopySuffix+"Constrained"+$side) -p ($upperLower+"OuterLid"+$droopySuffix+"ConstrainedOffset"+$side)  transform;
			asAlign ($upperLower+"OuterLid"+$droopySuffix+"ConstrainedOffset"+$side) ($upperLower+"OuterLid"+$droopySuffix+$side) 1 0 0 0;
			asFaceAddDrive ($upperLower+"OuterLid"+$droopySuffix+"Joint") $side ($upperLower+"OuterLid"+$droopySuffix+"Constrained") $side 1 {} {};
			parentConstraint -mo ($upperLower+"Lid"+$droopySuffix+"Joint"+$side) ("outerLid"+$droopySuffix+"Joint"+$side) ($upperLower+"OuterLid"+$droopySuffix+"Constrained"+$side);
//			parentConstraint -mo ($upperLower+"Lid"+$droopySuffix+"Joint"+$side) ($upperLower+"OuterLid"+$droopySuffix+"Constrained"+$side);
			setAttr ($upperLower+"OuterLid"+$droopySuffix+"Constrained"+$side+"_parentConstraint1.outerLid"+$droopySuffix+"Joint"+$side+"W1") 0.5;

			connectAttr ("outerLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[4]");
			connectAttr ($upperLower+"OuterLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[3]");
			connectAttr ($upperLower+"Lid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[2]");
			connectAttr ($upperLower+"InnerLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[1]");
			connectAttr ("innerLid"+$droopySuffix+"Joint"+$side+".t") ($upperLower+"Lid"+$mainDroopy+"Curve2"+$side+".cv[0]");


			//now after binding the curve, we can parent the joints
			if ($upperLower=="upper")
				parent ("innerLid"+$droopySuffix+"JointOffset"+$side) ("outerLid"+$droopySuffix+"JointOffset"+$side) FaceDeformationSetups;
			parent ($upperLower+"Lid"+$droopySuffix+"JointOffset"+$side) ($upperLower+"InnerLid"+$droopySuffix+"JointOffset"+$side) ($upperLower+"OuterLid"+$droopySuffix+"JointOffset"+$side) FaceDeformationSetups;

			if ($mainDroopy=="Droopy")
				continue;

			// LidControlFollow
			createNode -n ($upperLower+"Follow"+$side) -p ("LidSetup"+$side) transform;
			createNode -n ($upperLower+"FollowMultiplyDivide1"+$side) multiplyDivide;
			connectAttr ("Eye"+$side+".ry") ($upperLower+"FollowMultiplyDivide1"+$side+".input1X");//upDown
			connectAttr ("Eye"+$side+".rx") ($upperLower+"FollowMultiplyDivide1"+$side+".input1Y");//side
			createNode -n ($upperLower+"FollowMultiplyDivide2"+$side) multiplyDivide;
			connectAttr -f ($upperLower+"FollowMultiplyDivide1"+$side+".outputX") ($upperLower+"FollowMultiplyDivide2"+$side+".input1X");
			connectAttr -f ($upperLower+"FollowMultiplyDivide1"+$side+".outputY") ($upperLower+"FollowMultiplyDivide2"+$side+".input1Y");
			setAttr ($upperLower+"FollowMultiplyDivide2"+$side+".input2") -type float3 0.01 0.01 0.01;
			connectAttr -f ($upperLower+"FollowMultiplyDivide2"+$side+".outputX") ($upperLower+"Follow"+$side+".tx");
			connectAttr -f ($upperLower+"FollowMultiplyDivide2"+$side+".outputY") ($upperLower+"Follow"+$side+".ty");
			createNode -n ($upperLower+"FollowWs1"+$side) -p ("LidSetup"+$side) transform;
			xform -ws -ro 0 0 0 ($upperLower+"FollowWs1"+$side);
			createNode -n ($upperLower+"FollowWs2"+$side) -p ($upperLower+"FollowWs1"+$side) transform;
			pointConstraint ($upperLower+"Follow"+$side) ($upperLower+"FollowWs2"+$side);
			}
		}
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	$posA=`xform -q -ws -t upperLid_R`;
	$posB=`xform -q -ws -t lowerLid_R`;
	$lidFollowMultiplier=$posA[1]-$posB[1];
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		asFaceAddDrive ($upperLower+"LidJoint") $side ($upperLower+"FollowWs2") $side ($lidFollowMultiplier*0.125) {"tx"} {"tx"};
		asFaceAddDrive ($upperLower+"LidJoint") $side ($upperLower+"FollowWs2") $side ($lidFollowMultiplier*-0.25) {"ty"} {"ty"};
		asFaceAddDrive ($upperLower+"LidJoint") $side ($upperLower+"FollowWs2") $side ($lidFollowMultiplier*0.125) {"tz"} {"tz"};
		}
	}

//ctrlLid attributes
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	if (!`attributeExists blink ("ctrlEye"+$side)`)
		addAttr -ln "blink"  -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkCenter ("ctrlEye"+$side)`)
		addAttr -ln "blinkCenter" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLid ("ctrlEye"+$side)`)
		addAttr -ln "upperLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLid ("ctrlEye"+$side)`)
		addAttr -ln "lowerLid" -k 1 -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists upperLidOut ("ctrlEye"+$side)`)
		addAttr -ln "upperLidOut" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidOut ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidOut" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkDriven ("ctrlEye"+$side)`)
		{
		addAttr -ln "eyeDriven" -k 1 -at double ("ctrlEye"+$side);
		setAttr -l 1 ("ctrlEye"+$side+".eyeDriven");
		}
	if (!`attributeExists upperLidFollow ("ctrlEye"+$side)`)
		{
		addAttr -ln "upperLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 10 ("ctrlEye"+$side);
		connectAttr -f ("ctrlEye"+$side+".upperLidFollow") ("upperFollowMultiplyDivide1"+$side+".input2Y");
		connectAttr -f ("ctrlEye"+$side+".upperLidFollow") ("upperFollowMultiplyDivide1"+$side+".input2X");
		}
	if (!`attributeExists lowerLidFollow ("ctrlEye"+$side)`)
		{
		addAttr -ln "lowerLidFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 3 ("ctrlEye"+$side);
		connectAttr -f ("ctrlEye"+$side+".lowerLidFollow") ("lowerFollowMultiplyDivide1"+$side+".input2Y");
		connectAttr -f ("ctrlEye"+$side+".lowerLidFollow") ("lowerFollowMultiplyDivide1"+$side+".input2X");
		}
	if (`objExists FaceFitEyeLidDroopy`)
		if (!`attributeExists lidDroopyFollow ("ctrlEye"+$side)`)
			addAttr -ln "lidDroopyFollow" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists blinkDriven ("ctrlEye"+$side)`)
		{
		addAttr -ln "blinkDriven" -k 1 -at double ("ctrlEye"+$side);
		setAttr -l 1 ("ctrlEye"+$side+".blinkDriven");
		}
	if (!`attributeExists upperLidOutAuto ("ctrlEye"+$side)`)
		addAttr -ln "upperLidOutAuto" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);
	if (!`attributeExists lowerLidOutAuto ("ctrlEye"+$side)`)
		addAttr -ln "lowerLidOutAuto" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlEye"+$side);

	if (`objExists LidSetup`)
		{
		asFaceBsSdk ("ctrlEye"+$side+".blink") 10 ("LidSetup.blink"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".blink") -10 ("LidSetup.blink"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".blinkCenter") 10 ("LidSetup.blinkCenter"+$side) 1;
		setAttr ("ctrlEye"+$side+".blinkCenter") 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") 10 ("LidSetup.upperLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".upperLid") -10 ("LidSetup.upperLid"+$side) -1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") 10 ("LidSetup.lowerLid"+$side) 1;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLid") -10 ("LidSetup.lowerLid"+$side) -1;

		setAttr ("LidSetup.upperLidOut"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidOut") 10 ("LidSetup.upperLidOut"+$side) 1;
		setAttr ("LidSetup.lowerLidOut"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidOut") 10 ("LidSetup.lowerLidOut"+$side) 1;
		setAttr ("LidSetup.upperLidOutAuto"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".upperLidOutAuto") 10 ("LidSetup.upperLidOutAuto"+$side) 1;
		setAttr ("LidSetup.lowerLidOutAuto"+$side) 0;
		asFaceBsSdk ("ctrlEye"+$side+".lowerLidOutAuto") 10 ("LidSetup.lowerLidOutAuto"+$side) 1;
		}

	setAttr ("ctrlEye"+$side+".blinkCenter") 2;
	}

//Drive
$drivenJoints={"upperLidDroopyJoint","upperInnerLidDroopyJoint","upperOuterLidDroopyJoint","innerLidDroopyJoint",
							 "lowerLidDroopyJoint","lowerInnerLidDroopyJoint","lowerOuterLidDroopyJoint","outerLidDroopyJoint"};
for ($i=0;$i<size($drivenJoints);$i++)
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";

		if (!`objExists FaceFitEyeLidDroopy`)
			continue;

		asFaceAddDrive $drivenJoints[$i] $side Eye $side 1 {"tx"} {"ry"};
		asFaceAddDrive $drivenJoints[$i] $side Eye $side 1 {"ty"} {"rx"};

		setAttr ("ctrlEye"+$side+".lidDroopyFollow") 5;
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 0 -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+"."+$drivenJoints[$i]+"_tx");
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v (-0.001384*$b) -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+"."+$drivenJoints[$i]+"_tx");
		setAttr ("Eye"+$side+"_"+$drivenJoints[$i]+"_tx.preInfinity") 4;
		setAttr ("Eye"+$side+"_"+$drivenJoints[$i]+"_tx.postInfinity") 4;
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 0 -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+"."+$drivenJoints[$i]+"_ty");
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v (-0.001384) -cd ("ctrlEye"+$side+".lidDroopyFollow") ("Eye"+$side+"."+$drivenJoints[$i]+"_ty");
		setAttr ("Eye"+$side+"_"+$drivenJoints[$i]+"_ty.preInfinity") 4;
		setAttr ("Eye"+$side+"_"+$drivenJoints[$i]+"_ty.postInfinity") 4;
		}

//eyeLidArea set
for ($b=1;$b>-2;$b=$b-2)
	{
	$leftSuffix="";
	if ($b==-1 && !`objExists FaceFitEyeLidMainLeft`)
		break;
	if ($b==-1 && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
	$outerVtxs=`ls -sl -fl`;
	$outerVtxs=`asobjSetCast "" $outerVtxs EyeLidLayer`;
	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidMainCurve"+$leftSuffix)`);
	$mainVtxs=`ls -sl -fl`;
	$mainVtxs=`asobjSetCast "" $mainVtxs EyeLidLayer`;
	eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidInnerCurve"+$leftSuffix)`);
	$innerVtxs=`ls -sl -fl`;
	$innerVtxs=`asobjSetCast "" $innerVtxs EyeLidLayer`;

	select $mainVtxs;
	for ($i=0;$i<20;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;
		select -d $outerVtxs $innerVtxs;
		}
	select -add $mainVtxs;
	sets -n ("eyeLidArea"+$leftSuffix);
	sets -add FaceAreas ("eyeLidArea"+$leftSuffix);
	}

//Add joint as influences
string $addInfCmd="skinCluster -e ";
for ($a=0;$a<2;$a++)
	{
	if ($a==0) $mainDroopy="Main";
	if ($a==1) $mainDroopy="Droopy";
	if ($mainDroopy=="Droopy" && !`objExists FaceFitEyeLidDroopy`)
		continue;


	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) {$upperLower="upper";}
			else {$upperLower="lower";}

			$numLid=`getAttr ($upperLower+"EyeLid"+$mainDroopy+"Curve1"+$side+".spans")`+1;
			for ($i=0;$i<$numLid;$i++)
				{
				progressBar -e -s 1 $gMainProgressBar;
				$addInfCmd+=" -ai "+$upperLower+"Lid"+$mainDroopy+$i+$side;
				}
			}
		}
	}
$addInfCmd+=" -lw false -wt 0 "+$skinCluster;
eval ($addInfCmd);

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f EyeLidLayer.outMesh closestSampler.inMesh;


//Full weight for $mainVtxs & $innerVtxs
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($side=="_L" && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";}
		else {$upperLower="lower";}

		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidMainCurve"+$leftSuffix)`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		$upLoMainVtxs=`asobjSetCast "" $tempString EyeLidLayer`;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidInnerCurve"+$leftSuffix)`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		$upLoInnerVtxs=`asobjSetCast "" $tempString EyeLidLayer`;

		for ($i=0;$i<size($upLoMainVtxs);$i++)
			{
			//MainVtxs
			$pos=`xform -q -ws -t $upLoMainVtxs[$i]`;
			if ($side=="_L" && $leftSuffix=="") $pos[0]=$pos[0]*-1;
			setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
			skinPercent -tv ($upperLower+"LidMain"+$i+$side) 1 $skinCluster ("EyeLidLayer.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			}

		//DroopyVtxs
		if (!`objExists ($upperLower+"EyeLidDroopyCurve")`)
			continue;
		$tempString[0]=`asGetFaceFitSelection ($upperLower+"EyeLidDroopyCurve"+$leftSuffix)`;
		$tempString=`stringToStringArray $tempString[0] " "`;
		$upLoDroopyVtxs=`asobjSetCast "" $tempString EyeLidLayer`;
		for ($i=0;$i<size($upLoDroopyVtxs);$i++)
			{
			$pos=`xform -q -ws -t $upLoDroopyVtxs[$i]`;
			if ($side=="_L" && $leftSuffix=="") $pos[0]=$pos[0]*-1;
			setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
			skinPercent -tv ($upperLower+"LidDroopy"+$i+$side) 1 $skinCluster ("EyeLidLayer.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
			}
		}
	}

//changing the weight-blending to be per vertex-row, to upper to lower bleeding
//(droopy still will cause row to row bleeding)
for ($b=1;$b>-2;$b=$b-2)
	{
	$leftSuffix="";
	if ($b==-1 && !`objExists FaceFitEyeLidMainLeft`)
		break;
	if ($b==-1 && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	for ($z=0;$z<2;$z++)
		{
		eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidOuterCurve"+$leftSuffix)`);
		$outerVtxs=`ls -sl -fl`;
		$outerVtxs=`asobjSetCast "" $outerVtxs EyeLidLayer`;
		eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidMainCurve"+$leftSuffix)`);
		$mainVtxs=`ls -sl -fl`;
		$mainVtxs=`asobjSetCast "" $mainVtxs EyeLidLayer`;
		eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidInnerCurve"+$leftSuffix)`);
		$innerVtxs=`ls -sl -fl`;
		$innerVtxs=`asobjSetCast "" $innerVtxs EyeLidLayer`;

		if ($z==0) $innerOuterVtx=$outerVtxs;
		if ($z==1) $innerOuterVtx=$innerVtxs;

		//traversing edgeRow is slow for dense models, so we skip this for 500+ verts, with clear $rowWeightedVtxs they will get hammered
		select ("eyeLidArea"+$leftSuffix);
		if (size(`ls -sl -fl`)>500)
			{
			print "// eyeLidArea exceed 500 verticies, using simplified skinning for this area.\n";
			break;
			}

		for ($i=0;$i<size($mainVtxs);$i++)
			{
			select $mainVtxs[$i];
			$lidMainVtxNr=`asComponentToNr $mainVtxs[$i]`;
			for ($a=0;$a<99;$a++)
				{
				ConvertSelectionToEdges;
				ConvertSelectionToVertices;
				select -d $mainVtxs;
				$tempString=`ls -sl -fl`;
				for ($y=0;$y<size($tempString);$y++)
					if (`stringArrayCount $tempString[$y] $innerOuterVtx`)
						{
						$lidOuterVtxNr=`asComponentToNr $tempString[$y]`;
						select `polySelect -q -asSelectString -shortestEdgePath $lidMainVtxNr $lidOuterVtxNr`;
						ConvertSelectionToVertices;
						select -d $mainVtxs[$i];
						if ($z==0)//no need to weight the last row, if it is Outer
							select -d $innerOuterVtx;
						$rowVtxs=`ls -sl -fl`;
						$a=99;
						$y=99;
						break;
						}
				}

			$infs=`skinPercent -ignoreBelow 0.001 -q -t EyeLidSC $mainVtxs[$i]`;
			$rowWeightedVtxs=`stringArrayCatenate $rowWeightedVtxs $rowVtxs`;

			if ($z==1)//Main to Inner just to have full weight
				{
				if (size($rowVtxs))
					skinPercent -tv $infs[0] 1 EyeLidSC $rowVtxs;
				continue;
				}

			select $mainVtxs[$i];
			clear $previousVtxs;
			for ($a=0;$a<size($rowVtxs);$a++)
				{
				ConvertSelectionToEdges;
				ConvertSelectionToVertices;
				$tempString=`ls -sl -fl`;
				select -d $previousVtxs;
				$previousVtxs=$tempString;
				$tempString=`ls -sl -fl`;
				for ($y=0;$y<size($tempString);$y++)
					if (`stringArrayCount $tempString[$y] $rowVtxs`)
						skinPercent -tv $infs[0] (1-((1.0/(size($rowVtxs)+1))*($a+1))) EyeLidSC $tempString[$y];
				}
			}
		}

	//then weigh-hammer `left-overs`
	eval ("select "+`asGetFaceFitSelection ("EyeLidInnerAreaMesh"+$leftSuffix)`);
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString EyeLidLayer`;
	select -d $rowWeightedVtxs $mainVtxs $outerVtxs $innerVtxs;
	if (size(`ls -sl`))
		weightHammerVerts;

	//Droopy falloff
	if (`objExists ($upperLower+"EyeLidDroopyCurve"+$leftSuffix)`)
		{
		eval ("select "+`asGetFaceFitSelection ("FaceFitEyeLidDroopyCurve"+$leftSuffix)`);
		$droopyVtxs=`ls -sl -fl`;
		$droopyVtxs=`asobjSetCast "" $droopyVtxs EyeLidLayer`;
		}

	if (`objExists ($upperLower+"EyeLidDroopyCurve")`)
		{
		select $droopyVtxs;
		for ($i=1;$i<99;$i++)
			{
			polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionLayer;
			select -d $droopyVtxs;
			$tempString=`ls -sl -fl`;
			for ($y=1;$y<size($tempString);$y++)
				if (`stringArrayCount $tempString[$y] $mainVtxs`)
					{
					$i=99;
					break;
					}
			}
		select -d $mainVtxs;
		//then de-select vtx on the opposite side of the face 
		$tempString=`ls -sl`;
		polySelectConstraint -m 3 -t 0x0001 -d 3 -db 0 999 -da 1 0 0 -dp (999*$b) 0 0;
		$tempString2=`ls -sl`;
		polySelectConstraint -m 0;
		select $tempString;
		select -d $tempString2;

		//polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		//select -d $droopyVtxs;
		weightHammerVerts;
		}
	}
select -cl;

//Get a more accurate $tyValueForCloseLid value
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($b==-1 && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		if ($upperLower=="upper") $tempString[0]="lowerLidMain"+(`getAttr lowerEyeLidMainCurve.spans`/2)+$side;
		if ($upperLower=="lower") $tempString[0]="upperLidMain"+(`getAttr upperEyeLidMainCurve.spans`/2)+$side;
		$posA=`xform -q -ws -t $tempString[0]`;
		$previousMag=999;
		for ($i=0;$i<999;$i++)
			{
			move -r -ls -wd 0 (($scale/-40.0)*$upperLowerFactor) 0 ($upperLower+"Lid"+$side);
			refresh;
			$tempString[0]=$upperLower+"LidMain"+(`getAttr ($upperLower+"EyeLidMainCurve.spans")`/2)+$side;
			$posB=`xform -q -ws -t $tempString[0]`;
			if ($i>0)
				$previousMag=$mag;
			$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
			if ($mag>$previousMag)
				{
				$tyValueForCloseLid=`getAttr ($upperLower+"Lid"+$side+".ty")`;
				break;
				}
			}
		setAttr ($upperLower+"Lid"+$side+".ty") 0;
		if ($upperLower=="upper") $upperTyValueForCloseLid=$tyValueForCloseLid;
		if ($upperLower=="lower") $lowerTyValueForCloseLid=$tyValueForCloseLid;
		}
	if ($upperTyValueForCloseLid==0 || $lowerTyValueForCloseLid==0)
		error "Unable to find translateY value to close the eyeLid";

	//CloseAutoShape
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerOpposite="lower";$tyValueForCloseLid=$upperTyValueForCloseLid;}
		else {$upperLower="lower";$upperLowerOpposite="upper";$tyValueForCloseLid=$lowerTyValueForCloseLid;}

		addAttr -k 1 -ln closeAutoShape -at double -min 0 -max 10 -dv 10 ($upperLower+"Lid"+$side);
		addAttr -k 0 -ln tyValueForCloseLid -at double -dv $tyValueForCloseLid ($upperLower+"Lid"+$side);
		createNode -n ($upperLower+"Lid"+$side+"CloseAutoShapeUnitConversion") unitConversion;
		setAttr ($upperLower+"Lid"+$side+"CloseAutoShapeUnitConversion.conversionFactor") 0.1;
		connectAttr ($upperLower+"Lid"+$side+".closeAutoShape") ($upperLower+"Lid"+$side+"CloseAutoShapeUnitConversion.input");

		$spans=`getAttr ($upperLower+"LidMainCurve1"+$side+".spans")`;
		rebuildCurve -n ($upperLower+"LidMainCurve1CloseAutoShape"+$side) -ch 0 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 1 -tol 0.01 ($upperLowerOpposite+"LidMainCurve1"+$side);
		parent ($upperLower+"LidMainCurve1CloseAutoShape"+$side) ("LidWireWS"+$side);

		setAttr ($upperLower+"Lid"+$side+".ty") $tyValueForCloseLid;

		select -r ($upperLower+"LidMainCurve1CloseAutoShape"+$side) ($upperLower+"LidMainCurve2"+$side);

//		doWrapArgList "7" { "1","0","0", "2", "0", "0", "1", "0" };
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		asCreateWrap (($upperLower+"LidMainCurve1CloseAutoShapeWrap"+$side),0,0,1,0,0);//$threshold $maxDistance $exclusiveBind $autoWeightThreshold $falloffMode

		setAttr ("lowerLid"+$side+".ty") 0;
		setAttr ("upperLid"+$side+".ty") 0;

		select -r ($upperLower+"LidMainCurve1CloseAutoShape"+$side) ($upperLower+"LidMainCurve1"+$side);
		blendShape -n ($upperLower+"LidCloseAutoShapeBS"+$side) -frontOfChain;

		//then drive the BS with distance ty
		createNode -n ($upperLower+"Lid"+$side+"Dist") distanceBetween;
		connectAttr -f ($upperLower+"LidMainCurve2"+$side+".editPoints[1].yValueEp") ($upperLower+"Lid"+$side+"Dist.point1Y");
		connectAttr -f ($upperLower+"LidMainCurve2"+$side+".editPoints[1].yValueEp") ($upperLower+"Lid"+$side+"Dist.point2Y");
		setAttr ($upperLower+"Lid"+$side+".ty") $tyValueForCloseLid;
		disconnectAttr ($upperLower+"LidMainCurve2"+$side+".editPoints[1].yValueEp") ($upperLower+"Lid"+$side+"Dist.point2Y");
		setAttr ($upperLower+"Lid"+$side+".ty") 0;

		createNode -n ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide1") multiplyDivide;
		connectAttr ($upperLower+"Lid"+$side+"Dist.distance") ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide1.input1X");
		setAttr ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide1.input2X") `getAttr ($upperLower+"Lid"+$side+"Dist.distance")`;
		setAttr ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide1.operation") 2;

		createNode -n ($upperLower+"Lid"+$side+"CloseAutoShapeReverse") reverse;
		connectAttr ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide1.outputX") ($upperLower+"Lid"+$side+"CloseAutoShapeReverse.inputX");

		createNode -n ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide2") multiplyDivide;
		connectAttr ($upperLower+"Lid"+$side+"CloseAutoShapeReverse.outputX") ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide2.input1X");
		connectAttr ($upperLower+"Lid"+$side+"CloseAutoShapeUnitConversion.output") ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide2.input2X");

		connectAttr ($upperLower+"Lid"+$side+"CloseAutoShapeMultiplyDivide2.outputX") ($upperLower+"LidCloseAutoShapeBS"+$side+"."+$upperLower+"LidMainCurve1CloseAutoShape"+$side);
		}
	}

if (!`objExists FaceFitEyeLidMainLeft`)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//show CloseAutoShape
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($b==-1 && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerOpposite="lower";$tyValueForCloseLid=$upperTyValueForCloseLid;}
		else {$upperLower="lower";$upperLowerOpposite="upper";$tyValueForCloseLid=$lowerTyValueForCloseLid;}

		setAttr ($upperLower+"Lid"+$side+".ty") $tyValueForCloseLid;
		setAttr ($upperLower+"Lid"+$side+".closeAutoShape") 0;
		for ($i=1;$i<50;$i++)
			{
			setAttr ($upperLower+"Lid"+$side+".closeAutoShape") (($i*2)/10.0);
			refresh;
			}
		setAttr ($upperLower+"Lid"+$side+".closeAutoShape") 10;
		refresh;
		setAttr ($upperLower+"Lid"+$side+".ty") 0;
		}
	}

//default closeAutoShape value to 0
setAttr upperLid_R.closeAutoShape 0;
setAttr upperLid_L.closeAutoShape 0;
setAttr lowerLid_R.closeAutoShape 0;
setAttr lowerLid_L.closeAutoShape 0;

//delete EyeLidSkinCage_R;
delete upperEyeLidMainCurve1_R upperEyeLidOuterCurve1_R lowerEyeLidMainCurve1_R lowerEyeLidOuterCurve1_R;
delete upperEyeLidMainCurve1_L upperEyeLidOuterCurve1_L lowerEyeLidMainCurve1_L lowerEyeLidOuterCurve1_L;
if (`objExists FaceFitEyeLidDroopy`)
	{
	delete upperEyeLidDroopyCurve1_R lowerEyeLidDroopyCurve1_R;
	delete upperEyeLidDroopyCurve1_L lowerEyeLidDroopyCurve1_L;
	}
select eyeLidArea;

if (`objExists closestSampler`) delete closestSampler;
if (`objExists TempPos`) delete TempPos;
progressBar -e -ep $gMainProgressBar;

select -r ctrlEye_R ctrlEye_L;
}

global proc asFaceSquint ()
{
int $autoKeyState=`autoKeyframe -q -state`;
float $dist;
float $pos[],$pos2[];
string $ffd,$lattice,$latticeBase;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];
string $xyz[]={"x","y","z"};
string $trs[]={"t","r","s"};

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n SquintLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` SquintLayer 1 asFaceBS;
setAttr SquintLayer.v 1;

$pos=`xform -q -ws -t FitEyeBall`;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	addAttr -ln "squint" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 10 ("ctrlEye"+$side);
	createNode -n ("squint"+$side+"UnitConversion") unitConversion;
	setAttr ("squint"+$side+"UnitConversion.conversionFactor") 0.1;
	connectAttr ("ctrlEye"+$side+".squint") ("squint"+$side+"UnitConversion.input");

	createNode -n ("SquintLayerLatticeGroup"+$side) -p DeformationLayers transform;

	select SquintLayer;
	$tempString=`lattice -divisions 3 4 4 -objectCentered true  -ldv 2 2 2`;
	$ffd=`rename $tempString[0] ("SquintLayerFFD"+$side)`;
	$lattice=`rename $tempString[1] ("SquintLayerLattice"+$side)`;
	$latticeBase=`rename $tempString[2] ("SquintLayerLatticeBase"+$side)`;
	$tempString=`listConnections ("SquintLayerFFD"+$side+".message")`;
	rename $tempString[0] ("SquintLayerFFDSet"+$side);
	parent $lattice $latticeBase ("SquintLayerLatticeGroup"+$side) ;
	connectAttr ("squint"+$side+"UnitConversion.output") ("SquintLayerFFD"+$side+".envelope");

	xform -ws -t ($pos[0]) $pos[1] $pos[2] ("SquintLayerLattice"+$side);
	xform -ws -t ($pos[0]) $pos[1] $pos[2] ("SquintLayerLatticeBase"+$side);
	delete `scaleConstraint FitEyeBall ("SquintLayerLattice"+$side)`;
	delete `scaleConstraint FitEyeBall ("SquintLayerLatticeBase"+$side)`;
	scale -r 2 2 2 ("SquintLayerLattice"+$side);
	scale -r 2 2 2 ("SquintLayerLatticeBase"+$side);
	setAttr ("SquintLayerLattice"+$side+".sx") ($pos[0]*4);
	setAttr ("SquintLayerLatticeBase"+$side+".sx") ($pos[0]*4);
	}
setAttr SquintLayerLatticeGroup_L.sx -1;
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		connectAttr ("SquintLayerLattice_R."+$trs[$y]+$xyz[$z]) ("SquintLayerLattice_L."+$trs[$y]+$xyz[$z]);

//setAttr ctrlEye_L.squint 0;
setAttr SquintLayerLatticeGroup_L.v 0;
//setAttr SquintLayerLatticeBase_L.v 0;
select SquintLayerLattice_R SquintLayerLattice_L;
blendShape -n SquintRightToLeftBS -w 0 1;

if ($autoKeyState) autoKeyframe -state 0;
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 0;
setKeyframe SquintLayerLattice_R.pt[0:99][0:99][0:99];
currentTime 30;

select SquintLayerLattice_R.pt[1:2][1:2][2];
scale -r -p $pos[0] $pos[1] $pos[2] 1 0.2 1 ;
$pos=`xform -q -ws -t SquintLayerLattice_R.pt[0][2][3]`;
$pos2=`xform -q -ws -t SquintLayerLattice_R.pt[0][1][3]`;
$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
move -r 0 0 ($dist*0.2); 

setKeyframe SquintLayerLattice_R.pt[0:99][0:99][0:99];
if ($autoKeyState) autoKeyframe -state 1;

parent SquintLayerLatticeBase_R SquintLayerLattice_R;
parent SquintLayerLatticeBase_L SquintLayerLattice_L;

asReuseIntermediateMesh $geometry SquintLayer;
select -cl;
}

global proc asFaceEyeBrow ()
{
int $modifier=`getModifiers`;
int $vtxNr,$edgeNr,$noseVtxNr,$topVtxNr,$sideVtxNr,$numVtxStep,$c,$divisionsX,$numEyeBrowMid,$start,$end,$tempInt1,$tempInt2,$tempInt3,$tempInt4;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
float $pos[],$rot[],$posA[],$posB[],$outerUpDownTowardsPos[];
float $percentage,$dist;
float $scale=`asFaceGetScale`;
float $ctrlScale=`getAttr upperFaceOffset_M.sx`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster="EyeBrowSC";
string $side,$curveCmd,$cmd;
string $tempString[],$tempString2[],$inbetweenEyeBrowVtxs[],$prevVtxs[],$doneVtxs[],$eyeLidInnerAreaVtxs[];
string $eyeBrowMiddleVtx,$eyeBrowInnerVtx,$eyeBrowOuterVtx,$eyeBrowForeHeadNoseVtx,$eyeBrowForeHeadTopVtx,$eyeBrowForeHeadSideVtx,$eyeBrowForeHeadTopSide1Vtx;
string $eyeBrowForeHeadTopSide2Vtx,$eyeBrowForeHeadTopSide3Vtx,$eyeBrowEyeInnerCnrVtx,$eyeBrowEyeMid1CnrVtx,$eyeBrowEyeOuterCnrVtx;
string $eyeBrowMid1Vtx,$eyeBrowMid2Vtx,$eyeBrowMid3Vtx;
string $eyeBrowEyeMid2CnrVtx,$eyeBrowEyeMid3CnrVtx,$eyeBrowEyeMid4CnrVtx;
string $eyeBrowForeHeadTopSide4Vtx,$eyeBrowForeHeadTopSide5Vtx,$eyeBrowForeHeadTopSide6Vtx;

//finish Squint
currentTime 30;
delete `listConnections -s 1 -d 0 -type animCurve SquintLayerLattice_RShape`;
currentTime 0;
setAttr ctrlEye_L.tx 0;setAttr ctrlEye_L.ty 0;setAttr ctrlEye_L.squint 0;
setAttr ctrlEye_R.tx 0;setAttr ctrlEye_R.ty 0;setAttr ctrlEye_R.squint 0;

string $eyeBrows[]={"EyeBrowInner"};
for ($a=1;$a<4;$a++)
	if (`objExists ("EyeBrowMid"+$a)`)
		$eyeBrows[size($eyeBrows)]=("EyeBrowMid"+$a);
$eyeBrows[size($eyeBrows)]="EyeBrowOuter";
if (`objExists EyeBrowMiddle`)
$eyeBrows[size($eyeBrows)]="EyeBrowMiddle";

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n EyeBrowLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` EyeBrowLayer 1 asFaceBS;
setAttr EyeBrowLayer.v 1;
select Face_M EyeBrowLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] EyeBrowSC;
asReuseIntermediateMesh $geometry EyeBrowLayer;

//correspond ctrls vis
$tempString=`listRelatives -c Acontrols`;
$tempString2=`listRelatives -c Bcontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Ccontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	//EyeBrowRegion
	asCreateFaceController "EyeBrowRegion" $side 4;
	asFaceAddDrive "EyeBrowRegionJoint" $side "EyeBrowRegion" $side 1 {} {};
	asFaceAddDrive "EyeBrowRegionJoint" $side "SDKEyeBrowRegion" $side 1 {} {};
	parent ("EyeBrowRegionOffset"+$side) upperFace_M;
	$posA=`xform -q -ws -t EyeBrowInner`;
	$posB=`xform -q -ws -t EyeBrowOuter`;
	$pos[0]=($posA[0]+$posB[0])/(2.0*$b);$pos[1]=($posA[1]+$posB[1])/2.0;$pos[2]=($posA[2]+$posB[2])/2.0;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("EyeBrowRegionOffset"+$side);
	scale -r -p $pos[0] $pos[1] $pos[2] 6 2 6 ("EyeBrowRegion"+$side+".cv[0:7]");
	asFacePlaceCtrlByProjection ("EyeBrowRegion"+$side);
	asAlign ("EyeBrowRegionJointOffset"+$side) ("EyeBrowRegion"+$side) 1 0 0 0;

	for ($c=0;$c<size($eyeBrows);$c++)
		{
		if (`gmatch $eyeBrows[$c] "*Middle*"`)
			{
			if ($b==1) $side="_M";
			if ($b==-1) continue;			
			}

		$type=1;
		if ($c>0) $type=2;
		if ($c==size($eyeBrows)-1) $type=3;
		asPingPong $eyeBrows[$c] $eyeBrows[$c] $b $side $type 1 0;

		skinCluster -e -dr 4 -lw false -wt 0 -ai ($eyeBrows[$c]+"Joint"+$side) $skinCluster;
		}
	}

asFaceHalfMoonCurve EyeBrowInner_R 180;
asFaceHalfMoonCurve EyeBrowInner_L 180;

$pos=`xform -q -ws -t EyeBrowMiddle`;
$divisionsX=3;
if (`objExists EyeBrowMid1`) $divisionsX=4;
if (`objExists EyeBrowMid2`) $divisionsX=5;
if (`objExists EyeBrowMid3`) $divisionsX=6;
polyPlane -n eyeBrowCage -w 1 -h 1 -sx $divisionsX -sy 2 -ax 0 1 0 -cuv 2 -ch 0;
setAttr eyeBrowCage.rx 90;
setAttr -type float3 eyeBrowCage.t ($scale/-4.0) $pos[1] $pos[2];
setAttr -type float3 eyeBrowCage.s ($scale/2.0) ($scale/2.0) ($scale/2.0);

//Base config
$eyeBrowMiddleVtx="eyeBrowCage.vtx[7]";
$eyeBrowInnerVtx="eyeBrowCage.vtx[6]";
$eyeBrowOuterVtx="eyeBrowCage.vtx[5]";
$eyeBrowForeHeadNoseVtx="eyeBrowCage.vtx[3]";
$eyeBrowForeHeadTopVtx="eyeBrowCage.vtx[11]";
$eyeBrowForeHeadSideVtx="eyeBrowCage.vtx[4]";
$eyeBrowForeHeadTopSide1Vtx="eyeBrowCage.vtx[10]";
$eyeBrowForeHeadTopSide2Vtx="eyeBrowCage.vtx[9]";
$eyeBrowForeHeadTopSide3Vtx="eyeBrowCage.vtx[8]";
$eyeBrowEyeInnerCnrVtx="eyeBrowCage.vtx[2]";
$eyeBrowEyeMid1CnrVtx="eyeBrowCage.vtx[1]";
$eyeBrowEyeOuterCnrVtx="eyeBrowCage.vtx[0]";
if (`objExists EyeBrowMid1`)
	{
	$numEyeBrowMid=1;
	$eyeBrowMiddleVtx="eyeBrowCage.vtx[9]";
	$eyeBrowInnerVtx="eyeBrowCage.vtx[8]";
	$eyeBrowMid1Vtx="eyeBrowCage.vtx[7]";
	$eyeBrowOuterVtx="eyeBrowCage.vtx[6]";
	$eyeBrowForeHeadNoseVtx="eyeBrowCage.vtx[4]";
	$eyeBrowForeHeadTopVtx="eyeBrowCage.vtx[14]";
	$eyeBrowForeHeadSideVtx="eyeBrowCage.vtx[5]";
	$eyeBrowForeHeadTopSide1Vtx="eyeBrowCage.vtx[13]";
	$eyeBrowForeHeadTopSide2Vtx="eyeBrowCage.vtx[12]";
	$eyeBrowForeHeadTopSide3Vtx="eyeBrowCage.vtx[11]";
	$eyeBrowForeHeadTopSide4Vtx="eyeBrowCage.vtx[10]";
	$eyeBrowEyeInnerCnrVtx="eyeBrowCage.vtx[3]";
	$eyeBrowEyeMid1CnrVtx="eyeBrowCage.vtx[2]";
	$eyeBrowEyeMid2CnrVtx="eyeBrowCage.vtx[1]";
	$eyeBrowEyeOuterCnrVtx="eyeBrowCage.vtx[0]";
	}
if (`objExists EyeBrowMid2`)
	{
	$numEyeBrowMid=2;
	$eyeBrowMiddleVtx="eyeBrowCage.vtx[11]";
	$eyeBrowInnerVtx="eyeBrowCage.vtx[10]";
	$eyeBrowMid1Vtx="eyeBrowCage.vtx[9]";
	$eyeBrowMid2Vtx="eyeBrowCage.vtx[8]";
	$eyeBrowOuterVtx="eyeBrowCage.vtx[7]";
	$eyeBrowForeHeadNoseVtx="eyeBrowCage.vtx[5]";
	$eyeBrowForeHeadTopVtx="eyeBrowCage.vtx[17]";
	$eyeBrowForeHeadSideVtx="eyeBrowCage.vtx[6]";
	$eyeBrowForeHeadTopSide1Vtx="eyeBrowCage.vtx[16]";
	$eyeBrowForeHeadTopSide2Vtx="eyeBrowCage.vtx[15]";
	$eyeBrowForeHeadTopSide3Vtx="eyeBrowCage.vtx[14]";
	$eyeBrowForeHeadTopSide4Vtx="eyeBrowCage.vtx[13]";
	$eyeBrowForeHeadTopSide5Vtx="eyeBrowCage.vtx[12]";
	$eyeBrowEyeInnerCnrVtx="eyeBrowCage.vtx[4]";
	$eyeBrowEyeMid1CnrVtx="eyeBrowCage.vtx[3]";
	$eyeBrowEyeMid2CnrVtx="eyeBrowCage.vtx[2]";
	$eyeBrowEyeMid3CnrVtx="eyeBrowCage.vtx[1]";
	$eyeBrowEyeOuterCnrVtx="eyeBrowCage.vtx[0]";
	}
if (`objExists EyeBrowMid3`)
	{
	$numEyeBrowMid=3;
	$eyeBrowMiddleVtx="eyeBrowCage.vtx[13]";
	$eyeBrowInnerVtx="eyeBrowCage.vtx[12]";
	$eyeBrowMid1Vtx="eyeBrowCage.vtx[11]";
	$eyeBrowMid2Vtx="eyeBrowCage.vtx[10]";
	$eyeBrowMid3Vtx="eyeBrowCage.vtx[9]";
	$eyeBrowOuterVtx="eyeBrowCage.vtx[8]";
	$eyeBrowForeHeadNoseVtx="eyeBrowCage.vtx[6]";
	$eyeBrowForeHeadTopVtx="eyeBrowCage.vtx[20]";
	$eyeBrowForeHeadSideVtx="eyeBrowCage.vtx[7]";
	$eyeBrowForeHeadTopSide1Vtx="eyeBrowCage.vtx[19]";
	$eyeBrowForeHeadTopSide2Vtx="eyeBrowCage.vtx[18]";
	$eyeBrowForeHeadTopSide3Vtx="eyeBrowCage.vtx[17]";
	$eyeBrowForeHeadTopSide4Vtx="eyeBrowCage.vtx[16]";
	$eyeBrowForeHeadTopSide5Vtx="eyeBrowCage.vtx[15]";
	$eyeBrowForeHeadTopSide6Vtx="eyeBrowCage.vtx[14]";
	$eyeBrowEyeInnerCnrVtx="eyeBrowCage.vtx[5]";
	$eyeBrowEyeMid1CnrVtx="eyeBrowCage.vtx[4]";
	$eyeBrowEyeMid2CnrVtx="eyeBrowCage.vtx[3]";
	$eyeBrowEyeMid3CnrVtx="eyeBrowCage.vtx[2]";
	$eyeBrowEyeMid4CnrVtx="eyeBrowCage.vtx[1]";
	$eyeBrowEyeOuterCnrVtx="eyeBrowCage.vtx[0]";
	}

//TempPosForeHeadNose, TempPosForeHeadTop, TempPosForeHeadSide
createNode -n TempPosForeHeadNose transform;
$vtxNr=`getAttr FaceFitForeHead.noseCvNr`;
$pos=`xform -q -ws -t ("ForeHeadCurve.cv["+$vtxNr+"]")`;
xform -ws -t $pos[0] $pos[1] $pos[2] TempPosForeHeadNose;
createNode -n TempPosForeHeadTop transform;
$vtxNr=`getAttr FaceFitForeHead.topCvNr`;
$pos=`xform -q -ws -t ("ForeHeadCurve.cv["+$vtxNr+"]")`;
xform -ws -t $pos[0] $pos[1] $pos[2] TempPosForeHeadTop;
createNode -n TempPosForeHeadSide transform;
$vtxNr=`getAttr FaceFitForeHead.sideCvNr`;
$pos=`xform -q -ws -t ("ForeHeadCurve.cv["+$vtxNr+"]")`;
xform -ws -t $pos[0] $pos[1] $pos[2] TempPosForeHeadSide;

//place the eyeBrowCageVtxs
$pos=`xform -q -ws -t EyeBrowMiddle`;
xform -ws -t 0 $pos[1] $pos[2] $eyeBrowMiddleVtx;
$pos=`xform -q -ws -t EyeBrowInner`;
xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowInnerVtx;
$pos=`xform -q -ws -t EyeBrowOuter`;
xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowOuterVtx;
$pos=`xform -q -ws -t TempPosForeHeadNose`;
xform -ws -t 0 $pos[1] $pos[2] $eyeBrowForeHeadNoseVtx;
$pos=`xform -q -ws -t TempPosForeHeadTop`;
xform -ws -t 0 $pos[1] $pos[2] $eyeBrowForeHeadTopVtx;
$pos=`xform -q -ws -t TempPosForeHeadSide`;
xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowForeHeadSideVtx;
$pos=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowEyeInnerCnrVtx;
$pos=`xform -q -ws -t upperEyeLidOuterCurve.cv[$upperEyeLidOuterNumCVs-1]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowEyeOuterCnrVtx;

if ($eyeBrowMid1Vtx!="")
	{
	$pos=`xform -q -ws -t EyeBrowMid1`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowMid1Vtx;
	}
if ($eyeBrowMid2Vtx!="")
	{
	$pos=`xform -q -ws -t EyeBrowMid2`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowMid2Vtx;
	}
if ($eyeBrowMid3Vtx!="")
	{
	$pos=`xform -q -ws -t EyeBrowMid3`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowMid3Vtx;
	}

//Calculated `averaged` vtxs
if (`objExists tempPointOnCurveInfo`) delete tempPointOnCurveInfo;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
connectAttr -f upperEyeLidOuterCurve.worldSpace[0] tempPointOnCurveInfo.inputCurve;
for ($i=0;$i<$numEyeBrowMid+1;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter ((1.0/($numEyeBrowMid+1))*($i+1));
	if ($numEyeBrowMid==0) setAttr tempPointOnCurveInfo.parameter 0.5;
	$pos=`getAttr tempPointOnCurveInfo.position`;
	if ($i==0) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowEyeMid1CnrVtx;
	if ($i==1) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowEyeMid2CnrVtx;
	if ($i==2) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowEyeMid3CnrVtx;
	if ($i==3) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowEyeMid4CnrVtx;
	}

$topVtxNr=`getAttr FaceFitForeHead.topCvNr`;
$sideVtxNr=`getAttr FaceFitForeHead.sideCvNr`;
$numVtxTopToSide=$sideVtxNr-$topVtxNr;
$numVtxStep=$numVtxTopToSide/3;

//Make a new custom copy of "ForeHeadCurve", that runs from "topCvNr" to "sideCvNr"
$curveCmd="curve -d 1 -n TempForeHeadCurve";
$start=$topVtxNr;
$end=$sideVtxNr;
if ($topVtxNr>$sideVtxNr)
	{
	$start=$sideVtxNr;
	$end=$topVtxNr;
	}
for ($i=$start;$i<$end+1;$i++)
	{
	$pos=`xform -q -ws -t ("ForeHeadCurve.cv["+$i+"]")`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
eval ($curveCmd);
if ($topVtxNr>$sideVtxNr)
	{
	reverseCurve -ch 0 -rpo 1 TempForeHeadCurve;
	}
connectAttr -f TempForeHeadCurve.worldSpace[0] tempPointOnCurveInfo.inputCurve;
//find $outerUpDownTowardsPos for later usage
setAttr tempPointOnCurveInfo.parameter 0.65;
$outerUpDownTowardsPos=`getAttr tempPointOnCurveInfo.position`;
createNode -n TempPos transform;
createNode -n TempPos2 transform;
xform -ws -t $outerUpDownTowardsPos[0] $outerUpDownTowardsPos[1] $outerUpDownTowardsPos[2] TempPos;
delete `pointConstraint EyeBrowOuter TempPos TempPos2`;
//delete `geometryConstraint EyeBrowLayer TempPos2`;
$outerUpDownTowardsPos=`xform -q -ws -t TempPos2`;
delete TempPos TempPos2;

for ($i=0;$i<$numEyeBrowMid+3;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter ((1.0/($numEyeBrowMid+4))*($i+1));
	$pos=`getAttr tempPointOnCurveInfo.position`;
	if ($i==0) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowForeHeadTopSide1Vtx;
	if ($i==1) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowForeHeadTopSide2Vtx;
	if ($i==2) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowForeHeadTopSide3Vtx;
	if ($i==3) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowForeHeadTopSide4Vtx;
	if ($i==4) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowForeHeadTopSide5Vtx;
	if ($i==5) xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowForeHeadTopSide6Vtx;
	}
delete TempForeHeadCurve;

//skinning
select Face_M eyeBrowCage;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] eyeBrowCageSC;
skinCluster -e -dr 4 -lw false -wt 0
	-ai EyeBrowMiddleJoint_M -ai EyeBrowInnerJoint_R -ai EyeBrowInnerJoint_L -ai EyeBrowOuterJoint_R -ai EyeBrowOuterJoint_L 
	eyeBrowCageSC;
skinPercent -tv EyeBrowMiddleJoint_M 1 eyeBrowCageSC $eyeBrowMiddleVtx;
skinPercent -tv EyeBrowInnerJoint_R 1 eyeBrowCageSC $eyeBrowInnerVtx;
skinPercent -tv EyeBrowOuterJoint_R 1 eyeBrowCageSC $eyeBrowOuterVtx;
if ($eyeBrowMid1Vtx!="")
	{
	skinCluster -e -dr 4 -lw false -wt 0 -ai EyeBrowMid1Joint_R eyeBrowCageSC;
	skinPercent -tv EyeBrowMid1Joint_R 1 eyeBrowCageSC $eyeBrowMid1Vtx;
	}
if ($eyeBrowMid2Vtx!="")
	{
	skinCluster -e -dr 4 -lw false -wt 0 -ai EyeBrowMid2Joint_R eyeBrowCageSC;
	skinPercent -tv EyeBrowMid2Joint_R 1 eyeBrowCageSC $eyeBrowMid2Vtx;
	}
if ($eyeBrowMid3Vtx!="")
	{
	skinCluster -e -dr 4 -lw false -wt 0 -ai EyeBrowMid3Joint_R eyeBrowCageSC;
	skinPercent -tv EyeBrowMid3Joint_R 1 eyeBrowCageSC $eyeBrowMid3Vtx;
	}

duplicate -n eyeBrowCage_M eyeBrowCage;
duplicate -n eyeBrowCage_M2 eyeBrowCage;
scale -r -p 0 0 0 -1 1 1 eyeBrowCage_M2.vtx[0:99];
polyNormal -normalMode 0 -userNormalMode 0 -ch 0 eyeBrowCage_M2;
polyUnite -n eyeBrowCage_M3 -ch 0 -mergeUVSets 1 eyeBrowCage_M eyeBrowCage_M2;
delete eyeBrowCage_M eyeBrowCage_M2;
rename eyeBrowCage_M3 eyeBrowCage_M;
polyMergeVertex -d 0.001 -am 1 -ch 0 eyeBrowCage_M;
select "EyeBrow*Joint_*";
select -add Face_M eyeBrowCage_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] eyeBrowCage_MSC;
select eyeBrowCage eyeBrowCage_M;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;	
copySkinWeights -ss eyeBrowCage_MSC -ds eyeBrowCage_MSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete eyeBrowCage;

//extrude extention, to avoid bleeding to e.g snout
duplicate -n eyeBrowCage2_M eyeBrowCage_M;
select -r eyeBrowCage2_M.e[0] ;
//SelectEdgeLoopSp;
polyConvertToShellBorder;//non-print-out alternative
//after delteAdv, then re-build, the eyeBrowCage mesh does not work with the polyConvertToShellBorder command
if (size(`ls -sl`)==0)
	{
	select -r eyeBrowCage2_M.e[0] ;
	SelectEdgeLoopSp;
	}
polyExtrudeEdge -n tempPolyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -divisions 1 -twist 0 -taper 1 -offset 0 -thickness 0 -smoothingAngle 30;
setAttr polyExtrudeEdge1.localTranslateZ 1;
ConvertSelectionToVertices;
$tempString2=`ls -sl`;
select "EyeBrow*Joint_*";
select -add Face_M eyeBrowCage2_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] eyeBrowCage2_MSC;
select eyeBrowCage_M eyeBrowCage2_M;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;	
skinPercent -tv Face_M 1 eyeBrowCage2_MSC $tempString2;
delete eyeBrowCage_M;

//non-symmetry
if (`objExists EyeBrowInnerLeft`)
	{
	$eyeBrowInnerVtx="eyeBrowCage2_M.vtx[17]";
	$eyeBrowOuterVtx="eyeBrowCage2_M.vtx[16]";
	if (`objExists EyeBrowMid1`)
		{
		$eyeBrowInnerVtx="eyeBrowCage2_M.vtx[20]";
		$eyeBrowMid1Vtx="eyeBrowCage2_M.vtx[19]";
		$eyeBrowOuterVtx="eyeBrowCage2_M.vtx[18]";
		}
	if (`objExists EyeBrowMid2`)
		{
		$eyeBrowInnerVtx="eyeBrowCage2_M.vtx[25]";
		$eyeBrowMid1Vtx="eyeBrowCage2_M.vtx[24]";
		$eyeBrowMid2Vtx="eyeBrowCage2_M.vtx[23]";
		$eyeBrowOuterVtx="eyeBrowCage2_M.vtx[22]";
		}
	if (`objExists EyeBrowMid3`)
		{
		$eyeBrowInnerVtx="eyeBrowCage2_M.vtx[30]";
		$eyeBrowMid1Vtx="eyeBrowCage2_M.vtx[29]";
		$eyeBrowMid2Vtx="eyeBrowCage2_M.vtx[28]";
		$eyeBrowMid3Vtx="eyeBrowCage2_M.vtx[27]";
		$eyeBrowOuterVtx="eyeBrowCage2_M.vtx[26]";
		}

	$pos=`xform -q -ws -t EyeBrowInnerLeft`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowInnerVtx;
	$pos=`xform -q -ws -t EyeBrowOuterLeft`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowOuterVtx;
	if (`objExists EyeBrowMid1`)
		{
		$pos=`xform -q -ws -t EyeBrowMid1Left`;
		xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowMid1Vtx;
		}
	if (`objExists EyeBrowMid2`)
		{
		$pos=`xform -q -ws -t EyeBrowMid2Left`;
		xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowMid2Vtx;
		}
	if (`objExists EyeBrowMid3`)
		{
		$pos=`xform -q -ws -t EyeBrowMid3Left`;
		xform -ws -t $pos[0] $pos[1] $pos[2] $eyeBrowMid3Vtx;
		}
	}

select eyeBrowCage2_M EyeBrowLayer;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;	

eval ("select "+`asGetFaceFitSelection EyeLidInnerAreaMesh`);
$tempString=`ls -sl`;
select `asobjSetCast "" $tempString EyeBrowLayer`;
skinPercent -tv Face_M 1 $skinCluster `ls -sl`;
$eyeLidInnerAreaVtx=`ls -sl`;

//Hammer weights for vtx 1 step out from upperEyeLidMainCurve
duplicate -n upperEyeLidOuterCurve2 upperEyeLidOuterCurve;
parent -w upperEyeLidOuterCurve2;
delete upperEyeLidOuterCurve2.cv[0] upperEyeLidOuterCurve2.cv[(`getAttr upperEyeLidOuterCurve2.spans`+1)];
eval ("select "+`asGetFaceFitSelection upperEyeLidOuterCurve2`);
delete upperEyeLidOuterCurve2;
$tempString=`ls -sl`;
select `asobjSetCast "" $tempString EyeBrowLayer`;
polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion;
select -d $eyeLidInnerAreaVtx;
$tempString=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	{
	if (size(`skinPercent -ignoreBelow 0.001 -q -t EyeBrowSC $tempString[$i]`)==1)
		continue;//skip vtx that are fully weighted to one joint
	select -add $tempString[$i];
	}
if (size(`ls -sl`))
	weightHammerVerts;

select EyeBrowLayer;
if (!`objExists FaceFitEyeBrowInnerLeft`)
	copySkinWeights -ss EyeBrowSC -ds EyeBrowSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

delete TempPosForeHeadNose TempPosForeHeadTop TempPosForeHeadSide;
if ($modifier!=4)
	delete eyeBrowCage2_M;

//Drive
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (`objExists ("EyeBrowMid1Joint"+$side)`)
		asFaceAddDrive "EyeBrowMid1Joint" $side "EyeBrowInnerJoint" $side 0.3 {} {};

	if (`objExists ("EyeBrowMid3Joint"+$side)`)
		asFaceAddDrive "EyeBrowMid3Joint" $side "EyeBrowOuterJoint" $side 0.3 {} {};
	else if (`objExists ("EyeBrowMid2Joint"+$side)`)
		asFaceAddDrive "EyeBrowMid2Joint" $side "EyeBrowOuterJoint" $side 0.3 {} {};
	}

if (`objExists EyeBrowMiddle_M`)
	{
	asFaceAddDrive "EyeBrowMiddleJoint" "_M" "EyeBrowInnerJoint" "_R" 0.5 {} {};
	asFaceAddDrive "EyeBrowMiddleJoint" "_M" "EyeBrowInnerJoint" "_L" 0.5 {} {};
	}

//DrivingSystem
$posA=`xform -q -ws -t EyeBrowInner`;
$posB=`xform -q -ws -t FitEyeBall`;
$dist=(($posA[1]-$posB[1])/`getAttr upperFaceOffset_M.sx`)/2.0;
if ($dist<0.25) $dist=0.25;
if ($dist>1.0) $dist=1.0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	if (`objExists EyeBrowInner_R`)
		{
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowInner"+$side+".ty") 1 $dist;
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowInner"+$side+".ty") -1 ($dist*-1);
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowInner"+$side+".ty") 1 $dist;
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowInner"+$side+".ty") -1 ($dist*-1);
		}
	if (`objExists EyeBrowMid1_R`)
		{
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid1"+$side+".ty") 1 ($dist*0.7);
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid1"+$side+".ty") -1 ($dist*-0.7);
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid1"+$side+".ty") 1 ($dist*0.1);
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid1"+$side+".ty") -1 ($dist*-0.1);
		}
	if (`objExists EyeBrowMid2_R`)
		{
		if (`objExists EyeBrowMid3_R`)
			{
			asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid2"+$side+".ty") 1 $dist;
			asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid2"+$side+".ty") -1 ($dist*-1);
			}
		else
			{
			asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid2"+$side+".ty") 1 ($dist*0.7);
			asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid2"+$side+".ty") -1 ($dist*-0.7);
			}
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid2"+$side+".ty") 1 ($dist*0.1);
		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid2"+$side+".ty") -1 ($dist*-0.1);
		}
	if (`objExists EyeBrowMid3_R`)
		{
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid3"+$side+".ty") 1 ($dist*0.7);
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowMid3"+$side+".ty") -1 ($dist*-0.7);
//		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid3"+$side+".ty") 1 ($dist*0.05);
//		asDsSdk ("ctrlBrow"+$side+".tx") ("SDKEyeBrowMid3"+$side+".ty") -1 ($dist*-0.05);
		}
	if (`objExists EyeBrowOuter_R`)
		{
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowOuter"+$side+".ty") 1 $dist;
		asDsSdk ("ctrlBrow"+$side+".ty") ("SDKEyeBrowOuter"+$side+".ty") -1 ($dist*-1);
		}
	}

//squeeze
$curveCmd="curve -d 1 -n EyeBrowCurve ";
$pos=`xform -q -ws -t EyeBrowMiddle`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
$pos=`xform -q -ws -t EyeBrowInner`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
if (`objExists EyeBrowMid1_R`) {$pos=`xform -q -ws -t EyeBrowMid1_R`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];}
if (`objExists EyeBrowMid2_R`) {$pos=`xform -q -ws -t EyeBrowMid2_R`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];}
if (`objExists EyeBrowMid3_R`) {$pos=`xform -q -ws -t EyeBrowMid3_R`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];}
$pos=`xform -q -ws -t EyeBrowOuter`;$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
eval ($curveCmd);
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 0 -kt 0 -s 0 -d 3 -tol 0.01 EyeBrowCurve;
createNode -n TempPos transform;
createNode -n tempMotionPath motionPath;
setAttr tempMotionPath.fractionMode 1;
connectAttr EyeBrowCurve.worldSpace tempMotionPath.geometryPath;
connectAttr tempMotionPath.allCoordinates TempPos.t;
connectAttr tempMotionPath.rotate TempPos.rotate;
setAttr tempMotionPath.worldUpType 0;
setAttr tempMotionPath.upAxis 1;
setAttr tempMotionPath.frontAxis 0;
setAttr tempMotionPath.inverseFront 1;
createNode -n tempNearestPointOnCurve nearestPointOnCurve;
connectAttr -f EyeBrowCurve.worldSpace[0] tempNearestPointOnCurve.inputCurve;
createNode -n TempPos2 transform;
connectAttr TempPos2.t tempNearestPointOnCurve.inPosition;
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	addAttr -k 1 -ln squeeze -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
	$pos=`xform -q -ws -t EyeBrowInner_R`;
	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowMiddle_M.ty") 10 (($pos[0]/$ctrlScale)*-0.05);

	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowInner"+$side+".tx") 10 (($pos[0]/$ctrlScale)*0.50);
	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowInner"+$side+".ty") 10 (($pos[0]/$ctrlScale)*0.25);
	asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDKEyeBrowInner"+$side+".sx") 10 0.25;

	clear $tempString;
	$tempString={"EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowOuter"};
	for ($i=0;$i<size($tempString);$i++)
		{
		if (!`objExists ($tempString[$i]+$side)`)
			continue;
		asAlign TempPos2 ($tempString[$i]+"_R") 1 0 0 0;
		delete `geometryConstraint EyeBrowCurve TempPos2`;
		refresh;
		$percentage=`getAttr tempNearestPointOnCurve.parameter`;
		setAttr "tempMotionPath.uValue" $percentage;
		$rot[1]=`getAttr TempPos.ry`;
		setAttr "tempMotionPath.uValue" ($percentage-0.1);
		$rot[1]=($rot[1]-`getAttr TempPos.ry`);
		$pos=`xform -q -ws -t TempPos`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($tempString[$i]+"_R");
		$pos=`getAttr ($tempString[$i]+"_R.t")`;
		setAttr ($tempString[$i]+"_R.t") 0 0 0;
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".tx") 10 $pos[0];
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".ty") 10 $pos[1];
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".tz") 10 $pos[2];
		asDsSdk ("ctrlBrow"+$side+".squeeze") ("SDK"+$tempString[$i]+$side+".ry") 10 $rot[1];
		}
	}
delete TempPos TempPos2 tempNearestPointOnCurve EyeBrowCurve;

//outerUpDown
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	addAttr -k 1 -ln outerUpDown -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ("ctrlBrow"+$side);
	xform -ws -t $outerUpDownTowardsPos[0] $outerUpDownTowardsPos[1] $outerUpDownTowardsPos[2] EyeBrowOuter_R;
	$pos=`getAttr EyeBrowOuter_R.t`;
	setAttr EyeBrowOuter_R.t 0 0 0;
	clear $tempString;
	$tempString={"EyeBrowInner","EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowOuter"};
	for ($i=0;$i<size($tempString);$i++)
		{
		if (!`objExists ($tempString[$i]+$side)`)
			continue;
		$percentage=`smoothstep 0 1 (0.2*($i+1))`;
		asDsSdk ("ctrlBrow"+$side+".outerUpDown") ("SDK"+$tempString[$i]+$side+".tx") 10 ($pos[0]*$percentage);
		asDsSdk ("ctrlBrow"+$side+".outerUpDown") ("SDK"+$tempString[$i]+$side+".ty") 10 ($pos[1]*$percentage);
		asDsSdk ("ctrlBrow"+$side+".outerUpDown") ("SDK"+$tempString[$i]+$side+".tz") 10 ($pos[2]*$percentage);
		}
	}

select -cl;
}

global proc asFaceLip ()
{
global string $gMainProgressBar;
global string $gSelect;
global string $artSelectObject;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $skinCluster="LipSC";
int $outerNumCv,$ctrlNr,$type,$numCvs,$nrAsInt,$nearestVtx;
int $innerVtxNr[],$outerVtxNr[],$mainVtxNr[];
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $dist,$currentValue,$factor,$lipDistOffsetScale,$minDist;
float $pos[],$posA[],$posB[],$posC[],$posD[],$posAB[],$posUpperA[],$posLowerA[],$libBShapePos[];
string $startVtx,$endVtx,$inOutMain,$side,$inf,$ctrl,$cd,$setRange,$plusMinusAverage,$joint,$grpA,$grpB,$jointOffset,$nr,$cmd,$upperLower,$leftSuffix;
string $tempString[],$tempString2[],$tempString3[],$completedVtxs[],$endingVtxs[],$allLoopVtxs[],$lipArea[],$lipPress[];
string $rightCnrVtxs[],$leftCnrVtxs[],$loopVtxs[];
string $AB[]={"A","B"};
string $tr[]={"t","r"};
string $xyz[]={"x","y","z"};

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n LipLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` LipLayer 1 asFaceBS;
setAttr LipLayer.v 1;
select Face_M LipLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] LipSC;
asReuseIntermediateMesh $geometry LipLayer;

//correspond ctrls vis
$tempString=`listRelatives -c Acontrols`;
$tempString2=`listRelatives -c Bcontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Ccontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;

progressBar -e -st "Lip Falloff" -bp -ii 0 -min 0 -max 14 $gMainProgressBar;

eval ("select "+`asGetFaceFitSelection LipInnerAreaMesh`);
$tempString=`ls -sl`;
select `asobjSetCast "" $tempString LipLayer`;
$lipArea=`ls -sl -fl`;

createNode -n lipArea objectSet;
sets -add FaceAreas lipArea;
sets -add lipArea $lipArea;

createNode -n LipSetup transform;
parent LipSetup FaceDeformationSetups;
createNode -n LipPuckerSetup transform;
parent LipPuckerSetup FaceDeformationSetups;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr LipLayer.outMesh closestSampler.inMesh;
createNode -n closestNurbsSampler closestPointOnSurface;
createNode -n LipConstruction transform;

//LipNarrow
select -cl;
createNode -n LipJoints_M transform;
createNode -n LipJointsNarrow_M transform;
createNode -n LipJointsPart_M transform;
parent LipJoints_M  Face_M;
parent LipJointsNarrow_M LipJoints_M;
$pos=`xform -q -ws -t ("upperLipOuterCurve.cv[0]")`;
$posA=`xform -q -ws -t ("lowerLipOuterCurve.cv[0]")`;
xform -ws -t 0 (($pos[1]+$posA[1])/2.0) `max $pos[2] $posA[2]` LipJointsNarrow_M;
duplicate -n LipJointsNarrow_R LipJointsNarrow_M;
duplicate -n LipJointsNarrow_L LipJointsNarrow_M;
duplicate -n LipJointsPart_R LipJointsPart_M;
parent LipJointsPart_R LipJointsNarrow_R;
duplicate -n LipJointsPart_L LipJointsPart_M;
parent LipJointsPart_L LipJointsNarrow_L;
parent LipJointsPart_M LipJointsNarrow_M;

//Press & Roll & Pucker addAttrs
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Press") -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	createNode -n ($upperLower+"LipPressPlusMinusAverage") plusMinusAverage;
	connectAttr ("ctrlMouth_M."+$upperLower+"Press") ($upperLower+"LipPressPlusMinusAverage.input3D[0].input3Dy");
	}
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Squeeze") -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	connectAttr ("ctrlMouth_M."+$upperLower+"Squeeze") ($upperLower+"LipPressPlusMinusAverage.input3D[0].input3Dz");
	}
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Roll") -at double -smx 10 -hsx 1 -smn -10 -hnv 1 ctrlMouth_M;
	createNode -n ($upperLower+"LipRollPlusMinusAverage") plusMinusAverage;
	connectAttr ("ctrlMouth_M."+$upperLower+"Roll") ($upperLower+"LipRollPlusMinusAverage.input1D[0]");
	}
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";else $upperLower="lower";
	addAttr -k 1 -ln ($upperLower+"Pucker") -at double -smx 10 -hsx 1 -smn 0 -hnv 1 ctrlMouth_M;
	createNode -n ($upperLower+"LipPuckerPlusMinusAverage") plusMinusAverage;
	connectAttr ("ctrlMouth_M."+$upperLower+"Pucker") ($upperLower+"LipPuckerPlusMinusAverage.input1D[0]");
	}

//LipRegion
$posA=`xform -q -ws -t upperLipMainCurve.cv[0]`;
$posB=`xform -q -ws -t lowerLipMainCurve.cv[0]`;
$pos[0]=0;$pos[1]=($posA[1]+$posB[1])/2.0;$pos[2]=($posA[2]+$posB[2])/2.0;

asCreateFaceController "LipRegion" "_M" 4;
asFaceAddDrive "LipRegionJoint" "_M" "LipRegion" "_M" 1 {} {};
asFaceAddDrive "LipRegionJoint" "_M" "SDKLipRegion" "_M" 1 {} {};
//parent LipRegionOffset_M Regionscontrols;
scale -r -p 0 0 0 6 6 6 LipRegion_M.cv[0:7];
xform -ws -t 0 $pos[1] $pos[2] LipRegionOffset_M;
move -r 0 0 ($scale/10.0) LipRegion_M.cv[0:99];
asAlign LipRegionJointOffset_M LipRegion_M 1 0 0 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	$leftSuffix="";
	if ($b==-1 && !`objExists FaceFitEyeLidMainLeft`)
		break;
	if ($b==-1)
		$leftSuffix="Left";

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		//Create BuildCurves (based on ordered selection)
		for ($a=0;$a<3;$a++)
			{
			progressBar -e -s 1 $gMainProgressBar;
			if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";

			$curveCmd="curve -d 1 ";
	//		eval ("select "+`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`);
			eval ("select "+`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve"+$leftSuffix)`);

			$loopVtxs=`ls -sl -fl`;
			clear $completedVtxs;
	//		$tempString[0]=`getAttr ("FaceFitLip"+$inOutMain+"."+$upperLower+"Selection")`;
			$tempString[0]=`asGetFaceFitSelection ($upperLower+"Lip"+$inOutMain+"Curve"+$leftSuffix)`;
			$tempString=`stringToStringArray $tempString[0] " "`;
			select $tempString[0];
			for ($i=0;$i<size($loopVtxs);$i++)
				{
				$tempString=`ls -sl -fl`;
				if (size($tempString)==0)
					continue;
				$completedVtxs=`stringArrayCatenate $completedVtxs $tempString`;
				$pos=`xform -q -ws -t $tempString`;
				$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
				ConvertSelectionToEdges;
				ConvertSelectionToVertices;
				$tempString=`ls -sl -fl`;
				for ($y=0;$y<size($tempString);$y++)
					if (!`stringArrayCount $tempString[$y] $loopVtxs`)
						select -d $tempString[$y];
				select -d $completedVtxs;
				}
			$tempString[0]=`eval ($curveCmd)`;
			rename $tempString[0] ($upperLower+"Lip"+$inOutMain+"BuildCurve"+$leftSuffix);
			parent ($upperLower+"Lip"+$inOutMain+"BuildCurve"+$leftSuffix) LipConstruction;
			}
		$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve"+$leftSuffix+".spans")`+1;

		//Create Joints & CenterCurve
		$curveCmd="curve -d 1 ";
		for ($i=0;$i<$outerNumCv;$i++)
			{
			select LipJoints_M;
			joint -n ($upperLower+"LipJoint"+$i+$leftSuffix);
			setAttr ($upperLower+"LipJoint"+$i+$leftSuffix+".radius") ($scale/10.0);
			$posA=`xform -q -ws -t ($upperLower+"LipOuterBuildCurve"+$leftSuffix+".cv["+$i+"]")`;
			$posB=`xform -q -ws -t ($upperLower+"LipInnerBuildCurve"+$leftSuffix+".cv["+$i+"]")`;
			$posC=`xform -q -ws -t ($upperLower+ "LipMainBuildCurve"+$leftSuffix+".cv["+$i+"]")`;
			$pos={(($posA[0]+$posB[0]+$posC[0])/3.0),(($posA[1]+$posB[1]+$posC[1])/3.0),(($posA[2]+$posB[2]+$posC[2])/3.0)};
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"LipJoint"+$i+$leftSuffix);
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] ($upperLower+"LipCenterBuildCurve"+$leftSuffix);
		parent ($upperLower+"LipCenterBuildCurve"+$leftSuffix) LipConstruction;
		}
	}

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Mirror joints 
	for ($i=0;$i<$outerNumCv;$i++)
		{
		if ($i==0) $side="_M";
		else $side="_R";
	
		rename ($upperLower+"LipJoint"+$i) ($upperLower+"LipJoint"+$i+$side);
		if ($side=="_R")
			{
			duplicate -n ($upperLower+"LipJoint"+$i+"_L") ($upperLower+"LipJoint"+$i+"_R");
			parent ($upperLower+"LipJoint"+$i+"_R") LipJointsPart_R;
			parent ($upperLower+"LipJoint"+$i+"_L") LipJointsPart_L;
			$pos=`xform -q -ws -t ($upperLower+"LipJoint"+$i+"_L")`;
			if (`objExists ($upperLower+"LipJoint"+$i+"Left")`)
				{
				$pos=`xform -q -ws -t ($upperLower+"LipJoint"+$i+"Left")`;
				$pos[0]=$pos[0]*-1;
				delete ($upperLower+"LipJoint"+$i+"Left");
				}
			xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ($upperLower+"LipJoint"+$i+"_L");
			}
		if ($side=="_M")
			parent ($upperLower+"LipJoint"+$i+"_M") LipJointsPart_M;
		}
	if (`objExists ($upperLower+"LipJoint0Left")`)
		delete ($upperLower+"LipJoint0Left");
	}


//JointOffsetGrps & ziplip
createNode -n LipFollicles -p LipSetup transform;
//createNode -n LipZip -p LipSetup transform;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	//Ribbon
	duplicate -n ($upperLower+"LipCenterBuildCurve_L") ($upperLower+"LipCenterBuildCurve");
	setAttr ($upperLower+"LipCenterBuildCurve_L.sx") -1;
	if (`objExists ($upperLower+"LipCenterBuildCurveLeft")`)
		{
		delete ($upperLower+"LipCenterBuildCurve_L");
		rename ($upperLower+"LipCenterBuildCurveLeft") ($upperLower+"LipCenterBuildCurve_L");
		}
	attachCurve -ch 0 -n ($upperLower+"LipCenterBuildCurve_M") -rpo 0 -kmk 1 -m 1 -bb 0.5 -bki 0 -p 0.1 ($upperLower+"LipCenterBuildCurve_L") ($upperLower+"LipCenterBuildCurve");

	curve -n tempLoftProfile -d 1 -p 0 0 ($faceFitScale/-50.0) -p 0 0 ($faceFitScale/50.0) -k 0 -k 1 ;
//	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 tempLoftProfile;
	if (`objExists tempPointOnCurveInfo`) delete tempPointOnCurveInfo;
	createNode -n tempPointOnCurveInfo pointOnCurveInfo;
	setAttr tempPointOnCurveInfo.turnOnPercentage 1;
	duplicate -n ($upperLower+"LipCenterBuildCurve2_M") ($upperLower+"LipCenterBuildCurve_M");
	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.01 ($upperLower+"LipCenterBuildCurve2_M");
	connectAttr -f ($upperLower+"LipCenterBuildCurve2_MShape.worldSpace[0]") tempPointOnCurveInfo.inputCurve;
	for ($i=0;$i<5;$i++)
		{
		duplicate -n ("tempLoftProfile"+$i) tempLoftProfile;
		setAttr tempPointOnCurveInfo.parameter ($i/4.0);
		if ($i==1) setAttr tempPointOnCurveInfo.parameter 0.20;
		if ($i==3) setAttr tempPointOnCurveInfo.parameter 0.80;
		$pos=`getAttr tempPointOnCurveInfo.position`;
		xform -ws -t $pos[0] $pos[1] $pos[2] ("tempLoftProfile"+$i);
		}
	delete ($upperLower+"LipCenterBuildCurve2_M");
	if (`objExists TempPos`) delete TempPos;
	//orient curves, for `folding back` mouths e.g. cody
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "scene" tempLoftProfile1 tempLoftProfile0`;
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "scene" tempLoftProfile2 tempLoftProfile1`;
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector  1 0 0 -upVector 0 1 0 -worldUpType "scene" tempLoftProfile3 tempLoftProfile4`;
	delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector  1 0 0 -upVector 0 1 0 -worldUpType "scene" tempLoftProfile2 tempLoftProfile3`;

	select -cl;
	for ($i=0;$i<5;$i++)
		select -add ("tempLoftProfile"+$i);
	loft -ch 1 -n ($upperLower+"LipCenterPlane") -u 1 -c 0 -ar 0 -d 3 -ss 1 -rn 0 -po 0 -rsn true;
	delete tempLoftProfile;
	for ($i=0;$i<5;$i++)
		delete ("tempLoftProfile"+$i);
	reverseSurface -d 3 -ch 0 -rpo 1 ($upperLower+"LipCenterPlane");
	rebuildSurface -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 0 -su 0 -du 3 -sv 0 -dv 3 -tol 0.01 -fr 0 -dir 2 ($upperLower+"LipCenterPlane");

	parent ($upperLower+"LipCenterPlane") LipSetup;
	connectAttr -f ($upperLower+"LipCenterPlaneShape.worldSpace[0]") closestNurbsSampler.inputSurface;
	parent ($upperLower+"LipCenterBuildCurve_M") LipSetup;

	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			$tempString[0]=`createNode follicle`;
			$tempString=`listRelatives -p $tempString[0]`;
			rename $tempString[0] ($upperLower+"follicle"+$i+$side);
			parent ($upperLower+"follicle"+$i+$side) LipFollicles;
			setAttr ($upperLower+"follicle"+$i+$side+".collide") 0;
			connectAttr ($upperLower+"LipCenterPlane.local") ($upperLower+"follicle"+$i+$side+".inputSurface");
			connectAttr ($upperLower+"LipCenterPlane.worldMatrix[0]") ($upperLower+"follicle"+$i+$side+".inputWorldMatrix");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outTranslate") ($upperLower+"follicle"+$i+$side+".t");
			connectAttr -f ($upperLower+"follicle"+$i+$side+".outRotate") ($upperLower+"follicle"+$i+$side+".r");

			$pos=`xform -q -ws -t ($upperLower+"LipJoint"+$i+$side)`;
			setAttr -type float3 closestNurbsSampler.inPosition $pos[0] $pos[1] $pos[2];
			setAttr ($upperLower+"follicle"+$i+$side+".parameterU") `getAttr closestNurbsSampler.parameterU`;
			setAttr ($upperLower+"follicle"+$i+$side+".parameterV") `getAttr closestNurbsSampler.parameterV`;
			connectAttr ($upperLower+"follicle"+$i+$side+".t") ($upperLower+"LipJoint"+$i+$side+".t");
			connectAttr ($upperLower+"follicle"+$i+$side+".r") ($upperLower+"LipJoint"+$i+$side+".r");
			}
		}
	}

if (`objExists tempPointOnCurveInfo`) delete tempPointOnCurveInfo;

//Bind
select `listRelatives -ad -type joint LipJoints_M`;
$tempString=`ls -sl`;
select -cl;
//faster to add `locked` then unlock
$cmd="skinCluster -e  -dr 4 -lw true -wt 0 ";
for ($i=0;$i<size($tempString);$i++)
	$cmd+=" -ai "+$tempString[$i];
$cmd+=" "+$skinCluster;
eval $cmd;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".lockInfluenceWeights") 0;
//setAttr LipJoints_M.lockInfluenceWeights 1;

for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;

	for ($b=1;$b>-2;$b=$b-2)
		{
		progressBar -e -s 1 $gMainProgressBar;
		//Hard weights
		for ($a=0;$a<3;$a++)
			{
			if ($a==0) $inOutMain="Inner";if ($a==1) $inOutMain="Outer";if ($a==2) $inOutMain="Main";
	
			for ($i=0;$i<$outerNumCv;$i++)
				{
				if ($b==1) $side="_R";
				else $side="_L";
				if ($i==0) $side="_M";
				if ($i==0 && $b==-1) continue;

				$pos=`xform -q -ws -t ($upperLower+"Lip"+$inOutMain+"BuildCurve.cv["+$i+"]")`;
				if ($side=="_L" && `objExists ($upperLower+"Lip"+$inOutMain+"BuildCurveLeft.cv["+$i+"]")`)
					{
					$pos=`xform -q -ws -t ($upperLower+"Lip"+$inOutMain+"BuildCurveLeft.cv["+$i+"]")`;
					$pos[0]=$pos[0]*-1;
					}
				setAttr -type float3 closestSampler.inPosition ($pos[0]*$b) $pos[1] $pos[2];
				select ("LipLayer.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
				catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
	
				if ($inOutMain=="Inner") $innerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Outer") $outerVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				if ($inOutMain=="Main") $mainVtxNr[$i]=`getAttr closestSampler.result.closestVertexIndex`;
				}
			}
	
		//shortestEdgePath vtxs
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			select LipLayer;
			select `polySelect -q -asSelectString -shortestEdgePath $outerVtxNr[$i] $mainVtxNr[$i]`;//outer -> main
			ConvertSelectionToVertices;
			if ($i==$outerNumCv-1 && $b==1) $rightCnrVtxs=`ls -sl`;
			if ($i==$outerNumCv-1 && $b==-1) $leftCnrVtxs=`ls -sl`;
			catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
			select LipLayer;
			select `polySelect -q -asSelectString -shortestEdgePath $innerVtxNr[$i] $mainVtxNr[$i]`;//inner -> main
			ConvertSelectionToVertices;
			$tempString=`ls -sl`;
			if ($i==$outerNumCv-1 && $b==1) $rightCnrVtxs=`stringArrayCatenate $rightCnrVtxs $tempString`;
			if ($i==$outerNumCv-1 && $b==-1) $leftCnrVtxs=`stringArrayCatenate $leftCnrVtxs $tempString`;
			catchQuiet (`skinPercent -tv ($upperLower+"LipJoint"+$i+$side) 1 $skinCluster`);
			}
		}
	}

//hammer any leftovers
select -cl;
for ($i=0;$i<size($lipArea);$i++)
	{
	if (`skinPercent -transform Face_M -ignoreBelow 1 -query -value $skinCluster $lipArea[$i]`)
		select -add $lipArea[$i];
	}
if (size(`ls -sl`))
	weightHammerVerts;

if (!`objExists upperLipMainBuildCurveLeft`)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;


//create clusters & pingPongs
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";
	for ($i=0;$i<7;$i++)
		{
		if ($i==0) {$ctrl="Lip";$side="_R";$type=2;}
		if ($i==1) {$ctrl=$upperLower+"LipB";$side="_R";$type=3;}
		if ($i==2) {$ctrl=$upperLower+"LipA";$side="_R";$type=2;}
		if ($i==3) {$ctrl=$upperLower+"Lip";$side="_M";$type=1;}
		if ($i==4) {$ctrl=$upperLower+"LipA";$side="_L";$type=2;}
		if ($i==5) {$ctrl=$upperLower+"LipB";$side="_L";$type=3;}
		if ($i==6) {$ctrl="Lip";$side="_L";$type=2;}

		select -r ($upperLower+"LipCenterPlane.cv["+(6-$i)+"][4]");

		$tempString=`newCluster " -envelope 1"`;
		rename $tempString[0] ($upperLower+$ctrl+"Cluster"+$side);
		rename $tempString[1] ($upperLower+$ctrl+"ClusterHandle"+$side);
		parent ($upperLower+$ctrl+"ClusterHandle"+$side) LipSetup;
		$tempString=`listConnections ($upperLower+$ctrl+"Cluster"+$side+".message")`;
		rename $tempString[0] ($upperLower+$ctrl+"ClusterSet"+$side);
		sets -add ($upperLower+$ctrl+"ClusterSet"+$side) ($upperLower+"LipCenterPlane.cv["+(6-$i)+"][0:3]");

		if (`objExists TempPos`) delete TempPos;
		createNode -n TempPos transform;
//		$pos=`xform -q -ws -piv ($upperLower+$ctrl+"ClusterHandle"+$side)`;
//		xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
		if ($i<4 || `objExists upperLipOuterCurveLeft`)
			{
			createNode -n tempMotionPath motionPath;
			setAttr tempMotionPath.fractionMode 1;
			connectAttr ($upperLower+"LipOuterCurve.worldSpace") tempMotionPath.geometryPath;
			if ($i>3 && `objExists upperLipOuterCurveLeft`)
				connectAttr -f  ($upperLower+"LipOuterCurveLeft.worldSpace") tempMotionPath.geometryPath;
			connectAttr -f tempMotionPath.allCoordinates TempPos.t;
			if ($i==1)//$libBShapePos
				{
				setAttr tempMotionPath.uValue 0.8;
				$libBShapePos=`xform -q -ws -t TempPos`;
				}
			if ($i==0) setAttr tempMotionPath.uValue 1;
			if ($i==1) setAttr tempMotionPath.uValue 1;
			if ($i==2) setAttr tempMotionPath.uValue 0.6;
			if ($i==3) setAttr tempMotionPath.uValue 0;
			if ($i==4) setAttr tempMotionPath.uValue 0.6;//nonSymm face
			if ($i==5) setAttr tempMotionPath.uValue 1;//nonSymm face
			if ($i==6) setAttr tempMotionPath.uValue 1;//nonSymm face

			//LipB to attach to the vtx before the corner
			if ($i==1)
				{
				setAttr tempMotionPath.fractionMode 0;
				setAttr tempMotionPath.uValue (`getAttr ($upperLower+"LipOuterCurve.spans")`-1);
				}
			$pos=`xform -q -ws -t TempPos`;
			delete tempMotionPath;
//			if ($i!=3)
//				xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] TempPos;
			}
		else
			{
			asAlign TempPos ($ctrl+"_R") 1 0 0 0;
			setAttr TempPos.tx (`getAttr TempPos.tx`*-1);
			}

		if (($i==0 || $i==6) && $upperLower=="lower")
			;//No need of controller
		else
			{
			asPingPong TempPos $ctrl 1 $side $type 1 0;
			//Lip Pucker
			createNode -n ($ctrl+"PuckerOffset"+$side) -p LipPuckerSetup transform;
			createNode -n ($ctrl+"Pucker"+$side) -p ($ctrl+"PuckerOffset"+$side) transform;
			$pos=`xform -q -ws -t NoseCorner`;
			$posA=`xform -q -ws -t Jaw`;
			$posB=`xform -q -ws -t lowerLipOuterCurve.cv[0]`;
			$posAB={(($posA[0]+$posB[0])/2.0),(($posA[1]+$posB[1])/2.0),(($posA[2]+$posB[2])/2.0)};
			$posLowerA={(($posAB[0]+$posD[0])/2.0),(($posAB[1]+$posD[1])/2.0),(($posAB[2]+$posD[2])/2.0)};
			$posC=`xform -q -ws -t SmileBulge`;
			$posD=`xform -q -ws -t FrownBulge`;
			$posUpperA={(($pos[0]+$posC[0])/2.0),(($pos[1]+$posC[1])/2.0),(($pos[2]+$posC[2])/2.0)};
			if ($ctrl+$side=="upperLip_M") xform -ws -t 0 $pos[1] $pos[2] ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="lowerLip_M") xform -ws -t 0 $posAB[1] $posAB[2] ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="upperLipA_R") xform -ws -t $posUpperA[0] $posUpperA[1] $posUpperA[2] ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="upperLipB_R") xform -ws -t (($posUpperA[0]+$posC[0])/2.0) (($posUpperA[1]+$posC[1])/2.0) (($posUpperA[2]+$posC[2])/2.0) ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="upperLipA_L") xform -ws -t ($posUpperA[0]*-1) $posUpperA[1] $posUpperA[2] ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="upperLipB_L") xform -ws -t (($posUpperA[0]+$posC[0])/-2.0) (($posUpperA[1]+$posC[1])/2.0) (($posUpperA[2]+$posC[2])/2.0) ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="Lip_R") xform -ws -t (($posC[0]+$posD[0])/2.0) (($posC[1]+$posD[1])/2.0) (($posC[2]+$posD[2])/2.0) ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="Lip_L") xform -ws -t (($posC[0]+$posD[0])/-2.0) (($posC[1]+$posD[1])/2.0) (($posC[2]+$posD[2])/2.0) ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="lowerLipA_R") xform -ws -t $posLowerA[0] $posLowerA[1] $posLowerA[2] ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="lowerLipB_R") xform -ws -t (($posD[0]+$posLowerA[0])/2.0) (($posD[1]+$posLowerA[1])/2.0) (($posD[2]+$posLowerA[2])/2.0) ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="lowerLipA_L") xform -ws -t ($posLowerA[0]*-1) $posLowerA[1] $posLowerA[2] ($ctrl+"PuckerOffset"+$side);
			if ($ctrl+$side=="lowerLipB_L") xform -ws -t (($posD[0]+$posLowerA[0])/-2.0) (($posD[1]+$posLowerA[1])/2.0) (($posD[2]+$posLowerA[2])/2.0) ($ctrl+"PuckerOffset"+$side);
			$b=-1;
			if ($upperLower=="lower") $b=1;
			delete `aimConstraint -aimVector 0 -1 0 -upVector $b 0 0 -worldUpType "vector" -worldUpVector 1 0 0 ($ctrl+"JointOffset"+$side) ($ctrl+"PuckerOffset"+$side)`;
			parent ($ctrl+"JointOffset"+$side) ($ctrl+"Pucker"+$side);
			if ($ctrl!="LipB" && $ctrl!="Lip")
				{
				connectAttr ($upperLower+"LipPuckerPlusMinusAverage.output1D") ($ctrl+"Pucker"+$side+".rx");
				$tempString=`listConnections -s 1 -d 0 ($ctrl+"Pucker"+$side+".rx")`;
				setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*2.5);
				}
			}
		delete TempPos;

		if ($ctrl==$upperLower+"LipB")//$libBShapePos
			{
			$pos=`xform -q -ws -t ($ctrl+$side)`;
			if ($side=="_L") move -r (($libBShapePos[0]*-1)-$pos[0]) ($libBShapePos[1]-$pos[1]) ($libBShapePos[2]-$pos[2]) ($ctrl+$side+".cv[0:99]");
			if ($side=="_R") move -r (($libBShapePos[0]* 1)-$pos[0]) ($libBShapePos[1]-$pos[1]) ($libBShapePos[2]-$pos[2]) ($ctrl+$side+".cv[0:99]");

			asFacePlaceCtrlByProjection ($ctrl+$side);
			}

		setAttr -l 1 ($upperLower+$ctrl+"ClusterHandle"+$side+".v") 0;
		}
	}

//Weight the `attachment vtx` for Lip_R to Lip_R, so moving the controller does not inderectly cause the controller itself not move differently
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	skinCluster -e  -dr 4 -lw false -wt 0 -ai ("LipJoint"+$side) $skinCluster;
	$pos=`xform -q -ws -t upperLipOuterCurve.cv[99]`;
	if ($side=="_L")
		{
		if (`objExists upperLipMainBuildCurveLeft`)
			$pos=`xform -q -ws -t upperLipMainBuildCurveLeft.cv[99]`;
		else
			$pos[0]=$pos[0]*-1;
		}
	setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	select ("LipLayer.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]");
	skinPercent -tv ("LipJoint"+$side) 1 $skinCluster `ls -sl`;
	}

select -cl;
if (!`objExists upperLipMainBuildCurveLeft`)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

asFaceHalfMoonCurve upperLip_M 90;
asFaceHalfMoonCurve lowerLip_M -90;


//constraint clusters
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";


	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		parentConstraint -mo ("LipJoint"+$side) ($upperLower+"LipClusterHandle"+$side);
		parentConstraint -mo ($upperLower+"LipBJoint"+$side) ($upperLower+$upperLower+"LipBClusterHandle"+$side);
		parentConstraint -mo ($upperLower+"LipAJoint"+$side) ($upperLower+$upperLower+"LipAClusterHandle"+$side);
		if ($b==1)
			parentConstraint -mo ($upperLower+"LipJoint_M") ($upperLower+$upperLower+"LipClusterHandle_M");
//		asFaceAddDrive ($upperLower+"LipBJoint") $side ("Lip") $side 1 {} {};
		//internConstrained
		for ($c=0;$c<size($AB);$c++)
			{
			//ConstrainedWeighted
			createNode -n ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side) -p LipSetup transform;
			createNode -n ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo"+$side) -p ("LipJoint"+$side) transform;
			delete `pointConstraint ($upperLower+"LipClusterHandle"+$side) ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo"+$side)`;
			createNode -n ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo_M") -p ($upperLower+"LipJoint_M") transform;
			delete `pointConstraint ($upperLower+$upperLower+"LipClusterHandle_M") ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo_M")`;


			if (`objExists tempXform`) delete tempXform;
			createNode -n tempXform transform;
			delete `pointConstraint upperupperLipClusterHandle_M tempXform`;
			$posA=`xform -q -ws -t tempXform`;
			delete `pointConstraint ($upperLower+$upperLower+"Lip"+$AB[$c]+"ClusterHandle"+$side) tempXform`;
			$posB=`xform -q -ws -t tempXform`;
			delete `pointConstraint ($upperLower+"LipClusterHandle"+$side) tempXform`;
			$posC=`xform -q -ws -t tempXform`;
			if (`objExists tempXform`) delete tempXform;
			$factor=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`/`mag<<$posA[0]-$posC[0],$posA[1]-$posC[1],$posA[2]-$posC[2]>>`;
			pointConstraint -w $factor ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo"+$side) ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side);
			pointConstraint -w (1-$factor) ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo_M") ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side);

			//re-weighting for behaviour instead of position
			delete ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side+"_pointConstraint1");
			if ($AB[$c]=="A")
				{
				pointConstraint -mo -w 0.25 ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo"+$side) ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side);
				pointConstraint -mo -w 0.75 ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo_M") ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side);
				}
			else
				{
				pointConstraint -mo -w 0.75 ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo"+$side) ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side);
				pointConstraint -mo -w 0.25 ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeightedTo_M") ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side);
				}

			//ConstrainedScale
			createNode -n ($upperLower+"Lip"+$AB[$c]+"ConstrainedScale"+$side) -p ($upperLower+"Lip"+$AB[$c]+"ConstrainedWeighted"+$side) transform;
			createNode -n ($upperLower+"Lip"+$AB[$c]+"ConstrainedPos"+$side) -p ($upperLower+"Lip"+$AB[$c]+"ConstrainedScale"+$side) transform;
			delete `pointConstraint ($upperLower+$upperLower+"Lip"+$AB[$c]+"ClusterHandle"+$side) ($upperLower+"Lip"+$AB[$c]+"ConstrainedPos"+$side)`;
//			asAlign ($upperLower+"Lip"+$AB[$c]+"ConstrainedPos"+$side) ($upperLower+$upperLower+"Lip"+$AB[$c]+"ClusterHandle"+$side) 1 0 0 0;
			if (!`objExists ("Lip"+$side+"MPD")`)
				{
				createNode -n ("Lip"+$side+"MPD") multiplyDivide;
				createNode -n ("Lip"+$side+"PMA") plusMinusAverage;
				createNode -n ("Lip"+$side+"Clamp") clamp;
				setAttr ("Lip"+$side+"PMA.operation") 2;
				xform -ws -t 0 0 0 ("Lip"+$side);
				setAttr ("Lip"+$side+"PMA.input1D[0]") (`getAttr ("Lip"+$side+".tx")`*$b);
				setAttr ("Lip"+$side+".t") -type float3 0 0 0;
				connectAttr ("LipJoint"+$side+".tx") ("Lip"+$side+"PMA.input1D[1]");
				connectAttr ("Lip"+$side+"PMA.output1D") ("Lip"+$side+"MPD.input1.input1X");
				setAttr ("Lip"+$side+"MPD.input2.input2X") `getAttr ("Lip"+$side+"PMA.output1D")`;
				setAttr ("Lip"+$side+"MPD.operation") 2;

				connectAttr ("Lip"+$side+"MPD.outputX") ("Lip"+$side+"Clamp.inputR");
				setAttr ("Lip"+$side+"Clamp.maxR") `getAttr ("Lip"+$side+"MPD.outputX")`;
				}
			connectAttr ("Lip"+$side+"Clamp.outputR") ($upperLower+"Lip"+$AB[$c]+"ConstrainedScale"+$side+".sx");
			connectAttr ("Lip"+$side+"Clamp.outputR") ($upperLower+"Lip"+$AB[$c]+"ConstrainedScale"+$side+".sy");
			connectAttr ("Lip"+$side+"Clamp.outputR") ($upperLower+"Lip"+$AB[$c]+"ConstrainedScale"+$side+".sz");

			//Constrained
			createNode -n ($upperLower+"Lip"+$AB[$c]+"ConstrainedOffset"+$side) -p LipSetup transform;
			createNode -n ($upperLower+"Lip"+$AB[$c]+"Constrained"+$side) -p ($upperLower+"Lip"+$AB[$c]+"ConstrainedOffset"+$side) transform;
			asAlign ($upperLower+"Lip"+$AB[$c]+"ConstrainedOffset"+$side) ($upperLower+"Lip"+$AB[$c]+"ConstrainedPos"+$side) 1 1 0 0;
			parentConstraint ($upperLower+"Lip"+$AB[$c]+"ConstrainedPos"+$side) ($upperLower+"Lip"+$AB[$c]+"Constrained"+$side);

			asFaceAddDrive ($upperLower+"Lip"+$AB[$c]+"Joint") $side ($upperLower+"Lip"+$AB[$c]+"Constrained") $side 1 {} {};
			}
		}
	}

//Press & Roll
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	$outerNumCv=`getAttr ($upperLower+"LipOuterBuildCurve.spans")`+1;
	for ($b=1;$b>-2;$b=$b-2)
		{
		for ($i=0;$i<$outerNumCv;$i++)
			{
			if ($b==1) $side="_R";
			else $side="_L";
			if ($i==0) $side="_M";
			if ($i==0 && $b==-1) continue;

			//Press
			createNode -n ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion") unitConversion;
			setAttr ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion.conversionFactor") (1*`smoothstep 0 1 (1-((1/($outerNumCv-1.0)*$i)))`);
			connectAttr ($upperLower+"LipPressPlusMinusAverage.output3Dy") ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion.input");

			//Squeeze
			createNode -n ($upperLower+"LipJoint"+$i+$side+"SqueezeUnitConversion") unitConversion;
			setAttr ($upperLower+"LipJoint"+$i+$side+"SqueezeUnitConversion.conversionFactor") (1*`smoothstep 0 1 (1-((1/($outerNumCv-1.0)*$i)))`);
			connectAttr ($upperLower+"LipPressPlusMinusAverage.output3Dz") ($upperLower+"LipJoint"+$i+$side+"SqueezeUnitConversion.input");

			$setRange=$upperLower+"LipJoint"+$i+$side+"PressSetRange";
			createNode -n $setRange setRange;
			setAttr ($setRange+".minY") 2;
			setAttr ($setRange+".minZ") 2;
			setAttr ($setRange+".oldMinY") -10;
			setAttr ($setRange+".oldMinZ") -20;
			setAttr ($setRange+".oldMaxY") 10;
			setAttr ($setRange+".oldMaxZ") 20;
			connectAttr ($upperLower+"LipJoint"+$i+$side+"PressUnitConversion.output") ($setRange+".value.valueY");
			connectAttr ($upperLower+"LipJoint"+$i+$side+"SqueezeUnitConversion.output") ($setRange+".value.valueZ");
			connectAttr ($setRange+".outValue.outValueY") ($upperLower+"LipJoint"+$i+$side+".sy");
			connectAttr ($setRange+".outValue.outValueZ") ($upperLower+"LipJoint"+$i+$side+".sz");

			//Roll
			createNode -n ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion") unitConversion;
			setAttr ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion.conversionFactor") ($upperLowerFactor*-0.15*`smoothstep 0 1 (1-((1/($outerNumCv-1.0)*$i)))`);
			connectAttr ($upperLower+"LipRollPlusMinusAverage.output1D") ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion.input");
			connectAttr ($upperLower+"LipJoint"+$i+$side+"RollUnitConversion.output") ($upperLower+"LipJoint"+$i+$side+".jointOrientX");
			}
		}
	}

//LipMix
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	createNode -n ("LipMix"+$side) -p ("LipSideReverse"+$side)  transform;
	}

//Add attrs for mix of local xform with sdk
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	createNode -n ("LipWsOffset"+$side) -p ("Lip"+$side) transform;
	parent ("LipWsOffset"+$side) Acontrols;
	createNode -n ("LipWs"+$side) -p ("LipWsOffset"+$side) transform;
	pointConstraint ("LipMix"+$side) ("LipWs"+$side);
	
	for ($z=0;$z<size($xyz);$z++)
		{
		addAttr -k 0 -ln ("mixT"+$xyz[$z]) -at double ("Lip"+$side);
		connectAttr ("LipWs"+$side+".t"+$xyz[$z]) ("Lip"+$side+".mixT"+$xyz[$z]);
		}
	}

//Lip Squeeze TY
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	setAttr ("ctrlMouth_M.upperSqueeze") 0;
	setAttr ("ctrlMouth_M.lowerSqueeze") 0;
	setAttr ("ctrlMouth_M."+$upperLower+"Squeeze") 20;
	createNode -n ($upperLower+"SqueezeTYOffset_M") -p LipPuckerSetup transform;
	createNode -n ($upperLower+"SqueezeTY_M") -p ($upperLower+"SqueezeTYOffset_M") transform;
	$pos=`xform -q -ws -t ($upperLower+"LipJoint0_M")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"SqueezeTYOffset_M");
	parent ($upperLower+"LipPuckerOffset_M") ($upperLower+"SqueezeTY_M");

	createNode -n ($upperLower+"SqueezeTYMPD") multiplyDivide;
	connectAttr ($upperLower+"LipPressPlusMinusAverage.output3Dz") ($upperLower+"SqueezeTYMPD.input1.input1X");
	$posA=`xform -q -ws -t upperLipJoint0_M`;
	$posB=`xform -q -ws -t lowerLipJoint0_M`;
	$posC={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};

	for ($i=1;$i<99;$i++)
		{
		select ($upperLower+"SqueezeTY_M");
		move -r 0 (($posB[1]-$posA[1])/(20.0*$upperLowerFactor));
		$posD=`xform -q -ws -t ($upperLower+"LipJoint0_M")`;
		if (($upperLower=="upper" && $posD[1]<$posC[1]) || ($upperLower=="lower" && $posD[1]>$posC[1]))
			{
			break;
			}
		}

	setAttr ($upperLower+"SqueezeTYMPD.input2.input2X") (`getAttr ($upperLower+"SqueezeTY_M.ty")`/20.0);
	connectAttr ($upperLower+"SqueezeTYMPD.outputX") ($upperLower+"SqueezeTY_M.ty");
	}

setAttr ("ctrlMouth_M.upperSqueeze") 0;
setAttr ("ctrlMouth_M.lowerSqueeze") 0;

delete LipConstruction;
if (`objExists closestNurbsSampler`) delete closestNurbsSampler;

progressBar -e -ep $gMainProgressBar;

select -cl;
setToolTo $gSelect;
}

global proc asFaceLipFalloff ()
{
global string $gMove;
global string $gMainProgressBar;
int $vtxNrs[];
int $test,$lipFalloff,$numCVs;
float $value,$faceWeightAddValue,$minDist,$dist,$weight,$portion,$weightValue;
float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;
float $fadeFloat=1.3;
if (`floatField -q -ex asFaceLipFalloffSideFadeFloatField`)
	$fadeFloat=`floatField -q -v asFaceLipFalloffSideFadeFloatField`;
float $pos[],$posA[],$posB[],$values[],$weights[];
string $skinCluster="LipSC";
string $innerOuter,$inf,$closestLipOuterCurveVtx;
string $tempString[],$tempString2[],$tempString3[],$infs[],$lipFalloffInsideMouthArea[],$upperVtxs[],$lowerVtxs[],$upperVtxsL[],$lowerVtxsL[];
string $innerLipFalloffVtxs[],$outerLipFalloffVtxs[],$lipOuterCurveVtx[],$previousSel[],$nonLipFalloffAreaVtxs[],$doneVtxs[];

if (`objExists asFaceLipFalloffTest`)
	{
	$test=1;
	delete asFaceLipFalloffTest;
	}

setFocus MayaWindow;//ensure execution of intField -cc cmd, if focus is still at intField
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;

xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 upperLipA_R upperLipB_R lowerLipA_R lowerLipB_R Lip_R;

if (`objExists lipFalloffArea`) delete lipFalloffArea;
if (`objExists lipFalloffInsideMouthArea`) delete lipFalloffInsideMouthArea;
createNode -n lipFalloffArea objectSet;
sets -add FaceAreas lipFalloffArea;
if (!`objExists lipFalloffAreaMax`)
	{
	createNode -n lipFalloffAreaMax objectSet;
	sets -add FaceBuildingSets lipFalloffAreaMax;
	}

for ($a=0;$a<2;$a++)
	{
	if ($a==0) $innerOuter="Inner";
	if ($a==1) $innerOuter="Outer";

	$lipFalloff=`intField -q -v ("lipFalloff"+$innerOuter+"IntField")`;

	duplicate -n ("upperLip"+$innerOuter+"Curve_L") ("upperLip"+$innerOuter+"Curve");
	duplicate -n ("lowerLip"+$innerOuter+"Curve_L") ("lowerLip"+$innerOuter+"Curve");
	setAttr ("upperLip"+$innerOuter+"Curve_L.sx") -1;
	setAttr ("lowerLip"+$innerOuter+"Curve_L.sx") -1;

	eval ("select "+`asGetFaceFitSelection ("upperLip"+$innerOuter+"Curve")`);
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString LipLayer`;
	$upperVtxs=`ls -sl -fl`;
	eval ("select "+`asGetFaceFitSelection ("lowerLip"+$innerOuter+"Curve")`);
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString LipLayer`;
	$lowerVtxs=`ls -sl -fl`;

	//+left side
	if (`objExists ("upperLip"+$innerOuter+"CurveLeft")`)
		eval ("select "+`asGetFaceFitSelection ("upperLip"+$innerOuter+"CurveLeft")`);
	else
		eval ("select "+`asGetFaceFitSelection ("upperLip"+$innerOuter+"Curve_L")`);
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString LipLayer`;
	$upperVtxsL=`ls -sl -fl`;
	if (`objExists ("lowerLip"+$innerOuter+"CurveLeft")`)
		eval ("select "+`asGetFaceFitSelection ("lowerLip"+$innerOuter+"CurveLeft")`);
	else
		eval ("select "+`asGetFaceFitSelection ("lowerLip"+$innerOuter+"Curve_L")`);
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString LipLayer`;
	$lowerVtxsL=`ls -sl -fl`;

	select $upperVtxs $lowerVtxs $upperVtxsL $lowerVtxsL;
	for ($i=0;$i<$lipFalloff;$i++)
		{
		polySelectConstraint -pp 1 -t 0x0001;
		select -d lipArea;
		}
	select -d lipArea;
	if (size(`ls -sl`))
		{
		sets -add lipFalloffArea `ls -sl`;
		sets -add lipFalloffAreaMax `ls -sl`;
		}
	if ($innerOuter=="Inner") $innerLipFalloffVtxs=`ls -sl -fl`;
	if ($innerOuter=="Outer") $outerLipFalloffVtxs=`ls -sl -fl`;

	delete ("upperLip"+$innerOuter+"Curve_L") ("lowerLip"+$innerOuter+"Curve_L");
	}

select lipFalloffArea;
refresh;

if ($test)
	return;

eval ("select "+`asGetFaceFitSelection FaceFitLipOuterCurve`);
$lipOuterCurveVtx=`ls -sl -fl`;

//flood to head first, as rhis function might have ran previously with a larger falloff
select lipFalloffAreaMax;
catchQuiet (`skinPercent -tv Face_M 1 $skinCluster`);

//just hammer
select lipFalloffArea;
if (size(`ls -sl`))
	weightHammerVerts;

//keep lipFalloffArea vtx from weighting hard to joints near mouthCorner, to avoid chin skinfolding upon lip O shape
$posB=`xform -q -ws -t Lip_R`;
//$posB[0]=$posB[0]*1.2;
select lipFalloffArea;
$tempString=`ls -sl -fl`;
select -cl;
progressBar -e -st "Lip Falloff" -bp -ii 0 -min 0 -max (`size($tempString)`+1) $gMainProgressBar;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`checkBox -q -ex asFaceLipFalloffSideFadeCheckBox`)
		if (`checkBox -q -v asFaceLipFalloffSideFadeCheckBox`==0)
			break;
	progressBar -e -s 1 $gMainProgressBar;
	$pos=`xform -q -ws -t $tempString[$i]`;
	if (`objExists FaceFitLipMainLeft`)
		{
		if ($pos[0]>$sideTreshold)
			{
			$posB=`xform -q -ws -t Lip_L`;
			$posB[0]=$posB[0]*-1;
			$pos[0]=$pos[0]*-1;
			}
		else
			$posB=`xform -q -ws -t Lip_R`;
		}
	else
		if ($pos[0]>$sideTreshold)
			continue;
	$value=`skinPercent -transform Face_M -query $skinCluster $tempString[$i]`;
	$faceWeightAddValue=0;
	$portion=($posB[0]*$fadeFloat)-$posB[0];//increasing the $fadeFloat number, will increase the `softness` of the weightFalloff near mouthCorner
	if ($pos[0]<($posB[0]-$portion))
		$faceWeightAddValue=smoothstep (abs($posB[0]-$portion),abs($posB[0]+$portion),abs($pos[0]));
//	catchQuiet (`skinPercent -tv Face_M ($value+$faceWeightAddValue) $skinCluster $tempString[$i]`);
	$vtxNrs[size($vtxNrs)]=`asComponentToNr $tempString[$i]`;
	$weightValue=$value+$faceWeightAddValue;
	if ($weightValue>1)
		$weightValue=1;
	$weights[size($weights)]=$weightValue;
	}
asSkinWeightSet Face_M LipLayer $skinCluster $vtxNrs $weights;

if (!`objExists FaceFitLipMainLeft`)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

progressBar -e -ep $gMainProgressBar;

//just hammer inside
select $lipFalloffInsideMouthArea;
if (size(`ls -sl`))
	weightHammerVerts;

select upperLipA_R;
setToolTo $gMove;
}

global proc asFaceJaw ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $skinCluster="JawSC";
float $scale=`asFaceGetScale`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $pos[],$pos2[],$posA[],$posB[];
string $tempString[],$lipCtrl[],$lipSide[],$lipUpLo[];
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $tr[]={"t","r"};
string $upLoCtrl,$side;

//Existing Jaw ?
if (`objExists Jaw_M`)
	error "Jaw_M already exists, can not build new Jaw, remove old jaw first";

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n JawLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` JawLayer 1 asFaceBS;
setAttr JawLayer.v 1;
select Face_M JawLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] JawSC;
asReuseIntermediateMesh $geometry JawLayer;

//correspond ctrls vis
$tempString=`listRelatives -c Acontrols`;
$tempString2=`listRelatives -c Bcontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Ccontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Regionscontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
setAttr ctrlBox.RegionsCtrlVis 1;
setAttr lowerFaceOffset_M.v 1;

asCreateFaceController "Jaw" "_M" 4;
$pos=`xform -q -ws -t JawPivot`;
xform -ws -t 0 $pos[1] $pos[2] JawOffset_M;
asAlign JawJointOffset_M Jaw_M 1 0 0 0;
parent JawOffset_M lowerFace_M;
scale -r -p 0 $pos[1] $pos[2] 8 2 8 Jaw_M.cv[0:99];
$pos2=`xform -q -ws -t Jaw`;
move -r 0 ($pos2[1]-$pos[1]) (($pos2[2]-$pos[2])*1.3) Jaw_M.cv[0:99];
asFaceAddDrive "JawJoint" "_M" "Jaw" "_M" 1 {} {};
asFaceAddDrive "JawJoint" "_M" "SDKJaw" "_M" 1 {} {};

//JawMix_M, for tongue and lowerteeth to follow
createNode -n JawMix_M -p JawSideReverse_M transform;
createNode -n JawMixTPMA plusMinusAverage;
createNode -n JawMixRPMA plusMinusAverage;
connectAttr Jaw_M.t JawMixTPMA.input3D[0];
connectAttr Jaw_M.r JawMixRPMA.input3D[0];
connectAttr SDKJaw_M.t JawMixTPMA.input3D[1];
connectAttr SDKJaw_M.r JawMixRPMA.input3D[1];
connectAttr JawMixTPMA.output3D JawMix_M.t;
connectAttr JawMixRPMA.output3D JawMix_M.r;
createNode -n JawMixSMPD multiplyDivide;
connectAttr Jaw_M.s JawMixSMPD.input1;
connectAttr SDKJaw_M.s JawMixSMPD.input2;
connectAttr JawMixSMPD.output JawMix_M.s;

string $upperLower,$upperLowerTeeth;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$upperLowerTeeth=$upperTeeth;}
	else {$upperLower="lower";$upperLowerTeeth=$lowerTeeth;}

	if ($upperLowerTeeth!="")
		{
		eval ("select "+$upperLowerTeeth);
		$tempString=`ls -sl -o`;
		if (size($tempString)>1)
			select $tempString[0];
		float $bb[]=`xform -q -ws -bb`;

		select -cl;
		joint -n ($upperLower+"TeethJoint_M");
//		parent ($upperLower+"TeethJoint_M") ($upperLower+"FaceJoint_M");
		parent ($upperLower+"TeethJoint_M") Face_M;

//		createNode -n ($upperLower+"TeethOffset_M") -p ($upperLower+"Face_M") transform;
		createNode -n ($upperLower+"TeethOffset_M") -p lowerFace_M transform;

		xform -ws -t 0 (($bb[1]+$bb[4])/2.0) (($bb[2]+$bb[5])/2.0) ($upperLower+"TeethOffset_M");

		$tempString=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 4 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] ($upperLower+"Teeth_M");
		parent -r ($upperLower+"Teeth_M") ($upperLower+"TeethOffset_M");
		scale (($bb[3]-$bb[0])/$faceFitScale) 1 (($bb[5]-$bb[2])/$faceFitScale) ($upperLower+"Teeth_M.cv[0:7]");
		sets -add FaceControlSet ($upperLower+"Teeth_M");
		setAttr ($upperLower+"Teeth_MShape.overrideEnabled") 1;
		setAttr ($upperLower+"Teeth_MShape.overrideColor") 17;
		connectAttr ctrlBox.TeethCtrlVis ($upperLower+"Teeth_MShape.overrideVisibility");

		if ($upperLower=="lower")
			{
			createNode -n lowerTeethStatic_M -p Jaw_M transform;
			parent lowerTeethStatic_M lowerFace_M;
			duplicate -n lowerTeethBlend_M  lowerTeethStatic_M ;
			parentConstraint lowerTeethStatic_M JawMix_M lowerTeethBlend_M;
			scaleConstraint lowerTeethStatic_M JawMix_M lowerTeethBlend_M;
			parent lowerTeethOffset_M lowerTeethBlend_M;
			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 lowerTeeth_M;
			asUnitConvertAndReverse lowerTeethBlend lowerTeeth_M.follow;
			connectAttr lowerTeethBlendReverse.outputX lowerTeethBlend_M_parentConstraint1.lowerTeethStatic_MW0;
			connectAttr lowerTeethBlendReverse.outputX lowerTeethBlend_M_scaleConstraint1.lowerTeethStatic_MW0;
			connectAttr lowerTeethBlendUnitConversion.output lowerTeethBlend_M_parentConstraint1.JawMix_MW1;
			connectAttr lowerTeethBlendUnitConversion.output lowerTeethBlend_M_scaleConstraint1.JawMix_MW1;
			}

		parentConstraint ($upperLower+"Teeth_M") ($upperLower+"TeethJoint_M");
		scaleConstraint ($upperLower+"Teeth_M") ($upperLower+"TeethJoint_M");
		}
	}

setAttr JawJoint_M.segmentScaleCompensate 0;
if (`objExists upperTeethJoint_M`)
	setAttr upperTeethJoint_M.segmentScaleCompensate 0;
if (`objExists lowerTeethJoint_M`)
setAttr lowerTeethJoint_M.segmentScaleCompensate 0;

if (`objExists upperTeethOffset_M`) setAttr upperTeethOffset_M.v 0;
if (`objExists lowerTeethOffset_M`) setAttr lowerTeethOffset_M.v 0;

skinCluster -e -lw false -wt 0 -ai JawJoint_M $skinCluster;

//Skin jaw-curves
select Face_M JawJoint_M JawCurve;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawCurveSC;

//Create the JawOpenLayer mesh
duplicate -n JawOpenLayer templateLayer;
setAttr JawLayer.v 0;
setAttr JawOpenLayer.v 1;
sets -e -forceElement initialShadingGroup JawOpenLayer;
select JawOpenLayer Face_M JawJoint_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] JawOpenLayerSC;
skinPercent -tv Face_M 1 JawOpenLayerSC JawOpenLayer.vtx[0:99999];

select `asobjSetCast lipArea {} JawOpenLayer`;
sets -n lipAreaJawOpenLayer;
sets -add FaceBuildingSets lipAreaJawOpenLayer;

asSkinTeeth;

asFaceDesignMouthOpen;
asFaceWeightLips;
asFaceUpdateJawCurvesWeights;

setAttr JawLayer.v 0;

parent -w FaceFitJawCurves;
parent mouthOpenSoftModHandle FaceBuildInProgress;

currentTime 30;
select Jaw_M;
autoKeyframe -st 1;
}

global proc asFaceJawFinish ()
{
global string $gSelect;
setToolTo $gSelect;
int $upperLowerFactor,$outerNumCv;
float $jawHeadWeight,$lipValue,$jawWeightAtMouthCorner;
float $values[],$cnrValues[],$pos[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $lipInf,$upperLower,$sourceSide,$mouthCornerVtx;
string $sel[]=`ls -sl`;
string $tempString[],$infs[],$infJoints[],$attrs[];

currentTime 0 ;

select JawOpenLayer JawLayer;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
duplicate -n TempJawLayer templateLayer;
//select Face_M JawJoint_M TempJawLayer;
select `listConnections -type joint JawSC.matrix`;
select -add TempJawLayer;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
select JawLayer TempJawLayer;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;


//find out percentage influence at mouthCorner
select upperLipOuterCurve.cv[`getAttr upperLipOuterCurve.spans`];
$pos=`xform -q -ws -t`;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f JawOpenLayer.outMesh closestSampler.inMesh;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$mouthCornerVtx="JawOpenLayer.vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete closestSampler;
$infs=`skinPercent -ignoreBelow 0.001 -q -t JawOpenLayerSC $mouthCornerVtx`;
$values=`skinPercent -ignoreBelow 0.001 -q -v JawOpenLayerSC $mouthCornerVtx`;
for ($y=0;$y<size($infs);$y++)
	if ($infs[$y]=="JawJoint_M")
		$jawWeightAtMouthCorner=$values[$y];

for ($i=0;$i<`getAttr -s mouthOpenSoftMod.falloffCurve`;$i++)
	setAttr ("mouthOpenSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue") $jawWeightAtMouthCorner;

asFaceWeightLips;
asFaceUpdateJawCurvesWeights;

duplicate -n StickyLipsLayer templateLayer;
select Face_M JawJoint_M StickyLipsLayer;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
select JawOpenLayer StickyLipsLayer;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete LipDeformations LipDeform mouthOpenSoftModHandle JawCurveSC;
parent FaceFitJawCurves FaceFitSkeleton;

select TempJawLayer JawLayer;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

delete JawOpenLayer TempJawLayer;

setAttr JawLayer.v 1;

//change the jaw animation to DrivingSystem
currentTime 30;

asDsSdk ("ctrlMouth_M.ty") ("SDKJaw_M.ty") -1 `getAttr Jaw_M.ty`;
asDsSdk ("ctrlMouth_M.ty") ("SDKJaw_M.tz") -1 `getAttr Jaw_M.tz`;
asDsSdk ("ctrlMouth_M.ty") ("SDKJaw_M.rx") -1 `getAttr Jaw_M.rx`;


delete `listConnections -s 1 -d 0 -type animCurve Jaw_M`;
delete `listConnections -s 1 -d 0 -type animCurve ctrlMouth_M`;

setAttr ctrlMouth_M.ty 0;

setAttr -l 0 Jaw_M.tx;
setAttr -l 0 Jaw_M.ry;
setAttr -l 0 Jaw_M.rz;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 Jaw_M;
currentTime 0 ;

asShowLayer Normal;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v 1;

//re-apply weighting for teeth & tounge that is part of Main Mesh.
//actually `move` weighting from JawLayer to Main Layer
if (`gmatch $upperTeeth ($geometry+"*")` && `gmatch $upperTeeth "*[.]*"`)
	{
	eval ("select "+$upperTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString JawLayer`;
	skinPercent -tv Face_M 1 JawSC `ls -sl`;
	skinCluster -e -dr 4 -lw false -wt 0 -ai upperTeethJoint_M $skinCluster;
	select `asobjSetCast "" $tempString $geometry`;
	skinPercent -tv upperTeethJoint_M 1 $skinCluster `ls -sl`;
	}
if (`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString JawLayer`;
	skinPercent -tv Face_M 1 JawSC `ls -sl`;
	skinCluster -e -dr 4 -lw false -wt 0 -ai lowerTeethJoint_M $skinCluster;
	select `asobjSetCast "" $tempString $geometry`;
	skinPercent -tv lowerTeethJoint_M 1 $skinCluster `ls -sl`;
	}
if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
	{
	eval ("select "+$tongue);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString JawLayer`;
	skinPercent -tv Face_M 1 JawSC `ls -sl`;
	}

//delete lipFalloffWeights;
catchQuiet (`select $sel`);
}

global proc asFaceZipperLips ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $pos[],$posA[],$posB[];
float $dist,$value;
int $upperLipMainNumCVs=`getAttr upperLipMainCurve.spans`+1;
int $vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
string $tempString[],$tempString2[];

createNode -n ZipperLipSetup -p FaceMotionSystem transform;
setAttr -l 1 ZipperLipSetup.v 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	//create LayerMesh
	if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
	$tempString=`listRelatives -c DeformationLayers`;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($tempString[$i]+".v") 0;
	duplicate -n ("zipperLips"+$side+"Layer") templateLayer; 
	blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` ("zipperLips"+$side+"Layer") 1 asFaceBS;
	setAttr ("zipperLips"+$side+"Layer.v") 1;

	$pos=`xform -q -ws -t upperLipMainCurve.cv[$upperLipMainNumCVs]`;
	if ($side=="_L") $pos[0]=$pos[0]*-1;
	select -r ("zipperLips"+$side+"Layer");
	$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
	rename $tempString[0] ("ZipperSoftMod"+$side);
	rename $tempString[1] ("ZipperSoftModHandle"+$side);
	parent ("ZipperSoftModHandle"+$side) ZipperLipSetup;
	setAttr ("ZipperSoftMod"+$side+".falloffRadius") 999;
	setAttr ("ZipperSoftMod"+$side+".falloffMode") 0;
	setAttr -type float3 ("ZipperSoftModHandle"+$side+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
	setAttr ("ZipperSoftMod"+$side+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
	xform -piv $pos[0] $pos[1] $pos[2] ("ZipperSoftModHandle"+$side);
//	setAttr ("ZipperSoftMod"+$side+".falloffCurve[1].falloffCurve_Position") 0.95;
	parentConstraint -mo JawJoint_M ("ZipperSoftModHandle"+$side);
	}

//correspond ctrls vis
setAttr JawOffset_M.v 0;

connectAttr -f ZipperSoftMod_R.falloffCurve ZipperSoftMod_L.falloffCurve;

duplicate -n TempStickyLipsBlenderLayer templateLayer;
select JawLayer StickyLipsLayer TempStickyLipsBlenderLayer;
blendShape -n TempStickyLipsBlenderBS -frontOfChain;

//First find $maxDist
eval ("select "+`asGetFaceFitSelection FaceFitLipMainCurve`);
$tempString=`ls -sl`;
select `asobjSetCast "" $tempString TempStickyLipsBlenderLayer`;
$tempString=`ls -sl`;
for ($i=0;$i<$vtxsFromLipToNose*2;$i++)
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
$tempString=`ls -sl -fl`;
$tempString2=$tempString;
select -cl;
float $maxDist=0;
setAttr ctrlMouth_M.ty -1;
for ($i=0;$i<size($tempString);$i++)
	{
//	setAttr "ctrlMouth_M.stickyLips" 0;
	setAttr TempStickyLipsBlenderBS.JawLayer 1;
	setAttr TempStickyLipsBlenderBS.StickyLipsLayer 0;
	$posA=`xform -q -ws -t $tempString[$i]`;
//	setAttr "ctrlMouth_M.stickyLips" 10;
	setAttr TempStickyLipsBlenderBS.JawLayer 0;
	setAttr TempStickyLipsBlenderBS.StickyLipsLayer 1;
	$posB=`xform -q -ws -t $tempString[$i]`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist>$maxDist)
	    $maxDist=$dist;
	}
//Then get Selection on Both sides
setAttr ctrlMouth_M.ty 0;
setAttr "FaceFitLipMainCurve.scaleX" -1;
eval ("select "+`asGetFaceFitSelection FaceFitLipMainCurve`);
$tempString=`ls -sl`;
select `asobjSetCast "" $tempString TempStickyLipsBlenderLayer`;
for ($i=0;$i<$vtxsFromLipToNose*2;$i++)
	polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
select -add $tempString2;
$tempString=`ls -sl -fl`;
setAttr "FaceFitLipMainCurve.scaleX" 1;
select -cl;
setAttr ctrlMouth_M.ty -1;

//Then set weight to $dist/$maxDist
percent -v 0 ZipperSoftMod_R zipperLips_RLayer;
percent -v 0 ZipperSoftMod_L zipperLips_LLayer;
for ($i=0;$i<size($tempString);$i++)
	{
//	setAttr "ctrlMouth_M.stickyLips" 0;
	setAttr TempStickyLipsBlenderBS.JawLayer 1;
	setAttr TempStickyLipsBlenderBS.StickyLipsLayer 0;
	$posA=`xform -q -ws -t $tempString[$i]`;
//	setAttr "ctrlMouth_M.stickyLips" 10;
	setAttr TempStickyLipsBlenderBS.JawLayer 0;
	setAttr TempStickyLipsBlenderBS.StickyLipsLayer 1;
	$posB=`xform -q -ws -t $tempString[$i]`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($maxDist>0)
		$value=($dist/$maxDist)/2.0;
	if ($posA[1]<$posB[1]) $value=$value*-1;
	percent -v $value ZipperSoftMod_R `substitute TempStickyLipsBlenderLayer $tempString[$i] "zipperLips_RLayer"`;
	percent -v $value ZipperSoftMod_L `substitute TempStickyLipsBlenderLayer $tempString[$i] "zipperLips_LLayer"`;
	}
//setAttr "ctrlMouth_M.stickyLips" 0;

delete TempStickyLipsBlenderLayer StickyLipsLayer;

$posA=`xform -q -ws -t upperLipMainCurve.cv[$upperLipMainNumCVs]`;
$posB=`xform -q -ws -t upperLipMainCurve.cv[0]`;
$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`*2;
addAttr -k 1 -ln falloffRadius -at double -dv ($dist/10.0) ZipperSoftModHandle_R;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	addAttr -k 1 -ln ("zipLips"+$side) -at double -min 0 -max 10 -dv 0 ctrlMouth_M;

	createNode -n ("zipLips"+$side+"MultiplyDivide") multiplyDivide;
	connectAttr ZipperSoftModHandle_R.falloffRadius ("zipLips"+$side+"MultiplyDivide.input2.input2X");
	connectAttr ("ctrlMouth_M.zipLips"+$side) ("zipLips"+$side+"MultiplyDivide.input1.input1X");

	connectAttr ("zipLips"+$side+"MultiplyDivide.outputX")("ZipperSoftMod"+$side+".falloffRadius");

	asReuseIntermediateMesh $geometry ("zipperLips"+$side+"Layer");
	}

parent -w ZipperSoftModHandle_R;
setAttr ctrlMouth_M.zipLips_L 5;
setAttr ctrlMouth_M.zipLips_R 5;

asShowLayer Normal;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v 1;

select ctrlMouth_M;
}

global proc asFaceNose ()
{
global string $gMainProgressBar;
int $type;
float $pos[],$posA[],$posB[];
float $radius,$falloffRadius,$noseUnderFalloffRadius;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $skinCluster="NoseSC";
string $noseLocs[]={"NoseSide","NoseUnder","NoseMiddle","Nostril","NoseCorner","Nose"};
string $side;

//Finish zipperLips first
parent ZipperSoftModHandle_R ZipperLipSetup;
setAttr ctrlMouth_M.tx 0;
setAttr ctrlMouth_M.ty 0;
setAttr ctrlMouth_M.zipLips_R 0;
setAttr ctrlMouth_M.zipLips_L 0;

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n NoseLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` NoseLayer 1 asFaceBS;
setAttr NoseLayer.v 1;
select Face_M NoseLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] NoseSC;
asReuseIntermediateMesh $geometry NoseLayer;

//correspond ctrls vis 

$pos=`xform -q -ws -t Nose`;
$posA=$pos;
$posB=`xform -q -ws -t NoseCorner`;
$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

if (`objExists TempPos`) delete TempPos;
createNode -n TempPos transform;

progressBar -e -st "Lip Falloff" -bp -ii 0 -min 0 -max `size($noseLocs)` $gMainProgressBar;

//asPingPong Nose NoseRegion 1 "_M" 4 1 0;
asCreateFaceController "NoseRegion" "_M" 4;
asFaceAddDrive "NoseRegionJoint" "_M" "NoseRegion" "_M" 1 {} {};
asFaceAddDrive "NoseRegionJoint" "_M" "SDKNoseRegion" "_M" 1 {} {};
//parent NoseRegionOffset_M middleFace_M;
$pos=`xform -q -ws -t Nose`;
xform -ws -t 0 $pos[1] $pos[2] NoseRegionOffset_M;
asAlign NoseRegionJointOffset_M NoseRegion_M 1 0 0 0;
scale -r -p $pos[0] $pos[1] $pos[2] 3 3 3 NoseRegion_M.cv[0:7];
setAttr NoseRegionOffset_M.v 0;

$posA=`xform -q -ws -t NoseUnder`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[0]`;
$noseUnderFalloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;

for ($c=0;$c<size($noseLocs);$c++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";
		if ($noseLocs[$c]=="Nose" || $noseLocs[$c]=="NoseUnder" || $noseLocs[$c]=="NoseMiddle")
			{
			if ($b==1) $side="_M";
			else continue;
			}

		progressBar -e -s 1 $gMainProgressBar;
		if (!`objExists $noseLocs[$c]`)
			continue;	

		else if ($noseLocs[$c]=="Nostril" || $noseLocs[$c]=="NoseSide" || $noseLocs[$c]=="NoseMiddle" || $noseLocs[$c]=="NoseUnder") $type=3;
		else $type=2;

		$pos=`xform -q -ws -t $noseLocs[$c]`;
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] TempPos;
		asPingPong TempPos $noseLocs[$c] 1 $side $type 1 0;
//		asParentPingPongJoint ($noseLocs[$c]+"Joint"+$side) NoseRegionJoint_M;
		skinCluster -e -dr 4 -lw false -wt 0 -ai  ($noseLocs[$c]+"Joint"+$side) $skinCluster;

		$radius=$falloffRadius;
		if ($noseLocs[$c]=="NoseUnder")
			$radius=$noseUnderFalloffRadius;
		if ($noseLocs[$c]=="Nostril" || $noseLocs[$c]=="NoseSide")
			$radius=$falloffRadius/2.0;
		if ($side!="_L")
			asSkinWeightBySoftMod ($noseLocs[$c]+"Joint"+$side) NoseLayer $skinCluster $radius 1;
		}
	}
progressBar -e -ep $gMainProgressBar;
if (`objExists TempPos`) delete TempPos;

copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select Nose_M;
}

global proc asFaceSmilePull ()
{
global string $gMove;
setToolTo $gMove;
int $autoKeyState=`autoKeyframe -q -state`;
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
float $scale=`asFaceGetScale`;
float $falloffRadius,$distToEyeCrn;
float $pos[],$posA[],$posB[],$posC[];
string $side,$leftSuffix;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster="SmilePullSC";
string $tempString[];
string $xyz[]={"x","y","z"};

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n SmilePullLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` SmilePullLayer 1 asFaceBS;
setAttr SmilePullLayer.v 1;
select Face_M SmilePullLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] SmilePullSC;
asReuseIntermediateMesh $geometry SmilePullLayer;

//correspond ctrls vis
$tempString=`listRelatives -c Acontrols`;
$tempString2=`listRelatives -c Bcontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Ccontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
setAttr ctrlBox.RegionsCtrlVis 0;


for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($side=="_L" && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	$pos=`xform -q -ws -t ("upperLipOuterCurve"+$leftSuffix+".cv["+($upperLipOuterNumCVs-1)+"]")`;
	$posA=`xform -q -ws -t JawPivot`;
	$posB=`xform -q -ws -t ("upperEyeLidOuterCurve"+$leftSuffix+".cv["+($upperEyeLidOuterNumCVs-1)+"]")`;
	if ($side=="_L" && !`objExists FaceFitEyeLidMainLeft`)
		{
		$pos[0]=$pos[0]*-1;
		$posB[0]=$posB[0]*-1;
		}
	$distToEyeCrn=`mag<<$pos[0]-$posB[0],$pos[1]-$posB[1],$pos[2]-$posB[2]>>`;
//changing smilePull direction to be towards JawPivot
//	$posA[0]=(($posA[0]+$posB[0])/2.0);$posA[1]=(($posA[1]+$posB[1])/2.0);$posA[2]=(($posA[2]+$posB[2])/2.0);
	$posB=`xform -q -ws -t NoseCorner`;
	createNode -n LipPullLocator transform;
	xform -ws -t $posA[0] $posA[1] $posA[2] LipPullLocator;
	createNode -n LipPullStaticLocator transform;
	xform -ws -t $pos[0] $pos[1] $pos[2] LipPullStaticLocator;
	if (`objExists TempPos`) delete TempPos;
	createNode -n TempPos transform;
	pointConstraint LipPullStaticLocator LipPullLocator TempPos;
	setAttr TempPos_pointConstraint1.LipPullLocatorW1 0.5;
	$posA=`xform -q -ws -t TempPos`;

	//$falloffRadius is 1.5x the distance to sceneCenterX 
	$falloffRadius=$pos[0]*-1.5*$b;

	//Or if $distToEyeCrn is nearer
	if ($distToEyeCrn<$falloffRadius)
		$falloffRadius=$distToEyeCrn;

	asPingPong LipPullStaticLocator LipPull 1 $side 1 1 0;
	skinCluster -e -dr 4 -lw false -wt 0 -ai ("LipPullJoint"+$side) SmilePullSC;
	asSkinWeightBySoftMod ("LipPullJoint"+$side) SmilePullLayer SmilePullSC $falloffRadius 1;

	addAttr -k 0 -ln falloffRadius -at double -dv $falloffRadius ("LipPull"+$side);

	//tweak curve
	move -r 0 0 ($scale/20.0) ("LipPull"+$side+".cv[0:7]");
	asFaceHalfMoonCurve ("LipPull"+$side) 0;

	delete TempPos LipPullStaticLocator LipPullLocator;
	xform -ws -t $posA[0] $posA[1] $posA[2] ("LipPull"+$side);
	$posA=`getAttr ("LipPull"+$side+".t")`;
	setAttr -type float3 ("LipPull"+$side+".t") 0 0 0;
	if ($side=="_R")
		$posC=$posA;
	}

//connect _R to _L
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("LipPull_R.t"+$xyz[$z]) ("LipPull_L.t"+$xyz[$z]) ;
setAttr LipPullOffset_L.v 0;

//fitAnim
if ($autoKeyState) autoKeyframe -state 0;
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 0;
setKeyframe -shape 0 LipPull_R;
currentTime 30;
setAttr -type float3 LipPull_R.t $posC[0] $posC[1] $posC[2];
asLockAttr LipPull_R 0 1 1 1;
setKeyframe -shape 0 LipPull_R;
if ($autoKeyState) autoKeyframe -state 1;

currentTime 30;
select LipPull_R;
}

global proc asFaceSmileBulge ()
{
global string $gMove;
setToolTo $gMove;
int $autoKeyState=`autoKeyframe -q -state`;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
float $falloffRadius,$smileBulgeVtxValue;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $pos[],$posA[],$posB[],$values[];
string $side,$smileBulgeVtx;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[],$infs[];
string $xyz[]={"x","y","z"};

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n SmileBulgeLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` SmileBulgeLayer 1 asFaceBS;
setAttr SmileBulgeLayer.v 1;
select Face_M SmileBulgeLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] SmileBulgeSC;
asReuseIntermediateMesh $geometry SmileBulgeLayer;

asShowLayer Normal;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v 1;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	currentTime 0;
	if (`objExists tempXform`) delete tempXform;
	createNode -n tempXform transform;
	$pos=`xform -q -ws -t SmileBulge`;
	xform -ws -t $pos[0] $pos[1] $pos[2] tempXform;
	delete `geometryConstraint lowerEyeLidOuterCurve tempXform`;
	$posB=`xform -q -ws -t tempXform`;
	$falloffRadius=`mag<<$pos[0]-$posB[0],$pos[1]-$posB[1],$pos[2]-$posB[2]>>`*1.2;

	//or if sceneCenterX is nearer
	if ($falloffRadius>$posB[0]*-1.2)
		$falloffRadius=$posB[0]*-1.2;

	asAlign tempXform SmileBulge 1 0 0 0;
	if ($side=="_L" && `objExists SmileBulgeLeft`)
		asAlign tempXform SmileBulgeLeft 1 0 0 0;
	if ($side=="_L" && !`objExists SmileBulgeLeft`)
		setAttr tempXform.tx (`getAttr tempXform.tx`*-1);
	asPingPong tempXform SmileBulge 1 $side 2 1 0; 
	delete tempXform;
	skinCluster -e -dr 4 -lw false -wt 0 -ai ("SmileBulgeJoint"+$side) SmileBulgeSC;
	asSkinWeightBySoftMod ("SmileBulgeJoint"+$side) SmileBulgeLayer SmileBulgeSC $falloffRadius 1;
	addAttr -k 0 -ln falloffRadius -at double -dv $falloffRadius ("SmileBulge"+$side);

	$posA[0]=$falloffRadius/($faceFitScale/1.0);
	$posA[1]=0;
	$posA[2]=$falloffRadius/($faceFitScale/1.0);
	}

//connect _R to _L
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("SmileBulge_R.t"+$xyz[$z]) ("SmileBulge_L.t"+$xyz[$z]) ;
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("SmileBulge_R.s"+$xyz[$z]) ("SmileBulge_L.s"+$xyz[$z]) ;
setAttr SmileBulgeOffset_L.v 0;

//fitAnim
if ($autoKeyState) autoKeyframe -state 0;
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 0;
setKeyframe -shape 0 SmileBulge_R;
currentTime 30;
setAttr -type float3 SmileBulge_R.t $posA[0] $posA[1] $posA[2];
setAttr -type float3 SmileBulge_R.s 1.2 1.2 1.2;
asLockAttr SmileBulge_R 0 1 0 1;
setKeyframe -shape 0 SmileBulge_R;
if ($autoKeyState) autoKeyframe -state 1;

currentTime 30;
select SmileBulge_R;
}

global proc asFaceCheekRaiser ()
{
global string $gMove;
setToolTo $gMove;
int $autoKeyState=`autoKeyframe -q -state`;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
float $falloffRadius;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $pos[],$posA[],$posB[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $side,$leftSuffix;
string $tempString[];
string $xyz[]={"x","y","z"};

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n CheekRaiserLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` CheekRaiserLayer 1 asFaceBS;
setAttr CheekRaiserLayer.v 1;
select Face_M CheekRaiserLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] CheekRaiserSC;
asReuseIntermediateMesh $geometry CheekRaiserLayer;

asShowLayer Normal;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v 1;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($side=="_L" && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	currentTime 0;
	$pos=`xform -q -ws -t ("LipPull"+$side)`;
	$posA=`xform -q -ws -t ("CheekRaiser"+$leftSuffix)`;
	createNode -n tempXform transform;
	xform -ws -t $posA[0] $posA[1] $posA[2] tempXform;
	//delete `geometryConstraint lowerEyeLidOuterCurve tempXform`;
	delete `geometryConstraint ("upperEyeLidOuterCurve"+$leftSuffix) tempXform`;
	$posB=`xform -q -ws -t tempXform`;
	$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`*1.2;

	currentTime 0;

	asAlign tempXform CheekRaiser 1 0 0 0;
	if ($side=="_L" && `objExists CheekRaiserLeft`)
		asAlign tempXform CheekRaiserLeft 1 0 0 0;
	if ($side=="_L" && !`objExists CheekRaiserLeft`)
		setAttr tempXform.tx (`getAttr tempXform.tx`*-1);
	asPingPong tempXform CheekRaiser 1 $side 2 1 0;
	delete tempXform;
	asLockAttr ("CheekRaiser"+$side) 0 1 0 0;

	skinCluster -e -dr 4 -lw false -wt 0 -ai ("CheekRaiserJoint"+$side) CheekRaiserSC;
	asSkinWeightBySoftMod ("CheekRaiserJoint"+$side) CheekRaiserLayer CheekRaiserSC $falloffRadius 1;
	addAttr -k 0 -ln falloffRadius -at double -dv $falloffRadius ("CheekRaiser"+$side);
	}

//connect _R to _L
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("CheekRaiser_R.t"+$xyz[$z]) ("CheekRaiser_L.t"+$xyz[$z]) ;
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("CheekRaiser_R.s"+$xyz[$z]) ("CheekRaiser_L.s"+$xyz[$z]) ;
setAttr CheekRaiserOffset_L.v 0;

//fitAnim
if ($autoKeyState) autoKeyframe -state 0;
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 0;
setKeyframe -shape 0 CheekRaiser_R;
currentTime 30;
setAttr -type float3 CheekRaiser_R.s 1.2 1.2 1.2;
asLockAttr CheekRaiser_R 0 1 0 1;
setKeyframe -shape 0 CheekRaiser_R;
if ($autoKeyState) autoKeyframe -state 1;

currentTime 30;
select CheekRaiser_R;
}

global proc asFaceFrownPull ()
{
global string $gMove;
setToolTo $gMove;
int $autoKeyState=`autoKeyframe -q -state`;
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $upperEyeLidOuterNumCVs=`getAttr upperEyeLidOuterCurve.spans`+1;
float $falloffRadius;
float $pos[],$rot[];
string $side;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster="SmilePullSC";
string $tempString[];

asShowLayer SmilePull;
setAttr CheekRaiserOffset_R.v 0;
setAttr SmileBulgeOffset_R.v 0;

//store LipPull & SmileBulge & CheekRaiser info
currentTime 30;
$pos=`getAttr LipPull_R.t`;
$rot=`getAttr LipPull_R.r`;

createNode -n LipPullMixedValues -p LipPull_R transform;
parent LipPullMixedValues LipPullSubtract_R;

setAttr asFaceBS.SmilePullLayer 1;
setAttr asFaceBS.SmileBulgeLayer 0;
setAttr asFaceBS.CheekRaiserLayer 0;
createNode -n LipPullValues -p LipPull_R transform;
parent LipPullValues LipPullSubtract_R;

setAttr asFaceBS.SmilePullLayer 0;
setAttr asFaceBS.SmileBulgeLayer 1;
setAttr asFaceBS.CheekRaiserLayer 0;
createNode -n SmileBulgeValues -p SmileBulge_R transform;
parent SmileBulgeValues SmileBulgeSubtract_R;

setAttr asFaceBS.SmilePullLayer 0;
setAttr asFaceBS.SmileBulgeLayer 0;
setAttr asFaceBS.CheekRaiserLayer 1;
createNode -n CheekRaiserValues -p CheekRaiser_R transform;
parent CheekRaiserValues CheekRaiserSubtract_R;

setAttr asFaceBS.SmilePullLayer 1;
setAttr asFaceBS.SmileBulgeLayer 1;
setAttr asFaceBS.CheekRaiserLayer 1;

asLockAttr LipPullValues 0 1 1 0;
asLockAttr CheekRaiserValues 0 1 1 0;
asLockAttr SmileBulgeValues 0 1 1 0;

currentTime 0;
$tempString=`listConnections -type animCurve -s 1 -d 0 LipPull_R CheekRaiser_R SmileBulge_R`;
if (size($tempString))
	delete $tempString;

if ($autoKeyState) autoKeyframe -state 0;
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 0;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 LipPull_R;
setKeyframe -shape 0 LipPull_R;
currentTime 30;
setAttr LipPull_R.t $pos[0] ($pos[1]*-1) $pos[2];
asLockAttr LipPull_R 0 1 1 1;
setKeyframe -shape 0 LipPull_R;
if ($autoKeyState) autoKeyframe -state 1;

select LipPull_R;
}

global proc asFaceFrown ()
{
global string $gMove;
setToolTo $gMove;
int $autoKeyState=`autoKeyframe -q -state`;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $falloffRadius,$xDist,$yDist,$xyDist,$minXyDist;
float $pos[],$posA[],$posB[];
string $side,$chosenVert;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];
string $xyz[]={"x","y","z"};

//correspond ctrls vis
setAttr LipPullOffset_R.v 0;

asFaceFrownPull;

asShowLayer Normal;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v 1;

currentTime 0;dgdirty -a;
$falloffRadius=`getAttr LipPull_R.falloffRadius`;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	createNode -n tempXform transform;
	asAlign tempXform FrownBulge 1 0 0 0;
	if ($side=="_L" && `objExists FrownBulgeLeft`)
		asAlign tempXform FrownBulgeLeft 1 0 0 0;
	if ($side=="_L" && !`objExists FrownBulgeLeft`)
		setAttr tempXform.tx (`getAttr tempXform.tx`*-1);
	asPingPong tempXform FrownBulge 1 $side 2 1 0;
	delete tempXform;
	skinCluster -e -dr 4 -lw false -wt 0 -ai ("FrownBulgeJoint"+$side) CheekRaiserSC;
	asSkinWeightBySoftMod ("FrownBulgeJoint"+$side) CheekRaiserLayer CheekRaiserSC $falloffRadius 1;
	addAttr -k 0 -ln falloffRadius -at double -dv $falloffRadius ("FrownBulge"+$side);

	$posA[0]=$falloffRadius/($faceFitScale/2.0);
	$posA[1]=0;
	$posA[2]=$falloffRadius/($faceFitScale/2.0);
	}

//connect _R to _L
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("FrownBulge_R.t"+$xyz[$z]) ("FrownBulge_L.t"+$xyz[$z]) ;
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("FrownBulge_R.s"+$xyz[$z]) ("FrownBulge_L.s"+$xyz[$z]) ;
setAttr FrownBulgeOffset_L.v 0;

//fitAnim
if ($autoKeyState) autoKeyframe -state 0;
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 0;
setKeyframe -shape 0 FrownBulge_R;
currentTime 30;

//slide FrownBulge sideWays (-x), until the LipPull location matches that of the SmileBulge, to avoid `controller-wobble`
$posA=`xform -q -ws -t LipPullMixedValues`;
for ($i=0;$i<99;$i++)
	{
	$posB=`xform -q -ws -t LipPull_R`;
	move -r -0.01 0 0 FrownBulge_R;
	refresh;
	if ($posB[0]<$posA[0])
		break;
	}

setAttr -type float3 FrownBulge_R.s 1.2 1.2 1.2;
asLockAttr FrownBulge_R 0 1 0 1;
setKeyframe -shape 0 FrownBulge_R;
if ($autoKeyState) autoKeyframe -state 1;

currentTime 30;
select FrownBulge_R;
}

global proc asFaceMouthNarrow ()
{
int $autoKeyState=`autoKeyframe -q -state`;
float $falloffRadius,$distToEyeCurve,$rotY,$weight;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $pos[],$posA[];
string $side,$leftSuffix;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $centerVtxs[];
string $xyz[]={"x","y","z"};

if ($autoKeyState) autoKeyframe -state 0;

//store FrownPullValues & FrownBulgeValues
currentTime 30;

setAttr asFaceBS.SmilePullLayer 1;
setAttr asFaceBS.SmileBulgeLayer 0;
setAttr asFaceBS.CheekRaiserLayer 0;
createNode -n FrownPullValues -p LipPull_R transform;
parent FrownPullValues LipPullSubtract_R;

setAttr asFaceBS.SmilePullLayer 0;
setAttr asFaceBS.SmileBulgeLayer 0;
setAttr asFaceBS.CheekRaiserLayer 1;
createNode -n FrownBulgeValues -p FrownBulge_R transform;
parent FrownBulgeValues FrownBulgeSubtract_R;

setAttr asFaceBS.SmilePullLayer 1;
setAttr asFaceBS.SmileBulgeLayer 1;
setAttr asFaceBS.CheekRaiserLayer 1;

currentTime 0;
$tempString=`listConnections -type animCurve -s 1 -d 0 LipPull_R FrownBulge_R`;
if (size($tempString))
	delete $tempString;


//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n MouthNarrowLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` MouthNarrowLayer 1 asFaceBS;
setAttr MouthNarrowLayer.v 1;
select Face_M MouthNarrowLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] MouthNarrowSC;
asReuseIntermediateMesh $geometry MouthNarrowLayer;

//correspond ctrls vis
$tempString=`listRelatives -c Acontrols`;
$tempString2=`listRelatives -c Bcontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Ccontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;

$falloffRadius=`getAttr LipPull_R.falloffRadius`;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($side=="_L" && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	$pos=`xform -q -ws -t ("LipPullJointOffset"+$side)`;
	$posA=`xform -q -ws -t upperLipJoint0_M`;
	$falloffRadius=`mag<<$pos[0]-$posA[0],$pos[1]-$posA[1],$pos[2]-$posA[2]>>`*1.05;
	//or if dist to lowerEyeLidMainCurve is closer
	if (`objExists TempPos`) delete TempPos;
	createNode -n TempPos transform;
	select ("lowerEyeLidMainCurve"+$leftSuffix) TempPos;
	geometryConstraint -weight 1;
	$posA=`xform -q -ws -t TempPos`;
	delete TempPos_geometryConstraint1;
	$pos=`xform -q -ws -t ("upperLipOuterCurve"+$leftSuffix+".cv[0]")`;
	$posA=`xform -q -ws -t ("lowerLipOuterCurve"+$leftSuffix+".cv[0]")`;
	xform -ws -t (($faceFitScale/-2000.0)*$b) (($pos[1]+$posA[1])/2.0) `max $pos[2] $posA[2]` TempPos;

	asPingPong TempPos MouthNarrow 1 $side 2 1 0;
	skinCluster -e -dr 4 -lw false -wt 0 -ai ("MouthNarrowJoint"+$side) MouthNarrowSC;

	//asSkinWeightBySoftMod MouthNarrowJoint_R MouthNarrowLayer MouthNarrowSC $falloffRadius 1;
	addAttr -k 0 -ln falloffRadius -at double -dv $falloffRadius ("MouthNarrowJoint"+$side);

	//copy the weights from SmilePull
	if ($side=="_R")
		{
		setAttr Face_M.type 1;
		setAttr LipPullJoint_R.type 2;
		setAttr MouthNarrowJoint_R.type 2;
		select SmilePullLayer MouthNarrowLayer;
		catchQuiet (`copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation label`);
		setAttr Face_M.type 0;
		setAttr LipPullJoint_R.type 0;
		setAttr MouthNarrowJoint_R.type 0;
		}

	//weight lip
	select lipArea;
	$tempString=`ls -sl -fl`;
	select `asobjSetCast "" $tempString MouthNarrowLayer`;
	$tempString=`ls -sl -fl`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		if (($pos[0]>-0.001 && $side=="_R") || ($pos[0]<0.001 && $side=="_L"))
			{
			select -d $tempString[$i];
			$centerVtxs[size($centerVtxs)]=$tempString[$i];
			}
		}
	skinPercent -tv ("MouthNarrowJoint"+$side) 1 MouthNarrowSC;

	//hammer lipFalloffArea
	select lipFalloffArea;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString MouthNarrowLayer`;
	if (size(`ls -sl`))
		weightHammerVerts;

	//find rotY
	if ($side=="_R")
		{
		parent TempPos upperLipJoint0_M;
		setAttr TempPos.t -type float3 0 0 0;
		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 LipPullJointOffset_R TempPos;
		$rotY=`getAttr TempPos.rz`;
		delete TempPos;
		}
	}

//hammer centerVtx
select $centerVtxs;
if (size($centerVtxs))
	{
	select $centerVtxs;
	weightHammerVerts;
	}

//connect _R to _L
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("MouthNarrow_R.t"+$xyz[$z]) ("MouthNarrow_L.t"+$xyz[$z]) ;
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("MouthNarrow_R.r"+$xyz[$z]) ("MouthNarrow_L.r"+$xyz[$z]) ;
for ($z=0;$z<size($xyz);$z++)
	connectAttr ("MouthNarrow_R.s"+$xyz[$z]) ("MouthNarrow_L.s"+$xyz[$z]) ;
setAttr MouthNarrowOffset_L.v 0;

//fitAnim
playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 0;
setKeyframe -shape 0 MouthNarrow_R;
currentTime 30;
//xform -ws -t $pos[0] $pos[1] $pos[2] MouthNarrow_R;
setAttr MouthNarrow_R.s -type float3 0.125 1 0.125;
setAttr MouthNarrow_R.ry $rotY;
setKeyframe -shape 0 MouthNarrow_R;

setAttr -l 1 MouthNarrow_R.tx 0;
setAttr -l 1 MouthNarrow_R.ty 0;
setAttr -l 1 MouthNarrow_R.tz 0;
setAttr -l 1 MouthNarrow_R.rx 0;
setAttr -l 1 MouthNarrow_R.rz 0;
if ($autoKeyState) autoKeyframe -state 1;

currentTime 30;
select MouthNarrow_R;
}

global proc asFaceSmileFinish ()
{
global string $gMainProgressBar;
int $vtxNrs[];
float $scale=`asGetScale`;
float $lipPullDist,$narrowDist,$lipPullNarrowFactor,$rotY;
float $pos[],$posA[],$posB[],$rot[],$sca[],$values[],$weights[],$inAngles[],$outAngles[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $side,$exp,$driver,$blendWeighted,$upperLower;
string $sdks[],$attrs[],$infs[],$tempString[],$tempString2[];
string $smileElems[]={"MouthWide","MouthNarrow"};
string $mouthCtrs[]={"MouthNarrow","FrownBulge","SmileBulge","CheekRaiser","LipPull"};
string $xy[]={"x","y"};
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $trs[]={"t","r","s"};
$transRotScale={"translate","rotate","scale"};

setAttr LipPullOffset_R.v 1;
setAttr LipPullOffset_L.v 1;
setAttr CheekRaiserOffset_R.v 1;
setAttr CheekRaiserOffset_L.v 1;
setAttr SmileBulgeOffset_R.v 1;
setAttr SmileBulgeOffset_L.v 1;
setAttr FrownBulgeOffset_R.v 1;
setAttr FrownBulgeOffset_L.v 1;
setAttr MouthNarrowOffset_R.v 0;
setAttr MouthNarrowOffset_L.v 0;
asLockAttr LipPull_R 0 0 0 0;
asLockAttr SmileBulge_R 0 0 0 0;
asLockAttr FrownBulge_R 0 0 0 0;
asLockAttr CheekRaiser_R 0 0 0 0;
asLockAttr MouthNarrow_R 0 0 0 0;

//store MouthNarrowValues info
currentTime 30;
createNode -n MouthNarrowValues -p MouthNarrow_R transform;
parent -w MouthNarrowValues;
currentTime 0;
parent MouthNarrowValues LipPullSubtract_R;
$tempString=`listConnections -type animCurve -s 1 -d 0 MouthNarrow_R`;
if (size($tempString))
	delete $tempString;

for ($i=0;$i<size($mouthCtrs);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 ($mouthCtrs[$i]+"_L."+$trs[$y]+$xyz[$z])`;
			if ($tempString[0]!="")
				disconnectAttr $tempString[0] ($mouthCtrs[$i]+"_L."+$trs[$y]+$xyz[$z]);
		}

//Adding SmilePull, which also drives the ctrlMouthCorner outputs
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	//SmilePull
	asPingPong ("LipPull"+$side) SmilePull 1 $side 1 0 0;
	setAttr ("SmilePull"+$side+"Shape.overrideColor") 17;
	$pos=`xform -q -ws -t ("LipPull"+$side)`;
	scale -r -p $pos[0] $pos[1] $pos[2] 2 2 1 ("SmilePull"+$side+".cv[0:7]");
	asFaceHalfMoonCurve ("SmilePull"+$side) 0;
	asLockAttr ("SmilePull"+$side) 0 1 1 1;
	setAttr -l 1 -k 0 ("SmilePull"+$side+".tz");
	$rotY=`getAttr MouthNarrowValues.ry`;
	setAttr ("SmilePullOffset"+$side+".ry") ($rotY*$b);

	createNode -n ("SmilePullTPMA"+$side) plusMinusAverage;

	for ($z=0;$z<size($xy);$z++)
		{
		$tempString=`listConnections -s 0 -d 1 -p 1 ("ctrlMouthCorner"+$side+".t"+$xy[$z])`;

		addAttr -k 0 -ln ("t"+$xy[$z]+"Mixed") -at double ("ctrlMouthCorner"+$side);
		connectAttr ("SmilePullTPMA"+$side+".output3D"+$xy[$z]) ("ctrlMouthCorner"+$side+".t"+$xy[$z]+"Mixed");

		connectAttr ("ctrlMouthCorner"+$side+".t"+$xy[$z]) ("SmilePullTPMA"+$side+".input3D[0].input3D"+$xy[$z]);
		connectAttr ("SmilePull"+$side+".t"+$xy[$z]) 			 ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]);
		connectAttr ("SDKSmilePull"+$side+".t"+$xy[$z])		 ("SmilePullTPMA"+$side+".input3D[2].input3D"+$xy[$z]);
		if ($xy[$z]=="x")
			connectAttr ("ctrlMouth_M.t"+$xy[$z])		 ("SmilePullTPMA"+$side+".input3D[3].input3D"+$xy[$z]);

		for ($i=0;$i<size($tempString);$i++)
			connectAttr -f ("ctrlMouthCorner"+$side+".t"+$xy[$z]+"Mixed") $tempString[$i];
		}

	setAttr ("LipPullOffset"+$side+".v") 0;
	}

//asDsSdk ctrlMouthCorner
$posA=`xform -q -ws -t LipPull_R`;
$posB=`xform -q -ws -t LipPullValues`;
$lipPullDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
$posB=`xform -q -ws -t MouthNarrowValues`;
$narrowDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
$lipPullNarrowFactor=$lipPullDist/$narrowDist;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	move -r 0 0 (`asFaceGetScale`/-20.0) ("LipPull"+$side+".cv[0:7]");

	//create blendedAttr for mouthCorner X&Y (smile)
	setAttr ("ctrlMouthCorner"+$side+".tx") 1;
	setAttr ("ctrlMouthCorner"+$side+".ty") 1;

	asCreateBlendedAttribute {("ctrlMouthCorner"+$side+".tx"),("ctrlMouthCorner"+$side+".ty")};
	//override so this X_Y attr is driven from Xmixed and Ymixed
	connectAttr -f ("ctrlMouthCorner"+$side+".txMixed") ("ctrlMouthCorner"+$side+"txPos_tyPosSetRange1.valueX");
	connectAttr -f ("ctrlMouthCorner"+$side+".tyMixed") ("ctrlMouthCorner"+$side+"txPos_tyPosSetRange1.valueY");

	if (`objExists BlendedCorrectiveDriver`) delete BlendedCorrectiveDriver;
//	setAttr -cb 0 ("ctrlMouthCorner"+$side+".txPos_tyPos");

	//create blendedAttr for mouthCorner X&Y (frown)
	setAttr ("ctrlMouthCorner"+$side+".tx") 1;
	setAttr ("ctrlMouthCorner"+$side+".ty") -1;

	asCreateBlendedAttribute {("ctrlMouthCorner"+$side+".tx"),("ctrlMouthCorner"+$side+".ty")};
	//override so this X_Y attr is driven from Xmixed and Ymixed
	connectAttr -f ("ctrlMouthCorner"+$side+".txMixed") ("ctrlMouthCorner"+$side+"txPos_tyNegSetRange1.valueX");
	connectAttr -f ("ctrlMouthCorner"+$side+".tyMixed") ("ctrlMouthCorner"+$side+"txPos_tyNegSetRange1.valueY");

	if (`objExists BlendedCorrectiveDriver`) delete BlendedCorrectiveDriver;
//	setAttr -cb 0 ("ctrlMouthCorner"+$side+".txPos_tyNeg");

	setAttr ("ctrlMouthCorner"+$side+".tx") 0;
	setAttr ("ctrlMouthCorner"+$side+".ty") 0;

	//from ctrlMouthCorner
	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKMouthNarrow"+$side+".sx") -1 0.2;
	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKMouthNarrow"+$side+".sy") -1 0.2;
	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKMouthNarrow"+$side+".sz") -1 0.2;
	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKMouthNarrow"+$side+".ry") -1 (`getAttr MouthNarrowValues.ry`*0.8);
	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKLipPull"+$side+".tx") 1 `getAttr LipPullValues.tx`;
//	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKLipPull"+$side+".tx") -1 (`getAttr MouthNarrowValues.tx`*$lipPullNarrowFactor);
	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKLipPull"+$side+".tz") 1 `getAttr LipPullValues.tz`;
//	asDsSdk ("ctrlMouthCorner"+$side+".txMixed") ("SDKLipPull"+$side+".tz") -1 (`getAttr MouthNarrowValues.tz`*$lipPullNarrowFactor);

	asDsSdk ("ctrlMouthCorner"+$side+".tyMixed") ("SDKLipPull"+$side+".ty") 1 `getAttr LipPullValues.ty`;
	asDsSdk ("ctrlMouthCorner"+$side+".tyMixed") ("SDKLipPull"+$side+".ty") -1 `getAttr FrownPullValues.ty`;

	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			//smileFrown driver attribute
			asDsSdk ("ctrlMouthCorner"+$side+".txPos_tyPos") ("SDKSmileBulge"+$side+"."+$trs[$y]+$xyz[$z]) 1 `getAttr ("SmileBulgeValues."+$trs[$y]+$xyz[$z])`;
//			asDsSdk ("ctrlMouthCorner"+$side+".txPos_tyPos") ("SDKCheekRaiser"+$side+"."+$trs[$y]+$xyz[$z]) 1 `getAttr ("CheekRaiserValues."+$trs[$y]+$xyz[$z])`;
			asDsSdk ("ctrlMouthCorner"+$side+".txPos_tyNeg") ("SDKFrownBulge"+$side+"."+$trs[$y]+$xyz[$z]) 1 `getAttr ("FrownBulgeValues."+$trs[$y]+$xyz[$z])`;
			}
	}


//resolve transition between LipPull & MouthNarrow
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R";
	else $side="_L";

	setAttr ("SDKLipPull"+$side+"_translateX.preInfinity") 1; setAttr ("SDKLipPull"+$side+"_translateX.postInfinity") 1;
//	setAttr ("SDKLipPull"+$side+"_translateX1.preInfinity") 1; setAttr ("SDKLipPull"+$side+"_translateX1.postInfinity") 1;
	setAttr ("SDKLipPull"+$side+"_translateZ.preInfinity") 1; setAttr ("SDKLipPull"+$side+"_translateZ.postInfinity") 1;
//	setAttr ("SDKLipPull"+$side+"_translateZ1.preInfinity") 1; setAttr ("SDKLipPull"+$side+"_translateZ1.postInfinity") 1;

	setAttr ("SDKMouthNarrow"+$side+"_rotateY.preInfinity") 1; setAttr ("SDKMouthNarrow"+$side+"_rotateY.postInfinity") 1;

	setAttr ("SDKMouthNarrow"+$side+"_scaleX.preInfinity") 1; setAttr ("SDKMouthNarrow"+$side+"_scaleX.postInfinity") 1;
	setAttr ("SDKMouthNarrow"+$side+"_scaleY.preInfinity") 1; setAttr ("SDKMouthNarrow"+$side+"_scaleY.postInfinity") 1;
	setAttr ("SDKMouthNarrow"+$side+"_scaleZ.preInfinity") 1; setAttr ("SDKMouthNarrow"+$side+"_scaleZ.postInfinity") 1;

	keyTangent -index 1 -itt spline -ott spline ("SDKLipPull"+$side+"_translateX");
//	keyTangent -index 0 -itt spline -ott spline ("SDKLipPull"+$side+"_translateX1");
//	keyTangent -index 1 -itt spline -ott spline ("SDKLipPull"+$side+"_translateX1");
//	keyTangent -index 2 -itt spline -ott spline ("SDKLipPull"+$side+"_translateX1");
	keyTangent -index 1 -itt spline -ott spline ("SDKLipPull"+$side+"_translateY");
	keyTangent -index 1 -itt spline -ott spline ("SDKLipPull"+$side+"_translateZ");
//	keyTangent -index 0 -itt spline -ott spline ("SDKLipPull"+$side+"_translateZ1");
//	keyTangent -index 1 -itt spline -ott spline ("SDKLipPull"+$side+"_translateZ1");
//	keyTangent -index 2 -itt spline -ott spline ("SDKLipPull"+$side+"_translateZ1");

	keyTangent -index 0 -itt spline -ott spline ("SDKMouthNarrow"+$side+"_rotateY");
	keyTangent -index 0 -itt spline -ott spline ("SDKMouthNarrow"+$side+"_scaleX");
	keyTangent -index 0 -itt spline -ott spline ("SDKMouthNarrow"+$side+"_scaleY");
	keyTangent -index 0 -itt spline -ott spline ("SDKMouthNarrow"+$side+"_scaleZ");

	if (`getAttr MouthNarrowValues.sy`>0.999 && `objExists ("SDKMouthNarrow"+$side+"_scaleY")`)
		{
		delete ("SDKMouthNarrow"+$side+"_scaleY");
		}
	}

//update SmilePull - mixTx to get 1/1 translation
for ($z=0;$z<size($xy);$z++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";

		disconnectAttr ("SmilePull"+$side+".t"+$xy[$z]) ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]);
		//use SDK instead
		if ($side=="_R")
			{
			$pos[0]=`getAttr ("SmilePullAttach_R.t"+$xy[$z])`;
			setAttr ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]) 1;
			$posA[0]=`getAttr ("SmilePullAttach_R.t"+$xy[$z])`;
			setAttr ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]) -1;
			$posB[0]=`getAttr ("SmilePullAttach_R.t"+$xy[$z])`;
			setAttr ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]) 0;
			if ($xy[$z]=="y") {$posA[0]*=-1;$posB[0]*=-1;}
			}
		setDrivenKeyframe -itt "clamped" -ott "clamped" -dv 0  -v 0 -cd ("SmilePull"+$side+".t"+$xy[$z]) ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]);
		setDrivenKeyframe -itt "clamped" -ott "clamped" -dv ($pos[0]-$posA[0]) -v 1  -cd ("SmilePull"+$side+".t"+$xy[$z]) ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]);
		setDrivenKeyframe -itt "clamped" -ott "clamped" -dv ($pos[0]-$posB[0]) -v -1 -cd ("SmilePull"+$side+".t"+$xy[$z]) ("SmilePullTPMA"+$side+".input3D[1].input3D"+$xy[$z]);
		setAttr ("SmilePullTPMA"+$side+"_input3D_1__input3D"+$xy[$z]+".preInfinity") 1;
		setAttr ("SmilePullTPMA"+$side+"_input3D_1__input3D"+$xy[$z]+".postInfinity") 1;
		}
	}

//lip auto-press when stretched
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) $upperLower="upper";
	else $upperLower="lower";

	createNode -n ($upperLower+"LipPressSetRange") setRange;
	setAttr ($upperLower+"LipPressSetRange.minY") -10;
	setAttr ($upperLower+"LipPressSetRange.maxZ")  10;
	setAttr ($upperLower+"LipPressSetRange.oldMinY") -1;
	setAttr ($upperLower+"LipPressSetRange.oldMaxZ")  1;
	connectAttr ctrlMouth_M.tx ($upperLower+"LipPressSetRange.valueY");
	connectAttr ctrlMouth_M.tx ($upperLower+"LipPressSetRange.valueZ");
	connectAttr ($upperLower+"LipPressSetRange.outValueY") ($upperLower+"LipPressPlusMinusAverage.input3D[1].input3Dy");
//	connectAttr ($upperLower+"LipPressSetRange.outValueZ") ($upperLower+"LipPressPlusMinusAverage.input3D[1].input3Dz");
	}

//lip auto-Squeeze when stretched
addAttr -ln "lipDriven" -k 1 -at double ctrlMouth_M;
setAttr -l 1 ctrlMouth_M.lipDriven;
addAttr -ln "autoSqueeze" -k 1 -at double -smx 10 -hsx 1 -smn 0 -hnv 1 -dv 2 ctrlMouth_M;
createNode -n LipAutoSqueezePMA plusMinusAverage;
connectAttr ctrlMouth_M.tx LipAutoSqueezePMA.input1D[0];//This get half value of 2x ctrlMouthCorners

createNode -n LipAutoSqueezeMouthCornerHalfMPD multiplyDivide;
connectAttr ctrlMouthCorner_R.txMixed LipAutoSqueezeMouthCornerHalfMPD.input1.input1X;
connectAttr ctrlMouthCorner_L.txMixed LipAutoSqueezeMouthCornerHalfMPD.input1.input1Y;
setAttr LipAutoSqueezeMouthCornerHalfMPD.input2 -type float3 0.5 0.5 0.5;

connectAttr LipAutoSqueezeMouthCornerHalfMPD.outputX LipAutoSqueezePMA.input1D[1];
connectAttr LipAutoSqueezeMouthCornerHalfMPD.outputY LipAutoSqueezePMA.input1D[2];

createNode -n LipAutoSqueezeMPD multiplyDivide;
connectAttr LipAutoSqueezePMA.output1D LipAutoSqueezeMPD.input1.input1X;
connectAttr ctrlMouth_M.autoSqueeze LipAutoSqueezeMPD.input2.input2X;

connectAttr LipAutoSqueezeMPD.outputX upperLipPressPlusMinusAverage.input3D[1].input3Dz;
connectAttr LipAutoSqueezeMPD.outputX lowerLipPressPlusMinusAverage.input3D[1].input3Dz;

//delete SmilePull CheekRaiser;
asShowLayer Normal;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v 1;
//select ctrlMouthCorner_R ctrlMouthCorner_L;
select -cl;
}

global proc asFaceCheek ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster="CheekSC";
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $cvNr;
int $vtxNrs[];
float $falloffRadius,$distToEyeCurve,$weight;
float $scale=`asFaceGetScale`;
float $posA[],$posB[],$posC[],$posD[],$weights[];
string $side,$leftSuffix;
string $xyz[]={"x","y","z"};
string $infJoints[],$tempString[];

setAttr ctrlMouthCorner_R.tx 0;
setAttr ctrlMouthCorner_R.ty 0;
setAttr ctrlMouthCorner_L.tx 0;
setAttr ctrlMouthCorner_L.ty 0;
setAttr LipPull_R.t -type float3 0 0 0;
setAttr LipPull_L.t -type float3 0 0 0;

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n CheekLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` CheekLayer 1 asFaceBS;
setAttr CheekLayer.v 1;
select Face_M CheekLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] CheekSC;
asReuseIntermediateMesh $geometry CheekLayer;

//correspond ctrls vis
$tempString=`listRelatives -c Acontrols`;
$tempString2=`listRelatives -c Bcontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Ccontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;

if (`objExists TempPos`) delete TempPos;
createNode -n TempPos transform;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($side=="_L" && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	$pos=`xform -q -ws -t Cheek`;
	if ($side=="_L" && `objExists CheekLeft`)
		$pos=`xform -q -ws -t CheekLeft`;
	if ($side=="_L" && !`objExists CheekLeft`)
		$pos[0]=$pos[0]*-1;
	xform -ws -t $pos[0] $pos[1] $pos[2] TempPos;
	asPingPong TempPos Cheek 1 $side 1 1 0;

	skinCluster -e -dr 4 -lw false -wt 0 -ai ("CheekJoint"+$side) $skinCluster;
	$posA=`xform -q -ws -t ("Cheek"+$side)`;
	$posB=`xform -q -ws -t ("Lip"+$side)`;

	$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	$falloffRadius=$falloffRadius*1.5;

	//Or if Eye is nearer
	asAlign TempPos ("Cheek"+$side) 1 0 0 0;
	select ("lowerEyeLidMainCurve"+$leftSuffix) TempPos;
	delete `geometryConstraint -weight 1`;
	$posB=`xform -q -ws -t TempPos`;
	$distToEyeCurve=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($distToEyeCurve<$falloffRadius)
		$falloffRadius=$distToEyeCurve*1.1;

	if ($side=="_R" || $leftSuffix=="Left")
		{
		asSkinWeightBySoftMod ("CheekJoint"+$side) CheekLayer $skinCluster $falloffRadius 1;
		//reduse weights near CheekBone
		$posC=`xform -q -ws -t ("CheekBone"+$leftSuffix)`;
		//virtually push CheekBone pos, to allow some CheekWeights over CheekBone
		$posC[1]+=($scale/50.0);
		select CheekLayer;
		polySelectConstraint -m 3 -t 1 -d 1 -dp $posA[0] $posA[1] $posA[2] -db 0 $falloffRadius;
		$tempString=`ls -sl -fl`;
		polySelectConstraint -m 0;
		clear $vtxNrs;
		clear $weights;
		for ($i=0;$i<size($tempString);$i++)
			{
			$posD=`xform -q -ws -t $tempString[$i]`;
			if ($posD[1]>$posC[1])//over CheekBone
				$weight=0;
			else if ($posD[1]<$posA[1])//under Cheek
				continue;
			else
				$weight=(1-(($posD[1]-$posA[1]) / ($posC[1]-$posA[1])))*`skinPercent -transform ("CheekJoint"+$side) -query CheekSC $tempString[$i]`;
			$vtxNrs[size($vtxNrs)]=`asComponentToNr $tempString[$i]`;
			$weights[size($weights)]=$weight;
			}
		asSkinWeightSet ("CheekJoint"+$side) CheekLayer CheekSC $vtxNrs $weights;
		}
	else
		copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

delete TempPos;
select Cheek_R;
}

global proc asFaceJawOpen ()
{
int $autoKeyState=`autoKeyframe -q -state`;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
float $pos[];
float $scale=`asGetScale`;

//correspond ctrls vis
setAttr LipPullOffset_R.v 1;
setAttr CheekOffset_L.v 0;

asShowLayer Normal;

if ($autoKeyState) autoKeyframe -state 0;

playbackOptions -min 0 -max 30 -ast 0 -aet 30;
currentTime 30;
setKeyframe -shape 0 -t 0 -v 0 ctrlMouth_M.ty;
setKeyframe -shape 0 -t 30 -v -1 ctrlMouth_M.ty;
dgdirty -a;

for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		connectAttr ("Cheek_R."+$trs[$y]+$xyz[$z]) ("Cheek_L."+$trs[$y]+$xyz[$z]);
		connectAttr ("LipPull_R."+$trs[$y]+$xyz[$z]) ("LipPull_L."+$trs[$y]+$xyz[$z]);
		}

setKeyframe -shape 0 -t 0 -v 0 Cheek_R.t;
setKeyframe -shape 0 -t 0 -v 0 LipPull_R.t;

setAttr Cheek_R.t -type float3 0 0 0;
$pos=`xform -q -ws -t Cheek_R`;
move -r ($pos[0]/-10.0) 0 0 Cheek_R;//move 10th of it`s position
setKeyframe -shape 0 -t 30 Cheek_R.t;

if ($autoKeyState) autoKeyframe -state 1;
}

global proc asFaceTongue ()
{
global string $gSelect;
setToolTo $gSelect;
int $modifier=`getModifiers`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};

float $pos[],$bb[];
float $scale=`asFaceGetScale`;
string $side;
string $tongueSkinCluster="";
string $tempString[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 CheekRaiser_R;
//xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 CheekRaiser_L;

//finish JawOpen
currentTime 30;
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		disconnectAttr ("Cheek_R."+$trs[$y]+$xyz[$z]) ("Cheek_L."+$trs[$y]+$xyz[$z]);
		disconnectAttr ("LipPull_R."+$trs[$y]+$xyz[$z]) ("LipPull_L."+$trs[$y]+$xyz[$z]);
		}
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	for ($z=0;$z<size($xyz);$z++)
		{
		asDsSdk ("ctrlMouth_M.ty") ("SDKCheek"+$side+".t"+$xyz[$z]) -1 `getAttr ("Cheek_R.t"+$xyz[$z])`;
		asDsSdk ("ctrlMouth_M.ty") ("SDKLipPull"+$side+".t"+$xyz[$z]) -1 `getAttr ("LipPull_R.t"+$xyz[$z])`;
		}
	}
delete `listConnections -s 1 -d 0 -type animCurve Cheek_R`;
delete `listConnections -s 1 -d 0 -type animCurve LipPull_R`;
delete `listConnections -s 1 -d 0 -type animCurve ctrlMouth_M`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 Cheek_R Cheek_L LipPull_R LipPull_L;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 ;
currentTime 0 ;
setAttr ctrlMouth_M.ty 0;

asShowLayer Normal;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v 1;
setAttr CheekLayer.v 0;
setAttr lowerFaceOffset_M.v 1;
setAttr CheekOffset_R.v 0;
setAttr LipPullOffset_R.v 0;

setAttr ctrlBox.ACtrlVis 0;
setAttr ctrlBox.BCtrlVis 0;
setAttr ctrlBox.CCtrlVis 0;
setAttr ctrlBox.TeethCtrlVis 0;
setAttr ctrlBox.RegionsCtrlVis 0;

if ($tongue=="")
	return;

//Display only tongue geo
if (`gmatch $tongue "*[.]*"`)
	setAttr ($geometry+".v") 1;
else
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		{
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 0;
		}
	setAttr ($tongue+".v") 1;
	}

if (!`objExists TongueCurve`)
	{
	//If tongue geometry has been choosen, but not Fit-tongue, we create default FitTongue.
	print ("// No Fit Tongue was found, Now creating Default Fit Tongue.\n");
	asCreateFaceFit Tongue "" 0 0 0 "asBlueSG";
	}

for ($i=0;$i<4;$i++)
	{
	asCreateFaceController ("Tongue"+$i) "_M" 4;
	asFaceAddDrive ("Tongue"+$i+"Joint") "_M" ("Tongue"+$i) "_M" 1 {} {};
	asFaceAddDrive ("Tongue"+$i+"Joint") "_M" ("SDKTongue"+$i) "_M" 1 {} {};
	connectAttr -f ctrlBox.TongueCtrlVis ("Tongue"+$i+"_MShape.overrideVisibility");
	$pos=`xform -q -ws -t ("TongueCurve.cv["+$i+"]")`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i+"Offset_M");
	xform -ws -t $pos[0] $pos[1] $pos[2] ("Tongue"+$i+"JointOffset_M");
	scale -r -p $pos[0] $pos[1] $pos[2] (3.4*2.0) 3.4 1 ("Tongue"+$i+"_M.cv[0:7]");
	rotate -r -os 0 90 0 ("Tongue"+$i+"_M.cv[0:7]");
	}

for ($i=1;$i<5;$i++)
	{
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ("Tongue"+$i) ("Tongue"+($i-1)+"Offset_M")`;
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 ("Tongue"+$i) ("Tongue"+($i-1)+"JointOffset_M")`;
	}
for ($i=1;$i<4;$i++)
	{
	parent ("Tongue"+$i+"Offset_M") ("Tongue"+($i-1)+"_M");
	parent ("Tongue"+$i+"JointOffset_M") ("Tongue"+($i-1)+"Joint_M");
	}

//follow jaw
createNode -n Tongue0Static_M -p Jaw_M transform;
parent Tongue0Static_M  lowerFace_M;
duplicate -n Tongue0Blend_M  Tongue0Static_M ;
parentConstraint Tongue0Static_M  JawMix_M Tongue0Blend_M;
scaleConstraint Tongue0Static_M  JawMix_M Tongue0Blend_M;
parent Tongue0Offset_M Tongue0Blend_M;
addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 Tongue0_M;
asUnitConvertAndReverse Tongue0Blend Tongue0_M.follow;
connectAttr Tongue0BlendReverse.outputX Tongue0Blend_M_parentConstraint1.Tongue0Static_MW0;
connectAttr Tongue0BlendReverse.outputX Tongue0Blend_M_scaleConstraint1.Tongue0Static_MW0;
connectAttr Tongue0BlendUnitConversion.output Tongue0Blend_M_parentConstraint1.JawMix_MW1;
connectAttr Tongue0BlendUnitConversion.output Tongue0Blend_M_scaleConstraint1.JawMix_MW1;

//changing Tongue joints to be Constrained instead of Exp, and SDK`s inline in hierarcy
for ($i=0;$i<4;$i++)
	{
	delete ("Tongue"+$i+"JointDriveExp_M");
	parent ("Tongue"+$i+"_M") ("SDKTongue"+$i+"_M");
	parentConstraint ("Tongue"+$i+"_M") ("Tongue"+$i+"Joint_M");
	scaleConstraint ("Tongue"+$i+"_M") ("Tongue"+$i+"Joint_M");
	}

//Polycube skin method
polyCube -n tempWeightCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 4 -ax 0 1 0 -cuv 4 -ch 1;
xform -s $scale $scale $scale tempWeightCube;
eval ("select "+$tongue);
$bb=`xform -q -ws -bb`;

select -r tempWeightCube.vtx[10:13] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[0]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[8:9] tempWeightCube.vtx[14:15] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[1]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[6:7] tempWeightCube.vtx[16:17] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[2]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[4:5] tempWeightCube.vtx[18:19] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[3]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

select -r tempWeightCube.vtx[0:3] ;
$tempString=`lattice  -divisions 2 5 2 -objectCentered true  -ldv 2 2 2`;
$pos=`xform -q -ws -t TongueCurve.cv[4]`;
xform -ws -t $pos[0] $pos[1] $pos[2] $tempString[1];
xform -ws -s ($bb[3]-$bb[0]) ($bb[4]-$bb[1]) 0 $tempString[1];

duplicate -n tempWeightCube2 tempWeightCube;
select -r tempWeightCube2 Tongue3Joint_M Tongue2Joint_M Tongue1Joint_M Tongue0Joint_M;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] tongueBoxSC;
//	skinCluster -n tongueBoxSC -dr 4 -lw false -wt 1 -mi 1;
select -r tempWeightCube2.vtx[10:13] ;
skinPercent -tv Tongue0Joint_M 1 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[8:9] tempWeightCube2.vtx[14:15] ;
skinPercent -tv Tongue0Joint_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue1Joint_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[6:7] tempWeightCube2.vtx[16:17] ;
skinPercent -tv Tongue1Joint_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue2Joint_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[4:5] tempWeightCube2.vtx[18:19] ;
skinPercent -tv Tongue2Joint_M 1 tongueBoxSC `ls -sl`;
skinPercent -tv Tongue3Joint_M 0.5 tongueBoxSC `ls -sl`;
select -r tempWeightCube2.vtx[0:3] ;
skinPercent -tv Tongue3Joint_M 1 tongueBoxSC `ls -sl`;

string $historyNodes[];
tokenize $tongue $tempString;
if(size($tempString))
	$historyNodes=`listHistory $tempString[0]`;
else
	$historyNodes=`listHistory $tongue`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="skinCluster")
		if (!`gmatch $historyNodes[$i] "prefix_*"` && $historyNodes[$i]!="squashIKSC")
			{
			$tongueSkinCluster=$historyNodes[$i];
			break;
			}
if ($tongueSkinCluster=="")
	{
	select -r $tongue Tongue3Joint_M Tongue2Joint_M Tongue1Joint_M Tongue0Joint_M;
	$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
	rename $tempString[0] tongueSC;
	$tongueSkinCluster="tongueSC";
	}
else
	skinCluster -e -lw true -wt 0 -ai Tongue3Joint_M -ai Tongue2Joint_M -ai Tongue1Joint_M -ai Tongue0Joint_M $tongueSkinCluster;

for ($i=0;$i<4;$i++)
	setAttr ("Tongue"+$i+"Joint_M.liw") 0;
eval ("select "+$tongue);
ConvertSelectionToVertices;
skinPercent -tv Tongue0Joint_M 1 $tongueSkinCluster `ls -sl`;

setAttr ctrlBox.jointsVis 1;
refresh;

if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
	{
	eval ("select "+$tongue);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select tempWeightCube2;
	select -add $tempString;
	}
else
	{
	select tempWeightCube2;
	select -add $tongue;
	}

copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
setAttr ctrlBox.jointsVis 0;
skinCluster -e -removeUnusedInfluence 1 $tongueSkinCluster;
delete tempWeightCube;
if ($modifier!=4)
	delete tempWeightCube2;

select -cl;
}

global proc asFaceRegions ()
{
int $numVtx;
int $tempInts[],$vtxNrs[];
float $value;
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
float $values[],$weights[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $skinCluster="RegionsSC";
string $side,$leftSuffix;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $tempString[],$allFaceGeo[],$infs[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
float $posA[],$posB[];

//Display all again, after finishing tongue
if (!`gmatch $tongue "*[.]*"`)
	for ($i=0;$i<size($allFaceGeo);$i++)
		if (!`getAttr -l ($allFaceGeo[$i]+".v")`)
			setAttr ($allFaceGeo[$i]+".v") 1;

//create LayerMesh
if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 0;
duplicate -n RegionsLayer templateLayer;
blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` RegionsLayer 1 asFaceBS;
setAttr RegionsLayer.v 1;
select Face_M RegionsLayer;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] RegionsSC;
asReuseIntermediateMesh $geometry RegionsLayer;

//correspond ctrls vis 
$tempString=`listRelatives -c Regionscontrols`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;
setAttr ctrlBox.RegionsCtrlVis 1;
setAttr ctrlBox.TongueCtrlVis 0;


string $regionJoints[]={"EyeBrowRegionJoint_R","EyeBrowRegionJoint_L","EyeRegionJoint_R","EyeRegionJoint_L","NoseRegionJoint_M","LipRegionJoint_M"};
for ($i=0;$i<size($regionJoints);$i++)
	{
	skinCluster -e -dr 4 -lw false -wt 0 -ai $regionJoints[$i] $skinCluster;
	}

//Nose
$posA=`xform -q -ws -t Nose`;
$posB=`xform -q -ws -t NoseCorner`;
$falloffRadius=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
asSkinWeightBySoftMod NoseRegionJoint_M RegionsLayer $skinCluster ($falloffRadius*1.2) 1;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	$leftSuffix="";
	if ($side=="_L" && `objExists FaceFitEyeLidMainLeft`)
		$leftSuffix="Left";

	if ($side=="_L" && !`objExists FaceFitEyeLidMainLeft`)
		break;

	//Eye
	eval ("select "+`asGetFaceFitSelection ("lowerEyeLidMainCurve"+$leftSuffix)`);
	eval ("select -add "+`asGetFaceFitSelection ("upperEyeLidMainCurve"+$leftSuffix)`);
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString RegionsLayer`;
	skinPercent -tv ("EyeRegionJoint"+$side) 1 $skinCluster `ls -sl`;
	asInvertSelection;
	asSmoothFlood ("EyeRegionJoint"+$side) Face_M 25;
	select -cl;

	//EyeBrow
	$tempInts=`polyEvaluate -v EyeBrowLayer`;
	$numVtx=$tempInts[0];
	clear $vtxNrs;
	clear $weights;
	for ($i=0;$i<$numVtx;$i++)
		{
		$value=`skinPercent -transform "Face_M" -q -v EyeBrowSC ("EyeBrowLayer.vtx["+$i+"]")`;
		if ($value==1)
			continue;
		$value=1.0-$value;
		$pos=`xform -q -ws -t ("EyeBrowLayer.vtx["+$i+"]")`;
		if (($side=="_R" && $pos[0]>($centerTolerance*-1)) || ($side=="_L" && $pos[0]<($centerTolerance)))
			continue;
		$vtxNrs[size($vtxNrs)]=$i;
		$weights[size($weights)]=$value;
		}
	asSkinWeightSet ("EyeBrowRegionJoint"+$side) RegionsLayer $skinCluster $vtxNrs $weights;

	//Lip
	clear $vtxNrs;
	clear $weights;
	for ($i=0;$i<$numVtx;$i++)
		{
		$value=`skinPercent -transform "Face_M" -q -v LipSC ("LipLayer.vtx["+$i+"]")`;
		if ($value==1)
			continue;
		$value=1.0-$value;
		$pos=`xform -q -ws -t ("LipLayer.vtx["+$i+"]")`;
		if (($side=="_R" && $pos[0]>($centerTolerance*-1)) || ($side=="_L" && $pos[0]<($centerTolerance)))
			continue;
		$vtxNrs[size($vtxNrs)]=$i;
		$weights[size($weights)]=$value;
		}
	asSkinWeightSet LipRegionJoint_M RegionsLayer $skinCluster $vtxNrs $weights;
	}

if (!`objExists FaceFitEyeLidMainLeft`)
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//hammer centerVtxs
select RegionsLayer;
polySelectConstraint -m 3 -t 0x0001 -d 3 -db 0 $centerTolerance -da 1 0 0 -dp 0 0 0;
$tempString=`ls -sl -fl`;
polySelectConstraint -m 0;
if (size($tempString))
	{
	select $tempString;
	weightHammerVerts;
	}

select -cl;
}

global proc asFaceEyeAim ()
{
setAttr ctrlBox.RegionsCtrlVis 0;
setAttr ctrlBox.AimCtrlVis 1;
select -cl;
}

global proc asFaceUpMidLo ()
{
int $numVtx;
int $tempInts[],$vtxNrs[];
float $value;
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
float $values[],$pos[],$posA[],$posB[],$weights[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $rightEye=`textField -q -tx asFaceEye_RTextField`;
string $leftEye=`textField -q -tx asFaceEye_LTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $skinCluster="UpMidLoSC";
string $name;
string $tempString[],$tempString2[],$infs[],$teethTongueEyes[];
string $upLo[]={"upper","lower"};

//create LayerMesh
if (!`objExists UpMidLoLayer`)
	{
	if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
	$tempString=`listRelatives -c DeformationLayers`;
	for ($i=0;$i<size($tempString);$i++)
		setAttr ($tempString[$i]+".v") 0;
	duplicate -n UpMidLoLayer templateLayer;
	blendShape -e -w `getAttr -s asFaceBS.w` 1 -tc 0 -t $geometry `getAttr -s asFaceBS.w` UpMidLoLayer 1 asFaceBS;
	setAttr UpMidLoLayer.v 1;
	select Face_M upperFaceJoint_M middleFaceJoint_M lowerFaceJoint_M UpMidLoLayer;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] UpMidLoSC;
	asReuseIntermediateMesh $geometry UpMidLoLayer;
	}

if (!`objExists upperFaceLocator_M`)
	{
	$posB=`xform -q -ws -t ctrlEye_L`;
	for ($i=0;$i<size($upLo);$i++)
		{
		$posA=`xform -q -ws -t ($upLo[$i]+"Face_M")`;
		spaceLocator -n ($upLo[$i]+"FaceLocator_M");
		xform -ws -t $posA[0] $posA[1] $posA[2] ($upLo[$i]+"FaceLocator_M");
		setAttr -type float3 ($upLo[$i]+"FaceLocator_MShape.localScale") $posB[0] $posB[0] $posB[0];
		}
	$posA=`xform -q -ws -t FaceFitSkeleton`;
	$posA[1]=$posA[1]*0.995;
	spaceLocator -n underFaceLocator_M;
	xform -ws -t $posA[0] $posA[1] $posA[2] underFaceLocator_M;
	setAttr -type float3 underFaceLocator_MShape.localScale $posB[0] $posB[0] $posB[0];
	}

//correspond ctrls vis
setAttr ctrlBox.RegionsCtrlVis 0;
setAttr ctrlBox.UpMidLoCtrlVis 1;
setAttr ctrlBox.AimCtrlVis 0;
setAttr NoseRegionOffset_M.v 0;
setAttr LipRegionOffset_M.v 0;
setAttr EyeRegionOffset_R.v 0;
setAttr EyeRegionOffset_L.v 0;
setAttr EyeBrowMiddleOffset_M.v 0;

//first flood to head as previous might have larger falloff
catchQuiet (`skinPercent -tv middleFaceJoint_M 1 $skinCluster UpMidLoLayer`);

$posA=`xform -q -ws -t upperFaceLocator_M`;
select UpMidLoLayer;
polySelectConstraint -m 3 -t 1 -d 3 -db $posA[1] 9999 -da 0 1 0 -dp 0 0 0;
catchQuiet (`skinPercent -tv upperFaceJoint_M 1 $skinCluster`);
$posA=`xform -q -ws -t lowerFaceLocator_M`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 $posA[1] -da 0 1 0 -dp 0 0 0;
catchQuiet (`skinPercent -tv lowerFaceJoint_M 1 $skinCluster`);

$posA=`xform -q -ws -t underFaceLocator_M`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 $posA[1] -da 0 1 0 -dp 0 0 0;
if (size(`ls -sl`))
	catchQuiet (`skinPercent -tv Face_M 1 $skinCluster`);
polySelectConstraint -m 0;

//Weight nose to middleFaceJoint_M
$tempInts=`polyEvaluate -v RegionsLayer`;
$numVtx=$tempInts[0];
for ($i=0;$i<$numVtx;$i++)
	{
	$infs=`skinPercent -ignoreBelow 0.01 -q -t RegionsSC ("RegionsLayer.vtx["+$i+"]")`;
	$values=`skinPercent -ignoreBelow 0.01 -q -v RegionsSC ("RegionsLayer.vtx["+$i+"]")`;
	if (!`stringArrayCount "NoseRegionJoint_M" $infs`)
		continue;
	$pos=`xform -q -ws -t ("RegionsLayer.vtx["+$i+"]")`;
	if ($pos[0]>($centerTolerance))
		continue;
	$vtxNrs[size($vtxNrs)]=$i;
	$weights[size($weights)]=1;
	//weight nose
//	skinPercent -tv middleFaceJoint_M 1 $skinCluster ("UpMidLoLayer.vtx["+$i+"]");
	}
asSkinWeightSet middleFaceJoint_M UpMidLoLayer $skinCluster $vtxNrs $weights;
select UpMidLoLayer;
copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation oneToOne;
asSmoothFlood upperFaceJoint_M middleFaceJoint_M `intField -q -v asFaceNumUpMidLomooths`;
asSmoothFlood lowerFaceJoint_M middleFaceJoint_M `intField -q -v asFaceNumUpMidLomooths`;
asSmoothFlood lowerFaceJoint_M Face_M `intField -q -v asFaceNumUpMidLomooths`;
//usually leaves some middleFace_M-weigts in the `lowerFaceJoint_M/Face_M` transition-area, to be removed
$posA=`xform -q -ws -t lowerFaceLocator_M`;
$posB=`xform -q -ws -t underFaceLocator_M`;
polySelectConstraint -m 3 -t 1 -d 3 -db (($posA[1]+$posB[1])/2.0) $posB[1] -da 0 1 0 -dp 0 0 0;
$tempString=`ls -sl`;
polySelectConstraint -m 0;
setAttr upperFaceJoint_M.liw 1;
setAttr lowerFaceJoint_M.liw 1;
if (size($tempString))
	{
	select $tempString;
	skinPercent -tv middleFaceJoint_M 0 $skinCluster;
	}
setAttr upperFaceJoint_M.liw 0;
setAttr lowerFaceJoint_M.liw 0;

asFaceAddHeadObjectAsLayerMesh UpMidLoLayer;

////if teeth/tongue part of Main mesh, then the verts to be removed from "lowerFaceJoint_M" weights on UpMidLoSC
if (`gmatch $upperTeeth ($geometry+"*")` && `gmatch $upperTeeth "*[.]*"`)
	{
	eval ("select "+$upperTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString UpMidLoLayer`;
	skinPercent -tv Face_M 1 UpMidLoSC `ls -sl`;
	}
if (`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString UpMidLoLayer`;
	skinPercent -tv Face_M 1 UpMidLoSC `ls -sl`;
	}
if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
	{
	eval ("select "+$tongue);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString UpMidLoLayer`;
	skinPercent -tv Face_M 1 UpMidLoSC `ls -sl`;
	}

select -r upperFace_M;
}

global proc asFacePhonemes ()
{
float $scale=`asGetScale`;
float $value;
float $pos[],$values[],$tValues[],$rValues[];
string $frownBulgeTowardsVtx,$side;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];
string $phonemes[]={"aaa","eh","ahh","ohh","uuu","iee","rrr","www","sss","fff","tth","mbp","ssh","schwa","gk","lntd"};
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
//string $phonemesFaceCtrls[]={"upperLipA","lowerLipA","SmileBulge","FrownBulge","CheekRaiser","upperLip","lowerLip"};

//correspond ctrls vis
setAttr ctrlBox.UpMidLoCtrlVis 0;

asShowLayer Normal;

if (`objExists upperFaceLocator_M`) delete upperFaceLocator_M;
if (`objExists lowerFaceLocator_M`) delete lowerFaceLocator_M;
if (`objExists underFaceLocator_M`) delete underFaceLocator_M;

createNode -n tempXform transform;
createNode -n tempXform2 transform;

for ($i=0;$i<size($phonemes);$i++)
	addAttr -k 1 -ln $phonemes[$i] -at double -smn 0 -hsn 1 -smx 10 -hsx 1 ctrlPhonemes_M;

addAttr -k 1 -ln multipliers ctrlPhonemes_M;
addAttr -k 1 -ln jaw -at double -smn 0 -hsn 1 -smx 2 -hsx 1 -dv 1 ctrlPhonemes_M;
addAttr -k 1 -ln lip -at double -smn 0 -hsn 1 -smx 2 -hsx 1 -dv 1 ctrlPhonemes_M;
setAttr ctrlPhonemes_M.multipliers -l 1;

for ($i=0;$i<size($phonemes);$i++)
	{
	addAttr -k 0 -ln ($phonemes[$i]+"JawMultiplied") -at double -smn 0 -hsn 1 -smx 10 -hsx 1 ctrlPhonemes_M;
	addAttr -k 0 -ln ($phonemes[$i]+"LipMultiplied") -at double -smn 0 -hsn 1 -smx 10 -hsx 1 ctrlPhonemes_M;

	createNode -n ($phonemes[$i]+"MPD") multiplyDivide;
	connectAttr ("ctrlPhonemes_M."+$phonemes[$i]) ($phonemes[$i]+"MPD.input1X");
	connectAttr ("ctrlPhonemes_M."+$phonemes[$i]) ($phonemes[$i]+"MPD.input1Y");
	connectAttr ("ctrlPhonemes_M.jaw") ($phonemes[$i]+"MPD.input2X");
	connectAttr ("ctrlPhonemes_M.lip") ($phonemes[$i]+"MPD.input2Y");
	connectAttr ($phonemes[$i]+"MPD.outputX") ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied") ;
	connectAttr ($phonemes[$i]+"MPD.outputY") ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ;
	}
for ($i=0;$i<size($phonemes);$i++)
	{
	setAttr -l 1 ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied");
	setAttr -l 1 ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied");
	}

//find $frownBulgeTowardsVtx
if (`objExists tempNearestPointOnCurve`) delete tempNearestPointOnCurve;
createNode -n tempNearestPointOnCurve nearestPointOnCurve;
connectAttr -f JawCurve.worldSpace[0] tempNearestPointOnCurve.inputCurve;
$pos=`xform -q -ws -t FrownBulge`;
setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
$pos=`getAttr tempNearestPointOnCurve.result.position`;
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
setAttr -type float3 closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$frownBulgeTowardsVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
delete tempNearestPointOnCurve closestSampler;

//jawPhonemes
for ($i=0;$i<size($phonemes);$i++)
	{
	$value=0;
	if ($phonemes[$i]=="aaa") $value=1;
	if ($phonemes[$i]=="eh") $value=0.5;
	if ($phonemes[$i]=="ahh") $value=1.2;
	if ($phonemes[$i]=="ohh") $value=0.75;
	if ($phonemes[$i]=="uuu") $value=0.25;
	if ($phonemes[$i]=="iee") $value=0.25;
	if ($phonemes[$i]=="rrr") $value=0.5;
	if ($phonemes[$i]=="www") $value=0.4;
	if ($phonemes[$i]=="mbp") $value=0.4;
	if ($phonemes[$i]=="fff") $value=0.2;
	if ($phonemes[$i]=="tth") $value=0.2;
	if ($phonemes[$i]=="schwa") $value=0.5;
	if ($phonemes[$i]=="gk") $value=0.5;
	if ($phonemes[$i]=="lntd") $value=0.5;
	if ($value!=0)
		{
		setAttr ctrlMouth_M.ty (-1*$value);
		$tValues=`getAttr SDKJaw_M.t`;
		$rValues=`getAttr SDKJaw_M.r`;
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied") "SDKJaw_M.ty" 10 $tValues[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied") "SDKJaw_M.tz" 10 $tValues[2];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied") "SDKJaw_M.rx" 10 $rValues[0];

		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==1) $side="_R"; else $side="_L";

			$tValues=`getAttr SDKCheek_R.t`;
			$rValues=`getAttr SDKCheek_R.r`;
			for ($z=0;$z<size($xyz);$z++)
				{
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied") ("SDKCheek"+$side+".t"+$xyz[$z]) 10 $tValues[$z];
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied") ("SDKCheek"+$side+".r"+$xyz[$z]) 10 $rValues[$z];
				}
			}
		setAttr ctrlMouth_M.ty 0;
		}
	}

//jaw Translate Forward Phonemes
for ($i=0;$i<size($phonemes);$i++)
	{
	$values={0,0,0};
	if ($phonemes[$i]=="ohh") {$value=0.2;}
	if ($phonemes[$i]=="sss") {$value=0.2;}
	if ($phonemes[$i]=="ssh") {$value=0.2;}
	if ($value!=0)
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"JawMultiplied") "SDKJaw_M.tz" 10 $value;
	}


//Other controls
for ($i=0;$i<size($phonemes);$i++)
	{
	setAttr ("ctrlPhonemes_M."+$phonemes[$i]) 10;

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			//LipA towards CheekRaiser(upper) or FrownBulge(lower)
			$value=0;
			if ($phonemes[$i]=="aaa" && $upperLower=="upper") $value=0.15;
			if ($phonemes[$i]=="aaa" && $upperLower=="lower") $value=0.25;
			if ($phonemes[$i]=="eh" && $upperLower=="upper") $value=0.25;
			if ($phonemes[$i]=="eh" && $upperLower=="lower") $value=0.35;
			if ($phonemes[$i]=="ahh" && $upperLower=="upper") $value=0.15;
			if ($phonemes[$i]=="ahh" && $upperLower=="lower") $value=0.25;
//			if ($phonemes[$i]=="ohh" && $upperLower=="upper") $value=0.1;
//			if ($phonemes[$i]=="ohh" && $upperLower=="lower") $value=0.2;
			if ($phonemes[$i]=="uuu" && $upperLower=="upper") $value=0.1;
			if ($phonemes[$i]=="uuu" && $upperLower=="lower") $value=0.2;
			if ($phonemes[$i]=="iee" && $upperLower=="upper") $value=0.1;
			if ($phonemes[$i]=="iee" && $upperLower=="lower") $value=0.25;
			if ($phonemes[$i]=="mbp" && $upperLower=="upper") $value=-0.1;
			if ($phonemes[$i]=="sss" && $upperLower=="lower") $value=-0.1;
			if ($phonemes[$i]=="tth" && $upperLower=="upper") $value=0.1;
			if ($phonemes[$i]=="ssh" && $upperLower=="upper") $value=0.1;
			if ($phonemes[$i]=="ssh" && $upperLower=="lower") $value=-0.1;
			if ($value!=0)
				{
				pointConstraint -w (1.0-$value) ($upperLower+"LipA"+$side) tempXform;
				if ($upperLower=="upper") pointConstraint -w $value ("CheekRaiser"+$side) tempXform;
				if ($upperLower=="lower") pointConstraint -w $value ("FrownBulge"+$side) tempXform;
				$pos=`xform -q -ws -t tempXform`;
				parent tempXform ($upperLower+"LipASubtract"+$side);
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDK"+$upperLower+"LipA"+$side+".tx") 10 `getAttr tempXform.tx`;
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDK"+$upperLower+"LipA"+$side+".ty") 10 `getAttr tempXform.ty`;
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDK"+$upperLower+"LipA"+$side+".tz") 10 `getAttr tempXform.tz`;
				delete tempXform_pointConstraint1;
				parent -w tempXform;
				}
			}

		// Mouth narrowWide
		$value=0;
		if ($phonemes[$i]=="aaa") $value=0.3;
		if ($phonemes[$i]=="eh") $value=0.5;
		if ($phonemes[$i]=="ohh") $value=-0.65;
		if ($phonemes[$i]=="uuu") $value=-0.75;
		if ($phonemes[$i]=="iee") $value=0.5;
		if ($phonemes[$i]=="www") $value=-1;
		if ($phonemes[$i]=="sss") $value=-0.15;
		if ($phonemes[$i]=="fff") $value=0.2;
		if ($phonemes[$i]=="ssh") $value=-0.4;
		if ($value!=0)
			{
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKSmilePull"+$side+".tx") 10 (`getAttr LipPullValues.tx`*$value);
//removed, since SmilePull_R.tz is locked, so Edit system will not work
//			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKSmilePull"+$side+".tz") 10 (`getAttr LipPullValues.tz`*$value);
			}

		//MouthCorner upDown
		$value=0;
		if ($phonemes[$i]=="iee") $value=0.2;
		if ($phonemes[$i]=="fff") $value=0.2;
		if ($value!=0)
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKLipPull"+$side+".ty") 10 (`getAttr LipPullValues.ty`*$value);

		//SmileBulge towards CheekRaiser
		$value=0;
		if ($phonemes[$i]=="aaa") $value=0.15;
		if ($phonemes[$i]=="eh") $value=0.25;
		if ($phonemes[$i]=="iee") $value=0.25;
		if ($phonemes[$i]=="tth") $value=0.05;
		if ($value!=0)
			{
			pointConstraint -w (1.0-$value) ("SmileBulge"+$side) tempXform;
			pointConstraint -w $value ("CheekRaiser"+$side) tempXform;
			parent tempXform ("SmileBulgeSideReverse"+$side);
			$pos=`getAttr tempXform.t`;
			delete tempXform_pointConstraint1;

			for ($z=0;$z<size($xyz);$z++)
				asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKSmileBulge"+$side+".t"+$xyz[$z]) 10 $pos[$z];
			for ($z=0;$z<size($XYZ);$z++)
				{
				if (`objExists ("SDKSmileBulge_R_translate"+$XYZ[$z])`)
					setAttr ("SDKSmileBulge_R_translate"+$XYZ[$z]+".preInfinity") 1;
				if (`objExists ("SDKSmileBulge_R_translate"+$XYZ[$z]+"1")`)
					setAttr ("SDKSmileBulge_R_translate"+$XYZ[$z]+"1.preInfinity") 1;
				}
			}

		//FrownBulge towards NearestPointOnJawCurve
		//Needs to update to get VTX, since JawCurve does not Open along with Jaw
		$value=0;
		if ($phonemes[$i]=="aaa") $value=0.15;
		if ($phonemes[$i]=="eh") $value=0.25;
		if ($phonemes[$i]=="iee") $value=0.35;
		if ($value!=0)
			{
			$pos=`xform -q -ws -t $frownBulgeTowardsVtx`;
			xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] tempXform2;

			pointConstraint -w (1.0-$value) ("FrownBulge"+$side) tempXform;
			pointConstraint -w $value tempXform2 tempXform;
			parent tempXform ("FrownBulgeSideReverse"+$side);
			$pos=`getAttr tempXform.t`;
			delete tempXform_pointConstraint1;

			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKFrownBulge"+$side+".tx") 10 $pos[0];
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKFrownBulge"+$side+".ty") 10 $pos[1];
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKFrownBulge"+$side+".tz") 10 $pos[2];
			}

		//CheekRaiser upwards
		$value=0;
		if ($phonemes[$i]=="aaa") $value=0.25;
		if ($phonemes[$i]=="eh") $value=0.5;
		if ($value!=0)
			{
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKCheekRaiser"+$side+".ty") 10 $value;
			}
		}

	//upperLip_M
	$values={0,0,0};
	if ($phonemes[$i]=="ohh") {$values[2]=0.25;}
	if ($phonemes[$i]=="uuu") {$values[2]=0.45;}
	if ($phonemes[$i]=="iee") {$values[1]=0.1;}
	if ($phonemes[$i]=="rrr") {$values[1]=0.1;$values[2]=0.1;}
	if ($phonemes[$i]=="mbp") {$values[1]=-0.45;$values[2]=-0.45;}
	if ($phonemes[$i]=="sss") {$values[1]=0.1;}
	if ($phonemes[$i]=="ssh") {$values[1]=0.1;$values[2]=0.25;}
	if ($values[0]!=0 || $values[1]!=0 || $values[2]!=0)
		{
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") SDKupperLip_M.ty 10 $values[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") SDKupperLip_M.tz 10 $values[2];
		}

	//lowerLip_M
	$values={0,0,0};
	if ($phonemes[$i]=="ohh") {$values[2]=0.25;}
	if ($phonemes[$i]=="uuu") {$values[2]=0.45;}
	if ($phonemes[$i]=="iee") {$values[1]=-0.45;}
	if ($phonemes[$i]=="rrr") {$values[1]=-0.1;$values[2]=0.1;}
	if ($phonemes[$i]=="mbp") {$values[1]=0.25;$values[2]=-0.25;}
	if ($phonemes[$i]=="sss") {$values[1]=-0.45;}
	if ($phonemes[$i]=="fff") {$values[2]=-0.25;}
	if ($phonemes[$i]=="ssh") {$values[1]=-0.25;$values[2]=0.25;}
	if ($values[0]!=0 || $values[1]!=0 || $values[2]!=0)
		{
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") SDKlowerLip_M.ty 10 $values[1];
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") SDKlowerLip_M.tz 10 $values[2];
		}

	//upperLip_M roll
	$value=0;
	if ($phonemes[$i]=="ohh") $value=-30;
	if ($phonemes[$i]=="uuu") $value=-60;
	if ($phonemes[$i]=="rrr") $value=-30;
	if ($phonemes[$i]=="www") $value=-30;
	if ($phonemes[$i]=="mbp") $value=60;
	if ($phonemes[$i]=="sss") $value=-15;
	if ($phonemes[$i]=="tth") $value=-20;
	if ($phonemes[$i]=="ssh") $value=-50;
	if ($value!=0)
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") SDKupperLip_M.rx 10 $value;

	//lowerLip_M roll
	$value=0;
	if ($phonemes[$i]=="ohh") $value=30;
	if ($phonemes[$i]=="uuu") $value=60;
	if ($phonemes[$i]=="rrr") $value=30;
	if ($phonemes[$i]=="www") $value=30;
	if ($phonemes[$i]=="mbp") $value=-40;
	if ($phonemes[$i]=="sss") $value=30;
	if ($phonemes[$i]=="fff") $value=-50;
	if ($phonemes[$i]=="tth") $value=20;
	if ($phonemes[$i]=="ssh") $value=50;
	if ($value!=0)
		asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") SDKlowerLip_M.rx 10 $value;

	//tongue
	$values={0,0,0};// Rz of tongue1,2,3
	if ($phonemes[$i]=="rrr") {$values[0]=17;$values[1]=17;$values[2]=17;}
	if ($phonemes[$i]=="tth") {$values[0]=10;$values[1]=10;$values[2]=10;}
	if ($phonemes[$i]=="gk") {$values[0]=0;$values[1]=40;$values[2]=-80;}
	if ($phonemes[$i]=="lntd") {$values[0]=0;$values[1]=10;$values[2]=40;}
	if (($values[0]!=0 || $values[1]!=0 || $values[2]!=0) && `objExists Tongue3_M`)
		for ($a=1;$a<4;$a++)
			asDsSdk ("ctrlPhonemes_M."+$phonemes[$i]+"LipMultiplied") ("SDKTongue"+$a+"_M.rz") 10 $values[$a];

	setAttr ("ctrlPhonemes_M."+$phonemes[$i]) 0;
	}

delete tempXform tempXform2;
select ctrlPhonemes_M;
}

global proc asFaceDsSdk ()
{
float $drivenValue=1;
string $side;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";

	//ctrlCheek
	if (`objExists lowerLid_R`)
		{
		if (`attributeExists tyValueForCloseLid lowerLid_R`)
			$drivenValue=`getAttr lowerLid_R.tyValueForCloseLid`/4.0;
		asDsSdk ("ctrlCheek"+$side+".ty") ("SDKlowerLid"+$side+".ty") 1 $drivenValue;
		}
	if (`objExists lowerLidDroopy_R`)
		asDsSdk ("ctrlCheek"+$side+".ty") ("SDKlowerLidDroopy"+$side+".ty") 1 1;
	if (`objExists CheekRaiser_R`)
		asDsSdk ("ctrlCheek"+$side+".ty") ("SDKCheekRaiser"+$side+".ty") 1 0.15;
	asDsSdk ("ctrlCheek"+$side+".tx") ("SDKCheek"+$side+".tx") 1 1;
//	asFaceAddDrive CheekJoint $side ctrlCheek $side 1 {"tx"} {};

	//ctrlNose
	if (`objExists NoseCorner_R`)
		{
		asDsSdk ("ctrlNose"+$side+".ty") ("SDKNoseCorner"+$side+".ty") 1 0.5;
		asDsSdk ("ctrlNose"+$side+".tx") ("SDKNoseCorner"+$side+".tx") 1 0.25;
		}
	if (`objExists NoseSide_R`)
		asDsSdk ("ctrlNose"+$side+".ty") ("SDKNoseSide"+$side+".ty") 1 0.5;
	}
}

global proc asFaceFinish ()
{
int $haveSkinCluster;
float $value;
float $pos[],$posA[],$posB[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $mirrorVtx,$sc,$curveCmd,$leftCtrl,$objectType;
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;
string $tempString[],$tempString2[],$sets[],$historyNodes[],$attachers[];
string $ctrls[]={"Brow_R","Eye_R","Cheek_R","Nose_R","Mouth_M","MouthCorner_R"};

//correspond ctrls vis
$tempString=`listRelatives -c Acontrols`;
$tempString2=`listRelatives -c Bcontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
$tempString2=`listRelatives -c Ccontrols`;
$tempString=`stringArrayCatenate $tempString $tempString2`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;
setAttr ("LipPullOffset_R.v") 0;
setAttr ("LipPullOffset_L.v") 0;
setAttr ("MouthNarrowOffset_R.v") 0;
setAttr ("MouthNarrowOffset_L.v") 0;

setAttr ctrlBox.ACtrlVis 1;
setAttr ctrlBox.BCtrlVis 1;
setAttr ctrlBox.CCtrlVis 1;
setAttr ctrlBox.TeethCtrlVis 1;
setAttr ctrlBox.TongueCtrlVis 1;
setAttr ctrlBox.RegionsCtrlVis 1;
setAttr ctrlBox.UpMidLoCtrlVis 1;
setAttr ctrlBox.AimCtrlVis 1;
setAttr NoseRegionOffset_M.v 1;
setAttr LipRegionOffset_M.v 1;
setAttr EyeRegionOffset_R.v 1;
setAttr EyeRegionOffset_L.v 1;
setAttr EyeBrowMiddleOffset_M.v 1;
setAttr NoseCornerOffset_R.v 1;
setAttr NoseCornerOffset_L.v 1;
setAttr JawOffset_M.v 1;
if (`objExists upperTeethOffset_M`) setAttr upperTeethOffset_M.v 1;
if (`objExists lowerTeethOffset_M`) setAttr lowerTeethOffset_M.v 1;

asShowLayer Normal;

//run asFaceDsSdk first
asFaceDsSdk;

//Skinweight mirror all layers, since Right side might have been `SoftMod radius` edited.
select -cl;
$tempString=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists FaceFitLipMainLeft`)
		break;
	$haveSkinCluster=0;
	$historyNodes=`listHistory -pdo 1 -il 2 $tempString[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$sc=$historyNodes[$y];
			break;
			}
	if ($haveSkinCluster)
		copySkinWeights -ss $sc -ds $sc -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

//Wrap-attach (SkinAttachCtrls) to only use 1 curve
$tempString=`listRelatives -c -type transform SkinAttachCtrls`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (!`gmatch $tempString[$i] "*Attacher*"`)
	    continue;
	$attachers[size($attachers)]=$tempString[$i];
	}
$curveCmd="curve -d 1 -n AttacherCurve";
for ($i=0;$i<size($attachers);$i++)
	{
	$pos=`xform -q -ws -t $attachers[$i]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
eval ($curveCmd);
$tempString=`listRelatives -s AttacherCurve`;
rename $tempString[0] AttacherCurveShape;
//SkinAttachCtrls (the transform) must be visable, otherwise it causes crashing in Hardware textured mode
//parent AttacherCurve SkinAttachCtrls;
parent AttacherCurve SkinAttachCtrls FaceDeformationSystem;
setAttr "AttacherCurveShape.dispGeometry" 0;
for ($i=0;$i<size($attachers);$i++)
	{
	$tempString=`listConnections -s 1 -d 0($attachers[$i]+".t")`;
	connectAttr -f AttacherCurve.worldSpace[0] ($tempString[0]+".inputCurve");
	setAttr ($tempString[0]+".parameter") $i;
	}
//deletes all existing `SkinAttachCtrlsWraps` nodes, for creating a new Single SkinAttachCtrlsWrap
delete SkinAttachMesh;
$tempString=`listRelatives -c -type transform SkinAttachCtrls`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*AttachCurve*"`)
		delete $tempString[$i];
select AttacherCurve $geometry;
//$tempString=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
asCreateWrap ("SkinAttachCtrlsWrap",0,0,1,0,0);//$threshold $maxDistance $exclusiveBind $autoWeightThreshold $falloffMode
//rename $tempString[0] SkinAttachCtrlsWrap;

//Lock vis of hidden "base" obj, these are wrap-deform-base-meshes, and they are not to show, if user does "Show->All"
$tempString=`ls -r 1 -type mesh "*Base*"`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -f -p $tempString[$i]`;
	if (`getAttr ($tempString2[0]+".v")`==0 && `getAttr -l ($tempString2[0]+".v")`==0)
		setAttr -l 1 ($tempString2[0]+".v");
	}



//faceArea sets to be symmetrical
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
$sets=`sets -q FaceAreas`;
for ($i=0;$i<size($sets);$i++)
	{
	select `asobjSetCast $sets[$i] {} $geometry`;
	sets -clear $sets[$i];
	$tempString=`ls -sl -fl`;
	sets -add $sets[$i] $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		$pos=`xform -q -ws -t $tempString[$y]`;
		if ($pos[0]>=0)
			continue;
		setAttr -type float3 closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		$mirrorVtx=$geometry+".vtx["+`getAttr closestSampler.result.closestVertexIndex`+"]";
		if (!`sets -im $sets[$i] $mirrorVtx`)
			sets -add $sets[$i] $mirrorVtx;
		}
	}
delete closestSampler;

if (`objExists tempLocFlip`) delete tempLocFlip;

if (`objExists FaceBuildInProgress`) delete FaceBuildInProgress;


//Also update buildPose
select `sets -q FaceControlSet`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	$tempString=`listAttr -k -shortNames $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controlSetMembers[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
setAttr -type "string" faceBuildPose.udAttr $setAttrCmd;

//version
if (!`attributeExists version FaceGroup`)
	addAttr -ln version -at double FaceGroup;
setAttr -l 0 FaceGroup.version;
setAttr -l 1 FaceGroup.version `asGetScriptVersion`;

//update AllSet
select -ne `ls -o`;
select -ne -d `ls -type objectSet`;
select -ne -d `ls -type partition`;
select -d allBeforeFaceBuild;
//not include any `intermediate` meshes, as these most likely belong to the model
select -d `ls -type mesh -intermediateObjects`;
//include "FaceAreas" sets
select -add -ne `sets -q FaceAreas` FaceAreas;
sets -add FaceAllSet `ls -sl`;

sets -rm FaceBuildingSets allBeforeFaceBuild;
delete `sets -q FaceBuildingSets`;

asEnsureSDKcurvesNamed;

asGoToBuildPose faceSetup;//as we might have "keept buildpose" from previous build.

//Resore any deltaMush
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
		setAttr ($tempString[$y]+".envelope") 1;

//isHistoricallyInteresting
asSetIsHistoricallyInteresting FaceControlSet;

cycleCheck -e on;

evalDeferred ("sets -clear allBeforeFaceBuild;delete allBeforeFaceBuild;");

asUpdateButtonEnables;
select -cl;
print ("// Advanced Face created\n");
}

global proc asFaceRebuildRestore ()
{
int $numKeys,$customizedDrivingSystemCurve,$haveSkinCluster,$spans,$degree,$numCVs;
int $keepAll=`checkBox -q -v asFaceKeepAllCheckBox`;
int $keepSkinWeights=`checkBox -q -v asFaceKeepSkinWeightsCheckBox`;
//int $transferSkinWeights=`checkBox -q -v asFaceTransferSkinWeightsCheckBox`;
int $keepPupil=`checkBox -q -v asFaceKeepPupilCheckBox`;
int $keepEyeBrow=`checkBox -q -v asFaceKeepEyeBrowCheckBox`;
int $keepEyeLash=`checkBox -q -v asFaceKeepEyeLashCheckBox`;
//int $keepDeltaMush=`checkBox -q -v asFaceKeepDeltaMushCheckBox`;
int $keepHeadSquash=`checkBox -q -v asFaceKeepHeadSquashCheckBox`;
int $keepBlendShapes=`checkBox -q -v asFaceKeepBlendShapesCheckBox`;
int $keepDrivingSystems=`checkBox -q -v asFaceKeepDrivingSystemsCheckBox`;
int $keepCurveShapes=`checkBox -q -v asFaceKeepCurveShapesCheckBox`;
float $fc[],$vc[],$pFc[],$pVc[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $newAnimCurve,$blendWeighted,$deltaMush,$curveShape,$prefixCurveShape;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$historyNodes[],$allFaceGeo[],$animCurves[],$cmds[];
string $controls[]=`sets -q FaceControlSet`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//Restore procedures done after FaceBuil (Iris, EyeBrow, EyeLash, FaceExtras, DeltaMush, BlendShapes, CustomControllers, Simplified FaceSetup
if (!`objExists prefix_FaceGroup`)
	return;

if (`attributeExists previousIris prefix_FaceGroup`)
	checkBox -e -v 1 asFaceIrisCheckBox;
if (`attributeExists previousPupil prefix_FaceGroup` && ($keepAll || $keepPupil))
	{
	print ("// Restoring EyeBall setup.\n");
	asFaceEyeBallBuild;
	}

//skinWeightedToFace
if ($keepAll || $keepEyeBrow)
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!=$geometry)
			if (`attributeExists skinWeightedToFace $allFaceGeo[$i]`)
				{
				print ("// Restoring SkinWeightedToFace for:\""+$allFaceGeo[$i]+"\".\n");
				select $allFaceGeo[$i];
				asFaceCopyWeightsToFace;
				}

//transfer weights from previous face-build
if (`objExists prefix_DeformationLayers` && ($keepAll || $keepSkinWeights))
	{
	$tempString=`listRelatives -c prefix_DeformationLayers`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2[0]=`substitute "prefix_" $tempString[$i] ""`;
		if (!`objExists $tempString2[0]`)
			{
			//add missing DeformationLayer objects, such as EyeBrowLayer_model_brow_R
			print ("// Skipping weights for missing skinLayer object:"+ $tempString[$i]+"\n");
			continue;
			}
		$haveSkinCluster=0;
		$historyNodes=`listHistory -pdo 1 -il 2 $tempString[$i]`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				$haveSkinCluster=1;
		if (!$haveSkinCluster)
			continue;
		//here we need to add influence for missing joints, e.g EyeBrows , Iris etc skinning previously added
		select $tempString[$i] $tempString2[0];
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}
	}

//keepDrivingSystems
if ($keepAll || $keepDrivingSystems)
	{
	$tempString=`ls "prefix_bwSDK*"`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$animCurves=`listConnections -scn 1 -s 1 -d 0 -type animCurve $tempString[$i]`;
		for ($y=0;$y<size($animCurves);$y++)
			{
			$newAnimCurve=`substitute "prefix_" $animCurves[$y] ""`;
			if (`gmatch $newAnimCurve "SDKSmilePull_*_translateZ*"`)//versions prior to 5.679 had some un-needed SmilePull_R.tz driving
				continue;
			if (`getAttr prefix_FaceGroup.version`<5.683 && `gmatch $newAnimCurve "SDK*Pull*"`)//versions prior to 5.679 had different LipPull driving
				continue;
			if (!`objExists $newAnimCurve`)
				{
				print ("// Restoring missing DrivingSystem curve:\""+$newAnimCurve+"\" from: ");		
				duplicate -n $newAnimCurve $animCurves[$y];
				sets -rm prefix_FaceAllSet $newAnimCurve;
				$tempString2=`listConnections -p 1 -s 1 -d 0 -scn 1 ($animCurves[$y]+".input")`;
				$tempString3=`listConnections -p 0 -s 0 -d 1 -scn 1 ($animCurves[$y]+".output")`;
				$tempString2[0]=`substitute "prefix_" $tempString2[0] ""`;
				print ("\""+$tempString2[0]+"\".\n");		
				$tempString4=`listConnections -p 1 -s 0 -d 1 -scn 1 ($tempString3[0]+".output")`;
				$tempString4[0]=`substitute "prefix_" $tempString4[0] ""`;
				if ($tempString2[0]=="" || $tempString4[0]=="")
					continue;
				connectAttr $tempString2[0] ($newAnimCurve+".input");
				$blendWeighted=`asEnsureBlendWeighted $tempString4[0]`;
				connectAttr ($newAnimCurve+".output") ($blendWeighted+".input["+`getAttr -s ($blendWeighted+".input")`+"]");
				dgdirty -a;refresh;//to get `getAttr -s ($blendWeighted+".input")` returning correctly
				}

				$customizedDrivingSystemCurve=0;
			$numKeys=`keyframe -q -keyframeCount $animCurves[$y]`;
			for ($z=0;$z<$numKeys;$z++)
				{
				$fc=`keyframe -in $z -q -fc $animCurves[$y]`;
				$vc=`keyframe -in $z -q -vc $animCurves[$y]`;
				$pFc=`keyframe -in $z -q -fc $newAnimCurve`;
				$pVc=`keyframe -in $z -q -vc $newAnimCurve`;
				if ($fc[0]!=$pFc[0] || $vc[0]!=$pVc[0])
					$customizedDrivingSystemCurve=1;
				}
			if (!$customizedDrivingSystemCurve)
				continue;
			print ("// Restoring customized DrivingSystem curve:\""+$newAnimCurve+"\".\n");			
			select $animCurves[$y];
			selectKey -add -k -f "-999:999" $newAnimCurve;
			copyKey;
			select $newAnimCurve;
			selectKey -add -k -f "-999:999" $animCurves[$y];
			pasteKey -option "replaceCompletely";
			}
		}
	}

if (($keepAll || $keepHeadSquash) && `objExists prefix_squashFfdSet`)
	{
	print ("// Restoring HeadSquash.\n");
	asAdvancedSquash;
	select ($geometry+".vtx[0:99999]");
	if (!`sets -im prefix_squashFfdSet`)
		{
		print ("// Restoring Optimize HeadSquash.\n");
		select -cl;
		asOptimizeSquash;
		}
	select -cl;
	}

//BlendShapes
if (($keepAll || $keepBlendShapes) && `objExists prefix_asBlendShapes`)
	{
	print ("// Restoring BlendShapes.\n");
	checkBox -e -v 1 asKeepBSTargetsCheckBox;
	if (`attributeExists convertedboxCtrlsToBlendShapes prefix_FaceGroup`
	 || `attributeExists convertedctrlPhonemesToBlendShapes prefix_FaceGroup`
	 ||`attributeExists convertedctrlMouthToBlendShapes prefix_FaceGroup`)
		asBSConvertControlsToBlendShapes boxCtrls;
	if (`attributeExists convertedsquintToBlendShapes prefix_FaceGroup`)
		asBSConvertControlsToBlendShapes squint;
	if (`attributeExists convertedfleshyEyeToBlendShapes prefix_FaceGroup`)
		asBSConvertControlsToBlendShapes fleshyEye;
	if (`attributeExists convertedblinkToBlendShapes prefix_FaceGroup`)
		asBSConvertControlsToBlendShapes blink;

	if (`objExists asBlendShapes`)
		{
		$tempString=`listRelatives -c asBlendShapes`;
		for ($i=0;$i<size($tempString);$i++)
			{
			if (!`objExists ("prefix_"+$tempString[$i])`)
				continue;
			connectAttr ("prefix_"+$tempString[$i]+".outMesh") ($tempString[$i]+".inMesh");
			refresh;
			}
		delete asBlendShapes;
		}
	}

//keepCurveShapes
if ($keepAll || $keepCurveShapes)
	{
	print ("// Restoring control shapes and colors.\n");
	for ($i=0;$i<size($controls);$i++)
		{
		$tempString=`listRelatives -s $controls[$i]`;
		for ($z=0;$z<size($tempString);$z++)
			{
			$curveShape=$tempString[$z];
			$prefixCurveShape="prefix_"+$tempString[$z];
			if (!`objExists $curveShape` || !`objExists $prefixCurveShape`)
				continue;
			if (`objectType $curveShape`!="nurbsCurve" || `objectType $prefixCurveShape`!="nurbsCurve")
				continue;
			$spans=`getAttr ($prefixCurveShape+".spans")`;
			$degree=`getAttr ($prefixCurveShape+".degree")`;
			$numCVs=$spans+$degree;
			for ($y=0;$y<$numCVs;$y++)
				{
				$cvPos=`getAttr ($prefixCurveShape+".controlPoints["+$y+"]")`;
				$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
				}
			//color
			$cmds[size($cmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($prefixCurveShape+".overrideColor")`+";";
			}
		}
	for ($cmd in $cmds)
		if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
	}

if (`objExists prefix_FaceGroup`) delete prefix_FaceGroup;
if (`objExists prefix_FaceAllSet`) delete `sets -q prefix_FaceAllSet`;

print ("// Advanced Face Rebuild complete.\n");
asUpdateButtonEnables;
}

global proc asFaceResetBuildStep ()
{
int $buildStep,$newBuildStep;
if (!`objExists FaceFitSkeleton`)
	return;
$buildStep=`getAttr FaceFitSkeleton.buildStep`;
if ($buildStep==0)
	{
	for ($i=0;$i<99;$i++)
		if (!`columnLayout -q -ex ("asStepBuildColumnLayout"+$i)`)
			break;
	$newBuildStep=$i-2;
	}
setAttr FaceFitSkeleton.buildStep $newBuildStep;
asFaceUpdateInfo 1;
}

global proc asFaceAddHeadObjectAsLayerMesh (string $layer)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $rightEye=`textField -q -tx asFaceEye_RTextField`;
string $leftEye=`textField -q -tx asFaceEye_LTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $name;
string $tempString[],$tempString2[],$teethTongueEyes[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

//$teethTongueEyes, since it can be multiple objs, e.g eye+lens 
$tempString={$upperTeeth,$lowerTeeth,$tongue,$leftEye,$rightEye};
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	for ($y=0;$y<size($tempString2);$y++)
		if ($tempString2[$y]!="")
			$teethTongueEyes[size($teethTongueEyes)]=$tempString2[$y];
	}

for ($i=0;$i<size($allFaceGeo);$i++)
	{
	if ($allFaceGeo[$i]==$geometry || `stringArrayCount $allFaceGeo[$i] $teethTongueEyes`)
		continue;
	$name=`substitute ":" $allFaceGeo[$i] "_"`;

	if (!`objExists ($layer+"_"+$name)`)
		{
		duplicate -n ($layer+"_"+$name) $allFaceGeo[$i];
		parent ($layer+"_"+$name) DeformationLayers;
		sets -e -forceElement initialShadingGroup ($layer+"_"+$name);
		$tempString=`listRelatives -s ($layer+"_"+$name)`;
		for ($y=0;$y<size($tempString);$y++)
			if (`getAttr ($tempString[$y]+".intermediateObject")`)
				delete $tempString[$y];

		select ($layer+"_"+$name) $allFaceGeo[$i];
		blendShape -n ("asFaceBS_"+$name) -w 0 1 -frontOfChain;

		setAttr ($allFaceGeo[$i]+".v") 0;
		select upperFaceJoint_M middleFaceJoint_M lowerFaceJoint_M ($layer+"_"+$name);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ("UpMidLoSC_"+$name);
		}
	select $layer ($layer+"_"+$name);
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
}

global proc asReuseIntermediateMesh (string $source, string $dest)
{
string $sourceMesh,$destMesh;
string $tempString[];

$tempString=`listRelatives -s $source`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		{
		$sourceMesh=$tempString[$i];
		break;
		}
$tempString=`listRelatives -s $dest`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		{
		$destMesh=$tempString[$i];
		break;
		}
connectAttr ($sourceMesh+".outMesh") ($destMesh+".inMesh");
}

global proc asFaceHalfMoonCurve (string $ctrl, float $rotation)
{
int $cv1Nr=7;
int $cv2Nr=3;
float $factor=8;
float $posA[],$posB[];

for ($i=0;$i<3;$i++)
	{
	if ($i==1) {$cv1Nr=0;$cv2Nr=2;}
	if ($i==2) {$cv1Nr=6;$cv2Nr=4;}
	if ($i>0) $factor=4;

	$posA=`xform -q -ws -t ($ctrl+".cv["+$cv1Nr+"]")`;
	$posB=`xform -q -ws -t ($ctrl+".cv["+$cv2Nr+"]")`;
	xform -ws -t ((($posA[0]*$factor)+($posB[0]*1))/($factor+1)) ((($posA[1]*3)+($posB[1]*1))/4.0) ((($posA[2]*3)+($posB[2]*1))/4.0) ($ctrl+".cv["+$cv2Nr+"]");
	}

$posA=`xform -q -ws -t ($ctrl+".cv[1]")`;
$posB=`xform -q -ws -t ($ctrl+".cv[3]")`;
xform -ws -t ((($posA[0]*$factor)+($posB[0]*1))/($factor+1)) $posA[1] $posA[2] ($ctrl+".cv[1]");

$posA=`xform -q -ws -t ($ctrl+".cv[5]")`;
$posB=`xform -q -ws -t ($ctrl+".cv[3]")`;
xform -ws -t ((($posA[0]*$factor)+($posB[0]*1))/($factor+1)) $posA[1] $posA[2] ($ctrl+".cv[5]");

$posA=`xform -q -ws -t $ctrl`;
rotate -r -p $posA[0] $posA[1] $posA[2] -os 0 0 $rotation ($ctrl+".cv[0:99]");

scale -r -p $posA[0] $posA[1] $posA[2] 1.35 1.35 1.35 ($ctrl+".cv[0:99]");
}

global proc asFaceAddDrive (string $driven, string $drivenSide, string $driver, string $driverSide, float $dv, string $drivenAttrs[], string $driverAttrs[])
{
int $showAttr=1;
int $driverIsCtr=1;
float $ctrlScale=`getAttr upperFaceOffset_M.sx`;
string $exp,$existingExp,$mirrorMult,$ctrlScaleMult,$attributeObject;
string $xyz[]={"x","y","z"};
string $trs[]={"t","r","s"};
string $tempString[];

if ($driven==$driver+"Joint")//no need to show attr, when it is the `Main` driver
	$showAttr=0;
if (`gmatch $driven "*ClusterHandle*"`)
	$showAttr=0;

if (`gmatch $driver "*Constrained"` || `gmatch $driver "*FollowWs2*"` || `gmatch $driver "*Joint*"`)
	$driverIsCtr=0;

$attributeObject=$driver;
if ($driverIsCtr==0)
	$attributeObject=`substitute "Joint" $attributeObject ""`;

//string $attrName=$driven+$drivenSide;
string $attrName=$driven;
if (size($drivenAttrs)==1)
	$attrName+="_"+$drivenAttrs[0];
if (size($drivenAttrs)==3)
	{
	if ($drivenAttrs[0]=="tx" && $drivenAttrs[1]=="ty" && $drivenAttrs[2]=="tz") $attrName+="_t";
	if ($drivenAttrs[0]=="rx" && $drivenAttrs[1]=="ry" && $drivenAttrs[2]=="rz") $attrName+="_r";
	if ($drivenAttrs[0]=="sx" && $drivenAttrs[1]=="sy" && $drivenAttrs[2]=="sz") $attrName+="_s";
	}
if ($driverSide=="_M" && $drivenSide!="_M")
	$attrName+=$drivenSide;
if (`attributeExists $attrName ($attributeObject+$driverSide)`)
	for ($i=1;$i<99;$i++)
		if (!`attributeExists ($attrName+$i) ($attributeObject+$driverSide)`)
			{
			$attrName=$attrName+$i;
			break;
			}

if (!`attributeExists influence ($attributeObject+$driverSide)` && $showAttr)
	{
	addAttr -k 1 -ln influence -at double ($attributeObject+$driverSide);
	setAttr -l 1 ($attributeObject+$driverSide+".influence");
	}
//addAttr -k 1 -ln $attrName -at double -dv $dv -smx 2 -hsx 1 -smn 0 -hnv 1 ($attributeObject+$driverSide);
addAttr -k 1 -ln $attrName -at double -dv $dv ($attributeObject+$driverSide);
setAttr -cb 1 ($attributeObject+$driverSide+"."+$attrName);

if (!$showAttr)
	setAttr -cb 0 -k 0 ($attributeObject+$driverSide+"."+$attrName);

if (`objExists ($driven+"DriveExp"+$drivenSide)`)
	$existingExp=`getAttr ($driven+"DriveExp"+$drivenSide+".expression")`;

if ($existingExp=="")
	{
	$exp="//AdvancedSkeleton autogenerated expression\n";
	$exp+="float $tx=0;float $ty=0;float $tz=0;float $rx=0;float $ry=0;float $rz=0;float $sx=0;float $sy=0;float $sz=0;\n";
	}
else
	{
	//remove "to:" section
	tokenize $existingExp "\n" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`gmatch $tempString[$i] "//from:*"`)
			$exp+="\n";
		if (`gmatch $tempString[$i] "//to:*"`)
			break;
		$exp+=$tempString[$i]+"\n";
		}
	delete ($driven+"DriveExp"+$drivenSide);
	}

if (!size($drivenAttrs))
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$drivenAttrs[size($drivenAttrs)]=$trs[$y]+$xyz[$z];
			}

if (size($driverAttrs)==0)
	$driverAttrs=$drivenAttrs;

$exp+="\n//from:"+$driver+$driverSide+"\n";

for ($i=0;$i<size($drivenAttrs);$i++)
	{
	$mirrorMult=$ctrlScaleMult="";
	if ($driverIsCtr)
		{
		if ($driverSide=="_R")
			if ($driverAttrs[$i]=="tx" || $driverAttrs[$i]=="ry" || $driverAttrs[$i]=="rz") 
				$mirrorMult="*-1";
		if (`gmatch $driverAttrs[$i] "t*"` || `gmatch $driverAttrs[$i] "*drivet*"` || `gmatch $driverAttrs[$i] "*driverT*"`)
			$ctrlScaleMult="*"+$ctrlScale;
		}

	if ($driverAttrs[$i]=="sx" || $driverAttrs[$i]=="sy" || $driverAttrs[$i]=="sz")//scale attrs needs multiply
		$exp+="$"+$drivenAttrs[$i]+"+=("+$driver+$driverSide+"."+$driverAttrs[$i]+"-1)*"+$attributeObject+$driverSide+"."+$attrName+$ctrlScaleMult+$mirrorMult+";\n";
	else
		$exp+="$"+$drivenAttrs[$i]+"+="+$driver+$driverSide+"."+$driverAttrs[$i]+"*"+$attributeObject+$driverSide+"."+$attrName+$ctrlScaleMult+$mirrorMult+";\n";
	}

$exp+="\n";
$exp+="//to:\n";
for ($y=0;$y<size($trs);$y++)
	for ($z=0;$z<size($xyz);$z++)
		{
		if ($trs[$y]=="s")//scale attrs needs multiply
			$exp+=$driven+$drivenSide+"."+$trs[$y]+$xyz[$z]+"=($"+$trs[$y]+$xyz[$z]+"+1);\n";
		else
			$exp+=$driven+$drivenSide+"."+$trs[$y]+$xyz[$z]+"=$"+$trs[$y]+$xyz[$z]+";\n";
		}
expression -n ($driven+"DriveExp"+$drivenSide) -s $exp -o ($driven+$drivenSide) -ae 1 -uc all ;
}

global proc string asGetFaceFitSelection (string $object)
{
int $tempInts[];
int $form,$spans,$degrees,$numCv,$vtxNr,$numVtx;
float $radius,$maxScale;
float $scale=`asFaceGetScale`;
float $pos[],$pos2[],$s[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $selection,$objectType;
string $sel[]=`ls -sl`;
string $tempString[],$curves[],$groupChildren[];
$tempString=`listRelatives -s $object`;
if ($tempString[0]!="")
	$objectType=`objectType $tempString[0]`;

if (`objExists closestSamplerFitSelection2`) delete closestSamplerFitSelection2;
createNode -n closestSamplerFitSelection2 closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSamplerFitSelection2.inMesh;

if ($objectType=="locator")
	{
	$pos=`xform -q -ws -t $object`;
	setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
	$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
	$selection=($geometry+".vtx["+$vtxNr+"]");
	}
else if ($objectType=="mesh")
	{
	$tempInts=`polyEvaluate -v $object`;
	$numVtx=$tempInts[0];
	for ($i=0;$i<$numVtx;$i++)
		{
		$pos=`xform -q -ws -t ($object+".vtx["+$i+"]")`;
		setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
		$selection+=($geometry+".vtx["+$vtxNr+"] ");
		}
	}
else if ($tempString[0]=="")
	{
	$groupChildren=`listRelatives -c $object`;
	for ($i=0;$i<size($groupChildren);$i++)
		{
		$tempString=`listRelatives -s $groupChildren[$i]`;
		if (`gmatch $groupChildren[$i] "*Profile*"`)
			continue;
		if ($tempString[0]!="")
			$curves[size($curves)]=$groupChildren[$i];
		}
	}
else
	$curves[0]=$object;

for ($i=0;$i<size($curves);$i++)
	{
	$spans=`getAttr ($curves[$i]+".spans")`;
	$degrees=`getAttr ($curves[$i]+".degree")`;
	$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr -type float3 closestSamplerFitSelection2.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSamplerFitSelection2.result.closestVertexIndex`;
		$selection+=($geometry+".vtx["+$vtxNr+"] ");
		}
	}

delete closestSamplerFitSelection2;
select $sel;
return $selection;
}

global proc string[] asobjSetCast (string $set, string $components[], string $destObj)
{
//string $sel[]=`ls -sl`;
string $tempString[],$return[];

if ($set!="")
	{
	select $set;
	$tempString=`ls -sl -fl`;
	}
else
	$tempString=$components;

//string $tempString[]=`ls -sl -fl`;
string $tempString2[];
tokenize $tempString[0] "[.]" $tempString2;
string $sourceObj=$tempString2[0];
//select -cl;
for ($i=0;$i<size($tempString);$i++)
	{
	$return[$i]=`substitute $sourceObj $tempString[$i] $destObj`;
	}

//string $return[]=`ls -sl -fl`;
//select $sel;
return $return;
}

global proc asFaceReSelect (string $section, string $part)
{
string $leftSuffix;
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSym`=="Left")
		$leftSuffix="Left";
string $faceFitNode="FaceFit"+$section+$part+$leftSuffix;
if (`objExists $faceFitNode`)
	if (`attributeExists selection $faceFitNode`)
		eval ("select "+`getAttr ($faceFitNode+".selection")`);
print ("// ReSelecting: "+$section+" : "+$part+$leftSuffix+"\n");
}

global proc asFaceEditLipShapeBySoftMod ()
{
setAttr JawOpenLayer.v (!`getAttr JawOpenLayer.v`);
setAttr LipDeform.v (!`getAttr LipDeform.v`);
if (`getAttr LipDeform.v`)
	{
	select mouthOpenSoftModHandle;
	AttributeEditor;
	}
else
	select -cl;
}

global proc asFaceUpdateLipShapeBySoftMod ()
{
setAttr JawOpenLayer.v 1;
setAttr LipDeform.v 0;
asFaceWeightLips;
asFaceUpdateJawCurvesWeights;
print "// Updated\n";
}

global proc asFaceWeightLips ()
{
float $weight;
float $values[],$pos[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[],$lipMainVtxs[],$lipOuterVtxs[],$lipInnerVtxs[],$lipAreaVtxs[],$infs[];
string $sel[]=`ls -sl`;

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 1;
float $currentTime=`currentTime -q`;
currentTime 0;

skinPercent -tv Face_M 1 JawOpenLayerSC JawOpenLayer.vtx[0:99999];

duplicate -n lipWeighter $geometry;
$tempString=`listRelatives -s -f lipWeighter`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
sets -rm lipArea lipWeighter.vtx[0:99999];
sets -add mouthOpenSoftModSet lipWeighter;
sets -add mouthOpenSoftModSet JawCurveMid.cv[1:4];
setAttr mouthOpenSoftModHandle.ty 0;
if (!`objExists lipAreaJawOpenLayer`)
	{
	createNode -n lipAreaJawOpenLayer objectSet;
	sets -add FaceBuildingSets lipAreaJawOpenLayer;
	}
select lipArea;
$tempString=`ls -sl -fl`;
select `asobjSetCast "" $tempString JawOpenLayer`;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	string $vtxOnLipWeighter=`substitute JawOpenLayer $tempString[$i] lipWeighter`;
	$posA=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 1;
	$posB=`xform -q -ws -t $vtxOnLipWeighter`;
	setAttr mouthOpenSoftModHandle.ty 0;
	$weight=$posB[1]-$posA[1];
	$tempString[0]=`substitute $geometry $tempString[$i] JawOpenLayer`;
	sets -add lipAreaJawOpenLayer $tempString[0];
	catchQuiet (`skinPercent -tv JawJoint_M $weight JawOpenLayerSC $tempString[0]`);
	}
delete lipWeighter;

//Smooth Lip weights, since the SoftMod (with surface falloff) will create some lip-crunching
select `asobjSetCast lipArea {} JawOpenLayer`;
$lipAreaVtxs=`ls -sl -fl`;
eval ("select "+`asGetFaceFitSelection FaceFitLipMainCurve`);
$lipMainVtxs=`ls -sl`;
select `asobjSetCast "" $lipMainVtxs JawOpenLayer`;
$lipMainVtxs=`ls -sl -fl`;

eval ("select "+`asGetFaceFitSelection FaceFitLipOuterCurve`);
$lipOuterVtxs=`ls -sl`;
select `asobjSetCast "" $lipOuterVtxs JawOpenLayer`;
$lipOuterVtxs=`ls -sl -fl`;

eval ("select "+`asGetFaceFitSelection FaceFitLipInnerCurve`);
$lipInnerVtxs=`ls -sl`;
select `asobjSetCast "" $lipInnerVtxs JawOpenLayer`;
$lipInnerVtxs=`ls -sl -fl`;

for ($i=0;$i<size($lipOuterVtxs);$i++)
	{
	select $lipOuterVtxs[$i];
	for ($a=0;$a<99;$a++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $tempString[$y] $lipMainVtxs`)
				{
				$infs=`skinPercent -q -t JawOpenLayerSC $tempString[$y]`;
				$values=`skinPercent -q -v JawOpenLayerSC $tempString[$y]`;
				for ($z=0;$z<size($infs);$z++)
					if ($infs[$z]=="JawJoint_M")
						$weight=$values[$z];
				skinPercent -tv JawJoint_M $weight JawOpenLayerSC $lipOuterVtxs[$i];
				$a=99;
				}
		}
	}

for ($i=0;$i<size($lipInnerVtxs);$i++)
	{
	select $lipInnerVtxs[$i];
	for ($a=0;$a<99;$a++)
		{
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			if (`stringArrayCount $tempString[$y] $lipMainVtxs`)
				{
				$infs=`skinPercent -q -t JawOpenLayerSC $tempString[$y]`;
				$values=`skinPercent -q -v JawOpenLayerSC $tempString[$y]`;
				for ($z=0;$z<size($infs);$z++)
					if ($infs[$z]=="JawJoint_M")
						$weight=$values[$z];
				skinPercent -tv JawJoint_M $weight JawOpenLayerSC $lipInnerVtxs[$i];
				$a=99;
				}
		}
	}

select $lipAreaVtxs;
select -d $lipMainVtxs $lipOuterVtxs $lipInnerVtxs;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[0]>-0.001)
		select -d $tempString[$i];
	}
if (size(`ls -sl`))
	weightHammerVerts;
select JawOpenLayer;
if (!`objExists FaceFitLipMainLeft`)
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 0;
currentTime $currentTime;
select $sel;
}

global proc asFaceUpdateJawCurvesWeights ()
{
global string $gMainPane;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
float $posA[],$posB[],$posC[];
float $bbCurveTop[],$bbCurveBottom[];
float $maxDist;
string $tempString[],$ySel[],$zSelInv[],$infJoints[],$lipFalloffAreaVtxs[];
int $numJawSmooths=`intField -q -v asFaceNumJawSmooths`;
int $upperLipOuterNumCVs=`getAttr upperLipOuterCurve.spans`+1;
int $vtxsFromLipToNose=3;
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
float $currentTime=`currentTime -q`;
currentTime 0;

progressBar -e -st ("Update Jaw Weights") -bp -ii 0 -min 0 -max 1 $gMainProgressBar;

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 1;

if (`objExists jawArea`) delete jawArea;
if (`objExists jawCurveVtxs`) delete jawCurveVtxs;

asSelectCurveVtx JawCurve;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] JawOpenLayer`;
string $jawCurveVtxs[]=`ls -sl -fl`;
sets -n jawCurveVtxs;
sets -add FaceBuildingSets jawCurveVtxs;
asSelectCurveVtx JawCurveMid;
$tempString=`ls -sl -fl`;select -cl;
for ($i=0;$i<size($tempString);$i++) select -add `substitute $geometry $tempString[$i] JawOpenLayer`;
string $jawCurveMidVtxs[]=`ls -sl -fl`;

skinPercent -tv JawJoint_M 1 JawOpenLayerSC $jawCurveVtxs;
skinPercent -tv JawJoint_M 0.5 JawOpenLayerSC $jawCurveMidVtxs;

//taper off skinWeights towards the jawPivot, based on distance
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t Jaw`;
$maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv JawJoint_M (($dist/$maxDist)*2) JawOpenLayerSC $jawCurveVtxs[$i];
	}

//taper off skinWeights towards the jawPivot, based on distance (50vtx)
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t upperLipOuterCurve.cv[$upperLipOuterNumCVs]`;
$maxDist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
for ($i=0;$i<size($jawCurveMidVtxs);$i++)
	{
	$posB=`xform -q -ws -t $jawCurveMidVtxs[$i]`;
	float $dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<($maxDist/2.0))
		skinPercent -tv JawJoint_M ($dist/$maxDist) JawOpenLayerSC $jawCurveMidVtxs[$i];
	}

//Select vtxs with curve boundaries, first from BB polySeConstr for speed
duplicate -n JawCurveTopSampler JawCurveTop;
duplicate -n JawCurveBottomSampler JawCurveBottom;
select JawCurveTopSampler.cv[0:6] JawCurveBottomSampler.cv[0:5];
move -x 0;
//include Jaw vtx
move -r 0 -0.001 0 JawCurveBottomSampler.cv[5];
//Jaw can be lower than throat on some characters
$posA=`xform -q -ws -t Jaw`;
$posB=`xform -q -ws -t Throat`;
if ($posA[1]<$posB[1])
	{
	xform -ws -t 0 $posA[1] $posA[2] JawCurveBottomSampler.cv[5];
	//And there might be vtx`s lower then Jaw loc
	$posC=`xform -q -ws -t JawCurveBottomSampler.cv[4]`;
	xform -ws -t 0 ($posA[1]-(`getAttr FaceFitSkeleton.sy`/10.0)) (($posA[2]+$posC[2])/2.0) JawCurveBottomSampler.cv[4];
	}
spaceLocator -n samplerLocator;
spaceLocator -n samplerLocatorTop;
spaceLocator -n samplerLocatorBottom;
parent samplerLocatorTop samplerLocatorBottom samplerLocator;
select JawCurveTopSampler samplerLocatorTop;geometryConstraint -weight 1;
select samplerLocator samplerLocatorTop;pointConstraint;
select JawCurveBottomSampler samplerLocatorBottom;geometryConstraint -weight 1;
select samplerLocator samplerLocatorBottom;pointConstraint;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenLayer;
//polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[4] -da 0 1 0 -dp 0 0 0;
//updated to all for jaw to be under world Y axis(fish)
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveTop[4]-$bbCurveBottom[1])/1.99) -dp 0 (($bbCurveTop[4]+$bbCurveBottom[1])/2.0) 0 -da 0 1 0;
$ySel=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[2]-100);
$zSelInv=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
asInvertSelection;
string $outsideOuterBoundsVtxs[]=`ls -sl`;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenLayer;
//polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveBottom[1] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
//updated to all for jaw to be under world Y axis(fish)
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveTop[1]-$bbCurveBottom[1])/2.0) -dp 0 (($bbCurveTop[1]+$bbCurveBottom[1])/2.0) 0 -da 0 1 0;
$ySel=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 100 -da 0 0 1 -dp 0 0 ($bbCurveBottom[5]-100);
$zSelInv=`ls -sl`;
polySelectConstraint -m 0;
select $ySel;
select -d $zSelInv;
string $insideInnerBoundsVtxs[]=`ls -sl`;

$bbCurveTop=`xform -q -ws -bb JawCurveTopSampler`;
$bbCurveBottom=`xform -q -ws -bb JawCurveBottomSampler`;
select JawOpenLayer;
//polySelectConstraint -m 3 -t 1 -d 3 -db $bbCurveTop[4] $bbCurveTop[1] -da 0 1 0 -dp 0 0 0;
//updated to all for jaw to be under world Y axis(fish)
polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($bbCurveTop[4]-$bbCurveTop[1])/2.0) -dp 0 (($bbCurveTop[4]+$bbCurveTop[1])/2.0) 0 -da 0 1 0;
string $yOnBoundSel[]=`ls -sl`;
polySelectConstraint -m 3 -t 1 -d 3 -db 0 ((($bbCurveBottom[5]-$bbCurveBottom[2])/2.0)*1.001) -da 0 0 1 -dp 0 0 (($bbCurveBottom[5]+$bbCurveBottom[2])/2.0);
string $zOnBoundSelInv[]=`ls -sl`;
polySelectConstraint -m 0;
select $yOnBoundSel $zOnBoundSelInv;
select -d $outsideOuterBoundsVtxs;
string $onBoundsVtxs[]=`ls -sl -fl`;

select -cl;
for ($i=0;$i<size($onBoundsVtxs);$i++)
	{
	$pos=`xform -q -ws -t $onBoundsVtxs[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] samplerLocator;
	refresh;
	if (`getAttr samplerLocatorTop.ty`>0)
		select -add $onBoundsVtxs[$i];
	}

select -add $insideInnerBoundsVtxs;
select -d lipAreaJawOpenLayer;
sets -n jawArea;
sets -add FaceBuildingSets jawArea;
select -d $jawCurveVtxs $jawCurveMidVtxs;

if (size(`ls -sl`))
	{
	weightHammerVerts;
	copySkinWeights -ss -ds -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

select jawArea;
//asSmoothFlood Face_M JawJoint_M $numJawSmooths;
select JawOpenLayer JawCurve;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//fix the weighting just above upperLip
select lipAreaJawOpenLayer;
string $completedVtxs[]=`ls -sl -fl`;
//eval ("select "+`getAttr FaceFitLipOuter.upperSelection`);
eval ("select "+`asGetFaceFitSelection upperLipOuterCurve`);
$tempString=`ls -sl -fl`;
float $bb[]=`xform -q -bb`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	select -add `substitute $geometry $tempString[$i] JawOpenLayer`;
string $lipOutherVtxs[]=`ls -sl -fl`;
for ($i=0;$i<size($lipOutherVtxs);$i++)
	{
	$posA=`xform -q -ws -t $lipOutherVtxs[$i]`;
//	if ($posA[0]>0)
//		continue;
	select $lipOutherVtxs[$i];
	float $prevWeights[];
	float $onLipWeights[]=`skinPercent -ignoreBelow 0.001 -q -v JawOpenLayerSC`;
	select $lipOutherVtxs[$i];
	for ($y=0;$y<$vtxsFromLipToNose;$y++)
		{
		asWsPickWalk 0 1 0;
//		refresh;
		$tempString=`ls -sl -fl`;
		if (`sets -im lipAreaJawOpenLayer $tempString[0]`)
			continue;
		float $newWeight=$onLipWeights[1]-(($onLipWeights[1]/$vtxsFromLipToNose)*$y);
		skinPercent -tv JawJoint_M $newWeight JawOpenLayerSC;
		}
	}

if (!`objExists FaceFitLipMainLeft`)
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;


select jawArea;
select -d jawCurveVtxs;
currentTime 30;
asSmoothFlood Face_M JawJoint_M $numJawSmooths;

if (!`objExists FaceFitLipMainLeft`)
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

if (`objExists JawOpenLayerDeleteComponent`)
	setAttr JawOpenLayerDeleteComponent.nodeState 0;

delete samplerLocator JawCurveTopSampler JawCurveBottomSampler;

//remove all jaw weights, as the jawAre might have been reduced by adjustment of JawCurves
skinPercent -tv JawJoint_M 0 JawSC JawLayer;

//transfer to JawLayer mesh - from:LipDeform
select `asobjSetCast lipArea {} LipDeform`;
select -add `asobjSetCast lipArea {} JawLayer`;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//Hammer $lipFalloffAreaVtxs
select `asobjSetCast lipFalloffArea {} JawOpenLayer`;
$lipFalloffAreaVtxs=`ls -sl -fl`;
select $lipFalloffAreaVtxs;
if (size(`ls -sl`))
	weightHammerVerts;

//if teeth part of Main mesh
if (`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString JawOpenLayer`;
	skinPercent -tv JawJoint_M 1 JawOpenLayerSC `ls -sl`;
	}
//if tongue part of Main mesh
if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
	{
	eval ("select "+$tongue);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	select `asobjSetCast "" $tempString JawOpenLayer`;
	skinPercent -tv JawJoint_M 1 JawOpenLayerSC `ls -sl`;
	}

currentTime 0 ;
if (`objExists FaceFitLipMainLeft`)
	{
	select -r `asobjSetCast lipArea {} JawOpenLayer`;
	asInvertSelection;
	copySkinWeights -ss -ds -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
else
	copySkinWeights -ss JawOpenLayerSC -ds JawOpenLayerSC -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;

progressBar -e -ep $gMainProgressBar;
currentTime $currentTime;
select $sel;
}

global proc asWsPickWalk (int $x, int $y, int $z)
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "No selection provided to asWsPickWalk";
float $posA[]=`xform -q -ws -t $sel[0]`;
ConvertSelectionToEdges;
ConvertSelectionToVertices;
string $expandSel[]=`ls -sl -fl`;
float $dist,$maxWeight;
//float $minDist=9999;
for ($i=0;$i<size($expandSel);$i++)
	{
	if ($expandSel[$i]==$sel[0])
		continue;
	float $posB[]=`xform -q -ws -t $expandSel[$i]`;
	if ($x==1 && $posB[0]<$posA[0]) continue;
	if ($y==1 && $posB[1]<$posA[1]) continue;
	if ($z==1 && $posB[2]<$posA[2]) continue;
	if ($x==-1 && $posB[0]>$posA[0]) continue;
	if ($y==-1 && $posB[1]>$posA[1]) continue;
	if ($z==-1 && $posB[2]>$posA[2]) continue;

	$xDist=abs($posB[0]-$posA[0]);
	$yDist=abs($posB[1]-$posA[1]);
	$zDist=abs($posB[2]-$posA[2]);
	$xyzDist=$xDist+$yDist+$zDist;
	if (abs($x)) $weight=$xDist/$xyzDist;
	if (abs($y)) $weight=$yDist/$xyzDist;
	if (abs($z)) $weight=$zDist/$xyzDist;

	if ($weight>$maxWeight)
		{
		$maxWeight=$weight;
		select $expandSel[$i];
		}
	}
string $tempString[]=`ls -sl -fl`;
if (size($tempString)>1)
	select $tempString[0];
}

global proc asCurveOffsetMesh (string $curve, string $geometry ,float $offset)
{
float $spans=`getAttr ($curve+".spans")`;
float $startPos[]=`xform -q -ws -t ($curve+".cv[0]")`;
float $endPos[]=`xform -q -ws -t ($curve+".cv[99]")`;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 20 -d 3 -tol 0.01 $curve;
spaceLocator -n constraintLoc;
spaceLocator -n constraintLoc2;
parent constraintLoc2 constraintLoc;
setAttr constraintLoc2.tx $offset;
select $geometry constraintLoc;
geometryConstraint -weight 1;
select $geometry constraintLoc;
normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
for ($i=0;$i<23;$i++)
    {
    $posA=`xform -q -ws -t ($curve+".cv["+$i+"]")`;
    xform -ws -t $posA[0] $posA[1] $posA[2] constraintLoc;
    $posB=`xform -q -ws -t constraintLoc2`;
    xform -ws -t $posB[0] $posB[1] $posB[2] ($curve+".cv["+$i+"]");
    }
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 3 -tol 0.01 $curve;
delete constraintLoc;
xform -ws -t $startPos[0] $startPos[1] $startPos[2] ($curve+".cv[0]");
xform -ws -t $endPos[0] $endPos[1] $endPos[2] ($curve+".cv[99]");
}

global proc asFaceWrapDeformToFace ()
{
float $pos[];
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $shape;
string $tempString[];
//remove possible existing defomers first
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	DeleteHistory;
	}
for ($i=0;$i<size($sel);$i++)
	{
	select -r $sel[$i];
	select -add $geometry;
	$tempString=`doWrapArgList "6" { "1","0","1", "2", "0", "1", "1", "0" }`;
	rename $tempString[0] eyeBrowWrap;
	}
print ("// WrapDeformer created\n");
}

global proc asFaceWireDeformToFace ()
{
string $sel[]=`ls -sl`;
int $spans,$cv;
float $bb[],$scale[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster,$side;
string $curveCmd="curve -d 1";
string $tempString[],$eyeBrows[],$EyeBrowLayerGeos[];

for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	asFaceCopyWeightsToFace;
	$EyeBrowLayerGeos[$i]="EyeBrowLayer_"+`substitute ":" $sel[$i] "_"`;
	}

string $eyeBrowLocs[]={"EyeBrowInner","EyeBrowMid1","EyeBrowMid2","EyeBrowMid3","EyeBrowOuter"};
for ($y=0;$y<size($eyeBrowLocs);$y++)
	{
	if (!`objExists $eyeBrowLocs[$y]`)
		continue;
	$pos=`xform -q -ws -t $eyeBrowLocs[$y]`;
	$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
	}
if (!`objExists EyeBrowMainCurve`)
	{
	$tempString[0]=`evalEcho ($curveCmd)`;
	rename $tempString[0] EyeBrowMainCurve;
	}

if (!`objExists EyeBrowWire`)
	{
	createNode -n EyeBrowWire -p FaceDeformationSetups transform;
	createNode -n EyeBrowWireScaleOffset -p EyeBrowWire transform;
	createNode -n EyeBrowWireScale_R -p EyeBrowWireScaleOffset transform;
	createNode -n EyeBrowWireScale_L -p EyeBrowWireScaleOffset transform;
	$scale=`getAttr upperFaceOffset_M.s`;
	setAttr -type float3 EyeBrowWireScaleOffset.s $scale[0] $scale[0] $scale[0];
	scaleConstraint EyeBrowRegion_R EyeBrowWireScale_R;
	scaleConstraint EyeBrowRegion_L EyeBrowWireScale_L;
	parent EyeBrowMainCurve EyeBrowWire;
	}

$eyeBrows[size($eyeBrows)]="EyeBrowInner";
$spans=1;
if (`objExists EyeBrowMid1`) {$spans++;$eyeBrows[size($eyeBrows)]="EyeBrowMid1";}
if (`objExists EyeBrowMid2`) {$spans++;$eyeBrows[size($eyeBrows)]="EyeBrowMid2";}
if (`objExists EyeBrowMid3`) {$spans++;$eyeBrows[size($eyeBrows)]="EyeBrowMid3";}
$eyeBrows[size($eyeBrows)]="EyeBrowOuter";

for ($i=0;$i<size($EyeBrowLayerGeos);$i++)
	{
	$side="_R";
	$bb=`xform -q -ws -bb $EyeBrowLayerGeos[$i]`;
	if ((($bb[0]+$bb[3])/2.0)>0)
		$side="_L";

//	select $EyeBrowLayerGeos[$i];
//	DeleteHistory;

	if (`objExists ("EyeBrowWireCurve"+$side)`) delete ("EyeBrowWireCurve"+$side);
	duplicate -n ("EyeBrowWireCurve"+$side) EyeBrowMainCurve;
	if ($side=="_L")
		{
		setAttr EyeBrowWireCurve_L.sx -1;
		makeIdentity -a 1 -t 0 -r 0 -s 1 EyeBrowWireCurve_L;
		}

	rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spans -d 3 -tol 0.000393701 ("EyeBrowWireCurve"+$side);

	$tempString=`wire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w ("EyeBrowWireCurve"+$side) $EyeBrowLayerGeos[$i]`;
	$tempString[0]=`rename $tempString[0] ("EyeBrowWire"+$side)`;
	string $wireDeformer=$tempString[0];
//	connectAttr ("EyeBrowWireScale"+$side+".sx") ($wireDeformer+".scale[0]");

	//set dropoffDistance to the width of the geometry (5x to allow for scaling)
	$bb=`xform -q -ws -bb $EyeBrowLayerGeos[$i]`;
	setAttr ("EyeBrowWire"+$side+".dropoffDistance[0]") (($bb[3]-$bb[0])*5);

	for ($y=0;$y<size($eyeBrows);$y++)
		{
		$cv=$y;
		if ($y>0) $cv=$y+1;
		if ($y==size($eyeBrows)-1) $cv=$y+2;
		select -r ("EyeBrowWireCurve"+$side+".cv["+$cv+"]");
		$tempString=`newCluster " -envelope 1"`;
		rename $tempString[0] ($eyeBrows[$y]+"WireCluster"+$side);
		rename $tempString[1] ($eyeBrows[$y]+"WireClusterHandle"+$side);
		$tempString=`listConnections ($eyeBrows[$y]+"WireCluster"+$side+".message")`;
		rename $tempString[0] ($eyeBrows[$y]+"WireClusterSet"+$side);
		parent ($eyeBrows[$y]+"WireClusterHandle"+$side) EyeBrowWire;
		}
	sets -add ($eyeBrows[0]+"WireClusterSet"+$side) ("EyeBrowWireCurve"+$side+".cv[1]");
	sets -add ($eyeBrows[size($eyeBrows)-1]+"WireClusterSet"+$side) ("EyeBrowWireCurve"+$side+".cv["+`size($eyeBrows)`+"]");

	for ($y=0;$y<size($eyeBrows);$y++)
		{
		createNode -n ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side) plusMinusAverage;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".operation") 2;
		connectAttr ($eyeBrows[$y]+"Joint"+$side+".t") ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0]");
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[1].input3Dx") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0].input3Dx")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[1].input3Dy") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0].input3Dy")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[1].input3Dz") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".input3D[0].input3Dz")`;
		connectAttr ($eyeBrows[$y]+"WirePlusMinusAverageT"+$side+".output3D") ($eyeBrows[$y]+"WireClusterHandle"+$side+".t");

		createNode -n ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side) plusMinusAverage;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".operation") 2;
		connectAttr ($eyeBrows[$y]+"Joint"+$side+".r") ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0]");
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[1].input3Dx") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0].input3Dx")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[1].input3Dy") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0].input3Dy")`;
		setAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[1].input3Dz") `getAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".input3D[0].input3Dz")`;
		connectAttr ($eyeBrows[$y]+"WirePlusMinusAverageR"+$side+".output3D") ($eyeBrows[$y]+"WireClusterHandle"+$side+".r");
		}
	}

print "// Wire deformer added.\n";
select $EyeBrowLayerGeos;
}

global proc int asQuietRemoveUnusedInfluences ()
{
	string $sel[] = `ls -sl`;
	if (size($sel) == 0) {
		error( (uiRes("m_removeUnusedInfluences.kNoSkinsSel")));
	}
	int $counter = 0;
	int $totalRemoveCount = 0;
	for ($selobj in $sel) {
		// find the skinCluster on the selected object
		//
		string $skinCluster = findRelatedSkinCluster($selobj);
		if ($skinCluster == "") {
			continue;
		}
		$counter++;
		int $removeCount = removeUnusedForSkin($skinCluster,0);//int $verbose=0

		if (0 == $removeCount) {
			string $infoFormat = (uiRes("m_removeUnusedInfluences.kAllUnusedAlreadyRemoved"));
			string $infoStr = `format -stringArg $selobj $infoFormat`;
//			print $infoStr;
		} else {
			string $infoFormat = (uiRes("m_removeUnusedInfluences.kRemoveUnused"));
			string $infoStr = `format -stringArg $removeCount -stringArg $selobj $infoFormat`;
//			print $infoStr;
		}
		$totalRemoveCount += $removeCount;
	}
	if (0 == $counter) {
		error( (uiRes("m_removeUnusedInfluences.kNoSkinsSelected")));
	}
	return $totalRemoveCount;
}

global proc asFaceCopyWeightsToFace ()
{
int $isRebuilding=`objExists prefix_FaceGroup`;
string $name;
string $sel[]=`ls -sl`;
string $eyeBrowJoints[]={"EyeBrowInnerJoint_R","EyeBrowOuterJoint_R","EyeBrowMid1Joint_R","EyeBrowMid2Joint_R","EyeBrowMid3Joint_R",
												 "EyeBrowInnerJoint_L","EyeBrowOuterJoint_L","EyeBrowMid1Joint_L","EyeBrowMid2Joint_L","EyeBrowMid3Joint_L",
												 "EyeBrowMiddleJoint_M"};
string $layers[]={"EyeBrow","Regions","Squint","EyeLid","CheekRaiser"};

for ($i=0;$i<size($sel);$i++)
	{
	$name=`substitute ":" $sel[$i] "_"`;
	for ($y=0;$y<size($layers);$y++)
		{
		if ($isRebuilding && !`objExists ("prefix_"+$layers[$y]+"Layer_"+$name)`)
			continue;
		duplicate -n ($layers[$y]+"Layer_"+$name) $sel[$i];
		parent ($layers[$y]+"Layer_"+$name) DeformationLayers;
		sets -e -forceElement initialShadingGroup ($layers[$y]+"Layer_"+$name);
		$tempString=`listRelatives -s ($layers[$y]+"Layer_"+$name)`;
		for ($z=0;$z<size($tempString);$z++)
			if (`getAttr ($tempString[$z]+".intermediateObject")`)
				delete $tempString[$z];

		blendShape -e -w `getAttr -s ("asFaceBS_"+$name+".w")` 1 -tc 0 -t $sel[$i] `getAttr -s ("asFaceBS_"+$name+".w")` ($layers[$y]+"Layer_"+$name) 1 ("asFaceBS_"+$name);

		setAttr ($layers[$y]+"Layer_"+$name+".v") 0;
	
		if (`objExists ($layers[$y]+"SC")`)
			{
			select `listConnections -s 1 -d 0 -type joint ($layers[$y]+"SC.matrix")`;
			select -add ($layers[$y]+"Layer_"+$name);
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($layers[$y]+"SC_"+$name);
			select ($layers[$y]+"Layer") ($layers[$y]+"Layer_"+$name);
			copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation name;
			select ($layers[$y]+"Layer_"+$name);
			asQuietRemoveUnusedInfluences;
			}

		if ($layers[$y]=="Squint")
			{
			sets -add SquintLayerFFDSet_R ("SquintLayer_"+$name);
			sets -add SquintLayerFFDSet_L ("SquintLayer_"+$name);
			}

		if (!`attributeExists skinWeightedToFace $sel[$i]`)
			addAttr -k 0 -ln skinWeightedToFace -at bool -dv true $sel[$i];
		}
	}

select $sel;
print "// Weights copied.\n";
}

global proc asFaceCopyWeightsToFaceAllLayers ()
{
int $alreadyInLayer[];
string $name,$skinCluster,$dialog,$sourceSkinCluster,$destSkinCluster;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $sel[]=`ls -sl`;
string $tempString[]=`listRelatives -c DeformationLayers`;
string $layers[],$infJoints[];

for ($y=0;$y<size($tempString);$y++)
	{
	if (!`gmatch $tempString[$y] "*Layer"` || $tempString[$y]=="templateLayer")
		continue;
	$layers[size($layers)]=$tempString[$y];
	}

for ($i=0;$i<size($sel);$i++)
	{
	$name=`substitute ":" $sel[$i] "_"`;

	//First. Everything must have skinCluster
	$tempString=`listHistory $sel[$i]`;
	$skinCluster="";
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		{
		if ($dialog!="Create New SkinCluster")
			$dialog=`confirmDialog -t "Confirm"
			-m "No SkinCluster found on this geometry"
			-b "Create New SkinCluster" -db "Create New SkinCluster"
			-b "Cancel" -ds "Cancel"`;
		if ($dialog!="Create New SkinCluster")
			return;
		select $sel[$i] $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		rename $tempString[0] ($name+"SC");
		$skinCluster=$name+"SC";
		}


	for ($y=0;$y<size($layers);$y++)
		{
		if (`objExists ($layers[$y]+"_"+$name)`)
			{
			$alreadyInLayer[$y]=1;
			continue;
			}
//			error ("Object has already been attacheded, since this object already exists:\""+$layers[$y]+"_"+$name+"\"");
		duplicate -n ($layers[$y]+"_"+$name) $sel[$i];
		parent ($layers[$y]+"_"+$name) DeformationLayers;
		sets -e -forceElement initialShadingGroup ($layers[$y]+"_"+$name);
		$tempString=`listRelatives -s ($layers[$y]+"_"+$name)`;
		for ($z=0;$z<size($tempString);$z++)
			if (`getAttr ($tempString[$z]+".intermediateObject")`)
				delete $tempString[$z];

		select -add ($layers[$y]+"_"+$name);
		select -add $sel[$i];
		if (!`objExists ("asFaceBS_"+$name)`)
			blendShape -n ("asFaceBS_"+$name) -frontOfChain -w 0 1;
		else
			{
			blendShape -e -tc 0 -t $sel[$i] `getAttr -s ("asFaceBS_"+$name+".w")` ($layers[$y]+"_"+$name) 1 ("asFaceBS_"+$name);
			setAttr ("asFaceBS_"+$name+"."+$layers[$y]+"_"+$name) 1;
			}

		//newSkinCluster & CopySkinWeights
		$sourceSkinCluster=`substitute "Layer" $layers[$y] "SC"`;
		$destSkinCluster=$sourceSkinCluster+"_"+$name;
		if (!`objExists $sourceSkinCluster`)
			continue;
		$infJoints=`listConnections ($sourceSkinCluster+".matrix")`;
		if (!size($infJoints))
			continue;
		if (!`objExists $destSkinCluster`)
			{
			select $infJoints;
			select -add ($layers[$y]+"_"+$name);
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] $destSkinCluster;
			}
		select $layers[$y] ($layers[$y]+"_"+$name);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}

	sets -add SquintLayerFFDSet_R ("SquintLayer_"+$name);
	sets -add SquintLayerFFDSet_L ("SquintLayer_"+$name);
	if (!`attributeExists skinWeightedToFace $sel[$i]`)
		addAttr -k 0 -ln skinWeightedToFace -at bool -dv true $sel[$i];//so we get BS targets when using EditBlendShape tools
	}

select $sel;
print "// Added to all SkinLayers.\n";
}

global proc asFaceSwapControlsToSpheres ()
{
int $keepOffset=`checkBox -q -v asFaceSwapControlsKeepOffsetCheckBox`;
float $mag;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $posA[],$posB[];
string $sel[]=`ls -sl`;
string $aCtrls[]=`listConnections ctrlBox.ACtrlVis`;
string $bCtrls[]=`listConnections ctrlBox.BCtrlVis`;
string $cCtrls[]=`listConnections ctrlBox.CCtrlVis`;
string $onFaceCtrls[]=`stringArrayCatenate $aCtrls $bCtrls`;
$onFaceCtrls=`stringArrayCatenate $onFaceCtrls $cCtrls`;
string $tempString[];

asFaceEnsureShaders;

for ($i=0;$i<size($onFaceCtrls);$i++)
	{
	if (`gmatch $onFaceCtrls[$i] "SmilePull_*"`)
		continue;
	$tempString=`listRelatives -s $onFaceCtrls[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`objectType $tempString[0]`!="nurbsCurve")
		continue;
	$posA=`xform -q -ws -t ($onFaceCtrls[$i]+".cv[1]")`;
	$posB=`xform -q -ws -t ($onFaceCtrls[$i]+".cv[5]")`;
	$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
	$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r (($mag*5)/$faceFitScale) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
	rename $tempString[0] ($onFaceCtrls[$i]+"Sphere");
	parent -add -s ($onFaceCtrls[$i]+"SphereShape") $onFaceCtrls[$i];
	delete ($onFaceCtrls[$i]+"Shape");
	rename ($onFaceCtrls[$i]+"SphereShape") ($onFaceCtrls[$i]+"Shape");
	delete ($onFaceCtrls[$i]+"Sphere");

	if (`stringArrayCount $onFaceCtrls[$i] $aCtrls`) sets -e -forceElement asFaceGreenSG ($onFaceCtrls[$i]+"Shape");
	if (`stringArrayCount $onFaceCtrls[$i] $bCtrls`) sets -e -forceElement asFaceRedSG ($onFaceCtrls[$i]+"Shape");
	if (`stringArrayCount $onFaceCtrls[$i] $cCtrls`) sets -e -forceElement asFaceBlueSG ($onFaceCtrls[$i]+"Shape");

	if (!$keepOffset)
		continue;
	$posB=`xform -q -ws -t ($onFaceCtrls[$i]+".cv[0][0]")`;
	$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
	move -r 0 0 $mag ($onFaceCtrls[$i]+".cv[0:99][0:99]");
	}
select $sel;
}

global proc asFaceDetachControllers ()
{
string $layers[],$historyNodes[];
string $skinCluster;

$layers=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($layers);$i++)
	{
	$historyNodes=`listHistory $layers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$skinCluster=$historyNodes[$y];
			setAttr ($skinCluster+".envelope") 0;
			break;
			}
	}
print "// Controllers Detached.\n";
}

global proc asFaceAttachControllers ()
{
int $b;
float $pos[],$pos2[],$rot[];
string $tempString[],$layers[],$historyNodes[],$controls[],$tempString[];
string $skinCluster,$offsetNode,$jointOffsetNode;

//`move` offset to OffsetNode
$controls=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	clear $pos;
	clear $rot;
	if (`getAttr -k ($controls[$i]+".tx")`)
		{
		$pos=`getAttr ($controls[$i]+".t")`;
		$pos2=`xform -q -ws -t $controls[$i]`;
		}
	if (`getAttr -k ($controls[$i]+".rx")`)
		$rot=`getAttr ($controls[$i]+".r")`;
	if (!($pos[0]!=0 || $pos[1]!=0 || $pos[2]!=0 || $rot[0]!=0 || $rot[1]!=0 || $rot[2]!=0))
		continue;
	$b=1;
	if (`gmatch $controls[$i] "*_R"`)
		$b=-1;

	tokenize $controls[$i] "_" $tempString;
	$offsetNode=$tempString[0]+"Offset_"+$tempString[1];
	$jointOffsetNode=$tempString[0]+"JointOffset_"+$tempString[1];
	xform -ws -t $pos2[0] $pos2[1] $pos2[2] $offsetNode;
	setAttr ($offsetNode+".r") -type float3 $rot[0] ($rot[1]*$b) ($rot[2]*$b);

	xform -ws -ro  $rot[0] ($rot[1]*$b) ($rot[2]*$b) $jointOffsetNode;

	setAttr ($controls[$i]+".r") -type float3 0 0 0;
	}

//freezeSkinCluster 
$layers=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($layers);$i++)
	{
	$historyNodes=`listHistory $layers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$skinCluster=$historyNodes[$y];
			freezeSkinCluster $skinCluster;
			setAttr ($skinCluster+".envelope") 1;
			break;
			}
	}

dgdirty -a;
print "// Controllers Attached.\n";
}

global proc asFaceEyeBallBuild ()
{
int $innerVtxsIsA,$IrisLoopNextToPupilLoop;
int $addIrisAttr=`checkBox -q -v asFaceIrisCheckBox`;
float $bb[],$bbA[],$bbB[],$pos[],$pupilCenterPos[],$irisCenterPos[],$temp[];
float $eyeRadius,$pupilRadius,$vtxRadius,$irisRadius,$wouldBeRadius,$factor,$maxX,$maxY;
string $xyz[]={"x","y","z"};
//string $xyz[]={"y","z"};
string $vtxs[],$pupilVtxs[],$pupilVtxs[],$tempString[],$tempString2[],$sideAVtxs[],$sideBVtxs[];
string $innerVtxs[],$outerVtxs[],$backHalfVtxs[],$irisToBackHalfVtxs[];
string $pupilText,$irisText,$skinCluster,$maxXVtx,$maxYVtx,$pupilIris,$pupilIrisLowerCase,$eyeGeo,$setAttrCmdExtra,$eyeCtrl,$buildPose;

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	
	$eyeCtrl="ctrlEye"+$side;
	if (!`objExists $eyeCtrl`)
		$eyeCtrl="FKEye"+$side;

	if (`attributeExists pupil $eyeCtrl`)
		error "Pupil attribute already added";

	$pupilText=`textField -q -tx ("asFacePupil"+$side+"TextField")`;
	$irisText=`textField -q -tx ("asFaceIris"+$side+"TextField")`;
	if ($pupilText=="") {warning ("Pupil"+$side+" EdgeLoop not defined");continue;}
	if ($irisText=="") {warning ("Iris"+$side+" EdgeLoop not defined");continue;}

	eval ("select "+$pupilText);
	ConvertSelectionToVertices;
	$pupilVtxs=`ls -sl -fl`;
	$bb=`xform -q -bb`;
	$pupilCenterPos={(($bb[3]+$bb[0])/2.0),(($bb[4]+$bb[1])/2.0),(($bb[5]+$bb[2])/2.0)};
	$pupilRadius=($bb[4]-$bb[1])/2.0;

	eval ("select "+$irisText);
	ConvertSelectionToVertices;
	$irisVtxs=`ls -sl -fl`;
	$bb=`xform -q -bb`;
	$irisCenterPos={(($bb[3]+$bb[0])/2.0),(($bb[4]+$bb[1])/2.0),(($bb[5]+$bb[2])/2.0)};
	$irisRadius=($bb[4]-$bb[1])/2.0;

	//find $eyeGeo & $eyeRadius
	tokenize $pupilVtxs[0] "[.]" $tempString;
	$eyeGeo=$tempString[0];
	$bb=`xform -q -ws -bb $eyeGeo`;
	$eyeRadius=($bb[4]-$bb[1])/2.0;

	//find $backHalfVtxs
	select $eyeGeo;
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	createNode -n tempTransform -p ("Eye"+$side) transform;
	for ($i=0;$i<size($tempString);$i++)
		{
		$pos=`xform -q -ws -t $tempString[$i]`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempTransform;
		if (`getAttr tempTransform.tz`<0)
			$backHalfVtxs[size($backHalfVtxs)]=$tempString[$i];
		}
	delete tempTransform;

	$tempString=`listHistory $pupilVtxs[0]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]`=="skinCluster")
			if ($tempString[$y]!="squashIKSC")
				$skinCluster=$tempString[$y];

	for ($a=1;$a>-2;$a=$a-2)
		{
		if ($a==1)
			{$pupilIris="Pupil";$pupilIrisLowerCase="pupil";$pos=$pupilCenterPos;$vtxs=$pupilVtxs;}
		else
			{$pupilIris="Iris";$pupilIrisLowerCase="iris";$pos=$irisCenterPos;$vtxs=$irisVtxs;}
		
		//Create Joint
		select ("Eye"+$side);
		joint -n ($pupilIris+$side);
		setAttr ($pupilIris+$side+".segmentScaleCompensate") 0;
		xform -ws -t $pos[0] $pos[1] $pos[2] ($pupilIris+$side);

		//Orient to Loop-Plane
		$maxX=$maxY=-9999;
		for ($i=0;$i<size($vtxs);$i++)
			{
			$pos=`xform -q -ws -t $vtxs[$i]`;
			if ($pos[0]>$maxX) {$maxX=$pos[0];$maxXVtx=$vtxs[$i];}
			if ($pos[1]>$maxY) {$maxY=$pos[1];$maxYVtx=$vtxs[$i];}
			}
		createNode -n tempTransform2 -p ("Eye"+$side) transform;
		$pos=`xform -q -ws -t $maxXVtx`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempTransform2;
		createNode -n tempTransform3 -p ("Eye"+$side) transform;
		$pos=`xform -q -ws -t $maxYVtx`;
		xform -ws -t $pos[0] $pos[1] $pos[2] tempTransform3;
		delete `aimConstraint -aimVector 	0 0 1 -upVector 0 -1 0 -worldUpType object -worldUpObject tempTransform3 tempTransform2 ($pupilIris+$side)`;
		delete tempTransform2 tempTransform3;

		//AddAttr
		if ($a==1) //Add Iris attr first, so Pupil attr appear last
			{
			addAttr -k $addIrisAttr -ln iris -at double -smn -10 -hsn 1 -smx 10 -hsx 1 -dv 0 $eyeCtrl;
			addAttr -k 1 -ln pupil -at double -smn -10 -hsn 1 -smx 10 -hsx 1 -dv 0 $eyeCtrl;
			}
		addAttr -k 0 -ln ($pupilIrisLowerCase+"Scale") -at double -dv 1 $eyeCtrl;
		for ($z=0;$z<size($xyz);$z++)
			connectAttr ($eyeCtrl+"."+$pupilIrisLowerCase+"Scale") ($pupilIris+$side+".s"+$xyz[$z]);

		skinCluster -e -ai ($pupilIris+$side) -lw false -wt 0 $skinCluster;
		skinPercent -tv ($pupilIris+$side) 1 $skinCluster $vtxs;
		}

	select  $pupilVtxs[0];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $pupilVtxs;
	$tempString=`ls -sl -fl`;

	//Grow A
	select $tempString[0];
	for ($i=0;$i<99;$i++)
		{
		if (`stringArrayCount $tempString[0] $irisVtxs`) // IrisLoops is next to PupilLoop
			{$IrisLoopNextToPupilLoop=1;select $irisVtxs;break;}
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $pupilVtxs $irisVtxs;
		if (size(`ls -sl -fl`)==size($tempString2))//same count as previously
			break;
		$tempString2=`ls -sl -fl`;
		}
	$sideAVtxs=`ls -sl -fl`;

	//Grow B
	select $tempString[1];
	for ($i=0;$i<99;$i++)
		{
		if (`stringArrayCount $tempString[1] $irisVtxs`) // IrisLoops is next to PupilLoop
			{$IrisLoopNextToPupilLoop=1;select $irisVtxs;break;}
		polySelectConstraint -pp 1 -t 0x0001;//GrowPolygonSelectionRegion(without print-out in Maya2018);
		select -d $pupilVtxs $irisVtxs;
		if (size(`ls -sl -fl`)==size($tempString2))//same count as previously
			break;
		$tempString2=`ls -sl -fl`;
		}
	$sideBVtxs=`ls -sl -fl`;

	//Determine A/B is Inner/Outer
	$bbA=`xform -q -bb $sideAVtxs`;
	$bbB=`xform -q -bb $sideBVtxs`;
	$xyzA=($bbA[3]-$bbA[0]) + ($bbA[4]-$bbA[1]) + ($bbA[5]-$bbA[2]);
	$xyzB=($bbB[3]-$bbB[0]) + ($bbB[4]-$bbB[1]) + ($bbB[5]-$bbB[2]);
	if ($xyzA<$xyzB)
		{
		$innerVtxs=$sideAVtxs;
		$outerVtxs=$sideBVtxs;
		}
	else
		{
		$innerVtxs=$sideBVtxs;
		$outerVtxs=$sideAVtxs;
		}

	//Weighting Pupil-to-Iris-area (flatten eye, for correct radius-fraction calculations)
	skinPercent -tv ("Pupil"+$side) 1 $skinCluster $innerVtxs;
	skinPercent -tv ("Iris"+$side) 1 $skinCluster $outerVtxs;
	select $innerVtxs $outerVtxs;
	$tempString=`lattice -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
	rename $tempString[0] EyeFlattenFFD;
	rename $tempString[1] EyeFlattenLattice;
	rename $tempString[2] EyeFlattenBase;
	setAttr EyeFlattenFFD.outsideLattice 1;
	parent EyeFlattenLattice EyeFlattenBase	 ("Iris"+$side);
	setAttr -type float3 EyeFlattenLattice.r 0 0 0;
	setAttr -type float3 EyeFlattenBase.r 0 0 0;
	setAttr EyeFlattenLattice.sx 0;
	xform -ws -t $pupilCenterPos[0] $pupilCenterPos[1] $pupilCenterPos[2] EyeFlattenLattice;
	for ($i=0;$i<size($outerVtxs);$i++)
		{
		if ($IrisLoopNextToPupilLoop)
			break;
		$pos=`xform -q -ws -t $outerVtxs[$i]`;
		$vtxRadius=`mag <<($pos[0]-$pupilCenterPos[0]),($pos[1]-$pupilCenterPos[1]),($pos[2]-$pupilCenterPos[2])>>`;
		$factor=1-(smoothstep(0,$irisRadius,$vtxRadius));
		$factor=$vtxRadius/$irisRadius;
		$factor=linstep ($pupilRadius,$irisRadius,$vtxRadius);
		$factor=(($irisRadius/$pupilRadius)*$vtxRadius);
		$wouldBeRadius=($irisRadius/$pupilRadius)*$vtxRadius;
		$factor=linstep ($vtxRadius,$wouldBeRadius,$irisRadius);
		skinPercent -tv ("Pupil"+$side) $factor $skinCluster $outerVtxs[$i];
		}
	delete EyeFlattenLattice;

	//Weighting Iris-to-backHalf-area (flatten eye, for correct radius-fraction calculations)
	tokenize $pupilVtxs[0] "[.]" $tempString;
	select $tempString[0];
	ConvertSelectionToVertices;
	select -d $innerVtxs $outerVtxs $pupilVtxs $irisVtxs $backHalfVtxs;
	$irisToBackHalfVtxs=`ls -sl -fl`;
	skinPercent -tv ("Eye"+$side) 1 $skinCluster $irisToBackHalfVtxs;
	select $irisToBackHalfVtxs;
	$tempString=`lattice -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
	rename $tempString[0] EyeFlattenFFD;
	rename $tempString[1] EyeFlattenLattice;
	rename $tempString[2] EyeFlattenBase;
	setAttr EyeFlattenFFD.outsideLattice 1;
	parent EyeFlattenLattice EyeFlattenBase	 ("Iris"+$side);
	setAttr -type float3 EyeFlattenLattice.r 0 0 0;
	setAttr -type float3 EyeFlattenBase.r 0 0 0;
	setAttr EyeFlattenLattice.sx 0;
	xform -ws -t $irisCenterPos[0] $irisCenterPos[1] $irisCenterPos[2] EyeFlattenLattice;
	for ($i=0;$i<size($irisToBackHalfVtxs);$i++)
		{
//		if ($IrisLoopNextToPupilLoop)
//			break;
		$pos=`xform -q -ws -t $irisToBackHalfVtxs[$i]`;
		$vtxRadius=`mag <<($pos[0]-$irisCenterPos[0]),($pos[1]-$irisCenterPos[1]),($pos[2]-$irisCenterPos[2])>>`;
		$factor=1-(smoothstep(0,$eyeRadius,$vtxRadius));
		$factor=$vtxRadius/$eyeRadius;
		$factor=linstep ($irisRadius,$eyeRadius,$vtxRadius);
		$factor=(($eyeRadius/$irisRadius)*$vtxRadius);
		$wouldBeRadius=($eyeRadius/$irisRadius)*$vtxRadius;
		$factor=linstep ($vtxRadius,$wouldBeRadius,$eyeRadius);
		skinPercent -tv ("Iris"+$side) $factor $skinCluster $irisToBackHalfVtxs[$i];
		}
	//not sure why below line was commented out, but tuna seem to need it.
	skinPercent -normalize on $skinCluster $eyeGeo;
	delete EyeFlattenLattice;

	setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 1 -cd ($eyeCtrl+".pupil") ($eyeCtrl+".pupilScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v 1 -cd ($eyeCtrl+".iris") ($eyeCtrl+".irisScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v ($irisRadius/$pupilRadius) -cd ($eyeCtrl+".pupil") ($eyeCtrl+".pupilScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v ($eyeRadius/$irisRadius) -cd ($eyeCtrl+".iris") ($eyeCtrl+".irisScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv -10 -v 0 -cd ($eyeCtrl+".pupil") ($eyeCtrl+".pupilScale");
	setDrivenKeyframe -itt "linear" -ott "linear" -dv -10 -v ($pupilRadius/$irisRadius) -cd ($eyeCtrl+".iris") ($eyeCtrl+".irisScale");

	for ($a=1;$a>-2;$a=$a-2)
		{
		if ($a==1)
			{$pupilIris="Pupil";$pupilIrisLowerCase="pupil";$vtxs=$pupilVtxs;}
		else
			{$pupilIris="Iris";$pupilIrisLowerCase="iris";$vtxs=$irisVtxs;}

		if ($a==-1 && !$addIrisAttr)
			continue;

		//pushback as grows with Lattice
		if ($a==1)  select $irisVtxs;
		if ($a==-1) select $eyeGeo;
		$tempString=`lattice -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
		rename $tempString[0] ($pupilIris+"Ffd"+$side);
		rename $tempString[1] ($pupilIris+"FfdLattice"+$side);
		rename $tempString[2] ($pupilIris+"FfdBase"+$side);
		$tempString=`listConnections ($pupilIris+"Ffd"+$side+".message")`;
		rename $tempString[0] ($pupilIris+"FfdSet"+$side);
		setAttr -l 1 ($pupilIris+"FfdLattice"+$side+".v") 0;
		setAttr -l 1 ($pupilIris+"FfdBase"+$side+".v") 0;
		if (`objExists squashFfd`)
			reorderDeformers squashFfd ($pupilIris+"Ffd"+$side) $eyeGeo;
		if ($a==1)  sets -add ($pupilIris+"FfdSet"+$side) $vtxs $innerVtxs $outerVtxs;
		if ($a==-1) sets -remove ($pupilIris+"FfdSet"+$side) $backHalfVtxs;
		setAttr ($pupilIris+"Ffd"+$side+".outsideLattice") 1;
		parent ($pupilIris+"FfdLattice"+$side) ($pupilIris+"FfdBase"+$side) ("Eye"+$side);
		asAlign ($pupilIris+"FfdLattice"+$side) ("Iris"+$side) 0 1 0 0;
		asAlign ($pupilIris+"FfdBase"+$side) ("Iris"+$side) 0 1 0 0;
		rotate -r -os 0 90 0 ($pupilIris+"FfdLattice"+$side);
		rotate -r -os 0 90 0 ($pupilIris+"FfdBase"+$side);
		if ($a==-1)
			{
			setAttr ($pupilIris+"FfdLattice"+$side+".tx") 0;
			setAttr ($pupilIris+"FfdBase"+$side+".tx") 0;
			}
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v `getAttr ($pupilIris+"FfdLattice"+$side+".sz")` -cd ($eyeCtrl+"."+$pupilIrisLowerCase) ($pupilIris+"FfdLattice"+$side+".sz");
		keyTangent -index 0 -inTangentType flat -outTangentType flat ($pupilIris+"FfdLattice"+$side+"_scaleZ");
		setDrivenKeyframe -itt "linear" -ott "linear" -dv 10 -v 0 -cd ($eyeCtrl+"."+$pupilIrisLowerCase) ($pupilIris+"FfdLattice"+$side+".sz");
		setDrivenKeyframe -itt "linear" -ott "linear" -dv -10 -v (`getAttr ($pupilIris+"FfdLattice"+$side+".sz")`*1) -cd ($eyeCtrl+"."+$pupilIrisLowerCase) ($pupilIris+"FfdLattice"+$side+".sz");

		$buildPose="faceBuildPose";
		if (!`objExists $buildPose`)
			$buildPose="buildPose";
		$setAttrCmdExtra="setAttr "+$eyeCtrl+"."+$pupilIrisLowerCase+" 0;";
		setAttr -type "string" ($buildPose+".udAttr") (`getAttr ($buildPose+".udAttr")`+$setAttrCmdExtra);
		}
	}
if (`objExists ctrlEye_R`)
	select ctrlEye_R ctrlEye_L;
else
	select FKEye_R FKEye_L;
print "// EyeBall build complete.\n";
}

global proc asFaceEditEyeBallSDK ()
{
string $sdkObjs[]={"Pupil_R","Pupil_L","IrisFfdLattice_R","IrisFfdLattice_L"};
select -cl;
for ($i=0;$i<size($sdkObjs);$i++)
	if (`objExists $sdkObjs[$i]`)
		select -add $sdkObjs[$i];
GraphEditor;
}

global proc asFaceAttachEyeLashes ()
{
string $sel[]=`ls -sl`;
if (size($sel)==0)
	error "Nothing selected";
int $modifier=`getModifiers`;
int $numLid,$haveSkinCluster;
float $weight;
float $upperCurveChkSumBefore_R,$lowerCurveChkSumBefore_R,$upperCurveChkSumAfter_R,$lowerCurveChkSumAfter_R;
float $upperCurveChkSumBefore_L,$lowerCurveChkSumBefore_L,$upperCurveChkSumAfter_L,$lowerCurveChkSumAfter_L;
float $pos[],$bb[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster,$side,$upperLower,$name;
string $tempString[],$historyNodes[],$eyeLashTargets[],$deleteObjs[];
//string $targets[]=`listAttr -m asFaceBS.weight`;

//MayaCrash when looping and duplicating
if (size($sel)>1)
	error "// Select only 1 EyeLash object at the time.\n";

//delete existing
for ($i=0;$i<size($sel);$i++)
	{
	$name=`substitute ":" $sel[$i] "_"`;

	$deleteObjs={"asFaceBS_"+$name, "EyeLidLayer_"+$name, "CheekRaiserLayer_"+$name, "RegionsLayer_"+$name, "UpMidLoLayer_"+$name};
	for ($y=0;$y<size($deleteObjs);$y++)
		if (`objExists $deleteObjs[$y]`) delete $deleteObjs[$y];
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1) $side="_R"; else $side="_L";
	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";

		for ($y=1;$y<99;$y++)
			{
			if (`objExists ($upperLower+"LidMain"+$y+$side)`)
				$numLid=$y;
			else
				break;
			}

		polyPlane -n ($upperLower+"EyeLidCage"+$side) -w 1 -h 1 -sx ($numLid-1) -sy 1 -ax 0 1 0 -cuv 2 -ch 1;
		for ($y=1;$y<$numLid+1;$y++)
			{
			$pos=`xform -q -ws -t ($upperLower+"LidMain"+$y+$side)`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			xform -ws -t $pos[0] $pos[1] $pos[2] ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			$pos=`xform -q -ws -t FitEyeBall`;
			scale -r -p ($pos[0]*$b) $pos[1] $pos[2] 4 4 4 ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			}
		select ($upperLower+"EyeLidCage"+$side);
		for ($y=1;$y<$numLid+1;$y++)
			select -add ($upperLower+"LidMain"+$y+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($upperLower+"EyeLidCageSC"+$side);
		select EyeLidLayer ($upperLower+"EyeLidCage"+$side);
		copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		
		for ($y=1;$y<$numLid+1;$y++)
			{
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1)+"]");
			artAttrSkinWeightCopy;
			select ($upperLower+"EyeLidCage"+$side+".vtx["+($y-1+$numLid)+"]");
			artAttrSkinWeightPaste;
			}
		}
	}

select upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;
for ($i=0;$i<size($sel);$i++)
	{
	$historyNodes=`listHistory $sel[$i]`;
	$haveSkinCluster=0;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if (!$haveSkinCluster)
		{
		select $headJoint $sel[$i];
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		}

	$name=`substitute ":" $sel[$i] "_"`;
	duplicate -n ("EyeLidLayer_"+$name) $sel[$i];
	parent ("EyeLidLayer_"+$name) DeformationLayers;
	sets -e -forceElement initialShadingGroup ("EyeLidLayer_"+$name);
	$tempString=`listRelatives -s ("EyeLidLayer_"+$name)`;
	for ($y=0;$y<size($tempString);$y++)
		if (`getAttr ($tempString[$y]+".intermediateObject")`)
			delete $tempString[$y];
	duplicate -n ("CheekRaiserLayer_"+$name) ("EyeLidLayer_"+$name);
	duplicate -n ("RegionsLayer_"+$name) ("EyeLidLayer_"+$name);
	duplicate -n ("UpMidLoLayer_"+$name) ("EyeLidLayer_"+$name);
	duplicate -n ("SquintLayer_"+$name) ("EyeLidLayer_"+$name);
	select ("EyeLidLayer_"+$name) ("CheekRaiserLayer_"+$name)  ("RegionsLayer_"+$name) ("UpMidLoLayer_"+$name) ("SquintLayer_"+$name) $sel[$i];
	if (`objExists ("asFaceBS_"+$name)`)
		{
		blendShape -e -tc 0 -t $sel[$i] `getAttr -s ("asFaceBS_"+$name+".w")` ("EyeLidLayer_"+$name) 1 ("asFaceBS_"+$name);
		setAttr ("asFaceBS_"+$name+".EyeLidLayer_"+$name) 1;
		}
	else
		blendShape -n ("asFaceBS_"+$name) -frontOfChain -w 0 1 -w 1 1 -w 2 1 -w 3 1 -w 4 1;

	setAttr ("EyeLidLayer_"+$name+".v") 0;
	setAttr ("CheekRaiserLayer_"+$name+".v") 0;
	setAttr ("RegionsLayer_"+$name+".v") 0;
	setAttr ("UpMidLoLayer_"+$name+".v") 0;
	setAttr ("SquintLayer_"+$name+".v") 0;
	select ("EyeLidLayer_"+$name);

	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R"; else $side="_L";
		for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
			{
			if ($upperLowerFactor==1) $upperLower="upper";
			else $upperLower="lower";

			for ($y=1;$y<99;$y++)
				{
				if (`objExists ($upperLower+"LidMain"+$y+$side)`)
					$numLid=$y;
				else
					break;
				}

			for ($y=1;$y<$numLid+1;$y++)
				select -add ($upperLower+"LidMain"+$y+$side);
			}
		}

	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	$skinCluster=`rename $tempString[0] ($sel[$i]+"EyeLashSC")`;

	$bb=`xform -q -ws -bb $sel[$i]`;

	//CheekRaiserLayer
	select Face_M;
	if ((($bb[0]+$bb[3])/2.0)<0)
		select -add CheekRaiserJoint_R;
	else
		select -add CheekRaiserJoint_L;
	select -add ("CheekRaiserLayer_"+$name);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	$skinCluster=`rename $tempString[0] ($sel[$i]+"CheekRaiserSC")`;
	select CheekRaiserLayer ("CheekRaiserLayer_"+$name);
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;	

	//RegionsLayer
	select ("RegionsLayer_"+$name);
	if ((($bb[0]+$bb[3])/2.0)<0)
		select -add EyeRegionJoint_R;
	else
		select -add EyeRegionJoint_L;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	$skinCluster=`rename $tempString[0] ($sel[$i]+"RegionsSC")`;

	//UpMidLoLayer
	select Face_M upperFaceJoint_M middleFaceJoint_M lowerFaceJoint_M ("UpMidLoLayer_"+$name);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	$skinCluster=`rename $tempString[0] ($sel[$i]+"UpMidLoSC")`;
	skinPercent -tv upperFaceJoint_M 1 ($sel[$i]+"UpMidLoSC") ("UpMidLoLayer_"+$name);

	//SquintLayer
	sets -add SquintLayerFFDSet_R ("SquintLayer_"+$name);
	sets -add SquintLayerFFDSet_L ("SquintLayer_"+$name);

	if (!`attributeExists skinWeightedToFace $sel[$i]`)
		addAttr -k 0 -ln skinWeightedToFace -at bool -dv true $sel[$i];//so we get BS targets when using EditBlendShape tools
	}

delete upperEyeLidCage_R upperEyeLidCage_L lowerEyeLidCage_R lowerEyeLidCage_L;

select $sel;
print ("// Attached EyeLashes.\n");
}

global proc float asCurveChkSum (string $curve)
{
int $form,$spans,$degrees,$numCv;
float $chkSum;
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2) $numCv=$spans;
else $numCv=$spans+$degrees;
for ($i=0;$i<$numCv;$i++)
	{
	$pos=`xform -q -ws -t ($curve+".cv["+$i+"]")`;
	$chkSum=$chkSum+$pos[0]+$pos[1]+$pos[2];
	}

return $chkSum;
}

global proc asFaceDeleteFromCheckBox (string $region)
{
string $leftSuffix;
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSym`=="Left")
		$leftSuffix="Left";

string $dialog=`confirmDialog -t "Confirm"
	-m ("Delete "+$region)
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	{
	checkBox -e -v 1 ("asFaceFit"+$region);
	return;
	}
if (`objExists ("FaceFit"+$region+$leftSuffix)`)
	delete ("FaceFit"+$region+$leftSuffix);

if (`gmatch $region "Lip*"` && `objExists ("FaceFit"+$region+"Left")`)
	delete ("FaceFit"+$region+"Left");

checkBox -e -ed 0 ("asFaceFit"+$region);
}

global proc asSmoothFlood (string $infA, string $infB, int $numSmoo)
{
global string $gSelect;
string $selO[]=`ls -sl -o`;
if ($selO[0]=="")
	return;

string $tempString[]=`listHistory $selO[0]`;
string $skinCluster;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="skinCluster")
		$skinCluster=$tempString[$y];

//string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $infJoints[]=`listConnections ($skinCluster+".matrix")`;

if ($infB!="")
	for ($i=0;$i<size($infJoints);$i++)
		{
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 1;
		if ($infJoints[$i]==$infA || $infJoints[$i]==$infB)
			setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
		}

ArtPaintSkinWeightsTool; 
artAttrSkinPaintCtx -e -sao smooth -influence $infA artAttrSkinContext;
artSkinInflListChanging $infA 1;
artSkinInflListChanged artAttrSkinPaintCtx;
for ($i=0;$i<$numSmoo;$i++)
	artFloodSurfaces;

for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
setToolTo $gSelect;
}

global proc asSkinTeeth ()
{
global string $gMainProgressBar;
global string $gSelect;
int $tempSkinTongue=1;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $upperTeethJoint="upperTeethJoint_M";
string $lowerTeethJoint="lowerTeethJoint_M";
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $tempString[];

//make sure teeth & tongue geo is in vtxs
if ($upperTeeth!="") 
	{
	eval ("select "+$upperTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$upperTeeth=`stringArrayToString $tempString " "`;
	}
if ($lowerTeeth!="") 
	{
	eval ("select "+$lowerTeeth);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$lowerTeeth=`stringArrayToString $tempString " "`;
	}
if ($tongue!="") 
	{
	eval ("select "+$tongue);
	ConvertSelectionToVertices;
	$tempString=`ls -sl`;
	$tongue=`stringArrayToString $tempString " "`;
	}

//teeth
string $upperLower,$teeth,$teethJoint,$teethObject;
string $teethObjects[];
string $teethSC=$skinCluster;
for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
	{
	if ($upperLowerFactor==1) {$upperLower="upper";$teeth=$upperTeeth;$teethJoint=$upperTeethJoint;}
	else {$upperLower="lower";$teeth=$lowerTeeth;$teethJoint=$lowerTeethJoint;}
		
	if ($teeth=="")
		continue;

  eval ("select "+$teeth);
  $teethObjects=`ls -sl -o`;

	for ($i=0;$i<size($teethObjects);$i++)
		{
		$teethObject=$teethObjects[$i];
		int $haveSkinCluster=0;
	
		string $historyNodes[]=`listHistory -pdo 1 -il 2 $teethObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$teethSC=$historyNodes[$y];
				}
		if (!$haveSkinCluster)
			{
			select $teethJoint;
			select -add $teethObjects[$i];
			$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
			rename $tempString[0] ($upperLower+"TeethSC");
			}
		else if (`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)
			{
			skinCluster -e -ai $teethJoint -lw false -wt 0 JawSC;
			skinCluster -e -ai $teethJoint -lw false -wt 0 JawOpenLayerSC;
			eval ("select "+$teeth);
			$tempString=`ls -sl`;
			select `asobjSetCast "" $tempString JawOpenLayer`;
			skinPercent -tv $teethJoint 1 JawOpenLayerSC `ls -sl`;
			}
		else
			{
			$tempString=`listConnections ($teethSC+".matrix")`;
			if (!`stringArrayCount $teethJoint $tempString`)
				skinCluster -e -ai $teethJoint -lw false -wt 0 $teethSC;
			eval ("select "+$teeth);
			skinPercent -tv $teethJoint 1 $teethSC `ls -sl`;
//			skinCluster -e -ri $headJoint $teethSC;//removed cause can cause Maya to quietly stop evaluation from here onward.
			}
		}
	}
//Temp skin tongue as well, for easier jaw-weighting
//if teeth part of Main mesh, then skip as weight will be on JawLayer
if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
	$tempSkinTongue=0;
if ($tongue!="" && $tempSkinTongue)
	{
	eval ("select "+$tongue);
	$tempString=`ls -sl -o`;
	string $tongueObject=$tempString[0];
	int $haveSkinCluster=0;
	string $historyNodes[]=`listHistory -pdo 1 -il 2 $tongueObject`;
		for ($y=0;$y<size($historyNodes);$y++)
			if (`nodeType $historyNodes[$y]`=="skinCluster")
				{
				$haveSkinCluster=1;
				$skinCluster=$historyNodes[$y];
				}
	if (!$haveSkinCluster)
		{
		select JawJoint_M;
		select -add $tongueObject;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] TongueSC;
		}
	else if (`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)
		{
		eval ("select "+$tongue);
		$tempString=`ls -sl`;
		select `asobjSetCast "" $tempString JawOpenLayer`;
		skinPercent -tv JawJoint_M 1 JawOpenLayerSC `ls -sl`;
		}
	else
		{
		$tempString=`listConnections ($skinCluster+".matrix")`;
		if (!`stringArrayCount JawJoint_M $tempString`)
			skinCluster -e -ai JawJoint_M -lw false -wt 0 $skinCluster;
		eval ("select "+$tongue);
		skinPercent -tv JawJoint_M 1 $skinCluster `ls -sl`;
//		skinCluster -e -ri $headJoint $skinCluster;//removed cause can cause Maya to quietly stop evaluation from here onward.
		}
	}

setToolTo $gSelect;
}

global proc asSelectCurveVtx (string $curve)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[]=`listRelatives -s $curve`;
string $curveShape=$tempString[0];

string $tmpObjs[]={"tempLocator","tempPointOnCurveInfo","samplerMesh","closestSampler"};
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
spaceLocator -n tempLocator;
createNode -n tempPointOnCurveInfo pointOnCurveInfo;
connectAttr -f ($curveShape+".worldSpace[0]") tempPointOnCurveInfo.inputCurve;
setAttr tempPointOnCurveInfo.turnOnPercentage 1;
setAttr tempPointOnCurveInfo.parameter 0.5;
connectAttr tempPointOnCurveInfo.position tempLocator.t;
setAttr tempLocator.v 0;

asCreateSamplerMesh $geometry; 
createNode -n closestSampler closestPointOnMesh;
connectAttr samplerMesh.outMesh closestSampler.inMesh;
connectAttr tempLocator.worldPosition closestSampler.inPosition;
setAttr "tempPointOnCurveInfo.parameter" 1;
select -cl;
int $previousVtx;
for ($i=0;$i<101;$i++)
	{
	setAttr tempPointOnCurveInfo.parameter (0.01*$i);
	int $vtx=`getAttr closestSampler.result.closestVertexIndex`;
	if($vtx!=$previousVtx)
		{
		select -add ($geometry+".vtx["+$vtx+"]");
		string $currentSel[]=`ls -sl`;
//		refresh;
		select $currentSel;
		}
	$previousVtx=$vtx;
	}
for ($i=0;$i<size($tmpObjs);$i++) if (`objExists $tmpObjs[$i]`) delete $tmpObjs[$i];
}

global proc asFacePaintControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (`gmatch $sel[0] "*Lip[0-9]_*"`)
	error "The Lip controller does not directly control any joints or clusters";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";

$tempString=`listConnections ($sel[0]+".s")`;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	asFacePaintClusterWeights;
	asShowLayer Clusters;
	select ClustersRegion;
	print "// Detected this controller to control a \"Cluster\", starting Cluster Painting Tool";
	}
else
	{
	tokenize $sel[0] "_" $tempString;
	if (!($tempString[1]=="R" || $tempString[1]=="L" || $tempString[1]=="M"))
		$error=1;
	string $joint=$tempString[0]+"Joint_"+$tempString[1];
	if (!`objExists $joint`)
		$error=1;
	if (!$error)
		{
		select $geometry;
		ArtPaintSkinWeightsTool;
		string $currentCtx = `currentCtx`;
		artSkinSelectInfluence artAttrSkinPaintCtx $joint;
		asShowLayer Normal;
		select $geometry;
		print "// Detected this controller to control a \"Joint\", starting Skin Weight Tool";
		}
	}
if ($error)
		error "Unable to detect which joint or cluster this is controlling";
}

global proc asFacePaintClusterWeights ()
{
global string $artSelectObject;
string $dialog=`confirmDialog -t "Confirm"
	-m ("This cluster have been \"Pruned\" for improved performance\n"
		+"Which means weights can not be painted outside Pruned area.")
	-b "UnPrune" -b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog=="Cancel")
	return;
	
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $sel[]=`ls -sl`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[0];
$side="_"+$tempString[1];

if (!`getAttr -l ($geometry+".v")`) setAttr ($geometry+".v") 0;
setAttr ClustersRegion.v 1;

if ($dialog=="UnPrune")
	if (`objExists ($fitJoint+"Cluster"+$side+"Set") `)
		{
		string $currentMembers[]=`sets -q ($fitJoint+"Cluster"+$side+"Set")`;
		select ClustersRegion.vtx[0:999999];
		select -d $currentMembers;
		sets -add ($fitJoint+"Cluster"+$side+"Set") `ls -sl`;
		percent -v 0 ($fitJoint+"Cluster"+$side) `ls -sl`;
		select -cl;
		}

artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
select ClustersRegion;
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$fitJoint+"Cluster"+$side+".weights\")");
}

global proc asShowLayer (string $layer)
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $rightEye=`textField -q -tx asFaceEye_RTextField`;
string $leftEye=`textField -q -tx asFaceEye_LTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $tempString[],$tempString2[],$allFaceGeo[],$teethTongueEyes[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
if (!`stringArrayCount $geometry $allFaceGeo`)
	$allFaceGeo[size($allFaceGeo)]=$geometry;

//$teethTongueEyes, since it can be multiple objs, e.g eye+lens 
$tempString={$upperTeeth,$lowerTeeth,$tongue,$leftEye,$rightEye};
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="")
		continue;
	tokenize $tempString[$i] $tempString2;
	for ($y=0;$y<size($tempString2);$y++)
		if ($tempString2[$y]!="")
			$teethTongueEyes[size($teethTongueEyes)]=$tempString2[$y];
	}

int $normal=0;
if ($layer=="Normal") $normal=1;

for ($i=0;$i<size($allFaceGeo);$i++)
	{
	if (`stringArrayCount $allFaceGeo[$i] $teethTongueEyes`)
		continue;
	setAttr ($allFaceGeo[$i]+".v") $normal;
	}

string $layers[]=`listRelatives -c DeformationLayers`;
for ($i=0;$i<size($layers);$i++)
	{
	if (`getAttr -l ($layers[$i]+".v")`)
		setAttr -l 0 ($layers[$i]+".v");
	setAttr ($layers[$i]+".v") 0;
	}
select -cl;
setAttr -l 0 DeformationLayers.v;
setAttr DeformationLayers.v (!$normal);
setAttr -l $normal DeformationLayers.v;
if (!$normal)
	for ($i=0;$i<size($layers);$i++)
		if (`gmatch $layers[$i] ($layer+"Layer*")`)
//		if ($layers[$i]==$layer+"Layer")
			{
			setAttr ($layers[$i]+".v") (!$normal);
			if (!$normal) select -add $layers[$i];
			}
//setAttr -l 0 FaceDeformationSystem.v;
//setAttr FaceDeformationSystem.v (!$normal);
//setAttr -l 1 FaceDeformationSystem.v;
}

global proc asCreateLayerLayout ()
{
columnLayout;
separator -h 5;
rowLayout -nc 3;
	text -w 100 -l "Layer Name:";
	textField -w 80 asLayerNameTextField;
	setParent..;

separator -h 50;
rowLayout -nc 4;
	separator -w 10 -st none;
	button -l "OK" -c "asCreateLayerGetName;layoutDialog -dismiss \"OK\";";
	separator -w 10 -st none;
	button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
	setParent..;
}

global proc asCreateLayerGetName ()
{
global string $asLayerName;
//global int $asLayerAllHead;
$asLayerName=`textField -q -tx asLayerNameTextField`;
//$asLayerAllHead=`checkBox -q -v asLayerAllHeadCheckBox`;
}

global proc asCreateLayer ()
{
global string $asLayerName;
//global int $asLayerAllHead;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

string $dialogResult=`layoutDialog -t "Confirm" -ui asCreateLayerLayout`;
if ($dialogResult!="OK")
	return;
string $layerName=$asLayerName;
//int $allHead=$asLayerAllHead;

if ($layerName=="")
for ($i=1;$i<99;$i++)
	{
	$layerName="Untitled"+$i;
	if (!`objExists ($layerName+"Layer")`)
		break;
	}

duplicate -n ($layerName+"Layer") $geometry;
$tempString=`listRelatives -s ($layerName+"Layer")`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];

parent ($layerName+"Layer") DeformationLayers;
sets -e -forceElement initialShadingGroup ($layerName+"Layer");
blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` ($layerName+"Layer") 1 asFaceBS;
setAttr ("asFaceBS."+$layerName+"Layer") 1;
asShowLayer $layerName;

print ("// New Layer \""+$layerName+"\" created, You can add your own custom deformations here\n");
}

global proc asBSConvertControlsToBlendShapes (string $controls)
{
int $keepBSTarget=`checkBox -q -v asKeepBSTargetsCheckBox`;
int $keepLine,$reacedInfluenceAttr,$numChar,$sideFactor,$sideStepNr,$sideStepLeftNr,$sideStepRightNr;
int $limitsStatus=`getAttr ctrlBox.limits`;
int $values[]={1,-1};
float $cheekPos[]=`xform -q -ws -t JawPivot`;
float $drivingValue;
float $transformLimits[],$pos[],$softMaxs[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $exp,$newExp,$obj,$attr,$setAttrCmdExtra,$cmd;
string $name,$inOut,$side,$existingCmd,$newCmd,$asFaceBS,$targetName,$existingCmd,$newCmd,$sideLessObj;
string $defaultAttrs[]={"tx","ty"};
string $blendedAttrs[]={"txPos_tyPos","txPos_tyNeg","txNeg_tyPos","txNeg_tyNeg"};
string $xyz[]={"x","y","z"};
string $driveExpressions[]=`ls -type expression "*DriveExp*"`;
string $targets[]=`listAttr -m asFaceBS.weight`;
string $tempString[],$tempString2[],$tempString3[],$geos[],$sdkNodes[],$objAttrs[],$phonemesAttrs[],$phonemesPreBSSDKs[],$objs[],$phonemes[];
string $deleteObjs[],$upperTeethObjs[],$lowerTeethObjs[],$connectCmds[],$attrs[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

tokenize $upperTeeth $tempString;
for ($i=0;$i<size($tempString);$i++)
	$upperTeethObjs[$i]=$tempString[$i];
tokenize $lowerTeeth $tempString;
for ($i=0;$i<size($tempString);$i++)
	$lowerTeethObjs[$i]=$tempString[$i];

if ($controls=="boxCtrls")
	$objs={"ctrlBrow_R","ctrlBrow_L","ctrlCheek_R","ctrlCheek_L","ctrlNose_R","ctrlNose_L","ctrlMouthCorner_R","ctrlMouthCorner_L"};
if ($controls=="squint")
	{
	$objs={"ctrlEye_R","ctrlEye_L"};
	$defaultAttrs={"squint"};
	}
if ($controls=="fleshyEye")
	{
//	$objs={"ctrlEye_R","ctrlEye_L"};
	$objs={"Eye_R","Eye_L"};
	$defaultAttrs={"rx","ry"};
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1)  $side="_R";
		if ($b==-1) $side="_L";

		for ($y=0;$y<size($xyz);$y++)
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ("Eye"+$side+".r"+$xyz[$y])`;
			$connectCmds[size($connectCmds)]="connectAttr "+$tempString[0]+" Eye"+$side+".r"+$xyz[$y]+";";
			disconnectAttr $tempString[0] ("Eye"+$side+".r"+$xyz[$y]);
			}
		}
	}
if ($controls=="blink")
	{
	$objs={"ctrlEye_R","ctrlEye_L"};
	$defaultAttrs={"blink"};
	}
if ($controls=="ctrlMouth")
	{
	$objs={"ctrlMouth_M"};
	$defaultAttrs={"ty","upperPress","lowerPress","upperSqueeze","lowerSqueeze","upperRoll","lowerRoll","upperPucker","lowerPucker"};
	}
if ($controls=="ctrlPhonemes")
	{
	$objs={"ctrlPhonemes_M"};
	clear $defaultAttrs;
	$tempString=`listAttr -ud -k ctrlPhonemes_M`;
	for ($y=0;$y<size($tempString);$y++)
		if ($tempString[$y]!="jaw" && $tempString[$y]!="lip" && $tempString[$y]!="multipliers")
			$defaultAttrs[size($defaultAttrs)]=$tempString[$y];
	}

if (`attributeExists ("converted"+$controls+"ToBlendShapes") asFaceBS`)
	error ("Already converted \""+$controls+"\" to blendShapes");

if (`attributeExists convertedToBlendShapes asFaceBS`)
	error ("Already converted to blendShapes, using a older version of AdvancedSkeleton");

int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;

if ($limitsStatus)
	setAttr ctrlBox.limits 0;

$geos={$geometry};
//skinWeightedToFace, for Eyebrows to be included as blendShapes
//FaceExtras > Add to all SkinLayers allow for any object to be added, so we change to scan all objects for `skinWeightedToFace` attribute
SelectAllGeometry;
select -d `listRelatives -ad DeformationLayers`;
$tempString=`ls -sl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists skinWeightedToFace $tempString[$i]`)
		if (!`gmatch $tempString[$i] "prefix_*"`)
			$geos[size($geos)]=$tempString[$i];

if ($controls=="ctrlMouth" || $controls=="ctrlPhonemes")
	{
	if ($upperTeeth!="" && !(`gmatch $upperTeeth ($geometry+"*")` && `gmatch $upperTeeth "*[.]*"`)) $geos=`stringArrayCatenate $geos $upperTeethObjs`;
	if ($lowerTeeth!="" && !(`gmatch $lowerTeeth ($geometry+"*")` && `gmatch $lowerTeeth "*[.]*"`)) $geos=`stringArrayCatenate $geos $lowerTeethObjs`;
	if ($tongue!="" && !(`gmatch $tongue ($geometry+"*")` && `gmatch $tongue "*[.]*"`)) $geos[size($geos)]=$tongue;
	}

asGoToBuildPose faceSetup;

//Disable any deltaMush
$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
		{
		$cmd+="setAttr "+$tempString[$y]+".envelope "+`getAttr ($tempString[$y]+".envelope")`+";";
		setAttr ($tempString[$y]+".envelope") 0;
		}

select -cl;
if (`objExists asBlendShapes`)
	move -r 0 ($cheekPos[0]*-2.5) 0 `listRelatives -c asBlendShapes`;
else
	createNode -n asBlendShapes transform;
for ($i=0;$i<size($objs);$i++)
	{
	$numChar=size($objs[$i]);
	$side=`substring $objs[$i] ($numChar-1) 99`;
	$sideLessObj=`substring $objs[$i] 1 ($numChar-2)`;

	clear $attrs;
	$attrs=$defaultAttrs;
	for ($y=0;$y<size($blendedAttrs);$y++)
		if (`attributeExists $blendedAttrs[$y] $objs[$i]`)
			{
			$attrs[size($attrs)]=$blendedAttrs[$y];
			$tempString=`listConnections -s 1 -d 0 -p 1 ($objs[$i]+"."+$blendedAttrs[$y])`;
			$connectCmds[size($connectCmds)]="connectAttr "+$tempString[0]+" "+($objs[$i]+"."+$blendedAttrs[$y])+";";
			disconnectAttr $tempString[0] ($objs[$i]+"."+$blendedAttrs[$y]);
			}

	for ($y=0;$y<size($attrs);$y++)
		for ($z=0;$z<size($values);$z++)
			{
			$transformLimits=`transformLimits -q -ty $objs[$i]`;
			if ($attrs[$y]=="ty" && $values[$z]==-1 && $transformLimits[0]==0)
				continue;
			if ($attrs[$y]!="tx" && $attrs[$y]!="ty" && $attrs[$y]!="rx" && $attrs[$y]!="ry" && $objs[$i]!="ctrlMouth_M" && $values[$z]==-1)
				continue;

			$sideFactor=1;
			if ($side=="_L")
				{
				$sideFactor=-1;
				$sideStepLeftNr++;
				$sideStepNr=$sideStepLeftNr;
				}
			else
				{
				$sideStepRightNr++;
				$sideStepNr=$sideStepRightNr;
				}

			$name=$sideLessObj+$attrs[$y]+$side;//non-spsified attrs e.g txPos_tyPos 

			if (`gmatch $objs[$i] "ctrlBrow*"`)
				{
				if ($attrs[$y]=="tx" && $values[$z]==1)  $name="brow_innerRaiser"+$side;
				if ($attrs[$y]=="tx" && $values[$z]==-1) $name="brow_innerlower"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==1)  $name="brow_raiser"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==-1)  $name="brow_lower"+$side;
				}
			if (`gmatch $objs[$i] "ctrlCheek*"`)
				{
				if ($attrs[$y]=="tx" && $values[$z]==1)  $name="cheek_out"+$side;
				if ($attrs[$y]=="tx" && $values[$z]==-1) $name="cheek_in"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==1)  $name="cheek_raiser"+$side;
				}
			if (`gmatch $objs[$i] "ctrlNose*"`)
				{
				if ($attrs[$y]=="tx" && $values[$z]==1)  $name="nose_wide"+$side;
				if ($attrs[$y]=="tx" && $values[$z]==-1) $name="nose_narrow"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==1)  $name="nose_raiser"+$side;
				}
			if (`gmatch $objs[$i] "ctrlMouthCorner*"`)
				{
				if ($attrs[$y]=="tx" && $values[$z]==1)  $name="mouth_wide"+$side;
				if ($attrs[$y]=="tx" && $values[$z]==-1) $name="mouth_narrow"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==1)  $name="mouth_raiser"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==-1) $name="mouth_lower"+$side;
				}
			if (`gmatch $objs[$i] "Eye*"`)
				{
				if ($attrs[$y]=="rx" && $values[$z]==1)  $name="eye_lookDown"+$side;
				if ($attrs[$y]=="rx" && $values[$z]==-1) $name="eye_lookUp"+$side;
				if ($attrs[$y]=="ry" && $values[$z]==1)  $name="eye_lookLeft"+$side;
				if ($attrs[$y]=="ry" && $values[$z]==-1) $name="eye_lookRight"+$side;
				//special case, flip Left/Right for _R targets, to make EditBlendShapes work correctly with these
				if ($side=="_L")
					{
					if ($attrs[$y]=="ry" && $values[$z]==1)  $name="eye_lookRight"+$side;
					if ($attrs[$y]=="ry" && $values[$z]==-1) $name="eye_lookLeft"+$side;
					}
				if ($attrs[$y]!="rx" && $attrs[$y]!="ry") $name="eye_"+$attrs[$y]+$side;
				}
			if ($objs[$i]=="ctrlMouth_M")
				{
//				if ($attrs[$y]=="tx" && $values[$z]==1)  $name="mouth_wide"+$side;
//				if ($attrs[$y]=="tx" && $values[$z]==-1) $name="mouth_narrow"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==1)  $name="mouth_close"+$side;
				if ($attrs[$y]=="ty" && $values[$z]==-1) $name="mouth_open"+$side;
				if ($attrs[$y]!="tx" && $attrs[$y]!="ty")
					{
					if ($values[$z]==1) $inOut="In";
					if ($values[$z]==-1) $inOut="Out";
					$name="mouth_"+$attrs[$y]+$inOut+$side;
					}
				}
			if ($objs[$i]=="ctrlPhonemes_M")
				$name=$attrs[$y]+$side;

			for ($a=0;$a<size($geos);$a++)
				{
				if ($a==0)
					$asFaceBS="asFaceBS";
				else
					{
					$asFaceBS="asFaceBS_"+`substituteAllString $geos[$a] ":" "_"`;
					}
				if (!`objExists $asFaceBS`)
					{
					select $geos[$a];
					blendShape -n $asFaceBS -frontOfChain;
					}
				if ($attrs[$y]=="tx" || $attrs[$y]=="ty" || `stringArrayCount $attrs[$y] $blendedAttrs`)
					$drivingValue=$values[$z];
				else if ($attrs[$y]=="rx" || $attrs[$y]=="ry")
					$drivingValue=30*$values[$z];
				else if ($values[$z]==1)
					$drivingValue=10;
				else if ($values[$z]==-1)
					$drivingValue=-10;
				setAttr ($objs[$i]+"."+$attrs[$y]) $drivingValue;
				refresh;
				if (`objExists $name`)
					rename $name tempRenamingBlendShapeTarget;
//				duplicate -n $name $geos[$a];
				//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
				$tempString[0]=`createNode mesh`;
				$tempString=`listRelatives -p $tempString[0]`;
				rename $tempString[0] $name;
				connectAttr ($geos[$a]+".outMesh") ($name+".inMesh");
				sets -e -forceElement initialShadingGroup $name;
				refresh;
				disconnectAttr ($geos[$a]+".outMesh") ($name+".inMesh");

				parent $name asBlendShapes;
				blendShape -e -tc 0 -t $geos[$a] `getAttr -s ($asFaceBS+".w")` $name 1 $asFaceBS;
				if ($keepBSTarget)
					{
					$targetName=$name;
					if ($a>0)
						{
						$targetName=$name+"_"+`substituteAllString $geos[$a] ":" "_"`;
						rename $name $targetName;
						}
					if (`objExists tempRenamingBlendShapeTarget`)
						rename tempRenamingBlendShapeTarget $name;
					asLockAttr $targetName 0 0 0 0;
					move -r ($cheekPos[0]*2.5*$sideFactor*$sideStepNr) 0 0 $targetName;
					}

				setAttr ($objs[$i]+"."+$attrs[$y]) 0;
				if ($values[$z]>0)
					{
					asFaceBsSdk ($objs[$i]+"."+$attrs[$y]) $drivingValue ($asFaceBS+"."+$name) 1;
					setAttr ($asFaceBS+"_"+$name+".preInfinity") 1; // no neg weight when drive<0
					}
				else
					{
					asFaceBsSdk ($objs[$i]+"."+$attrs[$y]) $drivingValue ($asFaceBS+"."+$name) 1;
					setAttr ($asFaceBS+"_"+$name+".postInfinity") 0; // no neg weight when drive>0
					}

				if ($attrs[$y]=="tx" && `attributeExists txMixed $objs[$i]`) connectAttr -f ($objs[$i]+".txMixed") ($asFaceBS+"_"+$name+".input");
				if ($attrs[$y]=="ty" && `attributeExists tyMixed $objs[$i]`) connectAttr -f ($objs[$i]+".tyMixed") ($asFaceBS+"_"+$name+".input");

				if (!$keepBSTarget)
					delete $name;
				}
			}
	}

for ($i=0;$i<size($connectCmds);$i++)
	catchQuiet (`eval ($connectCmds[$i])`);

if ($controls=="boxCtrls")
	{//ctrlMouth And ctrlPhonemes now converts as part of "boxCtrls", for simplicity
	asBSConvertControlsToBlendShapes "ctrlMouth";
	asBSConvertControlsToBlendShapes "ctrlPhonemes";
	refresh;
	}

//Removing old system, since BlendShapes are now beeing used
if ($controls=="boxCtrls")
	{
	//remove SDK`s (Face DrivingSystems)
	$tempString=`ls -type blendWeighted "bwSDK*"`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im FaceAllSet $tempString[$i]`)
			delete $tempString[$i];
	//remove all ua on ctrlMouth_M
	$tempString=`listAttr -ud ctrlMouth_M`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$tempString2=`listConnections -p 1 -s 0 -d 1 ("ctrlMouth_M."+$tempString[$i])`;
		for ($y=0;$y<size($tempString2);$y++)
			if (!`gmatch $tempString2[$y] "asFaceBS*"`)
				disconnectAttr ("ctrlMouth_M."+$tempString[$i]) $tempString2[$y];
		}
	setAttr -l 0 ctrlMouth_M.lipDriven;
	deleteAttr ctrlMouth_M.lipDriven;
	deleteAttr ctrlMouth_M.autoSqueeze;
	if (`objExists upperLipPressSetRange`) delete upperLipPressSetRange;
	if (`objExists lowerLipPressSetRange`) delete lowerLipPressSetRange;
	if (`objExists LipAutoSqueezePMA`) delete LipAutoSqueezePMA;
	}

if ($controls=="squint")
	{
	//lock deformationLayers no longer used
	if (!`getAttr -l asFaceBS.SquintLayer`)
		setAttr -l 1 asFaceBS.SquintLayer 0;
	$deleteObjs={"SquintLayerLattice_R","SquintLayerLattice_L","SquintLayer"};
	for ($i=0;$i<size($deleteObjs);$i++)
		if (`objExists $deleteObjs[$i]`)
			delete $deleteObjs[$i];
	}

if ($controls=="fleshyEye")
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1)  $side="_R";
		if ($b==-1) $side="_L";

		setAttr ("ctrlEye"+$side+".upperLidFollow") 0;
		setAttr ("ctrlEye"+$side+".lowerLidFollow") 0;
		if (`attributeExists lidDroopyFollow ("ctrlEye"+$side)`)	
			setAttr ("ctrlEye"+$side+".lidDroopyFollow") 0;

		setAttr -l 0 ("ctrlEye"+$side+".eyeDriven");
		deleteAttr ("ctrlEye"+$side+".eyeDriven");
		deleteAttr ("ctrlEye"+$side+".upperLidFollow");
		deleteAttr ("ctrlEye"+$side+".lowerLidFollow");
		if (`attributeExists lidDroopyFollow ("ctrlEye"+$side)`)	
			deleteAttr ("ctrlEye"+$side+".lidDroopyFollow");

		setAttr ("upperFollowMultiplyDivide1"+$side+".input2") -type float3 0 0 0;
		setAttr ("lowerFollowMultiplyDivide1"+$side+".input2") -type float3 0 0 0;
		}
	}

if ($controls=="blink")
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1)  $side="_R";
		if ($b==-1) $side="_L";

		deleteAttr ("ctrlEye"+$side+".blinkCenter");
		deleteAttr ("ctrlEye"+$side+".upperLid");
		deleteAttr ("ctrlEye"+$side+".lowerLid");
		deleteAttr ("ctrlEye"+$side+".upperLidOut");
		deleteAttr ("ctrlEye"+$side+".lowerLidOut");
		setAttr -l 0 ("ctrlEye"+$side+".blinkDriven");
		deleteAttr ("ctrlEye"+$side+".blinkDriven");
		deleteAttr ("ctrlEye"+$side+".upperLidOutAuto");
		deleteAttr ("ctrlEye"+$side+".lowerLidOutAuto");
		}

	delete `ls -type animCurveUU "LidSetup_*"`;//delete old blink sdks
	}

if ($controls=="ctrlMouth")
	{
	deleteAttr ctrlMouth_M.zipLips_R;
	deleteAttr ctrlMouth_M.zipLips_L;
	}

if ($controls=="ctrlPhonemes")
	{
	setAttr -l 0 ctrlPhonemes_M.multipliers;
	deleteAttr ctrlPhonemes_M.multipliers;
	deleteAttr ctrlPhonemes_M.jaw;
	deleteAttr ctrlPhonemes_M.lip;
	}

//update faceBuildPose
$existingCmd=`getAttr faceBuildPose.udAttr`;
$newCmd="";
tokenize $existingCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!catchQuiet (`eval ($tempString[$i])`))
		$newCmd+=$tempString[$i]+";";
	else
		print ($tempString[$i]+"\n");
setAttr -type "string" faceBuildPose.udAttr $newCmd;
//update FaceFitSkeleton.run
if (`attributeExists run FaceFitSkeleton`)
	{
	$existingCmd=`getAttr FaceFitSkeleton.run`;
	$newCmd="";
	tokenize $existingCmd ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (!catchQuiet (`eval ($tempString[$i])`))
			$newCmd+=$tempString[$i]+";";
		else
			print ($tempString[$i]+"\n");
	setAttr -type "string" FaceFitSkeleton.run $newCmd;
	}
addAttr -ln ("converted"+$controls+"ToBlendShapes") -at bool -dv 1 asFaceBS;

if ($limitsStatus)
	setAttr ctrlBox.limits 1;

if ($autoKeyState) autoKeyframe -state 1;

if (!$keepBSTarget && `objExists asBlendShapes`)
	delete asBlendShapes;

if ($cmd!="") eval ($cmd);
asUpdateButtonEnables;//disables some skinLayers
select -cl;
print ("// Converted \""+$controls+"\" to BlendShapes.\n");
}

global proc asBSWizardStop ()
{
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[];
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
int $lastStep=$buffer[1];
text -e -l ("0/"+$lastStep) asBSWizardStepText;
text -e -l "..." asBSWizardObjAttrText;
text -e -l "..." asBSWizardValueText;
button -e -en 1 asBSWizardButton;
button -e -en 0 asBSWizardHelpButton;
button -e -en 0 asBSWizardNextButton;
if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
}

global proc asBSWizard ()
{
asBSWizardStop;
button -e -en 0 asBSWizardButton;
button -e -en 1 asBSWizardNextButton;
button -e -en 1 asBSWizardHelpButton;
asGoToBuildPose faceSetup;
playbackOptions -min 1 -max 10 -ast 1 -aet 10;
asBSWizardNext;
}

global proc asBSWizardNext ()
{
int $limitsOn=`getAttr ctrlBox.limits`;
float $value;
float $keyXValues[],$keyYValues[];
string $stepText=`text -q -l asBSWizardStepText`;
string $buffer[],$tempString[],$tempString2[],$targets[];
string $target, $objAttr,$sdk,$xy;
tokenize $stepText "/" $buffer;
int $previousStep=$buffer[0];
//int $lastStep=$buffer[1];
int $lastStep;
int $step=$previousStep+1;

if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
if ($limitsOn)
	setAttr ctrlBox.limits 0;

$targets=`asBSGetTargets`;
$lastStep=size($targets);

$tempString=`listConnections -s 1 -d 0 ("asFaceBS."+$targets[$step-1])`;
$sdk=$tempString[0];
$tempString=`listConnections -s 1 -d 0 -p 1 $sdk`;
$objAttr=$tempString[0];
$keyXValues=`keyframe -q -fc $sdk`;
$keyYValues=`keyframe -q -vc $sdk`;
for ($i=0;$i<size($keyYValues);$i++)
	if ($keyYValues[$i]==1)
		{
		$value=$keyXValues[$i];
		}

if (`gmatch $objAttr "*Mixed"`)//going for one of the sources
	{
	$tempString=`listConnections -s 1 -d 0 $objAttr`;
	$tempString2=`listConnections -s 1 -d 0 -p 1 $objAttr`;
	if (`gmatch $tempString2[0] "*output3Dx"`) $xy="x";
	if (`gmatch $tempString2[0] "*output3Dy"`) $xy="y";
	$tempString2=`listConnections -s 1 -d 0 -p 1 ($tempString[0]+".input3D[0].input3D"+$xy)`;
	$objAttr=$tempString2[0];
	}

if (`gmatch $objAttr "*tx*_ty*"`)//blendedAttrs, skipping this in Wizard
	{
	print ("Skipping blendedAttribute: \""+$objAttr+"\"\n");
	if ($limitsOn) setAttr ctrlBox.limits 1;
	text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
	asBSWizardNext;
	if ($limitsOn) setAttr ctrlBox.limits 1;
	return;
	}

if ($step==size($targets)+1)
	{
	print ("// All Shapes Complete.\n");
	asBSWizardStop;
	if (`window -q -ex faceHelpImage`)
		deleteUI faceHelpImage;
	if ($limitsOn) setAttr ctrlBox.limits 1;
	return;
	}

text -e -l ($step+"/"+$lastStep) asBSWizardStepText;
button -e -c ("asHelpImage \"asBSWizardStep"+$objAttr+"_"+$value+"\"") asBSWizardHelpButton;
if (`window -q -ex faceHelpImage`)
	asHelpImage ("asBSWizardStep"+$objAttr+"_"+$value);

text -e -l $objAttr asBSWizardObjAttrText;
text -e -l $value asBSWizardValueText;

print ("// asFaceBS."+$targets[$step-1]+" ("+$step+"/"+$lastStep+")\n");

eval ("setAttr "+$objAttr+" "+$value);
asBSAdjustTarget;
if ($limitsOn) setAttr ctrlBox.limits 1;
}

global proc asBSResetTarget ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $asFaceMirroWrap;
string $tempString[],$resetTargets[];
if (!`objExists deleteThis`)
	error "Click create blendshape target first";
$tempString=`listRelatives deleteThis`;
$resetTargets[0]=$tempString[0];

setAttr asFaceBS.envelope 0;
duplicate -n asBSResetTarget $geometry;
setAttr asFaceBS.envelope 1;
parent asBSResetTarget deleteThis;
$tempString=`listRelatives -s asBSResetTarget`;
for ($i=0;$i<size($tempString);$i++)
    if (`getAttr ($tempString[$i]+".intermediateObject")`)
        delete $tempString[$i];
for ($i=0;$i<size($resetTargets);$i++)
	{
	select -r asBSResetTarget $resetTargets[$i];
	blendShape -n deleteThisResetBS -frontOfChain;
	setAttr deleteThisResetBS.asBSResetTarget 1;
	select $resetTargets[$i];
	DeleteHistory;
	}
delete asBSResetTarget;
select $sel;
}

global proc asBSExtractAll ()
{
string $tempString[];

if (`objExists asBlendShapes`) delete asBlendShapes;
createNode -n asBlendShapes transform;
asGoToBuildPose faceSetup;
asBSWizard;
for ($i=0;$i<999;$i++)
	{
	if (!`objExists deleteThis`)//finished
		break;
	for ($a=0;$a<99;$a++)
		{
		if ($a==0) $asFaceMirroWrap="asFaceMirroWrap";
		else $asFaceMirroWrap="asFaceMirroWrap"+$a;
		if (`objExists $asFaceMirroWrap`)
			{
			select `listConnections ($asFaceMirroWrap+".outputGeometry")`;
			DeleteHistory;
			}
		else
			break;
		}

	$tempString=`listRelatives -c deleteThis`;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`gmatch $tempString[$y] "*_L"`)
			setAttr ($tempString[$y]+".v") 1;
		if (`getAttr ($tempString[$y]+".v")`)
			parent $tempString[$y] asBlendShapes;
		if (`gmatch $tempString[$y] "*_M"` || `gmatch $tempString[$y] "*_M*"`)
			setAttr ($tempString[$y]+".tx") 0;
		setAttr ($tempString[$y]+".ty") (($i+1)*`asFaceGetScale`);
		}

	asBSWizardNext;
	}

if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
print "// All targets extracted.\n";
}

global proc asBSDeltaMushAll ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $deltaMush;
if (`checkBox -q -ex wbDeltaMush`)
	checkBox -e -v 0 wbDeltaMush;
string $tempString[];

asGoToBuildPose faceSetup;
select $geometry;
asApplyDeltaMush;
refresh;
//auto zero-weight for eyeLids & lip
if (`objExists eyeLidArea` && `objExists lipArea`)
	{
	$tempString=`listHistory $geometry`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
			$deltaMush=$tempString[$y];
	select eyeLidArea;
	percent -v 0 $deltaMush;
	select lipArea;
	percent -v 0 $deltaMush;
	select -cl;
	}

if (`undoInfo -q -state`)
	{
	evalDeferred ("undoInfo -state 1;");
	undoInfo -state 0;
	}

createNode -n runningDeltaMushAllTargets transform;
asBSWizard;
refresh;
for ($i=0;$i<999;$i++)
	{
	if (!`objExists deleteThis`)//finished
		break;
	asBSWizardNext;
	}

$tempString=`listHistory $geometry`;
for ($y=0;$y<size($tempString);$y++)
	if (`objectType $tempString[$y]`=="wbDeltaMush" || `objectType $tempString[$y]`=="deltaMush")
		evalDeferred ("delete "+$tempString[$y]);
if (`objExists runningDeltaMushAllTargets`)
	delete runningDeltaMushAllTargets;

if (`objExists deleteThis`)
	delete deleteThis;
asGoToBuildPose faceSetup;
}

global proc asBSAdjustTarget ()
{
select asFaceBS;
int $targetNum,$numLetters;
int $inputTargetGroups[];
float $targetWeights[];
float $targetWeightsSum=0;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $targetLeft,$side,$asFaceBS,$mirrorDriver,$leftBDriver,$target,$restorePoseCmd;
//string $targets[]=`listAttr -m asFaceBS.weight`;
string $targets[]=`asBSGetTargets`;
string $raiserLower[]={"raiser","lower"};
string $blendedAttrs[]={"txPos_tyPos","txPos_tyNeg","txNeg_tyPos","txNeg_tyNeg"};
string $geos[],$tempString[];
float $multiply=`floatFieldGrp -q -v1 asCreateTargetShapeMultiplier`;
if (`objExists runningDeltaMushAllTargets`)
	$multiply=`floatFieldGrp -q -v1 asDeltaMushShapeMultiplier`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

$geos={$geometry};
for ($i=0;$i<size($allFaceGeo);$i++)
	if ($allFaceGeo[$i]!=$geometry)
		$geos[size($geos)]=$allFaceGeo[$i];
//FaceExtras > Add to all SkinLayers allow for any object to be added, so we change to scan all objects for `skinWeightedToFace` attribute
SelectAllGeometry;
if (`objExists DeformationLayers`)
	select -d `listRelatives -ad DeformationLayers`;
$tempString=`ls -sl`;
select -cl;
for ($i=0;$i<size($tempString);$i++)
	if (`attributeExists skinWeightedToFace $tempString[$i]`)
		if (!`stringArrayCount $tempString[$i] $geos`)
			$geos[size($geos)]=$tempString[$i];

//special case ctrlMouth_M.tx
if (`getAttr ctrlMouth_M.tx`>0)
	{
	setAttr ctrlMouth_M.tx 0;
	setAttr ctrlMouthCorner_R.tx 1;
	dgdirty -a;
	}
if (`getAttr ctrlMouth_M.tx`<0)
	{
	setAttr ctrlMouth_M.tx 0;
	setAttr ctrlMouthCorner_R.tx -1;
	dgdirty -a;
	}

//special case txPos_tyPos
for ($i=0;$i<size($targets);$i++)
	{
	if (!`attributeExists convertedboxCtrlsToBlendShapes asFaceBS`)
		continue;
	if (`getAttr ("asFaceBS."+$targets[$i])`!=1)
		continue;
	for ($y=0;$y<size($blendedAttrs);$y++)
		{
		if (`gmatch $targets[$i] ("*"+$blendedAttrs[$y]+"*")`)
			{
			//in this case, just set all other targets (that are sdk driving) to 0. Later restore the target values with dgdirty.
			for ($y=0;$y<size($targets);$y++)
				{
				if ($y==$i)
					continue;
				$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$targets[$i])`;
				if ($tempString[0]=="")
					continue;
				setAttr ("asFaceBS."+$targets[$y]) 0;
				}
			$restorePoseCmd="dgdirty -a;";
			}
		}
	}

for ($i=0;$i<size($targets);$i++)
	{
	$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$targets[$i])`;
	if ($tempString[0]=="")
		continue;
	$targetWeights[$i]=`getAttr ("asFaceBS."+$targets[$i])`;
	$targetWeightsSum+=$targetWeights[$i];
	if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
		$targetNum=$i;
	}
if ($targetWeightsSum>1.01 || $targetWeightsSum<0.99)
	{
	for ($i=0;$i<size($targets);$i++)
		{
		$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$targets[$i])`;
		if ($tempString[0]!="")
			if ($targetWeights[$i]>0.001 || $targetWeights[$i]<-0.001)
				print ("// asFaceBS."+$targets[$i]+" = "+$targetWeights[$i]+"\n");
		}
	AttributeEditor;
	error "Must have one target set to \"1\", and the rest set to \"0\"\n";
	}

if (`objExists deleteThis`)
	delete deleteThis;
createNode -n deleteThis transform;
float $cheekPos[]=`xform -q -ws -t JawPivot`;
string $targetName=$targets[$targetNum];
if (`objExists $targetName`)
	error ("Object "+$targetName+" exists");
if (!`attributeExists ($targetName+"_tweaked") FaceFitSkeleton`)
	addAttr -k 1 -dv 1 -ln ($targetName+"_tweaked") -at bool FaceFitSkeleton;
setAttr ("FaceFitSkeleton."+$targetName+"_tweaked") 1;

for ($a=0;$a<size($geos);$a++)
	{
	if ($a==0)
		$asFaceBS="asFaceBS";
	else
		$asFaceBS="asFaceBS_"+`substituteAllString $geos[$a] ":" "_"`;
	if (!`objExists $asFaceBS`)
		continue;

	//update $inputTargetGroups & $targets & $targetNum, as this will vary between $geos
	$inputTargetGroups=`getAttr -mi ($asFaceBS+".inputTarget[0].inputTargetGroup")`;
	$targets=`listAttr -m ($asFaceBS+".weight")`;
	$targetWeightsSum=0;
	for ($i=0;$i<size($targets);$i++)
		{
		$tempString=`listConnections -scn 1 -s 1 -d 0 -type animCurve ($asFaceBS+"."+$targets[$i])`;
		if ($tempString[0]=="")
			continue;
		$targetWeights[$i]=`getAttr ($asFaceBS+"."+$targets[$i])`;
		$targetWeightsSum+=$targetWeights[$i];
		if ($targetWeights[$i]>0.99 && $targetWeights[$i]<1.01)
			$targetNum=$i;
		}
	if ($targetWeightsSum<1)
		continue;
	if ($targets[$targetNum]!="")
		$target=$targets[$targetNum];
	if ($a==0)
		$targetName=$target;
	else
		$targetName=$target+"_"+`substituteAllString $geos[$a] ":" "_"`;

	if (`gmatch $targetName "*_R*"`)
		{
		$targetLeft=`substitute "_R" $targetName "_L"`;
		print ("$targetName="+$targetName+"   $targetLeft="+$targetLeft+"\n");
		if (!`attributeExists ($targetLeft+"_tweaked") FaceFitSkeleton`)
			addAttr -k 1 -dv 1 -ln ($targetLeft+"_tweaked") -at bool FaceFitSkeleton;
		setAttr ("FaceFitSkeleton."+$targetLeft+"_tweaked") 1;
		}
	if ($multiply!=1)
		setAttr ($asFaceBS+".w["+$targetNum+"]") $multiply;

	setAttr ($skinCluster+".envelope") 0;

//	duplicate -n $targetName $geos[$a];
	//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
	$tempString[0]=`createNode mesh`;
	$tempString=`listRelatives -p $tempString[0]`;
	rename $tempString[0] $targetName;
	connectAttr ($geos[$a]+".outMesh") ($targetName+".inMesh");
	refresh;
	disconnectAttr ($geos[$a]+".outMesh") ($targetName+".inMesh");
	sets -e -forceElement initialShadingGroup $targetName;

	asLockAttr $targetName 0 0 0 0;
	setAttr ($skinCluster+".envelope") 1;
	parent $targetName deleteThis;
	select $targetName;
	$tempString=`listRelatives -f -s $targetName`;
	for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
//print ("connectAttr -f "+$targetName+".worldMesh[0] "+$asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$targetNum]+"].inputTargetItem[6000].inputGeomTarget;\n");
//	if (!`isConnected ($targetName+".worldMesh[0]") ($asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$targetNum]+"].inputTargetItem[6000].inputGeomTarget")`)
		connectAttr -f ($targetName+".worldMesh[0]") ($asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$targetNum]+"].inputTargetItem[6000].inputGeomTarget");
	refresh;//Maya2016 bug workaround
	move -r ($cheekPos[0]*2.5) 0 0 $targetName;

	if (`gmatch $targetName "*_R*"` && !`gmatch $targetName "*_M_*"`)
		{
		refresh;
//		$numLetters=size($targetName);
//		$targetLeft=`substring $targetName 1 ($numLetters-2)`+"_L";
		$targetLeft=`substitute "_R" $targetName "_L"`;
		setAttr ($asFaceBS+".envelope") 0;
//		duplicate -n $targetLeft $geos[$a];
		//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
		$tempString[0]=`createNode mesh`;
		$tempString=`listRelatives -p $tempString[0]`;
		rename $tempString[0] $targetLeft;
		connectAttr ($geos[$a]+".outMesh") ($targetLeft+".inMesh");
		refresh;
		disconnectAttr ($geos[$a]+".outMesh") ($targetLeft+".inMesh");
		sets -e -forceElement initialShadingGroup $targetLeft;

		asLockAttr $targetLeft 0 0 0 0;
		parent $targetLeft deleteThis;
		setAttr ($asFaceBS+".envelope") 1;
		move -r (`getAttr ctrlBox.tx`*2) 0 0 $targetLeft;
		$tempString=`listRelatives -f -s $targetLeft`;
		for ($i=0;$i<size($tempString);$i++)
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
		duplicate -n ($targetLeft+"MirrorDriver") $targetLeft;
		setAttr ($targetLeft+"MirrorDriver.sx") -1;
		setAttr ($targetLeft+"MirrorDriver.v") 0;


		select -r $targetLeft ($targetLeft+"MirrorDriver");
//		CreateWrap;
		doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" };
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}

		$tempString=`listConnections ($targetLeft+"MirrorDriver.inflType")`;
		rename $tempString[0] asFaceMirroWrap;
		setAttr asFaceMirroWrap.exclusiveBind 1;
		connectAttr -f ($targetName+".outMesh") ($targetLeft+"MirrorDriver.inMesh");
	
		for ($i=0;$i<size($targets);$i++)
			if ($targets[$i]==$targetLeft || ($targets[$i]+"_"+`substituteAllString $geos[$a] ":" "_"`)==$targetLeft)
				connectAttr -f ($targetLeft+".worldMesh[0]") ($asFaceBS+".inputTarget[0].inputTargetGroup["+$inputTargetGroups[$i]+"].inputTargetItem[6000].inputGeomTarget");

		}

	if ($a==0)
		{
		floatSlider -e -en 1 asFaceBSFloatSlider;
		connectControl asFaceBSFloatSlider ("asFaceBS."+$targetName);
		}
	}

//$otherGeos to wrapInf eachothers MirrorDriver. e.g. leftEyeBrow wrapDrive rightEyeBrow
if (`gmatch $target "*_R*"`)
	for ($a=1;$a<size($geos);$a++)
		for ($b=1;$b<size($geos);$b++)
			{
			if ($a==$b)
				continue;

			$asFaceBS="asFaceBS_"+`substituteAllString $geos[$a] ":" "_"`;
			if (!`objExists $asFaceBS`)
				continue;
			$mirrorDriver=`substitute "_R" $target "_L"`+"_"+`substituteAllString $geos[$a] ":" "_"`+"MirrorDriver";
			$leftBDriver=`substitute "_R" $target "_L"`+"_"+`substituteAllString $geos[$b] ":" "_"`;
			if (!`objExists $mirrorDriver` || !`objExists $leftBDriver`)
				continue;
			setAttr ($asFaceBS+".envelope") 0;
			$tempString=`listConnections -s 1 -d 0 -p 1 ($mirrorDriver+".inMesh")`;
			connectAttr -f ($geos[$a]+".outMesh") ($mirrorDriver+".inMesh");

			select $leftBDriver;
			select -add $mirrorDriver;

			AddWrapInfluence;
			connectAttr -f $tempString[0] ($mirrorDriver+".inMesh");
			setAttr ($asFaceBS+".envelope") 1;
			}

if ($restorePoseCmd!="")
	eval($restorePoseCmd);

select $targetName;
if (size($geos)>1)
	select deleteThis;
}
 
global proc string[] asBSGetTargets ()
{
string $targets[];
string $tempString[],$tempString2[];

$tempString=`listAttr -m asFaceBS.weight`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*_L"`)
		continue;
	if (`gmatch $tempString[$i] "weight*"`)
		continue;
	$tempString2=`listConnections -scn 1 -s 1 -d 0 -type animCurve ("asFaceBS."+$tempString[$i])`;
	if ($tempString2[0]=="")
		continue;
	$targets[size($targets)]=$tempString[$i];
	}

return $targets;
}

global proc asBSNewTarget ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSMirror;
$asDSMessage="Create New BlendShape";
$asDSAttrName="";
$asDSObjName="";
string $side;
string $tempString[];
string $geometry=`textField -q -tx asFaceGeometryTextField`;
float $cheekPos[]=`xform -q -ws -t JawPivot`;

if (!`asConfirmIfNotInBuildPose`)
	return;

string $dialogResult=`layoutDialog -t "Confirm" -ui asDsLayout`;
if ($dialogResult!="OK")
	return;
if ($asDSAttrName=="") $asDSAttrName="Untitled";
if ($asDSObjName=="") $asDSObjName="ctrlUntitled";
if (`objExists $asDSObjName`)
	{
	if (`gmatch $asDSObjName "*_R"`) $side="_R";
	else $side="_M";
	}
else
	{
	if ($asDSMirror) $side="_R";
	else $side="_M";
	}
if (`objExists $asDSAttrName`)
	error ("Object \""+$asDSAttrName+"\" Already Exists");

if (`objExists deleteThis`)
	delete deleteThis;

$targetName=$asDSAttrName;
$driverName=$asDSObjName;

//	duplicate -n ($targetName+$side) $geometry;
	//duplicate geo causes onFace ctrls to move (due to wrapDeformer confused when duplicating driver, and moving copy), so instead create mesh
	$tempString[0]=`createNode mesh`;
	$tempString=`listRelatives -p $tempString[0]`;
	rename $tempString[0] ($targetName+$side);
	connectAttr ($geometry+".outMesh") ($targetName+$side+".inMesh");
	refresh;
	disconnectAttr ($geometry+".outMesh") ($targetName+$side+".inMesh");
	sets -e -forceElement initialShadingGroup ($targetName+$side);

asLockAttr ($targetName+$side) 0 0 0 0;
createNode -n deleteThis transform;
parent ($targetName+$side) deleteThis;
$tempString=`listRelatives -s ($targetName+$side)`;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		delete $tempString[$i];
move -r ($cheekPos[0]*2.5) 0 0 ($targetName+$side);

//Mirrored target
if ($side=="_R")
  {
  refresh;
  duplicate -n ($targetName+"_L") ($targetName+$side);
  move -r ($cheekPos[0]*-5) 0 0 ($targetName+"_L");

  duplicate -n ($targetName+"_LMirrorDriver") ($targetName+"_L");
  setAttr ($targetName+"_LMirrorDriver.sx") -1;
  setAttr ($targetName+"_LMirrorDriver.v") 0;

  select -r ($targetName+"_L") ($targetName+"_LMirrorDriver");
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
  connectAttr -f ($targetName+$side+".outMesh") ($targetName+"_LMirrorDriver.inMesh");
  }

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1 && $side=="_M") break;
	if ($b==-1 && $side=="_R")
		{
		$side="_L";
		$driverName=`substitute "_R" $driverName "_L"`;
		}

	if (!`objExists $driverName`)
		{
		$driverName=$asDSObjName+$side;
		$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r 0.1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
		rename $tempString[0] $driverName;
		parent $driverName ctrlBox;
		$tempString=`listRelatives -s $driverName`;
		setAttr ($tempString[0]+".overrideEnabled") 1;
		setAttr ($tempString[0]+".overrideColor") 13;
		xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $driverName;
		if ($side!="_M") setAttr ($driverName+".tx") ($cheekPos[0]*0.2*$b);
		}
	if (!`attributeExists $targetName $driverName`)
		addAttr -k 1 -ln $targetName -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $driverName;
	
	blendShape -e -tc 0 -t $geometry `getAttr -s asFaceBS.w` ($targetName+$side) 1 asFaceBS;
	setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($driverName+"."+$targetName) ("asFaceBS."+$targetName+$side);
	setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 10 -cd ($driverName+"."+$targetName) ("asFaceBS."+$targetName+$side);
	selectKey -add -k -f 0 -f 10 ("asFaceBS_"+$targetName+$side);
	setInfinity -pri cycleRelative -poi cycleRelative;

	string $setAttrCmdExtra="setAttr "+$driverName+"."+$targetName+" 0;";
	setAttr -type "string" faceBuildPose.udAttr (`getAttr faceBuildPose.udAttr`+$setAttrCmdExtra);
	}

select $driverName;
}

global proc asFaceConvertControlToSoftMod ()
{
global string $gSoftMod;
int $b=1;
int $falloffMode=1;
float $falloffRadius=1;
float $currentTime=`currentTime -q`;
string $sel[]=`ls -sl`;
string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`gmatch $rootLevelObjects[$i] "convertedSoftModHandle_*"`)
		error "Already converted to SoftMod, now you can edit the softMod if you wish, then click \"done\" to convert back to controller";
if (!size($sel))
	error "Nothing selected, must select a control first";
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a face control";
float $t[3]=`getAttr ($sel[0]+".t")`;
float $r[3]=`getAttr ($sel[0]+".r")`;
float $s[3]=`getAttr ($sel[0]+".s")`;
currentTime -e 0;
float $ctrlScale=`getAttr upperFaceOffset_M.sx`;
string $tempString[];
tokenize $sel[0] "_" $tempString;
string $fitJoint=$tempString[0];
string $side="_"+$tempString[1];
string $deformJoint=$fitJoint+"Joint"+$side;
string $falloffCurveString;
if ($side=="_L")
	error "must be Right side";
if ($side=="_R")
	$b=-1;

$tempString=`listConnections -s 0 -d 1 -type skinCluster $deformJoint`;
string $skinCluster=$tempString[0];
if ($skinCluster=="")
	error "This controller can not be converted to SoftMod";
$tempString=`listConnections -s 0 -d 1 -type mesh $skinCluster`;
string $geometry=$tempString[0];

if (`attributeExists falloffRadius $fitJoint`) $falloffRadius=`getAttr ($fitJoint+".falloffRadius")`;
else if (`attributeExists falloffRadius $sel[0]`) $falloffRadius=`getAttr ($sel[0]+".falloffRadius")`;
if (`attributeExists falloffMode $fitJoint`) $falloffMode=`getAttr ($fitJoint+".falloffMode")`;
if (`attributeExists falloffCurve $fitJoint`) $falloffCurveString=`getAttr ($fitJoint+".falloffCurve")`;

setAttr ($skinCluster+".envelope") 0;
float $pos[3]=`xform -q -ws -t $sel[0]`;

//select -r ClustersRegion;
select $geometry;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ("convertedSoftMod_"+$sel[0])`;
string $softModHandle=`rename $tempString[1] ("convertedSoftModHandle_"+$sel[0])`;
$tempString=`listConnections ($softMod+".message")`;
string $softModSet=$tempString[0];
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]) $pos[1] $pos[2];
xform -piv ($pos[0]) $pos[1] $pos[2] $softModHandle;
xform -ws -t ($t[0]*$ctrlScale*$b) ($t[1]*$ctrlScale) ($t[2]*$ctrlScale) -ro $r[0] ($r[1]*$b) ($r[2]*$b) -s $s[0] $s[1] $s[2] $softModHandle;

if (`attributeExists falloffRadius $fitJoint`) connectAttr ($softMod+".falloffRadius") ($fitJoint+".falloffRadius");
else if (`attributeExists falloffRadius $sel[0]`) connectAttr ($softMod+".falloffRadius") ($sel[0]+".falloffRadius");

if ($falloffCurveString!="")
	evalEcho (`substituteAllString $falloffCurveString "TempSoftMod" $softMod`);

select $softModHandle;
setToolTo $gSoftMod;
currentTime -e $currentTime;
}

global proc asFaceConvertSoftModBackToControl ()
{
global string $gSelect;
setToolTo $gSelect;
int $b=1;
float $currentTime=`currentTime -q`;
string $sel[]=`ls -sl`;
currentTime -e 0;
string $tempString[];

if (!`gmatch $sel[0] "convertedSoftModHandle_*"`)
	error "convertedSoftModHandle not selected";
tokenize $sel[0] "_" $tempString;
$fitJoint=$tempString[1];
$side="_"+$tempString[2];
string $deformJoint=$fitJoint+"Joint"+$side;
string $ctrl=$fitJoint+$side;
if ($side=="_R")
	$b=-1;

float $t[3]=`getAttr ($sel[0]+".t")`;
float $r[3]=`getAttr ($sel[0]+".r")`;
float $s[3]=`getAttr ($sel[0]+".s")`;
float $pos[3]=`xform -q -ws -piv $sel[0]`;

xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $sel[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $ctrl;

string $softMod=`substitute "Handle" $sel[0] ""`;
float $falloffRadius=`getAttr ($softMod+".falloffRadius")`;
duplicate -n tempSoftModCopy $softMod;
delete $sel[0];

$tempString=`listConnections -s 0 -d 1 -type skinCluster $deformJoint`;
string $skinCluster=$tempString[0];
$tempString=`listConnections -s 0 -d 1 -type mesh $skinCluster`;
string $geometry=$tempString[0];

select $ctrl;
setAttr ($skinCluster+".envelope") 1;
skinPercent -tv $deformJoint 0 $skinCluster $geometry;
asSkinWeightBySoftMod $deformJoint $geometry $skinCluster $falloffRadius 1;

if ($side=="_R" && `objExists ($fitJoint+"_L")`)
	{
	skinPercent -tv  ($fitJoint+"Joint_L") 0 $skinCluster $geometry;
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

xform -ws -t $pos[0] $pos[1] $pos[2] $ctrl;
xform -os -ro $r[0] ($r[1]*$b) ($r[2]*$b) -s $s[0] $s[1] $s[2] $ctrl;

currentTime -e $currentTime;
}

global proc asUnlockAllInfluences (string $skinCluster)
{
string $tempString[]=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".liw") 0;
}

global proc asFaceConvertFaceSetup ()
{
global string $gMainProgressBar;
int $drawStyle,$hasConvertedToBlendShapes,$numChar,$scHistNr,$isEyeLash;
//int $keepBSTarget=`checkBox -q -v asFaceSimplifiedKeepBSTargetsCheckBox`;
int $values[]={1,-1};
int $vtxNrs[];
float $posA[],$posB[],$weights[];
float $value,$jointWeight,$falloffRadius;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $upperTeeth=`textField -q -tx asFaceUpperTeethTextField`;
string $lowerTeeth=`textField -q -tx asFaceLowerTeethTextField`;
string $tongue=`textField -q -tx asFaceTongueTextField`;
string $name,$inOut,$side,$existingCmd,$newCmd,$eyeLashObj,$eyeBrowsObj,$lowerTeethName,$tongueName,$object,$sc,$objType;
string $upperLower,$upperLowerOpposite,$layer,$addInfCmd,$dialogResult,$eyeLidLayerGeo,$eyeLidLayerSc;
string $tempString[],$tempString2[],$tempString3[],$targets[],$allFaceGeo[],$attrs[],$eyeLashObjs[],$eyeBrowsObjs[];
string $scJoints[],$ctrls[],$regions[],$sides[],$infJoints[],$historyNodes[];
string $asFaceBSs[]=`ls -type blendShape "asFaceBS*"`;
string $upMidLo[]={"upper","middle","lower"};
string $objs[]={"ctrlEye_R","ctrlEye_L"};
string $trs[]={"t","r","s"};
string $xy[]={"x","y"};
string $xyz[]={"x","y","z"};
string $XYZ[]={"X","Y","Z"};
string $eyeBrows[]={"EyeBrowInner"};
for ($a=1;$a<4;$a++)
	if (`objExists ("EyeBrowMid"+$a)`)
		$eyeBrows[size($eyeBrows)]=("EyeBrowMid"+$a);
$eyeBrows[size($eyeBrows)]="EyeBrowOuter";
if (`objExists EyeBrowMiddle`)
$eyeBrows[size($eyeBrows)]="EyeBrowMiddle";
//string $noseLocs[]={"NoseSide","NoseUnder","NoseMiddle","Nostril","NoseCorner","Nose","CheekRaiser","Cheek"};
string $noseLocs[]={"NoseSide","NoseUnder","NoseMiddle","Nostril","NoseCorner","Nose"};
string $eyeLidDroopyCtrs[]={"upperLidDroopy","upperInnerLidDroopy","innerLidDroopy","lowerInnerLidDroopy",
	"lowerLidDroopy","lowerOuterLidDroopy","outerLidDroopy","upperOuterLidDroopy"};
int $tempInts[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInts[0];
int $autoKeyState=`autoKeyframe -q -state`;
float $builtVersion=`getAttr FaceGroup.version`;
float $currentVersion=`asGetScriptVersion`;

if ($currentVersion!=$builtVersion)
	if (`confirmDialog -t "Confirm"
				-m ("Current version ("+$currentVersion+")\n"
					+"Does not match the rig version ("+$builtVersion+")\n"
					+"This will prabably not work.\n\n"
					+"Either ReBuild the Face with current version,\n"
					+"or run \"Convert FaceSetup\" with AdvancedSkeleton v"+$builtVersion)
				-b "Ok, Cancel" -db "Ok, Cancel"
				-b "Continue anyway" -ds "Cancel"`!="Continue anyway")
					return;

if (!`objExists upperFaceJointOffset_M`)
	error "Already converted to SimplifiedFaceSetup.";

if ($autoKeyState)
	autoKeyframe -state 0;
//limits seem to cause Maya2016 to crash
int $limitsOn=`getAttr ctrlBox.limits`;
if ($limitsOn)
	setAttr ctrlBox.limits 0;

progressBar -e -st "Baking FaceSetup" -bp -ii 1 -min 0 -max 18 $gMainProgressBar;
progressBar -e -s 1 $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);

for ($i=0;$i<size($asFaceBSs);$i++)
	{
	$targets=`listAttr -m ($asFaceBSs[$i]+".weight")`;
	for ($y=0;$y<size($targets);$y++)
		{
		$tempString=`listConnections ($asFaceBSs[$i]+"."+$targets[$y])`;
		if (!size($tempString))
			catchQuiet (`setAttr -l 1 ($asFaceBSs[$i]+"."+$targets[$y]) 0`);
		}
	}

//If not converted to BlendShapes, we delete asFaceBS
$tempString=`listAttr -ud asFaceBS`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "converted*ToBlendShapes"`)
		$hasConvertedToBlendShapes=1;
if (!$hasConvertedToBlendShapes)
	delete asFaceBS;

//faceRegion
$regions={"EyeBrow","Eye","Nose","Lip"};
$sides={"_R","_L","_M"};
for ($i=0;$i<size($regions);$i++)
	for ($a=0;$a<size($sides);$a++)
		{
		$tempString[0]=$regions[$i]+"RegionOffset"+$sides[$a];
		if (`objExists $tempString[0]`)
			delete $tempString[0];
		$tempString[0]=$regions[$i]+"RegionJointOffset"+$sides[$a];
		if (`objExists $tempString[0]`)
			delete $tempString[0];
		}

//Create New Face_M;
rename Face_M FacePreSimplified_M;
select -cl;
joint -n Face_M;
parent Face_M $headJoint;
setAttr -type float3 Face_M.t 0 0 0;
setAttr Face_M.segmentScaleCompensate 0;
connectAttr ctrlBox.jointsVis Face_M.v;

//Add FacePreSimplified_M as infl, tp get correct asSkinWeightMerge
skinCluster -e -ai FacePreSimplified_M -lw false -wt 0 $skinCluster;

//`clean` the skinCLuster plugs, with a new SkinCluster
$historyNodes=`listHistory -pdo 1 -il 2 $geometry`;
for ($i=0;$i<size($historyNodes);$i++)
	if ($historyNodes[$i]==$skinCluster)
		$scHistNr=$i;
duplicate -n asFaceWeightHolder $geometry;
parent -w asFaceWeightHolder;
$infJoints=`listConnections ($skinCluster+".matrix")`;
select $infJoints asFaceWeightHolder;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] asFaceWeightHolderSC;
select $geometry asFaceWeightHolder;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete $skinCluster;
select $infJoints $geometry;
$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
rename $tempString[0] $skinCluster;
select asFaceWeightHolder $geometry;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete asFaceWeightHolder;
//restore deformationOrder
if ($historyNodes[0]!=$skinCluster)
	reorderDeformers $historyNodes[$scHistNr-1] $skinCluster $geometry;

//UpMidLo
progressBar -e -s 1 $gMainProgressBar;
asUnlockAllInfluences $skinCluster;
for ($i=0;$i<size($upMidLo);$i++)
	{
	rename ($upMidLo[$i]+"FaceJoint_M") ($upMidLo[$i]+"FaceJointOld_M");
	select Face_M;
	joint -n ($upMidLo[$i]+"FaceJoint_M");
	parentConstraint ($upMidLo[$i]+"Face_M") ($upMidLo[$i]+"FaceJoint_M");
	connectAttr ($upMidLo[$i]+"Face_M.sx") ($upMidLo[$i]+"FaceJoint_M.sx");
	connectAttr ($upMidLo[$i]+"Face_M.sy") ($upMidLo[$i]+"FaceJoint_M.sy");
	connectAttr ($upMidLo[$i]+"Face_M.sz") ($upMidLo[$i]+"FaceJoint_M.sz");
	skinCluster -e -ai ($upMidLo[$i]+"FaceJoint_M") -lw false -wt 0 $skinCluster;
	}
select UpMidLoLayer $geometry;
asSkinWeightMerge UpMidLoSC $skinCluster $headJoint;
select $geometry;
catchQuiet (`skinPercent -tv FacePreSimplified_M 0 $skinCluster`);

//other objects that might be using UpMidLo
for ($i=0;$i<size($asFaceBSs);$i++)
	{
	if ($asFaceBSs[$i]=="asFaceBS")
		continue;
	$tempString=`listHistory -f 1 $asFaceBSs[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString[0]=$tempString[$y];
			break;
			}
	$tempString=`listRelatives -p $tempString[0]`;
	$object=$tempString[0];
	if ($object==$upperTeeth || $object==$lowerTeeth || $object==$tongue)
		continue;
	$tempString=`listHistory -pdo 1 -il 2 $object`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]`=="skinCluster")
			$sc=$tempString[$y];
	catchQuiet (`skinCluster -e -ai upperFaceJoint_M -ai middleFaceJoint_M -ai lowerFaceJoint_M -lw false -wt 0 $sc`);
	select $geometry $object;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}

//transfer Jaw weights
progressBar -e -s 1 $gMainProgressBar;
asUnlockAllInfluences $skinCluster;
parent JawJointOffset_M lowerFaceJoint_M;
skinCluster -e -ai JawJoint_M -lw true -wt 0 $skinCluster;
select JawLayer $geometry;
asSkinWeightMerge JawSC $skinCluster $headJoint;
select $geometry;
catchQuiet (`skinPercent -tv FacePreSimplified_M 0 $skinCluster`);

//Eyes
//delete Eye_R_scaleConstraint1 Eye_L_scaleConstraint1;
for ($b=1;$b>-2;$b=$b-2)
	{
	$side="_R";
	if ($b==-1) $side="_L";

	parent ("Eye"+$side) upperFaceJoint_M;
	setAttr ("Eye"+$side+".segmentScaleCompensate") 0;
	$tempString=`listRelatives -p ("Eye"+$side)`;
	if (`gmatch $tempString[0] "transform*"`)
		rename $tempString[0] ("EyeOffset"+$side);
	if (`objExists ("PupilFfd"+$side)`) delete ("PupilFfd"+$side);
	if (`objExists ("IrisFfd"+$side)`) delete ("IrisFfd"+$side);
	if (`attributeExists pupil ("ctrlEye"+$side)`) deleteAttr ("ctrlEye"+$side+".pupil");
	if (`attributeExists iris ("ctrlEye"+$side)`) deleteAttr ("ctrlEye"+$side+".iris");
	}

//EyeBrows
progressBar -e -s 1 $gMainProgressBar;
asUnlockAllInfluences $skinCluster;
for ($b=1;$b>-2;$b=$b-2)
	{
	$side="_R";
	if ($b==-1) $side="_L";

	for ($c=0;$c<size($eyeBrows);$c++)
		{
		if (`gmatch $eyeBrows[$c] "*Middle*"`)
			{
			if ($b==1) $side="_M";
			if ($b==-1) continue;			
			}

		parent ($eyeBrows[$c]+"JointOffset"+$side) upperFaceJoint_M;
		catchQuiet (`skinCluster -e -ai ($eyeBrows[$c]+"Joint"+$side) -lw true -wt 0 $skinCluster`);
		}
	}
select EyeBrowLayer $geometry;
asSkinWeightMerge EyeBrowSC $skinCluster $headJoint;
select $geometry;
catchQuiet (`skinPercent -tv FacePreSimplified_M 0 $skinCluster`);

//nose
progressBar -e -s 1 $gMainProgressBar;
asUnlockAllInfluences $skinCluster;
$tempString=`listConnections ($skinCluster+".matrix")`;
for ($c=0;$c<size($noseLocs);$c++)
	{
	for ($b=1;$b>-2;$b=$b-2)
		{
		if ($b==1) $side="_R";
		else $side="_L";
		if ($noseLocs[$c]=="Nose" || $noseLocs[$c]=="NoseUnder" || $noseLocs[$c]=="NoseMiddle")
			{
			if ($b==1) $side="_M";
			else continue;
			}
		if (!`objExists $noseLocs[$c]`)
			continue;	
		parent ($noseLocs[$c]+"JointOffset"+$side) middleFaceJoint_M;
		catchQuiet (`skinCluster -e -ai ($noseLocs[$c]+"Joint"+$side) -lw true -wt 0 $skinCluster`);
		}
	}
select NoseLayer $geometry;
asSkinWeightMerge NoseSC $skinCluster $headJoint;
select $geometry;
catchQuiet (`skinPercent -tv FacePreSimplified_M 0 $skinCluster`);

//EyeLids
progressBar -e -s 1 $gMainProgressBar;
asUnlockAllInfluences $skinCluster;
parent LidJoints_R LidJoints_L upperFaceJoint_M;
//addInf all in in go, faster then individually
$tempString=`listRelatives -c -type joint LidJoints_R LidJoints_L`;
$addInfCmd="skinCluster -e ";
for ($i=0;$i<size($tempString);$i++)
	$addInfCmd+=" -ai "+$tempString[$i];
$addInfCmd+=" -ai LidJoints_R";
$addInfCmd+=" -ai LidJoints_L";
$addInfCmd+=" -lw true -wt 0 "+$skinCluster;
eval ($addInfCmd);

select EyeLidLayer $geometry;
asSkinWeightMerge EyeLidSC $skinCluster $headJoint;

for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Droopy*"`)
		setAttr ($tempString[$i]+".liw") 0;
$tempString=`listRelatives -ad -type joint Face_M`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*EyeBrow*"`)
		setAttr ($tempString[$i]+".liw") 1;
select $geometry;
catchQuiet (`skinPercent -tv FacePreSimplified_M 0 $skinCluster`);

//Lip
progressBar -e -s 1 $gMainProgressBar;
asUnlockAllInfluences $skinCluster;
parent LipJoints_M lowerFaceJoint_M;
parent LipSetup LipPuckerSetup FaceDeformationSystem;
setAttr -l 1 LipSetup.v 0;
setAttr -l 1 LipPuckerSetup.v 0;
//addInf all in in go, faster then individually
$tempString=`listRelatives -ad -type joint LipJoints_M`;
$addInfCmd="skinCluster -e ";
for ($i=0;$i<size($tempString);$i++)
	$addInfCmd+=" -ai "+$tempString[$i];
$addInfCmd+=" -lw true -wt 0 "+$skinCluster;
eval ($addInfCmd);

select LipLayer $geometry;
asSkinWeightMerge LipSC $skinCluster $headJoint;
select $geometry;
catchQuiet (`skinPercent -tv FacePreSimplified_M 0 $skinCluster`);


//LipPull, SmileBulge, FrownBulge, Cheek, CheekRaiser ( 10% )
$ctrls={"LipPull","SmileBulge","FrownBulge","Cheek","CheekRaiser"};
for ($i=0;$i<size($ctrls);$i++)
	{
	parent ($ctrls[$i]+"JointOffset_R") ($ctrls[$i]+"JointOffset_L") Face_M;
	//lock weights;
	for ($b=1;$b>-2;$b=$b-2)
		{
		$side="_R";
		if ($b==-1) $side="_L";

		catchQuiet (`skinCluster -e -ai ($ctrls[$i]+"Joint"+$side) -lw false -wt 0 $skinCluster`);
		clear $vtxNrs;
		clear $weights;
		for ($y=0;$y<$numVtx;$y++)
			{
			$layer=$ctrls[$i]+"Layer";
			$sc=$ctrls[$i]+"SC";
			if ($ctrls[$i]=="LipPull") {$sc="SmilePullSC";$layer="SmilePullLayer";}
			if ($ctrls[$i]=="FrownBulge") {$sc="CheekRaiserSC";$layer="CheekRaiserLayer";}
			$jointWeight=`skinPercent -ignoreBelow 0.001 -t ($ctrls[$i]+"Joint"+$side) -q -v $sc ($layer+".vtx["+$y+"]")`*0.1;
			if ($jointWeight>0)
				{
				$vtxNrs[size($vtxNrs)]=$y;
				$weights[size($weights)]=$jointWeight;
				}
			}
		progressBar -e -s 1 $gMainProgressBar;
		asSkinWeightSet ($ctrls[$i]+"Joint"+$side) $geometry $skinCluster $vtxNrs $weights;
		asFaceSetExpMult $ctrls[$i] $side;
		}
	}

//mouthNarrow
for ($b=1;$b>-2;$b=$b-2)
	{
	$side="_R";
	if ($b==-1) $side="_L";

	parent ("MouthNarrowJointOffset"+$side) lowerFaceJoint_M;
	parent ("LipJointsNarrow"+$side) ("MouthNarrowJoint"+$side);
	}
//for NonSym faces to not get "centerVtx" left behind
parent LipJointsNarrow_M MouthNarrowJoint_R;

//Lips follow jaw
createNode -n lowerJawFollowOffset_M -p JawJoint_M transform;
createNode -n lowerJawFollow_M -p lowerJawFollowOffset_M transform;
createNode -n lowerJawHalfFollow_M -p lowerJawFollowOffset_M transform;
parent lowerJawFollowOffset_M LipPuckerSetup;
parent lowerSqueezeTYOffset_M lowerJawFollow_M;
parent LipPuckerOffset_R LipPuckerOffset_L lowerJawHalfFollow_M;
for ($y=0;$y<size($trs);$y++)
	{
	if ($trs[$y]!="s")
		{
		createNode -n ("lowerJawHalfFollow"+$trs[$y]+"MPD") multiplyDivide;
		setAttr ("lowerJawHalfFollow"+$trs[$y]+"MPD.input2") -type float3 0.5 0.5 0.5;
		}
	for ($z=0;$z<size($xyz);$z++)
		{
		connectAttr ("JawJoint_M."+$trs[$y]+$xyz[$z]) ("lowerJawFollow_M."+$trs[$y]+$xyz[$z]);
		if ($trs[$y]!="s")
			{
			connectAttr ("JawJoint_M."+$trs[$y]+$xyz[$z]) ("lowerJawHalfFollow"+$trs[$y]+"MPD.input1"+$XYZ[$z]);
			connectAttr ("lowerJawHalfFollow"+$trs[$y]+"MPD.output"+$XYZ[$z]) ("lowerJawHalfFollow_M."+$trs[$y]+$xyz[$z]);
			}
		else
			connectAttr ("JawJoint_M.s"+$xyz[$z]) ("lowerJawHalfFollow_M.s"+$xyz[$z]);
		}
	}


//EyeLid rig to follow head
createNode -n FaceDeformationFollowUpperFace -p FaceDeformationSystem transform;
setAttr -l 1 FaceDeformationFollowUpperFace.v 0;
parentConstraint upperFaceJoint_M FaceDeformationFollowUpperFace;
scaleConstraint upperFaceJoint_M FaceDeformationFollowUpperFace;
$tempString=`listRelatives -c -type transform FaceDeformationSetups`;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="EyeSetup")
		continue;
	parent $tempString[$i] FaceDeformationFollowUpperFace;
	}

//other object `skinWeightedToFace` (e.g eyeBrows)
SelectAllGeometry;
$tempString=`ls -sl`;
select -cl;
$skinClusterJoints=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($tempString);$i++)
	{
	$object=$tempString[$i];
	select $object;
	if (!`attributeExists skinWeightedToFace $object`)
		continue;
	$tempString2=`ls -l $object`;
	if (`gmatch $tempString2[0] "*|DeformationLayers|*"`)
		continue;
	$tempString2=`listHistory -pdo 1 -il 2 $object`;
	for ($y=0;$y<size($tempString2);$y++)
		if (`nodeType $tempString2[$y]`=="skinCluster")
			{
			$sc=$tempString2[$y];
			$scJoints=`listConnections ($sc+".matrix")`;
			break;
			}
	for ($y=0;$y<size($scJoints);$y++)
		setAttr ($scJoints[$y]+".liw") 0;
	for ($y=0;$y<size($skinClusterJoints);$y++)
		{
		if ($skinClusterJoints[$y]==$headJoint)
			continue;
		if (`stringArrayCount $skinClusterJoints[$y] $scJoints`)
			continue;
		catchQuiet (`skinCluster -e -ai $skinClusterJoints[$y] -lw false -wt 0 $sc`);
		}
	select $geometry $object;
	catchQuiet (`copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint`);
	select $object;
	catchQuiet (`removeUnusedInfluences`);

	//Eyelash
	$isEyeLash=0;
	$name=`substitute ":" $object "_"`;
	$eyeLidLayerGeo="EyeLidLayer_"+$name;
	clear $tempString3;
	if (`objExists $eyeLidLayerGeo`)
		{
		$tempString2=`listHistory -pdo 1 -il 2 $eyeLidLayerGeo`;
		for ($y=0;$y<size($tempString2);$y++)
			if (`nodeType $tempString2[$y]`=="skinCluster")
				{
				$eyeLidLayerSc=$tempString2[$y];
				$tempString3=`listConnections ($eyeLidLayerSc+".matrix")`;
				break;
				}
		}
	for ($y=0;$y<size($tempString3);$y++)
		{
		if ($y>0)
			$isEyeLash=1;
	 if (!`gmatch $tempString3[$y] "upperLid*"` && !`gmatch $tempString3[$y] "lowerLid*"` && $tempString3[$y]!="Face_M" && $tempString3[$y]!="FacePreSimplified_M")
		 $isEyeLash=0;
		}
		if (`objExists ("EyeBrowLayer_"+$name)`)// not eyeLash, since eyeLash do not have this
			$isEyeLash=0;
	if ($isEyeLash)
		{
		select $eyeLidLayerGeo $object;
		catchQuiet (`copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint`);	
		}
	}

//unlock weights
asUnlockAllInfluences $skinCluster;

//Teeth/Tongue
if (`objExists upperTeethJoint_M`) parent upperTeethJoint_M lowerFaceJoint_M;
if (`objExists lowerTeethJoint_M`) parent lowerTeethJoint_M JawJoint_M;
if (`objExists Tongue0JointOffset_M`) parent Tongue0JointOffset_M JawJoint_M;

//parent constraint to ConstraintSystem to keep DeformationSystem as joints only
createNode -n FaceConstraintSystem -p FaceMotionSystem transform;
$tempString=`listRelatives -ad -type transform Face_M`;
for ($i=0;$i<size($tempString);$i++)
	{
	$objType=`objectType $tempString[$i]`;
	if (`gmatch $objType "*Constraint"`)
		parent $tempString[$i] FaceConstraintSystem;
	}

//update faceBuildPose
$existingCmd=`getAttr faceBuildPose.udAttr`;
$newCmd="";
tokenize $existingCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!catchQuiet (`eval ($tempString[$i])`))
		$newCmd+=$tempString[$i]+";";
setAttr -type "string" faceBuildPose.udAttr $newCmd;

//delete old Face joint & DeformationLayers
dgdirty -a;
delete FacePreSimplified_M;
delete DeformationLayers;
//delete asFaceBS_ blendshape (hair etc, bs to deformLayer)
if (!$hasConvertedToBlendShapes)
	{
	$tempString=`ls  -type blendShape "asFaceBS_*"`;
	if (size($tempString))
		delete $tempString;
	}

if ($limitsOn) setAttr ctrlBox.limits 1;
if ($autoKeyState) autoKeyframe -state 1;

select -cl;
print "// FaceSetup conversion complete.\n";
}

global proc asFaceSetExpMult (string $ctrl, string $side)
{
string $expNode=$ctrl+"JointDriveExp"+$side;
if (!`objExists $expNode`)
	return;
string $exp=`expression -q -s $expNode`;
$exp=`substitute ($ctrl+"Joint"+$side+".translateX=$tx;\n") $exp ($ctrl+"Joint"+$side+".translateX=$tx*10;\n")`;
$exp=`substitute ($ctrl+"Joint"+$side+".translateY=$ty;\n") $exp ($ctrl+"Joint"+$side+".translateY=$ty*10;\n")`;
$exp=`substitute ($ctrl+"Joint"+$side+".translateZ=$tz;\n") $exp ($ctrl+"Joint"+$side+".translateZ=$tz*10;\n")`;
expression -e -s $exp -o ($ctrl+"Joint") -ae 1 -uc all $expNode;
}

global proc asFaceRetopoBase ()
{
if (!`objExists FaceFitSkeleton`)
	error "FaceFitSkeleton not found, The Face>Fit section must be completed first";
float $pos[];
string $tempString[];
string $headJoint=`getAttr FaceFitSkeleton.HeadJoint`;
string $geometry=`getAttr FaceFitSkeleton.Geometry`;

if (`objExists faceCage`) delete faceCage;
string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
parent -w faceCage;
setAttr faceCage.v 1;
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

int $vtxs[]={0,1,2,3,4,5,6,7,8,9,
	10,11,12,13,
	14,16,17,18,20,21,
	22,23,
	24,25};
string $dests[]={"JawCurve.cv[3] ","Jaw","JawCorner","Throat","upperLipOuterCurve.cv[99]","lowerLipOuterCurve.cv[0]","JawPivot","Cheek","NoseCorner","NoseUnder",
	"CheekRaiser","upperLipOuterCurve.cv[0]","Nose",("lowerEyeLidOuterCurve.cv["+(`getAttr lowerEyeLidOuterCurve.spans`/2)+"]"),
	"lowerEyeLidOuterCurve.cv[0]","lowerEyeLidOuterCurve.cv[99]","EyeBrowMain3","EyeBrowMain0","EyeBrowMain6","EyeBrowOuterCurve.cv[99]",
	("upperEyeLidOuterCurve.cv["+(`getAttr upperEyeLidOuterCurve.spans`/2)+"]"),("EyeBrowOuterCurve.cv["+(`getAttr EyeBrowOuterCurve.spans`/2)+"]"),
	"EyeBrowOuterCurve.cv[0]","JawCurveTop.cv[3]"};
for ($i=0;$i<size($vtxs);$i++)
	{
	$pos=`xform -q -ws -t $dests[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] faceCage.vtx[$vtxs[$i]];
	}

$pos=`xform -q -ws -t faceCage.vtx[18]`; xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[19];

$posA=`xform -q -ws -t faceCage.vtx[12]`;
$posB=`xform -q -ws -t faceCage.vtx[19]`;
xform -ws -t 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) faceCage.vtx[15];

//cluster BeackHead
select -r faceCage.vtx[28:42] ;
$tempString=`newCluster " -envelope 1"`;
rename $tempString[0] backHeadCluster;
rename $tempString[1] backHeadClusterHandle;
$posA=`xform -q -ws -piv backHeadClusterHandle`;
$posB=`xform -q -ws -piv faceCage.vtx[33]`;
xform -piv 0 $posA[1] $posB[2];
setAttr -type float3 backHeadClusterHandleShape.origin 0 $posA[1] $posB[2];
$posA=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
$posB=`xform -q -ws -t JawCorner`;
$posC=`xform -q -ws -piv backHeadClusterHandle`;
move -r 0 ((($posA[1]+$posB[1])/2.0)-$posC[1]) 0 backHeadClusterHandle;
$posA=`xform -q -ws -t $headJoint`;
move -r 0 0 ($posA[2]-$posC[2]) backHeadClusterHandle;

//scale to match
$posA=`xform -q -ws -t JawPivot`;
$posB=`xform -q -ws -t faceCage.vtx[30]`;
$scaleX=$posA[0]/$posB[0];
$posA=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
$posB=`xform -q -ws -t JawCorner`;
$FaceFitHeight=$posA[1]-$posB[1];
$posA=`xform -q -ws -t faceCage.vtx[33]`;
$posB=`xform -q -ws -t faceCage.vtx[29]`;
$BackHeadHeight=$posA[1]-$posB[1];
$scaleY=$FaceFitHeight/$BackHeadHeight;
scale -r $scaleX $scaleY ($scaleX/1.5) backHeadClusterHandle;
//select faceCage;
//DeleteHistory;

//snap to surface
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($geometry+".outMesh") closestSampler.inMesh;
$posA=`xform -q -ws -t faceCage.vtx[14]`;
$posB=`xform -q -ws -t faceCage.vtx[12]`;
setAttr -type float3 closestSampler.inPosition 0 $posA[1] $posB[2];
$pos=`getAttr closestSampler.result.position`;
xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[15];

$posA=`xform -q -ws -t faceCage.vtx[15]`;
$posB=`xform -q -ws -t faceCage.vtx[12]`;
setAttr -type float3 closestSampler.inPosition 0 (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0);
$pos=`getAttr closestSampler.result.position`;
xform -ws -t 0 $pos[1] $pos[2] faceCage.vtx[26];

$pos=`xform -q -ws -t faceCage.vtx[10]`;
setAttr -type float3 closestSampler.inPosition ($pos[0]/2.0) $pos[1] $pos[2];
$pos=`getAttr closestSampler.result.position`;
xform -ws -t $pos[0] $pos[1] $pos[2] faceCage.vtx[27];

delete closestSampler;
print "// Face SkinCage created.\n";
}

global proc asFaceRetopoSections ()
{
float $pos[];
string $tempString[];
string $geometry=`getAttr FaceFitSkeleton.Geometry`;

if (`objExists topologyConstruction`) delete topologyConstruction;
if (!`objExists asRed`) asFitModeEnsureShaders;
createNode -n topologyConstruction transform;
asLockAttr topologyConstruction 1 1 1 1;

for ($a=0;$a<2;$a++)
	{
	if ($a==0) $lidLip="EyeLid";
	if ($a==1) $lidLip="Lip";

	addAttr -k 1 -dv 3 -ln ($lidLip+"Degree") -at "enum" -en "Linear=1:Cubic=3" topologyConstruction;
	addAttr -k 1 -dv 8 -ln ($lidLip+"UNumber") -at long topologyConstruction;
	addAttr -k 1 -dv 2 -ln ($lidLip+"VNumber") -at long topologyConstruction;

	for ($upperLowerFactor=1;$upperLowerFactor>-2;$upperLowerFactor=$upperLowerFactor-2)
		{
		if ($upperLowerFactor==1) $upperLower="upper";
		else $upperLower="lower";
		for ($b=0;$b<3;$b++)
			{
			if ($b==0) $outerMain="Outer";
			if ($b==1) $outerMain="Main";
			if ($b==2) $outerMain="Inner";

			rebuildCurve -n ($upperLower+$lidLip+$outerMain+"Curve2") -ch 0 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.000393701 ($upperLower+$lidLip+$outerMain+"Curve");
			setAttr ($upperLower+$lidLip+$outerMain+"Curve2.v") 0;
			parent ($upperLower+$lidLip+$outerMain+"Curve2") topologyConstruction;
			}
		select ($upperLower+$lidLip+"OuterCurve2") ($upperLower+$lidLip+"MainCurve2") ($upperLower+$lidLip+"InnerCurve2");
		$tempString=`loft -n ($upperLower+$lidLip+"Surface") -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true`;
		setAttr ($upperLower+$lidLip+"Surface.v") 0;
		rename $tempString[1] ($upperLower+$lidLip+"Loft");
		connectAttr ("topologyConstruction."+$lidLip+"Degree") ($upperLower+$lidLip+"Loft.degree");

		$tempString=`nurbsToPoly -n ($upperLower+$lidLip) -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.1 -ft 0.01 -mel 0.001 -d 0.1 -ut 2 -un 8 -vt 3 -vn 1 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 ($upperLower+$lidLip+"Surface")`;
		rename $tempString[1] ($upperLower+$lidLip+"NurbsTessellate");
		parent ($upperLower+$lidLip+"Surface") ($upperLower+$lidLip) topologyConstruction;

		connectAttr ("topologyConstruction."+$lidLip+"UNumber") ($upperLower+$lidLip+"NurbsTessellate.uNumber");
		connectAttr ("topologyConstruction."+$lidLip+"VNumber") ($upperLower+$lidLip+"NurbsTessellate.vNumber");
		sets -e -forceElement asRedSG ($upperLower+$lidLip);

		rename ($upperLower+$lidLip) ($upperLower+$lidLip+"_R");
		instance -n ($upperLower+$lidLip+"_L") ($upperLower+$lidLip+"_R");
		setAttr ($upperLower+$lidLip+"_L.scaleX") -1;
		}
	}

polyPlane -n NosePatch -w 1 -h 1 -sx 1 -sy 2 -ax 0 1 0 -cuv 2 -ch 0;
parent NosePatch topologyConstruction;
sets -e -forceElement asGreen2SG NosePatch;

$pos=`xform -q -ws -t NoseCorner`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[0:5];
$pos=`xform -q -ws -t NoseUnder`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[1];
$pos=`xform -q -ws -t Nose`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[3];

spaceLocator -n tempGeoSnapLoc;
geometryConstraint $geometry tempGeoSnapLoc;
$pos=`xform -q -ws -t Nose`; xform -ws -t $pos[0] $pos[1] $pos[2] tempGeoSnapLoc;
$posA=`xform -q -ws -t Nose`;
$posB=`xform -q -ws -t upperEyeLidOuterCurve.cv[0]`;
for ($i=0;$i<10;$i++)
	setAttr tempGeoSnapLoc.ty (($posA[1]+$posB[1])/2.0);
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[5];

$posA=`xform -q -ws -t Nose`;
$posB=`xform -q -ws -t NoseCorner`;
for ($i=0;$i<10;$i++)
	setAttr tempGeoSnapLoc.tx ($posB[0]/3.0);
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[4];
for ($i=0;$i<10;$i++)
	{
	setAttr tempGeoSnapLoc.ty (($pos[1]+$posB[1])/2.0);
	setAttr tempGeoSnapLoc.tx $posB[0];
	}
$pos=`xform -q -ws -t tempGeoSnapLoc`; xform -ws -t $pos[0] $pos[1] $pos[2] NosePatch.vtx[2];

rename NosePatch NosePatch_R;
instance -n NosePatch_L NosePatch_R;
setAttr NosePatch_R.scaleX -1;

delete tempGeoSnapLoc;
select topologyConstruction;
}

global proc asFaceDeleteSkinCage ()
{
delete faceCage;
}

global proc asEyeBallsChooseInput (string $textField)
{
string $sel[]=`ls -sl`;
string $txt=$sel[0];
if (size($sel)>1)
	for ($i=1;$i<size($sel);$i++)
		$txt+=" "+$sel[$i];
textField -e -tx $txt $textField;
asFaceUpdateInfo 0;
}

global proc asChooseInput (string $textField)
{
int $confirmed;
float $tempFloat[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $txt,$dialog,$m,$ffd;
string $sel[]=`ls -sl`;
string $restoreSel[]=$sel;
string $tempString[],$tempString2[],$selGeos[];

if (!`objExists FaceFitSkeleton`)
	error "FaceFitSkeleton not found, you must click \"Create Face FitSkeleton Node\" first.";

float $pos1[]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $pos2[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;

if (`gmatch $textField "*Joint*"`)
	{
	if (`objectType $sel[0]`!="joint")
		error "A joint must be selected";
	$txt=$sel[0];
	}
else
	{
	//Include children
	select -cl;
	string $children[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			select -add `listRelatives -ad -f -type transform $sel[$i]`;
	string $addedSel[]=`ls -sl`;
	$sel=`stringArrayCatenate $sel $addedSel`;
	$sel=`stringArrayRemoveDuplicates $sel`;

	//Not include non-mesh || non-nurbs (unless choose joint)
	string $shapes[];
	for ($i=0;$i<size($sel);$i++)
		if (!`gmatch $sel[$i] "*[.]*"`)
			{
			$nodeType="";
			$shapes=`listRelatives -s -ni -f $sel[$i]`;
			if (size($shapes))
				$nodeType=`nodeType $shapes[0]`;
			if ($nodeType=="nurbsSurface" || $nodeType=="mesh")
				$selGeos[size($selGeos)]=$sel[$i];
			}
	$txt=$selGeos[0];
	}
select $restoreSel;

if (size($selGeos)>1)
	for ($i=1;$i<size($selGeos);$i++)
		$txt+=" "+$selGeos[$i];

//FaceGeometry validate part1
if ($textField=="asFaceGeometryTextField" && $selGeos[0]!="")
	if (!`asModelCheck "Continue anyway"`)
		return;

//Everything must have skinCluster
string $skinCluster;
for ($i=0;$i<size($selGeos);$i++)
	{
	if ($textField=="asFaceHeadJointTextField")
		continue;
	$tempString=`listHistory $selGeos[$i]`;
	$skinCluster="";
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		{
		if ($dialog!="Create New SkinCluster")
			$dialog=`confirmDialog -t "Confirm"
			-m ("No SkinCluster found on this geometry:\n"+$selGeos[$i])
			-b "Create New SkinCluster" -db "Create New SkinCluster"
			-b "Cancel" -ds "Cancel"`;
		if ($dialog!="Create New SkinCluster")
			return;
		select -cl;
		if (!`objExists $headJoint`)
			{
			joint -n $headJoint;
			xform -ws -t 0 ($pos1[1]+(($pos2[1]-$pos1[1])/3.0)) 0 $headJoint;
			}
		textField -e -tx $headJoint asFaceHeadJointTextField;
		select $selGeos[$i] $headJoint;
		$tempString=`newSkinCluster "-toSelectedBones -mi 1 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		select $selGeos[$i];
		}
	if ($textField=="asFaceGeometryTextField")
		textField -e -tx $skinCluster asFaceSkinClusterTextField;
	}

//If there is a Lattice on the Eye, this might be for non-spherical eyes
if (`gmatch $textField "asFaceEye_*TextField"`)
	for ($i=0;$i<size($selGeos);$i++)
		{
		$tempString=`listHistory $selGeos[$i]`;
		$skinCluster="";
		for ($y=0;$y<size($tempString);$y++)
			{
			if (`objectType $tempString[$y]`=="ffd")
				$ffd=$tempString[$y];
			if (`objectType $tempString[$y]`=="skinCluster")
				$skinCluster=$tempString[$y];
			}
		if ($ffd!="")
			{
			if ($dialog!="Detected Lattice")
				$dialog=`confirmDialog -t "Confirm"
				-m ("Lattice detected.\nUse this Lattice for non-spherical eyes ?")
				-b "Yes" -db "Yes"
				-b "No" -ds "No"`;
			if ($dialog=="Yes")
				{
				$tempString=`listAttr -ud $ffd`;
				for ($y=0;$y<size($tempString);$y++)
					if (`gmatch $tempString[$y] "asNonSphereLattice_*"`)
						deleteAttr ($ffd+"."+$tempString[$y]);
				if ($textField=="asFaceEye_RTextField")
					addAttr -k 0 -ln asNonSphereLattice_R -at bool -dv true $ffd;
				if ($textField=="asFaceEye_LTextField")
					addAttr -k 0 -ln asNonSphereLattice_L -at bool -dv true $ffd;

				reorderDeformers $ffd $skinCluster $selGeos[$i];

				}
			}
		}

//FaceGeometry validate part2
if ($textField=="asFaceGeometryTextField" && $selGeos[0]!="")
	{
	//Auto weight head ? (check by see if any other then Head-joint are inf on the top 2/3 of verts in `FaceFitSkeleton-region`
	select $selGeos;
//	polySelectConstraint -m 3 -t 1 -d 3 -db 0 (((($pos2[1]-$pos1[1])/1.0)*2)/3.0) -dp 0 $pos2[1] 0 -da 0 1 0;
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($pos2[1]-$pos1[1])/1.0) -dp 0 $pos2[1] 0 -da 0 1 0;
	$tempString=`skinPercent -query -t $skinCluster`;
	$tempString2=`ls -sl`;
	polySelectConstraint -m 0;
	select $tempString2;
	refresh;
	if (size($tempString)>1 || $tempString[0]!=$headJoint)
		$dialog=`confirmDialog -t "Confirm"
				-m "Selected vertices are not fully weighted to the headjoint."
				-b "Weight face to headjoint" -db "Weight face to headjoint"
				-b "No, keep current weighting" -ds "Cancel"`;
				if ($dialog=="Weight face to headjoint")
					{
					print "// Weighting face to headjoint.\n";
					polySelectConstraint -m 3 -t 1 -d 3 -db 0 (($pos2[1]-$pos1[1])/1.0) -dp 0 $pos2[1] 0 -da 0 1 0;
					skinPercent -tv $headJoint 1 $skinCluster;
					polySelectConstraint -m 0;
					select $selGeos;
					asSmoothFlood $headJoint "" 3;
					}
	select $selGeos;
	}

if (!`objExists FaceFitSkeleton`)
	error "First Create Face FitSkeleton Node";

asFaceEnsureFitBase;

textField -e -tx $txt $textField;
//optionVar -sv $textField $txt;
asFaceUpdateInfo 0;
}

global proc asFaceAddIn (string $targets[], string $transform, int $mo)
{
string $trAddIn=$transform+"AddIn";
createNode -n $trAddIn transform;
string $tempString[]=`listRelatives -p $transform`;
parent $trAddIn $tempString[0];
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $trAddIn;
string $cmd="parentConstraint";
if($mo)
	$cmd+=" -mo";
for ($i=0;$i<size($targets);$i++)
	$cmd+=" "+$targets[$i];
$cmd+=" "+$trAddIn;
eval $cmd;

string $trs[]={"t","r"};
for ($i=0;$i<size($trs);$i++)
	{
	createNode -n ($trAddIn+$trs[$i]+"plusMinusAverage") plusMinusAverage;
	if ($trs[$i]=="s")
		setAttr ($trAddIn+$trs[$i]+"plusMinusAverage.operation") 3;
	connectAttr ($trAddIn+"."+$trs[$i]+"x") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dx");
	connectAttr ($trAddIn+"."+$trs[$i]+"y") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dy");
	connectAttr ($trAddIn+"."+$trs[$i]+"z") ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[0].input3Dz");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"x")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dx");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"y")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dy");
	connectAttr `listConnections -p 1 ($transform+"."+$trs[$i]+"z")` ($trAddIn+$trs[$i]+"plusMinusAverage.input3D[1].input3Dz");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dx") ($transform+"."+$trs[$i]+"x");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dy") ($transform+"."+$trs[$i]+"y");
	connectAttr -f ($trAddIn+$trs[$i]+"plusMinusAverage.output3Dz") ($transform+"."+$trs[$i]+"z");
	}
}

global proc float asFaceGetScale ()
{
float $scale=1.5;
if (`objExists FaceFitSkeletonHeightShape`)
    {
    float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
    float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
    $scale=$pos1[1]-$pos2[1];
   	}
return $scale;
}

global proc asCreateFaceFitJoint (string $region, float $size, int $color)
{
string $sel[]=`ls -sl -fl`;
float $pos[3]=`xform -q -ws -t $sel[0]`;
float $centerErrorMargin=0.001;
if ($region=="mouthUpper" || $region=="mouthLower" || $region=="eyeBrow0"
	|| `gmatch $region "*Middle"` || $region=="noseTip" || $region=="noseLower")
	if ($pos[0]>$centerErrorMargin || $pos[0]<(-1*$centerErrorMargin))
		error ($region+" needs to be in the center, currently:"+$pos[0]+"\n");
int $jointNumber;
string $jointName;
for ($i=1;$i<99;$i++)
	{
	$jointNumber=$i;
	$jointName=$region+$jointNumber;
	if (!`objExists $jointName`)
		break;
	}
asFaceEnsureFitBase;
for ($i=0;$i<size($sel);$i++)
	{
	$jointName=$region;
	if (size($sel)>1)
		$jointName=$region+$jointNumber;
	$jointNumber++;
	$jointName=`asFaceCreateFitJoint $jointName $size $color`;
	$pos=`xform -q -ws -t $sel[$i]`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $jointName;
	}

if (`checkBox -q -ex ("asFaceFit"+$region)`)
	checkBox -e -v 1 -ed 1 ("asFaceFit"+$region);
hilite -r `ls -o $sel`; 
select $sel;
repeatLast -addCommand ("asCreateFaceFitJoint "+$region+" "+$size+" "+$color);

if (`gmatch $region "eyeBrow[0-9]"`)
	asAutoEyeBrowFalloff $region;
}

global proc asAutoEyeBrowFalloff (string $region)
{
float $posA[3],$posB[3];
float $mag;
int $nr=`substring $region 8 8`;
string $previousRegion="eyeBrow"+($nr-1);
if (!`objExists $previousRegion`)
	return;
$posA=`xform -q -ws -t $region`;
$posB=`xform -q -ws -t $previousRegion`;
$mag=mag(<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>);
setAttr ($region+".falloffRadius") $mag;
float $previousRad=`getAttr ($previousRegion+".falloffRadius")`;
if ($mag>$previousRad || $previousRegion=="eyeBrow0")
	setAttr ($previousRegion+".falloffRadius") $mag;
}

global proc string asFaceCreateFitJoint (string $name, float $radius, int $color)
{
if (`objExists $name`)
	error ($name+" Already Exists");

if (!`objExists FaceFitFromSoftMods`)
	createNode -n FaceFitFromSoftMods -p FaceFitSkeleton transform;

select FaceFitFromSoftMods;
joint -n $name;
setAttr ($name+".overrideEnabled") 1;
setAttr ($name+".overrideColor") $color;
addAttr -k 1 -min 0 -dv $radius -ln "falloffRadius" -at double $name;
addAttr -k 1 -ln "falloffMode"  -at "enum" -en "volume:surface:" $name;
addAttr -k 1 -ln "interpolation"  -at "enum" -en "none:linear:smooth:spline:" $name;
if (`gmatch $name "lowerEye*"` || `gmatch $name "upperEye*"` || `gmatch $name "lowerLip*"` || `gmatch $name "upperLip*"`)
	;
else
	{
	setAttr ($name+".falloffMode") 1;
	setAttr ($name+".interpolation") 2;
	}
if (`gmatch $name "*Sculpt*"`)
	setAttr ($name+".falloffMode") 0;
return $name;
}

global proc asFaceUpdateInfo (int $read)
{
if (!`columnLayout -q -ex asColumnLayout`)
	return;
int $vtxsFromLipToNose=3;
int $vtxsFromLipCornerToNoseCorner=6;
int $stepBuild=0;
int $nextStep,$headerEn,$bodyEn,$m,$nonSymFace,$leftFaceFitting;
int $disableSteps[];
string $attrs[]={"Geometry","AllFaceGeo","Eye_R","Eye_L","UpperTeeth","LowerTeeth","Tongue",
	"EyeBrow_L","EyeBrow_R","EyeLash_L","EyeLash_R","HeadJoint","SkinCluster","NonSym","Pupil_R","Pupil_L","Iris_R","Iris_L"};
string $avaiableBuiltTypes[];
string $text,$obj,$fitType,$savedFitType,$leftSuffix,$parent,$stepBuildText;

if ($read)
	{
	if (`attributeExists NonSym FaceFitSkeleton`)
		{
		if (`getAttr FaceFitSkeleton.NonSym`!="")
			$nonSymFace=1;
		if (`getAttr FaceFitSkeleton.NonSym`=="Left")
			{
			$leftSuffix="Left";
			$leftFaceFitting=1;
			}
		}

	columnLayout -e -m $nonSymFace asFaceNonSymColumnLayout;
	checkBox -e -v $nonSymFace asFaceNonSymCheckBox;
	if ($nonSymFace)
		{
		if ($leftFaceFitting)
			frameLayout -e -l (" Fit                      (Left)") asFaceFitFrameLayout;
		else
			frameLayout -e -l (" Fit                      (Right)") asFaceFitFrameLayout;
		}
	else
		{
		frameLayout -e -l " Fit" asFaceFitFrameLayout;
		textField -e -tx "" asFaceNonSymTextField;
		}
	}
	
for ($i=0;$i<size($attrs);$i++)
	{
	string $texField="asFace"+$attrs[$i]+"TextField";
	if(!`textField -q -ex $texField`)
		continue;
	if ($read)
		{
		$text="";

		if ($attrs[$i]=="HeadJoint") $text="Head_M";
		if (`attributeExists $attrs[$i] FaceFitSkeleton`)
			$text=`getAttr ("FaceFitSkeleton."+$attrs[$i])`;
		textField -e -tx $text $texField;
		}
	else
		{
		if (!`attributeExists $attrs[$i] FaceFitSkeleton`)
			addAttr -ln $attrs[$i] -dt "string" FaceFitSkeleton;
		setAttr -type "string" ("FaceFitSkeleton."+$attrs[$i]) `textField -q -tx $texField`;
		}
	}

//Update CheckBoxes
string $checkBoxes[]=`lsUI -type checkBox`;
for ($i=0;$i<size($checkBoxes);$i++)
	{
	int $value=0;
	if (`gmatch $checkBoxes[$i] "asFaceFit*"`)
		{
		$obj=`substitute "asFaceFit" $checkBoxes[$i] "FaceFit"`+$leftSuffix;
		if (`objExists $obj`)
			$value=1;
		checkBox -e -ed $value -v $value $checkBoxes[$i];
		}
	//Not all checkBoxes to be used for Left side Fitting
	if (`gmatch $checkBoxes[$i] "asFaceFitLip*"` || $checkBoxes[$i]=="asFaceFitEyeBrowMiddle"
	 || $checkBoxes[$i]=="asFaceFitNose" || $checkBoxes[$i]=="asFaceFitNoseMiddle" || $checkBoxes[$i]=="asFaceFitNoseUnder"
	 || $checkBoxes[$i]=="asFaceFitJaw" || $checkBoxes[$i]=="asFaceFitThroat" || $checkBoxes[$i]=="asFaceFitTongue"
	 || $checkBoxes[$i]=="asFaceFitForeHead" || $checkBoxes[$i]=="asFaceFitJawCurves")
	 	{
		$parent=`checkBox -q -p $checkBoxes[$i]`;
		layout -e -en (!$leftFaceFitting) $parent;
		}
	}




//BuildStep
if (`attributeExists buildStep FaceFitSkeleton`)
	$stepBuild=`getAttr FaceFitSkeleton.buildStep`;
$nextStep=$stepBuild+1;
for ($i=0;$i<99;$i++)
	{
	if (!`columnLayout -q -ex ("asStepBuildColumnLayout"+$i)`)
		break;
	$headerEn=0;
	$bodyEn=0;
	$m=0;

	if ($i>($nextStep-2))
		$m=1;

	if (`text -q -ex ("stepBuild"+$i+"Text")`)
		{
		$stepBuildText=`text -q -l ("stepBuild"+$i+"Text")`;
		if (`gmatch $stepBuildText "*RebuildRestore"`)
			if (!`objExists prefix_FaceGroup`)
				$m=0;
		}

	if ($i==($nextStep-1))
			$bodyEn=1;
	if ($i==$nextStep)
			$headerEn=1;

	rowLayout -e -en $headerEn -m $m ("asStepBuildRowLayout"+$i);
	columnLayout -e -en $bodyEn -m $m ("asStepBuildColumnLayout"+$i);
	}

//vtxsFromLipToNose
if (`attributeExists vtxsFromLipToNose FaceFitSkeleton`)
	$vtxsFromLipToNose=`getAttr FaceFitSkeleton.vtxsFromLipToNose`;
if (`intField -q -ex lipFalloffOuterIntField`)
	intField -e -v $vtxsFromLipToNose lipFalloffOuterIntField;

//vtxsFromCornerLipToNoseCorner
if (`attributeExists vtxsFromLipCornerToNoseCorner FaceFitSkeleton`)
	$vtxsFromLipCornerToNoseCorner=`getAttr FaceFitSkeleton.vtxsFromLipCornerToNoseCorner`;
if (`intField -q -ex vtxsFromLipCornerToNoseCornerIntField`)
	intField -e -v $vtxsFromLipCornerToNoseCorner vtxsFromLipCornerToNoseCornerIntField;

//BuildType
if (`optionMenu -q -ex asFaceBuildTypeOptionMenu`)
	{
	$fitType="Full";
	if (`attributeExists buildType FaceFitSkeleton`)
		{
		$avaiableBuiltTypes=`optionMenu -q -ils asFaceBuildTypeOptionMenu`;
		$savedFitType=`getAttr FaceFitSkeleton.buildType`;
		if (`stringArrayCount $savedFitType $avaiableBuiltTypes`)
			$fitType=$savedFitType;
		}
	optionMenu -e -v $fitType asFaceBuildTypeOptionMenu;
	}
}

global proc asParentPingPong (string $pingPong, string $side, string $ctrlParent)
{
parent ($pingPong+"Offset"+$side) $ctrlParent;
setAttr -type float3 ($pingPong+"Offset"+$side+".s") 1 1 1;
setAttr -type float3 ($pingPong+"Offset"+$side+".r") 0 0 0;
setAttr -type float3 ($pingPong+"SideReverse"+$side+".s") 1 1 1;
}

global proc asPingPong (string $trnPos, string $name, int $b, string $side, int $type, int $createJoint, int $bindSkin)
{
int $mirrorMult;
float $ctrlScale=`getAttr upperFaceOffset_M.sx`;
float $maxZ;
float $bb[],$pos[];
string $exp,$flipStr,$scaleStr;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $curves[],$tempString[];
$pos=`xform -q -ws -t $trnPos`;

//nurbsSphere controller
asCreateFaceController $name $side $type;
xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"Offset"+$side);

if (`objExists ($name+"AttachCurve"+$side)`)
	{
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"AttachCurve"+$side+".cv[0:99]");
	parent ($name+"Attacher"+$side) SkinAttachCtrls;

	select ($name+"AttachCurve"+$side) SkinAttachMesh;
//	asCreateWrap (($name+"SkinAttachCtrlsWrap"+$side),0,0,1,0,0);//$threshold $maxDistance $exclusiveBind $autoWeightThreshold $falloffMode
	//chaning to non-exclusiveBind, as this initilaizes quicker.In the end this will be replaced by a single exclusiveBind Wrap node
	asCreateWrap (($name+"SkinAttachCtrlsWrap"+$side),0,0,0,0,0);//$threshold $maxDistance $exclusiveBind $autoWeightThreshold $falloffMode
	}

//Joint + Offset
if ($createJoint)
	{
	select -cl;
	createNode -n ($name+"JointOffset"+$side) transform;
	joint -n ($name+"Joint"+$side);
	parent ($name+"JointOffset"+$side) Face_M;
	setAttr ($name+"Joint"+$side+".segmentScaleCompensate") 0;
	xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ($name+"JointOffset"+$side);
	asFaceAddDrive ($name+"Joint") $side $name $side 1 {} {};
	asFaceAddDrive ($name+"Joint") $side ("SDK"+$name) $side 1 {} {};
	}
if ($bindSkin)
	{
	string $bindToSkinCluster=$skinCluster;
	skinCluster -e -ai ($name+"Joint"+$side) -lw false -wt 0 $skinCluster;
	}

//move curve cv`s to be `infront` of mesh
asFacePlaceCtrlByProjection ($name+$side);

select -cl;
refresh;
}

global proc asSoftCluster (string $name, string $side, string $geometry, float $pos[], float $falloffRadius, int $falloffMode)
{
string $tempString[];

select $geometry;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
$tempString=`listConnections ($softMod+".message")`;
rename $tempString[0] ($name+"SoftModSet");
setAttr -type float3 ($softModHandle+"Shape.origin") $pos[0] $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

select $geometry;
$tempString=`newCluster " -envelope 1"`;
rename $tempString[0] ($name+"Cluster"+$side);
rename $tempString[1] ($name+"ClusterHandle"+$side);
$tempString=`listRelatives -s ($name+"ClusterHandle"+$side)`;
rename $tempString[0] ($name+"ClusterHandleShape"+$side);
$tempString=`listConnections ($name+"Cluster"+$side+".message")`;
rename $tempString[0] ($name+"ClusterSet"+$side);
setAttr -type float3 ($name+"ClusterHandleShape"+$side+".origin") $pos[0] $pos[1] $pos[2];
xform -ws -piv $pos[0] $pos[1] $pos[2] ($name+"ClusterHandle"+$side);

}

global proc asFaceConnectAttr (string $source, string $dest)
{
int $b=1;
float $ctrlScale=`getAttr upperFaceOffset_M.sx`;
float $t[];
string $sourceName,$sourceSidem,$destName,$destSide;
string $tempString[];

tokenize $source "_" $tempString;
$sourceName=$tempString[0];
$sourceSide="_"+$tempString[1];
if ($sourceSide=="_R") $b=-1;

tokenize $dest "_" $tempString;
$destName=$tempString[0];
$destSide="_"+$tempString[1];

createNode -n ($destName+"PlusMinusAverage"+$destSide) plusMinusAverage;
$t=`getAttr ($dest+".t")`;
setAttr -type float3 ($destName+"PlusMinusAverage"+$destSide+".input3D[0]") $t[0] $t[1] $t[2];
connectAttr ($destName+"PlusMinusAverage"+$destSide+".output3D") ($dest+".t");

createNode -n ($destName+"DriveAddT"+$destSide) plusMinusAverage;
$t=`getAttr ($dest+".t")`;
connectAttr ($sourceName+$sourceSide+".t") ($destName+"DriveAdd"+$destSide+".input3D[0]");
if (`objExists ($sourceName+"Drive"+$sourceSide)`)
	connectAttr ($sourceName+"Drive"+$sourceSide+".t") ($destName+"DriveAdd"+$destSide+".input3D[1]");

createNode -n ($destName+$destSide+"MultiplyDivide") multiplyDivide;
setAttr -type float3 ($destName+$destSide+"MultiplyDivide.input1") ($ctrlScale*$b) $ctrlScale $ctrlScale;
connectAttr ($destName+"DriveAdd"+$destSide+".output3D") ($destName+$destSide+"MultiplyDivide.input2");
connectAttr ($destName+$destSide+"MultiplyDivide.output") ($destName+"PlusMinusAverage"+$destSide+".input3D[1]");
}

global proc asParentPingPongJoint (string $child, string $parent)
{
string $tempString[];
string $plusMinusAverage;

tokenize $child "_" $tempString;
$plusMinusAverage="";
if ($tempString[1]!="")
	$plusMinusAverage=$tempString[0]+"PlusMinusAverage_"+$tempString[1];
if (`objExists $plusMinusAverage`)
	{
	createNode -n tempXform transform;
	asAlign tempXform $child 1 1 0 0;
	parent tempXform $parent;
	}
parent $child $parent;
if (`objExists $plusMinusAverage`)
	{
	$pos=`getAttr tempXform.t`;
	setAttr -type float3 ($plusMinusAverage+".input3D[0]") $pos[0] $pos[1] $pos[2];
	delete tempXform;
	}
}

global proc asCreateFaceController (string $name, string $side, int $type)
{
int $color;
float $scale=`asFaceGetScale`/5.0;
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
float $radius=0.2;
string $letter;
string $tempString[];

if (`gmatch $name "*Droopy*"`)
	$type=3;
if ($type==1) $radius=0.3;
if ($type==3) $radius=0.1;

if ($type==1) {$letter="A";$color=14;}
if ($type==2) {$letter="B";$color=13;}
if ($type==3) {$letter="C";$color=6;}
if ($type==4) {$letter="Regions";$color=17;}
if ($type==5) {$letter="Custom";$color=28;}

$tempString=`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $radius -d 3 -ut 0 -s 8 -ch 0`;
//$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/15.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);

sets -add "FaceControlSet" ($name+$side);
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") $color;
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"SideReverse"+$side) -p ($name+"Offset"+$side) transform;
createNode -n ("SDK"+$name+$side) -p ($name+"SideReverse"+$side) transform;
//createNode -n ($name+"Drive"+$side) -p ($name+"SideReverse"+$side) transform;
//parent ($name+$side) ($name+"Drive"+$side);
parent ($name+$side) ($name+"SideReverse"+$side);
if ($side=="_R")
	setAttr ($name+"SideReverse"+$side+".sx") -1;

if ($type==1 || $type==2 || $type==3)
	{
	createNode -n ($name+"Attach"+$side) -p ($name+"Offset"+$side) transform;
	curve -n ($name+"AttachCurve"+$side) -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1;
	parent ($name+"AttachCurve"+$side) SkinAttachCtrls;
	createNode -n ($name+"Poci"+$side) pointOnCurveInfo;
	connectAttr -f ($name+"AttachCurve"+$side+".worldSpace[0]") ($name+"Poci"+$side+".inputCurve");
	createNode -n ($name+"Attacher"+$side) -p ($name+"Offset"+$side) transform;
	connectAttr -f ($name+"Poci"+$side+".position") ($name+"Attacher"+$side+".t");
	pointConstraint ($name+"Attacher"+$side) ($name+"Attach"+$side);

	parent ($name+"SideReverse"+$side) ($name+"Attach"+$side);
	createNode -n ($name+"Subtract"+$side) -p ($name+"SideReverse"+$side) transform;

	createNode -n ($name+"SubtractMultiplyDivide"+$side) multiplyDivide;
	connectAttr ($name+$side+".t") ($name+"SubtractMultiplyDivide"+$side+".input1");
	setAttr -type float3 ($name+"SubtractMultiplyDivide"+$side+".input2") -1 -1 -1;
	connectAttr ($name+"SubtractMultiplyDivide"+$side+".output") ($name+"Subtract"+$side+".t");

	parent ($name+$side) ($name+"Subtract"+$side);
	}
if ($type==4)
	{
	createNode -n ($name+"JointOffset"+$side) -p Face_M transform;
	joint -n ($name+"Joint"+$side);
	}

parent ($name+"Offset"+$side) ($letter+"controls");
setAttr -type float3 ($name+"Offset"+$side+".s") ($faceFitScale/10.0) ($faceFitScale/10.0) ($faceFitScale/10.0);
connectAttr ("ctrlBox."+$letter+"CtrlVis") ($name+$side+"Shape.overrideVisibility");
//connectAttr ("ctrlBox."+$letter+"CtrlColor") ($name+$side+"Shape.overrideColor");
}

global proc asFacePlaceCtrlByProjection (string $ctrl)
{
float $offset;
float $maxZ=-999;
float $bb[];
float $faceFitScale=`getAttr FaceFitSkeleton.sy`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[],$curves[];

$tempString=`polyProjectCurve -ch true -direction 0 0 1 -pointsOnEdges 0 -tolerance 0.01 $ctrl $geometry`;
$curves=`listRelatives -c -type transform $tempString[0]`;
for ($i=0;$i<size($curves);$i++)
	{
	$bb=`xform -q -ws -bb $curves[$i]`;
	if ($bb[5]>$maxZ)
		$maxZ=$bb[5];
	}
delete $tempString[0];
$pos=`xform -q -ws -t ($ctrl+".cv[0]")`;
move -r 0 0 ($maxZ-$pos[2]) ($ctrl+".cv[0:99]");

//extra forward offset, to avoid sinking into geo
$tempString=`listConnections -p 1 ($ctrl+"Shape.overrideVisibility")`;
tokenize $tempString[0] "[.]" $tempString;
$offset=0;
if ($tempString[1]=="ACtrlVis") $offset=$faceFitScale/100.0;
if ($tempString[1]=="BCtrlVis") $offset=$faceFitScale/90.0;
if ($tempString[1]=="CCtrlVis") $offset=$faceFitScale/80.0;
move -r 0 0 $offset ($ctrl+".cv[0:99]");
}

global proc softCluster (string $trnPos, string $name, int $b, string $side)
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $falloffRadius=`getAttr ($name+".falloffRadius")`;
float $falloffMode=`getAttr ($name+".falloffMode")`;
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
string $allFaceGeo[],$tempString[];
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];

if (!`objExists ClustersRegion`)
	{
	if (`objExists tempTargetFullMesh`)
		duplicate -n ClustersRegion tempTargetFullMesh;
	else
		duplicate -n ClustersRegion tempTarget;
	parent ClustersRegion DeformationLayers;
	sets -e -forceElement initialShadingGroup ClustersRegion;
	blendShape -e -tc 0 -t `textField -q -tx asFaceGeometryTextField` `getAttr -s asFaceBS.w` ClustersRegion 1 asFaceBS;
	setAttr asFaceBS.ClustersRegion 1;
	}

select $allFaceGeo;
float $scale=`asFaceGetScale`/3.0;
float $pos[3]=`xform -q -ws -t $trnPos`;
float $tempFloat[];
int $numVtxs[];
int $infNr;
float $value;
float $skinPercents[];
string $skinClusterInfs[];
string $oppositeSide;
select -r ClustersRegion;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;

string $softMod=`rename $tempString[0] ($name+"SoftMod"+$side)`;
string $softModHandle=`rename $tempString[1] ($name+"SoftModHandle"+$side)`;
$tempString=`listConnections ($name+"SoftMod"+$side+".message")`;
string $softModSet=`rename $tempString[0] ($name+"SoftModSet"+$side)`;
setAttr -type float3 ($softModHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
setAttr ($softMod+".falloffCenter") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $softModHandle;
setAttr ($softMod+".falloffRadius") $falloffRadius;
setAttr ($softMod+".falloffMode") $falloffMode;

asPingPong $name $name $b $side 8 0 0;
//setAttr ($name+$side+"Shape.overrideColor") `getAttr ($name+".overrideColor")`;
parent ($name+"Attach"+$side) Acontrols;

setAttr -type float3 ($softModHandle+".t") 1 0 0;
//softMod -e -pr fails in batch, when affecting multiple meshes
//no longer pruning , as this gets tricky when user want to paint outside prune area
//if (`getAttr ($name+".overrideColor")`!=9)
//	softMod -e -pr $softMod;
//changed:trying to bring back -pruning
	dgdirty -a;
if (`getAttr ($name+".overrideColor")`!=9) // Prune softMode does not work well with multiAffectedObjects
	{
	if (`asMayaVersionAsFloat`==2016) //2016 seem to need falloffMode==0, for pruning to work
		{
		setAttr ($softMod+".falloffMode") 0;
		softMod -e -pr $softMod;
		setAttr ($softMod+".falloffMode") $falloffMode;
		}
	else
		softMod -e -pr $softMod;
	}
$tempString=`listConnections ($softMod+".message")`;
select `sets -q $tempString[0]`;
string $vtxs[]=`ls -sl -fl`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;

$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
string $cluster=$tempString[0];
string $clusterHandle=$tempString[1];
$tempString=`listRelatives -s $clusterHandle`;
string $clusterHandleShape=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].inputGeometry")`;
string $clusterGroupParts=$tempString[0];
$tempString=`listConnections ($cluster+".input[0].groupId")`;
string $clusterGroupId=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
parent $clusterHandle ClusterSetup;
setAttr -type float3 ($clusterHandle+"Shape.origin") ($pos[0]*$b) $pos[1] $pos[2];
xform -piv ($pos[0]*$b) $pos[1] $pos[2] $clusterHandle;

asFaceSoftModToCluster $softMod $cluster $vtxs;
delete $softMod;

setAttr -l 1 ($clusterHandle+".v") 0;
connectAttr ($name+$side+".t") ($clusterHandle+".t");
connectAttr ($name+$side+".r") ($clusterHandle+".r");
connectAttr ($name+$side+".s") ($clusterHandle+".s");

//catch (`reorderDeformers $skinCluster $cluster $geometry`);
//catch (`reorderDeformers asFaceBS $cluster $geometry`);

if (`getAttr ($name+".overrideColor")`==9)
	{
	for ($i=0;$i<size($allFaceGeo);$i++)
		if ($allFaceGeo[$i]!="ClustersRegion")
			{
			int $haveSkinCluster=0;
			$historyNodes=`listHistory -pdo 1 $allFaceGeo[$i]`;
			for ($y=0;$y<size($historyNodes);$y++)
				if (`nodeType $historyNodes[$y]`=="skinCluster")
					{
					$haveSkinCluster=1;
					$skinCluster=$historyNodes[$y];
					}
			if ($haveSkinCluster)
				catch (`reorderDeformers $skinCluster $cluster $allFaceGeo[$i]`);
			}
	}
}

global proc asFaceSoftModToCluster (string $softMod, string $cluster, string $vtxs[])
{
string $tempString[]=`listConnections ($softMod+".matrix")`;
string $softModHandle=$tempString[0];
setAttr ($softModHandle+".ty") 1;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
string $componentType="vtx";

string $deformMeshs[]=`ls -o $vtxs`;
$deformMeshs=`stringArrayRemoveDuplicates $deformMeshs`;
string $deformXforms[];
for ($i=0;$i<size($deformMeshs);$i++)
	{
	$tempString=`listRelatives -p $deformMeshs[$i]`;
	$deformXforms[$i]=$tempString[0];
	}
setAttr ($softMod+".envelope") 0;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshA"+$i) $deformMeshs[$i];
setAttr ($softMod+".envelope") 1;
for ($i=0;$i<size($deformMeshs);$i++)
    duplicate -n ("tempMeshB"+$i) $deformMeshs[$i];
float $sofModDefaultPos[3]=`xform -q -os -piv $softModHandle`;
float $posA[3];
float $posB[3];
for ($i=0;$i<size($deformMeshs);$i++)
    {
		$componentType="vtx";
		if (`objectType $deformMeshs[$i]`=="lattice")
			$componentType="pt";
    string $historyNodes[]=`listHistory $deformMeshs[$i]`;
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 1;
    percent -v 0 $cluster ($deformMeshs[$i]+"."+$componentType+"[0:999999]");
    for ($y=0;$y<size($vtxs);$y++)
        {
        if (!`gmatch $vtxs[$y] ($deformXforms[$i]+"[.]"+$componentType+"*")`)
            continue;
        tokenize $vtxs[$y] "." $tempString;
        $posA=`xform -q -ws -t ("tempMeshA"+$i+"."+$tempString[1])`;
        $posB=`xform -q -ws -t ("tempMeshB"+$i+"."+$tempString[1])`;
        percent -v ($posB[1]-$posA[1]) $cluster $vtxs[$y];
        }
    for ($y=0;$i<size($historyNodes[$y]);$y++)
    	if (`getAttr -se ($historyNodes[$y]+".nodeState")`)
	    	setAttr ($historyNodes[$y]+".nodeState") 0;
     }
for ($i=0;$i<size($deformMeshs);$i++)
	delete ("tempMeshA"+$i) ("tempMeshB"+$i);
clear $vtxs;
}

global proc string asFaceMirror ()
{
string $restoreCmd,$oppositeControl;
int $autoKeyState=`autoKeyframe -q -state`;
if ($autoKeyState)
	autoKeyframe -state 0;
string $mirrorAttrs[]={"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
string $controls[]=`sets -q FaceControlSet`;
for ($i=0;$i<size($controls);$i++)
	{
	if (!`gmatch $controls[$i] "*_L"`)
		continue;
	for ($attr in $mirrorAttrs)
		{
		if (`getAttr -l ($controls[$i]+"."+$attr)`)
			continue;
		$oppositeControl=`substitute "_L" $controls[$i] "_R"`;
		$multiply=1;
		if ($attr=="tx" || $attr=="ry" || $attr=="rz")
			$multiply=-1;
	
		$restoreCmd+="setAttr "+$controls[$i]+"."+$attr+" "+`getAttr ($controls[$i]+"."+$attr)`+";";
		setAttr ($controls[$i]+"."+$attr) (`getAttr ($oppositeControl+"."+$attr)`*$multiply);
		}
	}
if ($autoKeyState)
	$restoreCmd+="autoKeyframe -state 1;";
return $restoreCmd;
}

global proc asFaceMirrorControllerWeights ()
{
string $sel[]=`ls -sl`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $error;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 Controller first";

if (!(`sets -im FaceControlSet` || `sets -im ControlSet`))
	error "Not a controller, as it is not a member of a controlset";
$tempString=`listConnections ($sel[0]+".s")`;
float $pos[]=`getAttr ($sel[0]+".t")`;
float $rot[]=`getAttr ($sel[0]+".r")`;
float $sca[]=`getAttr ($sel[0]+".s")`;
	asGoToBuildPose faceSetup;
if (`gmatch $tempString[0] "*Cluster*"`)
	{
	print "// Detected this controller to control a \"Cluster\", performing Mirror Cluster Weights\n";
	asFaceMirrorClusterWeight;
	}
else
	{
	copySkinWeights -ss $skinCluster -ds $skinCluster -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	print "Detected this controller to control a \"Joint\", performing Mirror Skin Weights";
	}
setAttr -type float3 ($sel[0]+".t") $pos[0] $pos[1] $pos[2];
setAttr -type float3 ($sel[0]+".r") $rot[0] $rot[1] $rot[2];
setAttr -type float3 ($sel[0]+".s") $sca[0] $sca[1] $sca[2];
select $sel;
}

global proc asFaceMirrorClusterWeight ()
{
string $sel[]=`ls -sl`;
if (!`sets -im FaceControlSet $sel[0]`)
	error "Selected object is not a faceControl";
string $control=$sel[0];

string $restorePoseCmd;
int $multiply;
int $numVtxs[]=`polyEvaluate -v ClustersRegion`;
float $maxDist,$mag;
float $posA[3],$posB[3],$tempFloat[];
string $tempString[],$rightVtxs[];
string $cluster=`substitute "_R" $control "Cluster_R"`;
string $oppositeControl=`substitute "_R" $control "_L"`;
string $oppositeCluster=`substitute "_R" $cluster "_L"`;
if (!`gmatch $control "*_R"` || !`objExists $oppositeCluster`)
	return;
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$cluster+"Set";
string $oppositeClusterSet=`substitute "_R" $clusterSet "_L"`;
if (!`objExists $oppositeClusterSet`)
	return;

//Start off by pruning
setAttr -type float3 ($control+".t") 1 0 0;
cluster -e -pr $cluster;
setAttr -type float3 ($control+".t") 0 0 0;

//Mirror pose before doing left to ensure identical attachment
string $restoreCmd=`asFaceMirror`;

percent -v 0 $oppositeCluster ("ClustersRegion.vtx[0:"+$numVtxs[0]+"]");
select `sets -q ($cluster+"Set")`;
$rightVtxs=`ls -sl -fl`;
$posA=`xform -q -ws -t $control`;
$maxDist=0;
for ($i=0;$i<size($rightVtxs);$i++)
	{
	$posB=`xform -q -ws -t $rightVtxs[$i]`;
	$mag=`mag <<($posA[0]-$posB[0]),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>$maxDist)
		$maxDist=$mag;
	}
$maxDist=$maxDist+($maxDist/20.0);

select ClustersRegion;
sets -add ($oppositeCluster+"Set") ClustersRegion;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $maxDist -dp ($posA[0]*-1) $posA[1] $posA[2];
string $vtxs[]=`ls -sl -fl`;
polySelectConstraint -m 0;
//sets -add ($oppositeCluster+"Set") $vtxs;
string $closestSampler=`createNode -n closestSampler closestPointOnMesh`;
$tempString=`listRelatives -ni -s ClustersRegion`;
connectAttr -f ($tempString[0]+".outMesh") ($closestSampler+".inMesh");
connectAttr -f ("ClustersRegion.worldMatrix[0]") ($closestSampler+".inputMatrix");
int $closestOppositeVtxNr;
global string $gMainProgressBar;
progressBar -e -st ("Mirroring Cluster for: "+$control) -bp -ii 1 -min 0 -max `size($vtxs)` $gMainProgressBar;
for ($i=0;$i<size($vtxs);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		break;
	progressBar -e -s 1 $gMainProgressBar;
	$posB=`xform -q -ws -t $vtxs[$i]`;
	setAttr -type float3 ($closestSampler+".inPosition") ($posB[0]*-1) $posB[1] $posB[2];
	$closestOppositeVtxNr=`getAttr ($closestSampler+".result.closestVertexIndex")`;
	$tempFloat=`percent -q -v $cluster ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`;

	if (!`sets -im $clusterSet ("ClustersRegion.vtx["+$closestOppositeVtxNr+"]")`)
		$tempFloat[0]=0;

	percent -v $tempFloat[0] $oppositeCluster $vtxs[$i];
	}
progressBar -e -ep $gMainProgressBar;
setAttr -type float3 ($oppositeControl+".t") 1 1 1;
cluster -e -pr $oppositeCluster;
setAttr -type float3 ($oppositeControl+".t") 0 0 0;
delete $closestSampler;

eval ($restoreCmd);
}

global proc asHelpImage (string $region)
{
string $asScriptLocation=`asGetScriptLocation`;
if (`window -q -ex faceHelpImage`)
	deleteUI faceHelpImage;
window faceHelpImage;
scrollLayout -w 666 -h 10;

if (`gmatch $region "*asBSWizardStep*"`)
	$region="asBSWizard/"+$region;

formLayout asHelpFormLayout;
image -i ($asScriptLocation+"/AdvancedSkeleton5Files/div/images/help/"+$region+".jpg") asHelpImage;

formLayout -e
	-af asHelpImage "right" 0
	-af asHelpImage "left" 0
	-af asHelpImage "top" 0
	-af asHelpImage "bottom" 0
	asHelpFormLayout;

//Video Link
string $helpUrl;
string $buttonLabel="Open Video Link";
if ($region=="asDeformSkinCageSliders")
	$helpUrl="https://youtu.be/uMaKwxKXygw";
if ($region=="asFitLabels")
	$helpUrl="https://youtu.be/fyR2szfj3z0";
if ($region=="asFitAttributes")
	$helpUrl="https://youtu.be/WgJsDv1ZdVs";
if ($region=="asDeformSkinCageDWidth")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=153";
if ($region=="asDeformSubWrapCage" || $region=="asDeformSubWrapWrap")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=280";
if ($region=="asDeformSkinLoopsCreate" || $region=="asDeformSkinLoopsSelectAll"
	|| $region=="asDeformSkinLoopsBind" || $region=="asDeformSkinLoopsCutUp")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=151";
if ($region=="asMotionCaptureReadBvh" || $region=="asMotionCaptureConnect")
	{
	$helpUrl="https://sites.google.com/a/cgspeed.com/cgspeed/motion-capture/cmu-bvh-conversion";
	$buttonLabel="Open Link";
	}
if ($region=="asGameSkeletonCreate" || $region=="asUnrealMannequinTransferSkin")
	{
	$helpUrl="https://youtu.be/fPX9gy2RrbA";
	$buttonLabel="Open Link";
	}
if ($region=="asCorrectiveShapesCreate")
	$helpUrl="https://youtu.be/YOIyFB2nK90";
if ($region=="asCorrectiveShapesBake")
	$helpUrl="https://youtu.be/xVLMwc1LU00?t=327";
if ($region=="faceFitSkeletonNode")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=357";
if ($region=="asEditBlendShapesCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=663";
if ($region=="asTweakControllersCreate")
	$helpUrl="https://youtu.be/BifesWXUNrU?t=743";
if ($region=="asSelectorDesigner")
	$helpUrl="https://youtu.be/0dpLmKZbEJc";
if ($region=="fitFaceMouthSculpt")
	$helpUrl="https://youtu.be/punjwECuUJM?t=282";
if ($region=="asPoserDesigner")
	{
	$helpUrl="http://www.studiolibrary.com/";
	$buttonLabel="Open Link";
	}
if ($region=="asWalkDesigner")
	$helpUrl="https://youtu.be/jMTfxKArl1Q";

if ($helpUrl!="")
	{
	string $button=`button -w 200 -h 50 -l $buttonLabel -c ("showHelp -a \""+$helpUrl+"\"")`;
	formLayout -e
		-af $button "top" 715
		-af $button "left" 220
		asHelpFormLayout;
	if ($region=="asFitLabels" || $region=="asFitAttributes") formLayout -e -af $button "top" 40  asHelpFormLayout;
	}
showWindow;
window -e -h 808 faceHelpImage;
}

global proc asFaceBsSdk (string $ctrl, float $driveValue, string $bs, float $drivenValue)
{
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl $driveValue;
setAttr $bs $drivenValue;
setDrivenKeyframe -itt spline -ott spline -currentDriver $ctrl $bs;
setAttr $ctrl 0;
if ($driveValue>0)
	keyTangent -in 0 -itt linear -ott linear $bs;

//pre post infinity
string $nodes[]=`listConnections -s 1 -d 0 -scn 1 $bs`;
for ($i=0;$i<size($nodes);$i++)
	{
	$tempString=`nodeType -inherited $nodes[$i]`;
	if ($tempString[0]=="animCurve")
		{
		setAttr ($nodes[$i]+".preInfinity") 4;
		setAttr ($nodes[$i]+".postInfinity") 4;
		}
	}
}

global proc float[] asGetMidHeadPos ()
{
float $midHeadPos[];
//first look for joints, as the fig might be from before faceFitScaleCurve came about
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
float $headPos[]=`xform -q -ws -t $headJoint`;
string $tempString[]=`listRelatives -c $headJoint`;
if(size($tempString))
	{
	$temp=`xform -q -ws -t $tempString[0]`;
	$midHeadPos[0]=(($headPos[0]+$temp[0])/2.0);
	$midHeadPos[1]=(($headPos[1]+$temp[1])/2.0);
	$midHeadPos[2]=(($headPos[2]+$temp[2])/2.0);
	}
if (`objExists FaceFitSkeletonHeightShape`)
	{
	float $pos1[]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[5]`;
	float $pos2[]=`xform -q -ws -t FaceFitSkeletonShape.cv[5]`;
	$midHeadPos={$headPos[0],($pos1[1]+$pos2[1])/2.0,$headPos[2]};
	}

return $midHeadPos;
}

global proc asFaceCreateCtrlBox (string $name, float $x, float $y, int $half)
{
float $scale;
$tempString=`duplicate -rc ctrlBoxTemplate`;
rename $tempString[0] ("ctrlBox"+$name);
rename $tempString[1] ("ctrl"+$name);
setAttr -type float3 ("ctrlBox"+$name+".t") $x $y 0;
//Maya2012 and before dont have minTrans$LimitEnable attrs
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".minTransYLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransXLimitEnable")`);
catchQuiet (`connectAttr -f ctrlBox.limits ("ctrl"+$name+".maxTransYLimitEnable")`);

if ($half)
	{
	float $pos0[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[0]")`;
	float $pos2[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[2]")`;
	float $pos3[]=`xform -q -ws -t ("ctrlBox"+$name+".cv[3]")`;
	if ($half==1)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[2]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos3[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[3]");
		transformLimits -tx -1 1 -ty 0 1 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	if ($half==2)
		{
		xform -ws -t $pos2[0] (($pos0[1]+$pos2[1])/2.0) $pos2[2] ("ctrlBox"+$name+".cv[1]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[0]");
		xform -ws -t $pos3[0] (($pos0[1]+$pos2[1])/2.0) $pos3[2] ("ctrlBox"+$name+".cv[4]");
		transformLimits -tx -1 1 -ty -1 0 -tz 0 0 -etz 1 1 ("ctrl"+$name);
		}
	}
}

global proc asRemoveInfluence (string $joint, string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
string $infJoints[]=`listConnections -s 1 -d 0 ($skinCluster+".matrix")`;
if (`stringArrayCount $joint $infJoints`)
	{
	skinCluster -e -ri $joint $skinCluster;
	//If no other influences, then remove skinCluster.
	if (size($infJoints)==1)
		delete $skinCluster;
	}
}

global proc asFaceSwitchSide (int $right)
{
//$right==2 = Off
int $vis;

if ($right==1)
	textField -e -tx "Right" asFaceNonSymTextField;
else if ($right==0)
	textField -e -tx "Left" asFaceNonSymTextField;
else if ($right==2)
	{
	asFaceSwitchSide 1;
	textField -e -tx "" asFaceNonSymTextField;
	asFaceUpdateInfo 0;
	asFaceUpdateInfo 1;
	return;
	}
asFaceUpdateInfo 0;

string $tempString[]=`listRelatives -c -type transform FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*Left"`)
		$vis=!$right;
	else
		$vis=$right;
	setAttr ($tempString[$i]+".v") $vis;
	}
asFaceUpdateInfo 1;
}

global proc asFaceShowBothSides ()
{
string $tempString[]=`listRelatives -c -type transform FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;
}

global proc asBuildFitEyeBall ()
{
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $eyeGeoText=`textField -q -tx asFaceEye_RTextField`;
string $dialog="OK";
string $leftSuffix;
if (`attributeExists NonSym FaceFitSkeleton`)
	if (`getAttr FaceFitSkeleton.NonSym`=="Left")
		{
		$leftSuffix="Left";
		$eyeGeoText=`textField -q -tx asFaceEye_LTextField`;
		}
string $tempString[],$tempString2[],$eyeGeos[];
if ($eyeGeoText=="")
	error "No Eye Geometry choosen";
if (`objExists ("FitEyeBall"+$leftSuffix)`)
	error ("FitEyeBall"+$leftSuffix+" already exists");
int $hadBodyEye=0;
float $pos[],$rot[];
if (`objExists FKEye_R`)
	{
	if (!`objExists headTopology`)
		$dialog=`confirmDialog -t "Confirm"
			-m "This will replace the Eyes from the Body-setup"
			-b "OK" -db "OK"
			-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		return;
	$hadBodyEye=1;
	string $skinClusters[]=`ls -type skinCluster`;
	for ($i=0;$i<size($skinClusters);$i++)
		{
		//rare case, the EyeEnd joints could be bound, )doing Jaw-end check&remove here too)
		if (`objExists EyeEnd_R`) asRemoveInfluence EyeEnd_R $skinClusters[$i];
		if (`objExists EyeEnd_L`) asRemoveInfluence EyeEnd_L $skinClusters[$i];
		if (`objExists JawEnd_M`) asRemoveInfluence JawEnd_M $skinClusters[$i];
		//First add Head as inf (if Eye is only inf), since having none inf`s breaks the skinCluster
		$tempString=`listConnections ($skinClusters[$i]+".matrix")`;
		if (size($tempString)==1 && `gmatch $tempString[0] "Eye_*"`) {
			skinCluster -e -ai $headJoint -lw false -wt 1 $skinClusters[$i];
			print ("skinCluster -e -ai "+$headJoint+" -lw false -wt 1 "+$skinClusters[$i]+";\n");
			}
		if (`objExists Eye_R`) asRemoveInfluence Eye_R $skinClusters[$i];
		if (`objExists Eye_L`) asRemoveInfluence Eye_L $skinClusters[$i];
		}
	$pos=`xform -q -ws -t Eye_R`;
	$rot=`xform -q -ws -ro Eye_R`;
	if (`objExists FKOffsetEye_R`) delete FKOffsetEye_R;
	if (`objExists FKOffsetEye_L`) delete FKOffsetEye_L;
	if (`objExists FKAimEye_R`) delete FKAimEye_R;
	if (`objExists FKAimEye_L`) delete FKAimEye_L;
	if (`objExists Eye_R`)delete Eye_R;
	if (`objExists Eye_L`) delete Eye_L;
	if (`objExists AimEye`) delete AimEye;
	if (`objExists Eye`) delete Eye;
	asRemoveUnusedfromBuildPose bodySetup;
	}
float $height=10;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
asFitModeEnsureShaders;
spaceLocator -n ("FitEyeBall"+$leftSuffix);
addAttr -ln version -at double ("FitEyeBall"+$leftSuffix);
setAttr -l 1 ("FitEyeBall"+$leftSuffix+".version") `asGetScriptVersion`;
setAttr ("FitEyeBall"+$leftSuffix+".rotateOrder") 2;
setAttr -l 1 ("FitEyeBall"+$leftSuffix+".rz");
setAttr -type float3 ("FitEyeBall"+$leftSuffix+"Shape.localScale") 1.5 1.5 1.5;
createNode -n ("FaceFitEyeBall"+$leftSuffix) -p FaceFitSkeleton transform;
parent ("FitEyeBall"+$leftSuffix) ("FaceFitEyeBall"+$leftSuffix);
polySphere -n ("FitEyeSphere"+$leftSuffix) -r 0.5 -sx 8 -sy 8 -ax 0 1 0 -cuv 2 -ch 0;
setAttr ("FitEyeSphere"+$leftSuffix+".overrideEnabled") 1;
setAttr ("FitEyeSphere"+$leftSuffix+".overrideDisplayType") 2;
parent ("FitEyeSphere"+$leftSuffix) ("FitEyeBall"+$leftSuffix);
sets -e -forceElement asWhiteSG ("FitEyeSphere"+$leftSuffix);
sets -e -forceElement asBlackSG ("FitEyeSphere"+$leftSuffix+".f[56:63]");
setAttr -type float3 ("FitEyeSphere"+$leftSuffix+".r") 90 0 0;
setAttr -type float3 ("FitEyeBall"+$leftSuffix+".s") (0.025*$height) (0.025*$height) (0.025*$height);

if ($hadBodyEye)
	{
	xform -ws -t $pos[0] $pos[1] $pos[2] -ro ($rot[2]-180) ($rot[1]-90) 0 ("FitEyeBall"+$leftSuffix);
	}
else
	{
	$pos=`xform -q -ws -t $headJoint`;
	xform -ws -t $pos[0] $pos[1] $pos[2] ("FitEyeBall"+$leftSuffix);
	setAttr -type float3 ("FitEyeBall"+$leftSuffix+".t") ($pos[1]/-50.0) ($pos[1]/15.0) ($pos[1]/15.0);
	}

//guestimate placement (and scale) based upon 1st selected geo
tokenize $eyeGeoText $tempString;
for ($i=0;$i<size($tempString);$i++)
	if (!`gmatch $tempString[$i] "*[.]*"`)
		$eyeGeos[size($eyeGeos)]=$tempString[$i];
if (size($eyeGeos))
	{
	$tempString=`duplicate -n tempEye $eyeGeos[0]`;
	$tempString2=`listRelatives -p $tempString[0]`;
	if ($tempString2[0]!="")
		$tempString=`parent -w $tempString[0]`;
	select $tempString[0];
	CenterPivot;
	float $pos[]=`xform -q -ws -piv $tempString[0]`;
	float $bb[]=`xform -q -ws -bb $tempString[0]`;
	delete $tempString[0];
	if ($pos[1]>0)
		{
		parent -w ("FitEyeBall"+$leftSuffix);
		if (!$hadBodyEye)
			xform -ws -t $pos[0] $pos[1] $pos[2] ("FitEyeBall"+$leftSuffix);
		xform -os -s ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ($bb[4]-$bb[1]) ("FitEyeBall"+$leftSuffix);
		parent ("FitEyeBall"+$leftSuffix) ("FaceFitEyeBall"+$leftSuffix);
		}
//	if ($leftSuffix=="Left")
//		setAttr ("FitEyeBall"+$leftSuffix+".tx") (`getAttr ("FitEyeBall"+$leftSuffix+".tx")`*-1);
	}


select ("FitEyeBall"+$leftSuffix);
print ("// FitEyeBall"+$leftSuffix+" created, place this to match the eye-ball of your character\n");
checkBox -e -ed 1 -v 1 asFaceFitEyeBall;
}

global proc asFaceEnsureFitBase ()
{
if (!`objExists FaceFitSkeleton`)
	asCreateFaceFitSkeleton;
}

global proc asFaceEnsureShaders ()
{
string $colors[]={"asFaceBlue","asFaceBrown","asFaceGreen","asFaceCyan","asFaceRed"};
float $rs[]={0.0,0.541,0.000,0.0,0.4};
float $gs[]={0.0,0.282,0.275,0.5,0};
float $bs[]={1.0,0.200,0.098,0.5,0};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".ambientColor") $rs[$i] $gs[$i] $bs[$i];
	setAttr -type float3 ($colors[$i]+".incandescence") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asFaceEnsureAdvancedBase ()
{
asFaceEnsureShaders;
string $sel[]=`ls -sl`;
if (!`objExists FaceGroup`)
	error "FaceGroup does not exists, must build a Fit-system first";
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
string $tempString[];
if (!`objExists $headJoint`)
	error ("HeadJoint: \""+$headJoint+"\" Does not exists");
if (`objExists FaceMotionSystem`)
	setAttr FaceMotionSystem.v 1;
if (`objExists FaceMotionSystem`)
	return;

//top level nodes
createNode -n FaceMotionSystem -p FaceGroup transform;
createNode -n FaceMotionFollowHead -p FaceMotionSystem transform;
createNode -n ControlsSetup -p FaceMotionFollowHead transform;
createNode -n FaceDeformationSystem -p FaceGroup transform;
createNode -n DeformationLayers -p FaceDeformationSystem transform;
createNode -n FaceDeformationSetups -p FaceDeformationSystem transform;
setAttr -l 1 FaceDeformationSetups.v 0;
//setAttr -l 1 FaceDeformationSystem.v 0;
createNode -n FaceDeformationSystemFollowHead -p FaceDeformationSystem transform;
//setAttr -l 1 FaceDeformationSystemFollowHead.v 0;
createNode -n Acontrols -p ControlsSetup transform;
createNode -n Bcontrols -p ControlsSetup transform;
createNode -n Ccontrols -p ControlsSetup transform;
createNode -n Aimcontrols -p ControlsSetup transform;
createNode -n Regionscontrols -p ControlsSetup transform;
createNode -n Customcontrols -p ControlsSetup transform;

createNode -n FaceBuildInProgress transform;
setAttr FaceBuildInProgress.v 0;

createNode -n SkinAttachCtrls -p FaceDeformationSetups transform;
duplicate -n SkinAttachMesh $geometry;
parent SkinAttachMesh SkinAttachCtrls;
setAttr -l 1 SkinAttachMesh.v 0;
select $geometry SkinAttachMesh;
blendShape -n SkinAttachMeshBS -w 0 1;

createNode -n MainAndHeadScaleMultiplyDivide multiplyDivide;
connectAttr ($headJoint+".scale") MainAndHeadScaleMultiplyDivide.input1;
if (`objExists Main`)
	connectAttr Main.scale MainAndHeadScaleMultiplyDivide.input2;

for ($i=1;$i<99;$i++)
	{
	if (!`objExists ("MainExtra"+$i)`)
		break;
	createNode -n ("MainAndHeadScaleMultiplyDivide"+$i) multiplyDivide;
	if ($i==1)
		connectAttr Main.scale ("MainAndHeadScaleMultiplyDivide"+$i+".input1");
	else
		connectAttr ("MainAndHeadScaleMultiplyDivide"+($i-1)+".output") ("MainAndHeadScaleMultiplyDivide"+$i+".input1");
	connectAttr ("MainExtra"+$i+".scale") ("MainAndHeadScaleMultiplyDivide"+$i+".input2");
	connectAttr -f ("MainAndHeadScaleMultiplyDivide"+$i+".output") MainAndHeadScaleMultiplyDivide.input2;
	}

pointConstraint $headJoint FaceMotionFollowHead;
orientConstraint -mo $headJoint FaceMotionFollowHead;
//scaleConstraint $headJoint FaceMotionFollowHead;
connectAttr MainAndHeadScaleMultiplyDivide.output FaceMotionFollowHead.s;

pointConstraint $headJoint FaceDeformationSystemFollowHead;
orientConstraint -mo $headJoint FaceDeformationSystemFollowHead;

//faceBuildPose
if (!`objExists faceBuildPose`)
	{
	createNode -n faceBuildPose dagPose;
	addAttr -ln udAttr -dt "string"  faceBuildPose;
	}

//Sets
select -cl;
sets -name FaceAllSet;
sets -name FaceControlSet;
sets -em -n FaceAreas;
if (`objExists "Sets"`)
	{
	sets -add "Sets" FaceAllSet;
	sets -add "Sets" FaceControlSet;
	sets -add "Sets" FaceAreas;
	}
sets -em -n FaceBuildingSets;
sets -add FaceAllSet FaceBuildingSets;
sets -add FaceBuildingSets allBeforeFaceBuild;


select $sel;
}

global proc asFaceDeltaMush ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $tempString[];

if (!`exists deltaMush`)
	error "DeltaMush not avaiable in this version of Maya";
if (`objExists asFaceDeltaMush`)
	error "asFaceDeltaMush already exists";

select $geometry;
$tempString=`deltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1`;
rename $tempString[0] asFaceDeltaMush;
$tempString=`listConnections asFaceDeltaMush.message`;
rename $tempString[0] asFaceDeltaMushSet;

asConnectDeltaMushScale;
select $geometry;
print "// DeltaMush applied\n";
}

global proc asFaceDeltaMushZeroWeight ()
{
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $historyNodes[];

if (`objExists asFaceDeltaMush`)
	{
	evalEcho "percent -v 0 asFaceDeltaMush";
	return;
	}
$historyNodes=`listHistory -pdo 1 -il 2 $geometry`;
for ($i=0;$i<size($historyNodes);$i++)
	if (`objectType $historyNodes[$i]`=="deltaMush")
		evalEcho ("percent -v 0 "+$historyNodes[$i]);
}

global proc asAdvancedSquash ()
{
global string $gSelect;
setToolTo $gSelect;
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
float $scale=`asFaceGetScale`/3.0;
float $value,$min,$max;
float $pos[3],$pos2[3];
string $name;
string $tempString[],$allFaceGeo[],$historyNodes[],$infs[];
string $allFaceGeoString=`textField -q -tx asFaceAllFaceGeoTextField`;
tokenize $allFaceGeoString $tempString;
for ($i=0;$i<size($tempString);$i++)
	$allFaceGeo[$i]=$tempString[$i];
string $allBefore[]=`ls`;
string $faceControlSetMembers[]=`sets -q FaceControlSet`;

//squashHead
waitCursor -st 1;
float $squashTopPos[3]=`xform -q -ws -t FaceFitSkeletonHeightShape.cv[0]`;
float $squashBasePos[3]=`xform -q -ws -t FaceFitSkeletonShape.cv[0]`;
float $BaseToTopY=$squashTopPos[1]-$squashBasePos[1];

createNode -n SquashSetup -p FaceMotionSystem transform;
$tempString[0]=`curve -d 1 -p 1 1 1 -p 1 -1 1 -p -1 -1 1 -p -1 1 1 -p 1 1 1 -p 1 1 -1 -p 1 -1 -1 -p 1 -1 1 -p 1 -1 -1 -p -1 -1 -1 -p -1 1 -1 -p 1 1 -1 -p -1 1 -1 -p -1 1 1 -p -1 -1 1 -p -1 -1 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
rename $tempString[0] squashTop_M;
setAttr squashTop_MShape.overrideEnabled 1;
setAttr squashTop_MShape.overrideColor 13;
createNode -n squashTopOffset transform;
parent squashTop_M squashTopOffset;
xform -ws -t 0 $squashTopPos[1] 0 squashTopOffset;
xform -ws -s ($scale/0.75) ($scale/5.0) ($scale/5.0) squashTop_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashTop_M;
sets -add "FaceControlSet" squashTop_M;
duplicate -n SquashControls squashTopOffset;
rename SquashControls|squashTop_M squashBase_M;
xform -ws -t 0 $squashBasePos[1] 0 SquashControls;
duplicate -n squashMiddleOffset squashTopOffset;
rename squashMiddleOffset|squashTop_M squashMiddle_M;
xform -ws -t 0 (($squashBasePos[1]+$squashTopPos[1])/2) 0 squashMiddleOffset;
scale -r 1.5 1 1 squashMiddle_M;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 squashMiddle_M;
parent squashTopOffset squashMiddleOffset squashBase_M;

addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 squashTop_M;
createNode -n squashTopVolumeUC unitConversion;
setAttr squashTopVolumeUC.conversionFactor 0.1;
connectAttr squashTop_M.volume squashTopVolumeUC.input;

setAttr -l 1 -k 0 squashTop_M.rx;setAttr -l 1 -k 0 squashTop_M.ry;setAttr -l 1 -k 0 squashTop_M.rz;
setAttr -l 1 -k 0 squashTop_M.sx;setAttr -l 1 -k 0 squashTop_M.sy;setAttr -l 1 -k 0 squashTop_M.sz;
setAttr -l 1 -k 0 squashTop_M.v;
setAttr -l 1 -k 0 squashMiddle_M.rx;setAttr -l 1 -k 0 squashMiddle_M.ry;setAttr -l 1 -k 0 squashMiddle_M.rz;
setAttr -l 1 -k 0 squashMiddle_M.sx;setAttr -l 1 -k 0 squashMiddle_M.sy;setAttr -l 1 -k 0 squashMiddle_M.sz;
setAttr -l 1 -k 0 squashMiddle_M.v;
setAttr -l 1 -k 0 squashBase_M.sx;setAttr -l 1 -k 0 squashBase_M.sy;setAttr -l 1 -k 0 squashBase_M.sz;
setAttr -l 1 -k 0 squashBase_M.v;

select $allFaceGeo;
//Do not include wrapped on`s or wired on`s  (e.g eyebrows)
for ($i=0;$i<size($allFaceGeo);$i++)
	{
	$historyNodes=`listHistory -f 0 -pruneDagObjects 1 -lv 4 $allFaceGeo[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`objectType $historyNodes[$y]`=="wrap" || `objectType $historyNodes[$y]`=="wire")
			select -d $allFaceGeo[$i];
	}

$tempString=`lattice  -divisions 2 11 2 -objectCentered true  -ldv 2 2 2`;
rename $tempString[0] squashFfd;
rename $tempString[1] squashFfdLattice;
rename $tempString[2] squashFfdBase;
$tempString=`listConnections squashFfd.message`;
rename $tempString[0] squashFfdSet;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdLattice;
xform -ws -t 0 (($squashTopPos[1]+$squashBasePos[1])/2) 0 squashFfdBase;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdLattice;
xform -s $BaseToTopY $BaseToTopY $BaseToTopY squashFfdBase;
scale -r 1.25 1.25 1.25 squashFfdLattice;
scale -r 1.25 1.25 1.25 squashFfdBase;
setAttr "squashFfd.outsideLattice" 1;
parent squashFfdBase squashBase_M;
createNode -n squashXup transform;
setAttr -type float3 squashXup.r 90 0 90;
select squashXup;
$pos=`xform -q -ws -t squashFfdLattice.pt[0][1][1]`;
joint -n squashIKX0 -p 0 $pos[1] 0;
select squashXup;
for ($i=1;$i<10;$i++)
    {
    $pos=`xform -q -ws -t squashFfdLattice.pt[0][$i][1]`;
    joint -n ("squashIKX"+$i) -p 0 $pos[1] 0;
    }
setAttr squashIKX1.segmentScaleCompensate 0;
$tempString=`ikHandle -n squashIKHandle -ccv 1 -ns 2 -sol ikSplineSolver -sj squashIKX1 -ee squashIKX9`;
rename $tempString[1] squashIKEffector;
rename $tempString[2] squashIKECurve;
for ($i=0;$i<5;$i++)
    {
    select -r squashIKECurve.cv[$i];
    $tempString=`newCluster " -envelope 1"`;
    rename $tempString[0] ("squashIKCluster"+$i);
    rename $tempString[1] ("squashIKClusterHandle"+$i);
    }  
select -cl;
for ($i=0;$i<10;$i++)
    select -add ("squashIKX"+$i);
select -add squashFfdLattice;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] squashIKSC;

skinPercent -tv squashIKX0 1 squashIKSC squashFfdLattice.pt[0:1][0:1][0:1];
skinPercent -tv squashIKX2 1 squashIKSC squashFfdLattice.pt[0:1][2][0] squashFfdLattice.pt[0:1][2][1];
skinPercent -tv squashIKX3 1 squashIKSC squashFfdLattice.pt[0:1][3][0] squashFfdLattice.pt[0:1][3][1];
skinPercent -tv squashIKX4 1 squashIKSC squashFfdLattice.pt[0:1][4][0] squashFfdLattice.pt[0:1][4][1];
skinPercent -tv squashIKX5 1 squashIKSC squashFfdLattice.pt[0:1][5][0] squashFfdLattice.pt[0:1][5][1];
skinPercent -tv squashIKX6 1 squashIKSC squashFfdLattice.pt[0:1][6][0] squashFfdLattice.pt[0:1][6][1];
skinPercent -tv squashIKX7 1 squashIKSC squashFfdLattice.pt[0:1][7][0] squashFfdLattice.pt[0:1][7][1];
skinPercent -tv squashIKX8 1 squashIKSC squashFfdLattice.pt[0:1][8][0] squashFfdLattice.pt[0:1][8][1];
skinPercent -tv squashIKX9 1 squashIKSC squashFfdLattice.pt[0:1][9:10][0:1];

delete `pointConstraint squashIKClusterHandle4 squashIKClusterHandle3`;
parent squashIKClusterHandle3 squashIKClusterHandle4;
move -r 0 ($scale*-0.1) 0 ;

parent squashIKClusterHandle4 squashTop_M;
parent squashIKClusterHandle2 squashMiddle_M;
parent squashIKClusterHandle0 squashIKClusterHandle1 squashIKX0 squashBase_M;

createNode -n squashIKCurveInfo curveInfo;
connectAttr squashIKECurveShape.worldSpace[0] squashIKCurveInfo.inputCurve;


createNode -n squashIKCurveInfoNormalize multiplyDivide;
setAttr squashIKCurveInfoNormalize.operation 2;
connectAttr squashIKCurveInfo.arcLength squashIKCurveInfoNormalize.input1X;
setAttr squashIKCurveInfoNormalize.input2X `getAttr squashIKCurveInfoNormalize.input1X`;
createNode -n squashIKScale multiplyDivide;

//scale-compansate Main ctrl
createNode -n squashIKCurveInfoMainScale multiplyDivide;
setAttr squashIKCurveInfoMainScale.operation 2;
connectAttr squashIKCurveInfoNormalize.outputX squashIKCurveInfoMainScale.input1X;
if (`objExists Main`) // maight be `bodyLess` faceSetup
	connectAttr Main.sy squashIKCurveInfoMainScale.input2X;

connectAttr squashIKCurveInfoMainScale.outputX squashIKScale.input1X;
createNode -n squashIKStretch multiplyDivide;
connectAttr squashIKScale.outputX squashIKStretch.input2X;
setAttr squashIKStretch.input1X `getAttr squashIKX2.tx`;

//connectAttr squashIKScale.outputX squashIKStretch.input1X;
connectAttr ($headJoint+".sx") squashIKScale.input2X;
setAttr "squashIKScale.operation" 2;
for ($i=1;$i<10;$i++)
    connectAttr squashIKStretch.outputX ("squashIKX"+$i+".tx");
createNode -n squashVolume1Over multiplyDivide;
connectAttr squashIKScale.outputX squashVolume1Over.input2X;
setAttr "squashVolume1Over.input1X" 1;
setAttr "squashVolume1Over.operation" 2;
createNode -n squashVolumePow multiplyDivide;
connectAttr squashVolume1Over.outputX squashVolumePow.input1X;
setAttr "squashVolumePow.operation" 3;
setAttr "squashVolumePow.input2X" 0.5;
createNode -n squashBlendTwo blendTwoAttr;
setAttr squashBlendTwo.input[0] 1;
connectAttr squashVolumePow.outputX squashBlendTwo.input[1];
connectAttr squashTopVolumeUC.output squashBlendTwo.attributesBlender;
for ($i=2;$i<9;$i++)
    {
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sy");
    connectAttr squashBlendTwo.output ("squashIKX"+$i+".sz");
    }
    
parent squashFfdLattice squashIKECurve squashIKHandle SquashSetup;
//parent squashIKX1 $headJoint;
parent squashIKX1 FaceMotionFollowHead;
parent SquashControls FaceMotionSystem;
parentConstraint -mo $headJoint SquashControls;
//scaleConstraint $headJoint SquashControls;
connectAttr MainAndHeadScaleMultiplyDivide.output SquashControls.s;
delete squashXup;

setAttr -l 1 squashIKX1.v 0;
setAttr -l 1 squashFfdBase.v 0;
setAttr -l 1 squashIKHandle.v 0;
setAttr -l 1 squashIKX0.v 0;
for ($i=0;$i<5;$i++)
    setAttr -l 1 ("squashIKClusterHandle"+$i+".v") 0;

addAttr -k 0 -ln curveVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.curveVis;
connectAttr squashTop_M.curveVis squashIKECurve.v;
addAttr -k 0 -ln LatticeVis -at bool -dv false squashTop_M;
setAttr -e -channelBox true squashTop_M.LatticeVis;
connectAttr squashTop_M.LatticeVis squashFfdLattice.v;

//include on-face nurbsCurveControllers (yellow ones)
select -cl;
for ($i=0;$i<size($faceControlSetMembers);$i++)
	{
	$tempString=`ls -l $faceControlSetMembers[$i]`;
	if (`gmatch $tempString[0] "*|ctrlBox|*"` || `gmatch $faceControlSetMembers[$i] "AimEye_*"`)
		continue;
	$tempString=`listRelatives -s $faceControlSetMembers[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`getAttr ($tempString[0]+".overrideColor")`!=17)
		continue;
	sets -add squashFfdSet $tempString[0];
	}


//update buildPose
string $controls[]={"squashTop_M","squashMiddle_M","squashBase_M"};
string $setAttrCmd;
for ($i=0;$i<size($controls);$i++)
	{
	$tempString=`listAttr -k -shortNames $controls[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (!`getAttr -l ($controls[$i]+"."+$tempString[$y])`)
			$setAttrCmd+="setAttr "+$controls[$i]+"."+$tempString[$y]+" "+`getAttr ($controls[$i]+"."+$tempString[$y])`+";";
	}
string $existingCmd=`getAttr faceBuildPose.udAttr`;
setAttr -type "string" faceBuildPose.udAttr ($existingCmd+$setAttrCmd);

connectAttr ctrlBox.SquashCtrlVis squashTop_MShape.overrideVisibility;
connectAttr ctrlBox.SquashCtrlVis squashMiddle_MShape.overrideVisibility;
connectAttr ctrlBox.SquashCtrlVis squashBase_MShape.overrideVisibility;

//FaceAllset
string $allAfter[]=`ls`;
string $allNew[];
for ($i=0;$i<size($allAfter);$i++)
	if (!`stringArrayCount $allAfter[$i] $allBefore`)
		if (`objectType $allAfter[$i]`!="objectSet")
			$allNew[size($allNew)]=$allAfter[$i];
sets -add FaceAllSet $allNew;
sets -remove FaceAllSet `listRelatives -ad FaceFitSkeleton`;

waitCursor -st 0;
select squashTop_M;
}

global proc asOptimizeSquash ()
{
global string $gMainProgressBar;
string $tempString[],$tempString2[];
string $headJoint=`textField -q -tx asFaceHeadJointTextField`;
string $geometry=`textField -q -tx asFaceGeometryTextField`;
string $skinCluster=`textField -q -tx asFaceSkinClusterTextField`;
int $tempInt[]=`polyEvaluate -v $geometry`;
int $numVtx=$tempInt[0];

string $allHeadJoints[]=`listRelatives -ad -type joint $headJoint`;
$tempString=`listRelatives -ad -type joint FaceDeformationSystem`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections ($tempString[$i]+".worldMatrix")`;
	if ($tempString2[0]==$skinCluster)
		$allHeadJoints=`stringArrayCatenate $allHeadJoints $tempString`;
	}
if (`objExists EyeRegion_R`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_R";
if (`objExists EyeRegion_L`) $allHeadJoints[size($allHeadJoints)]="EyeRegion_L";
$allHeadJoints[size($allHeadJoints)]=$headJoint;
select -cl;
progressBar -e -st "Optimizing" -bp -ii 1 -min 0 -max $numVtx $gMainProgressBar;
for ($i=0;$i<$numVtx;$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;return;}

	string $vtx=$geometry+".vtx["+$i+"]";
	$infs=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster $vtx`;
	int $headVtx=0;
	for ($y=0;$y<size($infs);$y++)
		{
		if (`stringArrayCount $infs[$y] $allHeadJoints`)
			{
			$headVtx=1;
			break;
			}
		}
	if (!$headVtx)
		select -add $vtx;
	}
sets -rm squashFfdSet `ls -sl`;
asInvertSelection;
progressBar -e -ep $gMainProgressBar;
print ("// Optimize complete, now only these selected vtx`s are affected by Squash\n");
}


//-- ASFace Procedures Ends Here --//

global proc string asGetLatestLocalScriptLocation ()
{
string $scriptLocation=`asGetScriptLocation`;
string $latestLocalScriptLocation=$scriptLocation;
string $tempString[];
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	tokenize $scriptLocation "/" $tempString;
	$latestLocalScriptLocation="";
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="AdvancedSkeleton5Files")
			break;
		else
			{
			if ($i>0 || `gmatch $scriptLocation "/*"`)
				$latestLocalScriptLocation+="/";
			$latestLocalScriptLocation+=$tempString[$i];
			}
		}
	}
return $latestLocalScriptLocation;
}

global proc string asGetLatestLocalVersionAsString ()
{
string $latestLocalVersion=`asGetScriptVersionAsString`;
string $scriptLocation=`asGetScriptLocation`;
string $tempString[];
string $latestLocalASFile;
if (`gmatch $scriptLocation "*oldVersions*"`)
	{
	$latestLocalASFile=`asGetLatestLocalScriptLocation`+"/AdvancedSkeleton5.mel";
	$latestLocalVersion=`asGetScriptVersionFromFile $latestLocalASFile`;
	}
return $latestLocalVersion;
}

global proc asDownloadDemoUpdates ()
{
int $fileId,$replacedLine;
string $scriptLocation=`asGetScriptLocation`;
string $curl=$scriptLocation+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$scriptLocation+"/AdvancedSkeleton5Files/bin/7za.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
string $tempString[],$oldFilesList[],$exampleFolders[];
string $cmd,$name,$unzipFolder,$downloadedFile,$zipFileUrl,$file,$exampleFile,$nextLine,$demoVersionsText,$onlineVersion;
string $exampleFilesFolder=$scriptLocation+"/AdvancedSkeleton5Files/exampleFiles";
string $downloadsFolder=$exampleFilesFolder+"/downloads";
string $demoVersionsTextFile=$downloadsFolder+"/DemoVersions.txt";
if (!`file -q -ex $downloadsFolder`)
	sysFile -md $downloadsFolder;

for ($i=0;$i<99;$i++)
	{
	if (!`checkBox -q -ex ("asDemoUpdateCheckBox"+$i)`)
		break;
	if (!`checkBox -q -v ("asDemoUpdateCheckBox"+$i)`)
		continue;
	$name=`text -q -l ("asDemoUpdateFileText"+$i)`;
	$onlineVersion=`text -q -l ("asDemoUpdateFileOnlineVersion"+$i)`;
	$downloadedFile=$downloadsFolder+"/"+$name+".7z";
	$unzipFolder=$downloadsFolder+"/"+$name;
	$zipFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeletonExamples/"+$name+".7z";
	if (!`file -q -ex $unzipFolder`)
		sysFile -md $unzipFolder;

	//download
	if (`about -mac` || `about -linux`)
		{
		$cmd="\"curl -o "+$downloadedFile+" "+$zipFileUrl+"\"";
		evalEcho ("system("+$cmd+")");
		}
	else
		{
		$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -o \""+$downloadedFile+"\" "+$zipFileUrl;
		system ($cmd);
		}

	//confirm download
	if (`file -q -ex $downloadedFile`)
		print ("// Downloaded sucessfully:"+$downloadedFile+";\n");
	else
		error ("// Download failed, could not find:"+$downloadedFile+";\n");

	//unzip (with -y for overwrite)
	if (`about -mac` || `about -linux`)
	  $cmd="unzip "+$downloadedFile+" -d "+$unzipFolder;
	else
		$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x -y \""+$downloadedFile+"\" -o\""+$unzipFolder+"\"";
	print ("// Starting Unzip:"+$cmd+";\n");
	system($cmd);
	
	//confirm unzip
	if (`file -q -ex ($unzipFolder+"/"+$name+".mb")`)
		print ("// Unzipped sucessfully:"+$unzipFolder+"/"+$name+".mb;\n");
	else
		error ("// Unzipp failed, could not find:"+$unzipFolder+"/"+$name+".mb;\n");

	//remove old file
	if (`file -q -ex ($exampleFilesFolder+"/"+$name)`)
		{
		$oldFilesList=`getFileList -fld ($exampleFilesFolder+"/"+$name+"/")`;
		for ($file in $oldFilesList)
			sysFile -del ($exampleFilesFolder+"/"+$name+"/"+$file);
		sysFile -red ($exampleFilesFolder+"/"+$name);
		}

//	//Move (by rename) downloadedFolder to exampleFolder
//	sysFile -ren ($exampleFilesFolder+"/"+$name) $unzipFolder;

	//Delete $downloadedFile
	sysFile -del $downloadedFile;

	//Update DemoVersions.txt
	$demoVersionsText="";
	$replacedLine=0;
	$fileId=`fopen $demoVersionsTextFile "r"`;
	$nextLine=`fgetline $fileId`;
	while ( size( $nextLine ) > 0 )
		{
		$nextLine=`strip $nextLine`;
		tokenize $nextLine $tempString;
		if ($tempString[0]==$name)
			{
			$demoVersionsText=$demoVersionsText+`substitute $tempString[1] $nextLine $onlineVersion`+"\r\n";
			$replacedLine=1;
			}
		else if ($nextLine!="")
			$demoVersionsText=$demoVersionsText+$nextLine+"\r\n";
		$nextLine=`fgetline $fileId`;
		}
	fclose $fileId;
	if (!$replacedLine)
		$demoVersionsText=$demoVersionsText+$name+" "+$onlineVersion+"\r\n";
	$fileId=`fopen $demoVersionsTextFile "w"`;
	fprint $fileId $demoVersionsText;
	fclose $fileId;

	//populate Demo optionMenu
	$tempString=`optionMenu -q -ill asDemoOptionMenu`;
	for ($y=0;$y<size($tempString);$y++)
		deleteUI $tempString[$y];
	setParent -menu asDemoOptionMenu;
	$exampleFolders=`getFileList -fld ($exampleFilesFolder+"/downloads/")`;
	for ($y=0;$y<size($exampleFolders);$y++)
		{
		string $exampleFile=$exampleFilesFolder+"/downloads/"+$exampleFolders[$y]+"/"+$exampleFolders[$y]+".mb";
		if (`file -q -ex $exampleFile`)
			menuItem -l $exampleFolders[$y];
		}

	//disable RowLayout
	rowLayout -e -en 0 ("asDemoUpdateRowLayout"+$i);
	text -e -bgc 0 1 0 ("asDemoUpdateFileOnlineVersion"+$i);
	text -e -l $onlineVersion ("asDemoUpdateFileLocalVersion"+$i);
	checkBox -e -v 0 ("asDemoUpdateCheckBox"+$i);
	}
print "// Download of selected files complete.\n";
}

global proc asCheckForDemoUpdates ()
{
int $x,$y,$needUpdate,$fileId;
string $scriptLocation=`asGetScriptLocation`;
string $onlineVersionsText,$localVersionsText,$localVersionInfo;
string $onlineVersionsFile="http://www.advancedskeleton.com/download/AdvancedSkeletonExamples/DemoVersions.txt";
string $downloadsFolder=$scriptLocation+"/AdvancedSkeleton5Files/exampleFiles/downloads";
string $localVersionsFile=$downloadsFolder+"/DemoVersions.txt";
string $curl=$scriptLocation+"/AdvancedSkeleton5Files/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
string $tempString[],$localFiles[],$localVersions[],$onlineFiles[],$onlineVersions[];
print ("// Checking online for demo updates at www.advancedskeleton.com\n");
waitCursor -st 1;

$onlineVersionsText=`system ("\""+$curl+"\" -k -s "+$onlineVersionsFile)`;

if (!`gmatch $onlineVersionsText "*chubby*"`)
	print ("Failed to access \""+$onlineVersionsFile+"\"");

if (!`file -q -ex $downloadsFolder`)
	sysFile -md $downloadsFolder;

if (!`file -q -ex $localVersionsFile`)
	{
	$fileId=`fopen $localVersionsFile "w"`;
	fclose $fileId;
	}
$localVersionsText="";
$fileId=`fopen $localVersionsFile "r"`;
string $nextLine = `fgetline $fileId`;
while ( size( $nextLine ) > 0 )
	{
	$localVersionsText=$localVersionsText+$nextLine;
	$nextLine=`fgetline $fileId`;
	}
fclose $fileId;

$x=0;
tokenize $localVersionsText $tempString;
for ($i=0;$i<size($tempString);$i=$i+2)
	{
	$localFiles[$x]=$tempString[$i];
	$localVersions[$x]=$tempString[$i+1];
	$x++;
	}

$x=0;
tokenize $onlineVersionsText $tempString;
for ($i=0;$i<size($tempString);$i=$i+2)
	{
	$onlineFiles[$x]=$tempString[$i];
	$onlineVersions[$x]=$tempString[$i+1];
	$x++;
	}

if (`window -q -ex asDemoUpdates`)
	deleteUI asDemoUpdates;
window -t Updates asDemoUpdates;
columnLayout;
rowLayout -nc 4 -cw4 80 50 60 40;
	text -l " File:";
	text -l " Online:";
	text -l " Local:";
	text -l " Update:";
	setParent..;
separator -h 5 -st none;
for ($i=0;$i<size($onlineFiles);$i++)
	{
	$needUpdate=0;
	$localVersionInfo="n/a";
	for ($y=0;$y<size($localFiles);$y++)
		if ($localFiles[$y]==$onlineFiles[$i])
			$localVersionInfo=$localVersions[$y];
	if ($localVersionInfo!=$onlineVersions[$i])
		$needUpdate=1;

	rowLayout -en $needUpdate -nc 4 -cw4 80 50 50 50 ("asDemoUpdateRowLayout"+$i);
	text -l $onlineFiles[$i] ("asDemoUpdateFileText"+$i);
	if ($needUpdate)
		text -bgc 1 0 0 -l $onlineVersions[$i] ("asDemoUpdateFileOnlineVersion"+$i);
	else
		text -l $onlineVersions[$i] ("asDemoUpdateFileOnlineVersion"+$i);
	text -l $localVersionInfo ("asDemoUpdateFileLocalVersion"+$i);
	checkBox -v $needUpdate -l "" ("asDemoUpdateCheckBox"+$i);
	setParent..;
	}
separator -h 15 -st none;
button -l "  Download selected files  " -c asDownloadDemoUpdates;
showWindow;
waitCursor -st 0;
}

global proc asCheckForUpdates ()
{
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton5Files/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);
text -e -en 0 -l "x.xxx" asUpdateFoundVersion;
checkBox -e -v 0 asBetaCheckBox;
button -e -en 0 asUpdateVersionButton;
waitCursor -st 1;
int $modifier=`getModifiers`;
float $versions[];
string $versionsText;

if ($modifier==13)
	{
	print ("// Checking online for new BETA version at www.advancedskeleton.com\n");
	checkBox -e -v 1 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s http://www.advancedskeleton.com/download/AdvancedSkeleton5Beta/latestBetaVersion.txt")`;
	}
else
	{
	print ("// Checking online for new version at www.advancedskeleton.com\n");
	checkBox -e -v 0 asBetaCheckBox;
	$versionsText=`system ("\""+$curl+"\" -k -s http://www.advancedskeleton.com/download/AdvancedSkeleton5/latestVersion.txt")`;
	}
if (!`gmatch $versionsText "[0-9]*"`)
	{
	print ("// returned:\""+$versionsText+"\"\n");
	error "Unable to connect to update server \"http://www.advancedskeleton.com\", you might not be connected to internet, or blocked by firewall";
	}
string $latestVersionAsString=$versionsText;
float $latestVersion=$versionsText;

string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
float $latestInstalledVersion=`asGetScriptVersionFromFile ($sLoc+"/AdvancedSkeleton5.mel")`;
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;

if ($latestVersion>$latestInstalledVersion)
	{
	text -e -en 1 -l $latestVersionAsString asUpdateFoundVersion;
	button -e -en 1 asUpdateVersionButton;
	print ("// New version found, click Update, to update to the new version\n");
	}
else
	print ("// Latest version("+$latestVersionAsString+"), is not greater than your latest installed version("+$latestInstalledVersionAsString+")\n");
waitCursor -st 0;
}

global proc string asGetLatestInstalledVersionScriptLocation ()
{
string $sLoc=`asGetScriptLocation`;
string $ts[];
int $numTok=`tokenize $sLoc "/" $ts`;
if ($ts[size($ts)-2]=="oldVersions")
	$sLoc=`substitute ("/"+$ts[$numTok-3]+"/"+$ts[$numTok-2]+"/"+$ts[$numTok-1]) $sLoc ""`;
return $sLoc;
}

global proc asUpdateVersion ()
{
//First check if download is from Autodesk store,
//since the C:\ProgramData\Autodesk\ApplicationPlugins folder probably does not have overwrite priveleges
//Testing by attempting to rename eula.txt file
int $fileId;
int $isReadOnly=0;
string $dialog;
string $fDet,$cmd,$changePriviligeFolder;
string $asScriptLocation=`asGetScriptLocation`;
string $eulaFile=$asScriptLocation+"/eula.txt";
string $eula2File=$asScriptLocation+"/eula2.txt";
string $tmpDir=`asGetTempDirectory`;
string $batFile=$tmpDir+"AdvancedSkeleton_changeFolderPriviliges.bat";
if (`file -q -ex $eulaFile` && `about -win`)
	{
	sysFile -rename $eula2File $eulaFile;
	if (!`file -q -ex $eulaFile`)
		sysFile -rename $eulaFile $eula2File;
	else
		{
		$isReadOnly=1;
		sysFile -del $eula2File;
		}
	}
if ($isReadOnly)
	{
	$changePriviligeFolder=$asScriptLocation;
	if (`gmatch $asScriptLocation "C:/ProgramData/Autodesk/ApplicationPlugins/AdvancedSkeleton5*"`)
		$changePriviligeFolder="C:/ProgramData/Autodesk/ApplicationPlugins/AdvancedSkeleton5";
	$dialog=`confirmDialog -t "Confirm"
	-m ("Detected Read-Only AdvancedSkeleton files,\nClick OK to attemp to modify the priviliges for this folder:\n"+$changePriviligeFolder)
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
	if ($dialog!="OK")
		error ("Unable to Update, as the files are Read-Only.\nThis is common if you downloaded AdvancedSkeleton from the Autodesk store.\n"
			+"You can try to manually add Write-priviliges to this folder:\n"+$changePriviligeFolder);
	$fDet="icacls "+$changePriviligeFolder+" /grant Everyone:(OI)(CI)F";
	$fileId=`fopen $batFile "w"`;
	fprint $fileId ($fDet);
	fclose $fileId;
	$cmd="powershell -Command \"Start-Process '"+$batFile+"' -Verb runAs\"";
	system ($cmd);
	}

waitCursor -st 1;
string $sLoc=`asGetLatestInstalledVersionScriptLocation`;	
string $latestInstalledVersionAsString=`asGetScriptVersionFromFileAsString ($sLoc+"/AdvancedSkeleton5.mel")`;
string $curl=$sLoc+"/AdvancedSkeleton5Files/bin/curl.e";
string $zip=$sLoc+"/AdvancedSkeleton5Files/bin/7za.e";
string $newVersionAsString=`text -q -l asUpdateFoundVersion`;
string $newVersionFolder=$sLoc+"/AdvancedSkeleton5Files/newVersions/AdvancedSkeleton_v"+$newVersionAsString;
if (!`file -q -ex $newVersionFolder`)
	sysFile -md $newVersionFolder;
//download
string $newVersionZipFile=$newVersionFolder+"/AdvancedSkeleton5.zip";
string $zipFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
if (`checkBox -q -v asBetaCheckBox`)
	$zipFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5Beta/AdvancedSkeleton_v"+$newVersionAsString+"/AdvancedSkeleton5.zip";
if (`about -mac` || `about -linux`)
	{
	$cmd="\"curl -o "+$newVersionZipFile+" "+$zipFileUrl+"\"";
	evalEcho ("system("+$cmd+")");
	}
else
	{
	$cmd="start\/wait/I \"Downloading\"  \""+$curl+"\" -k -o \""+$newVersionZipFile+"\" "+$zipFileUrl;
	print ("// Starting Download:"+$cmd+";\n");
	system ($cmd);
	}
//confirm download
if (`file -q -ex $newVersionZipFile`)
	print ("// Downloaded sucessfully:"+$newVersionZipFile+";\n");
else
	error ("// Download failed, could not find:"+$newVersionZipFile+";\n");
//unzip
if (`about -mac` || `about -linux`)
  $cmd="unzip "+$newVersionZipFile+" -d "+$newVersionFolder;
else
	$cmd="start\/wait/I \"Unzipping\"  \""+$zip+"\" x \""+$newVersionZipFile+"\" -o\""+$newVersionFolder+"\"";
print ("// Starting Unzip:"+$cmd+";\n");
system($cmd);

//confirm unzip
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.mel")`)
	print ("// Unzipped sucessfully:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
else
	error ("// Unzipp failed, could not find:"+$newVersionFolder+"/AdvancedSkeleton5.mel;\n");
//remove zip file
if (`file -q -ex ($newVersionFolder+"/AdvancedSkeleton5.zip")`)
	sysFile -del ($newVersionFolder+"/AdvancedSkeleton5.zip");
//backup $latestInstalledVersion version
string $oldVersionsFolder=$sLoc+"/AdvancedSkeleton5Files/oldVersions/AdvancedSkeleton_v"+$latestInstalledVersionAsString;
print ("// Backing up old version: asCopyFilesInFolder \""+$oldVersionsFolder+"\" \""+$sLoc+"\";\n");
sysFile -md ($oldVersionsFolder+"/AdvancedSkeleton5Files");
asCopyFilesInFolder ($oldVersionsFolder+"/AdvancedSkeleton5Files") ($sLoc+"/AdvancedSkeleton5Files");
sysFile -cp ($oldVersionsFolder+"/AdvancedSkeleton5.mel") ($sLoc+"/AdvancedSkeleton5.mel");
//replace with new version
print ("// Replacing current version with the downloaded version: asCopyFilesInFolder \""+$sLoc+"\" \""+$newVersionFolder+";\n");
asCopyFilesInFolder $sLoc $newVersionFolder;
waitCursor -st 0;
print ("// Updated from "+$latestInstalledVersionAsString+" to "+$newVersionAsString+"\n");
//Re-start
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;
optionVar -iv asHaveRanThisVersion 0;
evalDeferred -lp ("source \""+$sLoc+"/AdvancedSkeleton5.mel\";AdvancedSkeleton5;");
}

global proc asVersionHistory ()
{
global string $gMainProgressBar;

string $versionHistoryFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5/versionHistory.txt";
if (`getModifiers`==13)
	$versionHistoryFileUrl="http://www.advancedskeleton.com/download/AdvancedSkeleton5Beta/betaVersionHistory.txt";
string $curl=`asGetScriptLocation`+"/AdvancedSkeleton5Files/bin/curl.e";
if (`about -mac` || `about -linux`) $curl="curl";
else if (!`file -q -ex $curl`)
	error ("File not found:"+$curl);

evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
print ("// Downloading version information from:"+$versionHistoryFileUrl+"\n");
progressBar -e -st "Downloading version information" -bp -ii 1 -min 0 -max 1 $gMainProgressBar;
string $versionHistoryText=`system ("\""+$curl+"\" -k -s "+$versionHistoryFileUrl)`;

if (`window -q -ex asVersionHistory`)
	deleteUI asVersionHistory;
window asVersionHistory;
formLayout asVersionHistoryFormLayout;
scrollField -text $versionHistoryText asVersionHistoryScrollField;
formLayout -e 
	-af asVersionHistoryScrollField "left" 0
	-af asVersionHistoryScrollField "right" 0
	-af asVersionHistoryScrollField "top" 0
	-af asVersionHistoryScrollField "bottom" 0
	asVersionHistoryFormLayout;
showWindow;
}

global proc asCopyFilesInFolder (string $destFolder, string $sourceFolder)
{
global string $gMainProgressBar;
if (`gmatch $destFolder"*/exampleFiles/*"`)
	return;//dont include downloaded exampleFiles
if (`gmatch $destFolder"*forced-aligner*"`)
	return;//dont include forced-aligners
if (`gmatch $destFolder"*download*"`)
	return;//dont include download folders (eg. AdvancedSkeleton5Files\bin\download used for forced-aligner)
if (!`file -q -ex $destFolder`)
    sysFile -md $destFolder;
string $fileList[]=`getFileList -fld ($sourceFolder+"/")`;
if (`size($fileList)`==0)
	return;
progressBar -e -st "Copy files" -bp -ii 1 -min 0 -max (size($fileList)) $gMainProgressBar;
for ($i=0;$i<size($fileList);$i++)
    {
		progressBar -e -s 1 $gMainProgressBar;
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
    if ($fileList[$i]=="incrementalSave" || $fileList[$i]=="downloads" || $fileList[$i]=="distributes" || `gmatch $fileList[$i] "[.]*"`
  		|| $fileList[$i]=="newVersions" || $fileList[$i]=="oldVersions" || $fileList[$i]=="asReleaser.mel" || `gmatch $fileList[$i] "*[.]psd"`
  		|| $fileList[$i]=="montreal-forced-aligner")
        continue;
    if (`filetest -d ($sourceFolder+"/"+$fileList[$i])`)
			asCopyFilesInFolder ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i]);
    else
			if (!`sysFile -cp ($destFolder+"/"+$fileList[$i]) ($sourceFolder+"/"+$fileList[$i])` && `about -win`)
				{
				error ("Failed to copy file ("+$destFolder+"/"+$fileList[$i]+")\n"
					+"Possibly privileges issue. This is common if you downloaded AdvancedSkeleton from the Autodesk store\n"
					+"Follow the steps in the URL below, then redo the updates\n"
					+"http://www.advancedskeleton.com/download/AdvancedSkeleton4/changePrivilegesHelp.jpg\n");
				progressBar -e -ep $gMainProgressBar;
				return;
				}
    }
progressBar -e -ep $gMainProgressBar;
}

global proc asDockWindow (int $dock)
{
int $asDock=`optionVar -q asDock`;
optionVar -iv asDock $dock;
removeAsWorkspaceControl;
if (`dockControl -q -ex AdvancedSkeletonDockControl`)
	deleteUI -control AdvancedSkeletonDockControl;
AdvancedSkeleton5;
}

global proc asDockWindowChangeFloatingState ()
{
optionVar -iv asDock (!`dockControl -q -ex AdvancedSkeletonDockControl`);
}

global proc asCreateWorkspaceControl ()
{
//First we ensure runTimeCommand
string $asScriptLocation=`asGetScriptLocation`;
if (`runTimeCommand -ex AdvancedSkeletonWorkspaceController`) //update, since $asScriptLocation can change.
	runTimeCommand -e -annotation "Run AdvancedSkeleton as WorkSpace controller" -category "User"
		-command ("if (!`exists AdvancedSkeleton5`) evalEcho (\"source \\\""+$asScriptLocation+"/AdvancedSkeleton5.mel\\\"\");AdvancedSkeleton5;")
		AdvancedSkeletonWorkspaceController;
else
	runTimeCommand -annotation "Run AdvancedSkeleton as WorkSpace controller" -category "User"
		-command ("if (!`exists AdvancedSkeleton5`) evalEcho (\"source \\\""+$asScriptLocation+"/AdvancedSkeleton5.mel\\\"\");AdvancedSkeleton5;")
		AdvancedSkeletonWorkspaceController;

if (`workspaceControl -ex asWorkspaceControl`)
	{
	print ("Already a Workspace Controller, click \"UnDock\" to detach.\n");
	return;//since removing it, then re-building it, appears to cause crashes.
	}

if (`exists dockControl`)
	if (`dockControl -q -ex AdvancedSkeletonDockControl`)
		deleteUI -control AdvancedSkeletonDockControl;
if (`window -q -ex AdvancedSkeletonWindow`)
    deleteUI AdvancedSkeletonWindow;

workspaceControl -initialWidth 288 -minimumWidth 288 -retain 0 -dockToControl ToolBox left -label AdvancedSkeleton -uiScript AdvancedSkeletonWorkspaceController asWorkspaceControl;
}

global proc removeAsWorkspaceControl ()
{
if (!`exists workspaceControl`)
	return;//Maya version < 2017
if (`workspaceControl -ex asWorkspaceControl`)
	workspaceControl -e -close asWorkspaceControl;
if (`workspaceControlState -exists asWorkspaceControl`)
	workspaceControlState -remove asWorkspaceControl;
}

global proc asFitSkeletonImport ()
{
string $dialog;
string $tempString[];
if (`objExists FitSkeleton`)
	{
	$dialog=`confirmDialog -t "Confirm"
		-m "FitSkeleton already exists"
		-b "Replace"
		-b "Merge"
		-b "Cancel"
		-db "Replace" -ds "Cancel"`;
	if ($dialog!="Replace" && $dialog!="Merge")
		return;
	}
int $merge=0;
if ($dialog=="Merge") $merge=1;

float $existingScale[];
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
string $removeExistingObjs[]={"FitSkeleton","FitSkeletonVisualizers","cylinders","boxes","locators","directions",
	"asRedSG","asRed2SG","asGreenSG","asGreen2SG","asBlueSG","asBlue2SG","asBlackSG","asWhiteSG","asBonesSG",
	"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asBlack","asWhite","asBones"};
if (!$merge)
	for ($i=0;$i<size($removeExistingObjs);$i++)
		if (`objExists $removeExistingObjs[$i]`)
			delete $removeExistingObjs[$i];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletons/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asFitFiles`;
if (`file -q -ex $FitSkeletonFile`)
	{
	if ($merge)
		{
		if (`namespace -ex "Merge"`)
			namespace -rm "Merge";
		file -import -ra true -ns "Merge" -options "v=0" $FitSkeletonFile;
		asFitSkeletonMerge;
		}
	else
		file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
	}
if ($existingScale[0]!=0)
	setAttr -type float3 FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
if (`objExists Group|Main` && !`objExists Group|Main|FitSkeleton` && `objExists FitSkeleton`)
	parent FitSkeleton Group|Main;
if (`objExists FitSkeleton`)
	{
	if (!`attributeExists fitSkeletonTemplate  FitSkeleton`) addAttr -ln fitSkeletonTemplate -dt "string" FitSkeleton;
	$tempString[0]=`optionMenu -q -v asFitFiles`;
	setAttr -type "string" FitSkeleton.fitSkeletonTemplate `basenameEx $tempString[0]`;
	}
asEnsureFitSkeletonAttributes;
//asFitSkeletonConnectControl; //asEnsureFitSkeletonAttributes now includes asFitSkeletonConnectControl
asUpdateButtonEnables;
}

global proc asFitSkeletonMerge ()
{
int $lockCenterJoints=`getAttr FitSkeleton.lockCenterJoints`;
string $tempString[],$tempString2[],$tempString3[];
string $counterPart,$counterPartParent;
setAttr FitSkeleton.lockCenterJoints 0;

string $dialog=`confirmDialog -t "Confirm"
		-m "Joints with same names ?"
		-b "Keep existing"
		-b "Keep imported"
		-b "Keep both by renaming imported"
		-db "Keep existing"`;
int $keepExisting=0;
int $keepImported=0;
int $keepBoth=0;
if ($dialog=="Keep existing") $keepExisting=1;
if ($dialog=="Keep imported") $keepImported=1;
if ($dialog=="Keep both by renaming imported") $keepBoth=1;

//$keepExisting
if ($keepExisting || $keepImported)
	{
	if ($keepExisting) $tempString=`listRelatives -ad -type joint Merge:FitSkeleton`;
	if ($keepImported) $tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (!`objExists $tempString[$i]`)
			continue;
		if ($keepExisting) $counterPart=`substitute "Merge:" $tempString[$i] ""`;
		if ($keepImported) $counterPart="Merge:"+$tempString[$i];
		if (`objExists $counterPart`)
			{
			delete $tempString[$i];
			continue;
			}
		$tempString2=`listRelatives -p $tempString[$i]`;
		if ($tempString2[0]=="")
			continue;
		if ($keepExisting) $counterPartParent=`substitute "Merge:" $tempString2[0] ""`;
		if ($keepImported) $counterPartParent="Merge:"+$tempString2[0];
		if (`objExists $counterPartParent`)
			parent $tempString[$i] $counterPartParent;
		}
	}

$tempString=`listRelatives -c -type joint Merge:FitSkeleton`;
if (size($tempString))
	parent $tempString FitSkeleton;

if (`objExists Merge:FitSkeleton`)
	{
	//Unlock
	$tempString=`listRelatives -ad -type joint FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		setAttr -l 0 ($tempString[$i]+".tx");setAttr -l 0 ($tempString[$i]+".ty");setAttr -l 0 ($tempString[$i]+".tz");
		setAttr -l 0 ($tempString[$i]+".rx");setAttr -l 0 ($tempString[$i]+".ry");setAttr -l 0 ($tempString[$i]+".rz");
		}

	//Keep imported DrivingSystems
	if (!`attributeExists drivingSystem FitSkeleton`)
		addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
	$tempString=`listAttr -ud -m Merge:FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		if (`gmatch $tempString[$i] "drivingSystem*"`)
			{
			$tempString2=`listConnections -s 1 -d 0 -p 1 ("Merge:FitSkeleton."+$tempString[$i])`;
			if ($tempString2[0]!="")
				{
				connectAttr -na $tempString2[0] FitSkeleton.drivingSystem;
				disconnectAttr -na $tempString2[0] -na Merge:FitSkeleton.drivingSystem;
				}
			$tempString2=`listConnections -s 0 -d 1 -p 1 ("Merge:FitSkeleton."+$tempString[$i])`;
			if ($tempString2[0]!="")
				{
				tokenize $tempString[$i] "[" $tempString3;
				if (!`attributeExists $tempString3[0] FitSkeleton`)
					addAttr -k 0 -ln $tempString3[0] -at bool -dv true -multi FitSkeleton;
				connectAttr -f ("FitSkeleton."+$tempString[$i]) $tempString2[0];
				}
			}
	delete Merge:FitSkeleton;
	}

//rename Merge:*
while (size(`ls "Merge:*"`))
	{
	$tempString=`ls "Merge:*"`;
	tokenize $tempString[0] ":" $tempString2;
	string $newName=$tempString2[1];
	if (`objExists $tempString2[1]`)
	for ($i=1;$i<99;$i++)
		{
		$newName=$tempString2[1]+$i;
		if (!`objExists $newName`)
			break;
		}
	rename $tempString[0] $newName;
	}

if ($lockCenterJoints)
	setAttr FitSkeleton.lockCenterJoints 1;
namespace -rm "Merge";
}

global proc asFitSkeletonLimbsImport ()
{
string $dialog;
string $tempString[],$tempString2[],$tempString3[];
string $fitSkeletonsDir=`asGetScriptLocation`+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $FitSkeletonFile=$fitSkeletonsDir+`optionMenu -q -v asLimbFiles`;
float $existingScale[3]={1,1,1};
if (`objExists FitSkeleton`)
	$existingScale=`getAttr FitSkeleton.s`;
if (`file -q -ex $FitSkeletonFile`)
	file -import -rpr "AdvancedSkeleton" -options "v=0" $FitSkeletonFile;
if (`objExists Main|FitSkeleton` && `objExists |FitSkeleton`)
	rename |FitSkeleton AdvancedSkeleton_FitSkeleton;
if (`objExists AdvancedSkeleton_FitSkeleton` && `objExists FitSkeleton`)
	{
	setAttr -type float3 AdvancedSkeleton_FitSkeleton.s $existingScale[0] $existingScale[1] $existingScale[2];
	$tempString=`listRelatives -f -c -type transform AdvancedSkeleton_FitSkeleton`;
	for ($i=0;$i<size($tempString);$i++)
		{
		tokenize $tempString[$i] "|" $tempString2;
		string $shortName=$tempString2[size($tempString2)-1];
		$tempString2=`ls -l $shortName`;
			{
			if (size($tempString2)>1)
				$dialog=`confirmDialog -t "Confirm"
				-m ($shortName+" already exist")
				-b "Replace" -db "Replace"
				-b "Merge" -ds "Merge"`;
			if ($dialog=="Replace")
				{
				for ($y=0;$y<size($tempString2);$y++)
					if ($tempString2[$y]!=$tempString[$i])
						{
						$tempString3=`listRelatives -p $tempString2[$y]`;
						delete $tempString2[$y];
						if ($tempString3[0]!="")
							parent $tempString[$i] $tempString3[0];
						else
							parent $tempString[$i] FitSkeleton;
						}
				}
			else if (`objExists Root`)
				parent $tempString[$i] Root;
			else
				parent $tempString[$i] FitSkeleton;
			}
		}
	//Transfer SDK`s to FitSkeleton;
	if (`attributeExists drivingSystem AdvancedSkeleton_FitSkeleton`)
		{
		$tempString=`listConnections AdvancedSkeleton_FitSkeleton.drivingSystem`;
		if (!`attributeExists drivingSystem FitSkeleton`)
			addAttr -k 0 -ln drivingSystem -at message -multi -indexMatters 0 FitSkeleton;
		for ($i=0;$i<size($tempString);$i++)
			connectAttr -na ($tempString[$i]+".drivingSystemOut") FitSkeleton.drivingSystem;
		string $uAs[]=`listAttr -ud AdvancedSkeleton_FitSkeleton`;
		for ($i=0;$i<size($uAs);$i++)
			{
			if (!`gmatch $uAs[$i] "drivingSystem_*"`)
				continue;
			if (!`attributeExists $uAs[$i] FitSkeleton`)
				addAttr -k 0 -ln $uAs[$i] -at bool -dv true -multi FitSkeleton;
			$tempString=`listConnections -p 1 ("AdvancedSkeleton_FitSkeleton."+$uAs[$i])`;
			for ($y=0;$y<size($tempString);$y++)
				connectAttr -f ("FitSkeleton."+$uAs[$i]+"["+$y+"]") $tempString[$y];
			}
		}
	delete AdvancedSkeleton_FitSkeleton;
	}
asEnsureFitSkeletonAttributes;
//asFitSkeletonConnectControl;
asUpdateButtonEnables;
}

global proc asFitSkeletonExport ()
{
string $selJoints[]=`ls -sl -type joint `;
string $selJointsLongName[]=`ls -l -sl -type joint `;
int $fitSkeletonVisLocked=`getAttr -l FitSkeleton.v`;
string $tempString[],$tempString2[],$drivingSystems[],$previousFitSkeletonChildren[],$previousSelJointParents[];
string $asScriptLocation=`asGetScriptLocation`;
string $fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletons/";

//Limb only, first check, to determine destinationDir
int $limbOnly=0;
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		$limbOnly=1;
	}
if ($limbOnly)
	$fitSkeletonsDir=$asScriptLocation+"/AdvancedSkeleton5Files/fitSkeletonsLimbs/";
string $return[] = `fileDialog2 -fileFilter "*.ma" -dialogStyle 2 -dir $fitSkeletonsDir`;
string $file=$return[0];
if ($file=="")
	return;

$tempString=`listRelatives -p FitSkeleton`;
string $currentParent=$tempString[0];
if ($fitSkeletonVisLocked)
	setAttr -l 0 FitSkeleton.v;
setAttr FitSkeleton.v 1;
if (`objExists $currentParent`)
	parent -w FitSkeleton;
$tempString=`listConnections -s 0 -d 1 -type animCurve`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listConnections -s 1 -d 0 -type transform $tempString[$i]`;
	if ($tempString2[0]!="" && $tempString2[0]!="FitSkeleton")
		if (!`stringArrayCount $tempString2[0] $drivingSystems`)
			$drivingSystems[size($drivingSystems)]=$tempString2[0];
	}

//Limb only ?
for ($i=0;$i<size($selJoints);$i++)
	{
	tokenize $selJointsLongName[$i] "|" $tempString2;
	if ($tempString2[0]=="FitSkeleton" && size($tempString2)>2)
		{
		if (!`objExists previousFitSkeletonChildren`)
			{
			createNode -n previousFitSkeletonChildren transform;
			$previousFitSkeletonChildren=`listRelatives -c -type joint FitSkeleton`;
			parent $previousFitSkeletonChildren previousFitSkeletonChildren;
			}
		$tempString=`listRelatives -p $selJoints[$i]`;
		$previousSelJointParents[$i]=$tempString[0];
		parent $selJoints[$i] FitSkeleton;
		}
	}

select FitSkeleton;
if (size($drivingSystems))
	delete $drivingSystems;
file -force -options "v=0;" -typ "mayaAscii" -es $file;
if (size($drivingSystems))
	undo;

if (`objExists $currentParent`)
	parent FitSkeleton $currentParent;
if ($fitSkeletonVisLocked)
	setAttr -l 1 FitSkeleton.v;

//Limb only ? (restore)
for ($i=0;$i<size($selJoints);$i++)
	if ($previousSelJointParents[$i]!="")
		parent $selJoints[$i] $previousSelJointParents[$i];
if (`objExists previousFitSkeletonChildren`)
	{
	parent `listRelatives -c previousFitSkeletonChildren` FitSkeleton;
	delete previousFitSkeletonChildren;
	}

print ("// FitSkeleton exported to: \""+$file+"\"\n");
}

global proc asOpenDemoFile ()
{
string $asScriptLocation=`asGetScriptLocation`;
string $exampleFoldersDir=$asScriptLocation+"/AdvancedSkeleton5Files/exampleFiles/downloads/";
string $exampleFolder=`optionMenu -q -v asDemoOptionMenu`;
string $exampleFile=$exampleFoldersDir+$exampleFolder+"/"+$exampleFolder+".mb";
string $tempString[];
float $preMayaVersion;

//backwards compatability files
string $exampleFiles[]=`getFileList -fld ($exampleFoldersDir+$exampleFolder+"/")`;
for ($i=0;$i<size($exampleFiles);$i++)
	if (`gmatch $exampleFiles[$i] "*_MayaPre*"`)
		{
		$tempString[0]=`substitute ($exampleFolder+"_MayaPre") $exampleFiles[$i] ""`;
		$tempString[0]=`basenameEx $tempString[0]`;
		$preMayaVersion=$tempString[0];
		if (`asMayaVersionAsFloat`<$preMayaVersion)
			{
			$exampleFile=$exampleFoldersDir+$exampleFolder+"/"+$exampleFiles[$i];
			print ("// using backwards compatability file, as the original file requires Maya:\""+$preMayaVersion+"\" or higher\n");
			//requires wbDeltaMushDeformer
			if ($exampleFolder=="cody")
				asLoadWbDeltaMushPlugin;
			}
		}

print ("// Opening:\""+$exampleFile+"\"\n");
if (`file -q -ex $exampleFile`)
	{
	if (`saveChanges ""`)
		file -f -o $exampleFile;
	}
else
	warning ("Not Found:"+$exampleFile);
}

global proc asFitChangeLimbType ()
{
string $limbType=`optionMenu -q -v asLimbType`;
if ($limbType=="Spine" || $limbType=="Neck" || $limbType=="Tail")
	checkBox -e -v 1 asLimbMiddle;
else
	checkBox -e -v 0 asLimbMiddle;
}

global proc asReferenceModelBrowser ()
{
global string $selectedNamespaceRadioButton;
string $sNRB=$selectedNamespaceRadioButton;
string $referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
int $referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
int $referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
string $ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
string $topNodesBefore[]=`ls -as`;

if (`asIsMayaLT`)
	error ("Maya LT does not have Reference, Import the model instead");
CreateReferenceOptions;

//Something in here Ran again, makes it work
global string $selectedNamespaceRadioButton;
$sNRB=$selectedNamespaceRadioButton;
$referenceOptionsRenamePrefix=`optionVar -q referenceOptionsRenamePrefix`;
$referenceUseNamespacesDuringFileIO=`optionVar -q referenceUseNamespacesDuringFileIO`;
$referenceOptionsUseRenamePrefix=`optionVar -q referenceOptionsUseRenamePrefix`;
$ReferenceMergeOptionValue=`optionVar -q ReferenceMergeOptionValue`;

optionVar -sv referenceOptionsRenamePrefix "model";
optionVar -iv referenceUseNamespacesDuringFileIO 1;
optionVar -iv referenceOptionsUseRenamePrefix 1;
optionVar -sv ReferenceMergeOptionValue "radioNamespaceOnString";
if ($selectedNamespaceRadioButton!="")
	$selectedNamespaceRadioButton="radioNamespaceOnString";
CreateReference;

optionVar -sv referenceOptionsRenamePrefix $referenceOptionsRenamePrefix;
optionVar -iv referenceUseNamespacesDuringFileIO $referenceUseNamespacesDuringFileIO;
optionVar -iv referenceOptionsUseRenamePrefix $referenceOptionsUseRenamePrefix;
optionVar -sv ReferenceMergeOptionValue $ReferenceMergeOptionValue;
if ($sNRB!="")
	$selectedNamespaceRadioButton=$sNRB;
string $topNodesAfter[]=`ls -as`;
select -cl;
for ($i=0;$i<size($topNodesAfter);$i++)
	if (!`stringArrayCount $topNodesAfter[$i] $topNodesBefore`)
		select -add $topNodesAfter[$i];

//Hi layer
if (`objExists Hi`)
	{
	if(`objectType Hi`=="displayLayer")
		editDisplayLayerMembers -noRecurse Hi `ls -selection`;
	}
else
	{
	createDisplayLayer -name Hi -number 1 -nr;
	setAttr Hi.displayType 1;
	}
select -cl;
}

global proc asFitTglRLA ()
{
if (!`objExists Visualizers`)
	return;
string $tempString[];
string $visualizers[]=`listRelatives -ad -type transform Visualizers`;
int $onOff,$setOnOff;
for ($i=0;$i<size($visualizers);$i++)
	{
	$tempString=`listRelatives -s $visualizers[$i]`;
	if ($tempString[0]!="" || !`gmatch $visualizers[$i] "*Aim"`)
		continue;
	if (!$setOnOff)
		{
		$onOff=!`getAttr ($visualizers[$i]+".displayLocalAxis")`;
		$setOnOff=1;
		}
	setAttr ($visualizers[$i]+".displayLocalAxis") $onOff;
	}
}

global proc asJointsVisibility (int $onOff)
{
string $joints[]=`listRelatives -type joint -ad Main`;
int $drawStyle=0;
if (!$onOff)
	$drawStyle=2;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".drawStyle") $drawStyle;

//DrawStyle=none, is still selectable ( in some versions of Maya), so set to "Reference"
//correction: setting to "Reference", causes selection of FK controls to select Shape only.
//turns out DrawStyle=none is not selectable, after save & reopen file.
//if (`objExists jointLayer`)
//	setAttr jointLayer.displayType (2*!$onOff);
}

global proc asDisplayRigRLA (int $onOff)
{
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;
for ($i=0;$i<size($joints);$i++)
	setAttr ($joints[$i]+".displayLocalAxis") $onOff;
}

global proc asSetIsHistoricallyInteresting (string $controlSet)
{
string $controlSetMembers[]=`sets -q $controlSet`;
string $historyNodes[];
string $allSet="AllSet";
if ($controlSet=="FaceControlSet")
	$allSet="FaceAllSet";

for ($i=0;$i<size($controlSetMembers);$i++)
	{
	//history
	$historyNodes=`listHistory -future 0 -leaf 0 -il 1 -pdo 1 $controlSetMembers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		{
		if (!`sets -im $allSet $historyNodes[$y]`)
			continue;
		if (`getAttr ($historyNodes[$y]+".isHistoricallyInteresting")`)
			{
			setAttr ($historyNodes[$y]+".isHistoricallyInteresting") 0;
			}
		}
	//future
	$historyNodes=`listHistory -future 1 -leaf 0 -il 1 -pdo 1 $controlSetMembers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		{
		if (!`sets -im $allSet $historyNodes[$y]`)
			continue;
		if (`getAttr ($historyNodes[$y]+".isHistoricallyInteresting")`)
			{
			setAttr ($historyNodes[$y]+".isHistoricallyInteresting") 0;
			}
		}
	//shapes
	$historyNodes=`listRelatives -s $controlSetMembers[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		{
		if (!`sets -im $allSet $historyNodes[$y]`)
			continue;
		if (`getAttr ($historyNodes[$y]+".isHistoricallyInteresting")`)
			{
			setAttr ($historyNodes[$y]+".isHistoricallyInteresting") 0;
			}
		}
	}
}

global proc asCreateFitSkeleton ()
{
if (`objExists FitSkeleton`)
	delete FitSkeleton;
string $tempString[]=`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1.5 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
rename $tempString[0] FitSkeleton;
setAttr FitSkeletonShape.overrideEnabled 1;
setAttr FitSkeletonShape.overrideColor 29;
scale -r -p 0 0 0 2 2 2 FitSkeleton.cv[0:7];
duplicate -n FitSkeletonHeight FitSkeleton;
parent FitSkeletonHeight FitSkeleton;
parent -add -s FitSkeletonHeightShape FitSkeleton;
delete FitSkeletonHeight;
move -r 0 17 0 FitSkeletonHeightShape.cv[0:7];
setAttr -k 0 -l 1 FitSkeleton.tx;setAttr -k 0 -l 1 FitSkeleton.ty;setAttr -k 0 -l 1 FitSkeleton.tz;
setAttr -k 0 -l 1 FitSkeleton.rx;setAttr -k 0 -l 1 FitSkeleton.ry;setAttr -k 0 -l 1 FitSkeleton.rz;
asEnsureFitSkeletonAttributes;
//asFitSkeletonConnectControl;
select FitSkeleton;
}

global proc asEnsureFitSkeletonAttributes ()
{
if (!`objExists FitSkeleton`)
	return;
float $gap=0.75;
if (`optionVar -ex asFitSkeletonGap`)
	$gap=`optionVar -q asFitSkeletonGap`;

if (!`attributeExists visGeo FitSkeleton`)
	addAttr -k 1 -ln visGeo -at bool -dv 0 FitSkeleton;
if (!`attributeExists visGeoType FitSkeleton`)
	addAttr -k 1 -ln visGeoType -at "enum" -en "cylinders:boxes:spheres:bones" FitSkeleton;
if (!`attributeExists visCylinders FitSkeleton`)
	addAttr -k 0 -ln visCylinders -at bool FitSkeleton;
if (!`attributeExists visBoxes FitSkeleton`)
	addAttr -k 0 -ln visBoxes -at bool FitSkeleton;
if (!`attributeExists visSpheres FitSkeleton`)
	addAttr -k 0 -ln visSpheres -at bool FitSkeleton;
if (!`attributeExists visBones FitSkeleton`)
	addAttr -k 0 -ln visBones -at bool FitSkeleton;
if (!`attributeExists lockCenterJoints FitSkeleton`)
	addAttr -k 1 -ln lockCenterJoints -dv 1 -at bool FitSkeleton;
if (!`attributeExists visGap FitSkeleton`)
	addAttr -k 1 -ln visGap -at double -dv $gap -min 0 -max 1 FitSkeleton;

if (!`attributeExists visPoleVector FitSkeleton`)
	addAttr -k 1 -ln visPoleVector -at bool -dv 0 FitSkeleton;
if (!`attributeExists visJointOrient FitSkeleton`)
	addAttr -k 1 -ln visJointOrient -at bool -dv 0 FitSkeleton;
if (!`attributeExists visJointAxis FitSkeleton`)
	addAttr -k 1 -ln visJointAxis -at bool -dv 0 FitSkeleton;

if (!`attributeExists preRebuildScript FitSkeleton`)
	addAttr -ln preRebuildScript -dt "string" FitSkeleton;
if (!`attributeExists postRebuildScript FitSkeleton`)
	addAttr -ln postRebuildScript -dt "string" FitSkeleton;

asFitSkeletonConnectControl;
}

global proc asEnsureFitBaseStruct ()
{
if (!`objExists FitSkeletonVisualizers`)
	createNode -n FitSkeletonVisualizers transform;
if (!`objExists Aims`)
	createNode -n Aims -p FitSkeletonVisualizers transform;
if (!`objExists Systems`)
	createNode -n Systems -p FitSkeletonVisualizers transform;
}

global proc asFitSkeletonConnectControl ()
{
if (!`objExists FitSkeleton`)
	return;

if(`attributeExists visGeo FitSkeleton`)
	connectControl asVisGeo FitSkeleton.visGeo;
if(`attributeExists visGeoType FitSkeleton`)
	connectControl asVisGeoType FitSkeleton.visGeoType;
if(`attributeExists visGap FitSkeleton`)
	connectControl asVisGap FitSkeleton.visGap;
if(`attributeExists lockCenterJoints FitSkeleton`)
	connectControl asLockCenterJoints FitSkeleton.lockCenterJoints;

if(`attributeExists lockCenterJoints FitSkeleton`)
	asFitModeLockCenterJoints;

if(`attributeExists visPoleVector FitSkeleton`)
	connectControl asVisPoleVector FitSkeleton.visPoleVector;
if(`attributeExists visJointOrient FitSkeleton`)
	connectControl asVisJointOrient FitSkeleton.visJointOrient;
if(`attributeExists visJointAxis FitSkeleton`)
	connectControl asVisJointAxis FitSkeleton.visJointAxis;
}

global proc asStraightEndLoc (string $loc, float $lenght)
{
//maintain the `direction` with the end loc
string $parent;
float $pos[]=`getAttr ($loc+".t")`;
$tempString=`listConnections -s 0 -d 1 ($loc+".message")`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		{
		if (`attributeExists "child" $tempString[$i]`)
			if (`isConnected ($loc+".message") ($tempString[$i]+".child")`)
				$parent=$tempString[$i];
		if (`attributeExists "otherChildren" $tempString[$i]`)
			for ($y=0;$y<`getAttr -s ($tempString[$i]+".otherChildren")`;$y++)
				if (`isConnected ($loc+".message") ($tempString[$i]+".otherChildren["+$y+"]")`)
					$parent=$tempString[$i];
		}

if ($parent!="")
	{
	float $pos2[]=`getAttr ($parent+".t")`;
	float $parentLenght=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if ($lenght==0)
		$lenght=$parentLenght;
	float $lenghtMuliplier=1;
	if ($lenght!=0)
		$lenghtMuliplier=$parentLenght*1/$lenght;
	if (`objExists ($loc+"End")`)
		{
		if (!`getAttr -l ($loc+"End.tx")`)
			setAttr ($loc+"End.tx") ($pos[0]+($pos[0]-$pos2[0])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.ty")`)
			setAttr ($loc+"End.ty") ($pos[1]+($pos[1]-$pos2[1])/$lenghtMuliplier);
		if (!`getAttr -l ($loc+"End.tz")`)
			setAttr ($loc+"End.tz") ($pos[2]+($pos[2]-$pos2[2])/$lenghtMuliplier);
		}
	}
}

global proc asUpdateButtonEnables ()
{
if (!`columnLayout -q -ex asColumnLayout`)
	return;
int $hasBodySetup=`objExists "Group"`;
int $hasFaceSetup=`objExists FaceMotionSystem`;
int $hasVisualizers=`objExists FitSkeletonVisualizers`;
int $hasGeometryVisualizers=`objExists FitSkeletonVisualizers` && `objExists Aims`;
int $showDelteAdvButton,$showDelteAdvFaceButton;
if ($hasBodySetup && `getAttr FitSkeleton.v`)
	$showDelteAdvButton=1;
if ($hasFaceSetup && `getAttr FaceFitSkeleton.v`)
	$showDelteAdvFaceButton=1;
string $buildLabel;
string $skinLayerButtons[];

//Body
checkBox -e -v $hasGeometryVisualizers asVisGeo;
optionMenu -e -en $hasVisualizers asVisGeoType;
floatSliderGrp -e -en $hasVisualizers asVisGap;

button -e -m $showDelteAdvButton asDelteAdvButton;
checkBox -e -m $hasBodySetup asKeepAllCheckBox;
if (!$hasBodySetup)
	columnLayout -e -m 0 asBodyKeepColumnLayout;

button -e -m $hasBodySetup asToggleFitSkeletonButton;
$buildLabel="Build AdvancedSkeleton";
if ($hasBodySetup)
	$buildLabel="ReBuild AdvancedSkeleton";
button -e -l $buildLabel asBuildAdvancedSkeletonButton;

//Face
button -e -m $showDelteAdvFaceButton asDelteAdvFaceButton;
checkBox -e -m $hasFaceSetup asFaceKeepAllCheckBox;
if (!$hasFaceSetup)
	columnLayout -e -m 0 asFaceKeepColumnLayout;
button -e -m $hasFaceSetup asToggleFitFaceButton;
$buildLabel="Build AdvancedFace";
if ($hasFaceSetup)
	$buildLabel="ReBuild AdvancedFace";
button -e -m 1 -l $buildLabel asBuildAdvancedFaceButton;
if (`objExists FaceBuildInProgress`)
	{
	checkBox -e -m 0 asFaceKeepAllCheckBox;
	columnLayout -e -m 0 asFaceKeepColumnLayout;
	button -e -m 0 asBuildAdvancedFaceButton;
	button -e -m 0 asDelteAdvFaceButton;
	}

text -e -m $hasFaceSetup asBodyText;
text -e -m $hasFaceSetup asFaceText;
button -e -m $hasFaceSetup asGoToBuildPoseFaceButton;

$skinLayerButtons=`columnLayout -q -ca asFaceSkinLayersColumnLayout`;
for ($i=0;$i<size($skinLayerButtons);$i++)
	if (`button -q -ex $skinLayerButtons[$i]`)
		{
		$label=`button -q -l $skinLayerButtons[$i]`;
		if ($label=="Normal" || $label=="Create New Layer")
			continue;
		button -e -en `objExists ($label+"Layer")` $skinLayerButtons[$i];
		}
}

global proc asSceneOpened ()
{
global string $gSelect;
global int $asFitModeScriptJobNr4,$asFitModeScriptJobNr5;

if (`currentCtx`=="softModContext")
	setToolTo $gSelect;

$asFitModeScriptJobNr4=`scriptJob -runOnce 1 -e SceneOpened asSceneOpened`;
asOffFitMode;

asEnsureFitSkeletonAttributes;
asUpdateButtonEnables;
asFaceUpdateInfo 1;
asUpdateHud;
}

global proc asUpdateHud ()
{
if (`headsUpDisplay -q -ex HUDFitMode`) headsUpDisplay -rem HUDFitMode;
if (`headsUpDisplay -q -ex HUDEDSMode`) headsUpDisplay -rem HUDEDSMode;
if (`headsUpDisplay -q -ex HUDCSMMode`) headsUpDisplay -rem HUDCSMMode;
}

global proc asOffFitMode ()
{
global int $asFitModeScriptJobNr1;
global int $asFitModeScriptJobNr2[];
global int $asFitModeScriptJobNr3;
if (`headsUpDisplay -q -ex HUDFitMode`)
	headsUpDisplay -rem HUDFitMode;

if (`scriptJob -ex $asFitModeScriptJobNr1` && $asFitModeScriptJobNr1!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr1;
	$asFitModeScriptJobNr1=0;
	}
if (`scriptJob -ex $asFitModeScriptJobNr3` && $asFitModeScriptJobNr3!=0)
	{
	scriptJob -kill $asFitModeScriptJobNr3;
	$asFitModeScriptJobNr3=0;
	}
for ($i=0;$i<size($asFitModeScriptJobNr2);$i++)
	if ($asFitModeScriptJobNr2[$i])
		if (`scriptJob -ex $asFitModeScriptJobNr2[$i]`)
			{
			scriptJob -kill $asFitModeScriptJobNr2[$i];
			$asFitModeScriptJobNr2[$i]=0;
			}
}


global proc asToggleFitFace ()
{
int $fitFaceVis=`getAttr FaceFitSkeleton.visibility`;
setAttr -l 0 FaceFitSkeleton.v;
setAttr -l 1 FaceFitSkeleton.v (!$fitFaceVis);
catchQuiet (`setAttr FaceMotionSystem.v $fitFaceVis`);
asUpdateButtonEnables;
}


global proc asCopyAttrProperties (string $sourceObjAttr, string $destObjAttr)
{
float $temp[];
string $tempString[];
tokenize $sourceObjAttr "[.]" $tempString;
string $sourceObj=$tempString[0];
string $sourceAttr=$tempString[1];
tokenize $destObjAttr "[.]" $tempString;
string $destObj=$tempString[0];
string $destAttr=$tempString[1];
if (`attributeQuery -node $sourceObj -minExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -min $sourceAttr`;
	addAttr -e -min $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -maxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -max $sourceAttr`;
	addAttr -e -max $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMinExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMin $sourceAttr`;
	addAttr -e -softMinValue $temp[0] $destObjAttr;
	}
if (`attributeQuery -node $sourceObj -softMaxExists $sourceAttr`)
	{
	$temp=`attributeQuery -node $sourceObj -softMax $sourceAttr`;
	addAttr -e -softMaxValue $temp[0] $destObjAttr;
	}
}

global proc asUpdateDsToFitSkeleton ()
{
string $sel[]=`ls -sl`;
//Remove ewxisting FitSkeltonDrivingSystems first
string $systems[]=`listRelatives -c Systems`;
for ($i=0;$i<size($systems);$i++)
	if (`gmatch $systems[$i] "DS_*"`)
		delete $systems[$i];
string $drivingSystems[]=`listRelatives -c DrivingSystem`;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	$ds="DS_"+$drivingSystems[$i];
	createNode -n $ds -p "Systems" transform;
	string $uAs[]=`listAttr -ud $drivingSystems[$i]`;
	for ($y=0;$y<size($uAs);$y++)
		{
		$dsd=$ds+"_"+$uAs[$y];
		createNode -n $dsd -p $ds transform;
		asLockAttr $dsd 1 1 1 1;
		addAttr -k 1 -ln $uAs[$y] -at double $ds;
		asCopyAttrProperties ($drivingSystems[$i]+"."+$uAs[$y]) ($ds+"."+$uAs[$y]);
		$tempString=`listConnections -s 0 -d 1 ($drivingSystems[$i]+"."+$uAs[$y])`;
		for ($z=0;$z<size($tempString);$z++)
			{
			duplicate -n ("Fit_"+$tempString[$z]) $tempString[$z];
			if (`sets -im AllSet ("Fit_"+$tempString[$z])`)
				sets -rm AllSet ("Fit_"+$tempString[$z]);
			addAttr -k 1 -ln ("standinAttr"+$z) -at double $dsd;
			connectAttr ("Fit_"+$tempString[$z]+".output") ($dsd+".standinAttr"+$z);
			}
		}
	}
select $sel;
}

global proc asFitModeEnsureShaders ()
{
string $colors[]={"asRed","asRed2","asGreen","asGreen2","asBlue","asBlue2","asWhite","asBlack","asBones"};
float $rs[]={1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.78};
float $gs[]={0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , 0.76};
float $bs[]={0.0 , 1.0 , 0.0 , 0.0 , 1.0 , 1.0 , 1.0 , 0.0 , 0.72};
for ($i=0;$i<size($colors);$i++)
	{
	if (`objExists $colors[$i]` && `objExists ($colors[$i]+"SG")`)
		continue;
	if (`objExists $colors[$i]`) delete $colors[$i];
	if (`objExists ($colors[$i]+"SG")`) delete ($colors[$i]+"SG");
	shadingNode -n $colors[$i] -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name ($colors[$i]+"SG");
	connectAttr -f ($colors[$i]+".outColor") ($colors[$i]+"SG.surfaceShader");
	setAttr -type float3 ($colors[$i]+".color") $rs[$i] $gs[$i] $bs[$i];
	}
}

global proc asCreateSamplerMesh (string $sourceObj)
{
//make a copy of the geometry, so we can freeze transforms and get correct sampler-results
string $tempString[];
duplicate -n samplerMesh $sourceObj;
$tempString=`listRelatives -f -ni -s samplerMesh`;
rename $tempString[0] samplerMeshShape;
asLockAttr samplerMesh 0 0 0 0;
$tempString=`listRelatives -p samplerMesh`;
if ($tempString[0]!="")
	parent -w samplerMesh;
$tempString=`listRelatives -s -f samplerMesh`;
for ($w=0;$w<size($tempString);$w++)
	if (`getAttr ($tempString[$w]+".intermediateObject")`)
		delete $tempString[$w];
makeIdentity -a 1 -t 1 -r 1 -s 1 samplerMesh;
}

global proc asSelectDeformJoints ()
{
string $sel[]=`ls -sl`;
if (`objExists "DeformSet"`)
	select `sets -q "DeformSet"`;
//Deselect end-joints
string $tempString[];
string $deformJoints[]=`ls -sl`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Slider[0-9]"`)
		continue;
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		select -d $deformJoints[$i];
	}
for ($i=0;$i<size($deformJoints);$i++)
	if ($deformJoints[$i]=="Eye_R" || $deformJoints[$i]=="Eye_L" || $deformJoints[$i]=="Jaw_M")
		select -d $deformJoints[$i];
select -add $sel;
}

global proc asSetSmoothBindOptions ()
{
optionVar
-iv "multipleBindPosesOpt" 1
-iv "bindMethod" 1
-iv "bindTo" 2
-iv "skinMethod" 1
-iv "removeUnusedInfluences" 0
-iv "colorizeSkeleton" 0
-fv "maxInfl" 3
-iv "normalizeWeights" 2
-iv "obeyMaxInfl" 0;
SmoothBindSkinOptions;
}

global proc asOpenSelector ()
{
evalEcho ("source \""+`asGetScriptLocation`+"/AdvancedSkeleton5Files/Selector/biped.mel\"");
}

global proc asCreateTempNodes ()
{
createNode -n TempNodes transform;
string $tempNodes[]={"FKScapula_R","FKScapula_L","FKAnkle_L","FKAnkle_R","FKChest_M","FKElbow_L","FKElbow_R","FKHead_M","FKHip_L","FKHip_R","FKIndexFinger1_L","FKIndexFinger1_R","FKIndexFinger2_L","FKIndexFinger2_R","FKIndexFinger3_L","FKIndexFinger3_R","FKKnee_L","FKKnee_R","FKMiddleFinger1_L","FKMiddleFinger1_R","FKMiddleFinger2_L","FKMiddleFinger2_R","FKMiddleFinger3_L","FKMiddleFinger3_R","FKNeck_M","FKPinkyFinger1_L","FKPinkyFinger1_R","FKPinkyFinger2_L","FKPinkyFinger2_R","FKPinkyFinger3_L","FKPinkyFinger3_R","FKRingFinger1_L","FKRingFinger1_R","FKRingFinger2_L","FKRingFinger2_R","FKRingFinger3_L","FKRingFinger3_R","FKRoot_M","FKShoulder_L","FKShoulder_R","FKSpine1_M","FKThumbFinger1_L","FKThumbFinger1_R","FKThumbFinger2_L","FKThumbFinger2_R","FKThumbFinger3_L","FKThumbFinger3_R","FKToes_L","FKToes_R","FKWrist_L","FKWrist_R"};
for ($i=0;$i<size($tempNodes);$i++)
	createNode -n $tempNodes[$i] -p TempNodes transform;
select `listRelatives -ad TempNodes`;
}

global proc asFitSkeletonFromEdgeLoops ()
{
global string $gMove;
setToolTo $gMove;
float $pos[];
string $loc;
string $skinLoopSets[]=`sets -q SkinLoops`;
for ($i=0;$i<size($skinLoopSets);$i++)
	{
	$loc=`substitute "SkinLoops_" $skinLoopSets[$i] ""`;
	$loc=`substitute "_R" $loc ""`;
	$loc=`substitute "_M" $loc ""`;
	if (!`objExists $loc`)
		continue;
	select $skinLoopSets[$i];
	$pos=`manipMoveContext -q -position "Move"`;
	xform -ws -t $pos[0] $pos[1] $pos[2] $loc;
	}
select -cl;
}

global proc asCreateSkinLoop (int $mirroring)
{
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
string $fkControl=$sel[size($sel)-1];
string $deformJoint;
if (`objExists DeformSet` && `sets -im DeformSet $fkControl`)
	$deformJoint=$fkControl;
else
	{
	$deformJoint=`substitute "FK" $fkControl ""`;
	if (!`gmatch $fkControl "FK*"`)
		error "No FK control selected";
	}
float $pos[];
float $scale=1;
if (`objExists FitSkeleton`)
	$scale=`getAttr FitSkeleton.sx`;
//float $mirrorTolerance=0.001*$scale;

int $neighboursInLoop;
string $mirrorFkControl;
string $tempString[],$tempString2[],$tempString3[],$mirrorVtxs[];

//validate complete loop
select -d $fkControl;
ConvertSelectionToVertices;
$tempString=`ls -sl -fl`;
for ($i=0;$i<size($tempString);$i++)
	{
	select $tempString[$i];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $tempString[$i];
	$tempString2=`ls -sl -fl`;
	$neighboursInLoop=0;
	for ($y=0;$y<size($tempString2);$y++)
		if (`stringArrayCount $tempString2[$y] $tempString`)
			$neighboursInLoop++;
	if ($neighboursInLoop!=2)
		{
		select $tempString[$i];
		if ($mirroring)
			error ("Not a complete loop, on mirrored side");
		else
			error ("Not a complete loop");
		}
	}

if (`objExists ("SkinLoops_"+$deformJoint)`)
	delete ("SkinLoops_"+$deformJoint);

if (!`objExists SkinLoops`)
	sets -em -name SkinLoops;
select $sel;
select -d $fkControl;
sets -name ("SkinLoops_"+$deformJoint);
sets -add  SkinLoops ("SkinLoops_"+$deformJoint);

if (`checkBox -q -v asCreateSkinLoopCheckBox` && !`gmatch $deformJoint "*_M"` && !$mirroring)
	{
	select ("SkinLoops_"+$deformJoint);
	ConvertSelectionToVertices;
	$tempString=`ls -sl -fl`;
	$tempString2=`ls -sl -o`;
	$tempString3=`listRelatives -p $tempString2[0]`;
	if (`objExists closestSampler`) delete closestSampler;
	if (`objExists samplerMesh`) delete samplerMesh;
	asCreateSamplerMesh $tempString3[0];
	createNode -n closestSampler closestPointOnMesh;
	connectAttr -f samplerMesh.outMesh closestSampler.inMesh;
	
	for ($i=0;$i<size($tempString);$i++)
		{
		select $tempString[$i];
		$pos=`xform -q -ws -t $tempString[$i]`;
		setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
		int $closestVtxIndex=`getAttr closestSampler.closestVertexIndex`;
		$mirrorVtxs[size($mirrorVtxs)]=$tempString2[0]+".vtx["+$closestVtxIndex+"]";
		}
	select $mirrorVtxs;
	ConvertSelectionToContainedEdges;
	if (`gmatch $deformJoint "*_R"`) $mirrorFkControl=`substitute "_R" $fkControl "_L"`;
	if (`gmatch $deformJoint "*_L"`) $mirrorFkControl=`substitute "_L" $fkControl "_R"`;
	select -add $mirrorFkControl;
	asCreateSkinLoop 1;
	}
if (`objExists closestSampler`) delete closestSampler;
if (`objExists samplerMesh`) delete samplerMesh;
print ("// SkinLoops_"+$deformJoint+" Created\n");
select $sel;
}

global proc asSelectAllSkinLoops ()
{
select SkinLoops;
select -add `ls -sl -o`;
}

global proc asDeleteCutUp ()
{
delete `listConnections CutUp.drawInfo`;
delete CutUp;
}

global proc asBindSkinLoops (int $createCutUp)
{
source removeUnusedInfluences;
global string $gMove;
string $sel[]=`ls -sl`;
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*[.]*"`)
		error ("Selection is not a object:"+$sel[$i]);
int $tempInt[],$twistJoints[];
int $haveSkinCluster,$numVtxs,$foundDownSideVtx,$loopAffectsCut;
float $circumference,$radius,$ratio;
float $pos[],$posA[],$posB[],$values[];
string $tempString[],$tempString2[],$deformJoints[],$parentJoints[],$childJoints[],$historyNodes[],$skinClusterJoints[],$infs[];
string $allJointChildren[],$edgeLoopVtxs[],$allEdgeLoopVtxs[],$allNonPartEdgeLoopVtxs[],$neighbourVtxs[];
string $skinCluster,$weightTo,$cutName,$twistJoint;
string $skinLoopSets[]=`sets -q SkinLoops`;
$skinLoopSets=`sort $skinLoopSets`;

createNode -n CutUpWIP transform;
sets -em -n SkinLoopWeighted;
if ($createCutUp && !`objExists CutUp`)
	{
	createDisplayLayer -e -name CutUp;
	setAttr CutUp.color 29;
	setAttr CutUp.displayType 2;
	}

string $skinLoopObjects[];
select SkinLoops;
$tempString=`ls -sl -o`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	if (!`stringArrayCount $tempString2[0] $skinLoopObjects`)
		$skinLoopObjects[size($skinLoopObjects)]=$tempString2[0];
	}

for ($i=0;$i<size($sel);$i++)
	{
	if (!`stringArrayCount $sel[$i] $skinLoopObjects`)
		{
		print ("// SkinLoops not defined for \""+$sel[$i]+"\", skipping this\n");
		continue;
		}
	if ($createCutUp)
		{//temp geo, to maintain weights on original
		duplicate -n ($sel[$i]+"CutUp") $sel[$i];
		$tempString=`listRelatives -s ($sel[$i]+"CutUp")`;
		for ($w=0;$w<size($tempString);$w++)
			if (`getAttr ($tempString[$w]+".intermediateObject")`)
				delete $tempString[$w];
		$sel[$i]=$sel[$i]+"CutUp";
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			$tempString=`duplicate $skinLoopSets[$y]`;
			rename $tempString[0] ($skinLoopSets[$y]+"CutUp");

			select $skinLoopSets[$y];
			$tempString=`ls -sl -fl`;
			for ($t=0;$t<size($tempString);$t++)
				if (`gmatch $tempString[$t] ($sel[$i]+"[.]*")`)
					{
					sets -add ($skinLoopSets[$y]+"CutUp") $tempString[$t];
					sets -rm $skinLoopSets[$y] $tempString[$t];
					}
			}

		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			rename $skinLoopSets[$y] ($skinLoopSets[$y]+"Temp");
			rename ($skinLoopSets[$y]+"CutUp") $skinLoopSets[$y];
			}
		}
	$haveSkinCluster=0;
	$tempInt=`polyEvaluate -v $sel[$i]`;
	$numVtxs=$tempInt[0];
	if (!$createCutUp)
		$historyNodes=`listHistory $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]`=="skinCluster")
			{
			$haveSkinCluster=1;
			$skinCluster=$historyNodes[$y];
			}
	if ($haveSkinCluster)
		skinPercent -tv Root_M 1 $skinCluster $sel[$i];
	else
		{
		select Root_M $sel[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		$skinClusterJoints=`listConnections ($skinCluster+".matrix")`;
		$deformJoints[$y]=`substitute "SkinLoops_" $skinLoopSets[$y] ""`;
		$parentJoints[$y]=$childJoints[$y]="";
		$twistJoints[$y]=0;

		$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$parentJoints[$y]=$tempString[0];
		$tempString=`listRelatives -c -type joint $deformJoints[$y]`;
		if ($tempString[0]!="")
			$childJoints[$y]=$tempString[0];
		if (!`stringArrayCount $deformJoints[$y] $skinClusterJoints`)
			{
			skinCluster -e -lw false -wt 0 -ai $deformJoints[$y] $skinCluster;
			$skinClusterJoints[size($skinClusterJoints)]=$deformJoints[$y];
			}
		if ($parentJoints[$y]!="")
			if (!`stringArrayCount $parentJoints[$y] $skinClusterJoints`)
				{
				skinCluster -e -lw false -wt 0 -ai $parentJoints[$y] $skinCluster;
				$skinClusterJoints[size($skinClusterJoints)]=$parentJoints[$y];
				}
		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		refresh;
		skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
		sets -add SkinLoopWeighted `ls -sl`;
		}
	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	string $loopVtxs[]=`ls -sl`;
	select ($sel[$i]+".vtx[0:"+$numVtxs+"]");
	select -d $loopVtxs;
	$nonLoopVtx=`ls -sl -fl`;
	refresh;
	weightHammerVerts;

	//another round of hammer, just near loops, to improve chance of finding $DownSideVtx
	select $loopVtxs;
	GrowPolygonSelectionRegion;
	select -d $loopVtxs;
	weightHammerVerts;

	select SkinLoops;
	ConvertSelectionToVertices;
	$allEdgeLoopVtxs=`ls -sl`;

	select -cl;
	for ($y=0;$y<size($skinLoopSets);$y++)
		if (!`gmatch $skinLoopSets[$y] "*Part[0-9]_*"`)
			select -add $skinLoopSets[$y];
	ConvertSelectionToVertices;
	$allNonPartEdgeLoopVtxs=`ls -sl`;

	for ($y=0;$y<size($skinLoopSets);$y++)
		{
		//Check that skinLoops comes from this object
		$tempString=`sets -q $skinLoopSets[$y]`;
		if (!size($tempString))
			continue;
		tokenize $tempString[0] "[.]" $tempString;
		if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
		if ($tempString[0]!=$sel[$i])
			continue;

		select $skinLoopSets[$y];
		ConvertSelectionToVertices;
		$edgeLoopVtxs=`ls -sl -fl`;
		select $edgeLoopVtxs[0];
		ConvertSelectionToEdges;
		ConvertSelectionToVertices;
		select -d $allEdgeLoopVtxs;
		$neighbourVtxs=`ls -sl -fl`;

		$allJointChildren=`listRelatives -ad -type joint $deformJoints[$y]`;
		for ($z=0;$z<size($neighbourVtxs);$z++)
			{
			if (`sets -im SkinLoopWeighted $neighbourVtxs[$z]`)
				continue;
			$foundDownSideVtx=0;
			select $neighbourVtxs[$z];
			$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $neighbourVtxs[$z]`;
			for ($q=0;$q<size($infs);$q++)
				{//size($infs)==1 means EndPiece
				if (`stringArrayCount $infs[$q] $allJointChildren` || size($infs)==1)
					{
					$cutName=$deformJoints[$y]+"_"+$infs[$q]+"_Cut";
					$foundDownSideVtx=1;
					break;
					}
				}
			if (`objExists ($cutName+"WIP")` || `objExists ($infs[$q]+"_"+$deformJoints[$y]+"_CutWIP")`)
				continue;
			if ($foundDownSideVtx)
				{
				$numSel=0;
				$previousNumSel=-1;
				for ($q=0;$q<100;$q++)
					{
					ConvertSelectionToEdges;
					ConvertSelectionToVertices;
//					select -d $allNonPartEdgeLoopVtxs;
					select -d $allEdgeLoopVtxs;
					$numSel=size(`ls -sl -fl`);
					if ($numSel==$previousNumSel)
						break;
					$previousNumSel=$numSel;
					if ($skinLoopSets[$y]!="SkinLoops_Root_M")
						$z=99;//dont need to check the other $neighbourVtxs
					}
				refresh;

				$tempString=`ls -sl -fl`;
				createNode -n ($cutName+"WIP") -p CutUpWIP transform;
				select $tempString;
				if (!$createCutUp)
					{
					if (!$twistJoints[$y])
						skinPercent -tv $deformJoints[$y] 1 $skinCluster `ls -sl`;
					if ($twistJoints[$y]==2)// Only works with TwistJoints==2 For Now.
						{
						tokenize $deformJoints[$y] "_" $tempString2;
						for ($w=1;$w<$twistJoints[$y]+1;$w++)
							{
							$twistJoint=$tempString2[0]+"Part"+$w+"_"+$tempString2[1];
							if (!`stringArrayCount $twistJoint $skinClusterJoints`)
								{
								skinCluster -e -lw false -wt 0 -ai $twistJoint $skinCluster;
								$skinClusterJoints[size($skinClusterJoints)]=$twistJoint;
								}
							}
						for ($w=0;$w<size($tempString);$w++)
							{
							$infs=`skinPercent -ignoreBelow 0.0000001 -q -t $skinCluster $tempString[$w]`;
							$values=`skinPercent -ignoreBelow 0.0000001 -q -v $skinCluster $tempString[$w]`;
							$tempString2=`listRelatives -ad -type joint $infs[0]`;
							if (`stringArrayCount $infs[1] $tempString2`)
								$ratio=$values[0];
							else
								$ratio=$values[1];
							tokenize $deformJoints[$y] "_" $tempString2;
							skinPercent -tv ($tempString2[0]+"Part1_"+$tempString2[1]) $ratio 
													-tv ($tempString2[0]+"Part2_"+$tempString2[1]) (1-$ratio)
													$skinCluster $tempString[$w];
							}
						}
					select $tempString;
					sets -add SkinLoopWeighted `ls -sl`;
					}
				if ($createCutUp)
					{
					ConvertSelectionToFaces;
					$tempString=`ls -sl`;
					if (`objExists $cutName`)
						delete $cutName;
					duplicate -n $cutName $sel[$i];
					asLockAttr $cutName 0 0 0 0;
					$tempString2=`listRelatives -s $cutName`;
					for ($w=0;$w<size($tempString2);$w++)
						if (`getAttr ($tempString2[$w]+".intermediateObject")`)
							delete $tempString2[$w];					
					parent $cutName $deformJoints[$y];
					editDisplayLayerMembers -noRecurse CutUp $cutName;
					select -cl;
					for ($q=0;$q<size($tempString);$q++)
						select -add `substitute $sel[$i] $tempString[$q] $cutName`;
					asInvertSelection;
					delete;
					select $cutName;
					CenterPivot;
					//cap
					for ($r=0;$r<size($skinLoopSets);$r++)
						{
						select $skinLoopSets[$r];
						$tempString=`ls -sl -o`;
						$loopAffectsCut=0;
						for ($t=0;$t<size($tempString);$t++)
							{
							$tempString2=`listRelatives -p $tempString[$t]`;
							if ($tempString2[0]==$cutName)
								{
								$loopAffectsCut=1;
								break;
								}
							}
						if (!$loopAffectsCut)
							continue;
						select -d ($sel[$i]+".e[0:99999]");
						//get radius of loop
						$circumference=0;
						$tempString=`ls -sl -fl`;
						for ($t=0;$t<size($tempString);$t++)
							{
							select $tempString[$t];
							ConvertSelectionToVertices;
							$tempString2=`ls -sl -fl`;
							$posA=`xform -q -ws -t $tempString2[0]`;
							$posB=`xform -q -ws -t $tempString2[1]`;
							$circumference+=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
							}
						$radius=($circumference/3.14)/2.0;
						select $skinLoopSets[$r];
						select -d ($sel[$i]+".e[0:99999]");
						$tempString=`polyExtrudeEdge -constructionHistory 1 -keepFacesTogether 1 -pvx 1.927402496 -pvy 3.865962148 -pvz 0.184265554 -divisions 1 -twist 0 -taper 1 -offset 0 -thickness 0 -smoothingAngle 30`;
						$extrudedSel=`ls -sl`;
						setToolTo $gMove;
						$pos=`manipMoveContext -q -position "Move"`;
						scale -r -p $pos[0] $pos[1] $pos[2] 0.25 0.25 0.25;
						$posB=`xform -q -ws -piv $cutName`;
						spaceLocator -n tempLoc1;
						xform -ws -t $posB[0] $posB[1] $posB[1] tempLoc1;
						spaceLocator -n tempLoc2;
						xform -ws -t $pos[0] $pos[1] $pos[1] tempLoc2;	
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 tempLoc2 tempLoc1;
						parent $cutName tempLoc1;
						select $extrudedSel;
						move -r -ls -wd ($radius*0.5) 0 0;

						parent $cutName $deformJoints[$y];
						delete tempLoc1 tempLoc2;
						select $cutName;
						DeleteHistory;
						sets -rm $skinLoopSets[$r] ($cutName+".e[0:99999]");
						}
					}
				}
			}
		}

	if (!$createCutUp)
		{
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			//Check that skinLoops comes from this object
			$tempString=`sets -q $skinLoopSets[$y]`;
			if (!size($tempString))
				continue;
			tokenize $tempString[0] "[.]" $tempString;
			if (`objectType $tempString[0]`=="mesh"){$tempString=`listRelatives -p $tempString[0]`;}
			if ($tempString[0]!=$sel[$i])
				continue;
			if (`gmatch $deformJoints[$y] "*Part[0-9]_*"`)//skip 50 weight of partial joint
				continue;

			select $skinLoopSets[$y];
			ConvertSelectionToVertices;
			$tempString2=`ls -sl`;
			$tempString=`listRelatives -p -type joint $deformJoints[$y]`;
			if (size($tempString))
				skinPercent -tv $deformJoints[$y] 0.5 -tv $tempString[0] 0.5 $skinCluster `ls -sl`;
			GrowPolygonSelectionRegion;
//			select -d $tempString2;
			select -d $loopVtxs;
			if (size(`ls -sl`))
				weightHammerVerts;
			}
		}
	if ($createCutUp)
		{
		delete $sel[$i];
		for ($y=0;$y<size($skinLoopSets);$y++)
			{
			if (`objExists $skinLoopSets[$y]`)
				delete $skinLoopSets[$y];
			rename ($skinLoopSets[$y]+"Temp") $skinLoopSets[$y];
			}
		}

	if (!$createCutUp)
		{
		select $sel[$i];
		removeUnusedInfluences;
		}
	}


delete CutUpWIP SkinLoopWeighted;
select -cl;
catchQuiet (`select $sel`);
if ($createCutUp)
	print "// SkinLoop CutUp completed.\n";
else
	print "// SkinLoop Bind completed.\n";
}

global proc asCopySkinLoopWeights ()
{
string $sel[]=`ls -sl`;

if (!`objExists SkinLoops`)
	error "SkinLoops not created";

int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster,$sourceSC;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

select SkinLoops;
select `ls -sl -o`;
$tempString=`ls -sl`;
string $source=$tempString[0];
$tempString=`ls -sl -showType $source`;
if ($tempString[1]=="mesh")
	{
	$tempString=`listRelatives -p $source`;
	$source=$tempString[0];
	}
$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$sourceSC=$history[$y];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 $source`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections ($sourceSC+".matrix")`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r  $source;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc string asStripSystemLetter (string $system)
{
string $systemNoLetter=$system;
int $numLetters=size($system);
if (`gmatch $system "*[A-Z]"`)
	$systemNoLetter=`substring $system 1 ($numLetters-1)`;
return $systemNoLetter;
}

global proc int asConfirmIfNotInBuildPose ()
{
if (!`objExists DeformSet`)
	return 1;
int $proceed=1;
int $maxTextLines=35;
int $numNonDef;
string $m;
string $deformJointsList[]=`sets -q DeformSet`;
string $checkAttr[]={"rx","ry","rz","sx","sy","sz"};
float $checkValues[]={0,0,0,1,1,1};
for ($i=0;$i<size($deformJointsList);$i++)
	for ($y=0;$y<size($checkAttr);$y++)
		{
		$value=`getAttr ($deformJointsList[$i]+"."+$checkAttr[$y])`;
		if ($value>($checkValues[$y]+0.01) || $value<($checkValues[$y]-0.01))
			{
			$m+=$deformJointsList[$i]+"."+$checkAttr[$y]+" = "+$value+"\n";
			$numNonDef++;
			}
		if ($numNonDef>$maxTextLines)
			{
			$m+="...And more..\n\n";
			$y=999;
			$i=999;
			}
		}
if ($m!="")
	{
	$m+="It is reccomended that you Go to Build Pose";
	string $dialog=`confirmDialog -t "Not in Build Pose"
		-m $m
		-b "Go to Build Pose, and Proceed"
		-b "Just Proceed"
		-b "Cancel"
		-ds "Cancel" -db "Cancel"`;
	if ($dialog=="Go to Build Pose, and Proceed")
		{
		asGoToBuildPose bodySetup;
		refresh;
		}
	if ($dialog=="Go to Build Pose, and Proceed")
		$proceed=1;
	else if ($dialog=="Just Proceed")
		$proceed=2;
	else
		$proceed=0;
	}
return $proceed;
}

global proc int asGetCurveNumCvs (string $curve)
{
int $form,$spans,$degrees,$numCv;
$form=`getAttr ($curve+".form")`;
$spans=`getAttr ($curve+".spans")`;
$degrees=`getAttr ($curve+".degree")`;
if ($form==2)
	$numCv=$spans;
else
	$numCv=$spans+$degrees;
return $numCv;
}

global proc float asgetCharHeight ()
{
float $height;
if (`objExists "Main"`)
	$height=`getAttr "Main.height"`;
return $height;
}

global proc asCreateSkeleton ()
{
string $fitSkeletonTemplate;
if (`attributeExists fitSkeletonTemplate FitSkeleton`)
	$fitSkeletonTemplate=`getAttr FitSkeleton.fitSkeletonTemplate`;

createNode -n SkeletonGeometry -p Geometry transform;
createDisplayLayer -e -name PolySkeleton;

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;

int $numChar,$hasBone,$b;
int $vs[];
float $dist,$dist2,$dist3;
float $pos[],$pos2[],$pos3[],$scale[];
string $newBone;
string $tempString[],$joints[],$children[];
string $deformJointsList[]=`sets -q "DeformSet"`;
string $copyBones[]={"Pelvis","Cranium","SpineVertebras","Mandible","Femur","Tibia","Fibula",
	"Calcaneus","Talus","Metatarsals","Phalanxs","Ribs","Humerus","Scapula","Clavicle","Ulna","Radius","CarpalA","CarpalB","Eye"};
string $joint,$side,$childJoint,$parentJoint,$sourceBone;
for ($i=0;$i<size($copyBones);$i++)
	for ($a=0;$a<3;$a++)
		{
		if ($a==0) $side="_M";
		if ($a==1) $side="_L";
		if ($a==2) $side="_R";
		$b=1;
		if ($side=="_L") $b=-1;
//		$joint=$copyBones[$i]+$side;
		if ($copyBones[$i]=="Pelvis") $joint="Root"+$side;
		if ($copyBones[$i]=="SpineVertebras") $joint="Root"+$side;
		if ($copyBones[$i]=="Cranium") $joint="Head"+$side;
		if ($copyBones[$i]=="Mandible") $joint="Jaw"+$side;
		if ($copyBones[$i]=="Femur") $joint="Hip"+$side;
		if ($copyBones[$i]=="Tibia") $joint="Knee"+$side;
		if ($copyBones[$i]=="Fibula") $joint="Knee"+$side;
		if ($copyBones[$i]=="Calcaneus") $joint="Ankle"+$side;
		if ($copyBones[$i]=="Talus") $joint="Ankle"+$side;
		if ($copyBones[$i]=="Metatarsals") $joint="Toes"+$side;
		if ($copyBones[$i]=="Phalanxs") $joint="Toes"+$side;
		if ($copyBones[$i]=="Ribs") $joint="Chest"+$side;
		if ($copyBones[$i]=="Humerus") $joint="Shoulder"+$side;
		if ($copyBones[$i]=="Scapula") $joint="Scapula"+$side;
		if ($copyBones[$i]=="Clavicle") $joint="Scapula"+$side;
		if ($copyBones[$i]=="Ulna") $joint="Elbow"+$side;
		if ($copyBones[$i]=="Radius") $joint="Elbow"+$side;
		if ($copyBones[$i]=="CarpalA") $joint="Wrist"+$side;
		if ($copyBones[$i]=="CarpalB") $joint="Wrist"+$side;
		if ($copyBones[$i]=="Eye") $joint="Eye"+$side;

		if ($fitSkeletonTemplate=="horse" || $fitSkeletonTemplate=="cat")
			{
			if ($copyBones[$i]=="Clavicle") $joint="";
			if ($copyBones[$i]=="CarpalA") $joint="";
			if ($copyBones[$i]=="CarpalB") $joint="";
			if ($copyBones[$i]=="Calcaneus") $joint="";
			if ($copyBones[$i]=="Talus") $joint="";
			if ($copyBones[$i]=="Metatarsals") $joint="";
			if ($copyBones[$i]=="Phalanxs") $joint="";
			}

		if (!`objExists $joint` || !`objExists ($copyBones[$i]+"Bone")`)
			continue;
		if (`objectType $joint`!="joint")
			continue;

		//fitSkeletonTemplate spesific bones
		if ($fitSkeletonTemplate!="" && `objExists ($fitSkeletonTemplate+$copyBones[$i]+"Bone")`)
			{
			delete ($copyBones[$i]+"Bone");
			rename ($fitSkeletonTemplate+$copyBones[$i]+"Bone") ($copyBones[$i]+"Bone");
			$tempString=`listRelatives -ad -type transform ($copyBones[$i]+"Bone")`;
			for ($y=0;$y<size($tempString);$y++)
				if (`gmatch $tempString[$y] ("*"+$fitSkeletonTemplate+"*")`)
					rename $tempString[$y] (`substitute $fitSkeletonTemplate $tempString[$y] ""`);
			}

		duplicate -n ($copyBones[$i]+"Bone"+$side) ($copyBones[$i]+"Bone");
		parent ($copyBones[$i]+"Bone"+$side) SkeletonGeometry;
		delete `parentConstraint $joint ($copyBones[$i]+"Bone"+$side) `;
		setAttr ($copyBones[$i]+"Bone"+$side+".v") 1;
//		sets -e -forceElement asBonesSG ($copyBones[$i]+"Bone"+$side);
		editDisplayLayerMembers -noRecurse PolySkeleton ($copyBones[$i]+"Bone"+$side);
		$childJoint=`asRlaChild $joint`;
		if ($copyBones[$i]=="SpineVertebras")
			{
			if (`objExists Head_M`) $childJoint="CraniumBone"+$side+"|CraniumBoneNeck";
			else if (`objExists Neck_M`) $childJoint="Neck_M";
			else if (`objExists Neck0_M`) $childJoint="Neck0_M";
			else if (`objExists Chest_M`) $childJoint="Chest_M";
			}
		if (($copyBones[$i]=="Cranium" || $copyBones[$i]=="Mandible")  && `objExists HeadEnd_M`) $childJoint="HeadEnd_M";
		if ($copyBones[$i]=="Femur"  && `objExists ("Knee"+$side)`) $childJoint="Knee"+$side;
		if (($copyBones[$i]=="Tibia" || $copyBones[$i]=="Fibula")  && `objExists ("Ankle"+$side)`) $childJoint="Ankle"+$side;
		if ($copyBones[$i]=="Humerus"  && `objExists ("Elbow"+$side)`) $childJoint="Elbow"+$side;
		if (($copyBones[$i]=="Ulna" || $copyBones[$i]=="Radius")  && `objExists ("Wrist"+$side)`) $childJoint="Wrist"+$side;
		if (($copyBones[$i]=="CarpalA"  || $copyBones[$i]=="CarpalB") && `objExists ("MiddleFinger1"+$side)`) $childJoint="MiddleFinger1"+$side;
		if ($childJoint!="")
			{
			$pos=`xform -q -ws -t $joint`;
			$pos2=`xform -q -ws -t $childJoint`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			$scale[0]=$dist;
			if (`attributeExists "fatY" $joint`)
				{
				$scale[1]=`getAttr ($joint+".fat")`*`getAttr ($joint+".fatY")`;
				$scale[2]=`getAttr ($joint+".fat")`*`getAttr ($joint+".fatZ")`;
				}
			else
				$scale[1]=$scale[2]=$scale[0];
			xform -os -a -s $scale[0] $scale[1] $scale[2] ($copyBones[$i]+"Bone"+$side);
			}
		if ($side=="_L")
			{
			$pos=`xform -q -ws -t $joint`;
			scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($copyBones[$i]+"Bone"+$side);
			}
/*
		//some bones not to un-twist
		if (`gmatch $joint "*Shoulder*"` || `gmatch $joint "*Hip*"`)
			if (`objExists ("TwistBalancer"+$joint)`)
				connectAttr -f ("TwistBalancer"+$joint+".rotateX") ($copyBones[$i]+"BoneParentConstraint"+$side+"_parentConstraint1.target[0].targetOffsetRotateX");
*/

		//Spine / neck
		if ($copyBones[$i]=="SpineVertebras")
			{
			if (`objExists Root_M` && `objExists $childJoint`)
				delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject Root_M $childJoint SpineVertebrasBone_M`;
			$scale[0]=`getAttr SpineVertebrasBone_M.sx`;
			setAttr -type float3 SpineVertebrasBone_M.s $scale[0] $scale[0] $scale[0];
			//Coccyx
			select ("SpineVertebrasBone"+$side+"Shape");
			$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
			rename $tempString[0] FixSoftMod;
			rename $tempString[1] FixSoftModHandle;
			$pos=`xform -q -ws -t ("SpineVertebrasBone"+$side+"|SpineVertebrasCoccyx")`;
			$pos2=`xform -q -ws -t ("Root"+$side)`;
			$pos3=`xform -q -ws -t PelvisBone_M|PelvisBoneFemur`;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
			setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
			xform -piv $pos2[0] $pos2[1] $pos2[2] FixSoftModHandle;
			setAttr FixSoftMod.falloffRadius $dist;
			setAttr FixSoftMod.falloffMode 0;
			$scale[0]=`mag<<$pos2[0]-$pos3[0],$pos2[1]-$pos3[1],$pos2[2]-$pos3[2]>>`/$dist;
			setAttr -type float3 FixSoftModHandle.s $scale[0] $scale[0] $scale[0];
			select ("SpineVertebrasBone"+$side+"Shape");
			DeleteHistory;
			//Run-through Chest joint
			if (`objExists Root_M` && `objExists Chest_M`)
				{
				select ("SpineVertebrasBone"+$side+"Shape");
				$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
				rename $tempString[0] FixSoftMod;
				rename $tempString[1] FixSoftModHandle;
				$pos=`xform -q -ws -t Root_M`;
				$pos2=`xform -q -ws -t Chest_M`;
				$pos3=`xform -q -ws -t Head_M`;
				$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
				$dist2=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
				$dist3=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
				if (`objExists tempLoc`) delete tempLoc;
				spaceLocator -n tempLoc;
				createNode -n tempMotionPath motionPath;
				setAttr tempMotionPath.fractionMode 1;
				connectAttr SpineVertebrasBone_M|SpineVertebrasCurve.worldSpace tempMotionPath.geometryPath;
				connectAttr tempMotionPath.allCoordinates tempLoc.t;
				setAttr tempMotionPath.uValue ($dist/$dist2);
				$pos=`xform -q -ws -t tempLoc`;
				delete tempLoc tempMotionPath;
				setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
				setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
				xform -piv $pos[0] $pos[1] $pos[2] FixSoftModHandle;
				setAttr FixSoftMod.falloffRadius ($dist3/2.0);
				setAttr FixSoftMod.falloffMode 0;
				delete `pointConstraint Chest_M FixSoftModHandle`;
				select ("SpineVertebrasBone"+$side+"Shape");
				DeleteHistory;
				}
			}

		//Scapula
		if ($copyBones[$i]=="Scapula" && `objExists ("HumerusBone"+$side)` && `objExists RibsBone_M`)
			if ($fitSkeletonTemplate!="horse" && $fitSkeletonTemplate!="cat")
				{
				$dist=`getAttr ("HumerusBone"+$side+".sx")`;
				setAttr -type float3 ("ScapulaBone"+$side+".s") $dist $dist $dist;

				duplicate -n ("ScapulaBone"+$side+"_Copy") ("ScapulaBone"+$side);
				parent -w ("ScapulaBone"+$side+"_Copy");
				catchQuiet (`makeIdentity -a 1 -t 1 -r 1 -s 1 ("ScapulaBone"+$side+"_Copy")`);

				select ("ScapulaBone"+$side+"_CopyShape");
				$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
				rename $tempString[0] FixSoftMod;
				rename $tempString[1] FixSoftModHandle;
				$pos=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneLoc1")`;
				$pos2=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneLoc2")`;
				$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
				setAttr -type float3 FixSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
				setAttr FixSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
				xform -piv $pos[0] $pos[1] $pos[2] FixSoftModHandle;
				setAttr FixSoftMod.falloffRadius $dist;
				setAttr FixSoftMod.falloffMode 0;
				setAttr FixSoftMod.falloffInY 0;
				$pos3=`xform -q -ws -t ("RibsBone_M|RibsBoneLoc1")`;
				move -r 0 0 (($pos3[2]-$pos[2])*1.2) FixSoftModHandle;
				select ("ScapulaBone"+$side+"_CopyShape") ("ScapulaBone"+$side+"Shape");
				blendShape -n TempBS -w 0 1;
				setAttr TempBS.origin 0;
				select ("ScapulaBone"+$side);
				DeleteHistory;
				delete ("ScapulaBone"+$side+"_Copy");
				}

		//Clavicle
		if ($copyBones[$i]=="Clavicle" && `objExists ("ScapulaBone"+$side)` && `objExists RibsBone_M`)
			{
			$pos=`xform -q -ws -t ("RibsBone_M|RibsBoneClavicle")`;
			xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] ("ClavicleBone"+$side);
			$pos2=`xform -q -ws -t ("ScapulaBone"+$side+"|ScapulaBoneClavicle")`;
			$pos2[0]=$pos2[0]*$b;
			$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
			$scale[0]=$dist*$b;
			xform -os -a -s $scale[0] $scale[0] $scale[0] ($copyBones[$i]+"Bone"+$side);
			delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($b) 0 0 -upVector 0 $b 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject Chest_M ("ScapulaBone"+$side+"|ScapulaBoneClavicle") ($copyBones[$i]+"Bone"+$side)`;
			}

		//PelvisBone
		if ($copyBones[$i]=="Pelvis")
			{
			xform -ws -ro 0 0 0 PelvisBone_M;
			$tempString=`listRelatives -type joint -c Root_M`;
			for ($y=0;$y<size($tempString);$y++)
				if (`gmatch $tempString[$y] "*_R"`)
					{
					$pos=`xform -q -ws -t $tempString[$y]`;
					xform -ws -t 0 $pos[1] $pos[2] PelvisBone_M;
					$pos2=`xform -q -ws -t PelvisBone_M|PelvisBoneFemur`;
					xform -r -s ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) PelvisBone_M;
					$scale[0]=`getAttr PelvisBone_M.sx`;
					setAttr -type float3 PelvisBone_M.s $scale[0] $scale[0] $scale[0];
					}
			}

		//Cranium
		if ($copyBones[$i]=="Cranium" && `objExists Eye_R`)
			{
			$pos=`xform -q -ws -t Eye_R`;
			$pos2=`xform -q -ws -t ("CraniumBone"+$side+"|CraniumBoneEye")`;
			scale -r ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) ($pos[0]/$pos2[0]) CraniumBone_M;
			$scale[0]=`getAttr CraniumBone_M.sz`;
			setAttr -type float3 CraniumBone_M.s $scale[0] $scale[0] $scale[0];
			$pos2=`xform -q -ws -t ("CraniumBone"+$side+"|CraniumBoneEye")`;
			move -r 0 ($pos[1]-$pos2[1]) 0 CraniumBone_M;
			}

		//Mandible
		if ($copyBones[$i]=="Mandible" && `objExists CraniumBone_M`)
			{
			asAlign MandibleBone_M CraniumBone_M 1 1 0 0;
			$scale=`getAttr CraniumBone_M.s`;
			setAttr -type float3 MandibleBone_M.s $scale[0] $scale[0] $scale[0];
			}

		//Ankle
		if ($copyBones[$i]=="Calcaneus" && `objExists Toes` && `objExists Ankle` && `objExists Heel`)
			{
			$pos=`xform -q -ws -t ("Ankle"+$side)`;
			$pos2=`xform -q -ws -t ("CalcaneusBone"+$side+"|CalcaneusBoneLoc1")`;
			$dist=($pos[1]/($pos[1]-$pos2[1]))*0.95;
			scale -r $dist 1 $dist ("CalcaneusBone"+$side);
			$pos2=`xform -q -ws -t ("CalcaneusBone"+$side+"|CalcaneusBoneLoc2")`;
			$pos3=`xform -q -ws -t Heel`;
			$dist=(($pos[2]-$pos3[2])/($pos[2]-$pos2[2]))*0.9;
			scale -r 1 $dist 1 ("CalcaneusBone"+$side);
			setAttr ("CalcaneusBone"+$side+".sz") `getAttr ("CalcaneusBone"+$side+".sy")`;
			}
		if ($copyBones[$i]=="Talus")
			{
			$scale[0]=`getAttr ("CalcaneusBone"+$side+".sy")`;
			setAttr -type float3 ("TalusBone"+$side+".s") $scale[0] $scale[0] $scale[0];
			}

		//Metatarsals
		if (($copyBones[$i]=="Metatarsals" || $copyBones[$i]=="Phalanxs") && `objExists Toes` && `objExists Ankle`)
			{
			$scale[0]=`getAttr ("TalusBone"+$side+".sx")`;
	//		$scale[0]=(`getAttr ("Ankle"+$side+".fat")`*`getAttr ("Ankle"+$side+".fatZ")`)/1.5*$b;
			setAttr ($copyBones[$i]+"Bone"+$side+".sy") $scale[0];
			setAttr ($copyBones[$i]+"Bone"+$side+".sz") $scale[0];
			}
		if ($copyBones[$i]=="Metatarsals" && `objExists Toes` && `objExists Ankle`)
			{
			select ("MetatarsalsBone"+$side+"Shape");
			$tempString=`lattice  -divisions 2 2 2 -objectCentered true  -ldv 2 2 2`;
	//		setAttr ($tempString[0]+".outsideLattice") 1;
			parent $tempString[1] $tempString[2] ("MetatarsalsBone"+$side+"|MetatarsalsBoneLattice");
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $tempString[1] $tempString[2];
			$pos=`xform -q -ws -t ("MetatarsalsBone"+$side+"|MetatarsalsBoneToes")`;
			$pos2=`xform -q -ws -t ("TalusBone"+$side+"|TalusBoneToes")`;

			select -r ($tempString[1]+".pt[0][0:1][0]") ($tempString[1]+".pt[0][0:1][1]");
			move -r ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]);
			select ("MetatarsalsBone"+$side);
			DeleteHistory;
			}

		//Bind: Bind-to Bones - selection
		select ($copyBones[$i]+"Bone"+$side) $joint;
		$childJoint=`asRlaChild $joint`;
		while (`gmatch $childJoint "*Part[0-9]*"`)
			{
			select -add $childJoint;
			$tempString=`listRelatives -c -type joint $childJoint`;
			$childJoint=$tempString[0];
			}

		//Bind: Bind-to Bones - tweaks
		if ($copyBones[$i]=="SpineVertebras" && `objExists Chest_M`)
			{
			select Chest_M;
			if (`objExists Head_M`)
				select `listRelatives -p Head_M`;
			for ($y=0;$y<99;$y++)
				{
				$tempString=`listRelatives -p`;
				select -add $tempString;
				if (`stringArrayCount "Root_M" $tempString`)
				 break;
				}
			}
		if ($copyBones[$i]=="Metatarsals") {select -r `listRelatives -p $joint`;select -d $joint;}

		//Bind
		select -add ($copyBones[$i]+"Bone"+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($copyBones[$i]+"BoneSC"+$side);

		//Bind: tweak - Carpal (wrist)
		if ($copyBones[$i]=="CarpalA")
			{
			skinCluster -e  -dr 4 -ai `listRelatives -p ("Wrist"+$side)` ("CarpalABoneSC"+$side);
			select -r ("CarpalABone"+$side);
			skinPercent -tv ("Wrist"+$side) 0.5 ("CarpalABoneSC"+$side);
			}
		//Bind: tweak - Jaw_M (with FaceSetup)
		if ($copyBones[$i]=="Mandible")
			{
			$tempString=`listRelatives -p $joint`;
			if ($tempString[0]=="Face_M")
				{
				select ($copyBones[$i]+"Bone"+$side);
				$tempString=`cluster -n ($copyBones[$i]+"BoneCluster"+$side) -envelope 1`;
				parent ($copyBones[$i]+"BoneCluster"+$side+"Handle") ($copyBones[$i]+"Bone"+$side);
				setAttr ($copyBones[$i]+"BoneCluster"+$side+"Handle.v") 0;
				parentConstraint -mo Head_M ($copyBones[$i]+"BoneCluster"+$side+"Handle");
				scaleConstraint Head_M ($copyBones[$i]+"BoneCluster"+$side+"Handle");
				}
			}
		}

//Fingers (Phalanges & Metacarpal)
$sourceBone="PhalangesBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (!`gmatch $deformJointsList[$i] "*Finger*"`)
		continue;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint=="")
		continue;
	if ($fitSkeletonTemplate=="horse" || $fitSkeletonTemplate=="cat")
		continue;

	$numChar=size($deformJointsList[$i]);
	$newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	delete `parentConstraint $deformJointsList[$i] ($newBone+$side) `;
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $childJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatY")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatZ")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`gmatch $deformJointsList[$i] "*_L"`)
		{
		$pos=`xform -q -ws -t $deformJointsList[$i]`;
		scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($newBone+$side+".vtx[0:9999]");
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($newBone+$side);
		}
	select $deformJointsList[$i] ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//MetaCarpals
$sourceBone="MetacarpalBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (!`gmatch $deformJointsList[$i] "*Finger1*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*ThumbFinger1*"`)
		continue;
	$tempString=`listRelatives -p $deformJointsList[$i]`;
	$parentJoint=$tempString[0];

	$numChar=size($deformJointsList[$i]);
	string $jointName=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	$newBone=$jointName+"MetacarpalBone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	string $loc="CarpalBBone"+$side+"|CarpalBone"+$jointName;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	delete `parentConstraint $parentJoint ($newBone+$side) `;
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $parentJoint $deformJointsList[$i] ($newBone+$side)`;

	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $parentJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	if (`objExists $loc`)
		{// allow space for CarpalBone
		$pos3=`xform -q -ws -t $loc`;
		$dist=`mag<<$pos3[0]-$pos[0],$pos3[1]-$pos[1],$pos3[2]-$pos[2]>>`;
		}
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatY")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatZ")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`objExists $loc`)
		{
		move -r -os -wd `mag<<$pos2[0]-$pos3[0],$pos2[1]-$pos3[1],$pos2[2]-$pos3[2]>>` 0 0 ($newBone+$side+".vtx[0:9999]");
		}
	select $parentJoint ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//Generic
$sourceBone="GenericBone";
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$hasBone=0;
	$tempString=`listConnections -s 0 -d 1 ($deformJointsList[$i]+".worldMatrix")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "*BoneSC_*"`)
			$hasBone=1;
	if ($hasBone)
		continue;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if ($childJoint=="")
		continue;

	$numChar=size($deformJointsList[$i]);
	$newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
	$side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	duplicate -n ($newBone+$side) $sourceBone;
	parent ($newBone+$side) SkeletonGeometry;
	delete `parentConstraint $deformJointsList[$i] ($newBone+$side) `;
	setAttr ($newBone+$side+".v") 1;
	editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);
	$pos=`xform -q -ws -t $deformJointsList[$i]`;
	$pos2=`xform -q -ws -t $childJoint`;
	$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	$scale[0]=$dist;
	$scale[1]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatY")`;
	$scale[2]=`getAttr ($deformJointsList[$i]+".fat")`*`getAttr ($deformJointsList[$i]+".fatZ")`;
	xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);
	if (`gmatch $deformJointsList[$i] "*_L"`)
		{
		$pos=`xform -q -ws -t $deformJointsList[$i]`;
		scale -r -p $pos[0] $pos[1] $pos[2] -1 -1 -1 ($newBone+$side+".vtx[0:9999]");
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($newBone+$side);
		}
	select $deformJointsList[$i] ($newBone+$side);
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] ($newBone+"BoneSC"+$side);
	}

//horseCoffinBone
if ($fitSkeletonTemplate=="horse")
	{
	for ($i=0;$i<size($deformJointsList);$i++)
		{
		$numChar=size($deformJointsList[$i]);
		$newBone=`substring $deformJointsList[$i] 1 ($numChar-2)`+"Bone";
		$sourceBone="horseCoffinBone";
		$side=`substring $deformJointsList[$i] ($numChar-1) 99`;

		if ((`gmatch $deformJointsList[$i] "Fingers*"` || `gmatch $deformJointsList[$i] "Toes*"`) && `objExists ($newBone+$side)`)
			{
			$pos=`xform -q -ws -t $deformJointsList[$i]`;
			scale -r -p $pos[0] $pos[1] $pos[2] 1 2 2 ($newBone+$side+".vtx[0:9999]");
			}

		if (!(`gmatch $deformJointsList[$i] "*Fingers3_*"` || `gmatch $deformJointsList[$i] "*Toes3_*"`))
			continue;

		if (`objExists ($newBone+$side)`) delete ($newBone+$side);
		duplicate -n ($newBone+$side) $sourceBone;
		parent ($newBone+$side) SkeletonGeometry;
		delete `pointConstraint $deformJointsList[$i] ($newBone+$side) `;
		setAttr ($newBone+$side+".v") 1;
		editDisplayLayerMembers -noRecurse PolySkeleton ($newBone+$side);

		$scale[0]=$scale[1]=$scale[2]=`getAttr ($newBone+$side+".ty")`;
		setAttr ($newBone+$side+".ty") 0;
		xform -os -a -s $scale[0] $scale[1] $scale[2] ($newBone+$side);

		select $deformJointsList[$i] ($newBone+$side);
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($newBone+"BoneSC"+$side);
		}
	}
if ($fitSkeletonTemplate=="cat")
	{
	if (`objExists Toes1Bone_R`) delete Toes1Bone_R;
	if (`objExists Toes1Bone_L`) delete Toes1Bone_L;
	}

$tempString=`listRelatives -f -ad -type locator -type nurbsCurve SkeletonGeometry`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		delete `listRelatives -f -p $tempString[$i]`;

if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

//asMirrorGeometry Skeleton 0;

print ("// Skeleton created\n");
select -cl;
}

global proc asDeleteSkeleton ()
{
string $deleteObjs[]={"SkeletonGeometry","PolySkeleton","Skeleton_Geometry","Mannequin_Geometry","SkinCage_Geometry","Skeleton","tempAimAt"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateFromFitGeometry (string $geo)
{
//$geo=Box, Cyl, Bone
if (!`asConfirmIfNotInBuildPose`)
	return;
string $geoLongName="Boxes";
if ($geo=="Cyl")
	$geoLongName="Cylinders";
if ($geo=="Bone")
	$geoLongName="Skeleton";
string $sourceGeo=$geo;
if (`getModifiers`==4)
	$sourceGeo="Cyl";
if (`objExists ($geoLongName+"Geometry")`)
	error ("\""+$geoLongName+"Geometry\" Alread exists");
if (`objExists ("Poly"+$geoLongName)`)
	error ("\"Poly"+$geoLongName+"\" Alread exists");
createNode -n ($geoLongName+"Geometry") -p Geometry transform;
connectAttr -f Main.scale ($geoLongName+"Geometry.scale");
createDisplayLayer -e -name ("Poly"+$geoLongName);
setAttr ("Poly"+$geoLongName+".color") 14;
if ($geo=="Bone")
	setAttr ("Poly"+$geoLongName+".color") 21;

float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;
float $visGap=`getAttr FitSkeleton.visGap`;
float $pos[],$rot[];
if (`objExists asMirror`)
	delete asMirror;
//checkBox -e -v 1 asVisGeo;
int $visGeo=`getAttr FitSkeleton.visGeo`;
setAttr FitSkeleton.visGeo 1;
asFitGeometry;
setAttr FitSkeleton.visGeo $visGeo;

setAttr FitSkeleton.visGap 1;
	dgdirty -a;
refresh;
setAttr FitSkeletonVisualizers.v 0;
refresh;

string $joint;
string $aimsAD[]=`listRelatives -ad -type transform Aims`;
for ($i=$y=0;$i<size($aimsAD);$i++)
	if (`gmatch $aimsAD[$i] ("*"+$sourceGeo+"*")`)
		{
		$joint=`substitute $sourceGeo $aimsAD[$i] ""`;
		string $side="_M";
		$pos=`xform -q -ws -t $aimsAD[$i]`;

		if ($pos[0]<$sideTreshold*-1)
			$side="_R";
		for ($b=1;$b>-2;$b=$b-2)
			{
			if ($b==-1 && $side=="_M") continue;
			if ($b==-1 && $side=="_R") $side="_L";

			if (!`objExists ($joint+$side)`)//could be `noMirror`
				continue;

			duplicate -n ($aimsAD[$i]+$side) $aimsAD[$i];
			editDisplayLayerMembers -noRecurse ("Poly"+$geoLongName) ($aimsAD[$i]+$side);
			setAttr ($aimsAD[$i]+$side+".v") 1;
			createNode -n asMirror transform;
			parent ($aimsAD[$i]+$side) asMirror;
			if ($side=="_L")
				{
				setAttr asMirror.sx -1;
				polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($aimsAD[$i]+$side);
//				setAttr ($aimsAD[$i]+$side+".sz") (`getAttr ($aimsAD[$i]+$side+".sz")`*-1);
				}
			parent -w ($aimsAD[$i]+$side);
			delete asMirror;
			createNode -n ($aimsAD[$i]+"ParentConstraint"+$side) -p ($geoLongName+"Geometry") transform;
			asAlign ($aimsAD[$i]+"ParentConstraint"+$side) ($aimsAD[$i]+$side) 1 1 0 0;

			if (`objExists ($joint+"Part1_M")` && $geo=="Bone" && `objExists ($joint+"Bone_M")`) //Bind Spine and Neck Geo
				{
				select ($joint+"_M");
				for ($z=1;$z<99;$z++)
					if (`objExists ($joint+"Part"+$z+"_M")`) select -add ($joint+"Part"+$z+"_M");
					else break;
				select -add ($joint+"Bone_M");
				newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
				}
			else
				{
//				parentConstraint -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
				pointConstraint ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
				orientConstraint ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
//				scaleConstraint  -mo ($joint+$side) ($aimsAD[$i]+"ParentConstraint"+$side);
				connectAttr ($joint+$side+".s") ($aimsAD[$i]+"ParentConstraint"+$side+".s");
				}

			parent ($aimsAD[$i]+$side) ($aimsAD[$i]+"ParentConstraint"+$side);

			setAttr ($aimsAD[$i]+$side+"Shape.overrideEnabled") 0;
			asLockAttr ($aimsAD[$i]+$side) 1 1 0 0;
//			if ($geo=="Box")
//				asMirrorGeometry Boxes 0; // slower, but looks better
//			refresh;
			}
		}
setAttr FitSkeleton.visGap $visGap;
delete FitSkeletonVisualizers;
}

global proc asCreateMuscular ()
{
int $form,$spans,$degrees,$numCv,$numChar,$skinningMethod,$numCurves;
string $tempString[],$tempString2[],$muscles[],$curves[],$mirrorCurves[],$transforms[],$newTransforms[];
string $skinCluster,$attach,$newTransform,$mirrorMuscle,$nurbs,$mirrorNurbs,$loft,$mirrorLoft,$sc;
string $cmd;
float $values[],$pos[];

if (!`objExists SkeletonGeometry`)
	error "Create Skeleton Geometry first";
asFitModeEnsureShaders;
if (`objExists MuscularGeometry`)
	delete MuscularGeometry;

string $asMuscularFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asMuscular.ma";
file -i $asMuscularFile;
parent MuscularGeometry Geometry;
$muscles=`listRelatives -c Muscular_Muscles`;


//Attach curves to bones by wrap
for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$attach=`getAttr ($curves[$y]+".attach")`;
		select $curves[$y] ("Muscular_"+$attach);
		$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		rename $tempString[0] ($curves[$y]+"TempWrap");	
		}
	}

//match bones by worldspace BS
$tempString=`listRelatives -c Muscular_SkeletonGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -ni -s $tempString[$i]`;
	if (`objectType $tempString2[0]`!="mesh")
		continue;
	$muscularBone=$tempString[$i];
	$bone=`substitute "Muscular_" $muscularBone ""`;
	if (!`objExists $bone`)
		continue;
	select $bone $muscularBone;
	select `listRelatives -ni -s`;
	blendShape -n ($muscularBone+"BS") -w 0 1;
	setAttr ($muscularBone+"BS.origin") 0;
	}

//Special case, Muscular_ExternalOblique_R
for ($i=1;$i<5;$i++)
	{
	select -r ("Muscular_ExternalObliqueALT1_curve"+$i+"_R") ("Muscular_ExternalOblique_curve"+$i+"_R");
	blendShape -n ("Muscular_ExternalOblique_curve"+$i+"_RTempBS") -w 0 1;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[7]") 0;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[6]") 0.2;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[8]") 0.2;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[5]") 0.4;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[9]") 0.4;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[4]") 0.6;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[10]") 0.6;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[3]") 0.8;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[11]") 0.8;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[2]") 1;
	setAttr ("Muscular_ExternalOblique_curve"+$i+"_RTempBS.inputTarget[0].inputTargetGroup[0].targetWeights[0]") 1;
	}

//Delete-Wrap-History, but retain `shape`
for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$numCv=`asGetCurveNumCvs $curves[$y]`;
		$cmd="";
		for ($cv=0;$cv<$numCv;$cv++)
			{
			$pos=`xform -q -ws -t ($curves[$y]+".cv["+$cv+"]")`;
			$cmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$curves[$y]+".cv["+$cv+"];";
			}
		delete ($curves[$y]+"TempWrap");
		if (`gmatch $curves[$y] ("*ALT*")`)
			continue;
		if (`gmatch $curves[$y] ("Muscular_ExternalOblique_curve[0-9]_R")` && `objExists ($curves[$y]+"TempBS")`)
			delete ($curves[$y]+"TempBS");
		eval ($cmd);
		}
	}
delete Muscular_SkeletonGeometry;
for ($i=0;$i<size($muscles);$i++)
	if (`gmatch $muscles[$i] "*ALT*"`)
		{
		delete $muscles[$i];
		$muscles=`stringArrayRemove {$muscles[$i]} $muscles`;
		}

for ($i=0;$i<size($muscles);$i++)
	{
	$curves=`listRelatives -c $muscles[$i]`;
	for ($y=0;$y<size($curves);$y++)
		{
		$tempString=`listRelatives -s $curves[$y]`;
		$curveShape=$tempString[0];
		$tempString=`listConnections ($curveShape+".create")`;
		$skinCluster=$tempString[0];
		if ($skinCluster=="")
			continue;
		$skinningMethod=`getAttr ($skinCluster+".skinningMethod")`;
		$numCv=`asGetCurveNumCvs $curves[$y]`;
		$transforms=`skinPercent -ib 0 -q -t $skinCluster ($curves[$y]+".cv[0:99]")`;
		clear $newTransforms;
		$cmd="";
		for ($z=0;$z<size($transforms);$z++)
			{
			$newTransform=`substitute "Muscular_" $transforms[$z] ""`;
			if (!`objExists $newTransform`)//pickWalk -d up, until we find a match
				{
				select $transforms[$z];
				while (!`objExists $newTransform`)
					{
					pickWalk -d up;
					$tempString=`ls -sl`;
					$newTransform=`substitute "Muscular_" $tempString[0] ""`;
					}
				}
			$newTransforms[size($newTransforms)]=$newTransform;
			for ($cv=0;$cv<$numCv;$cv++)
				{
				$values=`skinPercent -ib 0 -q -v $skinCluster ($curves[$y]+".cv["+$cv+"]")`;
				$cmd+="skinPercent -tv "+$newTransform+" "+$values[$z]+" "+$curves[$y]+"SC "+$curves[$y]+".cv["+$cv+"];\n";
				}
			}
		delete $skinCluster;
		select $curves[$y];
		select -add $newTransforms;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($curves[$y]+"SC");
		setAttr ($curves[$y]+"SC.skinningMethod") $skinningMethod;
		eval $cmd;
		}

	//Mirror
	$numChar=size($muscles[$i]);
	$mirrorMuscle=`substring $muscles[$i] 1 ($numChar-2)`+"_L";
	$nurbs=`substring $muscles[$i] 1 ($numChar-2)`+"_loft_R";
	$mirrorNurbs=`substring $muscles[$i] 1 ($numChar-2)`+"_loft_L";
	if (!`objExists $nurbs`)
		continue;

	duplicate -n $mirrorMuscle $muscles[$i];
	setAttr ($mirrorMuscle+".sx") -1;
	$curves=`listRelatives -c $mirrorMuscle`;
	$tempString=`listRelatives -f -c $mirrorMuscle`;
	for ($y=0;$y<size($curves);$y++)
		{
		$numChar=size($curves[$y]);
		$mirrorCurves[$y]=`substring $curves[$y] 1 ($numChar-2)`+"_L";
		rename $tempString[$y] $mirrorCurves[$y];
		asLockAttr $mirrorCurves[$y] 0 0 0 0;
		}
	makeIdentity -a 1 -t 1 -r 1 -s 1 $mirrorMuscle;
	for ($y=0;$y<size($curves);$y++)
		{
		$tempString=`listConnections ($curves[$y]+".create")`;
		$sc=$tempString[0];
		$tempString=`listConnections -s 1 -d 0 ($sc+".matrix")`;
		select -cl;
		for ($z=0;$z<size($tempString);$z++)
			{
			$numChar=size($tempString[$z]);
			if (`gmatch $tempString[$z] "*_R"`)
				select -add (`substring $tempString[$z] 1 ($numChar-2)`+"_L");
			else
				select -add $tempString[$z];
			}
		select -add $mirrorCurves[$y];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($mirrorCurves[$y]+"SC");
		select $curves[$y] $mirrorCurves[$y];
		copySkinWeights -ss $sc -ds ($mirrorCurves[$y]+"SC") -mirrorMode YZ -mirrorInverse -surfaceAssociation closestPoint -influenceAssociation closestJoint;
		}

	duplicate -n $mirrorNurbs $nurbs;
	$tempString=`listConnections ($nurbs+".create")`;
	$loft=$tempString[0];
	$tempString=`duplicate $loft`;
	$mirrorLoft=$tempString[0];
	connectAttr ($mirrorLoft+".outputSurface") ($mirrorNurbs+".create");
	$tempString=`listConnections ($loft+".inputCurve")`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$numChar=size($tempString[$y]);
		connectAttr (`substring $curves[$y] 1 ($numChar-2)`+"_L.worldSpace[0]") ($mirrorLoft+".inputCurve["+$y+"]");
		}
	//reverse
	$numCurves=`getAttr -s ($loft+".reverse")`;
	for ($y=0;$y<$numCurves;$y++)
		setAttr ($mirrorLoft+".reverse["+$y+"]") (!`getAttr ($loft+".reverse["+$y+"]")`);
	}
delete Muscular_Root_M;
select -cl;
print ("// Muscles created\n");
}

global proc asDeleteMuscular ()
{
string $deleteObjs[]={"MuscularGeometry","Muscular_SkeletonGeometry","Muscular_Root_M"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreatePolyBoxes ()
{
asCreateFromFitGeometry Box;
float $fitSkeletonScale=`getAttr FitSkeleton.sx`;
float $mag;
float $scale[3],$posA[3],$posB[3];
string $toes,$heel,$childLabel;
string $tempString[];
string $deformJointsList[]=`sets -q "DeformSet"`;
for ($i=0;$i<size($deformJointsList);$i++)
	{
	int $numChar=size($deformJointsList[$i]);
	string $joint=`substring $deformJointsList[$i] 1 ($numChar-2)`;
	string $side=`substring $deformJointsList[$i] ($numChar-1) 99`;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	if ($tempString[0]=="")
		continue;
	if (`objExists ($joint+"Box"+$side)`)
		continue;
	if (`gmatch $deformJointsList[$i] "*Eye*"`)
		continue;
	createNode -n ($joint+"BoxParentConstraint"+$side) -p BoxesGeometry transform;
	duplicate -n ($joint+"Box"+$side) RootBox_M;
	parent ($joint+"Box"+$side) ($joint+"BoxParentConstraint"+$side);
	setAttr -type float3 ($joint+"Box"+$side+".s") 1 1 1;
	xform -ws -t 0 0.875 -0.875 ($joint+"Box"+$side+".vtx[0]");
	xform -ws -t 0 0.875 0.875 ($joint+"Box"+$side+".vtx[1]");
	xform -ws -t 1 0.875 -0.875 ($joint+"Box"+$side+".vtx[2]");
	xform -ws -t 1 0.875 0.875 ($joint+"Box"+$side+".vtx[3]");
	xform -ws -t 1 -0.875 -0.875 ($joint+"Box"+$side+".vtx[4]");
	xform -ws -t 1 -0.875 0.875($joint+"Box"+$side+".vtx[5]");
	xform -ws -t 0 -0.875 -0.875 ($joint+"Box"+$side+".vtx[6]");
	xform -ws -t 0 -0.875 0.875 ($joint+"Box"+$side+".vtx[7]");
//	parentConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	pointConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	orientConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
//	scaleConstraint ($joint+$side) ($joint+"BoxParentConstraint"+$side);
	connectAttr ($joint+$side+".s") ($joint+"BoxParentConstraint"+$side+".s");
	$scale={0.1,1,1};
	$scale[1]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatY")`*$fitSkeletonScale;
	$scale[2]=`getAttr ($joint+$side+".fat")`*`getAttr ($joint+$side+".fatZ")`*$fitSkeletonScale;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	$mag=0;
	for ($y=0;$y<size($tempString);$y++)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$posB=`xform -q -ws -t $tempString[$y]`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($mag>$scale[0]) {
		$scale[0]=$mag;}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$tempString=`listRelatives -c -type joint $joint`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Toes*"`)
				$toes=$tempString[$y];
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			}
		}
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		{
		$posA=`xform -q -ws -t $deformJointsList[$i]`;
		$scale[0]=$posA[1];
		}
	setAttr -type float3 ($joint+"Box"+$side+".s") $scale[0] $scale[1] $scale[2];
	if (`gmatch $deformJointsList[$i] "*Ankle*"` && `objExists $toes` && `objExists ($toes+"Box"+$side)` && `objExists $heel`)
		{
		polySubdivideFacet -dv 1 -m 0 -ch 0 ($joint+"Box"+$side);
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[0]")`;
		xform -ws -t $posA[0] $posA[1] $posA[2] ($joint+"Box"+$side+".vtx[12]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[1]")`;
		xform -ws -t $posB[0] $posB[1] $posB[2] ($joint+"Box"+$side+".vtx[10]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) (($posA[1]+$posB[1])/2.0) (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[8]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`;
		xform -ws -t $posA[0] 0 $posA[2] ($joint+"Box"+$side+".vtx[2]");
		$posB=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`;
		xform -ws -t $posB[0] 0 $posB[2] ($joint+"Box"+$side+".vtx[3]");
		xform -ws -t (($posA[0]+$posB[0])/2.0) 0 (($posA[2]+$posB[2])/2.0) ($joint+"Box"+$side+".vtx[11]");

		$posA=`xform -q -ws -t $heel`;
		$posB=`xform -q -ws -t ($joint+"Box"+$side+".vtx[15]")`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		move -r -os -wd 0 ($mag*-1) 0 ($joint+"Box"+$side+".vtx[4:5]") ($joint+"Box"+$side+".vtx[15]");

		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[7]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[7]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[6]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[6]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[5]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[5]");
		$posA=`xform -q -ws -t ($toes+"Box"+$side+".vtx[4]")`; xform -ws -t $posA[0] 0 $posA[2] ($toes+"Box"+$side+".vtx[4]");
		if ($side=="_L")
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joint+"Box"+$side);
		}
	}

asMirrorGeometry Boxes 0;
print "// PolyBoxes created\n";
select -cl;
}

global proc asDeletePolyBoxes ()
{
if (`objExists "BoxesGeometry"`)
	delete "BoxesGeometry";
if (`objExists "PolyBoxes"`)
	delete "PolyBoxes";
}

global proc asCreateBoolean ()
{
global string $gMainProgressBar;
int $vs[];
string $tempString[],$tempString2[],$boxes[];
string $dupObj,$dupBox,$joint,$puppet,$restoreVisCmd;

if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	refresh;
	}
string $dialog=`confirmDialog -t "Boolean"
	-m "Attempt to Boolean selected geometry with PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "BoxesGeometry"`)
	error "No BoxesGeometry in scene !";
$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}


string $objs[]=`ls -sl`;
if (size($objs)<1)
	error "No Objects Selected !";

if (!`objExists Bool`)
	{
	createDisplayLayer -e -name Bool;
	setAttr Bool.color 21;
	setAttr Bool.displayType 2;
	}
dgdirty -a;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
progressBar -e -st "Creating Booleans" -bp -ii 1 -min 0 -max (size($objs)) $gMainProgressBar;
for ($i=0;$i<size($objs);$i++)
	{
	$restoreVisCmd+="setAttr "+$objs[$i]+".v "+`getAttr ($objs[$i]+".v")`+";";
	setAttr ($objs[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($objs);$i++)
	{
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;break;}
		$joint=`substitute "Box" $boxes[$y] ""`;
		if (`objExists ($tempString[0]+"Bool"+"_"+$tempString[1])`)
			warning ("Object \""+$tempString[0]+"Bool"+"_"+$tempString[1]+"\" Already exists...\n");
		$bool=`createNode -n ($tempString[0]+"Bool"+"_"+$tempString[1]) transform`;
		delete $bool;
		$dupObj=$objs[$i]+"_"+$boxes[$y];
		duplicate -n $dupObj $objs[$i];
		$tempString=`listRelatives -p $dupObj`;
		if ($tempString[0]!="")
			parent -w $dupObj;
		setAttr ($dupObj+".visibility") 0;
		$dupBox=$objs[$i]+"_"+$boxes[$y]+"Box";
		duplicate -n $dupBox $boxes[$y];
		asLockAttr $dupBox 0 0 0 0;
		parent -w $dupBox;
		select -r $dupObj $dupBox;
		refresh;
		$tempString=`polyBoolOp -n $dupObj -op 3 -ch 0 $dupObj $dupBox`;
		if (`objExists $dupObj`) delete $dupObj;
		if (`objExists $dupBox`) delete $dupBox;
		rename $tempString[0] $bool;
		$vs=`polyEvaluate -v $bool`;
		if (!$vs[0])
			delete  $bool;
		else
			{
			parent $bool $joint;
			editDisplayLayerMembers -noRecurse Bool $bool;
			}
		}
	}
eval ($restoreVisCmd);
progressBar -e -ep $gMainProgressBar;

print ("// Boolean created\n");
select -cl;
}

global proc asDeleteBoolean ()
{
string $all[]=`ls -r 1 -type transform "*Bool_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Bool`)
	delete Bool;
}

global proc asCreateWarp ()
{
global string $gMainProgressBar;
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists BoxesGeometry`)
	error "must create PolyBoxes first";
string $dialog=`confirmDialog -t "Warp"
	-m "Attempt to Warp selected geometry to PolyBoxes?"
	-b "OK" -db "OK"
	-b "Cancel" -ds "Cancel"`;
if ($dialog!="OK")
	return;
if (`getAttr BoxesGeometry.v`==0)
	{
	asHidePolyBoxes 0;
	refresh;
	asHidePolyBoxes 1;
	}
if (!`objExists Warp`)
	{
	createDisplayLayer -e -name Warp;
	setAttr Warp.color 28;
	setAttr Warp.displayType 2;
	}
int $sideFactor,$isEndJoint,$divisions;
int $tempInt[];
float $pos[],$facePos[];
string $restoreVisCmd;
string $tempString[],$tempString2[],$boxes[];
string $sel[]=`ls -sl`;
string $wrapBox,$SG;
string $multiSGs[];
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
createNode -n closestSampler closestPointOnMesh;

$tempString=`listRelatives -ad -type transform BoxesGeometry`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -s -ni $tempString[$i]`;
	if ($tempString2[0]!="")
		$boxes[size($boxes)]=$tempString[$i];
	}

for ($i=0;$i<size($sel);$i++)
	{
	$restoreVisCmd+="setAttr "+$sel[$i]+".v "+`getAttr ($sel[$i]+".v")`+";";
	setAttr ($sel[$i]+".v") 0;
	}
if (`objExists PolyBoxes`)
	{
	$restoreVisCmd+="setAttr PolyBoxes.v "+`getAttr PolyBoxes.v`+";";
	setAttr PolyBoxes.v 0;
	}
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -ni -s $sel[$i]`;
	string $meshNode=$tempString[0];
	$tempString=`listConnections ($tempString[0]+".instObjGroups")`;
	if ($tempString[0]!="")
		$SG=$tempString[0];
	else
		{
		//faceAssigned shaders
		for ($y=0;$y<`getAttr -s ($meshNode+".instObjGroups.objectGroups")`;$y++)
			{
			if($y==0)
				{
				//temp copy of mesh, so we can freeze xforms
				$tempString=`duplicate -n tempMesh $sel[$i]`;
				setAttr -l 0 tempMesh.tx;setAttr -l 0 tempMesh.ty;setAttr -l 0 tempMesh.tz;
				setAttr -l 0 tempMesh.rx;setAttr -l 0 tempMesh.ry;setAttr -l 0 tempMesh.rz;
				setAttr -l 0 tempMesh.sx;setAttr -l 0 tempMesh.sy;setAttr -l 0 tempMesh.sz;
				setAttr -l 0 tempMesh.v 0;
				catchQuiet (`parent -w tempMesh`);
				makeIdentity -a 1 -t 1 -r 1 -s 1 tempMesh;
				connectAttr -f tempMesh.outMesh closestSampler.inMesh;
				}
			$tempString=`listConnections -type shadingEngine ($meshNode+".instObjGroups.objectGroups["+$y+"].objectGrpColor")`;
			if ($tempString[0]!="")
				$multiSGs[size($multiSGs)]=$tempString[0];
			}
		}
	progressBar -e -st ("Creating Warps for:"+$sel[$i]) -bp -ii 1 -min 0 -max (size($boxes)) $gMainProgressBar;
	for ($y=0;$y<size($boxes);$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;return;}
		progressBar -e -s 1 $gMainProgressBar;
		if (`gmatch $boxes[$y] "*_L_*"`)
			$sideFactor=-1;
		else
			$sideFactor=1;
		$joint=`substitute "Box" $boxes[$y] ""`;
		tokenize $boxes[$y] "_" $tempString;
		for ($z=1;$z<99;$z++)
			if (!`objExists ($tempString[0]+"Warp"+$z+"_"+$tempString[1])`)
				break;
		$warpBox=$tempString[0]+"Warp"+$z+"_"+$tempString[1];
		$isEndJoint=0;
		$tempString=`listRelatives -type joint -c $joint`;
		if (!size($tempString))
			$isEndJoint=1;
		else if (!`sets -im DeformSet $tempString[0]`)
			$isEndJoint=1;			
		duplicate -n $warpBox $boxes[$y];
		setAttr -k 1 -l 0 ($warpBox+".tx");setAttr -k 1 -l 0 ($warpBox+".ty");setAttr -k 1 -l 0 ($warpBox+".tz");
		setAttr -k 1 -l 0 ($warpBox+".rx");setAttr -k 1 -l 0 ($warpBox+".ry");setAttr -k 1 -l 0 ($warpBox+".rz");
		parent $warpBox	$joint;
		$divisions=2;
		if ($joint=="Head_M")
			$divisions=4;
		catch (`polySmooth -mth 0 -dv $divisions -bnr 1 -c 1 -kb 1 -ksb 1 -khe 1 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $warpBox`);
		scale -r -ocp 1 0.7 0.7 ($warpBox+".e[0:15]");
		scale -r -ocp 1 0.9 0.9 ($warpBox+".vtx[34:50]") ($warpBox+".vtx[52]") ($warpBox+".vtx[54]") ($warpBox+".vtx[56]") ($warpBox+".vtx[58]") ($warpBox+".vtx[60]") ($warpBox+".vtx[62]") ($warpBox+".vtx[64]") ($warpBox+".vtx[74:89]");
		select $sel[$i];
		select -add $warpBox;
		transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

		select $warpBox;
		DeleteHistory;

		//round ends
		if (size($multiSGs))
			{
			$tempInt=`polyEvaluate -f $warpBox`;
			for ($z=0;$z<$tempInt[0];$z++)
				{
				if (`progressBar -q -ic $gMainProgressBar`)
					{progressBar -e -ep $gMainProgressBar;return;}
				$pos=`xform -q -ws -t ($warpBox+".f["+$z+"]")`;
				$facePos[0]=$facePos[1]=$facePos[2]=0;
				for ($a=0;$a<size($pos);$a=$a+3)
					{$facePos[0]+=$pos[$a];$facePos[1]+=$pos[$a+1];$facePos[2]+=$pos[$a+2];}
				$facePos[0]/=(size($pos)/3);$facePos[1]/=(size($pos)/3);$facePos[2]/=(size($pos)/3);
				setAttr closestSampler.inPosition $facePos[0] $facePos[1] $facePos[2];
				int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
				for ($a=0;$a<size($multiSGs);$a++)
					if (`sets -im $multiSGs[$a] ($sel[$i]+".f["+$closestFaceIndex+"]")`)
						sets -e -forceElement $multiSGs[$a] ($warpBox+".f["+$z+"]");
				}

			}
		else
			{
			$tempString=`listRelatives -ni -s $warpBox`;
			sets -e -forceElement $SG $tempString[0];
			}

		editDisplayLayerMembers -noRecurse Warp $warpBox;
		refresh;
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
if (`objExists tempMesh`)
	delete tempMesh;
progressBar -e -ep $gMainProgressBar;
eval ($restoreVisCmd);

print ("// Warp created\n");
select -cl;
}

global proc asDeleteWarp ()
{
string $all[]=`ls -r 1 -type transform "*Warp*_*"`;
for ($obj in $all)
	if (`objExists $obj`)
		delete $obj;
if (`objExists Warp`)
	delete Warp;
}


global proc asCreateMannequin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

if (`objExists MannequinGeometry`)
	error "MannequinGeometry already exists";
createNode -n MannequinGeometry transform;
parent MannequinGeometry "Geometry";

if (!`objExists Mannequin`)
	{
	createDisplayLayer -e -name Mannequin;
	setAttr Mannequin.color 24;
	setAttr Mannequin.displayType 2;
	editDisplayLayerMembers -noRecurse Mannequin  MannequinGeometry;
	}
float $charHeight=`asgetCharHeight`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $tempString[],$children[];
float $temp[],$temp2[],$temp3[];
int $sideFactor;
vector $childVec;
string $skipJoints[]={"Spine[0-9]*","Root_M","Chest_M","Jaw_M","Head_*","Eye_*"};

string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";
file -i $asGeometryFile;
setAttr Mannequin_Geometry.v 0;
setAttr Skeleton_Geometry.v 0;

$tempString=`listRelatives -c -type transform Mannequin_Geometry`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".v") 1;

for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	$children=`listRelatives -c -type joint $deformJointsList[$i]`;
	$childJoint=`asRlaChild $deformJointsList[$i]`;
	if (`gmatch $deformJointsList[$i] "Wrist_*"`)
		for ($y=0;$y<size($children);$y++)
			if (`gmatch $children[$y] "MiddleFinger1_*"`)
				$childJoint=$children[$y];
	if ($childJoint=="")
		continue;
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	int $skipMe=0;

	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$children=`listRelatives -c -type joint $childJoint`;
		$childJoint=$children[0];
		}
	$temp=`xform -q -ws -t $deformJointsList[$i]`;
	$temp2=`xform -q -ws -t $childJoint`;
	$lenght = `mag<<$temp2[0]-$temp[0],$temp2[1]-$temp[1],$temp2[2]-$temp[2]>>`;

	//spine
	if ($deformJointsList[$i]=="Root_M" || `gmatch $deformJointsList[$i] "*Spine[0-9]*"` || `gmatch $deformJointsList[$i] "*Chest*"` || `gmatch $deformJointsList[$i] "*Head_*"`)
		{
		if (`gmatch $deformJointsList[$i] "Head_*"`)
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Head`;
		else
			$tempString=`duplicate -n ($deformJointsList[$i]+"_Root") Mannequin_Root`;
		$poly=$tempString[0];
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		xform -os -s ($lenght/1) ($charHeight/10) ($charHeight/10) $poly;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}

	

	for ($y=0;$y<size($skipJoints);$y++)
		if (`gmatch $deformJointsList[$i] $skipJoints[$y]`)
			$skipMe=1;
	if ($skipMe) continue;

	if (`gmatch $deformJointsList[$i] "*Ankle*"` || `gmatch $deformJointsList[$i] "Toes*"`)
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Foot`;
		$poly=$tempString[0];
		xform -ws -t $temp[0] 0 $temp[2] $poly;
		xform -os -s ($lenght/1) ($lenght/1) ($lenght/1) $poly;
		//take on -ws .ry
		$temp3=`xform -q -ws -ro $deformJointsList[$i]`;
		if (`gmatch $deformJointsList[$i] "*Ankle*"`)
			$temp3=`xform -q -ws -ro $childJoint`;
		xform -ws -ro 0 ($temp3[1]-90) 0 $poly;
		//move forward
		move -r -os -wd 0 0 ($lenght/-4.0) $poly;
//		parentConstraint -mo $deformJointsList[$i] $poly;
		delete `parentConstraint -mo $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	else
		{
		$tempString=`duplicate -n ($deformJointsList[$i]+"_Limb") Mannequin_Limb`;
		$poly=$tempString[0];
		xform -os -s ($lenght) ($lenght/2) ($lenght/2) $poly;
		if (`gmatch $deformJointsList[$i] "Wrist*"`)
			setAttr ($poly+".sy") (`getAttr ($poly+".sy")`*3);
		if (`gmatch $deformJointsList[$i] "Toes*"`)
			setAttr ($poly+".sz") (`getAttr ($poly+".sz")`*3);
		if (`gmatch $deformJointsList[$i] "*Finger*"`)
			xform -os -s $lenght ($charHeight/70) ($charHeight/70) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($lenght*1.1) ($charHeight/10) ($charHeight/10) $poly;
		if (`gmatch $deformJointsList[$i] "*_L"`)
			{
			setAttr ($poly+".sx") (`getAttr ($poly+".sx")`*-1);
			polyNormal -normalMode 0 -userNormalMode 0 -ch 0 $poly;
			}
//		parentConstraint $deformJointsList[$i] $poly;
		delete `parentConstraint $deformJointsList[$i] $poly`;
		parent $poly MannequinGeometry;
		catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
		setAttr ($poly+"Shape.opposite") 0;
//		scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
		refresh;
		}
	$tempString=`duplicate -n ($deformJointsList[$i]+"_Sphere") Mannequin_Sphere`;
	$poly=$tempString[0];
	xform -os -s ($lenght/2) ($lenght/2) ($lenght/2) $poly;
	if (`gmatch $deformJointsList[$i] "*Finger*"`)
		xform -os -s ($charHeight/50) ($charHeight/50) ($charHeight/50) $poly;
	if (`gmatch $deformJointsList[$i] "*Neck*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "*Ankle*"`)
		xform -os -s ($charHeight/10) ($charHeight/10) ($charHeight/10) $poly;
	if (`gmatch $deformJointsList[$i] "Wrist*"`)
		xform -os -s ($charHeight/20) ($charHeight/20) ($charHeight/20) $poly;
	if (`gmatch $deformJointsList[$i] "Shoulder_*"` || `gmatch $deformJointsList[$i] "Hip_*"`)
		xform -os -s ($charHeight/7) ($charHeight/7) ($charHeight/7) $poly;

//	parentConstraint $deformJointsList[$i] $poly;
	delete `parentConstraint $deformJointsList[$i] $poly`;
	parent $poly MannequinGeometry;
	catchQuiet (`makeIdentity -a 1 -t 0 -r 0 -s 1 $poly`);
//	scaleConstraint $deformJointsList[$i] $poly;
		select $deformJointsList[$i] $poly;
		newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	refresh;
	}
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

if (`objExists shaderMannequin`) delete shaderMannequin;
if (`objExists shaderMannequinSG`) delete shaderMannequinSG;
shadingNode -n shaderMannequin -asShader lambert;
sets -renderable true -noSurfaceShader true -empty -name shaderMannequinSG;
connectAttr -f shaderMannequin.outColor shaderMannequinSG.surfaceShader;
setAttr -type float3 shaderMannequin.color 0.78 0.63 0.42;
setAttr shaderMannequin.ambientColor -type double3 0.53 0.42 0.25;

sets -e -forceElement shaderMannequinSG MannequinGeometry;


print ("// Mannequin created\n");
select -cl;
}

global proc asDeleteMannequin ()
{
string $deleteObjs[]={"MannequinGeometry","Mannequin_Geometry","Mannequin","wood","woodSG","woodShader"};
for ($i=0;$i<size($deleteObjs);$i++)
	if (`objExists $deleteObjs[$i]`)
		delete $deleteObjs[$i];
}

global proc asCreateRetopo ()
{
string $sel[]=`ls -sl`;
string $tempString[];
if (size($sel)!=1)
	error "Select 1 object";
if (!`objExists skinCage`)
	error "SkinCage not found, this must be created first. This is in the \"Deform(option2)\" section.";
if (`objExists retopo`)
	error "object \"retopo\" already exists, Choose \"delete retopo\", before creating a new one";

string $cage="skinCage";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}

if (`objExists retopo`) delete retopo;
select -cl;
createDisplayLayer -e -name "Retopo" -number 1 -nr;
setAttr Retopo.visibility 1;setAttr Retopo.color 5;
//setAttr Retopo.displayType 2;
duplicate -n retopo $cage;
$tempString=`listConnections -p 1 -s 1 -d 0 retopo.drawOverride`;
if (size($tempString))
	disconnectAttr $tempString[0] retopo.drawOverride;
editDisplayLayerMembers -noRecurse Retopo retopo;
if (`objExists Geometry`) parent retopo Geometry;

addAttr -ln hiResMesh -dt "string" retopo;
setAttr -type "string" retopo.hiResMesh $sel[0];
select $sel[0] retopo;

int $centerVtx[]=`asGetRetopoCenterVtxs`;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 1 ;
select retopo;
DeleteHistory;
polyNormalPerVertex -ufn true retopo;
polySoftEdge -angle 180 -ch 0 retopo;
asRestoreRetopoCenterVtx $centerVtx;
select retopo;
}

global proc asDeleteRetopo ()
{
string $deleteObjs[]={"retopo","Retopo","retopoHeadEdgeFinder"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asUpdateRetopo ()
{
string $sel[]=`ls -sl`;
if (!`gmatch $sel[0] "retopo*"`)
	error "\"retopo\" not selected, Select the entire \"retopo\" object, or vertices on the \"retopo\" object";
string $hiResMesh=`getAttr retopo.hiResMesh`;
if (!`objExists $hiResMesh`)
	error "Could not find HiResMesh, check the name in this attribute \"retopo.hiResMesh\"";
int $centerVtx[]=`asGetRetopoCenterVtxs`;
select $hiResMesh $sel;
transferAttributes -transferPositions 1 -transferNormals 1 -transferUVs 2 -transferColors 2 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3 -flipUVs 0 -colorBorders 1 ;
asRestoreRetopoCenterVtx $centerVtx;
select retopo;
DeleteHistory;
select $sel;
}

global proc asMirrorRetopo (int $L2R)
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "SkinCage not found, this must be created first. This is in the \"Deform(option2)\" section.";
string $cage="skinCage";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;
int $oppositeVtxNr;
int $numVtxs[]=`polyEvaluate -v $cage`;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($cage+".outMesh") closestSampler.inMesh;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ($cage+".vtx["+$i+"]")`;
	if ($pos[0]<$centerTolerance && $pos[0]>($centerTolerance*-1))
		continue;//Todo:should snap to center
	if ($L2R && $pos[0]<0) continue;
	if (!$L2R && $pos[0]>0) continue;
	setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
	$oppositeVtxNr=`getAttr closestSampler.closestVertexIndex`;
	$pos=`xform -q -ws -t ("retopo.vtx["+$i+"]")`;
	xform -ws -t ($pos[0]*-1) $pos[1] $pos[2] ("retopo.vtx["+$oppositeVtxNr+"]");
	}
delete closestSampler;
select $sel;
}

global proc int[] asGetRetopoCenterVtxs ()
{
int $centerVtx[];
int $numVtxs[]=`polyEvaluate -v retopo`;
float $pos[];
float $scale=`asGetScale`;
float $centerTolerance=0.01*$scale;

for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ("retopo.vtx["+$i+"]")`;
	if ($pos[0]<$centerTolerance && $pos[0]>($centerTolerance*-1))
		$centerVtx[size($centerVtx)]=$i;
	}
return $centerVtx;
}

global proc asRestoreRetopoCenterVtx (int $centerVtx[])
{
float $pos[];
for ($i=0;$i<size($centerVtx);$i++)
	{
	$pos=`xform -q -ws -t ("retopo.vtx["+$centerVtx[$i]+"]")`;
	xform -ws -t 0 $pos[1] $pos[2] ("retopo.vtx["+$centerVtx[$i]+"]");
	}
}

global proc asNormalMapRetopo ()
{
string $hiResMesh=`getAttr retopo.hiResMesh`;

performSurfaceSampling 1;
surfaceSamplingAddTargets( "retopo", true );
surfaceSamplingAddSource( $hiResMesh, true );
int $arraySize = `optionVar -q "surfaceSamplingOutputArraySize"`;
if ($arraySize<3)
	addMapUIFrame 0;
surfaceSamplingChangeXResolutionDragCmd 2048 0;
}

global proc asBindRetopo ()
{
int $numVtxsCage[],$numVtxsRetopo[];
string $tempString[];
string $cage="skinCage";
if (`objExists retopoSC`) error "retopoSC already exists. Try to UnBind first, before doing a nwe Bind";
if (`objExists skinSub`)
	{
	$cage="skinSub";
	print ("// skinSub cage detected, using this instead of skinCage.\n");
	}
duplicate -n skinCage2 skinCage;
parent -w skinCage2;
select skinCage2;
asSelectDeformJoints;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
select skinCage skinCage2;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

select retopo;
asSelectDeformJoints;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] retopoSC;
select skinCage2 retopo;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

//re-copyWeights, if topology match, with meshes aligned, for imroved results
$numVtxsCage=`polyEvaluate -v skinCage2`;
$numVtxsRetopo=`polyEvaluate -v retopo`;
if ($numVtxsCage[0]==$numVtxsRetopo[0])
	{
	select skinCage2 retopo;
	blendShape -n TempBS -w 0 1;
	select skinCage2 retopo;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	delete TempBS;
	}

delete skinCage2;
}

global proc asUnBindRetopo ()
{
select retopo;
DeleteHistory;
}

global proc asCreateFaceRetopo ()
{
int $vtxNr,$twistCurves;
float $dist,$minDist,$scaleY;
float $pos[],$pos2[],$rot[];
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopology/";
string $file,$prePosCmd,$restoreExistingLocPosCmd,$locator;
string $faces[],$retopoHeadFaces[],$retopoHeadVtxs[],$bodyHeadConnectionVtxs[],$headBodyConnectionVtxs[],$locators[],$neckLocs[],$tempString[],$tempString2[];
string $deleteObjs[]={"closestSampler","retopoHeadEdgeFinder"};

if (`objExists FKJaw_M`) if (!`asFaceRemoveBodyJaw`) return;

if (!`objExists Neck_M_middleCurve`) error "SkinCage Neck Curve curve not found, unable to proceed";
if (`objExists FaceGroup`) error "FaceGroup already exists, unable to proceed";
if (`objExists headTopology`)
	{
	if (`objExists guidesGroup`)
		{
		$tempString=`listRelatives -ad -type transform guidesGroup`;
		for ($i=0;$i<size($tempString);$i++)
			{
			if (!`gmatch $tempString[$i] "*Loc[0-9]*"`) continue;
			$pos=`xform -q -ws -t $tempString[$i]`;
			$restoreExistingLocPosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$tempString[$i]+";";
			}
		}
	asDeleteFaceRetopo 0;
	}

for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
select -cl;

string $curves[]={"Neck_M_middleCurve","Head_M_middleCurve","HeadEnd_M_middleCurve"};
if (`attributeExists inbetweenJoints Neck`)
	$twistCurves=`getAttr Neck.inbetweenJoints`;
if (`attributeExists twistJoints Neck`)
	$twistCurves=`getAttr Neck.twistJoints`;
for ($i=1;$i<$twistCurves+1;$i++)
	$curves[size($curves)]=("Neck_M_twistCurve"+$i);

for ($i=0;$i<size($curves);$i++)
	for ($y=0;$y<5;$y++)
		{
		$pos=`xform -q -ws -t ($curves[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr=`getAttr closestSampler.closestVertexIndex`;
		select -add ("skinCage.vtx["+$vtxNr+"]");
		}
ConvertSelectionToContainedFaces;

$faces=`ls -sl -fl`;
select -cl;
for ($i=0;$i<size($faces);$i++)
	select -add `substitute "skinCage" $faces[$i] "retopo"`;
$retopoHeadFaces=`ls -sl -fl`;

if (`objExists SkinSub`) //tmp resolve smoothProxyFaces via material
	{
	shadingNode -n tempShader -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name tempShaderSG;
	setAttr tempShader.color -type double3 0 0 0; 
	connectAttr -f tempShader.outColor tempShaderSG.surfaceShader;
	duplicate -n tempSkinCage skinCage;
	parent -w tempSkinCage;
	select -cl;
	for ($i=0;$i<size($faces);$i++)
		select -add `substitute "skinCage" $faces[$i] "tempSkinCage"`;
	sets -e -forceElement tempShaderSG;
//	polySmooth  -mth 0 -sdt 2 -ovb 1 -ofb 3 -ofc 0 -ost 1 -ocr 0 -dv 1 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 tempSkinCage;
	polySmooth  -mth 0 -dv 1 -bnr 1 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 tempSkinCage;
	$tempString=`sets -q tempShaderSG`;
	clear $retopoHeadFaces;
	for ($i=0;$i<size($tempString);$i++)
		$retopoHeadFaces[size($retopoHeadFaces)]=`substitute "tempSkinCage" $tempString[$i] "retopo"`;
	delete tempSkinCage tempShader tempShaderSG;
	}
select $retopoHeadFaces;
ConvertSelectionToVertices;
$retopoHeadVtxs=`ls -sl -fl`;
duplicate -n retopoHeadEdgeFinder retopo;
$retopoHeadVtxs=`asobjSetCast "" $retopoHeadVtxs retopoHeadEdgeFinder`;

select retopo;
cluster -n retopoCluster -envelope 1;
delete $retopoHeadFaces;
delete retopoCluster;
$tempString=`listConnections -s 1 -d 0 retopoShape.inMesh`;
rename $tempString[0] retopoHeadDeleteComponent;

//import mayaFile
$file=$headTopologyDir+`optionMenu -q -v asCreateFaceRetopoOptionMenu`;
file -i -rdn -mergeNamespacesOnClash false -rpr "guides" $file;
setAttr FaceGroup.v 0;
parent headTopology Geometry;
parent FaceGroup Group;
createNode -n FaceFitRetopoAttach -p FaceGroup transform;
setAttr headTopology.v 0;

//attached faceFitCurves to headTopology
$tempString=`listRelatives -ad -type nurbsCurve FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	if ($tempString[$i]=="TongueCurveShape") continue;
	if (`gmatch $tempString[$i] "*CurveShape"`)
		{
		select $tempString[$i] headTopology;
		$tempString2=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
		//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
		rename $tempString2[0] ($tempString[$i]+"TempWrap");
		$tempString2=`listConnections ($tempString[$i]+"TempWrap.basePoints[0]")`;
		parent $tempString2[0] FaceFitRetopoAttach;
		}
	}
//attached faceFit Locators to headTopology
$tempString=`listRelatives -ad -type locator FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -p $tempString[$i]`;
	$locator=$tempString2[0];
	$pos=`getAttr ($tempString[$i]+".worldPosition")`;
	curve -n ($tempString[$i]+"TempWrapCurve") -d 1 -p $pos[0] $pos[1] $pos[2] -p $pos[0] $pos[1] $pos[2] -k 0 -k 1;
	setAttr ($tempString[$i]+"TempWrapCurve.inheritsTransform") 0;
	$tempString2=`listRelatives -p $locator`;
	parent ($tempString[$i]+"TempWrapCurve") FaceFitRetopoAttach;
	geometryConstraint -weight 1 ($tempString[$i]+"TempWrapCurve")  $locator;

	select ($tempString[$i]+"TempWrapCurve") headTopology;
	$tempString2=`doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" }`;
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
	rename $tempString2[0] ($tempString[$i]+"TempWrap");
	$tempString2=`listConnections ($tempString[$i]+"TempWrap.basePoints[0]")`;
	parent $tempString2[0] FaceFitRetopoAttach;
	}

//place at head
float $neckPos[]=`xform -q -ws -t Neck_M_middleProfileShape.cv[0]`;
float $headEndPos[]=`xform -q -ws -t HeadEnd_M`;
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) FaceFitSkeleton;
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) headTopology.vtx[0:9999];
scale -r -p 0 0 0 ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) ($headEndPos[1]-$neckPos[1]) guidesGroup;
move -r 0 $neckPos[1] 0 FaceFitSkeleton;
move -r 0 $neckPos[1] 0 headTopology.vtx[0:9999];
move -r 0 $neckPos[1] 0 guidesGroup;

//store current locator positions
$tempString=`listRelatives -ad -type transform guidesGroup`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*Loc[0-9]*"`) $locators[size($locators)]=$tempString[$i];
for ($i=0;$i<size($locators);$i++)
	{
	$pos=`xform -q -ws -t $locators[$i]`;
	$prePosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$locators[$i]+";";
	}
addAttr -ln prePosCmd -dt "string" guidesGroup;
setAttr -type "string" guidesGroup.prePosCmd $prePosCmd;

//restore $restoreExistingLocPosCmd, if locators were already existing
tokenize $restoreExistingLocPosCmd ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	catchQuiet (`evalEcho($tempString[$i])`);

//find bodyHeadConnectionVtxs
connectAttr -f retopo.outMesh closestSampler.inMesh;
for ($i=0;$i<size($retopoHeadVtxs);$i++)
	{
	$pos=`xform -q -ws -t $retopoHeadVtxs[$i]`;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$vtxNr=`getAttr closestSampler.closestVertexIndex`;
	$pos2=`xform -q -ws -t ("retopo.vtx["+$vtxNr+"]")`;
	if (`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`<0.001)
		$bodyHeadConnectionVtxs[size($bodyHeadConnectionVtxs)]=("retopo.vtx["+$vtxNr+"]");
	if (!`attributeExists bodyHeadConnectionVtxs retopo`)
		addAttr -ln bodyHeadConnectionVtxs -dt "string" retopo;
	setAttr -type "string" retopo.bodyHeadConnectionVtxs `stringArrayToString $bodyHeadConnectionVtxs " "`;
	}
//find  headBodyConnectionVtxs
if (!`attributeExists headBodyConnectionVtxs retopo`)
	addAttr -ln headBodyConnectionVtxs -dt "string" retopo;
connectAttr -f headTopology.outMesh closestSampler.inMesh;
$pos=`xform -q -ws -t HeadProfileSideLoc6`;
setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
$vtxNr=`getAttr closestSampler.closestVertexIndex`;
select ("headTopology.vtx["+$vtxNr+"]");
ConvertSelectionToEdges;
string $edges[]=`ls -sl -fl`;
int $minNumEdgesInLoop=999;
for ($i=0;$i<size($edges);$i++)
	{
	select $edges[$i];
	SelectEdgeLoopSp;
	$tempString=`ls -sl -fl`;
	if (size($tempString)<$minNumEdgesInLoop)
		{
		$minNumEdgesInLoop=size($tempString);
		ConvertSelectionToVertices;
		$headBodyConnectionVtxs=`ls -sl -fl`;
		setAttr -type "string" retopo.headBodyConnectionVtxs `stringArrayToString $headBodyConnectionVtxs " "`;
		}
	}
//place neckLocs to nearest $bodyHeadConnectionVtxs
for ($i=0;$i<size($locators);$i++)
	if (`getAttr ($locators[$i]+".overrideColor")`==24)
		$neckLocs[size($neckLocs)]=$locators[$i];
for ($i=0;$i<size($neckLocs);$i++)
	{
	$pos=`xform -q -ws -t $neckLocs[$i]`;
	$minDist=999;
	for ($y=0;$y<size($bodyHeadConnectionVtxs);$y++)
		{
		$pos2=`xform -q -ws -t $bodyHeadConnectionVtxs[$y]`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		if ($dist<$minDist)
			{
			$minDist=$dist;
			xform -ws -t $pos2[0] $pos2[1] $pos2[2] $neckLocs[$i];
			}
		}
	}

delete retopoHeadEdgeFinder;
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
asFaceUpdateInfo 1;
print "// Now move the Locators, to match the head/face of your model.\n";
select -cl;
}

global proc asDeleteFaceRetopo (int $keepNewRetopo)
{
string $deleteObjs[]={"headTopology","retopoHeadDeleteComponent","retopoHeadJoint","guidesGroup","MainCurves","ProfileCurves"};
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
$deleteObjs=`ls "guides_*"`;
for ($obj in $deleteObjs) if (`objExists $obj`) delete $obj;
if (`objExists guidesRN`)
	{
	lockNode -l 0 guidesRN;
	delete guidesRN;
	}
if (!$keepNewRetopo)
	{
	if (`objExists headTopologyGeometry`) delete headTopologyGeometry;
	if (`objExists FaceGroup`) delete FaceGroup;
	}
if (!$keepNewRetopo && `objExists bodyTopology`)
	{
	delete retopo;
	setAttr bodyTopology.v 1;
	rename bodyTopology retopo;
	}
asFaceUpdateInfo 1;
}

global proc asMatchGuidesFaceRetopo ()
{
int $numVtxs[]=`polyEvaluate -v headTopology`;
float $pos[];
string $tempString[],$locators[],$curves[],$mirrorCurves[],$nonAverageVtxs[],$centerXvtxs[];
string $hiResMesh=`getAttr retopo.hiResMesh`;
string $restoreLocPosCmd;
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headBodyConnectionVtxs[]=`stringToStringArray $tempString[0] " "`;
if (`objExists retopoHeadJoint`)
	error "Match guides has already been executed. You can scrube the timeline from 0 to 10, to see the alignment";
if (!`objExists headTopology`)
	error "headTopology object not found, click \"Geometry: Create\" first";

$tempString=`listRelatives -ad -type transform guidesGroup`;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`gmatch $tempString[$i] "*Loc[0-9]*"`) $locators[size($locators)]=$tempString[$i];
	if (`gmatch $tempString[$i] "*Curve*"`) $curves[size($curves)]=$tempString[$i];
	}

for ($i=0;$i<size($locators);$i++)
	{
	if (!`gmatch $locators[$i] "*Loc[0-9]*"`) continue;
	$pos=`xform -q -ws -t $locators[$i]`;
	$restoreLocPosCmd+="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$locators[$i]+";";
	}

eval (`getAttr guidesGroup.prePosCmd`);

for ($i=0;$i<size($curves);$i++)
	{
	if ($curves[$i]=="HeadProfileSideCurve" || $curves[$i]=="noseProfileCurve") continue;
	duplicate -n ($curves[$i]+"mirror") $curves[$i];
	$mirrorCurves[size($mirrorCurves)]=$curves[$i]+"mirror";
	asLockAttr ($curves[$i]+"mirror") 1 1 0 0;
	setAttr ($curves[$i]+"mirror.sx") -1;
	connectAttr -f ($curves[$i]+".worldSpace[0]") ($curves[$i]+"mirror.create");
	}

//duplicate -n headTopologyOrig headTopology;
//setAttr headTopologyOrig.v 0;

for ($i=0;$i<$numVtxs[0];$i++)
	{
	$pos=`xform -q -ws -t ("headTopology.vtx["+$i+"]")`;
	if ($pos[0]<0.001 && $pos[0]>-0.001)
		$centerXvtxs[size($centerXvtxs)]="headTopology.vtx["+$i+"]";
	}

select FaceGroup;
joint -n retopoHeadJoint;
select headTopology retopoHeadJoint;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] headTopologySC;
setAttr headTopologySC.useComponents 1;

select headTopology $curves $mirrorCurves;
skinClusterInfluence 1 "-ug -dr 4 -ps 0 -ns 100";

eval ($restoreLocPosCmd);

asAlignBodyFaceRetopo;

clear $tempString;
asSelectCurveVtx upperLipMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx upperLipMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx lowerLipMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx lowerLipMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx eyeLidMainCurve;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx eyeLidMainCurvemirror;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx EyeBrowMainCurve2;select -add $tempString;$tempString=`ls -sl`;
asSelectCurveVtx EyeBrowMainCurve2mirror;select -add $tempString;$tempString=`ls -sl`;
if (`objExists EarCurve`)
	{asSelectCurveVtx EarCurve;select -add $tempString;$tempString=`ls -sl`;}
asSelectCurveVtx noseProfileCurve;select -add $tempString;$tempString=`ls -sl`;
GrowPolygonSelectionRegion;$tempString=`ls -sl`;
$nonAverageVtxs=`stringArrayCatenate $nonAverageVtxs $tempString`;

select headTopology.vtx[0:9999];
select -d $headBodyConnectionVtxs;
select -d $nonAverageVtxs;
$tempString=`ls -sl`;
select $hiResMesh $tempString;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;
select $tempString;
polyAverageVertex -i 10;
select $hiResMesh $tempString;
transferAttributes -transferPositions 1 -transferNormals 0 -transferUVs 0 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;

for ($i=0;$i<size($centerXvtxs);$i++)
	{
	$pos=`xform -q -ws -t $centerXvtxs[$i]`;
	xform -ws -t 0 $pos[1] $pos[2] $centerXvtxs[$i];
	}

setAttr headTopology.v 1;
select -cl;
}

global proc asShrinkWrapFaceRetopo ()
{
string $tempString[];
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headVtxs[]=`stringToStringArray $tempString[0] " "`;

select headTopology;
ConvertSelectionToVertices;
select -d $headVtxs;
polyAverageVertex -i 10 -ch 1;

}

global proc asAlignBodyFaceRetopo ()
{
float $mag,$minMag;
float $posA[],$posB[];
string $nearestVtx;
string $sel[]=`ls -sl`;
string $tempString[];

$tempString[0]=`getAttr retopo.bodyHeadConnectionVtxs`;
string $bodyVtxs[]=`stringToStringArray $tempString[0] " "`;
$tempString[0]=`getAttr retopo.headBodyConnectionVtxs`;
string $headVtxs[]=`stringToStringArray $tempString[0] " "`;

for ($i=0;$i<size($headVtxs);$i++)
	{
	$posA=`xform -q -ws -t $headVtxs[$i]`;
	$minMag=99999;
	for ($y=0;$y<size($bodyVtxs);$y++)
		{
		$posB=`xform -q -ws -t $bodyVtxs[$y]`;
		$mag=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
		if ($mag<$minMag)
			{
			$minMag=$mag;
			$nearestVtx=$bodyVtxs[$y];
			}
		}
	$posB=`xform -q -ws -t $nearestVtx`;
	xform -ws -t $posB[0] $posB[1] $posB[2] $headVtxs[$i];
	}
}

global proc asConnectBodyFaceRetopo ()
{
int $form,$spans,$degrees,$numCv;
float $posA[];
string $sel[]=`ls -sl`;
string $tempString[];
string $restoreCrvsCmd;

//`detach` wrapped-on FaceFitSkeleton
$tempString=`listRelatives -ad -type nurbsCurve FaceFitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	if (`gmatch $tempString[$i] "*CurveShape"`)
		{
		$form=`getAttr ($tempString[$i]+".form")`;
		$spans=`getAttr ($tempString[$i]+".spans")`;
		$degrees=`getAttr ($tempString[$i]+".degree")`;
		if ($form==2) $numCv=$spans;
		else $numCv=$spans+$degrees;
		for ($y=0;$y<$numCv;$y++)
			{
			$posA=`xform -q -ws -t ($tempString[$i]+".cv["+$y+"]")`;
			$restoreCrvsCmd+="xform -ws -t "+$posA[0]+" "+$posA[1]+" "+$posA[2]+" "+$tempString[$i]+".cv["+$y+"];";
			}
		}
setAttr FaceGroup.v 1;
refresh;
setAttr FaceGroup.v 0;
delete FaceFitRetopoAttach;
evalEcho ($restoreCrvsCmd);

rename retopo bodyTopology;
duplicate -n headTopologyForMerge headTopology;
duplicate -n bodyTopologyForMerge bodyTopology;
setAttr headTopology.v 0;
setAttr bodyTopology.v 0;

polyUnite -ch 0 -mergeUVSets 0 -name retopo bodyTopologyForMerge headTopologyForMerge;
addAttr -ln hiResMesh -dt "string" retopo;
setAttr -type "string" retopo.hiResMesh `getAttr bodyTopology.hiResMesh`;
delete headTopologyForMerge bodyTopologyForMerge;
//parent headTopology Geometry;
parent retopo Geometry;
editDisplayLayerMembers -noRecurse Retopo retopo;

polyMergeVertex -d 0.0001 -am 1 -ch 0 retopo;
select headTopology;
DeleteHistory;

asDeleteFaceRetopo 1;

if (`objExists retopoSC`)
	{
	rename retopoSC bodyTopologySC;
	select retopo;
	asSelectDeformJoints;
	$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
	rename $tempString[0] retopoSC;
	select bodyTopology retopo;
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	}
delete bodyTopology;

catchQuiet (`select $sel`);
}

global proc asCreateEyesFaceRetopo ()
{
float $pos[],$rot[];
float $eyeSize;
float $height=`getAttr "Main.height"`;
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyEyeBallDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyEyeBall/";
string $file,$side;

if (`objExists headTopologyEyes`)
	{
	select headTopologyEyes;
	error "headTopologyEyes already exists";
	}
createNode -n headTopologyEyes -p Geometry transform;
$file=$headTopologyEyeBallDir+`optionMenu -q -v asCreateFaceRetopoEyeBallOptionMenu`;
file -i $file;
parent eyeball headTopologyEyes;

$rot=`xform -q -ws -ro Eye_R`;
xform -r -ro $rot[0] ($rot[1]-90) 0 eyeball.vtx[0:999];
$pos=`xform -q -ws -t Eye_R`;
move -r $pos[0] $pos[1] $pos[2] eyeball.vtx[0:999];

$eyeSize=$height/30.0;
scale -r -p $pos[0] $pos[1] $pos[2] $eyeSize $eyeSize $eyeSize eyeball.vtx[0:999];

rename eyeball eyeball_R;
duplicate -n eyeball_L eyeball_R;
scale -r -p 0 0 0 -1 1 1 eyeball_L.vtx[0:999];
polyNormal -normalMode 0 -userNormalMode 0 -ch 0 eyeball_L;

asLockAttr headTopologyEyes 1 1 1 1;
addAttr -k 1 -ln "size" -at double -dv 1 headTopologyEyes;

$side="_R";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$side="_L";}
	select ("eyeball"+$side);
	$tempString=`newCluster " -envelope 1"`;
	rename $tempString[0] ("eyeballCluster"+$side);
	rename $tempString[1] ("eyeballClusterHandle"+$side);
	setAttr ("eyeballClusterHandle"+$side+".v") 0;
	parent ("eyeballClusterHandle"+$side) headTopologyEyes;
	connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sx");connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sy");connectAttr headTopologyEyes.size ("eyeballClusterHandle"+$side+".sz");
//	select ("eyeball"+$side);
//	asChooseInput ("asFaceEye"+$side+"TextField");
	}

//asBuildFitEyeBall;
print "//Eyes created, ajust the scale with the size attribute.\n";
select headTopologyEyes;
}

global proc asBindEyesFaceRetopo ()
{
string $side="_R";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$side="_L";}
	select ("eyeball"+$side);
	DeleteHistory;
	select Head_M ("eyeball"+$side);
	newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
	}
print "//Eyes skinned to eye-joints.\n";
select -cl;
}

global proc asCreateTeethFaceRetopo ()
{
float $pos[];
float $height=`getAttr "Main.height"`;
if (`objExists headTopologyTeeth`)
	{
	select teethLocator;
	error "headTopologyTeeth already exists";
	}
string $asScriptLocation=`asGetScriptLocation`;
string $headTopologyTeethDir=$asScriptLocation+"/AdvancedSkeleton5Files/div/headTopologyTeeth/";
string $file=$headTopologyTeethDir+`optionMenu -q -v asCreateFaceRetopoTeethOptionMenu`;
file -i $file;
parent headTopologyTeeth Geometry;

$pos=`xform -q -ws -t Head_M`;
xform -ws -t $pos[0] $pos[1] $pos[2] -s ($height/20.0) ($height/20.0) ($height/20.0) teethLocator;
$pos=`xform -q -ws -t Eye_R`;
setAttr teethLocator.tz $pos[2];

select teethLocator;
}

global proc asBindTeethFaceRetopo ()
{
select upperTeeth lowerTeeth tongue;
DeleteHistory;
delete teethLocator teethClusterHandle;

select upperTeeth lowerTeeth tongue Head_M;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

select -cl;
print "// Bind teeth complete.\n";
}

global proc asFaceRigPrepRetopo ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[],$tempString3[];
string $newSelectionString;

setAttr FaceGroup.v 1;

//Pre section
select retopo;
asChooseInput asFaceGeometryTextField;
select retopo;
string $optionalAllHeadObjs[]={"eyeball_R","eyeball_L","upperTeeth","lowerTeeth","tongue"};
for ($i=0;$i<size($optionalAllHeadObjs);$i++)
	if (`objExists $optionalAllHeadObjs[$i]`)
		select -add $optionalAllHeadObjs[$i];
asChooseInput asFaceAllFaceGeoTextField;
if (`objExists eyeball_R`) {select eyeball_R;asChooseInput asFaceEye_RTextField;}
if (`objExists eyeball_L`) {select eyeball_L;asChooseInput asFaceEye_LTextField;}
if (`objExists upperTeeth`) {select upperTeeth;asChooseInput asFaceUpperTeethTextField;}
if (`objExists lowerTeeth`) {select lowerTeeth;asChooseInput asFaceLowerTeethTextField;}
if (`objExists tongue`) {select tongue;asChooseInput asFaceTongueTextField;}


//Fit section
if (`objExists eyeball_R`)
	asBuildFitEyeBall;
if (`objExists tongue`)
	{
	asCreateFaceFit Tongue "" 0 0 0 asGreenSG;
	$posA=`xform -q -ws -t tongue.vtx[111]`;xform -ws -t 0 $posA[1] $posA[2] Tongue0;
	$posA=`xform -q -ws -t tongue.vtx[35]`; xform -ws -t 0 $posA[1] $posA[2] Tongue1;
	$posA=`xform -q -ws -t tongue.vtx[198]`;xform -ws -t 0 $posA[1] $posA[2] Tongue2;
	$posA=`xform -q -ws -t tongue.vtx[64]`; xform -ws -t 0 $posA[1] $posA[2] Tongue3;
	$posA=`xform -q -ws -t tongue.vtx[167]`;xform -ws -t 0 $posA[1] $posA[2] Tongue4;
	}

if (`objExists upperTeeth`)
	{
	asCreateFaceFit TeethCollider "" 0 0 0 asGreenSG;
	$posA=`xform -q -ws -t upperTeeth.vtx[904]`;
	$posB=`xform -q -ws -t upperTeeth.vtx[685]`;
	xform -ws -t 0 $posA[1] $posB[2] TeethCollider;
	setAttr TeethCollider.sz (($posA[2]-$posB[2])*2.7);
	setAttr TeethCollider.sx ($posB[0]*2.7);
	}

asFaceFitJawCurves;

catchQuiet (`select $sel`);
}

global proc asSelectMatchingComponents (string $destMesh)
{
int $edgeSelection=0;
float $pos[];

string $sel[]=`ls -sl`;
if (`gmatch $sel[0] "*.e[[]*"`) $edgeSelection=1;
if (`objExists closestSampler`) delete closestSampler;
if ($edgeSelection)
	ConvertSelectionToVertices;
string $vtxs[]=`ls -sl -fl`;

createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($destMesh+".outMesh") closestSampler.inMesh;
select -cl;
for ($i=0;$i<size($vtxs);$i++)
	{
	$pos=`xform -q -ws -t $vtxs[$i]`;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	select -add ("retopo.vtx["+`getAttr closestSampler.closestVertexIndex`+"]");
	}
if ($edgeSelection)
	ConvertSelectionToContainedEdges;
if (`objExists closestSampler`) delete closestSampler;
}

global proc asHidePolyBoxes (int $onOff)
{
if (!`objExists "BoxesGeometry"`)
	error "BoxesGeometry does not exists !\n";
setAttr -l 0 "BoxesGeometry.visibility";
setAttr -l ($onOff) "BoxesGeometry.visibility" (!$onOff);
if (!$onOff)
	setAttr -l ($onOff) "BoxesGeometry.visibility";
}

global proc asMirrorGeometry (string $geometry, int $L2R)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
int $vs[];
float $scale[3],$pos[3];
string $box,$matchBox;
string $allPCs[]=`listRelatives -type transform -c ($geometry+"Geometry")`;
for ($i=0;$i<size($allPCs);$i++)
	{
	$box=`substitute "ParentConstraint" $allPCs[$i] ""`;
	if ($L2R)
		$matchBox=`substitute "_L" $box "_R"`;
	else
		$matchBox=`substitute "_R" $box "_L"`;

	if ($box==$matchBox || `gmatch $box "*_M"`)
		continue;

	if (!`objExists $matchBox`)
		continue;

	$scale=`getAttr ($box+".scale")`;
	if (!`getAttr -l ($matchBox+".scaleX")`)
		setAttr -type float3 ($matchBox+".scale") $scale[0] $scale[1] $scale[2];
	$vs=`polyEvaluate -v $box`;
	for ($y=0;$y<$vs[0];$y++)
		{
		$pos=`xform -q -ws -t ($box+".vtx["+$y+"]")`;
		xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($matchBox+".vtx["+$y+"]");
		}
	}
}

global proc asMirrorControlCurves (int $L2R, string $set)
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
string $controlObjects[]=`sets -q $set`;
string $shapes[],$tempString[],$tempString2[];
string $oppositeShape,$oppositeControlObject;
float $pos[];
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	if ($shapes[0]=="")
		continue;
	$objType=`objectType $shapes[0]`;
	if ($objType!="nurbsCurve" && $objType!="nurbsSurface")
		continue;

	if ($L2R)
		{
		if (!`gmatch $shapes[0] "*_L*"`)
			continue;
		}
	else
		{
		if (!`gmatch $shapes[0] "*_R*"`)
			continue;
		}

	if ($set=="FaceControlSet" && `gmatch $shapes[0] "ctrl*"`)//not to mirror joystick ctrls
		continue;

	if ($L2R)
		{
		$oppositeShape=`substitute "_L" $shapes[0] "_R"`;
		$oppositeControlObject=`substitute "_L" $controlObjects[$i] "_R"`;
		}
	else
		{
		$oppositeShape=`substitute "_R" $shapes[0] "_L"`;
		$oppositeControlObject=`substitute "_R" $controlObjects[$i] "_L"`;
		}

	if (!`objExists $oppositeShape`)
		continue;

	if ($objType=="nurbsSurface")
		{
		select ($shapes[0]+".cv[0:999][0:999]");
		$tempString=`ls -sl -fl`;
		for ($y=0;$y<size($tempString);$y++)
			{
			//Correct if its not the Shape object returned by `ls`;
			tokenize $tempString[$y] "." $tempString2;
			if (`objectType $tempString2[0]`=="transform")
				$tempString[$y]=$shapes[0]+"."+$tempString2[1];

			$pos=`xform -q -ws -t $tempString[$y]`;
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] `substitute $shapes[0] $tempString[$y] $oppositeShape`;
			}
		continue;
		}

	$form=`getAttr ($shapes[0]+".form")`;
	$spans=`getAttr ($shapes[0]+".spans")`;
	$degrees=`getAttr ($shapes[0]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;

	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($shapes[0]+".cv["+$y+"]")`;
		if ($y==0)	$z=2;
		if ($y==1)	$z=3;
		if ($y==2)	$z=0;
		if ($y==3)	$z=1;
		if ($y==4)	$z=2;
		if ($set=="SkinCageCurvesSet")
			{
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$z+"]");
			if ($y==2)
				xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv[4]");
			}
		else
			xform -ws -t (-1*$pos[0]) $pos[1] $pos[2] ($oppositeShape+".cv["+$y+"]");
		}

	//Mirror slideJoints
	if ($set=="SkinCageCurvesSet")
		{
		string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $controlObjects[$i]`;
		int $haveSliderJoint[4];
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
				$haveSliderJoint[$y]=1;
			else
				$haveSliderJoint[$y]=0;
		if ($haveSliderJoint[0] || $haveSliderJoint[1] || $haveSliderJoint[2] || $haveSliderJoint[3])
			{
			select $oppositeControlObject;
			asCreateSliders;
			//mirror .slide values
			for ($y=0;$y<4;$y++)
				{
				string $sliderJoint=$skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y;
				string $oppositeSliderJoint;
				if ($L2R) $oppositeSliderJoint=`substitute "_L" $sliderJoint "_R"`;
				else $oppositeSliderJoint=`substitute "_R" $sliderJoint "_L"`;
				if ($y==0) $oppositeSliderJoint=`substitute "0" $oppositeSliderJoint "2"`;
				if ($y==1) $oppositeSliderJoint=`substitute "1" $oppositeSliderJoint "3"`;
				if ($y==2) $oppositeSliderJoint=`substitute "2" $oppositeSliderJoint "0"`;
				if ($y==3) $oppositeSliderJoint=`substitute "3" $oppositeSliderJoint "1"`;
				if (`objExists $sliderJoint` && `objExists $oppositeSliderJoint`)
					setAttr ($oppositeSliderJoint+".slide") `getAttr ($sliderJoint+".slide")`;
				}
			}
		else // sliders might have been deleted, this should also mirror
			{
			string $oppositeSkinCurveSliderInfo[]=`asSkinCurveSliderInfo $oppositeControlObject`;
			int $oppositeHaveSliderJoint[4];
			for ($y=0;$y<4;$y++)
				if (`objExists ($oppositeSkinCurveSliderInfo[0]+"_"+$oppositeSkinCurveSliderInfo[1]+"Slider"+$y)`)
					$oppositeHaveSliderJoint[$y]=1;
			if ($oppositeHaveSliderJoint[0] || $oppositeHaveSliderJoint[1] || $oppositeHaveSliderJoint[2] || $oppositeHaveSliderJoint[3])
				{
				select $oppositeControlObject;
				asDeleteSliders;
				}
			}
		}
	}

//include faceCurves, if exists
if ($set=="ControlSet" && `objExists FaceControlSet`)
	asMirrorControlCurves $L2R FaceControlSet;

select $sel;
}

global proc asScaleControlCurves ()
{
//scale selected if any control curves are selected, otherwice scale all
global string $gMove;
float $pos[];
float $scale=`floatField -q -v ScaleCCFloatField`;
if ((`getModifiers`/4) %  2)
	$scale=1/$scale;
string $controlObjects[],$faceControlSetMembers[],$shapes[];
string $sel[]=`ls -sl`;
for ($i=0;$i<size($sel);$i++)
	if (`sets -im ControlSet $sel[$i]` || `sets -im FaceControlSet $sel[$i]`)
		$controlObjects[size($controlObjects)]=$sel[$i];
if (!size($controlObjects))
	{
	$controlObjects=`sets -q "ControlSet"`;
	//include faceCurves, if exists
	if (`objExists FaceControlSet`)
		{
		$faceControlSetMembers=`sets -q FaceControlSet`;
		$controlObjects=`stringArrayCatenate $controlObjects $faceControlSetMembers`;
		}
	}
string $controlCurves[];
string $tempString[];
for ($i=0;$i<size($controlObjects);$i++)
	{
	$shapes=`listRelatives -s $controlObjects[$i]`;
	for ($y=0;$y<size($shapes);$y++)
		{
		if (`objectType $shapes[$y]`!="nurbsCurve")
			continue;
		select ($shapes[$y]+".cv[0:99999]");
		refresh;
		setToolTo $gMove;
		$pos=`manipMoveContext -q -position "Move"`;
		scale -r -p $pos[0] $pos[1] $pos[2] $scale $scale $scale;
		}
	}
select $sel;
}

global proc string[] asSkinCurveSliderInfo (string $skinCurve)
{
string $info[];//[0]=$deformJoint [1]=start/middle/end [2]=restoreWeightsToJoint
string $childJoint;
string $tempString[];
tokenize $skinCurve "_" $tempString;
string $deformJoint=$tempString[0]+"_"+$tempString[1];
$info[0]=$deformJoint;
if (`gmatch $skinCurve "*_middleProfile"`)
	$info[1]="middle";
if (`gmatch $skinCurve "*_startProfile"`)
	$info[1]="start";
if (`gmatch $skinCurve "*_endProfile"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile1"`)
	$info[1]="end";
if (`gmatch $skinCurve "*_twistProfile[2-9]"`)
	{
	//First some traversing to find the childJoint
	$tempString=`listRelatives -c -type joint $deformJoint`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
		if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
		}
	while (`gmatch $childJoint "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -c -type joint $childJoint`;
		$childJoint="";
		for ($i=0;$i<size($tempString);$i++)
			{
			if (`objExists ("FK"+$tempString[$i])`) $childJoint=$tempString[$i];
			if (`gmatch $tempString[$i] "*Part[0-9]_*"`) $childJoint=$tempString[$i];
			}
		}
	//Then see if it`s the lastTwister
	int $stringLenght=`size $skinCurve`;
	int $twistNr=`substring $skinCurve $stringLenght $stringLenght`;
	string $nextTwistProfile=`substring $skinCurve 1 ($stringLenght-1)`+($twistNr+1);
	if (!`objExists $nextTwistProfile`)
		{
		$info[0]=$childJoint;
		$info[1]="start";
		}
	}
//[2]=restoreWeightsToJoint
if (`gmatch $skinCurve "*_twistProfile1"`)
	{
	tokenize $skinCurve "_" $tempString;
	string $twistJoint=$tempString[0]+"Part1_"+$tempString[1];
	if (`objExists $twistJoint`)
		$info[2]=$twistJoint;
	else
		$info[2]=$info[0];
	}
else
	{
	$tempString=`listRelatives -p $info[0]`;
	if (`gmatch $skinCurve "*_endProfile"`)
		$info[2]=$info[0];
	else
		$info[2]=$tempString[0];
	}
return $info;
}

global proc asConvertSoftModToClusterControl (int $face)
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selXforms[]=`ls -sl -type transform`;
string $softModHandle;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*oftMod*Handle"`)
		$softModHandle=$sel[$i];
if ($softModHandle=="")
	error "SoftMod must be selected";

if (!`objExists ClusterControlMirrorSoftModHandle`)
	if (`promptDialog -t "Name" -m "Enter Name of new control:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
		return;
string $name=`promptDialog -query -text`;
string $side="_R";
string $faceBody="Body";
if ($face)
	$faceBody="Face";
if (`objExists ($name+$side)` && !`objExists ClusterControlMirrorSoftModHandle`)
	error ("\""+$name+$side+"\" Already exists, choose another name");
setToolTo $gSelect;
string $softMod,$mesh,$skinCluster,$nearestJoint,$buildPoseCmd,$newCtrlBuildPoseCmd,$maxWeightVts;
string $tempString[],$historyNodes[],$deformJoints[],$vtxs[],$historyNodes[];
int $haveSkinCluster;

int $mirror=`checkBox -q -v ("as"+$faceBody+"ClusterControlMirrorCheckBox")`;
int $middle=`checkBox -q -v ("as"+$faceBody+"ClusterControlMiddleCheckBox")`;
int $local=`checkBox -q -v ("as"+$faceBody+"ClusterControlLocalCheckBox")`;

float $mag,$vtxMag,$nearestJointDist,$falloffRadius,$falloffMode,$weight,$maxWeight,$magAB,$magAC;
float $pos[],$currentPos[],$vtxCurrentPos[],$originPos[],$vtxOriginPos[],$currentTrans[],$tempFloatA[],$tempFloatB[],$tempFloatC[];

if (!`objExists CustomSystem`)
	{
	createNode -n CustomSystem transform;
	if (`objExists MotionSystem`)
		parent CustomSystem MotionSystem;
	else if (`objExists FaceMotionSystem`)
		parent CustomSystem FaceMotionSystem;
	if (`objExists Main`)
		{
		//Could be AdvancedFace without AdvancedBody
		if (!`attributeExists customVis Main`)	
			{
			addAttr -k 1 -ln customVis -at bool -dv 1 Main;
			setAttr -k 0 -cb 1 Main.customVis;
			}
		connectAttr Main.customVis CustomSystem.v;
		}
	}
$currentPos=`xform -q -ws -piv $softModHandle`;
$currentTrans=`getAttr ($softModHandle+".t")`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;
$originPos=`xform -q -ws -piv $softModHandle`;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
$falloffRadius=`getAttr ($softMod+".falloffRadius")`;
$falloffMode=`getAttr ($softMod+".falloffMode")`;
$tempString=`listConnections -type mesh ($softMod+".outputGeometry")`;
$mesh=$tempString[0];
if ($originPos[0]>0)
	{
	$side="_L";
	}
if ($middle)
	{
	$originPos[0]=0;
	setAttr ($softModHandle+".originX") 0;
	setAttr ($softMod+".falloffCenterX") 0;
	$side="_M";
	}

//create control
if (!`objExists asClusterControlShader`)
	{
	shadingNode -n asClusterControlShader -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name asClusterControlShaderSG;
	connectAttr -f asClusterControlShader.outColor asClusterControlShaderSG.surfaceShader;
	setAttr -type float3 asClusterControlShader.color 1 0 0;
	}
float $scale=`asGetScale`;
if ($face)
	$scale=$scale/3.0;
$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/5.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);
if ($local)
	addAttr -ln "localOrient" -at bool -dv 1 ($name+$side);
sets -e -forceElement asClusterControlShaderSG ($name+$side);
//sets -add "ControlSet" ($name+$side);
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") 13;
createNode -n ($name+"ClusterControlGrp"+$side) -p CustomSystem transform;
setAttr -l 1 ($name+"ClusterControlGrp"+$side+".inheritsTransform") 0;
createNode -n ($name+"Attach"+$side) transform;
parent ($name+"Attach"+$side) ($name+"ClusterControlGrp"+$side);
createNode -n ($name+"Offset"+$side) transform;
createNode -n ($name+"Subtract"+$side) transform;
parent ($name+$side) ($name+"Subtract"+$side);
parent ($name+"Subtract"+$side) ($name+"Offset"+$side);
parent ($name+"Offset"+$side) ($name+"Attach"+$side);

//orientConstraint to nearest joint (or sencond selected Xform)
if (`objExists DeformationSystem`)
	$deformJoints=`listRelatives -type joint -ad DeformationSystem`;
if ($face && `objExists FaceFitSkeleton`)
	if (`attributeExists HeadJoint FaceFitSkeleton`)
		{
		clear $deformJoints;
		$deformJoints[0]=`getAttr FaceFitSkeleton.HeadJoint`;
		}
$nearestJointDist=9999;
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Part[0-9]*"`)
		continue;
	$pos=`xform -q -ws -t $deformJoints[$i]`;
	$mag=`mag<<$pos[0]-$originPos[0],$pos[1]-$originPos[1],$pos[2]-$originPos[2]>>`;
	if ($mag<$nearestJointDist)
		{
		$nearestJoint=$deformJoints[$i];
		$nearestJointDist=$mag;
		}
	}
//(or sencond selected Xform)
if ($selXforms[1]!="") 
	if (`sets -im DeformSet $selXforms[1]` || $face)
		$nearestJoint=$selXforms[1];

if (`objExists Main`)
	connectAttr Main.s ($name+"Attach"+$side+".s");

if (!$local)
	parent -w ($name+"Offset"+$side);
orientConstraint $nearestJoint ($name+"Attach"+$side);
if (!$local)
	parent ($name+"Offset"+$side) ($name+"Attach"+$side);

//avoid double Xform
createNode -n ($name+"PlusMinusAverage"+$side) plusMinusAverage;
setAttr ($name+"PlusMinusAverage"+$side+".operation") 2;
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
connectAttr -f ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[1]");
disconnectAttr ($name+$side+".t") ($name+"PlusMinusAverage"+$side+".input3D[0]");
parent -w ($name+"Offset"+$side);
connectAttr -f ($name+"PlusMinusAverage"+$side+".output3D") ($name+"Subtract"+$side+".t");
xform -ws -t $originPos[0] $originPos[1] $originPos[2] ($name+"Offset"+$side);

//create cluster
select $mesh;
$tempString=`cluster -n ($name+"Cluster"+$side) -envelope 1`;
setAttr -type float3 ($name+"Cluster"+$side+"HandleShape.origin") $originPos[0] $originPos[1] $originPos[2];
xform -piv $originPos[0] $originPos[1] $originPos[2] ($name+"Cluster"+$side+"Handle");
parent ($name+"Cluster"+$side+"Handle") ($name+"ClusterControlGrp"+$side);
setAttr -l 1 ($name+"Cluster"+$side+"Handle.v") 0;

if ($local)
	{
	createNode -n ($name+"LocalOrient"+$side) -p ($name+"Attach"+$side) transform;
	parent ($name+"LocalOrient"+$side) ($name+"ClusterControlGrp"+$side);
	xform -ws -t $originPos[0] $originPos[1] $originPos[2] ($name+"LocalOrient"+$side);
	createNode -n ($name+"LocalTranform"+$side) -p ($name+"LocalOrient"+$side) transform;
	connectAttr ($name+$side+".t") ($name+"LocalTranform"+$side+".t");
	connectAttr ($name+$side+".r") ($name+"LocalTranform"+$side+".r");
	connectAttr ($name+$side+".s") ($name+"LocalTranform"+$side+".s");
	parentConstraint -mo ($name+"LocalTranform"+$side) ($name+"Cluster"+$side+"Handle");
	scaleConstraint ($name+"LocalTranform"+$side) ($name+"Cluster"+$side+"Handle");
	}
else
	{
	connectAttr ($name+$side+".t") ($name+"Cluster"+$side+"Handle.t");
	connectAttr ($name+$side+".r") ($name+"Cluster"+$side+"Handle.r");
	connectAttr ($name+$side+".s") ($name+"Cluster"+$side+"Handle.s");
	}

//set clusterWeights
select $mesh;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $originPos[0] $originPos[1] $originPos[2];
$vtxs=`ls -sl -fl`;
polySelectConstraint -m 0;
//$mag=`mag<<$currentPos[0]-$originPos[0],$currentPos[1]-$originPos[1],$currentPos[2]-$originPos[2]>>`;
//speed up by disable other deformers
$historyNodes=`listHistory -pdo 1 -il 2 $mesh`;
for ($i=0;$i<size($historyNodes);$i++)
	setAttr ($historyNodes[$i]+".nodeState") 1;
setAttr ($softMod+".nodeState") 0;
percent -v 0 ($name+"Cluster"+$side) ($mesh+".vtx[0:99999]");
progressBar -e -st ("Converting SoftMod ("+$side+")") -bp -ii 1 -min 0 -max (size($vtxs)) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
for ($y=0;$y<size($vtxs);$y++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		print "// Cancelled.\n";
		delete ($name+"Offset"+$side) ($name+"Attach"+$side) ($name+"Cluster"+$side+"Handle");
		setAttr -type float3 ($softModHandle+".t") $currentTrans[0] $currentTrans[1] $currentTrans[2];
		select $softModHandle;
		return;
		}
	progressBar -e -s 1 $gMainProgressBar;
	setAttr -type float3 ($softModHandle+".t") 0 1 0;
	$vtxCurrentPos=`xform -q -ws -t $vtxs[$y]`;
	setAttr -type float3 ($softModHandle+".t") 0 0 0;
	$vtxOriginPos=`xform -q -ws -t $vtxs[$y]`;
//	$vtxMag=`mag<<$vtxCurrentPos[0]-$vtxOriginPos[0],$vtxCurrentPos[1]-$vtxOriginPos[1],$vtxCurrentPos[2]-$vtxOriginPos[2]>>`;
//	$weight=$vtxMag/1.0;
	$weight=($vtxCurrentPos[1]-$vtxOriginPos[1])/1.0;
	percent -v $weight ($name+"Cluster"+$side) $vtxs[$y];
	if ($weight>$maxWeight)
		{
		$maxWeightVts=$vtxs[$y];
		$maxWeight=$weight;
		}
	}
for ($i=0;$i<size($historyNodes);$i++)
	setAttr ($historyNodes[$i]+".nodeState") 0;
progressBar -e -ep $gMainProgressBar;

//Attach to the vert that will have the highest weight, via CurveFromMeshEdge;
select $maxWeightVts;
ConvertSelectionToEdges;
$tempString=`ls -sl -fl`;
select $tempString[0];
$tempString=`duplicateCurve -ch 1 -rn 0 -local 0`;
rename $tempString[0] ($name+"Curve"+$side);
rename $tempString[1] ($name+"CurveFromMeshEdge"+$side);
parent ($name+"Curve"+$side) ($name+"ClusterControlGrp"+$side);
setAttr -l 1 ($name+"Curve"+$side+".v") 0;
createNode -n ($name+"PointOnCurveInfo"+$side) pointOnCurveInfo;
setAttr ($name+"PointOnCurveInfo"+$side+".turnOnPercentage") 1;
connectAttr -f ($name+"Curve"+$side+"Shape.worldSpace[0]") ($name+"PointOnCurveInfo"+$side+".inputCurve");
connectAttr -f ($name+"PointOnCurveInfo"+$side+".position") ($name+"Attach"+$side+".t");
//determine PointOnCurveInfo.parameter
$tempFloatA=`xform -q -ws -t $maxWeightVts`;
$tempFloatB=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
$magAB=`mag<<$tempFloatA[0]-$tempFloatB[0],$tempFloatA[1]-$tempFloatB[1],$tempFloatA[2]-$tempFloatB[2]>>`;
setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 1;
$tempFloatC=`getAttr ($name+"PointOnCurveInfo"+$side+".position")`;
$magAC=`mag<<$tempFloatA[0]-$tempFloatC[0],$tempFloatA[1]-$tempFloatC[1],$tempFloatA[2]-$tempFloatC[2]>>`;
if ($magAB<$magAC)
	setAttr ($name+"PointOnCurveInfo"+$side+".parameter") 0;
parent ($name+"Offset"+$side) ($name+"Attach"+$side);

//reorderDeformers
$historyNodes=`listHistory -pdo 1 $mesh`;
for ($y=0;$y<size($historyNodes);$y++)
	if (`nodeType $historyNodes[$y]`=="skinCluster")
		{
		$haveSkinCluster=1;
		$skinCluster=$historyNodes[$y];
		}
if ($haveSkinCluster)
	catch (`reorderDeformers $skinCluster ($name+"Cluster"+$side) $mesh`);

//update buildPose
$newCtrlBuildPoseCmd="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+$side+";";
if ($face)
	{
	$buildPoseCmd=`getAttr faceBuildPose.udAttr`;
	setAttr -type "string" faceBuildPose.udAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
	sets -add FaceControlSet ($name+$side);
	}
else
	{
	$buildPoseCmd=`getAttr buildPose.udAttr`;
	setAttr -type "string" buildPose.udAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
	sets -add ControlSet ($name+$side);
	}

if ($mirror && !`objExists ClusterControlMirrorSoftModHandle`)
	{
	select $mesh;
	$tempString=`softMod`;
	rename $tempString[0] ClusterControlMirrorSoftMod;
	rename $tempString[1] ClusterControlMirrorSoftModHandle;
	setAttr -type float3 ClusterControlMirrorSoftModHandle.origin ($originPos[0]*-1) $originPos[1] $originPos[2];
	setAttr ClusterControlMirrorSoftMod.falloffCenter ($originPos[0]*-1) $originPos[1] $originPos[2];
//	setAttr -l 1 ClusterControlMirrorSoftMod.falloffCenterX;
	xform -piv ($originPos[0]*-1) $originPos[1] $originPos[2] ClusterControlMirrorSoftModHandle;
	setAttr ClusterControlMirrorSoftMod.falloffMode $falloffMode;
	setAttr ClusterControlMirrorSoftMod.falloffRadius $falloffRadius;
	select ClusterControlMirrorSoftModHandle;
	asConvertSoftModToClusterControl $face;
	}

if (`nodePreset -exists $softMod "asSoftMod"`)
	nodePreset -delete $softMod "asSoftMod";
delete $softModHandle;
select ($name+$side);
print ("// ClusterControl created\n");
}

global proc asConvertSoftModToSoftModControl (int $face)
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $selXforms[]=`ls -sl -type transform`;
string $softModHandle;
for ($i=0;$i<size($sel);$i++)
	if (`gmatch $sel[$i] "*oftMod*Handle"`)
		$softModHandle=$sel[$i];
if ($softModHandle=="")
	error "SoftMod must be selected";

if (!`objExists ClusterControlMirrorSoftModHandle`)
	if (`promptDialog -t "Name" -m "Enter Name of new control:" -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"`!="OK")
		return;
string $name=`promptDialog -query -text`;
string $faceBody="Body";
if ($face)
	$faceBody="Face";
string $side="_R";
if (`objExists ($name+$side)` && !`objExists ClusterControlMirrorSoftModHandle`)
	error ("\""+$name+$side+"\" Already exists, choose another name");
setToolTo $gSelect;
string $softMod,$mesh,$skinCluster,$nearestJoint,$buildPoseCmd,$newCtrlBuildPoseCmd,$maxWeightVts;
string $tempString[],$historyNodes[],$deformJoints[],$vtxs[],$historyNodes[];
int $haveSkinCluster;
int $mirror=`checkBox -q -v ("as"+$faceBody+"ClusterControlMirrorCheckBox")`;
int $middle=`checkBox -q -v ("as"+$faceBody+"ClusterControlMiddleCheckBox")`;
int $local=`checkBox -q -v ("as"+$faceBody+"ClusterControlLocalCheckBox")`;

float $mag,$vtxMag,$nearestJointDist,$falloffRadius,$falloffMode,$weight,$maxWeight,$magAB,$magAC;
float $pos[],$currentPos[],$vtxCurrentPos[],$originPos[],$vtxOriginPos[],$currentTrans[],$tempFloatA[],$tempFloatB[],$tempFloatC[];

if ($face)
	{
	$mirror=`checkBox -q -v asFaceClusterControlMirrorCheckBox`;
	$middle=`checkBox -q -v asFaceClusterControlMiddleCheckBox`;
	}

if (!`objExists CustomSystem`)
	{
	createNode -n CustomSystem transform;
	if (`objExists MotionSystem`)
		parent CustomSystem MotionSystem;
	else if (`objExists FaceMotionSystem`)
		parent CustomSystem FaceMotionSystem;
	if (`objExists Main`)
		{
		//Could be AdvancedFace without AdvancedBody
		if (!`attributeExists customVis Main`)	
			{
			addAttr -k 1 -ln customVis -at bool -dv 1 Main;
			setAttr -k 0 -cb 1 Main.customVis;
			}
		connectAttr Main.customVis CustomSystem.v;
		}
	}
$currentPos=`xform -q -ws -piv $softModHandle`;
$currentTrans=`getAttr ($softModHandle+".t")`;
setAttr -type float3 ($softModHandle+".t") 0 0 0;
$originPos=`xform -q -ws -piv $softModHandle`;
$tempString=`listConnections ($softModHandle+".worldMatrix[0]")`;
$softMod=$tempString[0];
$falloffRadius=`getAttr ($softMod+".falloffRadius")`;
$falloffMode=`getAttr ($softMod+".falloffMode")`;
$tempString=`listConnections -type mesh ($softMod+".outputGeometry")`;
$mesh=$tempString[0];
if ($originPos[0]>0)
	{
	$side="_L";
	}
if ($middle)
	{
	$originPos[0]=0;
	setAttr ($softModHandle+".originX") 0;
	setAttr ($softMod+".falloffCenterX") 0;
	$side="_M";
	}

//create control
if (!`objExists asSoftModControlShader`)
	{
	shadingNode -n asSoftModControlShader -asShader lambert;
	sets -renderable true -noSurfaceShader true -empty -name asSoftModControlShaderSG;
	connectAttr -f asSoftModControlShader.outColor asSoftModControlShaderSG.surfaceShader;
	setAttr -type float3 asSoftModControlShader.color 0 1 0;
	}
float $scale=`asGetScale`;
if ($face)
	$scale=$scale/3.0;
$tempString=`sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r ($scale/5.0) -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0`;
rename $tempString[0] ($name+$side);
if ($local)
	addAttr -ln "localOrient" -at bool -dv 1 ($name+$side);
sets -e -forceElement asSoftModControlShaderSG ($name+$side);
//sets -add "ControlSet" ($name+$side);
setAttr ($name+$side+"Shape.overrideEnabled") 1;
setAttr ($name+$side+"Shape.overrideColor") 14;
createNode -n ($name+"Attach"+$side) transform;
parent ($name+"Attach"+$side) CustomSystem;

//orientConstraint to nearest joint (or sencond selected Xform)
if (`objExists DeformationSystem`)
	$deformJoints=`listRelatives -type joint -ad DeformationSystem`;
if ($face && `objExists FaceFitSkeleton`)
	if (`attributeExists HeadJoint FaceFitSkeleton`)
		{
		clear $deformJoints;
		$deformJoints[0]=`getAttr FaceFitSkeleton.HeadJoint`;
		}
$nearestJointDist=9999;
for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Part[0-9]*"`)
		continue;
	$pos=`xform -q -ws -t $deformJoints[$i]`;
	$mag=`mag<<$pos[0]-$originPos[0],$pos[1]-$originPos[1],$pos[2]-$originPos[2]>>`;
	if ($mag<$nearestJointDist)
		{
		$nearestJoint=$deformJoints[$i];
		$nearestJointDist=$mag;
		}
	}
//(or sencond selected Xform)
if ($selXforms[1]!="") 
	if (`sets -im DeformSet $selXforms[1]` || $face)
		$nearestJoint=$selXforms[1];

//createsoftMod
select $mesh;
$tempString=`softMod`;
rename $tempString[0] ($name+"SoftMod"+$side);
rename $tempString[1] ($name+"SoftModModHandle"+$side);
$tempString=`listConnections ($name+"SoftMod"+$side+".message")`;
rename $tempString[0] ($name+"SoftModSet"+$side);
setAttr -type float3 ($name+"SoftModModHandle"+$side+".origin") $originPos[0] $originPos[1] $originPos[2];
setAttr ($name+"SoftMod"+$side+".falloffCenter") $originPos[0] $originPos[1] $originPos[2];
xform -piv $originPos[0] $originPos[1] $originPos[2] ($name+"SoftModModHandle"+$side);
if (!`objExists ClusterControlMirrorSoftModHandle`)
	nodePreset -save $softMod "asSoftMod";
nodePreset -load ($name+"SoftMod"+$side) "asSoftMod";
if (`objExists ClusterControlMirrorSoftModHandle`)
	setAttr ($name+"SoftMod"+$side+".falloffCenterX") (`getAttr ($name+"SoftMod"+$side+".falloffCenterX")`*-1);

$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
rename $tempString[0] ($name+"Base"+$side);
if ($local)
	addAttr -ln "localOrient" -at bool -dv 1 ($name+"Base"+$side);
scale -r -p 0 0 0 ($scale/2.0) ($scale/2.0) ($scale/2.0) ($name+"Base"+$side+"Shape.cv[0:4]");
setAttr ($name+"Base"+$side+"Shape.overrideEnabled") 1;
setAttr ($name+"Base"+$side+"Shape.overrideColor") 17;
parent ($name+"Base"+$side) ($name+"Attach"+$side);
parent ($name+$side) ($name+"Base"+$side);

spaceLocator -n ($name+"BaseLocator"+$side);
parent ($name+"BaseLocator"+$side) ($name+"Base"+$side);
setAttr -l 1 ($name+"BaseLocator"+$side+".v") 0;
setAttr -l 1 ($name+"SoftModModHandle"+$side+".v") 0;
connectAttr ($name+"BaseLocator"+$side+"Shape.worldPosition[0]") ($name+"SoftMod"+$side+".falloffCenter");

xform -ws -t $originPos[0] $originPos[1] $originPos[2] ($name+"Attach"+$side);
if ($local)
	{
	pointConstraint -mo $nearestJoint ($name+"Attach"+$side);
	orientConstraint $nearestJoint ($name+"Attach"+$side);
	}
else
	parentConstraint -mo $nearestJoint ($name+"Attach"+$side);
scaleConstraint $nearestJoint ($name+"Attach"+$side);

disconnectAttr ($name+"SoftModModHandle"+$side+"Shape.softModTransforms[0]") ($name+"SoftMod"+$side+".softModXforms");
disconnectAttr ($name+"SoftModModHandle"+$side+".worldMatrix[0]") ($name+"SoftMod"+$side+".matrix");
delete ($name+"SoftModModHandle"+$side);

//non-zero matrix, to avoid SoftMod reuse, when adding more then 1 softMod
connectAttr ($name+"Attach"+$side+".worldMatrix[0]") ($name+"SoftMod"+$side+".matrix");

connectAttr ($name+"Base"+$side+".worldInverseMatrix[0]") ($name+"SoftMod"+$side+".postMatrix");
connectAttr ($name+"Base"+$side+".worldMatrix[0]") ($name+"SoftMod"+$side+".preMatrix");

createNode -n ($name+"SoftModMultMatrix"+$side) multMatrix;
connectAttr ($name+$side+".worldMatrix[0]") ($name+"SoftModMultMatrix"+$side+".matrixIn[0]");
connectAttr ($name+$side+".parentInverseMatrix[0]") ($name+"SoftModMultMatrix"+$side+".matrixIn[1]");
connectAttr ($name+"SoftModMultMatrix"+$side+".matrixSum") ($name+"SoftMod"+$side+".softModXforms.weightedMatrix");

//falloffRadius
addAttr -k 1 -ln falloffRadius -at double -dv 1 ($name+$side);
addAttr -k 1 -ln "falloffMode" -at "enum" -en "volume:surface:" -dv $falloffMode ($name+$side);
connectAttr ($name+$side+".falloffMode") ($name+"SoftMod"+$side+".falloffMode");

createNode -n ($name+"MainScaleForSoftModMPD1"+$side) multiplyDivide;
connectAttr ($name+$side+".falloffRadius") ($name+"MainScaleForSoftModMPD1"+$side+".input1.input1X");
setAttr ($name+"MainScaleForSoftModMPD1"+$side+".input2.input2X") $falloffRadius;
//	connectAttr ($name+"MainScaleForSoftModMPD"+$side+".outputX") ($name+"SoftMod"+$side+".falloffRadius");

createNode -n ($name+"MainScaleForSoftModMPD2"+$side) multiplyDivide;
connectAttr ($name+"MainScaleForSoftModMPD1"+$side+".outputX") ($name+"MainScaleForSoftModMPD2"+$side+".input1.input1X");
connectAttr ($name+"Attach"+$side+".sx") ($name+"MainScaleForSoftModMPD2"+$side+".input2.input2X");

connectAttr ($name+"MainScaleForSoftModMPD2"+$side+".outputX") ($name+"SoftMod"+$side+".falloffRadius");

//update buildPose
$newCtrlBuildPoseCmd ="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+$side+";";
$newCtrlBuildPoseCmd+="xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 "+$name+"Base"+$side+";";
if ($face)
	{
	$buildPoseCmd=`getAttr faceBuildPose.udAttr`;
	setAttr -type "string" faceBuildPose.udAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
	sets -add FaceControlSet ($name+$side);
	sets -add FaceControlSet ($name+"Base"+$side);
	}
else
	{
	$buildPoseCmd=`getAttr buildPose.udAttr`;
	setAttr -type "string" buildPose.udAttr ($buildPoseCmd+$newCtrlBuildPoseCmd);
	sets -add ControlSet ($name+$side);
	sets -add ControlSet ($name+"Base"+$side);
	}

if ($mirror && !`objExists ClusterControlMirrorSoftModHandle`)
	{
	select $mesh;
	$tempString=`softMod`;
	rename $tempString[0] ClusterControlMirrorSoftMod;
	rename $tempString[1] ClusterControlMirrorSoftModHandle;
	setAttr -type float3 ClusterControlMirrorSoftModHandle.origin ($originPos[0]*-1) $originPos[1] $originPos[2];
	setAttr ClusterControlMirrorSoftMod.falloffCenter ($originPos[0]*-1) $originPos[1] $originPos[2];
	xform -piv ($originPos[0]*-1) $originPos[1] $originPos[2] ClusterControlMirrorSoftModHandle;
	setAttr ClusterControlMirrorSoftMod.falloffMode $falloffMode;
	setAttr ClusterControlMirrorSoftMod.falloffRadius $falloffRadius;
	select ClusterControlMirrorSoftModHandle;
	asConvertSoftModToSoftModControl $face;
	}

if (`nodePreset -exists $softMod "asSoftMod"`)
	nodePreset -delete $softMod "asSoftMod";
delete $softModHandle;
select ($name+$side);
print ("// SoftModControl created\n");
}

global proc asPaintClusterControlWeights ()
{
global string $artSelectObject;

string $sel[]=`ls -sl`;
if ($sel[0]=="") error "Select Control first";
string $tempString[]=`listConnections ($sel[0]+".r")`;
string $clusterHandle=$tempString[0];
if ($clusterHandle=="")
	error "No ClusterHandle found, selected object is not a Cluster-Control";
$tempString=`listConnections ($clusterHandle+".worldMatrix")`;
string $cluster=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
select $clusterSet;
select `ls -sl -o`;

artAttrToolScript 4 "cluster";
$artSelectObject="";
eval ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$cluster+".weights\")");
evalEcho ("artSetToolAndSelectAttr( \"artAttrCtx\", \"cluster."+$cluster+".weights\")");
toolPropertyWindow;
}

global proc asMirrorClusterControlWeights ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $mirrorCuster,$mirrorVtx,$object;
float $tempFloat[],$pos[];
if ($sel[0]=="") error "Select Control first";
$tempString=`listConnections ($sel[0]+".r")`;
string $clusterHandle=$tempString[0];
$tempString=`listConnections ($clusterHandle+".worldMatrix")`;
string $cluster=$tempString[0];
$tempString=`listConnections ($cluster+".message")`;
string $clusterSet=$tempString[0];
select $clusterSet;
$tempString=`ls -sl -fl`;
select `ls -sl -o`;
$tempString2=`ls -sl`;
$tempString2=`listRelatives -p $tempString2[0]`;
$object=$tempString2[0];

if (`gmatch $cluster "*_R"`)
	$mirrorCuster=`substitute "_R" $cluster "_L"`;
else
	$mirrorCuster=`substitute "_L" $cluster "_R"`;

percent -v 0 $mirrorCuster $object;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr ($object+".outMesh") closestSampler.inMesh;
//connectAttr -f ($object+".matrix") closestSampler.inputMatrix;\\Creates incorrect results, so just rely on Mesh have frozen xforms

progressBar -e -st "Mirroring" -bp -ii 1 -min 0 -max (size($tempString)) $gMainProgressBar;
evalDeferred ("progressBar -e -ep "+$gMainProgressBar);
for ($i=0;$i<size($tempString);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
	progressBar -e -s 1 $gMainProgressBar;
	$tempFloat=`percent -q -v $cluster $tempString[$i]`;
	$pos=`xform -q -ws -t $tempString[$i]`;
	if (`gmatch $cluster "*_R"` && $pos[0]>-0.001)
		continue;
	if (`gmatch $cluster "*_L"` && $pos[0]<0.001)
		continue;
	setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
	$mirrorVtx=$object+".vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	percent -v $tempFloat[0] $mirrorCuster $mirrorVtx;
	}
progressBar -e -ep $gMainProgressBar;
delete closestSampler;
select $sel;
}

global proc asAddSoftModInfluencedObject ()
{
string $set;
string $tempString[],$objectsToAdd[];
string $sel[]=`ls -sl`;

if (size($sel)<2)
	error "Select the controller, AND the object that should be influenced";

for ($i=0;$i<size($sel);$i++)
	{
	tokenize $sel[$i] "_" $tempString;
	if (size($tempString)<2)
		continue;
	if (`objExists ($tempString[0]+"SoftModSet_"+$tempString[1])`)
		$set=$tempString[0]+"SoftModSet_"+$tempString[1];
	else
		$objectsToAdd[size($objectsToAdd)]=$sel[$i];
	}
if ($set=="")
	error "No SoftModSet found, selected object is not a SoftMod-Control";
for ($i=0;$i<size($objectsToAdd);$i++)
	{
	print ("// Adding object \""+$objectsToAdd[$i]+"\" to \""+$set+"\".\n");
	sets -add $set $objectsToAdd[$i];
	}
}

global proc asCreateUnrealJoints ()
{
asDeleteUnrealJoints;

select DeformationSystem;
joint -n UnrealRoot;
parent Root_M UnrealRoot;
parentConstraint Main UnrealRoot;
parent UnrealRoot_parentConstraint1 ConstraintSystem;
connectAttr Main.s UnrealRoot.s;
select UnrealRoot;
joint -n ik_foot_root;
joint -n ik_foot_l;
select ik_foot_root;
joint -n ik_foot_r;
select UnrealRoot;
joint -n ik_hand_root;
joint -n ik_hand_gun;
joint -n ik_hand_l;
select ik_hand_gun;
joint -n ik_hand_r;
if (`objExists Wrist_R`) asAlign ik_hand_gun Wrist_R 1 0 0 0;
if (`objExists Wrist_L`) asAlign ik_hand_l Wrist_L 1 0 0 0;
if (`objExists Ankle_R`) asAlign ik_foot_r Ankle_R 1 0 0 0;
if (`objExists Ankle_L`) asAlign ik_foot_l Ankle_L 1 0 0 0;

select -cl;
print ("// Unreal Joint created\n");
}

global proc asDeleteUnrealJoints ()
{
string $tempString[];
string $deleteObjs[]={"UnrealRoot","UnrealRoot_parentConstraint1","ik_foot_root","ik_hand_root"};
if (`objExists UnrealRoot`)
	{
	$tempString=`listRelatives -c UnrealRoot`;
	if (size($tempString))
		parent $tempString DeformationSystem;
	}
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asCreateUnrealMannequinJoints ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

asDeleteUnrealJoints;
if (`objExists |root`) delete |root;

//make sure all names for Unreal joints are avaiable
int $constrainedToUnrealSkeleton;
string $destJoints[]={"root","spine_01","spine_02","spine_03","neck_01","head"};
string $deformJointsList[]=`sets -q "DeformSet"`;
string $sideDestJoints[],$tempString[],$tempString2[],$tempString3[],$notConstrainedJoints[];
string $SIDE="_R";
string $side="_r";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$SIDE="_L";$side="_l";}
	$sideDestJoints={("clavicle"+$side),("upperarm"+$side),("upperarm_twist_01"+$side),("lowerarm"+$side),("lowerarm_twist_01"+$side),("hand"+$side),
		("index_01"+$side),("index_02"+$side),("index_03"+$side),
		("middle_01"+$side),("middle_02"+$side),("middle_03"+$side),
		("ring_01"+$side),("ring_02"+$side),("ring_03"+$side),
		("pinky_01"+$side),("pinky_02"+$side),("pinky_03"+$side),
		("thumb_01"+$side),("thumb_02"+$side),("thumb_03"+$side),
		("thigh"+$side),("thigh_twist_01"+$side),("calf"+$side),("calf_twist_01"+$side),("foot"+$side),("ball"+$side)};
	}
$destJoints=`stringArrayCatenate $destJoints $sideDestJoints`;
for ($i=0;$i<size($destJoints);$i++)
	if (`objExists $destJoints[$i]`)
		{
		select $destJoints[$i];
		error ("A object with the name \""+$destJoints[$i]+"\" already exists, rename this to another name first.");
		}

string $unrealFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asUnreal.ma";
if (!`file -q -ex $unrealFile`)
	error ("Not found:"+$unrealFile);
file -i $unrealFile;

if (`objExists Main`)
	{
	pointConstraint Main root;
	orientConstraint Main root;
	setAttr root_orientConstraint1.offsetX -90;
	}
if (`objExists Root_M`)
	{
	pointConstraint Root_M pelvis;
	orientConstraint Root_M pelvis;
	setAttr pelvis_orientConstraint1.offsetX 180;
	}
if (`objExists RootPart1_M`)
	{
	pointConstraint RootPart1_M spine_01;
	orientConstraint RootPart1_M spine_01;
	setAttr spine_01_orientConstraint1.offsetX 180;
	}
else if (`objExists Root_M` && `objExists Spine1_M`)
	{
	pointConstraint Spine1_M spine_01;
	orientConstraint Spine1_M spine_01;
	setAttr spine_01_orientConstraint1.offsetX 180;
	delete spine_01_orientConstraint1 spine_01_pointConstraint1;
	pointConstraint Root_M Spine1_M spine_01;
	}
if (`objExists Spine1_M`)
	{
	pointConstraint Spine1_M spine_02;
	orientConstraint Spine1_M spine_02;
	setAttr spine_02_orientConstraint1.offsetX 180;
	}
if (`objExists Chest_M`)
	{
	pointConstraint Chest_M spine_03;
	orientConstraint Chest_M spine_03;
	setAttr spine_03_orientConstraint1.offsetX 180;
	}
$SIDE="_R";
$side="_r";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$SIDE="_L";$side="_l";}
	if (`objExists ("Scapula"+$SIDE)`)
		{
		pointConstraint ("Scapula"+$SIDE) ("clavicle"+$side);
		orientConstraint ("Scapula"+$SIDE) ("clavicle"+$side);
		setAttr -type float3 ("clavicle"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("Shoulder"+$SIDE)`)
		{
		pointConstraint ("Shoulder"+$SIDE) ("upperarm"+$side);
		orientConstraint ("Shoulder"+$SIDE) ("upperarm"+$side);
		setAttr -type float3 ("upperarm"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("Elbow"+$SIDE)`)
		{
		pointConstraint ("Elbow"+$SIDE) ("lowerarm"+$side);
		orientConstraint ("Elbow"+$SIDE) ("lowerarm"+$side);
		setAttr -type float3 ("lowerarm"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("ShoulderPart1"+$SIDE)`)
		{
		pointConstraint ("ShoulderPart1"+$SIDE) ("upperarm_twist_01"+$side);
		orientConstraint ("ShoulderPart1"+$SIDE) ("upperarm_twist_01"+$side);
		setAttr -type float3 ("upperarm_twist_01"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("ElbowPart1"+$SIDE)`)
		{
		pointConstraint ("ElbowPart1"+$SIDE) ("lowerarm_twist_01"+$side);
		orientConstraint ("ElbowPart1"+$SIDE) ("lowerarm_twist_01"+$side);
		setAttr -type float3 ("lowerarm_twist_01"+$side+"_orientConstraint1.offset") 180 0 180;
		}
	if (`objExists ("Wrist"+$SIDE)`)
		{
		pointConstraint ("Wrist"+$SIDE) ("hand"+$side);
		orientConstraint ("Wrist"+$SIDE) ("hand"+$side);
		setAttr -type float3 ("hand"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("PinkyFinger1"+$SIDE)`)
		{
		pointConstraint ("PinkyFinger1"+$SIDE) ("pinky_01"+$side);
		orientConstraint ("PinkyFinger1"+$SIDE) ("pinky_01"+$side);
		setAttr -type float3 ("pinky_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("PinkyFinger2"+$SIDE)`)
		{
		pointConstraint ("PinkyFinger2"+$SIDE) ("pinky_02"+$side);
		orientConstraint ("PinkyFinger2"+$SIDE) ("pinky_02"+$side);
		setAttr -type float3 ("pinky_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("PinkyFinger3"+$SIDE)`)
		{
		pointConstraint ("PinkyFinger3"+$SIDE) ("pinky_03"+$side);
		orientConstraint ("PinkyFinger3"+$SIDE) ("pinky_03"+$side);
		setAttr -type float3 ("pinky_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("RingFinger1"+$SIDE)`)
		{
		pointConstraint ("RingFinger1"+$SIDE) ("ring_01"+$side);
		orientConstraint ("RingFinger1"+$SIDE) ("ring_01"+$side);
		setAttr -type float3 ("ring_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("RingFinger2"+$SIDE)`)
		{
		pointConstraint ("RingFinger2"+$SIDE) ("ring_02"+$side);
		orientConstraint ("RingFinger2"+$SIDE) ("ring_02"+$side);
		setAttr -type float3 ("ring_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("RingFinger3"+$SIDE)`)
		{
		pointConstraint ("RingFinger3"+$SIDE) ("ring_03"+$side);
		orientConstraint ("RingFinger3"+$SIDE) ("ring_03"+$side);
		setAttr -type float3 ("ring_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("MiddleFinger1"+$SIDE)`)
		{
		pointConstraint ("MiddleFinger1"+$SIDE) ("middle_01"+$side);
		orientConstraint ("MiddleFinger1"+$SIDE) ("middle_01"+$side);
		setAttr -type float3 ("middle_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("MiddleFinger2"+$SIDE)`)
		{
		pointConstraint ("MiddleFinger2"+$SIDE) ("middle_02"+$side);
		orientConstraint ("MiddleFinger2"+$SIDE) ("middle_02"+$side);
		setAttr -type float3 ("middle_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("MiddleFinger3"+$SIDE)`)
		{
		pointConstraint ("MiddleFinger3"+$SIDE) ("middle_03"+$side);
		orientConstraint ("MiddleFinger3"+$SIDE) ("middle_03"+$side);
		setAttr -type float3 ("middle_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("IndexFinger1"+$SIDE)`)
		{
		pointConstraint ("IndexFinger1"+$SIDE) ("index_01"+$side);
		orientConstraint ("IndexFinger1"+$SIDE) ("index_01"+$side);
		setAttr -type float3 ("index_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("IndexFinger2"+$SIDE)`)
		{
		pointConstraint ("IndexFinger2"+$SIDE) ("index_02"+$side);
		orientConstraint ("IndexFinger2"+$SIDE) ("index_02"+$side);
		setAttr -type float3 ("index_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("IndexFinger3"+$SIDE)`)
		{
		pointConstraint ("IndexFinger3"+$SIDE) ("index_03"+$side);
		orientConstraint ("IndexFinger3"+$SIDE) ("index_03"+$side);
		setAttr -type float3 ("index_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("ThumbFinger1"+$SIDE)`)
		{
		pointConstraint ("ThumbFinger1"+$SIDE) ("thumb_01"+$side);
		orientConstraint ("ThumbFinger1"+$SIDE) ("thumb_01"+$side);
		setAttr -type float3 ("thumb_01"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("ThumbFinger2"+$SIDE)`)
		{
		pointConstraint ("ThumbFinger2"+$SIDE) ("thumb_02"+$side);
		orientConstraint ("ThumbFinger2"+$SIDE) ("thumb_02"+$side);
		setAttr -type float3 ("thumb_02"+$side+"_orientConstraint1.offset") 90 0 180;
		}
	if (`objExists ("ThumbFinger3"+$SIDE)`)
		{
		pointConstraint ("ThumbFinger3"+$SIDE) ("thumb_03"+$side);
		orientConstraint ("ThumbFinger3"+$SIDE) ("thumb_03"+$side);
		setAttr -type float3 ("thumb_03"+$side+"_orientConstraint1.offset") 90 0 180;
		}

	if (`objExists ("Hip"+$SIDE)`)
		{
		pointConstraint ("Hip"+$SIDE) ("thigh"+$side);
		orientConstraint ("Hip"+$SIDE) ("thigh"+$side);
		}
	if (`objExists ("HipPart1"+$SIDE)`)
		{
		pointConstraint ("HipPart1"+$SIDE) ("thigh_twist_01"+$side);
		orientConstraint ("HipPart1"+$SIDE) ("thigh_twist_01"+$side);
		}
	if (`objExists ("Knee"+$SIDE)`)
		{
		pointConstraint ("Knee"+$SIDE) ("calf"+$side);
		orientConstraint ("Knee"+$SIDE) ("calf"+$side);
		}
	if (`objExists ("Knee"+$SIDE)` && `objExists ("Ankle"+$SIDE)`)
		{
		pointConstraint ("Knee"+$SIDE) ("Ankle"+$SIDE) ("calf_twist_01"+$side);
		orientConstraint ("Knee"+$SIDE) ("calf_twist_01"+$side);
		}
	if (`objExists ("Ankle"+$SIDE)`)
		{
		pointConstraint ("Ankle"+$SIDE) ("foot"+$side);
		orientConstraint ("Ankle"+$SIDE) ("foot"+$side);
		}
	if (`objExists ("Toes"+$SIDE)`)
		{
		pointConstraint ("Toes"+$SIDE) ("ball"+$side);
		orientConstraint ("Toes"+$SIDE) ("ball"+$side);
		setAttr ("ball"+$side+"_orientConstraint1.offsetZ") 180;
		}
	}
if (`objExists Neck_M`)
	{
	pointConstraint Neck_M neck_01;
	orientConstraint Neck_M neck_01;
	setAttr neck_01_orientConstraint1.offsetX 180;
	}
if (`objExists Head_M`)
	{
	pointConstraint Head_M head;
	orientConstraint Head_M head;
	setAttr head_orientConstraint1.offsetX 180;
	}

//custom joints
for ($i=0;$i<size($deformJointsList);$i++)
	{
	if (`gmatch $deformJointsList[$i] "*Part[0-9]*"` || `gmatch $deformJointsList[$i] "*Cup_*"`)
		continue;
	$tempString=`listRelatives -c -type joint $deformJointsList[$i]`;
	if (!size($tempString) && !`gmatch $deformJointsList[$i] "*Slider*"`)
			continue;
	$constrainedToUnrealSkeleton=0;
	$tempString=`listConnections -s 0 -d 1 -type constraint $deformJointsList[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`ls -l $tempString[$y]`;
		if (`gmatch $tempString2[0] "|root|*"`)
			{
			$constrainedToUnrealSkeleton=1;
			break;
			}
		}
	if (!$constrainedToUnrealSkeleton)
		$notConstrainedJoints[size($notConstrainedJoints)]=$deformJointsList[$i];
	}

for ($i=0;$i<size($notConstrainedJoints);$i++)
	{
print ($notConstrainedJoints[$i]+"\n");
	duplicate -n ("unreal"+$notConstrainedJoints[$i]) $notConstrainedJoints[$i];
	sets -rm DeformSet ("unreal"+$notConstrainedJoints[$i]);
	sets -rm AllSet ("unreal"+$notConstrainedJoints[$i]);
	parent -w ("unreal"+$notConstrainedJoints[$i]);
	$tempString=`listRelatives -c -f ("unreal"+$notConstrainedJoints[$i])`;
	if (size($tempString))
		delete $tempString;
	}
for ($i=0;$i<size($notConstrainedJoints);$i++)
	{
	$tempString=`listRelatives -p $notConstrainedJoints[$i]`;
	if (`objExists ("unreal"+$tempString[0])`)
		parent ("unreal"+$notConstrainedJoints[$i]) ("unreal"+$tempString[0]);
	else
		{
		$tempString=`listConnections -s 0 -d 1 -type constraint $tempString[0]`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$tempString2=`ls -l $tempString[$y]`;
			if (`gmatch $tempString2[0] "|root|*"`)
				{
				$tempString3=`listConnections -s 0 -d 1 -type joint $tempString[$y]`;
				parent ("unreal"+$notConstrainedJoints[$i]) $tempString3[0];
				break;
				}
			}
		}
	parentConstraint -mo $notConstrainedJoints[$i] ("unreal"+$notConstrainedJoints[$i]);
	}

//select -cl;
print ("// GameSkeleton created\n");
}

global proc asDeleteUnrealMannequinJoints ()
{
if (`objExists |root`) delete |root;
}

global proc asUnrealMannequinTransferSkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

int $transferBack;
string $scs[]=`ls -type skinCluster`;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $sourceJoints[]={"Root_M","Spine1_M","RootPart1_M","Chest_M","Neck_M","Head_M"};
string $destJoints[]={"pelvis","spine_01","spine_02","spine_03","neck_01","head"};
string $scps[],$sideSourceJoints[],$sideDestJoints[],$tempString[],$unrealJoints[];
string $sourceJoint;
string $SIDE="_R";
string $side="_r";
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1) {$SIDE="_L";$side="_l";}
	$sideSourceJoints={("Scapula"+$SIDE),("Shoulder"+$SIDE),("ShoulderPart1"+$SIDE),("Elbow"+$SIDE),("ElbowPart1"+$SIDE),("Wrist"+$SIDE),
//		("Cup"+$SIDE),
		("IndexFinger1"+$SIDE),("IndexFinger2"+$SIDE),("IndexFinger3"+$SIDE),
		("MiddleFinger1"+$SIDE),("MiddleFinger2"+$SIDE),("MiddleFinger3"+$SIDE),
		("RingFinger1"+$SIDE),("RingFinger2"+$SIDE),("RingFinger3"+$SIDE),
		("PinkyFinger1"+$SIDE),("PinkyFinger2"+$SIDE),("PinkyFinger3"+$SIDE),
		("ThumbFinger1"+$SIDE),("ThumbFinger2"+$SIDE),("ThumbFinger3"+$SIDE),
		("Hip"+$SIDE),("HipPart1"+$SIDE),("Knee"+$SIDE),("Knee"+$SIDE),("Ankle"+$SIDE),("Toes"+$SIDE)};
	$sideDestJoints={("clavicle"+$side),("upperarm"+$side),("upperarm_twist_01"+$side),("lowerarm"+$side),("lowerarm_twist_01"+$side),("hand"+$side),
//		("hand"+$side),
		("index_01"+$side),("index_02"+$side),("index_03"+$side),
		("middle_01"+$side),("middle_02"+$side),("middle_03"+$side),
		("ring_01"+$side),("ring_02"+$side),("ring_03"+$side),
		("pinky_01"+$side),("pinky_02"+$side),("pinky_03"+$side),
		("thumb_01"+$side),("thumb_02"+$side),("thumb_03"+$side),
		("thigh"+$side),("thigh_twist_01"+$side),("calf"+$side),("calf_twist_01"+$side),("foot"+$side),("ball"+$side)};
	$sourceJoints=`stringArrayCatenate $sourceJoints $sideSourceJoints`;
	$destJoints=`stringArrayCatenate $destJoints $sideDestJoints`;
	}

if (`attributeExists skinTransferred root`)
	$transferBack=1;
else
	addAttr -ln skinTransferred -dv 1 -at bool root;

if ($transferBack)
	{
	$tempString=$sourceJoints;
	$sourceJoints=$destJoints;
	$destJoints=$tempString;
	}

//transfer $sourceJoints to $destJoints
for ($i=0;$i<size($sourceJoints);$i++)
	{
	if (!`objExists $sourceJoints[$i]` || !`objExists $destJoints[$i]`)
		continue;
	$scps=`listConnections -p 1 ($sourceJoints[$i]+".worldMatrix[0]")`;
	for ($y=0;$y<size($scps);$y++)
		connectAttr -f ($destJoints[$i]+".worldMatrix[0]") $scps[$y];
	}

//any custom joints, now call "unreal" joints
$unrealJoints=`ls -type joint "unreal*"`;
for ($i=0;$i<size($unrealJoints);$i++)
	{
	$sourceJoint=`substitute "unreal" $unrealJoints[$i] ""`;
	if (!`objExists $sourceJoint`)
		continue;
	if ($transferBack)
		{
		$tempString[0]=$unrealJoints[$i];
		$unrealJoints[$i]=$sourceJoint;
		$sourceJoint=$tempString[0];
		}
	$scps=`listConnections -p 1 ($sourceJoint+".worldMatrix[0]")`;
	for ($y=0;$y<size($scps);$y++)
		connectAttr -f ($unrealJoints[$i]+".worldMatrix[0]") $scps[$y];
	}

//any joints `under` head, to be assigned to head
$tempString=`listRelatives -ad -type joint Head_M`;
for ($i=0;$i<size($tempString);$i++)
	{
	$scps=`listConnections -p 1 ($tempString[$i]+".worldMatrix[0]")`;
	for ($y=0;$y<size($scps);$y++)
		connectAttr -f head.worldMatrix[0] $scps[$y];
	}

if (!$transferBack)
	for ($i=0;$i<size($scs);$i++)
		{
		for ($y=0;$y<size($deformJointsList);$y++)
			asRemoveInfluence $deformJointsList[$y] $scs[$i];
		}
for ($i=0;$i<size($scs);$i++)
	freezeSkinCluster $scs[$i];
dgdirty -a;
if ($transferBack)
	print "// Transferring skinning back to AdvancedSkeleton joints.\n";
else
	print ("// Skinning transferred to Unreal Skeleton\n");
}

global proc asCreatePartialJoints ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $dialog=`confirmDialog -t "Confirm"
	-m "Create Partial Joints for all deformJoints ?"
	-b "OK" -b "Cancel" -db "Cancel"
	-ds "Cancel"`;
if ($dialog!="OK")
	return;

if (!`objExists "DeformSet"`)
	return;

float $charHeight=`asgetCharHeight`;
int $sideFactor;
string $deformJointsList[]=`sets -q "DeformSet"`;
string $children[],$partialJoints[],$zero[],$parents[],$buffer[],$tempString[];
for ($i=0;$i<size($deformJointsList);$i++)
	{
	$children=`listRelatives -type joint -c $deformJointsList[$i]`;
	$parents=`listRelatives -type joint -p $deformJointsList[$i]`;
	if (!size($children) || !size($parents) || `gmatch $deformJointsList[$i] "*Part[0-9]*"`)
		continue;
	if (`gmatch $deformJointsList[$i] "*_L"`)
		$sideFactor=-1;
	else
		$sideFactor=1;
	select $deformJointsList[$i];
	tokenize $deformJointsList[$i] "_" $buffer;
	$partialJoints[$i]=$buffer[0]+"50_"+$buffer[1];
	$partialJoints[$i]=$buffer[0]+"_"+$buffer[1]+"_50";
	$zero[$i]=$buffer[0]+"_"+$buffer[1]+"_00";
	if (`objExists $partialJoints[$i]`)
		error ("PartialJoints already exists");
	joint -n $partialJoints[$i];
	parent $partialJoints[$i] $parents[0];
	setAttr ($partialJoints[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	setAttr ($partialJoints[$i]+".segmentScaleCompensate") 0;
	addAttr -ln partialJoint -at bool $partialJoints[$i];
	sets -add "DeformSet" $partialJoints[$i];
	select $parents[0];
	createNode -n $zero[$i] transform;
	parent $zero[$i] $parents[0];
	setAttr -type float3 ($zero[$i]+".t") 0 0 0;
	setAttr -type float3 ($zero[$i]+".r") 0 0 0;
	setAttr ($zero[$i]+".rotateOrder") `getAttr ($deformJointsList[$i]+".rotateOrder")`;
	addAttr -ln partialJoint -at bool $zero[$i];
	$tempString=`orientConstraint $zero[$i] $deformJointsList[$i] $partialJoints[$i]`;
	$tempString=`pointConstraint $deformJointsList[$i] $partialJoints[$i]`;
	setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
	}
select -cl;
for ($i=0;$i<size($deformJointsList);$i++)
	if (`gmatch $partialJoints[$i] "*_?_50"`)
		select -add $partialJoints[$i];
}

global proc asDeletePartialJoints ()
{
if (!`objExists "DeformSet"`)
	return;

string $DeformationSystemNodes[]=`listRelatives -ad "DeformationSystem"`;
for ($i=0;$i<size($DeformationSystemNodes);$i++)
	if (`attributeExists partialJoint $DeformationSystemNodes[$i]`)
		delete $DeformationSystemNodes[$i];
}

global proc asCreateJointGroups ()
{
string $deformJoints[]=`listRelatives -ad -type joint DeformationSystem`;
string $tempString[],$tempString2[];
string $constraint;

for ($i=0;$i<size($deformJoints);$i++)
	{
	if (`gmatch $deformJoints[$i] "*Part[0-9]*"` || `gmatch $deformJoints[$i] "Spine*"` || `gmatch $deformJoints[$i] "Chest*"`)
		continue;
	$tempString=`listConnections ($deformJoints[$i]+".rx")`;
	$constraint=$tempString[0];
	if($constraint=="")
		continue;

	createNode -n ($deformJoints[$i]+"JointGroup") transform;
	asAlign ($deformJoints[$i]+"JointGroup") $deformJoints[$i] 1 1 0 1;
	$tempString=`listRelatives -p $deformJoints[$i]`;
	parent ($deformJoints[$i]+"JointGroup") $tempString[0];
	parent $deformJoints[$i] ($deformJoints[$i]+"JointGroup");

	if (`objExists ("IKX"+$deformJoints[$i])`)
		{
		createNode -n ("IKXJointGroup"+$deformJoints[$i]) transform;
		asAlign ("IKXJointGroup"+$deformJoints[$i]) $deformJoints[$i] 1 1 0 1;
		parent ("IKXJointGroup"+$deformJoints[$i]) ("IKX"+$deformJoints[$i]);
		}

	$tempString=`listConnections -s 1 -d 0 -p 1 -c 1 $constraint`;
	for ($y=0;$y<size($tempString);$y=$y+2)
		{
		if (`gmatch $tempString[$y] "*targetJointOrient"`)
			{
			disconnectAttr $tempString[$y+1] $tempString[$y];
			setAttr -type float3 $tempString[$y] 0 0 0;
			continue;
			}
		if (`gmatch $tempString[$y+1] "IKX*"`)
			{
			$tempString2[0]=`substitute "IKX" $tempString[$y+1] "IKXJointGroup"`;
			catchQuiet (`connectAttr -f $tempString2[0] $tempString[$y]`);
			}
		}
	}
print "// JointGroups created\n";
select -cl;
}

global proc asDsPopulatePopupMenu (string $action)
{
string $popupMenu="asDs"+$action+"PopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
int $numKeys,$firstDsAttr,$maxNumKeys;
float $keyValues[];
string $cmd,$lev1Menu,$lev2Menu,$lev3Menu,$drivingAttr,$animCurve;
string $tempString[],$attrs[],$animCurves[];
string $drivingSystems[]=`asDsGetDrivingSystems`;

for ($i=0;$i<size($drivingSystems);$i++)
	{
	$firstDsAttr=1;
	if (`gmatch $drivingSystems[$i] "*_L"` && $action=="Edit")
		continue;

	//$menu2s
	$attrs=`asDsGetAttrs $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		$drivingAttr=$attrs[$y];

		if ($firstDsAttr)
			{
			//$menu1s
			setParent -menu $popupMenu;
			$lev1Menu=`menuItem -sm 1 -l $drivingSystems[$i]`;
			$firstDsAttr=0;
			}

		if ($action=="Graph" || $action=="Delete")
			{
			menuItem -p $lev1Menu -c ("asDsEdit "+$action+" "+$drivingSystems[$i]+" "+$attrs[$y]+" 0") -l $attrs[$y];
			continue;
//			break;//No level3 menus
			}
		else
			{
			$lev2Menu=`menuItem -p $lev1Menu -sm 1 -l $attrs[$y]`;
			}

		//$menu3s
		$animCurves=`asDsGetAnimCurves $drivingSystems[$i] $drivingAttr`;
	
		if (!size($animCurves))
			continue;
		$maxNumKeys=0;
		for ($a=0;$a<size($animCurves);$a++)//for multiple animCurve`s, find the one with the most keys
			{
			$numKeys=`keyframe -q -keyframeCount $animCurves[$a]`;
			if ($numKeys>$maxNumKeys)
				{
				$maxNumKeys=$numKeys;
				$animCurve=$animCurves[$a];
				}
			}
		for ($x=$numKeys+1;$x>-1;$x--)
			{
			$keyValues=`keyframe -in $x -q -fc $animCurve`;
			$keyValues[0]=`asRoundOff $keyValues[0] 3`;
			if($keyValues[0]==0)
				continue;
			$cmd="asDsEdit "+$action+" "+$drivingSystems[$i]+" "+$attrs[$y]+" "+$keyValues[0];
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 0 -l $keyValues[0] -c $cmd`;
			}
		}
	}
}

global proc string[] asGetBlendedDrivers (string $obj, string $attr)
{
float $driver1Value,$driver2Value;
string $mpd,$setRange,$driver1,$driver2;
string $tempString[],$blendedDrivers[];

$tempString=`listConnections -s 1 -d 0 ($obj+"."+$attr)`;
$mpd=$tempString[0];
$tempString=`listConnections -s 1 -d 0 ($mpd+".input1X")`;
$setRange=$tempString[0];
$tempString=`listConnections -s 1 -d 0 -p 1 ($setRange+".valueX")`;
$driver1=$tempString[0];
$driver1Value=`getAttr ($setRange+".maxX")`;
$tempString=`listConnections -s 1 -d 0 -p 1 ($setRange+".valueY")`;
$driver2=$tempString[0];
$driver2Value=`getAttr ($setRange+".maxY")`;

$blendedDrivers={$driver1,$driver2};
return $blendedDrivers;
}

global proc float[] asGetBlendedDriverValues (string $obj, string $attr)
{
float $blendedDriverValues[]={1,1};
string $tempString[];

tokenize $attr "_" $tempString;
if (`gmatch $tempString[0] "*Neg"`) $blendedDriverValues[0]=-1;
if (`gmatch $tempString[1] "*Neg"`) $blendedDriverValues[1]=-1;

return $blendedDriverValues;
}

global proc asDsCreate ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global int $asDSMirror;
global int $asDSAdvancedOptions;
global int $asBuilding;
global int $asRebuilding;
global float $asDSAttrMin;
global float $asDSAttrMax;

$asDSAdvancedOptions=0;
int $modifier=`getModifiers`;
if ($modifier==4)
	$asDSAdvancedOptions=1;
int $isFace,$isEditingExisting;
string $sel[]=`ls -sl`;

int $reusingSdkXform,$useExistingController,$breakSideLoop,$blendedAttr,$numChar,$inControlSet,$inFaceControlSet;
float $runValues[],$pos[],$drivenValues[],$blendedDriverValues[];
float $poseValue,$currentValue,$maxDistAmoungDrivens,$minX,$maxX,$minY,$maxY,$minZ,$maxZ,$difX,$difY,$difZ,$controlScale,$min,$dist;
string $parent,$child,$obj,$attr,$drivenObj,$drivenAttr,$m,$t,$controllerName,$side,$oppositeSide,$buildPoseNode,$dialogResult,$controllerName,$attrName,$restorePoseCmd;
string $attrType,$originalSideControllerName,$ctrl,$mirroredCtrl,$att;
string $tempString[],$tempString2[],$tempString3[],$tempString4[],$drivens[],$sdkDrivens[],$runObjAttrs[],$checkObjAttr[],$drivenObjs[],$buildPoseCmds[],$runCmds[];
string $existingSdkXforms[],$faceSDKs[],$blendedDrivers[],$connectionAttrNames[];
float $driverValue=10;
float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;

//Do we come from AdvancedSkeleton BUILD Mode ?
int $comeFromASBuild=0;
if ($asBuilding || $asRebuilding)
	$comeFromASBuild=1;
else
	{
	$asDSObjName="";
	$asDSAttrName="";
	}

//Are we editing Existing DrivingSystem ?
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	$isEditingExisting=1;
	$tempString[0]=`headsUpDisplay -q -l HUDEDSMode`;
	tokenize $tempString[0] $tempString2;
	tokenize $tempString2[3] "=" $tempString3;
	tokenize $tempString3[0] "." $tempString4;
	$asDSObjName=$tempString4[0];
	$asDSAttrName=$tempString4[1];
	$driverValue=$tempString3[1];
	}

//run asUpdatePoseAttributes, as we might have `dud` cmds, due to manually deleted drivingSystems
asUpdatePoseAttributes;

//Find driven attribute(s)
//get $buildPoseCmds
if (`objExists ControlSet`)
	$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}

for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<size($buildPoseCmds);$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
	{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			tokenize $objAttr "." $tempString3;
			$obj=$tempString3[0];
			$attr=$tempString3[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;

			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				{
				$tempString2=`listRelatives -p $obj`;
				if ($tempString2[0]=="DrivingSystem" || `gmatch $tempString2[0] "ctrlBox*"`)
					{
					if ($checkObjAttr[$z]==$asDSObjName+"."+$asDSAttrName)//This is the driver, probably detected when enter Edit mode
						continue;
					else
						error ("Found \""+$checkObjAttr[$z]+"\", which is a DrivingSystem attribute. To modify this right>click on the \"Edit\" button");
					}
				else
					{
					//Creating new DrivingSystem
					$drivens[size($drivens)]=$checkObjAttr[$z];
					if (!`stringArrayCount $obj $drivenObjs`)
						$drivenObjs[size($drivenObjs)]=$obj;
					}
				if (`gmatch $checkObjAttr[$z] "*_L*[.]*"`)
					error ("Found modified values on the Left side ("+$checkObjAttr[$z]+"), Only modify Right side (or middle)");
				if (`gmatch $checkObjAttr[$z] "*Extra*[.]*"`)
					error ("Found modified values on the Extra controller, Only modify the Main controllers");
				}
			}
		}
	}
if (size($drivens)==0)
	error ("Found no driven attributes, all controls are in Build-Pose");

$buildPoseNode="buildPose";
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObjs[0]`)
		{
		$isFace=1;
		$buildPoseNode="faceBuildPose";
		}

$m="Create system to drive these attributes?\n\n";
for ($i=0;$i<size($drivens);$i++)
	{
	float $value=`getAttr $drivens[$i]`;
	$value=`asRoundOff $value 3`;
	$t="Create New";
	$m+=$drivens[$i]+" = "+$value+"\n";
	}


$asDSMessage=$m;

if (!$comeFromASBuild && !$isEditingExisting)
	{
	$dialogResult=`layoutDialog -t $t -ui asDsLayout`;
	if ($dialogResult!="OK")
		return;
	if (`objExists $asDSObjName`)
		{
		$tempString=`ls -l $asDSObjName`;
		if (!(`gmatch $tempString[0] "*DrivingSystem*"` || `gmatch $tempString[0] "*ctrlBox*"`))
			error ("Object \""+$asDSObjName+"\" already exists, choose a unique name.");
		}
	}

$side="_M";
for ($i=0;$i<size($drivenObjs);$i++)
	{
	if (`gmatch $drivenObjs[$i] "*_R"`) $side="_R";
	if (`gmatch $drivenObjs[$i] "*_L"`) $side="_L";
	if ($side!="_M") break;
	}
for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==-1 && !$asDSMirror)
		continue;
	if ($b==-1 && $side=="_M")
		continue;
	if      ($b==-1 && $side=="_R") {$side="_L";$oppositeSide="_R";}
	else if ($b==-1 && $side=="_L") {$side="_R";$oppositeSide="_L";}
	for ($i=0;$i<size($drivenObjs);$i++)
		if ($b==-1)
			{
			$drivenObjs[$i]=`substitute $oppositeSide $drivenObjs[$i] $side`;
			if (!`objExists $drivenObjs[$i]`)
				{
				print ("// \""+$drivenObjs[$i]+"\" not found, skipping mirroring.\n");
				$breakSideLoop=1;
				}
			}
	if ($breakSideLoop)
		continue;
	for ($i=0;$i<size($drivens);$i++)
		if ($b==-1)
			$drivens[$i]=`substitute $oppositeSide $drivens[$i] $side`;

	$controllerName=$asDSObjName;
	if (!`gmatch $controllerName "*_[A-Z]"`)
		$controllerName+=$side;
	if ($asDSObjName=="")
		for ($y=1;$y<99;$y++)
			{
			$controllerName="DrivingSystem"+$y+$side;
			if (!`objExists $controllerName`)
				break;
			}

	if ($b==1)
		$originalSideControllerName=$controllerName;
	if (`objExists $controllerName`) //use-existing-Control
		{
		$useExistingController=1;
		if ($b==-1) $controllerName=`substitute $oppositeSide $controllerName $side`;
		}
	else
		asDsCreateController $controllerName $drivenObjs;

	$attrName=$asDSAttrName;
	if ($attrName=="")
		for ($y=1;$y<99;$y++)
			{
			$attrName="driver"+$y;
			if (!`attributeExists $attrName $controllerName`)
				break;
			}

	if (!`attributeExists $attrName $controllerName`)
		{
		addAttr -k 1 -ln $attrName -at double $controllerName;
		if ($asDSAttrHasMin && $asDSAttrSoftLimits)
			addAttr -e -hasSoftMinValue 1 -softMinValue $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMin && !$asDSAttrSoftLimits)
			addAttr -e -min $asDSAttrMin ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && $asDSAttrSoftLimits)
			addAttr -e -hasSoftMaxValue 1 -softMaxValue $asDSAttrMax ($controllerName+"."+$attrName);
		if ($asDSAttrHasMax && !$asDSAttrSoftLimits)
			addAttr -e -max $asDSAttrMax ($controllerName+"."+$attrName);
		}
	else
		{
		$attrType=`getAttr -type ($controllerName+"."+$attrName)`;
		if (!`gmatch $attrType "double*"`)//not to set limits on xform attrs
			{
			if ($driverValue<0)
				addAttr -e -softMinValue $driverValue ($controllerName+"."+$attrName);
			else if ($driverValue>10)
				addAttr -e -softMaxValue $driverValue ($controllerName+"."+$attrName);
			}
		}

	if (!`getAttr -se ($controllerName+"."+$attrName)` && `gmatch $attrName "*_*"`)
		$blendedAttr=1;

	for ($i=0;$i<size($drivens);$i++)
		{
		tokenize $drivens[$i] "[.]" $tempString;
		$drivenAttr=$tempString[1];
		$drivenObj=$tempString[0];
		tokenize $drivenObj "_" $tempString;
//		$faceSDKs[$i]=$tempString[0]+"SDK_"+$tempString[1];
		$faceSDKs[$i]="SDK"+$drivenObj;
		if ($isFace)
			{
			$sdkDrivens[$i]=$faceSDKs[$i]+"."+$drivenAttr;
			}
		else
			{
			if ($drivenObj!=$tempString[0])//first attr in new obj
				{

				if (!`objExists ("SDK"+$drivenObj)`)
					asDsCreateSDKXform $drivenObj;
				$sdkDrivens[$i]="SDK"+$drivenObj+"."+$drivenAttr;
				}
			$sdkDrivens[$i]="SDK"+$drivenObj+"."+$drivenAttr;
			}

	if ($b==1)
			{
			$drivenValues[$i]=`getAttr $drivens[$i]`;
			if ($isFace)
				{
				if ($blendedAttr && !`gmatch $drivenAttr "s*"`)
					{
					//BlendedAttrs must first Remove the values that are Driven by the components (e.g. X & Y), to determine the Delta $drivenValue
					$blendedDrivers=`asGetBlendedDrivers $controllerName $attrName`;
					if (`gmatch $blendedDrivers[0] "*Mixed"`) $blendedDrivers[0]=`substitute "Mixed" $blendedDrivers[0] ""`;
					if (`gmatch $blendedDrivers[1] "*Mixed"`) $blendedDrivers[1]=`substitute "Mixed" $blendedDrivers[1] ""`;
					$blendedDriverValues=`asGetBlendedDriverValues $controllerName $attrName`;
					setAttr $blendedDrivers[0] $blendedDriverValues[0];
					$componentDrivenValue[0]=`getAttr ($faceSDKs[$i]+"."+$drivenAttr)`;
					setAttr $blendedDrivers[0] 0;
					setAttr $blendedDrivers[1] $blendedDriverValues[1];
					$componentDrivenValue[1]=`getAttr ($faceSDKs[$i]+"."+$drivenAttr)`;
					setAttr $blendedDrivers[1] 0;
					$drivenValues[$i]=$drivenValues[$i]-$componentDrivenValue[0]-$componentDrivenValue[1];
					}
				}
			}
		}

	if ($b==-1 && !$isFace)	//use asMirror to get mirrorValues
		{
		$restorePoseCmd=`asGetRestorePoseCmd`;
		if (`window -q -ex tempWindow`)
			deleteUI tempWindow;
		window tempWindow;
		columnLayout;
		optionMenu tempWindowOptionMenu;
			menuItem -l ":";
		text -l "ControlSet " tempWindowControlSetsText;
		optionVar -sv asMOSide "asMOSideR2L";
		optionVar -sv asMOSpace "asMOSpaceMain";
		optionVar -sv asMOAxis "asMOAxisX";
		optionVar -sv asMOSelOnly "asMOSelOnlyAll";
		if ($isFace)
			text -e -l "FaceControlSet " tempWindowControlSetsText;
		asMirror tempWindow;
		for ($i=0;$i<size($sdkDrivens);$i++)
			$drivenValues[$i]=`getAttr $drivens[$i]`;
		deleteUI tempWindow;
		eval($restorePoseCmd);
		}

	for ($i=0;$i<size($sdkDrivens);$i++)
		{
		$connectionAttrNames[$i]=$attrName;
		if ($controllerName=="ctrlPhonemes_M") //for ctrlPhonemes_M, changing $connectionAttrNames[$i] to include Jaw/Lip Multiplied
			{
			if (`gmatch $sdkDrivens[$i] "SDKJaw_M*"` || `gmatch $sdkDrivens[$i] "SDKCheek_*"`)
				$connectionAttrNames[$i]=$attrName+"JawMultiplied";
			else
				$connectionAttrNames[$i]=$attrName+"LipMultiplied";
			}
		//for ctrlMouthCorner_*, changing tx to txMixed
		if (`gmatch $controllerName "ctrlMouthCorner_*"` && $attrName=="tx") $connectionAttrNames[$i]="txMixed";
		if (`gmatch $controllerName "ctrlMouthCorner_*"` && $attrName=="ty") $connectionAttrNames[$i]="tyMixed";

		asEnsureBlendWeighted $sdkDrivens[$i];
		setDrivenKeyframe -itt "linear" -ott "linear" -v $drivenValues[$i] -dv $driverValue -cd ($controllerName+"."+$connectionAttrNames[$i]) $sdkDrivens[$i];
		}

	//then set the "Start" SDK keyframe
	$restorePoseCmd=`asGetRestorePoseCmd`;
	if ($isFace)
		asGoToBuildPose faceSetup;
	else
		asGoToBuildPose bodySetup;
	for ($i=0;$i<size($sdkDrivens);$i++)
		setDrivenKeyframe -itt "linear" -ott "linear" -v `getAttr $drivens[$i]` -dv 0 -cd ($controllerName+"."+$connectionAttrNames[$i]) $sdkDrivens[$i];
	for ($i=0;$i<size($sdkDrivens);$i++)
		setInfinity -pri cycleRelative -poi cycleRelative $sdkDrivens[$i];
	eval($restorePoseCmd);

	if (!$blendedAttr && !$isEditingExisting)
		setAttr -type "string" ($buildPoseNode+".udAttr") (`getAttr ($buildPoseNode+".udAttr")`+";setAttr "+$controllerName+"."+$attrName+" 0;");
	}

asEnsureSDKcurvesNamed;

//Check if any existing SDK has been `zero`d out, then remove the SDK curve
//To find a better solution for this, because currently this breaks ctrlMouth_M
$tempString=`listConnections -s 0 -d 1 -type animCurve ($originalSideControllerName+"."+$attrName)`;
for ($i=0;$i<size($tempString);$i++)
	{
	tokenize $tempString[$i] "_" $tempString2;
	$ctrl=`substring $tempString2[0] 4 99`+"_"+$tempString2[1];
	if (!`objExists $ctrl`)
		continue;
	if (`gmatch $ctrl "*_L"`)
		continue;	
	$inControlSet=$inFaceControlSet=0;
	if (`objExists ControlSet`) if (`sets -im ControlSet $ctrl`) $inControlSet=1;
	if (`objExists FaceControlSet`) if (`sets -im FaceControlSet $ctrl`) $inFaceControlSet=1;
	if (!$inControlSet && !$inFaceControlSet)
		continue;
	$att=$tempString2[2];
	while (`gmatch $att "*[0-9]"`)
		{
		$numChar=size($att);
		$att=`substring $att 1 ($numChar-1)`;
		}
	if (`attributeExists $att $ctrl`)
		if (`getAttr ($ctrl+"."+$att)`==0)
			{
			print ("// Found value of Zero, on \""+$ctrl+"\" , now removing this SDK\n");
			delete $tempString[$i];
			//and the Mirrored SDK
			$mirroredCtrl=`substitute "_R" $tempString[$i] "_L"`;
			if (`objExists $mirroredCtrl`)
				delete $mirroredCtrl;
			}
	}

select -cl;

if ($isFace)
	asGoToBuildPose faceSetup;
else
	asGoToBuildPose bodySetup;

if (!$useExistingController)
	asDsOptimizeControllers;

if (!$blendedAttr)
	setAttr ($originalSideControllerName+"."+$attrName) $driverValue;
else
	{
	setAttr $blendedDrivers[0] $blendedDriverValues[0];
	setAttr $blendedDrivers[1] $blendedDriverValues[1];
	}
select -cl;
print ("// Created DrivingSystem "+$originalSideControllerName+"."+$attrName+";\n");

if (!$asBuilding && !$asRebuilding)
	asDsToFitSkeleton;
}

global proc asDsAutoFindAndEdit ()
{
string $drivingSystems[]=`asDsGetDrivingSystems`;
string $drivingSystem="";
string $driveAttr="";
string $leftDrivingSystem;
float $driveValue=0;
for ($i=0;$i<size($drivingSystems);$i++)
	{
	$attrs=`asDsGetAttrs $drivingSystems[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		float $value=`getAttr ($drivingSystems[$i]+"."+$attrs[$y])`;
		$value=`asRoundOff $value 3`;
		if ($value!=0)
			{
			if (`gmatch $drivingSystems[$i] "*_L"`)
				error ("Found modified values on the Left side ("+$drivingSystems[$i]+"."+$attrs[$y]+"), Only modify Right side (or middle)");
			if ($drivingSystem!="")
				{
				//Adding BlendedAttribute ?
				if ($drivingSystem==$drivingSystems[$i] && $driveAttr=="tx" && $attrs[$y]=="ty")
					{
					$attrs[$y]=`asGetBlendedAttributeName {$drivingSystems[$i]+".tx",$drivingSystems[$i]+".ty"}`;
					if (!`attributeExists $attrs[$y] $drivingSystems[$i]`)
						{
						if (`confirmDialog -t "Multiple drivers found"
							-m "Create Blended Attribute from TX And TY ?"
							-b "OK" -b "Cancel" -db "Cancel"
							-ds "Cancel"`!="OK")
								return;
						$attrs[$y]=`asCreateBlendedAttribute {$drivingSystems[$i]+".tx",$drivingSystems[$i]+".ty"}`;
						}
					if (`objExists BlendedCorrectiveDriver`) delete BlendedCorrectiveDriver;
					if (`gmatch $drivingSystems[$i] "*_R"`)
						{
						//Add to Left side as well
						$leftDrivingSystem=`substitute "_R" $drivingSystems[$i] "_L"`;
						setAttr ($leftDrivingSystem+".tx") `getAttr ($drivingSystems[$i]+".tx")`;
						setAttr ($leftDrivingSystem+".ty") `getAttr ($drivingSystems[$i]+".ty")`;
						asCreateBlendedAttribute {$leftDrivingSystem+".tx",$leftDrivingSystem+".ty"};
						if (`objExists BlendedCorrectiveDriver`) delete BlendedCorrectiveDriver;
						setAttr ($leftDrivingSystem+".tx") 0;
						setAttr ($leftDrivingSystem+".ty") 0;
						}
					$value=1;
					}
				else
					error ("Found multiple driver values set: "+$drivingSystem+"."+$driveAttr+" AND "+$drivingSystems[$i]+"."+$attrs[$y]);
				}
			$drivingSystem=$drivingSystems[$i];
			$driveAttr=$attrs[$y];
			$driveValue=$value;
			if (`gmatch $driveAttr "*_*"` && !`getAttr -se ($drivingSystem+"."+$driveAttr)`)//BlendedAttribute, assuming other attribs are just contributing to this.
				break;
			}
		}
	}
if ($drivingSystem=="")
	warning "Either right click on this button to edit specific drive-values, or set a driver-value, and click the button";
else
	asDsEdit "Edit" $drivingSystem $driveAttr $driveValue;
}

global proc asDsEdit (string $action, string $obj, string $attr, float $value)
{
int $numDriven,$blendedAttr;
int $colorNr=16;
float $driver1Value,$driver2Value;
float $drivenValues[],$limits[];
string $stripName,$restoreParentCmd,$mpd,$setRange,$driver1,$driver2;
string $drivingAttr=$attr;
string $drivenObjs[],$drivenAttrs[],$drivenSdkNode[];
string $animCurves[],$tempString[],$tempString2[];

if (!`getAttr -se ($obj+"."+$attr)` && `gmatch $attr "*_*"`)
	$blendedAttr=1;

if ($obj=="ctrlMouth_M" && $attr=="tx")
	error ("// Can not set DrivingSystem from ctrlMouth_M.tx, use ctrlMouthCorner_R.tx instead.\n");

if ($blendedAttr)//BlendedAttribute
	{
	$tempString=`listConnections -s 1 -d 0 ($obj+"."+$attr)`;
	$mpd=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 ($mpd+".input1X")`;
	$setRange=$tempString[0];
	$tempString=`listConnections -s 1 -d 0 -p 1 ($setRange+".valueX")`;
	$driver1=$tempString[0];
	if (`gmatch $attr "*txPos*"`) $driver1Value=1;
	if (`gmatch $attr "*txNeg*"`) $driver1Value=-1;
//	$driver1Value=`getAttr ($setRange+".valueX")`;
	$tempString=`listConnections -s 1 -d 0 -p 1 ($setRange+".valueY")`;
	$driver2=$tempString[0];
	if (`gmatch $attr "*tyPos*"`) $driver2Value=1;
	if (`gmatch $attr "*tyNeg*"`) $driver2Value=-1;
//	$driver2Value=`getAttr ($setRange+".valueY")`;
	}

//check backwards compatibility
if (`attributeExists version Main`)
	if (`getAttr Main.version`<5.5925)
		error "AdvancedSkeleton rig version older then v5.5925 detected, You must first run \"Rebuild AdvancedSkeleton\", before editing DrivingSystems.";

if (`objExists ControlSet`) asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;

$animCurves=`asDsGetAnimCurves $obj $drivingAttr`;

if ($action=="Edit")
	{
	if (!$blendedAttr)
		setAttr ($obj+"."+$attr) $value;
	else
		{
		if (`gmatch $driver1 "*Mixed"`) setAttr `substitute "Mixed" $driver1 ""` $driver1Value;
		else setAttr $driver1 $driver1Value;
		if (`gmatch $driver2 "*Mixed"`) setAttr `substitute "Mixed" $driver2 ""` $driver2Value;
		else setAttr $driver2 $driver2Value;
		$tempString2=`listConnections -scn 1 -s 0 -d 1 $driver1`;
		$animCurves=`stringArrayCatenate $animCurves $tempString2`;
		$tempString2=`listConnections -scn 1 -s 0 -d 1 $driver2`;
		$animCurves=`stringArrayCatenate $animCurves $tempString2`;
		}

	if (`attributeQuery -n $obj -softRangeExists $attr`)
		$limits=`attributeQuery -n $obj -softRange $attr`;
	else if ($attr=="tx" || $attr=="ty" ||$attr=="tz")
		$limits=`eval ("transformLimits -q -"+$attr+" "+$obj)`;
	else if ($attr=="txPos_tyPos")
		$limits={-1,1};
	if ($limits[0]!=0 && $limits[1]!=0)
		{
		if ($value>0 && $value!=$limits[1]) $colorNr=13;
		if ($value<0 && $value!=$limits[0]) $colorNr=13;
		}
	}

for ($i=0;$i<size($animCurves);$i++)
	if (size(`ls -type animCurve $animCurves[$i]`))	
		{
		tokenize $animCurves[$i] "_" $tempString2;
		$drivenSdkNode[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenSdkNode[$numDriven]=$drivenSdkNode[$numDriven]+"_";
			}
		$stripName=`substring $animCurves[$i] 4 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		if (`gmatch $stripName "[0-9]*"`)
			$stripName=`substring $stripName 2 99`;
		tokenize $stripName "_" $tempString2;
		$drivenObjs[$numDriven]="";
		for ($y=0;$y<size($tempString2)-1;$y++)
			{
			$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+$tempString2[$y];
			if ($y<size($tempString2)-2)
				$drivenObjs[$numDriven]=$drivenObjs[$numDriven]+"_";
			}
		string $drivenAttr=$tempString2[size($tempString2)-1];
		for ($a=0;$a<3;$a++)
			if (`gmatch $drivenAttr "*[0-9]"`)
				{
				int $numChars=size($drivenAttr);
				$drivenAttr=`substring $drivenAttr 1 ($numChars-1)`;
				}
		$drivenAttrs[$numDriven]=$drivenAttr;
		$drivenValues[$numDriven]=`getAttr ($drivenSdkNode[$numDriven]+"."+$drivenAttrs[$numDriven])`;
		$numDriven++;
		}

if ($action=="Graph")
	{
	select `listConnections -s 0 -d 1 -scn 1 ($obj+"."+$drivingAttr)`;
	GraphEditor;
	return;
	}
if ($action=="Delete")
	{
	if (`objExists ControlSet`) asGoToBuildPose bodySetup;
	if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;
	refresh;
	delete `listConnections -s 0 -d 1 -scn 1 ($obj+"."+$drivingAttr)`;
	//remove attr
	catchQuiet (`deleteAttr ($obj+"."+$drivingAttr)`);
	asUpdatePoseAttributes;
	if (`objExists ControlSet`) asGoToBuildPose bodySetup;
	return;
	}

if (`objExists ControlSet`) asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;

if (`objExists SmilePullOffset_R`) setAttr SmilePullOffset_R.v 0;
if (`objExists SmilePullOffset_L`) setAttr SmilePullOffset_L.v 0;

for ($i=0;$i<size($drivenObjs);$i++)
	{
	if (`gmatch $drivenObjs[$i] "*_L"`)
		continue;
//	print ($drivenObjs[$i]+"."+$drivenAttrs[$i]+" "+$drivenValues[$i]+"\n");
	if (`getAttr -l ($drivenObjs[$i]+"."+$drivenAttrs[$i])`)
		continue;//v5.678 and before had SmilePull_R.tz as a DS, which is locked
	setAttr ($drivenObjs[$i]+"."+$drivenAttrs[$i]) $drivenValues[$i];
	if (`gmatch $drivenObjs[$i] "LipPull_*"` || `gmatch $drivenObjs[$i] "MouthNarrow_*"`)
		{
		tokenize $drivenObjs[$i] "_" $tempString;
		setAttr ($tempString[0]+"Offset_"+$tempString[1]+".v") 1;
		}
	}

if (`headsUpDisplay -q -ex HUDEDSMode`)
	headsUpDisplay -e -rem HUDEDSMode;
headsUpDisplay -s 2 -b 0 -bs "medium" -l ("Editing Driving System:  "+$obj+"."+$attr+"="+$value) -lfs "large" HUDEDSMode;
displayColor headsUpDisplayLabels $colorNr;
rowLayout -e -en 1 asDSEditChoicesRowLayout;
//setAttr ($obj+"."+$attr) $value;
}

global proc asDsEditCancel ()
{
if (`objExists LipPullOffset_R`) setAttr LipPullOffset_R.v 0;
if (`objExists LipPullOffset_L`) setAttr LipPullOffset_L.v 0;
if (`objExists SmilePullOffset_R`) setAttr SmilePullOffset_R.v 1;
if (`objExists SmilePullOffset_L`) setAttr SmilePullOffset_L.v 1;
if (`objExists MouthNarrowOffset_R`) setAttr MouthNarrowOffset_R.v 0;
if (`objExists MouthNarrowOffset_L`) setAttr MouthNarrowOffset_L.v 0;

if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	headsUpDisplay -e -rem HUDEDSMode;
	displayColor headsUpDisplayLabels 16;
	}
rowLayout -e -en 0 asDSEditChoicesRowLayout;
if (`objExists ControlSet`) asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`) asGoToBuildPose faceSetup;
}

global proc asDsEditApply ()
{
global int $asDSMirror;
$asDSMirror=1;

if (`objExists LipPullOffset_R`) setAttr LipPullOffset_R.v 0;
if (`objExists LipPullOffset_L`) setAttr LipPullOffset_L.v 0;
if (`objExists SmilePullOffset_R`) setAttr SmilePullOffset_R.v 1;
if (`objExists SmilePullOffset_L`) setAttr SmilePullOffset_L.v 1;
if (`objExists MouthNarrowOffset_R`) setAttr MouthNarrowOffset_R.v 0;
if (`objExists MouthNarrowOffset_L`) setAttr MouthNarrowOffset_L.v 0;

asDsCreate;
if (`headsUpDisplay -q -ex HUDEDSMode`)
	{
	headsUpDisplay -e -rem HUDEDSMode;
	displayColor headsUpDisplayLabels 16;
	}
rowLayout -e -en 0 asDSEditChoicesRowLayout;
}

global proc asDsSdk (string $driver, string $driven, float $driverValue, float $drivenValue)
{
float $startValue=0;
string $tempString[],$beforeSDKCurves[],$afterSDKCurves[];

if (`gmatch $driven "*[.]s[x-z]"`)
	$startValue=1;

$drivenValue=`asRoundOff $drivenValue 3`;
if ($drivenValue==$startValue)
	return;

string $blendWeighted=`asEnsureBlendWeighted $driven`;

//When blending Scales, all SDK`s except the first one, needs value of 1 removed
if (`gmatch $driven "*[.]s[x-z]"`)
	$tempString=`listConnections -s 1 -d 0 -scn 1 ($blendWeighted+".input")`;
		if (size($tempString))
			{
			$startValue=$startValue-1;
			$drivenValue=$drivenValue-1;
			}

$beforeSDKCurves=`listConnections -s 1 -d 0 -scn 1 -type animCurve
 ($blendWeighted+".input")`;
setDrivenKeyframe -itt "linear" -ott "linear" -dv 0 -v $startValue -cd $driver $driven;
setDrivenKeyframe -itt "linear" -ott "linear" -dv $driverValue -v $drivenValue -cd $driver $driven;

asEnsureSDKcurvesNamed;
$afterSDKCurves=`listConnections -s 1 -d 0 -scn 1 ($blendWeighted+".input")`;
for ($i=0;$i<size($afterSDKCurves);$i++)
	{
	if (`stringArrayCount $afterSDKCurves[$i] $beforeSDKCurves`)
		continue;
	setAttr ($afterSDKCurves[$i]+".preInfinity") 4;
	setAttr ($afterSDKCurves[$i]+".postInfinity") 4;
	}
}

global proc asDsLayout ()
{
global string $asDSMessage;
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAdvancedOptions;
string $tempString[];
string $blendedAttrs[]={"txPos_tyPos","txPos_tyNeg","txNeg_tyPos","txNeg_tyNeg"};
tokenize $asDSMessage "\n" $tempString;
int $maxTextLines=35;
if (size($tempString)>$maxTextLines)
	{
	$asDSMessage="";
	for ($i=0;$i<$maxTextLines;$i++)
		$asDSMessage+=$tempString[$i]+"\n";
	$asDSMessage+="...And "+(size($tempString)-$maxTextLines)+" more..";
	}
columnLayout -adj 0;
columnLayout -adj 0;
	text -l $asDSMessage;
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 1 asDSInputsColumnLayout;
	rowLayout -nc 3;
		text -w 100 -l "Attribute Name:";
		textField -w 80 asDSAttrNameTextField;
		setParent..;
	rowLayout -nc 3 asDSControlNameRowLayout;
		text -w 100 -l "Control Name:";
		textField -w 80 asDSObjNameTextField;
		setParent..;
	rowLayout -en 0 -nc 4 asDSUseControlRowLayout; 
	    separator -w 5 -st none;
	    checkBox -w 95 -l "Use Control:"
	    	-onc "optionMenu -e -en 1 asDSObjNameOptionMenu;rowLayout -e -en 0 asDSControlNameRowLayout;checkBox -e -en 0 asDSMirrorCheckBox;"
	    	-ofc "optionMenu -e -en 0 asDSObjNameOptionMenu;rowLayout -e -en 1 asDSControlNameRowLayout;checkBox -e -en 1 asDSMirrorCheckBox;"
	    	asDSUseControlCheckBox;
    	optionMenu -en 0 asDSObjNameOptionMenu;
		setParent..;

	if ($asDSAdvancedOptions)
		{
		separator;
		text -l "Attribute limits:";
		rowLayout -en 1 -nc 8;
			checkBox -w 40 -v 1 -l "min:" asDSAttrHasMin;
			floatField -w 30 -v 0 -pre 1 asDSAttrMin;
			separator -w 10 -st none;
			checkBox -w 40 -v 1 -l "max:" asDSAttrHasMax;
			floatField -w 30 -v 10 -pre 1 asDSAttrMax;
			setParent..;
		separator -h 5 -st none;
		checkBox -l "Use Soft limits" -v 1 asDSAttrSoftLimits;
		}
	separator -h 10 -st none;
	setParent..;
columnLayout -adj 0;
	rowLayout -nc 3 asDSMirrorRowLayout;
			text -w 100 -l "Mirror:";
    	checkBox -l "" -v 1 asDSMirrorCheckBox;
		setParent..;
	rowLayout -nc 4;
		separator -w 10 -st none;
		button -l "OK" -c "asDsGetName;layoutDialog -dismiss \"OK\";";
		separator -w 10 -st none;
		button -l "Cancel" -c "layoutDialog -dismiss \"Cancel\"";
		setParent..;
	setParent..;

//populate asDSObjNameOptionMenu
string $drivingSystems[]=`asDsGetDrivingSystems`;
if (size($drivingSystems))
	rowLayout -e -en 1 asDSUseControlRowLayout;
setParent -menu asDSObjNameOptionMenu;

//This proc also used by CreateNewBlendShape, then $drivingSystems are actuall faceCtrls
if ($asDSMessage=="Create New BlendShape")
	{
	clear $drivingSystems;
	if (`objExists ctrlBox`)
		{
		$tempString=`listRelatives -c -type transform ctrlBox`;
		for ($i=0;$i<size($tempString);$i++)
			$drivingSystems[$i]=`substitute "Box" $tempString[$i] ""`;
		}
	}

for ($i=0;$i<size($drivingSystems);$i++)
	{
	if (`gmatch $drivingSystems[$i] "*_L"`)
		continue;
	menuItem -l $drivingSystems[$i];
	}

//fill out fields if we are editing
if ($asDSObjName!="")
	{
	textField -e -ed 0 -tx $asDSAttrName asDSAttrNameTextField;
	rowLayout -e -en 0 asDSControlNameRowLayout;
	checkBox -e -en 1 -v 1 asDSUseControlCheckBox;
	optionMenu -e -en 1 -v $asDSObjName asDSObjNameOptionMenu;
	columnLayout -e -m 0 asDSInputsColumnLayout;

	string $oppositeObjName="";
	if (`gmatch $asDSObjName "*_R"`) $oppositeObjName=`substitute "_R" $asDSObjName "_L"`;
	if (`gmatch $asDSObjName "*_L"`) $oppositeObjName=`substitute "_L" $asDSObjName "_R"`;
	if (!`objExists $oppositeObjName`)
		{
		checkBox -e -v 0 asDSMirrorCheckBox;
		rowLayout -e -en 0 asDSMirrorRowLayout;
		}
	}
}

global proc string asDsCreateSDKXform (string $drivenObj)
{
string $tempString[]=`listRelatives -p $drivenObj`;
string $parent=$tempString[0];
string $child=$drivenObj;
int $isFace=0;
if (`objExists FaceControlSet`)
	if (`sets -im FaceControlSet $drivenObj`)
		$isFace=1;

string $sdkXform;
if (`gmatch $parent "*Extra*"`)
	{
	$child=$parent;
	$tempString=`listRelatives -p $parent`;
	$parent=$tempString[0];
	}

$sdkXform="SDK"+$drivenObj;
createNode -n $sdkXform -p $parent transform;
sets -add AllSet $sdkXform;
setAttr ($sdkXform+".rotateOrder") `getAttr ($drivenObj+".rotateOrder")`;
xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1;

parent $child $sdkXform;
return $sdkXform;
}

global proc string[] asDsGetDrivingSystems ()
{
int $sdkConnection;
string $drivingSystems[],$tempString[],$tempString2[],$attrs[];
if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
if (`objExists ctrlBox`)
	{
	$tempString=`listRelatives -ad -type transform ctrlBox`;
	for ($i=0;$i<size($tempString);$i++)
		{
		$sdkConnection=0;
//		if (`gmatch $tempString[$i] "ctrlBox*"`)
//			continue;
//		$attrs=`listAttr -m -k $tempString[$i]`;
		$attrs=`asDsGetAttrs $tempString[$i]`;
		for ($y=0;$y<size($attrs);$y++)
			{
			$tempString2=`listConnections -s 0 -d 1 -type animCurve ($tempString[$i]+"."+$attrs[$y])`;
			if (`gmatch $tempString2[0] "*SDK*"`)
				$sdkConnection=1;
			}
		if ($sdkConnection)
			$drivingSystems[size($drivingSystems)]=$tempString[$i];
		}
	}
if (!`stringArrayCount ctrlPhonemes_M $drivingSystems` && `objExists ctrlPhonemes_M`)
	$drivingSystems[size($drivingSystems)]="ctrlPhonemes_M";
return $drivingSystems;
}

global proc string[] asDsGetAttrs (string $drivingSystem)
{
int $isCtrlBox;
string $attrs[],$tempString[];
string $blendedAttrs[]={"txPos_tyPos","txPos_tyNeg","txNeg_tyPos","txNeg_tyNeg"};

$tempString=`ls -l $drivingSystem`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isCtrlBox=1;

if ($isCtrlBox)
	{
	$attrs[size($attrs)]="tx";
	$attrs[size($attrs)]="ty";

	$tempString=`listAttr -ud $drivingSystem`;
	for ($i=0;$i<size($tempString);$i++)
		if ($drivingSystem!="ctrlMouth_M")
			if (`getAttr -k ($drivingSystem+"."+$tempString[$i])` || `getAttr -cb ($drivingSystem+"."+$tempString[$i])`)
				$attrs[size($attrs)]=$tempString[$i];
	}
else
	$attrs=`listAttr -ud $drivingSystem`;

if ($drivingSystem=="ctrlPhonemes_M")
	{
	$attrs=`listAttr -k $drivingSystem`;
	$attrs=`stringArrayRemove {"multipliers","jaw","lip"} $attrs`;
	}
return $attrs;
}

global proc string[] asDsGetAnimCurves (string $drivingSystem, string $drivingAttr)
{
string $animCurves[],$tempString[],$pmas[];

$animCurves=`listConnections -scn 1 -s 0 -d 1 -type animCurve ($drivingSystem+"."+$drivingAttr)`;
if (`gmatch $drivingSystem "ctrlMouthCorner_*"` && `gmatch $drivingAttr "t[x-y]"`)
	$animCurves=`listConnections -scn 1 -s 0 -d 1 -type animCurve ($drivingSystem+"."+$drivingAttr+"Mixed")`;
if ($drivingSystem=="ctrlPhonemes_M")
	{
	$tempString=`listConnections -scn 1 -s 0 -d 1 -type animCurve ($drivingSystem+"."+$drivingAttr+"LipMultiplied")`;
	$animCurves=`stringArrayCatenate $animCurves $tempString`;
	$tempString=`listConnections -scn 1 -s 0 -d 1 -type animCurve ($drivingSystem+"."+$drivingAttr+"JawMultiplied")`;
	$animCurves=`stringArrayCatenate $animCurves $tempString`;
	}

return $animCurves;
}

global proc asDsGetName ()
{
global string $asDSAttrName;
global string $asDSObjName;
global int $asDSAttrHasMin;
global int $asDSAttrHasMax;
global int $asDSAttrSoftLimits;
global float $asDSAttrMin;
global float $asDSAttrMax;
global int $asDSMirror;
$asDSAttrName=`textField -q -tx asDSAttrNameTextField`;
if (`rowLayout -q -en asDSControlNameRowLayout`)
	$asDSObjName=`textField -q -tx asDSObjNameTextField`;
else
	$asDSObjName=`optionMenu -q -v asDSObjNameOptionMenu`;
$asDSAttrHasMin=1;
$asDSAttrHasMax=1;
$asDSAttrSoftLimits=1;
$asDSAttrMin=0;
$asDSAttrMax=10;
if (`checkBox -q -ex asDSAttrHasMin`) $asDSAttrHasMin=`checkBox -q -v asDSAttrHasMin`;
if (`checkBox -q -ex asDSAttrHasMax`) $asDSAttrHasMax=`checkBox -q -v asDSAttrHasMax`;
if (`checkBox -q -ex asDSAttrSoftLimits`) $asDSAttrSoftLimits=`checkBox -q -v asDSAttrSoftLimits`;
if (`floatField -q -ex asDSAttrMin`) $asDSAttrMin=`floatField -q -v asDSAttrMin`;
if (`floatField -q -ex asDSAttrMax`) $asDSAttrMax=`floatField -q -v asDSAttrMax`;
$asDSMirror=`checkBox -q -v asDSMirrorCheckBox`;
}

global proc string asEnsureBlendWeighted (string $sdkDriven)
{
int $isFaceControl;
string $obj,$attr,$blendWeighted;
string $tempString[];

tokenize $sdkDriven "." $tempString;
$obj=$tempString[0];
$attr=$tempString[1];

if ($attr=="tx") $attr="translateX";
if ($attr=="ty") $attr="translateY";
if ($attr=="tz") $attr="translateZ";
if ($attr=="rx") $attr="rotateX";
if ($attr=="ry") $attr="rotateY";
if ($attr=="rz") $attr="rotateZ";
if ($attr=="sx") $attr="scaleX";
if ($attr=="sy") $attr="scaleY";
if ($attr=="sz") $attr="scaleZ";

if (`objExists FaceAllSet`)
	if (`sets -im FaceAllSet $obj`)
		$isFaceControl=1;
if (`objExists FaceBuildingSets`)
	$isFaceControl=1;

$blendWeighted="bw"+`substitute "[.]" ($obj+"."+$attr) "_"`;
if (!`objExists $blendWeighted`)
	{
	createNode -n $blendWeighted blendWeighted;
	if ($isFaceControl)
		sets -add FaceAllSet $blendWeighted;
	else
		sets -add AllSet $blendWeighted;
	connectAttr -f ($blendWeighted+".output") ($obj+"."+$attr);
	}
return $blendWeighted;
}

global proc asEnsureSDKcurvesNamed ()
{
int $isFaceControl;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];
string $newName;

$tempString=`ls -type transform "*SDK*_*"`;
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`ls -l $tempString[$i]`;
	if (!`gmatch $tempString2[0] "*|MotionSystem|*"` && !`gmatch $tempString2[0] "*|FaceMotionSystem|*"`)
		continue;
	if (`gmatch $tempString2[0] "*|MotionSystem|*"`) $isFaceControl=0;
	if (`gmatch $tempString2[0] "*|FaceMotionSystem|*"`) $isFaceControl=1;

	$tempString2=`listConnections -scn 1 -s 1 -d 0 $tempString[$i]`;
	for ($y=0;$y<size($tempString2);$y++)
		{
		$tempString3=`listConnections -scn 1 -s 1 -d 0 $tempString2[$y]`;
		for ($z=0;$z<size($tempString3);$z++)
			{
			if (!`gmatch $tempString3[$z] "animCurve*"`)
				continue;
			$tempString4=`listConnections -scn 1 -p 1  -d 1 -s 0 ($tempString2[$y]+".output")`;
			$newName=`substitute "[.]" $tempString4[0] "_"`;
			rename $tempString3[$z] $newName;

			if ($isFaceControl && `objExists FaceAllSet`)
				sets -add FaceAllSet $newName;
			if (!$isFaceControl && `objExists AllSet`)
				sets -add AllSet $newName;
			}
		}
	}
}
	
global proc asDsOptimizeControllers ()
{
string $sel[]=`ls -sl`;
int $numChar;
float $dist,$maxDist;
float $pos[3],$pos2[3];
string $constraintTo,$deformJoint,$rlaChild,$endJoint;
string $tempString[],$animCurves[],$allDrivenObjs[],$allDrivenDeformJoints[],$longNames[],$parents[],$drivingSystems[];
createNode -n tempSamplerOffset transform;
createNode -n tempSampler -p tempSamplerOffset transform;

if (`objExists DrivingSystem`)
	$drivingSystems=`listRelatives -c DrivingSystem`;
for ($a=0;$a<size($drivingSystems);$a++)
	{
	$tempString=`listConnections -s 1 -d 0 ($drivingSystems[$a]+".tx")`;
	if ($tempString[0]!="" && `objectType $tempString[0]`=="parentConstraint")
		delete $tempString[0];
	asLockAttr $drivingSystems[$a] 0 0 0 1;

	//Find common ancestors
	clear $allDrivenDeformJoints;
	clear $longNames;
	$animCurves=`listConnections -s 0 -d 1 -type animCurve $drivingSystems[$a]`;	
	for ($i=0;$i<size($animCurves);$i++)
		{
		tokenize $animCurves[$i] "_" $tempString;
		$numChar=`size $animCurves[$i]` - `size($tempString[size($tempString)-1])` - 1;
		$allDrivenObjs[$i]=`substring $animCurves[$i] 4 $numChar`;
		if (`gmatch $allDrivenObjs[$i] "[0-9]*"`)
			$allDrivenObjs[$i]=`substring $allDrivenObjs[$i] 2 99`;
		$deformJoint=$allDrivenObjs[$i];
		if (`gmatch $allDrivenObjs[$i] "FK*"`)
			$deformJoint=`substitute "FK" $allDrivenObjs[$i] ""`;
		if (!`stringArrayCount $deformJoint $allDrivenDeformJoints`)
			$allDrivenDeformJoints[size($allDrivenDeformJoints)]=$deformJoint;
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$tempString=`ls -l $allDrivenDeformJoints[$i]`;
		$longNames[$i]=$tempString[0];
		select $drivingSystems[$a];
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "vector" -worldUpVector 0 1 0 $allDrivenDeformJoints[$i] $drivingSystems[$a];
		}
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		tokenize $longNames[$i] "|" $parents;
		for ($y=size($parents)-2;$y>-1;$y--)
			{
			$numOthersHaveThisParent=0;
			for ($z=0;$z<size($longNames);$z++)
			if (`gmatch $longNames[$z] ("*|"+$parents[$y]+"|*")`)
				$numOthersHaveThisParent++;
			if ($numOthersHaveThisParent==size($longNames))
				{
				$constraintTo=$parents[$y];
				$i=999;$y=-999;$z=999;
				}
			}
		}

	delete `parentConstraint $drivingSystems[$a] tempSamplerOffset`;
	$pos=`xform -q -ws -t $constraintTo`;
	$maxDist=0;
	for ($i=0;$i<size($allDrivenDeformJoints);$i++)
		{
		$endJoint=$allDrivenDeformJoints[$i];
		$rlaChild=`asRlaChild $allDrivenDeformJoints[$i]`;
		if ($rlaChild!="")
			$endJoint=$rlaChild;
		$pos2=`xform -q -ws -t $endJoint`;
		$dist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		if ($dist>$maxDist)
			$maxDist=$dist;
		delete `pointConstraint $endJoint tempSampler`;
		}
	if ($maxDist<0.01) $maxDist=0.5;

	delete `pointConstraint $constraintTo $drivingSystems[$a]`;
	if (`objExists ($drivingSystems[$a]+"_aimConstraint1")`)
		delete ($drivingSystems[$a]+"_aimConstraint1");
	parentConstraint -mo $constraintTo $drivingSystems[$a];
	setAttr -type float3 ($drivingSystems[$a]+".s") ($maxDist*1.2) ($maxDist*0.5) 1;
	asLockAttr $drivingSystems[$a] 1 1 1 1;
	}
if (`objExists tempSamplerOffset`)
	delete tempSamplerOffset;

select $sel;
}

global proc asDsCreateController (string $objName, string $drivenObjs[])
{
int $isChildOfOtherDriven;
string $tempString[],$tempString2[];
string $constraintTo="Root_M";

$tempString=`circle -n $objName -c 0 0 0 -nr 0 0 1 -sw 180 -r 1 -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0`;
$objName=$tempString[0];
scale -r -1 1 1 ($objName+".cv[0:10]");
sets -add AllSet $objName;
sets -add AllSet ($objName+"Shape");
sets -add ControlSet $objName;
setAttr ($objName+"Shape.overrideEnabled") 1;
setAttr ($objName+"Shape.overrideColor") 17;
if (!`objExists DrivingSystem`)
	{
	createNode -n DrivingSystem -p MotionSystem transform;
	connectAttr Main.drvSysVis DrivingSystem.v;
	sets -add AllSet DrivingSystem;
	}
parent $objName DrivingSystem;

string $deformJoint=$drivenObjs[0];
if (`gmatch $drivenObjs[0] "FK*"`)
$deformJoint=`substitute "FK" $drivenObjs[0] ""`;
if (`objExists $deformJoint`)
	$constraintTo=$deformJoint;
asAlign $objName $drivenObjs[0] 1 1 0 0;
string $rlaChild=`asRlaChild $deformJoint`;
if (`objExists $rlaChild`)
	{
	float $scale=`getAttr ($rlaChild+".tx")`;
	setAttr -type float3 ($objName+".s") $scale $scale $scale;
//	scale -r $scale $scale $scale ($objName+".cv[0:10]");
	}

string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`) asGoToBuildPose bodySetup;
//if (`objExists ($objName+"_pointConstraint1")`)
//	delete ($objName+"_pointConstraint1");
if (`objExists $constraintTo`)
	parentConstraint -mo $constraintTo $objName;
eval($restorePoseCmd);
asLockAttr $objName 1 1 1 1;
}

global proc asCreateAngleAttrs (string $joint)
{
string $sel[]=`ls -sl`;
string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
float $charHeight=`asgetCharHeight`;
int $sideFactor=1;
if (`gmatch $joint "*_L"`)
	$sideFactor=-1;
string $FKjoint=$joint;
if (`objExists ("FK"+$joint)`)
	$FKjoint="FK"+$joint;
string $XYZ[]={"X","Y","Z"};
string $xyz[]={"x","y","z"};
string $RGB[]={"R","G","B"};
string $posNegs[]={"Pos","Neg"};
for ($i=0;$i<size($XYZ);$i++)
	{
	addAttr -k 1 -ln ("angle"+$XYZ[$i]) -at double $joint;
	addAttr -k 0 -ln ("angle"+$XYZ[$i]) -at double $FKjoint;
	setAttr -e -channelBox true ("FK"+$joint+".angle"+$XYZ[$i]);
	connectAttr -f ($joint+".angle"+$XYZ[$i]) ($FKjoint+".angle"+$XYZ[$i]);
	}
if (!`objExists AngleSystem`)
	{
	createNode -n AngleSystem -p MotionSystem transform;
	setAttr AngleSystem.inheritsTransform 0;
	}

string $tempString[]=`listRelatives -p $joint`;
string $parent=$tempString[0];

createNode -n ($joint+"AngleSamplerBaseParent") -p AngleSystem transform;
createNode -n ($joint+"AngleSamplerBase") -p ($joint+"AngleSamplerBaseParent") transform;
pointConstraint $parent ($joint+"AngleSamplerBaseParent");
orientConstraint $parent ($joint+"AngleSamplerBaseParent");
delete `orientConstraint $joint ($joint+"AngleSamplerBase")`;
pointConstraint $joint ($joint+"AngleSamplerBase");

for ($i=1;$i<size($XYZ);$i++)
	for ($y=0;$y<size($posNegs);$y++)
		{
		string $loc=$joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y];
		spaceLocator -n $loc;
		parent $loc ($joint+"AngleSamplerBase");
		setAttr -type float3 ($loc+".t") 0 0 0;
		setAttr -type float3 ($loc+".r") 0 0 0;
		setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
		}
setAttr ($joint+"AngleSamplerYPos.tz") ($sideFactor*-1*0.7071104);
setAttr ($joint+"AngleSamplerYNeg.tz") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZPos.ty") ($sideFactor*0.7071104);
setAttr ($joint+"AngleSamplerZNeg.ty") ($sideFactor*-1*0.7071104);

createNode -n ($joint+"AngleSamplerRotate") -p ($joint+"AngleSamplerBase") transform;
orientConstraint $joint ($joint+"AngleSamplerRotate");

string $loc=$joint+"AngleSamplerEnd";
spaceLocator -n $loc;
parent $loc ($joint+"AngleSamplerRotate");
setAttr -type float3 ($loc+".t") ($sideFactor*0.7071104) 0 0;
setAttr -type float3 ($loc+".r") 0 0 0;
setAttr -type float3 ($loc+"Shape.localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);

for ($y=0;$y<size($posNegs);$y++)
	{
	createNode -n ($joint+"OneMinus"+$posNegs[$y]) plusMinusAverage;
	setAttr ($joint+"OneMinus"+$posNegs[$y]+".operation") 2;
	setAttr -type float3 ($joint+"OneMinus"+$posNegs[$y]+".input3D[0]") 1 1 1;
	}
//Y & Z
for ($i=1;$i<size($XYZ);$i++)
	{
	for ($y=0;$y<size($posNegs);$y++)
		{
		createNode -n ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]) distanceBetween;
		connectAttr -f ($joint+"AngleSampler"+$XYZ[$i]+$posNegs[$y]+"Shape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point1");
		connectAttr -f ($joint+"AngleSamplerEndShape.worldPosition[0]") ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".point2");
		connectAttr -f ($joint+"Distance"+$XYZ[$i]+$posNegs[$y]+".distance") ($joint+"OneMinus"+$posNegs[$y]+".input3D[1].input3D"+$xyz[$i]);
		}
	createNode -n ($joint+"AngleCondition"+$XYZ[$i]) condition;
	setAttr ($joint+"AngleCondition"+$XYZ[$i]+".operation") 2;
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".firstTerm");
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".secondTerm");
	connectAttr -f ($joint+"OneMinusPos.output3D"+$xyz[$i]) ($joint+"AngleCondition"+$XYZ[$i]+".colorIfTrue"+$RGB[$i]);
	createNode -n ($joint+"AngleInverse"+$XYZ[$i]) unitConversion;
	setAttr ($joint+"AngleInverse"+$XYZ[$i]+".conversionFactor") -1;
	connectAttr -f ($joint+"OneMinusNeg.output3D"+$xyz[$i]) ($joint+"AngleInverse"+$XYZ[$i]+".input");
	connectAttr -f ($joint+"AngleInverse"+$XYZ[$i]+".output") ($joint+"AngleCondition"+$XYZ[$i]+".colorIfFalse"+$RGB[$i]);
	connectAttr -f ($joint+"AngleCondition"+$XYZ[$i]+".outColor.outColor"+$RGB[$i]) ($joint+".angle"+$XYZ[$i]);
	}
//X
createNode -n ($joint+"AngleXMultiplyDivide") multiplyDivide;
setAttr ($joint+"AngleXMultiplyDivide.operation") 2;
setAttr -type float3 ($joint+"AngleXMultiplyDivide.input2") 90 1 1;
if (`objExists ("TwistBalancer"+$joint)`) // tapping into existing twist system
	connectAttr -f ("TwistBalancer"+$joint+".rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
else // create twist deriver
	{
	select ($joint+"AngleSamplerBase");
	joint -n ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXUnTwistEnd");
	setAttr ($joint+"AngleXUnTwistEnd.tx") ($charHeight/12.0*$sideFactor);
	select ($joint+"AngleXUnTwist");
	joint -n ($joint+"AngleXBalancer");
	orientConstraint -mo ($joint) ($joint+"AngleXBalancer");
	ikHandle -n ($joint+"AngleXUnTwistIK") -ns 2 -sol "ikRPsolver" -sj ($joint+"AngleXUnTwist") -ee ($joint+"AngleXUnTwistEnd");
	parent ($joint+"AngleXUnTwistIK") ($joint+"AngleSamplerBase");
	parentConstraint -mo $joint ($joint+"AngleXUnTwistIK");
	createNode -n ($joint+"AngleXUnTwistPoleVec") -p ($joint+"AngleSamplerBase") transform;
	poleVectorConstraint ($joint+"AngleXUnTwistPoleVec") ($joint+"AngleXUnTwistIK");
	connectAttr -f ($joint+"AngleXBalancer.rx") ($joint+"AngleXMultiplyDivide.input1.input1X");
	}
connectAttr ($joint+"AngleXMultiplyDivide.output.outputX") ($joint+".angleX");

setAttr -l 1 ($joint+"AngleSamplerBaseParent.v") 0;
eval($restorePoseCmd);
select $sel;
}

global proc string asGetBlendedAttributeName (string $drivers[])
{
string $tempString[],$driverObjs[],$driverAttrs[];
string $attr;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];
	$attr+=$driverAttrs[$i];
	if (`getAttr $drivers[$i]`>=0)
		$attr+="Pos";
	else
		$attr+="Neg";
	if ($i<size($drivers)-1)
		$attr+="_";
	}
return $attr;
}

global proc string asCreateBlendedAttribute (string $drivers[])
{
string $sel[]=`ls -sl`;
string $tempString[],$driverObjs[],$driverAttrs[];
string $setAnglesCmd;
string $attr=`asGetBlendedAttributeName $drivers`;
for ($i=0;$i<size($drivers);$i++)
	{
	tokenize $drivers[$i] "[.]" $tempString;
	$driverObjs[$i]=$tempString[0];
	$driverAttrs[$i]=$tempString[1];

	$tempString[0]="FK"+`substitute "angle" $drivers[$i] "rotate"`;
	if (`objExists $tempString[0]`)
		$setAnglesCmd+="setAttr "+$tempString[0]+" "+`getAttr $tempString[0]`+";";
	}

createNode -n BlendedCorrectiveDriver transform;
addAttr -ln driverObj -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverObj $driverObjs[0];
addAttr -ln driverAttr -dt "string" BlendedCorrectiveDriver;
setAttr -type "string" BlendedCorrectiveDriver.driverAttr $attr;

if (`attributeExists $attr $driverObjs[0]`)
	{
	select $sel;
	return $attr;
	}

addAttr -k 0 -ln $attr -at double $driverObjs[0];
setAttr -e -channelBox true ($driverObjs[0]+"."+$attr);
if (!`gmatch $driverObjs[0] "FK*"` && `objExists ("FK"+$driverObjs[0])`)
	{
	addAttr -k 0 -ln $attr -at double ("FK"+$driverObjs[0]);
	setAttr -e -channelBox true ("FK"+$driverObjs[0]+"."+$attr);
	connectAttr ($driverObjs[0]+"."+$attr) ("FK"+$driverObjs[0]+"."+$attr);
	}

string $mpd,$sr;
string $previousOutput=$driverObjs[0]+"."+$driverAttrs[0];
for ($i=1;$i<size($drivers);$i++)
	{
	$sr=$driverObjs[0]+$attr+"SetRange"+$i;
	$mpd=$driverObjs[0]+$attr+"MultiplyDivide"+$i;
	createNode -n $sr setRange;

	connectAttr -f $previousOutput ($sr+".valueX");
	connectAttr -f ($driverObjs[$i]+"."+$driverAttrs[$i]) ($sr+".valueY");
	setAttr -type float3 ($sr+".max") 1 1 1;
	setAttr ($sr+".oldMaxX") `getAttr ($sr+".valueX")`;
	setAttr ($sr+".oldMaxY") `getAttr ($sr+".valueY")`;
	addAttr -k 1 -ln dvX -at double -dv `getAttr ($sr+".valueX")` $sr;
	addAttr -k 1 -ln dvY -at double -dv `getAttr ($sr+".valueY")` $sr;

	createNode -n $mpd multiplyDivide;
	connectAttr ($sr+".outValueX") ($mpd+".input1.input1X");
	connectAttr ($sr+".outValueY") ($mpd+".input2.input2X");
	if (`getAttr ($sr+".valueX")`<0)	//reverse negative numbers X
		{
		setAttr ($sr+".minX") 1;
		setAttr ($sr+".maxX") 0;
		setAttr ($sr+".oldMinX") (`getAttr ($sr+".oldMaxX")`);
		setAttr ($sr+".oldMaxX") 0;
		}
	if (`getAttr ($sr+".valueY")`<0)	//reverse negative numbers Y
		{
		setAttr ($sr+".minY") 1;
		setAttr ($sr+".maxY") 0;
		setAttr ($sr+".oldMinY") (`getAttr ($sr+".oldMaxY")`);
		setAttr ($sr+".oldMaxY") 0;
		}
	if ($i==(size($drivers))-1)
		{
		addAttr -ln setAnglesCmd -dt "string" $mpd;
		setAttr -type "string" ($mpd+".setAnglesCmd") $setAnglesCmd;
		}
	$previousOutput=($mpd+".outputX");

	}
connectAttr -f $previousOutput ($driverObjs[0]+"."+$attr);
select $sel;
return $attr;
}

global proc string[] asSetBlendedAttribute (string $driverObj, string $driverAttr, float $value, int $getDriversMode)
{
string $tempString[],$drivers[];
string $setAnglesCmd;
int $connectedToMultDiv=1;
string $plug=$driverObj+"."+$driverAttr;
float $dvs[];
while ($connectedToMultDiv)
	{
	$connectedToMultDiv=0;
	$tempString=`listConnections -s 1 -d 0 -scn 1 $plug`;
	string $nodeA=$tempString[0];
	if(size($tempString)>0)
		{
		if (`objectType $nodeA`=="multiplyDivide")
			{
			$connectedToMultDiv=1;
			$plug=$nodeA+".input1.input1X";
			if (`attributeExists setAnglesCmd $nodeA`)
				$setAnglesCmd=`getAttr ($nodeA+".setAnglesCmd")`;
			}
		else if (`objectType $nodeA`=="setRange")
			{
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueY")`;
			$drivers[size($drivers)]=$tempString[0];
			$dvs[size($dvs)]=`getAttr ($nodeA+".dvY")`;
			
			$tempString=`listConnections -s 1 -d 0 -p 0 -scn 1 ($nodeA+".valueX")`;
			string $nodeB=$tempString[0];
			$tempString=`listConnections -s 1 -d 0 -p 1 -scn 1 ($nodeA+".valueX")`;
			if (`objectType $nodeB`=="multiplyDivide")
				{
				$connectedToMultDiv=1;
				$plug=$nodeA+".valueX";
				}
			else
				{
				$drivers[size($drivers)]=$tempString[0];
				$dvs[size($dvs)]=`getAttr ($nodeA+".dvX")`;
				}
			}
		}
	
	}

//For inbetweens, just find the values were all inputs are equal, and sum up to total
if ($value<1)
	for ($i=0;$i<size($dvs);$i++)
		{
		float $temp=`pow $dvs[$i] 2`;
		$dvs[$i]=`sqrt($temp*$value)`;
		}

for ($i=0;$i<size($drivers);$i++)
	if (!$getDriversMode)
		{
		string $setDriver=$drivers[$i];
		if (`gmatch $setDriver "*[.]angle*"`)// blended angles
			eval $setAnglesCmd;
		else
			{
			string $FKDriver="FK"+$drivers[$i];
			if (`objExists $FKDriver`)
				$setDriver=$FKDriver;
			setAttr $setDriver $dvs[$i];
			}
		}
$drivers=`sort $drivers`;
return $drivers;
}

global proc string asCreateCorrectiveShape ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl -o`;
string $tempString[],$tempString2[];
if(size($sel)==0)
	error "No mesh selected, select geometry on your character";
if (size($sel)>1)
	error "More than 1 object selected, Only 1 object must be selected";
if (`gmatch $sel[0] "*__*"`)
	error "Selected object IS a Corrective Shape. Select geometry on your character";
if ($sel[0]!="")
	if (`objectType $sel[0]`=="mesh")
		$sel=`listRelatives -p $sel[0]`;
$tempString=`listRelatives -ni -s $sel[0]`;
if ($tempString[0]=="")
	error "Selected Object is not geometry";
if (`objectType $tempString[0]`!="mesh")
	error "Selected object is not a mesh";

string $controlSetMembers[];
if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;

//string $tr[]={"t","r"};
//string $xyz[]={"x","y","z"};
string $drivers[],$keyableAttr[];
string $objAttr;
float $poseValue,$currentValue;
//Find driving attribute(s)
string $buildPoseCmds[],$runCmds[];
//get $buildPoseCmds
if (`objExists ControlSet`)
	$buildPoseCmds[0]=`getAttr buildPose.udAttr`;
if (`objExists FaceControlSet`)
	$buildPoseCmds[1]=`getAttr faceBuildPose.udAttr`;
//get $runCmds
if (`objExists FitSkeleton`)
	if (`attributeExists run FitSkeleton`)
		{
		$runCmds[0]=`getAttr FitSkeleton.run`;
		$runCmds[0]=`substituteAllString $runCmds[0] "\"" ""`;
		}
if (`objExists FaceFitSkeleton`)
	if (`attributeExists run FaceFitSkeleton`)
		{
		$runCmds[1]=`getAttr FaceFitSkeleton.run`;
		$runCmds[1]=`substituteAllString $runCmds[1] "\"" ""`;
		}
string $runObjAttrs[],$checkObjAttr[];
float $runValues[];
for ($a=0;$a<2;$a++)
	{
	tokenize $runCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		$runObjAttrs[size($runObjAttrs)]=$tempString2[1];
		$runValues[size($runValues)]=$tempString2[2];
		}
	}
for ($a=0;$a<2;$a++)
	{
	tokenize $buildPoseCmds[$a] ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		tokenize $tempString[$i] $tempString2;
		int $loopTimes=0;
		if ($tempString2[0]=="setAttr")
			{
			$objAttr=$tempString2[1];
			$poseValue=$tempString2[2];
			$loopTimes=1;
			$checkObjAttr[0]=$objAttr;
			}
		else if ($tempString2[0]=="xform")
			{
			$loopTimes=9;
			$obj=$tempString2[size($tempString2)-1];
			$checkObjAttr[0]=$obj+".translateX";$checkObjAttr[1]=$obj+".translateY";$checkObjAttr[2]=$obj+".translateZ";
			$checkObjAttr[3]=$obj+".rotateX";$checkObjAttr[4]=$obj+".rotateY";$checkObjAttr[5]=$obj+".rotateZ";
			$checkObjAttr[6]=$obj+".scaleX";$checkObjAttr[7]=$obj+".scaleY";$checkObjAttr[8]=$obj+".scaleZ";
			$poseValue=0;
			}
		for ($z=0;$z<$loopTimes;$z++)
			{
			$currentValue=`getAttr $checkObjAttr[$z]`;
			if($z>5) $poseValue=1;//scale
			//actual poseValue might come from the run attribute//
			for ($y=0;$y<size($runObjAttrs);$y++)
				if ($checkObjAttr[$z]==$runObjAttrs[$y])
					$poseValue=$runValues[$y];

			if (`gmatch $checkObjAttr[$z] "FKExtra*"`)//must filter FKExtraJaw_M & FKExtraEye_*, so just filter all Extra
				continue;
			if (`gmatch $checkObjAttr[$z] "FKIK*"`)//filter FKIK* as this might be just to get to FK.
				continue;
			if($poseValue>($currentValue+0.001) || $poseValue<($currentValue-0.001))
				$drivers[size($drivers)]=$checkObjAttr[$z];
			}
		}
	}
if (size($drivers)==0)
	error ("Found no driving attribute, all values are in Build-Pose");

//For twistDistributed limbs, if not using "Angle", then rx is not excepted, neighter is any mix
if (!`checkBox -q -v asCorrectiveAngleCheckBox`)
	{
	if (`gmatch $drivers[0] "*[.]rotateX"` || `size($drivers)`>1)
		{
		tokenize $drivers[0] "[.]" $tempString;
		int $numChar=size($tempString[0]);
		string $fitJoint=`substring $tempString[0] 3 ($numChar-2)`;
		if (`objExists $fitJoint`)
			if (`attributeExists twistJoints $fitJoint` || `attributeExists inbetweenJoints $fitJoint`)
				{
				warning "Due to \"twistJoints\" or \"inbetweenJoints\" beeing used, rotation values will not work, Now turning On \"Angle\" rotations.";
				checkBox -e -v 1 asCorrectiveAngleCheckBox;
				asCreateCorrectiveShape;
				return "";
				}
		}
	}

for ($i=0;$i<size($drivers);$i++)
	{
	string $nonFKDriver=`substitute "FK" $drivers[$i] ""`;
	if (`objExists $nonFKDriver`)
//		if (!`gmatch $drivers[0] "FK*[.]translate*"`) //(FK*.t* dont have zero default values)
			$drivers[$i]=$nonFKDriver;
	}

tokenize $drivers[0] "[.]" $tempString;
string $deformObj=$sel[0];
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $directDriverAttr=$driverAttr;
float $dv=`getAttr $drivers[0]`;
float $idv=0;

//angle driver
if (`checkBox -q -v asCorrectiveAngleCheckBox`)
	if (`gmatch $driverAttr "r*"`)//rotation && !blended
		{
		if (!`attributeExists "angleX" $driverObj`)
			asCreateAngleAttrs $driverObj;

		//Max 90 degrees
		float $FKdv=`getAttr ("FK"+$drivers[0])`;
		if (abs($FKdv)>90)
			{
			warning ("Angle rotation more than 90 degrees, now reducing rotation to 90.");
			if ($dv>0) $dv=90;
			if ($dv<0) $dv=-90;
			setAttr ("FK"+$drivers[0]) $dv;
			}
		for ($i=0;$i<size($drivers);$i++)
			{
			if (`gmatch $drivers[$i] "*[.]rotate*"`)
				{
				$drivers[$i]=`substitute "rotate" $drivers[$i] "angle"`;
				$driverAttr=`substitute "rotate" $driverAttr "angle"`;
				}
			$idv=$dv;
			$dv=`getAttr ($driverObj+"."+$driverAttr)`;
			if (`gmatch $driverAttr "*X"` && `objExists ("TwistBalancer"+$driverObj)`)
				{
				//$idv special case if RX from a twist-system
				$idv=`getAttr ("TwistBalancer"+$driverObj+"."+$directDriverAttr)`;
				}
			}
		//2 rotation attributes could be translated to 3 angle attributes
		string $XYZ[]={"X","Y","Z"};
		if (size($drivers)>1)
			for ($i=0;$i<size($drivers);$i++)
				{
				for ($y=0;$y<size($XYZ);$y++)
					{
					string $check=$driverObj+".angle"+$XYZ[$y];
					float $checkVal=`getAttr $check`;
					if (abs($checkVal)>0.001)
						if (!`stringArrayCount $check $drivers`)
							{
							$drivers[size($drivers)]=$check;
							$drivers=`sort $drivers`;
							}
					}
				}
		}

if (size($drivers)>1)
	{
	//We might have arrived back here from already created blendAttr
	if (`objExists BlendedCorrectiveDriver`)
		{
		$driverObj=`getAttr BlendedCorrectiveDriver.driverObj`;
		$driverAttr=`getAttr BlendedCorrectiveDriver.driverAttr`;
		$dv=`getAttr ($driverObj+"."+$driverAttr)`;
		}
	else
		{
		string $m="Create Corrective Shape from blend of these drivers?\n\n";
		for ($i=0;$i<size($drivers);$i++)
			{
			float $value=`getAttr $drivers[$i]`;
			$value=`asRoundOff $value 3`;
			$m+=$drivers[$i]+" = "+$value+"\n";
			}
		if (!$asSkipConfirm)
			if (`confirmDialog -t "Multiple Drivers Found"
				-m $m
				-b "OK" -b "Cancel" -db "Cancel"
				-ds "Cancel"`!="OK")
					return "";
		asCreateBlendedAttribute $drivers;
		asCreateCorrectiveShape;
		return "";
		}
	}

string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
$dv=`asRoundOff $dv 3`;

float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr+"__"+$posNeg;

if (size($drivers)==1 && !$asSkipConfirm)
	{
	string $dialog=`confirmDialog -t "Single Driver Found"
		-m ("Create Corrective Shape from this driver?\n\n"+$driverObj+"."+$driverAttr+" = "+$dv)
		-b "OK" -b "Cancel" -db "Cancel"
		-ds "Cancel"`;
	if ($dialog!="OK")
		return "";
	}

asCorrectiveDuplicate $attrCode $sel[0];

addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;

return $attrCode;
}

global proc float asCorrectiveGetIV (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
float $iv=1;
string $bs=$deformObj+"Corrective";
if (!`objExists $bs`)
	return 1;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
float $maxKeyVal;
string $weights[]=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount ($driverObj+"__"+$driverAttr+"__"+$posNeg) $weights`)
	{
	$tempString=`listConnections ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
	float $keyXValues[]=`keyframe -q -fc $tempString[0]`;
	float $keyYValues[]=`keyframe -q -vc $tempString[0]`;
	float $xvalueAtOneY=$keyXValues[size($keyXValues)-1];
	for ($i=0;$i<size($keyYValues);$i++)
		if ($keyYValues[$i]==1)
			$xvalueAtOneY=$keyXValues[$i];

	$iv=$dv/$xvalueAtOneY;
	$iv=`asRoundOff $iv 3`;
	}
return $iv;
}

global proc asCorrectiveDuplicate (string $attrCode, string $source)
{
float $charHeight=`asgetCharHeight`;
string $tempString[];
if ($source=="FaceCorrective")
	{
	$tempString=`listConnections FaceCorrective.originalDeformObj`;
	duplicate -n $attrCode $tempString[0];
	}
else
	duplicate -n $attrCode $source;
asLockAttr $attrCode 0 0 0 0;
setAttr ($attrCode+".v") 1;
$tempString=`listRelatives -p $attrCode`;
if ($tempString[0]!="")
	parent -w $attrCode;
$tempString=`listRelatives -f -s $attrCode`;
for ($i=0;$i<size($tempString);$i++)
	if (`objectType $tempString[$i]`=="mesh")
		if (`getAttr ($tempString[$i]+".intermediateObject")`)
			delete $tempString[$i];
$tempString=`listRelatives -f -s $attrCode`;
rename $tempString[0] ($attrCode+"Shape");

rowLayout -e -en 1 asCorrectiveEditChoicesRowLayout;
button -e -en 0 asCreateCorrectiveButton;
button -e -en 0 asEditCorrectiveButton;
button -e -en 0 asDeleteCorrectiveButton;
button -e -en 0 asGraphCorrectiveButton;
string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 0;

$tempString=`ls -sl -l $source`;
if (!`gmatch $tempString[0] "|Group|*"`)
	{
	setAttr ($source+".v") 0;
	if (!`attributeExists "correctiveShapeModeHidden" $group`)
		addAttr -ln "correctiveShapeModeHidden" -dt "string" $group;
	setAttr -type "string" ($group+".correctiveShapeModeHidden") $source;
	}

//setAttr ($attrCode+".tx") ($charHeight*0.5);
select $attrCode;
SculptGeometryTool;

headsUpDisplay -s 2 -b 0 -bs "medium" -l "Corrective Shape Mode" -lfs "large" HUDCSMMode;
scriptJob -runOnce true -e deleteAll "asExitCorrectiveShapeMode";
scriptJob -runOnce true -nodeDeleted $attrCode "asExitCorrectiveShapeMode";
}

global proc asConnectCorrectiveShape ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
string $tempString[],$history[],$existingTargets[];
if (size($sel)<1)
	error "Select the Corrective Shape";
if (`gmatch $sel[0] "*[.]*"`)
	$sel=`ls -sl -o`;
if (`objectType $sel[0]`!="transform")
	{
	$tempString=`listRelatives -p $sel[0]`;
	$sel[0]=$tempString[0];
	}
if (size($sel)!=1)
	error "Select only the Corrective Shape";
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
string $restoreCmds[];
tokenize `substituteAllString $sel[0] "__"  "|"` "|" $tempString;
string $deformObj=$tempString[0];
string $driverObj=$tempString[1];
string $driverAttr=$tempString[2];
string $originalDeformObj=$deformObj;
if ($originalDeformObj=="FaceCorrective")
	{
	$tempString=`listConnections FaceCorrective.originalDeformObj`;
	$originalDeformObj=$tempString[0];
	}
float $dv=`getAttr ($sel[0]+".driverValue")`;
float $idv=`getAttr ($sel[0]+".indirectDriverValue")`;
string $posNeg="pos";
if ($dv<0)
	$posNeg="neg";
if (`gmatch $driverAttr "*_*"`)
	$posNeg="pos"; // blended attrs are always pos
float $iv=`getAttr ($sel[0]+".inbetweenValue")`;
int $deleteMode=`objExists DeleteCorrectiveShape`;
string $deltaShape=$driverObj+"__"+$driverAttr+"__"+$posNeg;
string $sdk=$deformObj+"Corrective_"+$deltaShape;
float $keyXValues[];
if (`objExists $sdk`)
	$keyXValues=`keyframe -q -fc $sdk`;
if ($sel[0]==$deformObj)
	error "Can not use itself as Corrective Shape, Select the Corrective Shape";
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

int $isJoystick=0;
$tempString=`ls -l $driverObj`;
if (`gmatch $tempString[0] "*|ctrlBox|*"`)
	$isJoystick=1;
float $mirrorDv=$dv;
string $mirrorPosNeg=$posNeg;
if (($driverAttr=="translateX" && !$isJoystick) || (`gmatch $driverObj "FK*"` && `gmatch $driverAttr "translate*"`))
	{
	$mirrorDv=$dv*-1;
	if ($posNeg=="pos") $mirrorPosNeg="neg";
	if ($posNeg=="neg") $mirrorPosNeg="pos";
	}
int $doMirror=0;
string $mirrorDriverObj,$FKMirrorDriverObj,$mirrorDeltaShape,$mirrorSdk;
string $side="_R";
string $mirrorDriverAttr=$driverAttr;
string $mirrorSide="_L";
if (`gmatch $driverObj "*_L"`)
	{
	$side="_L";
	$mirrorSide="_R";
	}

if (`checkBox -q -v asCorrectiveMirrorCheckBox`)
	{
	$mirrorDriverObj=`substitute $side $driverObj $mirrorSide`;
	$FKMirrorDriverObj=`substitute $side $FKDriverObj $mirrorSide`;
	$mirrorDeltaShape=`substitute $side $deltaShape $mirrorSide`;
	if ($mirrorPosNeg!=$posNeg)
		$mirrorDeltaShape=`substitute $posNeg $mirrorDeltaShape $mirrorPosNeg`;
	$mirrorSdk=`substitute $side $sdk $mirrorSide`;

	if (`objExists $mirrorDriverObj` && $driverObj!=$mirrorDriverObj)
		{
		$doMirror=1;
		//angle attrs
		if (`gmatch $driverAttr "angle*"`)
			if (!`attributeExists "angleX" $mirrorDriverObj`)
				asCreateAngleAttrs $mirrorDriverObj;
		//blended attrs
		if (`gmatch $driverAttr "*_*"`)
			{
			string $drivers[]=`asSetBlendedAttribute $driverObj $driverAttr 0 1`;
			string $mirroredDrivers[];
			float $driverValues[],$mirroredDriverValues[],$rotates[];
			for ($i=0;$i<size($drivers);$i++)
				{
				$driverValues[$i]=`getAttr $drivers[$i]`;
				$mirroredDriverValues[$i]=$driverValues[$i];
				$mirroredDrivers[$i]=`substitute $side $drivers[$i] $mirrorSide`;
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						$rotates=`getAttr ($FKDriverObj+".r")`;
						setAttr -type float3 ($FKDriverObj+".r") 0 0 0;
						}
					}
				else
					setAttr $drivers[$i] 0;
				if ((`gmatch $mirroredDrivers[$i] "*[.]translateX"` && !$isJoystick) || (`objExists ("FK"+$driverObj)` && `gmatch $mirroredDrivers[$i] "*[.]translate*"`))
					$mirroredDriverValues[$i]=$driverValues[$i]*-1;
				//temporary mirror blended pose
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						setAttr -type float3 ($FKMirrorDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
					}
				else
					setAttr $mirroredDrivers[$i] $mirroredDriverValues[$i];
				}
			//asCreateBlendedAttribute
			$mirrorDriverAttr=`asCreateBlendedAttribute $mirroredDrivers`;
			$mirrorDeltaShape=$mirrorDriverObj+"__"+$mirrorDriverAttr+"__pos";
			//restore blended pose
			for ($i=0;$i<size($drivers);$i++)
				{
				if (`gmatch $driverAttr "angle*"`) //blended angle driver
					{
					if ($i==0)//Only need to run this on 1st pass of loop
						{
						setAttr -type float3 ($FKMirrorDriverObj+".r") 0 0 0;
						setAttr -type float3 ($FKDriverObj+".r") $rotates[0] $rotates[1] $rotates[2];
						}
					}
				else
					{
					setAttr $mirroredDrivers[$i] 0;
					setAttr $drivers[$i] $driverValues[$i];					
					}
				}
			}
		}
	}

$history=`listHistory $deformObj`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			{
			setAttr ($history[$i]+".envelope") 0;
			$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
			}

//If Corrective on mesh that have "asFaceBS", then create separate "Corrective" mesh
$history=`listHistory $deformObj`;
if (`stringArrayCount asFaceBS $history`)
	{
	if (!`objExists FaceCorrective`)
		{
		duplicate -n FaceCorrective $deformObj;
		$existingTargets=`listAttr -m asFaceBS.w`;
		blendShape -e -t $deformObj `size($existingTargets)` FaceCorrective 1 asFaceBS;
		setAttr asFaceBS.FaceCorrective 1;
		addAttr -longName originalDeformObj -attributeType message FaceCorrective;
		connectAttr ($deformObj+".message") FaceCorrective.originalDeformObj;
		$originalDeformObj=$deformObj;
		}
	$deformObj="FaceCorrective";
	}

duplicate -n $deltaShape $deformObj;
asLockAttr $deltaShape 0 0 0 0;
$tempString=`listRelatives -p $deltaShape`;
if ($tempString[0]!="")
	parent -w $deltaShape;

addAttr -k 1 -ln driverValue -at double -dv $dv $deltaShape;
addAttr -k 1 -ln inbetweenValue -at double -dv $iv $deltaShape;
if($doMirror && !$deleteMode)
	{
	duplicate -n $mirrorDeltaShape $deformObj;
	asLockAttr $mirrorDeltaShape 0 0 0 0;
	$tempString=`listRelatives -p $mirrorDeltaShape`;
	if ($tempString[0]!="")
		parent -w $mirrorDeltaShape;
	addAttr -k 1 -ln driverValue -at double -dv $mirrorDv $mirrorDeltaShape;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $mirrorDeltaShape;
	}

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

//Inverse shapes from other deformers
//if (`gmatch $driverAttr "*_*"` && `objExists ($deformObj+"Corrective")`)
duplicate -n ($deltaShape+"_componentReverse") $originalDeformObj;
$tempString=`listRelatives -p ($deltaShape+"_componentReverse")`;
if ($tempString[0]!="")
	parent -w ($deltaShape+"_componentReverse");
select $sel[0] $originalDeformObj ($deltaShape+"_componentReverse");
blendShape -n ($deltaShape+"_componentReverseBS") -frontOfChain -w 0 1 -w 1 1;

$history=`listHistory $deformObj`;
string $weights[];
if (`objExists ($deformObj+"Corrective.w")`)
	$weights=`listAttr -m ($deformObj+"Corrective.w")`;
for ($i=0;$i<size($history);$i++)
	if (`attributeExists envelope $history[$i]`)
		if (`getAttr ($history[$i]+".envelope")`)
			if ($history[$i]==($deformObj+"Corrective"))
				if (`gmatch $driverAttr "*_*"`)
					for ($y=0;$y<size($weights);$y++)
						{
						if ($weights[$y]!=$deltaShape)
							setAttr ($deformObj+"Corrective."+$weights[$y]) 0;
						}

select ($deltaShape+"_componentReverse");
DeleteHistory;
select ($deltaShape+"_componentReverse") $sel[0];
blendShape -n ($deltaShape+"_componentReverseBS2") -frontOfChain -w 0 1;
select $sel[0];

DeleteHistory;
for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);
delete ($deltaShape+"_componentReverse");

//Restore bsTargets that were rest to Zero, by dgdirty. SDK`s will ensure restore.
dgdirty -a;
//eval ($resetTargetsRestoreCmd);

select $deltaShape $deformObj;
asCorrectiveConnectBS;

$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
	setAttr ($deformObj+"Corrective."+$deltaShape) 1;

int $incOnce,$numVtxMoved;
int $numVtxs[]=`polyEvaluate -v $deltaShape`;
float $mag,$prevMag,$move;
float $tol=0.001;
float $selPos[]=`xform -q -ws -t $sel[0]`;
float $deformPos[]=`xform -q -ws -t $deformObj`;
xform -ws -t $deformPos[0] $deformPos[1] $deformPos[2] $sel[0];
float $posA[3],$posA2[3],$posB[3],$temp[3];
string $xyz[]={"x","y","z"};

//get current FKIK blend values
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
string $restoreFKIKCmds[];
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`gmatch $controlSetMembers[$i] "FKIK*_*"`)
		if (`attributeExists FKIKBlend $controlSetMembers[$i]`)
			$restoreFKIKCmds[size($restoreFKIKCmds)]="setAttr "+$controlSetMembers[$i]+".FKIKBlend "+`getAttr ($controlSetMembers[$i]+".FKIKBlend")`+";";

string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

float $zv=`getAttr ($driverObj+"."+$driverAttr)`;
$zv=`asRoundOff $zv 3`;
float $mirrorZv;
if($doMirror)
	{
	$mirrorZv=`getAttr ($mirrorDriverObj+"."+$mirrorDriverAttr)`;
	$mirrorZv=`asRoundOff $mirrorZv 3`;
	}

//restore all FKIK blend values as berfore GoToBuildPose, since we might have changed to FK to do corrective
for ($i=0;$i<size($restoreFKIKCmds);$i++)
	eval ($restoreFKIKCmds[$i]);

eval($restorePoseCmd);
dgdirty -a;

//Go to `Corrective` Pose, (not guranteed to already be in this pose, specially if editing Existing target)
//asGoToCorrectivePose $driverObj $driverAttr $dv;
//refresh;

$tempString=`listRelatives -f -s $deformObj`;
string $preDeformMesh;
for ($i=0;$i<size($tempString);$i++)
	if (`getAttr ($tempString[$i]+".intermediateObject")`)
		$preDeformMesh=$tempString[$i];

//matrix loop utilities
float $xPoint[],$yPoint[],$zPoint[],$newPos[];
createNode -n correctiveMatrixUtilities transform;
createNode -n matrix2xform parentConstraint;
createNode -n matrix2scale scaleConstraint;
createNode -n invMReaderOffset transform;
addAttr -ln theMatrix -dt "matrix" invMReaderOffset;
createNode -n invMReader -p invMReaderOffset transform;
createNode -n invMNewPos -p invMReader transform;
createNode -n defOffset transform;
createNode -n corPos -p defOffset transform;
connectAttr -f corPos.translate invMNewPos.translate;
connectAttr -f corPos.rotate invMNewPos.rotate;
connectAttr -f corPos.scale invMNewPos.scale;
//invMReaderOffset.theMatrix to matrixInverter.xform
createNode -n matrixInverter transform;
createNode -n matrix2xform2 parentConstraint;
createNode -n matrix2scale2 scaleConstraint;
connectAttr invMReaderOffset.theMatrix  matrix2xform2.target[0].targetParentMatrix;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateX matrixInverter.translate.translateX;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateY matrixInverter.translate.translateY;
connectAttr matrix2xform2.constraintTranslate.constraintTranslateZ matrixInverter.translate.translateZ;
connectAttr matrix2xform2.constraintRotate.constraintRotateX matrixInverter.rotate.rotateX;
connectAttr matrix2xform2.constraintRotate.constraintRotateY matrixInverter.rotate.rotateY;
connectAttr matrix2xform2.constraintRotate.constraintRotateZ matrixInverter.rotate.rotateZ;
connectAttr invMReaderOffset.theMatrix matrix2scale2.target[0].targetParentMatrix;
connectAttr matrix2scale2.constraintScale matrixInverter.scale;
//matrixInverter.inverseMatrix to invMReader.xform
connectAttr matrixInverter.inverseMatrix matrix2xform.target[0].targetParentMatrix;
connectAttr matrix2xform.constraintTranslate.constraintTranslateX invMReader.translate.translateX;
connectAttr matrix2xform.constraintTranslate.constraintTranslateY invMReader.translate.translateY;
connectAttr matrix2xform.constraintTranslate.constraintTranslateZ invMReader.translate.translateZ;
connectAttr matrix2xform.constraintRotate.constraintRotateX invMReader.rotate.rotateX;
connectAttr matrix2xform.constraintRotate.constraintRotateY invMReader.rotate.rotateY;
connectAttr matrix2xform.constraintRotate.constraintRotateZ invMReader.rotate.rotateZ;
connectAttr matrixInverter.inverseMatrix matrix2scale.target[0].targetParentMatrix;
connectAttr matrix2scale.constraintScale invMReader.scale;
parent matrix2xform matrix2scale invMReaderOffset defOffset matrixInverter matrix2xform2 matrix2scale2 correctiveMatrixUtilities;
//setAttr ($deformObj+"Corrective.envelope") 0;

//Existing blendShape nodes causes a inverse (&multiplied) deformation, so envelope off these.
$history=`listHistory $deformObj`;
clear $restoreCmds;
string $bsNodes[];
string $skinCluster;
for ($i=0;$i<size($history);$i++)
	{
	if (`objectType $history[$i]`=="skinCluster" && $skinCluster=="")
		$skinCluster=$history[$i];
// Removed at 5.576: && $history[$i]!="asFaceBS"
	if (`objectType $history[$i]`=="blendShape")
		{
		setAttr ($history[$i]+".envelope") 0;
		$restoreCmds[size($restoreCmds)]="setAttr "+$history[$i]+".envelope 1;";
		}
	}

//Make sure the corrective is the first BS before the skinCluster
catchQuiet (`reorderDeformers $skinCluster ($deformObj+"Corrective") $deformObj`);
//And before "asFaceBS" // removed at v5.562 .. nope, brought back again.
if (`objExists "asFaceBS"`)
	catchQuiet (`reorderDeformers "asFaceBS" ($deformObj+"Corrective") $deformObj`);

//xyz Offsets`s
move -r 1 0 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n xOffsetts $originalDeformObj;
move -r -1 1 0 ($preDeformMesh+".vtx[0:999999]");
duplicate -n yOffsetts $originalDeformObj;
move -r 0 -1 1 ($preDeformMesh+".vtx[0:999999]");
duplicate -n zOffsetts $originalDeformObj;
move -r 0 0 -1 ($preDeformMesh+".vtx[0:999999]");
asLockAttr xOffsetts 0 0 0 0;
asLockAttr yOffsetts 0 0 0 0;
asLockAttr zOffsetts 0 0 0 0;
parent xOffsetts yOffsetts zOffsetts correctiveMatrixUtilities;

progressBar -e -st ("Computing Delta Shape") -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
for ($i=0;$i<$numVtxs[0];$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{
		progressBar -e -ep $gMainProgressBar;
		xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
		blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
		delete $deltaShape;
		if (`objExists $mirrorDeltaShape`)
			delete $mirrorDeltaShape;
		delete correctiveMatrixUtilities;
		select $sel[0];
		print ("// Corrective Shape Cancelled	\n");
		return;
		}
	if ($deleteMode)
		break;
	progressBar -e -s 1 $gMainProgressBar;

	$posA=`xform -q -ws -t ($originalDeformObj+".vtx["+$i+"]")`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;

	if (abs($posA[0]-$posB[0])<$tol && abs($posA[1]-$posB[1])<$tol && abs($posA[2]-$posB[2])<$tol)
		continue;

	$numVtxMoved++;

	//inverseMatrix
	float $nonDefPos[]=`xform -q -ws -t ($preDeformMesh+".vtx["+$i+"]")`;
	float $defPos[]=`xform -q -ws -t ($originalDeformObj+".vtx["+$i+"]")`;
	float $corPos[]=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;

	xform -ws -t $nonDefPos[0] $nonDefPos[1] $nonDefPos[2] invMReaderOffset;

	xform -ws -t $defPos[0] $defPos[1] $defPos[2] defOffset;
	xform -ws -t $corPos[0] $corPos[1] $corPos[2] corPos;

	$xPoint=`xform -q -ws -t ("xOffsetts.vtx["+$i+"]")`;
	$yPoint=`xform -q -ws -t ("yOffsetts.vtx["+$i+"]")`;
	$zPoint=`xform -q -ws -t ("zOffsetts.vtx["+$i+"]")`;

	setAttr -type "matrix" invMReaderOffset.theMatrix 
	($xPoint[0]-$defPos[0]) ($xPoint[1]-$defPos[1]) ($xPoint[2]-$defPos[2]) 0
	($yPoint[0]-$defPos[0]) ($yPoint[1]-$defPos[1]) ($yPoint[2]-$defPos[2]) 0
	($zPoint[0]-$defPos[0]) ($zPoint[1]-$defPos[1]) ($zPoint[2]-$defPos[2]) 0
	0 0 0 1;

	$newPos=`xform -q -ws -t invMNewPos`;
	xform -ws -t $newPos[0] $newPos[1] $newPos[2] ($deltaShape+".vtx["+$i+"]");
	}
progressBar -e -ep $gMainProgressBar;

//setAttr ($deformObj+"Corrective.envelope") 1;
delete correctiveMatrixUtilities;
xform -ws -t $selPos[0] $selPos[1] $selPos[2] $sel[0];
print ("//Calculated "+$numVtxMoved+" vtx for deltashape\n");

for ($i=0;$i<size($restoreCmds);$i++)
	eval ($restoreCmds[$i]);

if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;
eval($restorePoseCmd);
dgdirty -a;

if($doMirror && !$deleteMode)
	{
	createNode -n ($deltaShape+"MirrorGroup") transform;
	parent $deltaShape ($deltaShape+"MirrorGroup");
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	duplicate -n ($mirrorDeltaShape+"Default") $mirrorDeltaShape;
	select ($mirrorDeltaShape+"Default") $deltaShape;
	blendShape -n tempMirrorCorrectiveBS -frontOfChain;
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 1;
	select $mirrorDeltaShape $deltaShape;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	setAttr ("tempMirrorCorrectiveBS."+$mirrorDeltaShape+"Default") 0;
	select $mirrorDeltaShape;
	DeleteHistory;
	delete ($mirrorDeltaShape+"Default");
	select $mirrorDeltaShape $deformObj;
	asCorrectiveConnectBS;
	scale -r -1 1 1 -p 0 0 0 ($deltaShape+"MirrorGroup");
	}
if ($deleteMode)
	{
	$existingTargets=`listAttr -m ($deformObj+"Corrective.w")`;
	print ("deleting "+$deltaShape+", (inbetweenValue="+$iv+", value="+$dv+")\n");
	blendShape -e -tc 0 -rm -t $deformObj 1 $deltaShape 1 ($deformObj+"Corrective");
	selectKey -add -k -f $dv $sdk;
	cutKey -animation keys -clear;
	}

delete $deltaShape;
delete $sel[0];
if($doMirror && !$deleteMode)
	delete $mirrorDeltaShape ($deltaShape+"MirrorGroup");
if ($deleteMode)
	delete DeleteCorrectiveShape;
$weights=`listAttr -m ($deformObj+"Corrective.w")`;
if ($iv<1)
	;//print ("Inbetweener..skipping SDK..\n");
if ($iv==1) //SDK for inbetweens not done here
	if (`stringArrayCount $deltaShape $weights`) //does not exist for inbetween shapes
		{
		if (`objExists $sdk`) if (size($keyXValues)<2) delete $sdk;
		setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv $zv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv $dv -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$deltaShape);
		if($doMirror && !$deleteMode)
			{
			if (`objExists $mirrorSdk`) {float $mirrorKeyValues[]=`keyframe -q -fc $mirrorSdk`;if (size($mirrorKeyValues)<2) delete $mirrorSdk;}
			setDrivenKeyframe -itt "linear" -ott "linear" -v 0 -dv $mirrorZv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			setDrivenKeyframe -itt "linear" -ott "linear" -v 1 -dv $mirrorDv -cd ($mirrorDriverObj+"."+$mirrorDriverAttr) ($deformObj+"Corrective."+$mirrorDeltaShape);
			}
		}

if (`objExists BlendedCorrectiveDriver`)
	delete BlendedCorrectiveDriver;


string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	
setAttr ($group+".v") 1;
asExitCorrectiveShapeMode;
autoKeyframe -state $autoKeyframe;
if ($originalDeformObj!="FaceCorrective")
	select $originalDeformObj;
setToolTo $gSelect;
}

global proc asCancelCorrectiveShape ()
{
global string $gSelect;
string $tempString[];
string $rootLevelObjects[]=`ls -as`;
for ($i=0;$i<size($rootLevelObjects);$i++)
	if (`attributeExists driverValue $rootLevelObjects[$i]`)
		{
		delete $rootLevelObjects[$i];
		tokenize $rootLevelObjects[$i] "_" $tempString;
		if (`objExists $tempString[0]`)
			if ($tempString[0]!="FaceCorrective")
				select $tempString[0];
		}
if (`objExists "Group"`)
	setAttr "Group.v" 1;
asExitCorrectiveShapeMode;
setToolTo $gSelect;
}

global proc asExitCorrectiveShapeMode ()
{
//setAttr "Group.v" 1; crashes maya :(
rowLayout -e -en 0 asCorrectiveEditChoicesRowLayout;
button -e -en 1 asCreateCorrectiveButton;
button -e -en 1 asEditCorrectiveButton;
button -e -en 1 asDeleteCorrectiveButton;
button -e -en 1 asGraphCorrectiveButton;

string $group="Group";
if (!`objExists "Group"`) if (`objExists FaceGroup`) $group="FaceGroup";	

if (`attributeExists "correctiveShapeModeHidden" $group`)
	if (`getAttr ($group+".correctiveShapeModeHidden")`!="FaceCorrective")
		setAttr (`getAttr ($group+".correctiveShapeModeHidden")`+".v") 1;
if (`headsUpDisplay -q -ex HUDCSMMode`)
	headsUpDisplay -rem HUDCSMMode;
}

global proc asCorrectiveConnectBS ()
{
int $numLetters;
string $sel[]=`ls -sl`;
string $deltaShape=$sel[0];
string $deformObj=$sel[1];
string $tempString[];
tokenize `substituteAllString $deltaShape "__"  "|"` "|" $tempString;
string $driverObj=$tempString[0];
string $driverAttr=$tempString[1];
string $posNeg="pos";
if (`getAttr ($deltaShape+".driverValue")`<0)
	$posNeg="neg";
float $iv=`getAttr ($deltaShape+".inbetweenValue")`;
int $existingTargetNr=-1;
if (`objExists ($deformObj+"Corrective")`) //BSnode Exists (Adding Target to BS node)
	{
	int $inputTargetGroups[]=`getAttr -mi ($deformObj+"Corrective.inputTarget[0].inputTargetGroup")`;
	string $existingTargets[]=`listAttr -m ($deformObj+"Corrective.w")`;
	for ($i=0;$i<size($existingTargets);$i++)
		{
		if ($existingTargets[$i]==$deltaShape)
			$existingTargetNr=$i;
		}
	if ($existingTargetNr!=-1 && $iv==1) // BSnode and BStarget Exists (Replacing target)
		{
		print ("// Replacing BlendShape Target\n");
		connectAttr -f ($deltaShape+".worldMesh[0]") ($deformObj+"Corrective.inputTarget[0].inputTargetGroup["+$inputTargetGroups[$existingTargetNr]+"].inputTargetItem[6000].inputGeomTarget");
		}
	else if ($iv<1 || $iv>1) // BSnode and `similar` target Exists (This must be a inbetween target)
		{
		print ("// connecting inbeween shape at: "+$iv+" for targetNr: "+$existingTargetNr+"\n");
		blendShape -e -inBetween -t $deformObj $inputTargetGroups[$existingTargetNr] $deltaShape $iv ($deformObj+"Corrective");
		//add a key, so this inbeween can be extracted
		setDrivenKeyframe -v $iv -dv `getAttr ($deltaShape+".driverValue")` -cd ($driverObj+"."+$driverAttr) ($deformObj+"Corrective."+$driverObj+"__"+$driverAttr+"__"+$posNeg);
		}
	else
		{
		print ("// Creating New BlendShape\n");
		//Somtimes Maya errors: "Specified blendShape not found in history...";
		print ("blendShape -e -t "+$deformObj+" "+`size($existingTargets)`+" "+$deltaShape+" 1 "+$deformObj+"Corrective;\n");
		blendShape -e -t $deformObj `size($existingTargets)` $deltaShape 1 ($deformObj+"Corrective");
		}
	}
else
	{
	blendShape -n ($deformObj+"Corrective") -frontOfChain;
//	$tempString=`listConnections ($deformObj+"Corrective.outputGeometry[0]")`;
//	rename $tempString[0] ($deformObj+"PB");
	}
}

global proc asPopulateCorrectivePopupMenu (string $action)
{
string $popupMenu="as"+$action+"CorrectiveShapesPopupMenu";
string $existingMenuItems[]=`popupMenu -q -ia $popupMenu`;
for ($item in $existingMenuItems)
	deleteUI $item;
string $correctiveBS[]=`ls -r 1 -type blendShape "*Corrective"`;
int $menuExisted,$en;
float $keyXValues[],$keyYValues[];
string $label,$menu,$lev1Menu,$lev2Menu,$lev3Menu,$lev4Menu,$lev5Menu;
string $weights[],$tempString[],$menu2s[],$menu3s[],$menu4s[];
string $menu2Label,$prevMenu2Label,$menu3Label,$prevMenu3Label,$menu4Label,$prevMenu4Label;
for ($i=0;$i<size($correctiveBS);$i++)
	{
	string $deformObj=`substitute "Corrective" $correctiveBS[$i] ""`;
	setParent -menu $popupMenu;
	$sm=1;
	if ($action=="Graph")
		$sm=0;
	$lev1Menu=`menuItem -sm $sm -l $deformObj`;
	if ($action=="Graph")
		{
		menuItem -e -c ("select "+$correctiveBS[$i]+";GraphEditor;") $lev1Menu;
		continue;
		}
	$weights=`listAttr -m ($correctiveBS[$i]+".w")`;
	$weights=`sort $weights`;
	for ($y=0;$y<size($weights);$y++)
		{
		tokenize `substituteAllString $weights[$y] "__"  "|"` "|" $tempString;
		string $driverObj=$tempString[0];
		string $driverAttr=$tempString[1];
		string $posNeg=$tempString[2];
		setParent -menu $lev1Menu;

		//$menu2s
		$prevMenu2Label=$menu2Label;
		$menu2Label=$driverObj;
		if ($menu2Label==$prevMenu2Label)//Re-use
			setParent -menu $lev2Menu;
		else
			{
			setParent -menu $lev1Menu;
			$lev2Menu=`menuItem -sm 1 -l $menu2Label`;
			}
	
		//$menu3s
		$prevMenu3Label=$menu3Label;
		$menu3Label=$driverAttr;
		if ($menu3Label==$prevMenu3Label && $menu2Label==$prevMenu2Label)//Re-use
			setParent -menu $lev3Menu;
		else
			{
			setParent -menu $lev2Menu;
			$lev3Menu=`menuItem -sm 1 -l $menu3Label`;
			}

		//$menu4s
		$prevMenu4Label=$menu4Label;
		$menu4Label=$posNeg;
//		if ($menu4Label==$prevMenu4Label)//Re-use
//			setParent -menu $lev4Menu;
//		else
			{
			setParent -menu $lev3Menu;
			$lev4Menu=`menuItem -sm 1 -l $menu4Label`;
			}

		$sdk=`listConnections ($correctiveBS[$i]+"."+$driverObj+"__"+$driverAttr+"__"+$posNeg)`;
		$keyXValues=`keyframe -q -fc $sdk`;
		$keyYValues=`keyframe -q -vc $sdk`;
		$haveKeyAtOne=0;
		for ($z=0;$z<size($keyYValues);$z++)
			if ($keyYValues[$z]==1)
				$haveKeyAtOne=1;
		if (!$haveKeyAtOne)
			warning "Found No keys at with \"Y\" value of 1, Unable to determine which shape is not a inbetween";
		float $smallestKeyXValue=99;
		for ($z=0;$z<size($keyXValues);$z++)
			if (abs($keyXValues[$z])<$smallestKeyXValue)
				$smallestKeyXValue=abs($keyXValues[$z]);
		for ($z=0;$z<size($keyXValues);$z++)
			{
			if (($keyXValues[$z]>=0 && $keyXValues[$z]==$smallestKeyXValue) || ($keyXValues[$z]<0 && $keyXValues[$z]==-1*$smallestKeyXValue))
				continue;
			float $roundFactor;
			if ($keyXValues[$z]>0) $roundFactor=0.5;
			else $roundFactor=-0.5;
			$keyXValues[$z]=(trunc($keyXValues[$z]*`pow 10 3`+$roundFactor)/`pow 10 3`); //round to precition of 3
			$cmd="";
			if ($action=="Delete")
				$cmd="createNode -n DeleteCorrectiveShape transform;";
			if ($action=="Edit" || $action=="Delete")
				$cmd+="asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" \""+$keyXValues[$z]+"\" ";
			if ($action=="Delete")
				$cmd+=";asConnectCorrectiveShape;";
			$en=1;
			$label=$keyXValues[$z];
			if ($action=="Delete")
				if ($keyYValues[$z]==1 && size($keyXValues)>2)
//				if (($keyXValues[$z]>0 && size($keyXValues)>2 && $z==size($keyXValues)-1)
//				 || ($keyXValues[$z]<0 && size($keyXValues)>2 && $z==0))
					$en=0;
//			if (($keyXValues[$z]>0 && $z<size($keyXValues)-1) || ($keyXValues[$z]<0 && $z>0))
			if ($keyYValues[$z]!=1)
				$label+=" (inbtw)";
			setParent -menu $lev4Menu;
			menuItem -en $en -l $label -c $cmd;
			}
		}
	}
}

global proc float asSetRotationFromAngle (string $driverObj, string $driverAttr, float $dv)
{
//Dont set `mix` values
if (`gmatch $driverAttr "*_*"`)
	return 1;
string $XYZ=`substitute "angle" $driverAttr ""`;
float $a=1-`abs($dv)`;
float $c=0.707;
float $b=0.707;
float $rads = ((`pow $b 2`) + (`pow $c 2`) - (`pow $a 2`)) /( 2*$b*$c);
float $deg=90-`acosd($rads)`;
if ($dv<0)
	$deg*=-1;
setAttr ("FK"+$driverObj+".rotate"+$XYZ) $deg;
return $deg;
}

global proc asGoToCorrectivePose (string $driverObj, string $driverAttr, float $dv)
{
string $FKIK;
string $tempString[],$tempString2[],$tempString3[],$tempString4[];
string $FKDriverObj=$driverObj;
if (`objExists ("FK"+$driverObj)`)
	$FKDriverObj="FK"+$driverObj;

//inbetween changes the driverValue
int $numChar=size($driverObj);
string $fitJoint=`substring $driverObj 1 ($numChar-2)`;
if (`objExists $fitJoint`)
	if (`attributeExists inbetweenJoints $fitJoint`)
		$dv=$dv*(`getAttr ($fitJoint+".inbetweenJoints")`+1);

if (!`getAttr -settable ($FKDriverObj+"."+$driverAttr)`)//blended (including blended angles
	{
	asSetBlendedAttribute $driverObj $driverAttr $dv 0;
	if (`gmatch $driverAttr "angle*"`)//single angles (not blended angles)
		$idv=`asSetRotationFromAngle $driverObj $driverAttr $dv`;
	}
else
	setAttr ($FKDriverObj+"."+$driverAttr) $dv;

//Set FKIK to FK (if FK exists)
if (`objExists ("FK"+$driverObj)` && `objExists ("FKX"+$driverObj)` && `objExists ("IKX"+$driverObj)` && `objExists ("FKOffset"+$driverObj)`)
	{
	$tempString=`listConnections ($driverObj+".rx")`;
	if ($tempString[0]!="")
		$tempString2=`listAttr -ud $tempString[0]`;
	if ($tempString2[1]!="")
		$tempString3=`listConnections ($tempString[0]+"."+$tempString2[1])`;
	if (`objExists ($tempString3[0]+".input")`)
		$tempString4=`listConnections ($tempString3[0]+".input")`;
	if ($tempString4[0]!="")
		$FKIK=$tempString4[0];
	if (`objExists $FKIK`)
		setAttr ($FKIK+".FKIKBlend") 0;
	}
}

global proc asEditCorrectiveShape (string $deformObj, string $driverObj, string $driverAttr, float $dv)
{
//print ("asEditCorrectiveShape "+$deformObj+" "+$driverObj+" "+$driverAttr+" "+$dv+"\n");
float $idv;
int $autoKeyframe=`autoKeyframe -q -state`;
autoKeyframe -state 0;
//string $restorePoseCmd=`asGetRestorePoseCmd`;
if (`objExists ControlSet`)
	asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

asGoToCorrectivePose $driverObj $driverAttr $dv;

string $attrCode=$deformObj+"__"+$driverObj+"__"+$driverAttr;
float $iv=`asCorrectiveGetIV $deformObj $driverObj $driverAttr $dv`;
		
if (`objExists $attrCode`)
	warning ("Object "+$attrCode+" already exists");
else
	{
	asCorrectiveDuplicate $attrCode $deformObj;
	addAttr -k 1 -ln driverValue -at double -dv $dv $attrCode;
	addAttr -k 1 -ln inbetweenValue -at double -dv $iv $attrCode;
	addAttr -k 1 -ln indirectDriverValue -at double -dv $idv $attrCode;
	}
//asGoToBuildPose bodySetup;
//eval($restorePoseCmd);
autoKeyframe -state $autoKeyframe;
dgdirty -a;
}

global proc asCBDCreateCurves ()
{
string $sel[]=`ls -sl`;
string $mesh=`textField -q -tx asBodyCorrectiveCBDMeshTextField`;
string $fkControl=`textField -q -tx asBodyCorrectiveCBDFKControlTextField`;
string $joint=`substitute "FK" $fkControl ""`;
string $curveCmd,$curve,$slideSideNr,$axis,$parentJoint,$childJoint,$getXFrom,$deleteSlidersCmd;
string $tempString[],$curves[],$startProfile;
float $pos[],$tempPos[];
float $fat,$parentfat,$childfat;
int $haveSkinCage=`objExists SkinCage`;
int $rotYonly,$rotZonly,$singleAxisPositive;

if (!`gmatch $fkControl "FK*"`)
	error "Select FK-controller(s)";
if ($mesh=="")
	error "Mesh must be chosen";

if (!$haveSkinCage)
	{
	asCreateSkinCage;
	asSkinCurvesToWidth;
	setAttr SkinCage.v 0;
	setAttr SkinCurves1.v 0;
	setAttr SkinCurves2.v 0;
	}
select -cl;
if (`objExists tempLoc`)
	delete tempLoc;
if (`objExists curveDeformationObjects`)
	delete `sets -q curveDeformationObjects`;
createNode -n curveDeformationObjects objectSet;
createNode -n curveDeformationSetup transform;
sets -add curveDeformationObjects curveDeformationSetup;
addAttr -ln mesh -dt "string" curveDeformationSetup;
setAttr -l 1 -type "string" curveDeformationSetup.mesh $mesh;
addAttr -ln fkControl -dt "string" curveDeformationSetup;
setAttr -l 1 -type "string" curveDeformationSetup.fkControl $fkControl;

$tempString=`listRelatives -type joint -p $joint`;
while (`gmatch $tempString[0] "*Part[0-9]*"`)
	$tempString=`listRelatives -type joint -p $tempString[0]`;
$parentJoint=$tempString[0];
$tempString=`listRelatives -type joint -c $joint`;
while (`gmatch $tempString[0] "*Part[0-9]*"`)
	$tempString=`listRelatives -type joint -c $tempString[0]`;
$childJoint=$tempString[0];
$fat=`getAttr ($joint+".fat")`*`getAttr  ($joint+".fatZ")`;
$parentfat=`getAttr ($parentJoint+".fat")`*`getAttr  ($parentJoint+".fatZ")`;
$childfat=`getAttr ($childJoint+".fat")`*`getAttr  ($childJoint+".fatZ")`;

//find $startProfile & $endProfile
if (`objExists ($joint+"_startProfile")`) $startProfile=$joint+"_startProfile";
else
	for ($y=20;$y>0;$y--)
		if (`objExists ($parentJoint+"_twistProfile"+$y)`)
			{
			$startProfile=$parentJoint+"_twistProfile"+$y;
			break;
			}

if (`objExists ($joint+"_endProfile")`) $endProfile=$joint+"_endProfile";
else
	if (`objExists ($joint+"_twistProfile1")`)
		$endProfile=$joint+"_twistProfile1";
//if (!`objExists $endProfile`)
//	$endProfile=$childJoint+"_middleProfile";

//Ensure sliders
if (!`objExists ($joint+"_middleSlider0")`) {select ($joint+"_middleProfile");asCreateSliders;$deleteSlidersCmd+="select "+$joint+"_middleProfile;asDeleteSliders;";}
if (!`objExists ($joint+"_startSlider0")`)
	if (`objExists $startProfile`){select $startProfile;asCreateSliders;$deleteSlidersCmd+="select "+$startProfile+";asDeleteSliders;";}
	else
		{
		for ($i=0;$i<5;$i++)
			if (`objExists ($joint+"_middleSlider"+$i)`)
				{
				duplicate -n ($joint+"_startSlider"+$i) ($joint+"_middleSlider"+$i);
				parent ($joint+"_startSlider"+$i) $joint;
				setAttr ($joint+"_startSlider"+$i+".tx") `getAttr ($joint+".tx")`;
				}
		}
if (!`objExists ($joint+"_endSlider0")`)
	if (`objExists $endProfile`){select $endProfile;asCreateSliders;$deleteSlidersCmd+="select "+$endProfile+";asDeleteSliders;";}
	else
		{
		for ($i=0;$i<5;$i++)
			if (`objExists ($joint+"_middleSlider"+$i)`)
				{
				duplicate -n ($joint+"_endSlider"+$i) ($joint+"_middleSlider"+$i);
				parent ($joint+"_endSlider"+$i) $joint;
				setAttr ($joint+"_endSlider"+$i+".tx") `getAttr ($childJoint+".tx")`;
				}
		}

//$rotYonly,$rotZonly & $singleAxisPositive
$rotYonly=$rotZonly=0;
if (!`objExists ($joint+"_middleSlider0")`) $rotYonly=1;
if (!`objExists ($joint+"_middleSlider1")`) $rotZonly=1;
$singleAxisPositive=0;
if ($rotYonly && `getAttr ($joint+".jointOrientY")`>0) $singleAxisPositive=1;
if ($rotZonly && `getAttr ($joint+".jointOrientZ")`>0) $singleAxisPositive=1;
addAttr -k 1 -ln "rotYonly" -at bool -dv $rotYonly curveDeformationSetup;
addAttr -k 1 -ln "rotZonly" -at bool -dv $rotZonly curveDeformationSetup;
addAttr -k 1 -ln "singleAxisPositive" -at bool -dv $singleAxisPositive curveDeformationSetup;

spaceLocator -n tempLoc;
pointConstraint $parentJoint $joint $childJoint tempLoc;
parent tempLoc $joint;
setAttr -type float3 tempLoc.r 0 0 0;

for ($a=1;$a>-2;$a=$a-2)
	{
	if ($a==1)  $axis="Y";
	if ($a==-1) $axis="Z";
	if ($rotYonly && $axis=="Y") continue;
	if ($rotZonly && $axis=="Z") continue;

	for ($b=1;$b>-2;$b=$b-2)
		{
		$curveCmd="curve -d 3";
		if ($b==1)  $curve="deformationCurve"+$axis+"1";
		if ($b==-1) $curve="deformationCurve"+$axis+"2";
		if ($a==1  && $b==1)  $slideSideNr="2";
		if ($a==1  && $b==-1) $slideSideNr="0";
		if ($a==-1 && $b==1)  $slideSideNr="3";
		if ($a==-1 && $b==-1) $slideSideNr="1";

		$curves[size($curves)]=$curve;
		setAttr -type float3 ("tempLoc_pointConstraint1.offset") 0 0 0;
		for ($y=0;$y<9;$y++)
			{
			if ($y==0)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 1;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 0;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ($parentfat*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==1)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 3;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==2)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 1;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 0;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ((($fat+$parentfat)/2.0)*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}

			if ($y<3 && `gmatch $joint "*_R"` && `gmatch $parentJoint "*_M"` && $curve!="deformationCurveZ1")
				{//Branching such as Hip, not to extend to far across axis
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				$tempPos=`xform -q -ws -t tempLoc`;
				$pos[0]=$tempPos[0];
				}
			if ($y<3 && `gmatch $joint "*_R"` && $pos[0]>0)
				$pos[0]=0;

			if ($y==3)
				{
				$pos=`xform -q -ws -t ($joint+"_startSlider"+$slideSideNr)`;
				}
			if ($y==4)
				{
				$pos=`xform -q -ws -t ($joint+"_middleSlider"+$slideSideNr)`;
				}
			if ($y==5)
				{
				$pos=`xform -q -ws -t ($joint+"_endSlider"+$slideSideNr)`;
				}
			if ($y==6)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 1;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ((($fat+$childfat)/2.0)*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==7)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 1;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 3;
				$pos=`xform -q -ws -t tempLoc`;
				}
			if ($y==8)
				{
				setAttr ("tempLoc_pointConstraint1."+$parentJoint+"W0") 0;
				setAttr ("tempLoc_pointConstraint1."+$joint+"W1") 0;
				setAttr ("tempLoc_pointConstraint1."+$childJoint+"W2") 1;
				setAttr ("tempLoc_pointConstraint1.offset"+$axis) ($childfat*$b);
				$pos=`xform -q -ws -t tempLoc`;
				}
			$curveCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
			}
		$curveCmd+=" -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 6 -k 6";
		$tempString[0]=`eval ($curveCmd)`;
		rename $tempString[0] $curve;
		setAttr ($curve+".dispCV") 1;
		parent $curve curveDeformationSetup;
		select $childJoint $parentJoint ($joint+"_startSlider"+$slideSideNr) ($joint+"_middleSlider"+$slideSideNr) ($joint+"_endSlider"+$slideSideNr) $curve;
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		rename $tempString[0] ($curve+"SC");
		for ($y=0;$y<9;$y++)
			{
			if ($y==0) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==1) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==2) skinPercent -tv $parentJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==3) skinPercent -tv ($joint+"_startSlider"+$slideSideNr) 1	($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==4) skinPercent -tv ($joint+"_middleSlider"+$slideSideNr) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==5) skinPercent -tv ($joint+"_endSlider"+$slideSideNr) 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==6) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==7) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			if ($y==8) skinPercent -tv $childJoint 1 ($curve+"SC") ($curve+".cv["+$y+"]");
			}
		}
	}
if (`objExists deformationCurveZ1` && `objExists deformationCurveY2`)
	reorder -relative -1 deformationCurveZ1;
delete tempLoc;

addAttr -k 1 -ln haveSkinCage -at bool -dv $haveSkinCage curveDeformationSetup;
addAttr -ln deleteSlidersCmd -dt "string" curveDeformationSetup;
setAttr -type "string" curveDeformationSetup.deleteSlidersCmd $deleteSlidersCmd;

select $curves;
}

global proc asCBDCreateTestAnim ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;
float $singleAxisRotValue=-90;
if ($singleAxisPositive)
	$singleAxisRotValue=90;

currentTime 0;
if ($rotYonly || $rotZonly)
	{
	playbackOptions -min 0 -ast 0 -aet 10 -max 10;
	if ($rotYonly) setKeyframe ($fkControl+".ry");
	if ($rotZonly) setKeyframe ($fkControl+".rz");
	currentTime 10;
	if ($rotYonly)	{setAttr ($fkControl+".ry") $singleAxisRotValue;setKeyframe ($fkControl+".ry");}
	if ($rotZonly)	{setAttr ($fkControl+".rz") $singleAxisRotValue;setKeyframe ($fkControl+".rz");}
	}
else
	{
	playbackOptions -min 0 -ast 0 -aet 80 -max 80;
	setKeyframe ($fkControl+".r");
	currentTime 10;setAttr ($fkControl+".ry") 90;setKeyframe ($fkControl+".r");
	currentTime 20;setAttr ($fkControl+".ry") 0;setKeyframe ($fkControl+".r");
	currentTime 30;setAttr ($fkControl+".ry") -90;setKeyframe ($fkControl+".r");
	currentTime 40;setAttr ($fkControl+".ry") 0;setKeyframe ($fkControl+".r");
	currentTime 50;setAttr ($fkControl+".rz") 90;setKeyframe ($fkControl+".r");
	currentTime 60;setAttr ($fkControl+".rz") 0;setKeyframe ($fkControl+".r");
	currentTime 70;setAttr ($fkControl+".rz") -90;setKeyframe ($fkControl+".r");
	currentTime 80;setAttr ($fkControl+".rz") 0;setKeyframe ($fkControl+".r");
	}
refresh;
currentTime 5;
}

global proc asCBDHideMesh ()
{
string $source=`textField -q -tx asBodyCorrectiveCBDMeshTextField`;
if (`objExists $source`)
	setAttr ($source+".v") 0;
}

global proc asCBDCreateDeformMesh ()
{
float $pos[];
float $radius;
float $currentTime=`currentTime -q`;
string $tempString[];
string $existingSkinCluster,$newSkinCluster;
currentTime 0;

if (`objExists Corrective`) delete Corrective;
if (`objExists deformationLoft`) delete deformationLoft;

string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
string $joint=`substitute "FK" $fkControl ""`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;
string $curves[]=`listRelatives -c curveDeformationSetup`;

select $curves;
//	select $curves[0] $curves[2] $curves[1] $curves[3];
$tempString=`loft -n deformationLoft -ch 1 -u 1 -c 1 -ar 1 -d 3 -ss 2 -rn 0 -po 0 -rsn true`;
setAttr deformationLoftShape.curvePrecisionShaded 4;
setAttr deformationLoft.v 0;
parent deformationLoft curveDeformationSetup;

duplicate -n Corrective $mesh;
asLockAttr Corrective 0 0 0 0;
parent Corrective curveDeformationSetup;
setAttr Corrective.v 1;
$tempString=`listRelatives -s Corrective`;
for ($z=0;$z<size($tempString);$z++)
	if (`getAttr ($tempString[$z]+".intermediateObject")`)
		delete $tempString[$z];

//skinCluster first (fir out-of-bounds-regions)
$tempString=`listHistory -pdo 1 $mesh`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$existingSkinCluster=$tempString[$y];
select Corrective `listConnections ($existingSkinCluster+".matrix")`;
$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
rename $tempString[0] CorrectiveSC;
$tempString=`listConnections CorrectiveSC.message`;
rename $tempString[0] CorrectiveSCSet;
select $mesh Corrective;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;

sets -add curveDeformationObjects $curves deformationLoft Corrective;
select -r Corrective deformationLoft;$tempString=`doWrapArgList "7" { "1","0","1", "2", "0", "1", "1", "0" }`;
//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
rename $tempString[0] CorrectiveWrap;
$tempString=`listConnections CorrectiveWrap.message`;
rename $tempString[0] CorrectiveWrapSet;
if (`gmatch $joint "*_R"`)
	{
	polySelectConstraint -m 3 -t 1 -d 3 -db 0 999 -da 1 0 0 -dp 999 0 0;
	sets -remove CorrectiveWrapSet `ls -sl`;
	}

$pos=`xform -q -ws -t $fkControl`;
select Corrective;
$radius=(`getAttr ($joint+".fat")`*`getAttr ($joint+".fatZ")`)*6;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $radius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl`;
polySelectConstraint -m 0;
catchQuiet (`sets -remove CorrectiveSCSet $tempString`);
asInvertSelection;
sets -remove CorrectiveWrapSet `ls -sl`;
ConvertSelectionToFaces;
delete;
$tempString=`listConnections -s 1 -d 0 Corrective.inMesh`;
rename $tempString[0] CorrectiveDeleteComponent;

currentTime $currentTime;
}

global proc asCBDShowOriginal ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
setAttr ($mesh+".v") 1;
setAttr Corrective.v 0;
}

global proc asCBDShowNew ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
setAttr ($mesh+".v") 0;
setAttr Corrective.v 1;
}

global proc asCBBakeDeformMesh ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
int $rotYonly=`getAttr curveDeformationSetup.rotYonly`;
int $rotZonly=`getAttr curveDeformationSetup.rotZonly`;
int $singleAxisPositive=`getAttr curveDeformationSetup.singleAxisPositive`;

setAttr ($mesh+".v") 1;
textField -e -tx Corrective asBakeToCorrective1TextField;
textField -e -tx $mesh asBakeToCorrective2TextField;

if (`objExists CorrectiveDeleteComponent`)
	delete CorrectiveDeleteComponent;

string $checkBoxes[]=`rowLayout -q -ca asBakeAxisRowLayout`;
for ($i=0;$i<size($checkBoxes);$i++)
	if ($rotYonly || $rotZonly)
		checkBox -e -v 0 $checkBoxes[$i];
	else
		checkBox -e -v 1 $checkBoxes[$i];
checkBox -e -v 0 asBakeX1CheckBox;
checkBox -e -v 0 asBakeX2CheckBox;
if ($rotYonly && $singleAxisPositive) checkBox -e -v 1 asBakeY1CheckBox;
if ($rotYonly && !$singleAxisPositive) checkBox -e -v 1 asBakeY2CheckBox;
if ($rotZonly && $singleAxisPositive) checkBox -e -v 1 asBakeZ1CheckBox;
if ($rotZonly && !$singleAxisPositive) checkBox -e -v 1 asBakeZ2CheckBox;

if ($rotYonly || $rotZonly)
	checkBox -e -v 0 asCorrectiveAngleCheckBox;
else
	checkBox -e -v 1 asCorrectiveAngleCheckBox;

select $fkControl;
asBakeIntoCorrectiveShapes;
textField -e -tx "" asBakeToCorrective1TextField;
textField -e -tx "" asBakeToCorrective2TextField;

asCBCleanup;
print "// CurveBased Deformation Corrective BlendShape complete.\n";
}

global proc asCBCleanup ()
{
string $mesh=`getAttr curveDeformationSetup.mesh`;
string $fkControl=`getAttr curveDeformationSetup.fkControl`;
eval (`getAttr curveDeformationSetup.deleteSlidersCmd`);
if (!`getAttr curveDeformationSetup.haveSkinCage`)
	asDeleteSkinCage;

delete `sets -q curveDeformationObjects`;
setAttr ($mesh+".v") 1;
string $tempString[]=`listConnections -s 1 -d 0 -type animCurveTA $fkControl`;
for ($i=0;$i<size($tempString);$i++)
	delete $tempString[$i];
setAttr -type float3 ($fkControl+".r") 0 0 0;
}

global proc asBakeIntoCorrectiveShapes ()
{
global int $asSkipConfirm;
string $sel[]=`ls -sl`;
string $source=`textField -q -tx asBakeToCorrective1TextField`;
string $dest=`textField -q -tx asBakeToCorrective2TextField`;
if ($source=="" || !`objExists $source` || `gmatch $source "*[.]*"`)
	error "Source not valid";
if ($dest=="" || !`objExists $dest` || `gmatch $dest "*[.]*"`)
	error "Destination not valid";
string $tempString[]=`listRelatives -s -ni $source`;
string $sourceShape=$tempString[0];
string $restorePoseCmd=`asGetRestorePoseCmd`;
asGoToBuildPose bodySetup;
asSetAllFK "";
select -cl;
$asSkipConfirm=1;
string $xyz[]={"x","x","y","y","z","z"};
float $rots[]={90,-90,90,-90,90,-90};
for ($i=0;$i<size($sel);$i++)
	{
	print ("// Start checking:"+$sel[$i]+"\n");
	if (!`gmatch $sel[$i] "FK*"`)
		continue;
	if (!`sets -im ControlSet $sel[$i]`)
		continue;
	if (`gmatch $sel[$i] "FKExtra*"`)
		continue;
	if (`gmatch $sel[$i] "FKRoot*"`)
		continue;
	for ($y=0;$y<size($xyz);$y++)
		{
		if ($y==0 && !`checkBox -q -v asBakeX1CheckBox`) continue;
		if ($y==1 && !`checkBox -q -v asBakeX2CheckBox`) continue;
		if ($y==2 && !`checkBox -q -v asBakeY1CheckBox`) continue;
		if ($y==3 && !`checkBox -q -v asBakeY2CheckBox`) continue;
		if ($y==4 && !`checkBox -q -v asBakeZ1CheckBox`) continue;
		if ($y==5 && !`checkBox -q -v asBakeZ2CheckBox`) continue;
		print ("// Baking:"+$sel[$i]+".r"+$xyz[$y]+"="+$rots[$y]+"\n");
		setAttr ($sel[$i]+".r"+$xyz[$y]) $rots[$y];
		refresh;
		select $dest;
		$corrective=`asCreateCorrectiveShape`;
		$tempString=`listRelatives -s -ni $corrective`;
		$correctiveShape=$tempString[0];
		connectAttr -f ($sourceShape+".outMesh") ($correctiveShape+".inMesh");
		asConnectCorrectiveShape;
		setAttr ($sel[$i]+".r"+$xyz[$y]) 0;
		}
	}
$asSkipConfirm=0;
eval($restorePoseCmd);
select $sel;
}

global proc asUpdatePoseAttributes ()
{
//update buildPoses and run attributes
string $poseAttr,$existingCmd,$newCmd;
string $tempString[];
string $restorePoseCmd=`asGetRestorePoseCmd`;

for ($a=0;$a<4;$a++)
	{
	if ($a==0) $poseAttr="buildPose.udAttr";
	if ($a==1) $poseAttr="faceBuildPose.udAttr";
	if ($a==2) $poseAttr="FitSkeleton.run";
	if ($a==3) $poseAttr="FaceFitSkeleton.run";
	if (!`objExists $poseAttr`)
		continue;
	$existingCmd=`getAttr $poseAttr`;
	$newCmd="";
	tokenize $existingCmd ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		if (!catchQuiet (`eval ($tempString[$i])`))
			$newCmd+=$tempString[$i]+";";
		else if ($tempString[$i]!="")
			print ("// Removing from "+$poseAttr+":"+$tempString[$i]+"\n");

	setAttr -type "string" $poseAttr $newCmd;
	}
eval ($restorePoseCmd);
}

global proc string asGetRestorePoseCmd ()
{
string $restorePoseCmd;
string $controlSetMembers[];
if (`objExists ControlSet`) $controlSetMembers=`sets -q ControlSet`;
if (`objExists FaceControlSet`)
	{
	string $faceControlSetMembers[]=`sets -q FaceControlSet`;
	$controlSetMembers=`stringArrayCatenate $controlSetMembers $faceControlSetMembers`;
	}
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	string $attrs[]=`listAttr -k $controlSetMembers[$i]`;
	for ($y=0;$y<size($attrs);$y++)
		{
		if (`getAttr -l ($controlSetMembers[$i]+"."+$attrs[$y])`)
			continue;
		if (!`getAttr -settable ($controlSetMembers[$i]+"."+$attrs[$y])`)
			continue;
		$restorePoseCmd+="setAttr "+$controlSetMembers[$i]+"."+$attrs[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$attrs[$y])`+";";
		}
	}

return $restorePoseCmd;
}

global proc asSkinCurvesToWidth ()
{
if (!`objExists SkinCurves2` || !`objExists SkinCurves1`)
	error "SkinCurves not found. Create SkinCage first";
float $pos[],$pos2[];
string $skinCurves1[]=`listConnections SkinCurves1.drawInfo`;
string $skinCurves2[]=`listConnections SkinCurves2.drawInfo`;
string $tempString[];
string $joint,$aboveBelowProfile,$belowProfile,$parentJoint,$parentTarget;
for ($i=0;$i<size($skinCurves1);$i++)
	{
	tokenize $skinCurves1[$i] "_" $tempString;
	$joint="";
	for ($y=0;$y<size($tempString)-1;$y++)
		{
		$joint+=$tempString[$y];
		if ($y<size($tempString)-2)
			$joint+="_";
		}
	if (!`objExists $joint`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	while (`gmatch $tempString[0] "*Part[0-9]*"`)
		$tempString=`listRelatives -type joint -p $tempString[0]`;
	$parentJoint=$tempString[0];
	if (!`objExists $parentJoint`)
		continue;
	$tempString=`listRelatives -type joint -c $joint`;
	$childJoint=$tempString[0];
	if (!`objExists $childJoint`)
		continue;

	//ignore `inbetween` joints
	$tempString=`listRelatives -type joint -c $joint`;
	if (`gmatch $tempString[0] "*Part[0-9]*"` && !`attributeExists twistAmount $tempString[0]`)
		continue;
	$tempString=`listRelatives -type joint -p $joint`;
	if (`gmatch $tempString[0] "*Part[0-9]*"` && !`attributeExists twistAmount $tempString[0]`)
		continue;

	for ($a=0;$a<2;$a++)
		{
		// find profile
		$aboveBelowProfile="";
		if ($a==0 && !`attributeExists noStartCurve $joint`)
			{
			if (`objExists ($joint+"_startProfile")`)
				$aboveBelowProfile=$joint+"_startProfile";
			else
				{
				for ($y=20;$y>0;$y--)
					if (`objExists ($parentJoint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$parentJoint+"_twistProfile"+$y;
						break;
						}
				}
			if ($aboveBelowProfile=="")
				continue;
			}
		if ($a==1)
			{
			if (`objExists ($joint+"_endProfile")`)
				$aboveBelowProfile=$joint+"_endProfile";
			else
				{
				for ($y=1;$y<21;$y++)
					if (`objExists ($joint+"_twistProfile"+$y)`)
						{
						$aboveBelowProfile=$joint+"_twistProfile"+$y;
						break;
						}
				}
			}
		if ($aboveBelowProfile=="" || `gmatch $aboveBelowProfile "Neck*"`)//skip neck
			continue;
	
		// place profile
		int $targetIds[2]={0,1};
		$tempString=`listRelatives -p $aboveBelowProfile`;
		string $offsetNode=$tempString[0];
		string $parentConstraint=$offsetNode+"_pointConstraint1";
		string $scaleConstraint=$offsetNode+"_scaleConstraint1";
		string $targetAttrs[]=`listAttr -ud $parentConstraint`;
		setAttr -type float3 ($parentConstraint+".offset") 0 0 0;
		$tempString=`listConnections ($parentConstraint+".target[0].targetParentMatrix")`;
		if ($tempString[0]==`substitute "Profile" $skinCurves1[$i] "Curve"`)
			{
			$targetIds={1,0};
			$tempString=`listConnections ($parentConstraint+".target[1].targetParentMatrix")`;
			if ($tempString[0]=="")
				continue;
			}
		$parentTarget=$tempString[0];
		$pos=`xform -q -ws -t $skinCurves1[$i]`;
		$pos2=`xform -q -ws -t $parentTarget`;
		float $toParentDist=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
	
		$tempString=`listRelatives -c $skinCurves1[$i]`;
		$innerCurve=$tempString[0];
		$pos=`xform -q -ws -t ($innerCurve+".cv[0]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		float $curveHeight=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		$pos=`xform -q -ws -t ($innerCurve+".cv[1]")`;
		$pos2=`xform -q -ws -t ($innerCurve+".cv[2]")`;
		float $curveWidth=`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>`;
		float $hwAverage=($curveHeight+$curveWidth)/2.0;
	
		if ($targetAttrs[1]!="")
			{
			float $weight=($hwAverage/2.0)/$toParentDist;
			if ($weight>1)
				$weight=1;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($parentConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[0]]) $weight;
			setAttr ($scaleConstraint+"."+$targetAttrs[$targetIds[1]]) (1-$weight);
			}
		}
	}
}

global proc asAddWristDetails ()
{
global string $gMove;
float $pos[],$pos2[];
string $sel[]=`ls -sl`;
string $cv,$vtx;
string $tempString[],$locs[],$locVtxs[],$locCageVtxs[],$locCageMirrorVtxs[];
string $asGeometryFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asGeometry.ma";

file -i $asGeometryFile;
setAttr WristDetails.v 1;
setAttr WristDetailsLocators.v 1;
parent -w WristDetails WristDetailsLocators;
if (`objExists Mannequin_Geometry`)
	delete Mannequin_Geometry;
if (`objExists Skeleton_Geometry`)
	delete Skeleton_Geometry;
if (`objExists SkinCage_Geometry`)
	delete SkinCage_Geometry;

if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;

$locs=`listRelatives -c WristDetailsLocators`;
for ($i=0;$i<size($locs);$i++)
	{
	tokenize $locs[$i] "_" $tempString;
	$cv=$tempString[0]+"_"+$tempString[1]+"_"+$tempString[2]+"."+$tempString[3]+"["+$tempString[4]+"]";
	if (!`objExists $cv`)
		{
		if (`objExists closestSampler`) delete closestSampler;
		warning ("Skipped, because \""+$cv+"\" not found");
		delete WristDetails WristDetailsLocators;
		return;
		}
	$pos=`xform -q -ws -t $cv`;
	$pos2=`xform -q -ws -t $locs[$i]`;
	setAttr closestSampler.inPosition $pos2[0] $pos2[1] $pos2[2];
	connectAttr -f WristDetails.outMesh closestSampler.inMesh;
	$vtx="WristDetails.vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	$locVtxs[$i]=$vtx;

	//get $locCageVtxs
	connectAttr -f skinCage.outMesh closestSampler.inMesh;
	setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
	$locCageVtxs[$i]="skinCage.vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	xform -ws -t $pos[0] $pos[1] $pos[2] $vtx;
	//get $mirrorVtx as well
	setAttr closestSampler.inPosition ($pos[0]*-1) $pos[1] $pos[2];
	$locCageMirrorVtxs[$i]="skinCage.vtx["+`getAttr closestSampler.closestVertexIndex`+"]";
	}
delete WristDetailsLocators;

select $locVtxs;
asInvertSelection;

$pos=`xform -q -ws -t ThumbFinger2_R_startCurve.cv[2]`;
$pos2=`xform -q -ws -t ThumbFinger2_R_middleCurve.cv[2]`;
xform -ws -t ($pos[0]+($pos[0]-$pos2[0])) ($pos[1]+($pos[1]-$pos2[1])) ($pos[2]+($pos[2]-$pos2[2])) WristDetails.vtx[30];
select -d WristDetails.vtx[30];

for ($i=0;$i<15;$i++)
	polyAverageVertex -i 10 -ch 0;

setToolTo $gMove;
$pos=`manipMoveContext -q -position "Move"`;
scale -r -p $pos[0] $pos[1] $pos[2] 1.13 1.13 1.13;

select -r skinCage WristDetails;
transferAttributes -transferPositions 0 -transferNormals 0 -transferUVs 2 -transferColors 0 -sampleSpace 0 -sourceUvSpace "map1" -targetUvSpace "map1" -searchMethod 3-flipUVs 0 -colorBorders 1;
select -r WristDetails;
DeleteHistory;

select $locCageVtxs $locCageMirrorVtxs;
ConvertSelectionToContainedFaces;
delete;

//combine and merge, via new skinCage
rename skinCage skinCageOld;
rename skinClusterSkinCage skinClusterSkinCageOld;
rename wrapSkinCage wrapSkinCageOld;
duplicate -n WristDetailsMirrored WristDetails;
scale -r -p 0 0 0 -1 1 1 WristDetailsMirrored.vtx[0:9999];
duplicate -n skinCageCopy skinCageOld;
polyUnite -n skinCage -ch 0 -mergeUVSets 1 skinCageCopy WristDetails WristDetailsMirrored;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
delete skinCageCopy;
polyMergeVertex -ch 0 -d 0.001 -am 1 skinCage;
//bindSkin
select `listConnections skinClusterSkinCageOld.matrix`;
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r skinCageOld skinCage;
copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
delete skinCageOld;
//wrap
$cylinders=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	$tempString=`listRelatives -p $cylinders[$i]`;
	if ($tempString[0]!="MeshGeometry")
		continue;
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;
reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

if (`objExists closestSampler`) delete closestSampler;
select $sel;
}

global proc asCreateGroinLocators ()
{
if (`objExists GroinStart`) delete GroinStart;
if (`objExists GroinSide`) delete GroinSide;
spaceLocator -n GroinStart;
spaceLocator -n GroinSide;
float $posA[]=`xform -q -ws -t Root`;
float $posB[]=`xform -q -ws -t Root_M_middleCurve.cv[2]`;
xform -ws -t 0 ($posA[1]*0.9) $posA[2] GroinStart;
xform -ws -t $posB[0] ($posB[1]*1.03) $posA[2] GroinSide;
select -cl;
}

global proc asAdjustGroinArea ()
{
float $pos[];
float $posGroinStart[]=`xform -q -ws -t GroinStart`;
float $posGroinSide[]=`xform -q -ws -t GroinSide`;

if (!`objExists Root_M_middleCurve` || !`objExists Hip_R_startProfileShape`)
	{
	if (`objExists GroinStart`) delete GroinStart;
	if (`objExists GroinSide`) delete GroinSide;
	warning "Skipped, because required profile-curves not found";
	return;
	}

$pos=`xform -q -ws -t Root_M_middleProfile`;
xform -ws -t 0 $posGroinSide[1] $pos[2] Root_M_middleProfile;

$pos=`xform -q -ws -t Root_M_middleCurve.cv[2]`;
xform -ws -t $pos[0] ($pos[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[3];
$pos=`xform -q -ws -t Root_M_middleProfileShape.cv[2]`;
xform -ws -t $pos[0] ($pos[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[3];

$pos=`xform -q -ws -t Root_M_middleCurve.cv[1]`;
xform -ws -t $pos[0] ($pos[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[0] Hip_R_startProfileShape.cv[4];
$pos=`xform -q -ws -t Root_M_middleProfileShape.cv[1]`;
xform -ws -t $pos[0] ($pos[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[0] Hip_R_middleProfileShape.cv[4];

$pos=`xform -q -ws -t Hip_R_middleProfileShape.cv[2]`;
xform -ws -t $pos[0] ($posGroinStart[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[2];
$pos=`xform -q -ws -t Hip_R_middleProfileShape.cv[1]`;
xform -ws -t $pos[0] ($posGroinStart[1]*0.95) $pos[2] Hip_R_middleProfileShape.cv[1];

$pos=`xform -q -ws -t Hip_R_startProfileShape.cv[2]`;
xform -ws -t 0 ($posGroinStart[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[2];
$pos=`xform -q -ws -t Hip_R_startProfileShape.cv[1]`;
xform -ws -t 0 ($posGroinStart[1]*1.00) $pos[2] Hip_R_startProfileShape.cv[1];

scale -r 1.2 1.2 1.2 Hip_R_startProfile;

//might overlap with twistProfiles
int $twistJoints=`getAttr Hip.twistJoints`;
for ($i=1;$i<$twistJoints+1;$i++)
	{
	$pos=`xform -q -ws -t ("Hip_R_twistProfileShape"+$i+".cv[1]")`;
	if ($pos[1]>$posGroinStart[1])
		move -r 0 (($pos[1]-$posGroinStart[1])*-1.2) 0 ("Hip_R_twistProfileShape"+$i+".cv[1:2]");
	}

asMirrorControlCurves 0 SkinCageCurvesSet;

if (`objExists GroinStart`) delete GroinStart;
if (`objExists GroinSide`) delete GroinSide;
}

global proc asCreateSkinCage ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;
string $tempString[];

if (`objExists MeshGeometry`)
	{
	asRebuildSkinCage;
	return;
	}

createNode -n Cages transform;
parent Cages Geometry;
createNode -n MeshGeometry transform;
parent MeshGeometry Geometry;
setAttr "MeshGeometry.overrideEnabled" 1;
createNode -n MeshCurves transform;
parent MeshCurves Geometry;
createNode -n NurbsGeometry transform;
setAttr NurbsGeometry.v 0;
parent NurbsGeometry Geometry;
sets -em -name SkinCageCurvesSet;
sets -add "Sets" SkinCageCurvesSet;

select -cl;
createDisplayLayer -e -name "SkinCage" -number 1 -nr;
createDisplayLayer -e -name "SkinCurves1" -number 2 -nr;
createDisplayLayer -e -name "SkinCurves2" -number 3 -nr;
setAttr SkinCurves2.visibility 0; setAttr SkinCurves2.displayType 0; setAttr SkinCurves2.color 13;
setAttr SkinCurves1.visibility 1; setAttr SkinCurves1.displayType 0; setAttr SkinCurves1.color 14;
setAttr SkinCage.displayType 2;


//Build tubes
string $topNodes[]=`listRelatives -type joint -c DeformationSystem`;
asAnalyzeChainJoints $topNodes[0];

//pickup single brancers
string $children[];
$tempString=`asListAllDecents $topNodes[0]`;
for ($i=0;$i<size($tempString);$i++)
	{
	$children=`asListChildren $tempString[$i]`;
	if (size($children)>0)
		if (!`objExists ($tempString[$i]+"_middleCurve")`)
			asBuildChainCurves {$tempString[$i]};
	}


//Branch
asCreateBranchBoxes;

//merge copies.
select `ls -as "*_copy" "*_branch"`;
$tempString=`polyUnite -ch 0 -n skinCage`;
setAttr ($tempString[0]+".keepBorder") 0;
polyMergeVertex -d 0.0001 -am 1 -ch 1 skinCage;
select skinCage;
DeleteHistory;
polyNormal -normalMode 2 -userNormalMode 0 -ch 0 skinCage;
DeleteHistory;
parent skinCage Cages;
editDisplayLayerMembers -noRecurse SkinCage skinCage;
string $middleCurves[]=`ls -type transform "*_middleCurve"`;

//UV
polyAutoProjection -ch 0 -lm 0 -pb 0 -ibd 0 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0 skinCage;

//skinn
string $joint,$twistJoint;
select -cl;
for ($i=0;$i<size($middleCurves);$i++)
	{
	$joint=`substitute "_middleCurve" $middleCurves[$i] ""`;
	select -add $joint;
	//include twistJoints
	for ($y=1;$y<99;$y++)
		{
		tokenize $joint "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$y+"_"+$tempString[1];
		if (`objExists $twistJoint`)
			select -add ($twistJoint);
		else
			break;
		}
	//include nonListedParents
	$tempString=`listRelatives -type joint -p $joint`;
	if (size($tempString))
		if (!`objExists ($tempString[0]+"_middleCurve")`)
			if (!`gmatch $tempString[0] "*Part[0-9]*"`)
				select -add $tempString[0];
	//include 50`s
	if (`objExists ($joint+"_50")`)
		select -add ($joint+"_50");
	//deselect endJoints
	$tempString=`listRelatives -type joint -c $joint`;
	if (!`size($tempString)`)
		select -d $joint;
	}
select -add skinCage;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] skinClusterSkinCage;
select -r `listRelatives -c MeshGeometry`;
select `ls -sl -ni "*_poly"`;
select -add skinCage;
copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
string $cylinders[]=`ls -type transform "*_poly"`;
for ($i=0;$i<size($cylinders);$i++)
	{
	delete `listConnections ($cylinders[$i]+"Shape.inMesh")`;
	setAttr -l 1 ($cylinders[$i]+".v") 0;
	}

//wrap
$cylinders=`ls -type transform "*_poly"`;
select -cl;
deformer -type wrap skinCage;
for ($i=0;$i<size($cylinders);$i++)
	{
	select -r skinCage;
	select -add $cylinders[$i];
	AddWrapInfluence;
	}
$tempString=`listConnections "skinCageShape.inMesh"`;
rename $tempString[0] wrapSkinCage;

reorderDeformers "skinClusterSkinCage" "wrapSkinCage" "skinCage";

//scale profileCurves to markers
float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;
$fitSkeletonJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitSkeletonJoints);$i++)
		{
		$fitSkeletonSide[$i]="_R";
		$pos=`xform -q -ws -t $fitSkeletonJoints[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$fitSkeletonSide[$i]="_M";

		$side=$fitSkeletonSide[$i];
		if ($b==-1 && $fitSkeletonSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";

		string $profileCurve=$fitSkeletonJoints[$i]+$side+"_middleProfile";
		if (`objExists $profileCurve`)
			{
			if (!`attributeExists fat $fitSkeletonJoints[$i]`)
				continue;
			float $fat=`getAttr ($fitSkeletonJoints[$i]+$side+".fat")`;
			float $fatY=`getAttr ($fitSkeletonJoints[$i]+$side+".fatY")`;
			float $fatZ=`getAttr ($fitSkeletonJoints[$i]+$side+".fatZ")`;
//			float $sca[3]=`getAttr ($fitSkeletonJoints[$i]+".s")`;
//			setAttr -type float3 ($profileCurve+".s") $sca[0] $sca[1] $sca[2];
//			setAttr ($profileCurve+".sx") $scale;
//			setAttr ($profileCurve+".sy") ($fat*$fatY*$scale);
//			setAttr ($profileCurve+".sz") ($fat*$fatZ*$scale);
			setAttr ($profileCurve+".sy") ($fat*$fatY);
			setAttr ($profileCurve+".sz") ($fat*$fatZ);
			refresh;
			}
		}

//Profiles tweaks
asProfileTweaks;
asMirrorControlCurves 0 SkinCageCurvesSet;
print "// SkinCage created\n";
select -cl;
}

global proc asDeleteSkinCage ()
{
string $deleteObjs[]={"skinCage","SkinSub","Cages","MeshGeometry","MeshCurves","NurbsGeometry","SkinCage","SkinCurves1","SkinCurves2","SkinCageCurvesSet"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
}

global proc asRebuildSkinCage ()
{
string $restoreShapesCmds[];
string $profileCurveShapes[]=`ls -type nurbsCurve "*ProfileShape*"`;
int $form,$spans,$degrees,$numCv;
for ($i=0;$i<size($profileCurveShapes);$i++)
	{
	$form=`getAttr ($profileCurveShapes[$i]+".form")`;
	$spans=`getAttr ($profileCurveShapes[$i]+".spans")`;
	$degrees=`getAttr ($profileCurveShapes[$i]+".degree")`;
	if ($form==2)
		$numCv=$spans;
	else
		$numCv=$spans+$degrees;
	for ($y=0;$y<$numCv+1;$y++)
		{
		$pos=`xform -q -ws -t ($profileCurveShapes[$i]+".cv["+$y+"]")`;
		$restoreShapesCmds[size($restoreShapesCmds)]="xform -ws -t "+$pos[0]+" "+$pos[1]+" "+$pos[2]+" "+$profileCurveShapes[$i]+".cv["+$y+"];";
		}
	}

asDeleteSkinCage;
asCreateSkinCage;
for ($i=0;$i<size($restoreShapesCmds);$i++)
	print ($restoreShapesCmds[$i]+"\n");
for ($i=0;$i<size($restoreShapesCmds);$i++)
	catchQuiet (`eval $restoreShapesCmds[$i]`);
}

global proc asProfileTweaks ()
{
int $reverseKnee;
int $cvs[],$oppositeCvs[],$flipCvs[];
float $dist,$minDist;
float $pos1[],$pos2[],$pos3[],$sca1[],$sca2[];
string $heelFitJoint,$toesFitJoint,$cv,$closestCv;
string $tempString[];

string $ankleProfileEnds[]=`ls -type transform "*Ankle*_*endProfile"`;
for ($i=0;$i<size($ankleProfileEnds);$i++)
	{
	string $ankle=`substitute "_endProfile" $ankleProfileEnds[$i] ""`;
	int $numChar=size($ankle);
	string $fitAnkle=`substring $ankle 1 ($numChar-2)`;
	string $side=`substring $ankle ($numChar-1) 99`;
	int $b=1;
	if ($side=="_L") $b=-1;
	$heelFitJoint=$toesFitJoint="";
	$reverseKnee=0;
	$tempString=`listRelatives -c -type joint $fitAnkle`;
	for ($y=0;$y<size($tempString);$y++)
		{
		string $label=`asLabel $tempString[$y]`;
		if (`gmatch $label "*Heel*"`)
			$heelFitJoint=$tempString[$y];
		if (`gmatch $label "*Toes*"`)
			$toesFitJoint=$tempString[$y];
		}
	if ($heelFitJoint=="")
		continue;
	if ($toesFitJoint!="")
		{
		$pos1=`xform -q -ws -t ($toesFitJoint+$side+"_middleProfile.cv[0]")`;
		$pos2=`xform -q -ws -t ($toesFitJoint+$side+"_middleProfile.cv[2]")`;
		if ($pos1[1]>$pos2[1])
			$reverseKnee=1;
		}
	float $anklePos[]=`xform -q -ws -t $ankleProfileEnds[$i]`;
	float $heelPos[]=`xform -q -ws -t $heelFitJoint`;
	if (`gmatch $ankleProfileEnds[$i] "*_R_*"`)
		{
		$cvs={0,1,4};
		if ($reverseKnee) $cvs={2,3};
		}
	else
		{
		$cvs={2,3};
		if ($reverseKnee) $cvs={0,1,4};
		}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -os -t ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t ($heelPos[0]*$b) $heelPos[1] $heelPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		move -r -os 0 0 $existingPos[2] ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $anklePos[0] $anklePos[1] $anklePos[2] 1.2 1.2 1 ($ankleProfileEnds[$i]+".cv["+$cvs[$y]+"]");
		}

	}

string $toeProfileMiddle[]=`ls -type transform "*Toes*Profile"`;
for ($i=0;$i<size($toeProfileMiddle);$i++)
	{
	$reverseKnee=0;
	$pos1=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv[0]")`;
	$pos2=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv[2]")`;
	if ($pos1[1]>$pos2[1])
		$reverseKnee=1;
	$transformPos=`xform -q -ws -t $toeProfileMiddle[$i]`;
	if (`gmatch $toeProfileMiddle[$i] "*_R_*"`)
		{
		$cvs={0,1,4};$oppositeCvs={2,3};
		if ($reverseKnee) {$cvs={2,3};$oppositeCvs={0,1,4};}
		}
	else
		{
		$cvs={2,3};$oppositeCvs={0,1,4};
		if ($reverseKnee) {$cvs={0,1,4};$oppositeCvs={2,3};}
		}
	for ($y=0;$y<size($cvs);$y++)
		{
		$existingPos=`xform -q -ws -t ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]")`;
		xform -ws -t $existingPos[0] 0 $existingPos[2] ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]");
		scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 1.2 1.2 1 ($toeProfileMiddle[$i]+".cv["+$cvs[$y]+"]"); 
		}
	for ($y=0;$y<size($oppositeCvs);$y++)
		{
		if (`gmatch $toeProfileMiddle[$i] "*_start*"`)
			scale -r -p $transformPos[0] $transformPos[1] $transformPos[2] 0.5 0.5 1 ($toeProfileMiddle[$i]+".cv["+$oppositeCvs[$y]+"]"); 
		}
	}
if (`objExists Neck_M_startCurve` && `objExists Chest_M_middleProfile`)
	{
	$sca1=`getAttr Chest_M_middleProfile.s`;
	$sca2=`getAttr Neck_M_middleProfile.s`;
	for ($i=0;$i<5;$i++)
		{
		$pos1=`xform -q -ws -t ("Neck_M_middleProfile.cv["+$i+"]")`;
		setAttr -type float3 Neck_M_middleProfile.s $sca1[0] $sca1[1] $sca1[2];
		$pos2=`xform -q -ws -t ("Neck_M_middleProfile.cv["+$i+"]")`;
		setAttr -type float3 Neck_M_middleProfile.s $sca2[0] $sca2[1] $sca2[2];
		xform -ws -t ($pos1[0]*1.1) (($pos1[1]+$pos2[1])/2.0) (($pos1[2]+$pos2[2])/2.0) ("Neck_M_startProfile.cv["+$i+"]");
		}
	}
}

global proc asCreateSliders ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";

if (`objExists closestSampler`)
	delete closestSampler;
if (!`objExists SlideSystem`)
	createNode -n SlideSystem -p MotionSystem transform;

int $sideFactor=1;
int $vtxNr[];
int $bendAxis;
float $widthFactor;
string $tempString[],$branchVtxs[],$branchVtxSliderNrs[];
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
for ($i=0;$i<size($sel);$i++)
	{
	if (`gmatch $sel[$i] "*_L_*"`)
		$sideFactor=-1;
	else
		$sideFactor=1;

	$bendAxis=0;//all directions
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];

	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$tempString=`listRelatives -type joint -p $parent`;
		$parent=$tempString[0];
		}
	$tempString=`listRelatives -type joint -p $deformJoint`;
	string $firstPa=$tempString[0];

	if ($skinCurveSliderInfo[1]=="")
		{
		print ("// Skipping "+$sel[$i]+", as it`s not defining start or end or middle of deformation\n");
		continue;
		}
	string $stEnMid=$skinCurveSliderInfo[1];
	if (`objExists ($deformJoint+"_"+$stEnMid+"Slider0")` || `objExists ($deformJoint+"_"+$stEnMid+"Slider1")`)
		continue;

	createNode -n messureTemp transform;
	pointConstraint $sel[$i] messureTemp;
	parent messureTemp $firstPa;
	if ($skinCurveSliderInfo[1]=="end")
		parent messureTemp $deformJoint;
	float $xOffset=`getAttr messureTemp.tx`;
	delete messureTemp;

	//create the 50joint
	int $baseStrucExists=0;
	if (`objExists ($deformJoint+"_Slide50")`)
		$baseStrucExists=1;
	if (!$baseStrucExists)
		{
		select $deformJoint;
		joint -n ($deformJoint+"_Slide50");
		sets -add DeformSet ($deformJoint+"_Slide50");
		setAttr ($deformJoint+"_Slide50.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide50") $firstPa;
		createNode -n ($deformJoint+"_Slide00") transform;
		parent ($deformJoint+"_Slide00") $deformJoint;
		setAttr -type float3 ($deformJoint+"_Slide00.t") 0 0 0;
		setAttr -type float3 ($deformJoint+"_Slide00.r") 0 0 0;
		setAttr ($deformJoint+"_Slide00.rotateOrder") `getAttr ($deformJoint+".rotateOrder")`;
		parent ($deformJoint+"_Slide00") $firstPa;
		duplicate -n ($deformJoint+"_Slide00Offset") ($deformJoint+"_Slide00");
		parent ($deformJoint+"_Slide00") ($deformJoint+"_Slide00Offset");
		$tempString=`orientConstraint ($deformJoint+"_Slide00") $deformJoint ($deformJoint+"_Slide50")`;
//		setAttr ($tempString[0]+".interpType") 2; //`shortest` seem to be stable
//	shortest works best on elbow that has twists
		$tempString=`pointConstraint $deformJoint ($deformJoint+"_Slide50")`;
		setAttr ($tempString[0]+".offsetX") ($sideFactor*$charHeight/5000);
		}

	//only 2 for elbow/knee, determine $bendAxis
	if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
		{
		float $jo[]=`getAttr ($deformJoint+".jointOrient")`; // check jointOrient to find bend axis
		if (abs($jo[1])>abs($jo[2])) $bendAxis=1;// .joY greater than .joZ, so not a Zbender
		if (abs($jo[2])>abs($jo[1])) $bendAxis=2;// .joZ greater than .joY, so not a Ybender
		}

	for ($y=0;$y<4;$y++)
		{
		//only 2 for elbow/knee, determine $bendAxis
		if (`gmatch $deformJoint "*Elbow*"` || `gmatch $deformJoint "*Knee*"`)
			{
			if ($bendAxis==1) if ($y==0 || $y==2) continue;
			if ($bendAxis==2) if ($y==1 || $y==3) continue;
			}
		if ($skinCurveSliderInfo[1]=="start") select $firstPa;
		if ($skinCurveSliderInfo[1]=="middle") select ($deformJoint+"_Slide50");
		if ($skinCurveSliderInfo[1]=="end") select $deformJoint;
		joint -n ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		sets -add ("DeformSet") ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		float $posA[3]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		float $posB[3]=`xform -q -ws -t ($sel[$i]+".cv["+($y+1)+"]")`;
		float $pos[3]={(($posA[0]+$posB[0])/2.0), (($posA[1]+$posB[1])/2.0), (($posA[2]+$posB[2])/2.0)};
		xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		$widthFactor=`getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".ty")`;
		$widthFactor=`abs($widthFactor)`;

		if (!$baseStrucExists)
			{
			// recylcle these between starters, enders, and middlers
			createNode -n ($deformJoint+"_SlideDist"+$y) distanceBetween	;
			createNode -n ($deformJoint+"_SlideStart"+$y) transform;
			createNode -n ($deformJoint+"_SlideEnd"+$y) transform;
//			connectAttr -f ($deformJoint+"_SlideStart"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point1");
			connectAttr -f ($deformJoint+"_SlideEnd"+$y+".t") ($deformJoint+"_SlideDist"+$y+".point2");
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideStart"+$y);
//			$tempString=`spaceLocator`;rename $tempString[0] ($deformJoint+"_SlideEnd"+$y);
//			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
//			setAttr -type float3 ($deformJoint+"_SlideEnd"+$y+".localScale") ($charHeight/120) ($charHeight/120) ($charHeight/120);
			parent ($deformJoint+"_SlideStart"+$y) $firstPa;
			parent ($deformJoint+"_SlideEnd"+$y) $firstPa;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideStart"+$y);
			xform -ws -t $pos[0] $pos[1] $pos[2] ($deformJoint+"_SlideEnd"+$y);		
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_Slide50");
			setAttr ($deformJoint+"_SlideEnd"+$y+".tx") 0;
			float $temp[3]=`getAttr ($deformJoint+"_SlideEnd"+$y+".t")`;
			float $mag=`mag <<$temp[0],$temp[1],$temp[2]>>`*$sideFactor;
			$temp[0]=`getAttr ($deformJoint+".tx")`;
			setAttr -type float3 ($deformJoint+"_SlideStart"+$y+".t") ($temp[0]-$mag) 0 0;
			parent ($deformJoint+"_SlideStart"+$y) SlideSystem;
			parent ($deformJoint+"_SlideEnd"+$y) ($deformJoint+"_SlideStart"+$y);
//			parentConstraint -mo $firstPa ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo $deformJoint ($deformJoint+"_SlideStart"+$y);
			parentConstraint -mo ($deformJoint+"_Slide50") ($deformJoint+"_SlideEnd"+$y);
			//behaviour
			createNode -n ($deformJoint+"_SlideDistNormalize"+$y) multiplyDivide;
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDist"+$y+".distance") ($deformJoint+"_SlideDistNormalize"+$y+".input1X");
			setAttr ($deformJoint+"_SlideDistNormalize"+$y+".input2X") `getAttr ($deformJoint+"_SlideDistNormalize"+$y+".input1X")`;
			}

		//they all share `_SlideMultiply` & `SlideReducer` & `_SlidePlusOffset`
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
		setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") $widthFactor;
		if ($skinCurveSliderInfo[1]=="start")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") ($widthFactor*-1);
		//on opposide side, the start and end must move opposite direction
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			setAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X") (`getAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input2X")`*$sideFactor);
		createNode -n ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y) multiplyDivide;
		addAttr -k 1 -ln slide -at double -dv 1 ($deformJoint+"_"+$stEnMid+"Slider"+$y);
		connectAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".slide") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input2X");
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".input1X");
		createNode -n ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y) plusMinusAverage;
		connectAttr ($deformJoint+"_"+$stEnMid+"SlideMultiply"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[0]");
		if ($skinCurveSliderInfo[1]=="start" || $skinCurveSliderInfo[1]=="end")
			{
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y) plusMinusAverage;
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".operation") 2;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[0]");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".input1D[1]") 1;

			connectAttr ($deformJoint+"_"+$stEnMid+"SlideMinusOne"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") $xOffset;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".tx");
			}
		if ($skinCurveSliderInfo[1]=="middle")
			{
			string $slideAxis="z";
			if ($bendAxis==2)
				$slideAxis="y";
			if (($bendAxis==0) && ($y==0 || $y==2))
				$slideAxis="y";
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y) reverse;
			connectAttr ($deformJoint+"_SlideDistNormalize"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".inputX");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y) condition;
			if (`getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`>0)
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 4;
			else
				setAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".operation") 2;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".firstTerm");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfFalseR");
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y) multiplyDivide;
			createNode -n ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y) multiplyDivide;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideReverse"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input1X");
			setAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".input2X") -1;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideTimesMinusOne"+$y+".outputX") ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".colorIfTrueR");
			connectAttr ($deformJoint+"_"+$stEnMid+"SlideAbsolutor"+$y+".outColorR") ($deformJoint+"_"+$stEnMid+"SlideReducer"+$y+".input1X");

			setAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".input1D[1]") `getAttr ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis)`;
			connectAttr ($deformJoint+"_"+$stEnMid+"SlidePlusOffset"+$y+".output1D") ($deformJoint+"_"+$stEnMid+"Slider"+$y+".t"+$slideAxis);

			}

		//skinning
		skinCluster -e -lw false -wt 0 -ai ($deformJoint+"_"+$stEnMid+"Slider"+$y) skinClusterSkinCage;
		float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$y) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
		if ($bendAxis==0) //all directions
			{
			if ($y>0) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+($y-1)) 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$y]+"]");
			if ($y==3) skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider3") 0.5 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[0]+"]");
			}
		if (($bendAxis==1 && $y==3) || ($bendAxis==2 && $y==2)) //last loop for Z or Ybender
			{
			int $pickupVtx=2;
			int $sliderNr=1;
			if ($bendAxis==2) {$pickupVtx=1;$sliderNr=0;}
			float $temp[]=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			$pickupVtx=4;
			$sliderNr=3;
			if ($bendAxis==2) {$pickupVtx=3;$sliderNr=2;}
			$temp=`xform -q -ws -t ($sel[$i]+".cv["+$pickupVtx+"]")`;
			setAttr closestSampler.inPosition $temp[0] $temp[1] $temp[2];
			$vtxNr[$pickupVtx]=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$sliderNr) 1 skinClusterSkinCage ("skinCage.vtx["+$vtxNr[$pickupVtx]+"]");
			}
		}

	//branchVtx`s edgeloopCheck to see if there`s a extra vtx, if so.. this is a `brancher`
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	$branchVtxSliderNrs=`asGetBranchedVtx $tempString 1`;
	for ($y=0;$y<size($branchVtxs);$y++)
		skinPercent -tv ($deformJoint+"_"+$stEnMid+"Slider"+$branchVtxSliderNrs[$y]) 1 skinClusterSkinCage $branchVtxs[$y];
	}

if (`objExists closestSampler`)
	delete closestSampler;
print "// Sliders created\n";
select $sel;
}

global proc string[] asGetBranchedVtx (string $inputVtxs[], int $vertsOrSliderNr)
{
string $return[],$branchVtxs[],$branchVtxSliderNrs[];
string $connectVtx0s[],$connectVtx1s[],$connectVtx2s[],$connectVtx3s[];
for ($y=0;$y<4;$y++)
	{
	select $inputVtxs[$y];
	ConvertSelectionToEdges;
	ConvertSelectionToVertices;
	select -d $inputVtxs[$y];
	$tempString=`ls -sl -fl`;
	if ($y==0) $connectVtx0s=$tempString;
	if ($y==1) $connectVtx1s=$tempString;
	if ($y==2) $connectVtx2s=$tempString;
	if ($y==3) $connectVtx3s=$tempString;
	}
for ($y=0;$y<size($connectVtx0s);$y++) {
	if (`stringArrayCount $connectVtx0s[$y] $connectVtx1s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=0;}
if (`stringArrayCount $connectVtx0s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx0s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=3;}}
for ($y=0;$y<size($connectVtx1s);$y++)
	if (`stringArrayCount $connectVtx1s[$y] $connectVtx2s`) {$branchVtxs[size($branchVtxs)]=$connectVtx1s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=1;}
for ($y=0;$y<size($connectVtx2s);$y++)
	if (`stringArrayCount $connectVtx2s[$y] $connectVtx3s`) {$branchVtxs[size($branchVtxs)]=$connectVtx2s[$y];$branchVtxSliderNrs[size($branchVtxSliderNrs)]=2;}
if ($vertsOrSliderNr)
	$return=$branchVtxSliderNrs;
else
	$return=$branchVtxs;
return $return;
}

global proc asDeleteSliders ()
{
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
int $error = 0;
if (!size($sel))
	$error = 1;
if (!`objExists skinClusterSkinCage` || !`objExists skinCage`)
	error "skinCage and skinClusterSkinCage not found";
for ($i=0;$i<size($sel);$i++)
	{
	if (!`gmatch $sel[$i] "*_*_*Profile*"`)
		$error = 1;
	}
if ($error)
		error "Select a SkinCage Profile Curve (red or green)";
createNode -n closestSampler closestPointOnMesh;
connectAttr -f skinCage.outMesh closestSampler.inMesh;
string $tempString[];
int $vtxNr[];
for ($i=0;$i<size($sel);$i++)
	{
	string $skinCurveSliderInfo[]=`asSkinCurveSliderInfo $sel[$i]`;
	string $deformJoint=$skinCurveSliderInfo[0];
	int $haveSliderJoint[4];
	for ($y=0;$y<4;$y++)
		{
		//skinning
		float $pos[]=`xform -q -ws -t $sel[$i]`;
		createNode -n closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker1;
		$pos=`xform -q -ws -t ($sel[$i]+".cv["+$y+"]")`;
		createNode -n closestSamplerShrinker2 -p closestSamplerShrinker1 transform;
		xform -ws -t $pos[0] $pos[1] $pos[2] closestSamplerShrinker2;
		$pos=`xform -q -ws -t closestSamplerShrinker2`;
		scale -r 0.832 0.832 0.832 closestSamplerShrinker1;
		setAttr closestSampler.inPosition $pos[0] $pos[1] $pos[2];
		$vtxNr[$y]=`getAttr closestSampler.closestVertexIndex`;
		delete closestSamplerShrinker1;
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage skinCage.vtx[$vtxNr[$y]];
		}
	//$branchVtxs
	select -cl;
	for ($y=0;$y<4;$y++) select -add ("skinCage.vtx["+$vtxNr[$y]+"]");
	$tempString=`ls -sl -fl`;
	$branchVtxs=`asGetBranchedVtx $tempString 0`;
	for ($y=0;$y<size($branchVtxs);$y++)
		{
		if ($skinCurveSliderInfo[1]=="middle")
			skinPercent -tv $skinCurveSliderInfo[0] 0.5 -tv $skinCurveSliderInfo[2] 0.5 skinClusterSkinCage $branchVtxs[$y];
		else
			skinPercent -tv $skinCurveSliderInfo[2] 1 skinClusterSkinCage $branchVtxs[$y];
		}
	//delete the joint
	for ($y=0;$y<4;$y++)
		if (`objExists ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y)`)
			delete ($skinCurveSliderInfo[0]+"_"+$skinCurveSliderInfo[1]+"Slider"+$y);

	//remove 50 system, if no longer required
	int $remove50=0;
	if (!`objExists ($skinCurveSliderInfo[0]+"_SlideDistNormalize1")`)
		{
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide50")`)
			delete ($skinCurveSliderInfo[0]+"_Slide50");
		if (`objExists ($skinCurveSliderInfo[0]+"_Slide00")`)
			delete ($skinCurveSliderInfo[0]+"_Slide00");
		for ($y=0;$y<4;$y++)
			if (`objExists ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y)`)
				delete ($skinCurveSliderInfo[0]+"_"+"SlideStart"+$y);
		}
	}
if (`objExists closestSampler`)
	delete closestSampler;
select -cl;
}

global proc string asListParent (string $obj)
{
string $tempString[]=`listRelatives -type joint -p $obj`;
return $tempString[0];
}

global proc string[] asListChildren (string $obj)
{
int $skip,$skipChildrenToo;
string $fitJoint;
string $return[];
string $tempString[]=`listRelatives -type joint -c $obj`;
string $tempString2[];
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	$skip=$skipChildrenToo=0;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempString[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skipChildrenToo=1;
	tokenize $tempString[$i] "_" $tempString2;
	$fitJoint=$tempString2[0];
	if (`attributeExists noSkin $fitJoint`)
		if (`getAttr ($fitJoint+".noSkin")`)
			{
			$skip=1;
			$skipChildrenToo=1;
			}

	if ($skip)
		{
		if (!$skipChildrenToo)
			{
			$tempString2=`listRelatives -type joint -c $tempString[$i]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$skip=0;
				for ($y=0;$y<size($skips);$y++)
					if (`gmatch $tempString2[$z] ("*"+$skips[$y]+"*")`)
						$skip=1;
				if (!$skip)
					$return[size($return)]=$tempString2[$z];
				}
			}
		}
	else
		if ($tempString[$i]!="")
			$return[size($return)]=$tempString[$i];
	}
return $return;
}

global proc string[] asListAllDecents (string $obj)
{
int $skip;
string $fitJoint;
string $return[],$tempString2[],$tempString3[];
string $tempString[]=`listRelatives -type joint -ad $obj`;
string $tempStringFullPath[]=`listRelatives -type joint -ad -f $obj`;
string $skips[]={"Slider[0-9]","Slide50","Cup_","Scapula_","ThumbFinger1_","FootSideOuter_","FootSideInner_","Heel_","Jaw_","Eye_","_50","Float","Part[0-9]_","Part[0-9][0-9]_"};
string $skipsChildrenToo[]={"PinkyToe_","BigToe_","Jaw_","JawEnd_","Eye_","Eye[0-9]_","_50","Float"};
for ($i=0;$i<size($tempString);$i++)
	{
	if (size(`ls $tempString[$i]`)>1)
		$tempString[$i]=$tempStringFullPath[$i];
	$skip=0;
	for ($y=0;$y<size($skips);$y++)
		if (`gmatch $tempString[$i] ("*"+$skips[$y]+"*")`)
			$skip=1;
	for ($y=0;$y<size($skipsChildrenToo);$y++)
		if (`gmatch $tempStringFullPath[$i] ("*"+$skipsChildrenToo[$y]+"*")`)
			$skip=1;

	tokenize $tempString[$i] "_" $tempString2;
	$fitJoint=$tempString2[0];
	clear $tempString2;
	if (`objExists $fitJoint`)
		$tempString2=`ls -l $fitJoint`;
	tokenize $tempString2[0] "|" $tempString3;
	for ($y=0;$y<size($tempString3);$y++)
		if (`attributeExists noSkin $tempString3[$y]`)
			if (`getAttr ($tempString3[$y]+".noSkin")`)
				$skip=1;

	if (`attributeExists noSkin $fitJoint`)
		if (`getAttr ($fitJoint+".noSkin")`)
			$skip=1;


	if (!$skip)
		$return[size($return)]=$tempString[$i];
	}
return $return;
}

global proc asAnalyzeChainJoints (string $firstJoint)
{
string $kids[]=`asListChildren $firstJoint`;
string $chainJoints[],$tempString[];
clear $chainJoints;
float $pos[3];

//If $firstJoint is "*Part[0-9]*", then downscan until solid firstJoint
if (`gmatch $firstJoint "*Part[0-9]*"`)
	{
	string $child=$firstJoint;
	for ($i=0;$i<99;$i++)
		{
		$tempString=`asListChildren $child`;
		$child=$tempString[0];
		if (!`gmatch $child "*Part[0-9]*"`)
			break;
		}
	$firstJoint=$child;
	clear $kids;
	$kids=`asListChildren $firstJoint`;
	}


while(size($kids)==1)
	{
	if (size($chainJoints)==0)
		$chainJoints[size($chainJoints)]=$firstJoint;
	if (!`gmatch $kids[0] "*Part[0-9]*"`)
		$chainJoints[size($chainJoints)]=$kids[0];
	$tempString=`asListChildren $kids[0]`;
	clear $kids;
	for ($y=0;$y<size($tempString);$y++)
			$kids[size($kids)]=$tempString[$y];
	}

if (size($kids)>1)
	for ($y=0;$y<size($kids);$y++)
		asAnalyzeChainJoints $kids[$y];

//Root exception
if ($chainJoints[0]=="Spine1_M")
	stringArrayInsertAtIndex(0, $chainJoints, "Root_M");

if (size($chainJoints))
	if (!`objExists ($chainJoints[0]+"_middleCurve")`)
		asBuildChainCurves $chainJoints;
}

global proc asBuildChainCurves (string $chainJoints[])
{
int $childIsTwistJoint,$twistJointNr,$inbetweenJoints;
int $firstChildMinusX[],$spineJoint[],$terminator[],$topJoint[],$downTwist[],$upTwist[];
float $twistAmount,$rotXoffSet;
float $charHeight=`asgetCharHeight`;
string $curve,$startCurve,$endCurve,$twistCurve,$surface,$poly,$parent,$parentChainJoint,$childChainJoint,$twistJoint,$skinToJoint,$fitJoint;
string $tempString[],$tempString2[],$children[],$siblings[],$curves[],$startCurves[],$middleCurves[],$endCurves[],$twistCurves[];
float $scale;
float $pos1[],$pos2[],$pos3[];

//if (size($chainJoints)==1)
//	return;
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (`gmatch $chainJoints[$i] "Head_M"` || `gmatch $chainJoints[$i] "Hair_M"` || `gmatch $chainJoints[$i] "Root_M"` || `gmatch $chainJoints[$i] "Spine*_M"` || `gmatch $chainJoints[$i] "Chest_M"` || `gmatch $chainJoints[$i] "Tail*_M"`)
		$spineJoint[$i]=1;
	$tempString=`asListChildren $chainJoints[$i]`;
	if (size($tempString))
		if (`getAttr ($tempString[0]+".tx")`<0)
			$firstChildMinusX[$i]=1;
	if (size($tempString)==0)
		$terminator[$i]=1;
	if (`asListParent $chainJoints[$i]`=="")
		$topJoint[$i]=1;
	}

//Middlecurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	$middleCurve=$chainJoints[$i]+"_middleCurve";
	$middleCurves[size($middleCurves)]=$middleCurve;
	asCreateMeshCurve $middleCurve;
	$profileCurve=`substitute "Curve" $middleCurve "Profile"`;
	$scale=$charHeight/40;
	if (`gmatch $chainJoints[$i] "Wrist_*"`)
		$scale=$charHeight/80;
	if (`gmatch $chainJoints[$i] "Elbow_*"`)
		$scale=$charHeight/60;
	if (`gmatch $chainJoints[$i] "*Finger*"`)
		$scale=$charHeight/140;
	if ($spineJoint[$i])
		$scale=$charHeight/15;
	xform -os -s $scale $scale $scale $profileCurve;

	asAlign $profileCurve $chainJoints[$i] 1 1 0 0;
	if ($terminator[$i])
		asAlign $profileCurve `asListParent $chainJoints[$i]` 0 1 0 0;
	parent $profileCurve MeshCurves;
	editDisplayLayerMembers -noRecurse SkinCurves1 $profileCurve;

	refresh;
	}

//Find x-angle difference, to detect changes such as reversed-knees
for ($i=0;$i<size($chainJoints)-1;$i++)
	{
	spaceLocator -n tempLoc;
	parent tempLoc ($chainJoints[$i]+"_middleProfile");
	xform -os -t 0 0 0 -ro 0 0 0 tempLoc;
	aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $chainJoints[$i+1] $chainJoints[$i+1] tempLoc;
	$rotXoffSet=`getAttr tempLoc.rx`;
	delete tempLoc;
	if (!`gmatch $chainJoints[$i+1] "*_L"`)
		if ($rotXoffSet>90 || $rotXoffSet<-90)
			{
			print ("// Flip in jointChain detected, un-flipping skinCage: "+$chainJoints[$i+1]+" : "+$rotXoffSet+"\n");
			rotate -r -eu ($rotXoffSet*-1) 0 0 ($chainJoints[$i+1]+"_middleProfile");
			}
	}

//Twistcurves (includes partialJoints)
for ($i=0;$i<size($chainJoints);$i++)
	{
	$childIsTwistJoint=1;
	$joint=$chainJoints[$i];
	tokenize $joint "_" $tempString;
	$fitJoint=$tempString[0];
	$inbetweenJoints=2;
	if (`attributeExists inbetweenJoints $fitJoint`)
		$inbetweenJoints=`getAttr ($fitJoint+".inbetweenJoints")`;
	$twistJointNr=1;
	while($childIsTwistJoint)
		{
		$childIsTwistJoint=0;
		$tempString=`asListChildren $joint`;
		$twistJoint=$tempString[0];
		for ($y=0;$y<size($tempString);$y++)
			if (`gmatch $tempString[$y] "*Part[0-9]*"`)
				$twistJoint=$tempString[$y];
		$joint=$twistJoint;
//		if (`gmatch $joint "*Part[0-9]*"` && `attributeExists twistAmount $joint`)
		if (`gmatch $joint "*Part[0-9]*"`)
			$childIsTwistJoint=1;
		else
			break;
		if ($childIsTwistJoint)
			{
			$downTwist[$i]=$downTwist[$i]+1;
			$twistCurve=$chainJoints[$i]+"_twistCurve"+$downTwist[$i];
			$twistCurves[size($twistCurves)]=$twistCurve;
			asCreateMeshCurve $twistCurve;
			$profileCurve=`substitute "Curve" $twistCurve "Profile"`;
			createNode -n ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") transform;
			parent ($chainJoints[$i]+"_twistProfile"+$downTwist[$i]) ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			parent ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") MeshCurves;
			editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
			asAlign ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset") $twistJoint 1 1 0 0;
			$twistAmount=0.5;
			if (`attributeExists twistAmount $twistJoint`)
				$twistAmount=`getAttr ($twistJoint+".twistAmount")`*1;
			else if (`objExists ("FKX"+$twistJoint+"_orientConstraint1")`)
				{
//actually.. cant take inbetweenamount as twistAmount, cause inbetween "adds up to 1", before reacing the end
//				$tempString=`listAttr -ud ("FKX"+$twistJoint+"_orientConstraint1")`;
//				$twistAmount=`getAttr ("FKX"+$twistJoint+"_orientConstraint1."+$tempString[0])`;
				$twistAmount=(1.0/($inbetweenJoints+1))*$twistJointNr;
				}
			pointConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			pointConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w (1-$twistAmount) ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			scaleConstraint -w $twistAmount ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_twistCurve"+$downTwist[$i]+"Offset");
			}
		$twistJointNr++;
		}
	if ($i>0 && $downTwist[$i-1])
		$upTwist[$i]=$downTwist[$i-1];
	}

//Startcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		$startCurve=$chainJoints[$i]+"_startCurve";
		$startCurves[size($startCurves)]=$startCurve;
		asCreateMeshCurve $startCurve;
		$profileCurve=`substitute "Curve" $startCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_startCurveOffset") transform;
		parent ($chainJoints[$i]+"_startProfile") ($chainJoints[$i]+"_startCurveOffset");
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_startCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_startCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_startCurveOffset") MeshCurves;
		//first startCurve
		if ($i==0)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_startProfile.tx") 0.482;
			else
				setAttr ($chainJoints[$i]+"_startProfile.tx") -0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
		if ($i>0)
			{
			pointConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i-1]+"_middleCurve") ($chainJoints[$i]+"_startCurveOffset");
			}
		}
	}

//Endcurves
for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		$endCurve=$chainJoints[$i]+"_endCurve";
		$endCurves[size($endCurves)]=$endCurve;
		asCreateMeshCurve $endCurve;
		$profileCurve=`substitute "Curve" $endCurve "Profile"`;
		createNode -n ($chainJoints[$i]+"_endCurveOffset") transform;
		parent ($chainJoints[$i]+"_endProfile") ($chainJoints[$i]+"_endCurveOffset");
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		editDisplayLayerMembers -noRecurse SkinCurves2 $profileCurve;
		parent ($chainJoints[$i]+"_endCurveOffset") ($chainJoints[$i]+"_middleCurve");
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.t") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.r") 0 0 0;
		setAttr -type float3 ($chainJoints[$i]+"_endCurveOffset.s") 1 1 1;
		parent ($chainJoints[$i]+"_endCurveOffset") MeshCurves;
		//last endCurve
		if ($i==size($chainJoints)-1)
			{
			if ($firstChildMinusX[$i])
				setAttr ($chainJoints[$i]+"_endProfile.tx") -0.482;
			else
				setAttr ($chainJoints[$i]+"_endProfile.tx") 0.482;
			}
		pointConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		scaleConstraint -w 0.75 ($chainJoints[$i]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
		if ($i<size($chainJoints)-1)
			{
			pointConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			scaleConstraint -w 0.25 ($chainJoints[$i+1]+"_middleCurve") ($chainJoints[$i]+"_endCurveOffset");
			}
		}
	}

for ($i=0;$i<size($chainJoints);$i++)
	{
	if (!$terminator[$i] && !$spineJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_startCurve";
	$curves[size($curves)]=$chainJoints[$i]+"_middleCurve";
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		$curves[size($curves)]=$chainJoints[$i]+"_endCurve";
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		$curves[size($curves)]=$chainJoints[$i]+"_twistCurve"+$y;


	//branch
	$children=`asListChildren $chainJoints[$i]`;
	$tempString[0]=`asListParent $chainJoints[$i]`;
	$parent=$tempString[0];
	if ($parent!="")
		$siblings=`asListChildren $parent`;
	if (!(size($children)>1 || size($siblings)>1))
		continue;
	}

$surface=$chainJoints[0]+"_surface";
$poly=$chainJoints[0]+"_poly";
if (size($chainJoints)==1)
		extrude -n $surface -ch 1 -rn false -po 0 -et 0 -upn 1 -length ($charHeight/-250) -rotation 0 -scale 1 -dl 3 $curves;
else
	loft -n $surface -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 0 -rsn true $curves;
parent $surface NurbsGeometry;
nurbsToPoly -n $poly -mnd 1 -ch 1 -f 3 -pt 0 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 1 -un 3 -vt 1 -vn 3 -uch 0 -ucr 0 -cht 0 -es 0 -ntr 0 -mrt 0 -uss 1 $surface;
polySoftEdge -angle 0 -ch 1 $poly;
if (`gmatch $chainJoints[0] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $poly;
//polyMergeVertex -d 0.01 -am 1 -ch 1 $poly;
polyMergeVertex -d 0.0001 -am 1 -ch 1 $poly;
//displaySmoothness -polygonObject 3;
duplicate -n ($poly+"_copy") $poly;
parent $poly MeshGeometry;

//Create SkinCluster
select $chainJoints;
//include parentJoint
$tempString=`listRelatives -type joint -p $chainJoints[0]`;
if (size($tempString))
	select -add $tempString[0];
//deselect endJoints
for ($i=0;$i<size($chainJoints);$i++)
	{
	$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
	if (!`size($tempString)`)
		select -d $chainJoints[$i];
	}
for ($i=0;$i<size($tempString);$i++)
	{
	$tempString2=`listRelatives -type joint -c $tempString[$i]`;
	if (size($tempString2))
		select -add $tempString[$i];
	}
//include twistJoints
for ($i=0;$i<size($chainJoints);$i++)
	for ($y=1;$y<$downTwist[$i]+1;$y++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		select -add ($tempString[0]+"Part"+$y+"_"+$tempString[1]);
		}
//include 50`s
for ($i=0;$i<size($chainJoints);$i++)
	if (`objExists ($chainJoints[$i]+"_50")`)
		select -add ($chainJoints[$i]+"_50");
select -add $poly;
newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false";

float $temp[3];
int $vertIndex;
if (`objExists closestSampler`)
	delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($poly+"Shape.outMesh") closestSampler.inMesh;
$tempString=`listConnections ($poly+"Shape.inMesh")`;
string $skinCluster=$tempString[0];

//Skinning cylinders
for ($i=0;$i<size($chainJoints);$i++)
	{
	//Middlecurves
	for ($y=0;$y<4;$y++)
		{
		$temp=`xform -q -ws -t ($chainJoints[$i]+"_middleCurve.cv["+$y+"]")`;
		setAttr closestSampler.inPositionX $temp[0];
		setAttr closestSampler.inPositionY $temp[1];
		setAttr closestSampler.inPositionZ $temp[2];
		$vertIndex=`getAttr closestSampler.closestVertexIndex`;
		$skinToJoint=$chainJoints[$i];
		$tempString=`listRelatives -type joint -c $chainJoints[$i]`;
		if (!`size($tempString)`)
			{
			$tempString2=`listRelatives -type joint -p $chainJoints[$i]`;
			if (`size($tempString2)`)
				$skinToJoint=$tempString2[0];
			}

		skinPercent -tv $skinToJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		$tempString=`listRelatives -type joint -p $chainJoints[$i]`;
		if (!$spineJoint[$i])
			if (size($tempString))
				if ($skinToJoint==$chainJoints[$i])
					skinPercent -tv $tempString[0] 0.5 $skinCluster ($poly+".vtx["+$vertIndex+"]");

		if (`objExists ($chainJoints[$i]+"_50")`)
			skinPercent -tv ($chainJoints[$i]+"_50") 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
		}

	//Twistcurves
	for ($z=1;$z<$downTwist[$i]+1;$z++)
		{
		tokenize $chainJoints[$i] "_" $tempString;
		$twistJoint=$tempString[0]+"Part"+$z+"_"+$tempString[1];
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_twistCurve"+$z+".cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $twistJoint 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}

		}

	//Startcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$topJoint[$i] && !$upTwist[$i] && (size($chainJoints)>1) && !`attributeExists noStartCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_startCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			if ($i>0)
				skinPercent -tv $chainJoints[$i-1] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			else
				{
				$tempString=`listRelatives -type joint -p $chainJoints[0]`;
				skinPercent -tv $tempString[0] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
				}
			}
		}
	//Endcurves
	if (!$terminator[$i] && !$spineJoint[$i] && !$downTwist[$i] && (size($chainJoints)>1) && !`attributeExists noEndCurve $chainJoints[0]`)
		{
		for ($y=0;$y<4;$y++)
			{
			$temp=`xform -q -ws -t ($chainJoints[$i]+"_endCurve.cv["+$y+"]")`;
			setAttr closestSampler.inPositionX $temp[0];
			setAttr closestSampler.inPositionY $temp[1];
			setAttr closestSampler.inPositionZ $temp[2];
			$vertIndex=`getAttr closestSampler.closestVertexIndex`;
			skinPercent -tv $chainJoints[$i] 1 $skinCluster ($poly+".vtx["+$vertIndex+"]");
			}
		}
	}
if (size($children)==0)
	{
	$endJoint=$chainJoints[size($chainJoints)-1];
	polyPlane -n ($endJoint+"_cap_copy") -w 1 -h 1 -sx 1 -sy 1 -ax 1 0 0 -cuv 2 -ch 0;
	if (`gmatch $endJoint "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($endJoint+"_cap_copy");
	setAttr -type float3 ($endJoint+"_cap_copy.s") ($scale*2*(1/1.2)) ($scale*2*(1/1.2)) ($scale*2*(1/1.2));
	asAlign ($endJoint+"_cap_copy") $endJoint 1 1 0 0;
	asAlign ($endJoint+"_cap_copy") `asListParent $endJoint` 0 1 0 0;
	}
}

global proc asCreateMeshCurve (string $curve)
{
$tempString[0]=`curve -d 1 -p 0 -1 1 -p 0 1 1 -p 0 1 -1 -p 0 -1 -1 -p 0 -1 1`;
rename $tempString[0] $curve;
reverseCurve -ch 0 -rpo 1 $curve;
$profileCurve=`substitute "Curve" $curve "Profile"`;
duplicate -n $profileCurve $curve;
sets -add SkinCageCurvesSet $profileCurve;
scale -r 1.2 1.2 1.2 $profileCurve;
parent $curve $profileCurve;
connectAttr ($profileCurve+".worldSpace[0]") ($curve+".create");
setAttr ($curve+".v") 0;
}

global proc asCreateBranchBoxes ()
{
int $sortedNr[],$closestParentCvs[],$closestChildCvs[],$furthestParentCvs[],$furthestChildCvs[];
int $tempInt,$hasRChild,$hasLChild,$vtxNr;
string $parentCurve,$firstChild,$nextChild,$polyCreateFacetCmd,$backFront,$spreadMostAxis;
string $tempString[],$tempString2[],$children[],$childrenCurves[],$sortedChildren[];
float $minX,$maxX,$minY,$maxY,$minZ,$maxZ,$min,$dist;
float $pos[3],$pos1[3],$pos2[3],$childPos[3],$deltaPos[3],$spreadMostVector[3],$cubePos[3],$temp[3],$temp2[3];
float $Xs[],$Ys[],$Zs[],$sortValues[],$sortedValues[];
string $joints[]=`asListAllDecents DeformationSystem`;

for ($i=0;$i<size($joints);$i++)
	{
	$tempString=`asListChildren $joints[$i]`;
	if (size($tempString)<2) // branching only with 2 or more children
		continue;

	if ($joints[$i]=="Root_M" && !`objExists Root_M_middleCurve`)
		asBuildChainCurves {"Root_M"};

	//find $children
	clear $children;
	clear $sortedChildren;
	clear $childrenCurves;
	for ($y=0;$y<size($tempString);$y++) // child with no child of it`s own, is not a branch
		{
		$tempString2=`asListChildren $tempString[$y]`;
		if (size($tempString2))
			$children[size($children)]=$tempString[$y];
		}

	if (size($children)<2) // branching only with 2 or more children (check again, now that `false` children has been removed)
		continue;

	//For the Root, drop Spine as child
	if ($joints[$i]=="Root_M" && `stringArrayCount "Spine1_M" $children`)
		$children=`stringArrayRemove {"Spine1_M"} $children`;

	//find $spreadMostVector
	$minX=99;$minY=99;$minZ=99;
	$maxX=-99;$maxY=-99;$maxZ=-99;
	for ($y=0;$y<size($children);$y++)
		{
//		$temp=`xform -q -ws -t $children[$y]`;
		$temp=`getAttr ($children[$y]+".t")`;
		if ($tempString[0]!=$joints[$i])//might not be `direct` child
			{
			createNode -n tempTransform -p $joints[$i] transform;
			asAlign tempTransform $children[$y] 1 0 0 0;
			$temp=`getAttr tempTransform.t`;
			delete tempTransform;
			}
		if ($temp[0]<$minX) $minX=$temp[0];
		if ($temp[0]>$maxX) $maxX=$temp[0];
		if ($temp[1]<$minY) $minY=$temp[1];
		if ($temp[1]>$maxY) $maxY=$temp[1];
		if ($temp[2]<$minZ) $minZ=$temp[2];
		if ($temp[2]>$maxZ) $maxZ=$temp[2];
		}
	$xDif=$maxX+abs($minX);$yDif=$maxY+abs($minY);$zDif=$maxZ+abs($minZ);

	if ($yDif>$zDif) {$spreadMostVector={0,1,0};$spreadMostAxis="y";}
	if ($zDif>$yDif) {$spreadMostVector={0,0,1};$spreadMostAxis="z";}


	//sort children (by distance between themselves)
	for ($y=0;$y<size($children);$y++)
		{
//		$temp=`xform -q -ws -t $children[$y]`;
		$temp=`getAttr ($children[$y]+".t")`;
		$tempString=`listRelatives -p $children[$y]`;
		if ($tempString[0]!=$joints[$i])//might not be `direct` child
			{
			createNode -n tempTransform -p $joints[$i] transform;
			asAlign tempTransform $children[$y] 1 0 0 0;
			$temp=`getAttr tempTransform.t`;
			delete tempTransform;
			}
		$Xs[$y]=$temp[0];$Ys[$y]=$temp[1];$Zs[$y]=$temp[2];
		}
	$min=999;
	if ($spreadMostVector[0]) $sortValues=$Xs;
	if ($spreadMostVector[1]) $sortValues=$Ys;
	if ($spreadMostVector[2]) $sortValues=$Zs;

	for ($y=0;$y<size($children);$y++)
		{
		$sortedValues=`sort $sortValues`;
		}
	for ($y=0;$y<size($sortedValues);$y++)
		{
		for ($z=0;$z<size($children);$z++)
			if ($sortValues[$z]==$sortedValues[$y])
				$sortedChildren[$y]=$children[$z];
		}

	//find $parentCurve
	$parentCurve=$joints[$i]+"_middleCurve";
	if (`objExists ($joints[$i]+"_endCurve")`)
		$parentCurve=($joints[$i]+"_endCurve");

	//find $childrenCurves
	for ($y=0;$y<size($sortedChildren);$y++)
		{
		if (`objExists ($sortedChildren[$y]+"_startCurve")`)
			$childrenCurves[size($childrenCurves)]=$sortedChildren[$y]+"_startCurve";
		else if (`objExists ($sortedChildren[$y]+"_middleCurve")`)
			$childrenCurves[size($childrenCurves)]=$sortedChildren[$y]+"_middleCurve";
		}

	//aimed $childrenCurves
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		duplicate -n ($childrenCurves[$y]+"TempAimed") $childrenCurves[$y];
		parent -w ($childrenCurves[$y]+"TempAimed");
		float $aimVec[]={1,0,0};
//		if (`gmatch ($childrenCurves[$y]) "*_L_*"`)
		if (!`gmatch $joints[$i] "*_L"` && `gmatch $childrenCurves[$y] "*_L_*"`)
			$aimVec={-1,0,0};

		if ($joints[$i]=="Root_M")
			$aimVec[0]=$aimVec[0]*-1;

		createNode -n ($childrenCurves[$y]+"TempAimedTarget") transform;
		parent ($childrenCurves[$y]+"TempAimedTarget") $childrenCurves[$y];
		xform -os -t 1 0 0 -ro 0 0 0 ($childrenCurves[$y]+"TempAimedTarget");
//		$tempString=`aimConstraint -aimVector $aimVec[0] $aimVec[1] $aimVec[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $aimAt $aimAt ($childrenCurves[$y]+"TempAimed")`;
		$tempString=`aimConstraint -aimVector $aimVec[0] $aimVec[1] $aimVec[2] -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $joints[$i] ($childrenCurves[$y]+"TempAimedTarget") ($childrenCurves[$y]+"TempAimed")`;
		delete $tempString[0];
		}

	if ($spreadMostAxis=="x")//not real
		{
		$closestParentCvs[0]=1;
		$closestParentCvs[1]=2;
		$closestChildCvs[0]=1;
		$closestChildCvs[1]=2;
		}
	if ($spreadMostAxis=="y")//e.g. wrist
		{
		$closestParentCvs[0]=0;
		$closestParentCvs[1]=1;
		$closestChildCvs[0]=0;
		$closestChildCvs[1]=1;
		}
	if ($spreadMostAxis=="z")//e.g. chest
		{
		$closestParentCvs[0]=1;
		$closestParentCvs[1]=2;
		$closestChildCvs[0]=1;
		$closestChildCvs[1]=2;
		}

	//sideFace1
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$pos2=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$pos3=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
	$pos4=`xform -q -ws -t ($childrenCurves[0]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchStart -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $childrenCurves[0] "*_L_*"` && `gmatch $joints[$i] "*_L*"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($joints[$i]+"_branchStart");

	//child2childFace`s
	int $childACv[]=`asCvFlip $closestChildCvs`;
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		$pos3=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos4=`xform -q -ws -t ($childrenCurves[$y+1]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branch"+$y+" -ch 0 -tx 1 -s 1";
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
		$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
		eval ($polyCreateFacetCmd);
		if (`gmatch $childrenCurves[$y] "*_L_*"` && `gmatch $joints[$i] "*_L"`)
			polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($joints[$i]+"_branch"+$y);
		}

	//sideFace2
	int $childACv2[]=`asCvFlip $closestParentCvs`;
	int $lastChildNr=size($childrenCurves)-1;
	$pos1=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[1]+"]")`;
	$pos2=`xform -q -ws -t ($childrenCurves[$lastChildNr]+"TempAimed.cv["+$childACv[0]+"]")`;
	$pos3=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$pos4=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchEnd -ch 0 -tx 1 -s 1";
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
	$polyCreateFacetCmd+=" -p "+$pos3[0]+" "+$pos3[1]+" "+$pos3[2];
	$polyCreateFacetCmd+=" -p "+$pos4[0]+" "+$pos4[1]+" "+$pos4[2];
	eval ($polyCreateFacetCmd);
	if (`gmatch $childrenCurves[$lastChildNr] "*_L_*"` && `gmatch $joints[$i] "*_L"`)
		polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchEnd");

	//backFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchBack -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[1]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[1]+"]")`;
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[1]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);

	//frontFace n-sided
	$polyCreateFacetCmd="polyCreateFacet -n "+$joints[$i]+"_branchFront -ch 0 -tx 1 -s 1";
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$closestParentCvs[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	for ($y=0;$y<size($childrenCurves);$y++)
		{			
		$pos1=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$closestChildCvs[0]+"]")`;
		$pos2=`xform -q -ws -t ($childrenCurves[$y]+"TempAimed.cv["+$childACv[0]+"]")`;
		$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
		$polyCreateFacetCmd+=" -p "+$pos2[0]+" "+$pos2[1]+" "+$pos2[2];
		}
	$pos1=`xform -q -ws -t ($parentCurve+".cv["+$childACv2[0]+"]")`;
	$polyCreateFacetCmd+=" -p "+$pos1[0]+" "+$pos1[1]+" "+$pos1[2];
	eval ($polyCreateFacetCmd);
	polyNormal -normalMode 0 -userNormalMode 0 -ch 0 ($joints[$i]+"_branchFront");

	//polySplit
	for ($a=0;$a<2;$a++)
		{
		if ($a==0) $backFront="Back";
		if ($a==1) $backFront="Front";
		for ($y=1;$y<size($childrenCurves)-1;$y++)
			{
			$vtxNr=0;
			$pos1=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx[0]")`;
			$pos2=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx[99]")`;
			$pos=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+1)+"]")`;
			if (`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>` < `mag<<$pos1[0]-$pos[0],$pos1[1]-$pos[1],$pos1[2]-$pos[2]>>`)
				$vtxNr=99;
			polyConnectComponents -ch 0 ($joints[$i]+"_branch"+$backFront+".vtx["+$vtxNr+"]") ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+1)+"]");
			$pos=`xform -q -ws -t ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+2)+"]")`;
			if (`mag<<$pos2[0]-$pos[0],$pos2[1]-$pos[1],$pos2[2]-$pos[2]>>` < `mag<<$pos1[0]-$pos[0],$pos1[1]-$pos[1],$pos1[2]-$pos[2]>>`)
				$vtxNr=99;
			polyConnectComponents -ch 0 ($joints[$i]+"_branch"+$backFront+".vtx["+$vtxNr+"]") ($joints[$i]+"_branch"+$backFront+".vtx["+(($y*2)+2)+"]");
			}
		}

	//polyUnite branch-bits
	select ($joints[$i]+"_branchStart") ($joints[$i]+"_branchEnd") ($joints[$i]+"_branchFront") ($joints[$i]+"_branchBack");
	for ($y=0;$y<size($childrenCurves)-1;$y++)
		select -add ($joints[$i]+"_branch"+$y);
	polyUnite -n ($joints[$i]+"_branch") -ch 0 -mergeUVSets 1;

	//wireDeform into place
	wire -n ($joints[$i]+"_branchWire") -dds 0 0.001 -gw false -en 1.0 -ce 0.0 -li 0.0 ($joints[$i]+"_branch");
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		select ($childrenCurves[$y]+"TempAimed");
		select -add ($joints[$i]+"_branch");
		AddWire;
		setAttr ($joints[$i]+"_branchWire.dropoffDistance["+$y+"]") 0.001;
		}
	for ($y=0;$y<size($childrenCurves);$y++)
		{
		pointConstraint $childrenCurves[$y] ($childrenCurves[$y]+"TempAimed");
//		orientConstraint $childrenCurves[$y] ($childrenCurves[$y]+"TempAimed");
		parent  ($childrenCurves[$y]+"TempAimed") $childrenCurves[$y];
		//round to nearest 90
		$temp[0]=`getAttr ($childrenCurves[$y]+"TempAimed.rx")`;
		$temp[0]=$temp[0]/90.0;
		$temp[0]=trunc($temp[0]+0.5);
		$temp[0]=$temp[0]*90;
		setAttr ($childrenCurves[$y]+"TempAimed.rx") $temp[0];
		}

	//cleanup
	select ($joints[$i]+"_branch");
	DeleteHistory;
	for ($y=0;$y<size($childrenCurves);$y++)
		delete ($childrenCurves[$y]+"TempAimed") ($childrenCurves[$y]+"TempAimedTarget") ($childrenCurves[$y]+"TempAimedBaseWire");
	}
}

global proc int[] asCvFlip (int $vc[])
{
int $flipCv[]=$vc;
if ($vc[0]==0 && $vc[1]==1) $flipCv={3,2};
if ($vc[0]==1 && $vc[1]==0) $flipCv={2,3};

if ($vc[0]==2 && $vc[1]==3) $flipCv={1,0};
if ($vc[0]==3 && $vc[1]==2) $flipCv={0,1};

if ($vc[0]==1 && $vc[1]==2) $flipCv={0,3};
if ($vc[0]==2 && $vc[1]==1) $flipCv={3,0};

if ($vc[0]==0 && $vc[1]==3) $flipCv={1,2};
if ($vc[0]==3 && $vc[1]==0) $flipCv={2,1};
return $flipCv;
}

global proc asCopySkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinCage`)
	return;
string $sel[]=`ls -sl`;
int $isComponents=0;
source removeUnusedInfluences;
int $hasSkinCluster,$skinningMethod;
string $skinCluster;
string $selObjs[],$shapes[],$history[],$joints[],$tempString[];

if (`gmatch $sel[0] "*[.]*"`) 
    $isComponents=1;
if ($isComponents)
    {
    $tempString=`ls -sl -o`;
    $selObjs=`listRelatives -p $tempString[0]`;
    }
else
    $selObjs=$sel;

$history=`listHistory -pdo 1 skinCage`;
for ($y=0;$y<size($history);$y++)
	if (`nodeType $history[$y]` == "skinCluster")
		$skinningMethod=`getAttr ($history[$y]+".skinningMethod")`;

for ($i=0;$i<size($selObjs);$i++)
	{
	$shapes=`listRelatives -s -ni $selObjs[$i]`;
	if (size($shapes)<1)
		continue;
	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $selObjs[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}

	if ($hasSkinCluster) // possible joints added to skinCage
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		string $joints2[]=`listConnections ($skinCluster+".matrix")`;
		for ($y=0;$y<size($joints);$y++)
			if (!`stringArrayCount $joints[$y] $joints2`)
				skinCluster -e -lw false -wt 0 -ai $joints[$y] $skinCluster;
		}
	if (!$hasSkinCluster)
		{
		$joints=`listConnections skinClusterSkinCage.matrix`;
		select $joints;
		select -add $selObjs[$i];
		$tempString=`newSkinCluster "-toSelectedBones -mi 3 -dr 4 -rui false"`;
		$skinCluster=$tempString[0];
		}

	//copy skin
	select -r skinCage ;
	if ($isComponents)
	    select -add $sel;
	else
		select -add $sel[$i];
	copySkinWeights -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
	setAttr ($skinCluster+".skinningMethod") $skinningMethod;
	removeUnusedForSkin $skinCluster 0;
	}
select $sel;
}

global proc asHardenWeights ()
{
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
int $hasSkinCluster;
string $maxTransform;
string $tempString[],$history[],$joints[],$transforms[];
float $values[];
string $skinCluster;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listRelatives -s -ni $sel[$i]`;
	if (size($tempString)<1)
		continue;

	$hasSkinCluster=0;
	$history=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($history);$y++)
		if (`nodeType $history[$y]` == "skinCluster")
			{
			$hasSkinCluster=1;
			$skinCluster=$history[$y];
			}
	if (!$hasSkinCluster)
		error ("Object:\""+$sel[$i]+"\" has not skinCluster");		
	$joints=`listConnections ($skinCluster+".matrix")`;
	for ($y=0;$y<size($joints);$y++)
		setAttr ($joints[$y]+".lockInfluenceWeights") 0;

	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Hardening Vtx weight" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		{
		if (`progressBar -q -ic $gMainProgressBar`)
			{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
		progressBar -e -s 1 $gMainProgressBar;
		$transforms=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		$values=`skinPercent -ignoreBelow 0.001 -q -v $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
		float $maxValue=0;
		for ($z=0;$z<size($transforms);$z++)
			{
			if ($values[$z]>$maxValue)
				{
				$maxValue=$values[$z];
				$maxTransform=$transforms[$z];
				}
			}
		skinPercent -tv $maxTransform 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
		}
	progressBar -e -ep $gMainProgressBar;
	}
}

global proc asApplyDeltaMush ()
{
string $tempString[];
string $confirmResult,$systemCmd;

int $useWBDeltaMush=1;
if (`checkBox -q -ex wbDeltaMush`)
	$useWBDeltaMush=`checkBox -q -v wbDeltaMush`;

if (!$useWBDeltaMush)
	{
	deltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1 -envelope 1;
	asConnectDeltaMushScale;
	print "// DeltaMush applied\n";
	return;
	}

asLoadWbDeltaMushPlugin;

eval ("wbDeltaMush -smoothingIterations 10 -smoothingStep 0.5 -pinBorderVertices 1");
asConnectDeltaMushScale;

print "// DeltaMush applied\n";
}

global proc asLoadWbDeltaMushPlugin ()
{
int $haveASPlugPath=0;
string $envVarString=`getenv MAYA_PLUG_IN_PATH`;
string $pluginPaths[];
tokenize $envVarString ";" $pluginPaths;
for ($i=0;$i<size($pluginPaths);$i++)
	{
	if (`gmatch $pluginPaths[$i] "*AdvancedSkeleton5Files*"`) {
		$haveASPlugPath=1;
		break;
		}
	}
if (!$haveASPlugPath)
	asAddModulePath;
if (!`pluginInfo -q -l wbDeltaMushDeformer`)
	{
	$confirmResult=`confirmDialog -t Confirm -m "Plugin not loaded" -b "Load now" -b "Cancel" -db "Ok"`;
	if ($confirmResult!="Load now")
		return;
	chdir (`asGetScriptLocation`+"/AdvancedSkeleton5Files/modules/wbDeltaMushDeformer/"
		   +`asMayaVersionAsFloat`+"/plug-ins/");

	loadPlugin wbDeltaMushDeformer;
	if (!`pluginInfo -q -l wbDeltaMushDeformer`)
		error "Unable to load plugin";
	}
}

global proc asAddModulePath ()
{
global string $gMainProgressBar;
string $tempString[];

string $confirmResult=`confirmDialog -t Confirm -m "wbDeltaMushDeformer not added to MAYA_MODULE_PATH" -b "Add now" -b "Cancel" -db "Ok"`;
if ($confirmResult!="Add now")
	return;
//putenv: for current session
putenv "MAYA_PLUG_IN_PATH"  (`getenv "MAYA_PLUG_IN_PATH"`+";"+`asGetScriptLocation`
							 +"/AdvancedSkeleton5Files/modules/wbDeltaMushDeformer/"
							 +`asMayaVersionAsFloat`+"/plug-ins/");

//setx: for future sessions
string $MPIPfromReg="";
if (`about -win`) // get from registry, as this does not have the auto-added paths from modules
	{
	progressBar -e -st "Adding environment variable" -bp -ii 1 -min 0 -max 3 $gMainProgressBar;
	evalDeferred -lp ("progressBar -e -ep "+$gMainProgressBar);
	
	// add AS_MODULES_PATH whatever it does exist or not
	string $asModulePath = `asGetScriptLocation`+"/AdvancedSkeleton5Files/modules";
	$systemCmd="setx AS_MODULE_PATH "+$asModulePath;
	system ($systemCmd);

	// then we add MAYA_MODULE_PATH
	$systemCmd="reg query HKEY_CURRENT_USER\\Environment /v MAYA_MODULE_PATH";
	$systemReturn=`system ($systemCmd)`;

	if (!`gmatch $systemReturn "*Error*"` && !`gmatch $systemReturn "*ERROR*"`)
		{
		tokenize $systemReturn $tempString;	
		$MPIPfromReg=$tempString[3];
		}
	//string $newMPIP=$MPIPfromReg+";"+`asGetScriptLocation`+"\\AdvancedSkeleton5Files\\modules";
	string $newMPIP=`asGetScriptLocation`+"/AdvancedSkeleton5Files/modules;"+$MPIPfromReg;
	if ($MPIPfromReg!="")
		{
		print "// Found existing paths in MAYA_MODULE_PATH\n";
		print ("// New MAYA_MODULE_PATH="+$newMPIP+"\n");
		}
	$systemCmd="setx MAYA_MODULE_PATH "+$newMPIP;
	print ("// system(\""+$systemCmd+"\")\n");
	system ($systemCmd);
	progressBar -e -ep $gMainProgressBar;
	}
}

global proc asConnectDeltaMushScale ()
{
if (!`objExists Main`)
	return;
string $deltaMushNodes[]=`ls -type deltaMush`;
string $wbDeltaMushNodes[]=`ls -type wbDeltaMush`;
$deltaMushNodes=`stringArrayCatenate $deltaMushNodes $wbDeltaMushNodes`;
for ($i=0;$i<size($deltaMushNodes);$i++)
	{
	if (`isConnected Main.sx ($deltaMushNodes[$i]+".sx")`)
		continue;
	connectAttr Main.sx ($deltaMushNodes[$i]+".sx");
	connectAttr Main.sy ($deltaMushNodes[$i]+".sy");
	connectAttr Main.sz ($deltaMushNodes[$i]+".sz");
	}
}

global proc asWrapExlude ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;

string $sel[]=`ls -sl`;
if (!size($sel))
	error "No vertices selected ";
if (!`gmatch $sel[0] "*[.]vtx[[]*"`)
	error "Selection must be  vertices";
string $tempString[]=`listHistory -pdo 1 $sel[0]`;
string $wrapDeformer,$skinCluster;
int $hadSkinCluster=0;
for ($y=0;$y<size($tempString);$y++)
	{
	if (`nodeType $tempString[$y]` == "wrap")
		$wrapDeformer=$tempString[$y];
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
	}
if ($wrapDeformer=="")
	error "No wrap deformer on selected object";

if ($skinCluster=="")
	{
	asCopySkin;
	$tempString=`ls -sl -o`;
	$tempString=`listRelatives -p $tempString[0]`;
	select $tempString[0];
	asSmoothSkin;
	select $sel;
	}
else
	$hadSkinCluster=1;
$tempString=`listHistory -pdo 1 $sel[0]`;
for ($y=0;$y<size($tempString);$y++)
	if (`nodeType $tempString[$y]` == "skinCluster")
		$skinCluster=$tempString[$y];
$tempString=`listConnections ($wrapDeformer+".message")`;
string $wrapSet=$tempString[0];
$tempString=`listConnections ($skinCluster+".message")`;
string $skinClusterSet=$tempString[0];
sets -rm $wrapSet;
asInvertSelection;
sets -rm $skinClusterSet;
if (!$hadSkinCluster)
	{
	$tempString=`ls -sl -o`;
	select $tempString[0];
	removeUnusedInfluences;
	}
select $sel;
print ("// Selected vertices are now deformed by "+$skinCluster+" instead of wrapDeformer\n");
}

global proc asCreateSkinSub ()
{
string $sel[]=`ls -sl`;
if (!`objExists skinCage`)
	error "\"skinCage\" not found, You must create a skinCage (option2) first.";
if (`objExists skinSub`)
	error "\"skinSub\" already exists.";
if (!`objExists Cages`)
	{
	createNode -n Cages transform;
	parent Cages "Geometry";
	}

createNode -n subWrapPolySmoothProxy polySmoothProxy;
polyCube -n skinSub  -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 0;
parent skinSub Cages;
connectAttr skinCageShape.outMesh subWrapPolySmoothProxy.inputPolymesh;
connectAttr subWrapPolySmoothProxy.output skinSub.inMesh;
select skinSub;
createDisplayLayer -name SkinSub -number 1 -nr;
//setAttr SkinSub.shading 0;
setAttr SkinSub.displayType 2;
setAttr SkinSub.color 30;
setAttr SkinCage.displayType 1;
select $sel;
}

global proc asDeleteSkinSub ()
{
if (`objExists skinSub`)
	delete skinSub;
if (`objExists SkinSub`)
	delete SkinSub;
}

global proc asWrapSkin ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $sel[]=`ls -sl`;
if (!`objExists skinSub`)
	error "\"skinSub\" not found, you must create SubWrap first";
if (!size($sel))
	error "nothing selected";
for ($i=0;$i<size($sel);$i++)
	{
	string $historyNodes[]=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($historyNodes);$y++)
		if (`nodeType $historyNodes[$y]` == "wrap")
			error ($sel[$i]+" already have wrapDeformer");
	}

if (!`attributeExists wrapDeform Main`)
	{
	addAttr -k 1 -ln "wrapDeform" -at bool -dv 1 Main;
	setAttr -k 0 -cb 1 Main.wrapDeform;
	}
if (!`objExists wrapDeformReverse`)
	{
	createNode -n wrapDeformReverse reverse;
	connectAttr Main.wrapDeform wrapDeformReverse.inputX;
	}
string $tempString[];
for ($i=0;$i<size($sel);$i++)
	{
	select $sel[$i];
	select -add skinSub ;
//	CreateWrap;
	doWrapArgList "7" { "1","0","1", "2", "1", "1", "1", "0" };
	//doWrapArgList (7) {$operation=createWrap, $threshold, $maxDist , $inflType(1=vtx2=f), $exclusiveBind, $autoWeightThreshold, $renderInfl, $falloffMode}
	}
string $wraps[]=`listConnections -type wrap skinSub.worldMesh`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
float $wrapValues[]={0,0,1,0,0};
string $wrap;

for ($i=0;$i<size($wraps);$i++)
	{
	$wrap=`rename $wraps[$i] ("subWrap"+($i+1))`;
	$tempString=`listConnections ($wrap+".outputGeometry")`;
	setAttr ($wrap+".nodeState") 1;
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (`attributeExists $wrapAttrs[$y] $tempString[0]`) //We could be reattaching, so reuse wrapInfo
			$wrapValues[$y]=`getAttr ($tempString[0]+"."+$wrapAttrs[$y])`;
		setAttr ($wrap+"."+$wrapAttrs[$y]) $wrapValues[$y];
		}
	setAttr skinSub.dropoff 4;
	setAttr skinSub.smoothness 0;
	setAttr skinSub.inflType 2;
	connectAttr wrapDeformReverse.output.outputX ($wrap+".nodeState");
	}
select -cl;
}

global proc asSkinSubAttach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
if (!`objExists skinSub`) error "\"skinSub\" not found, you must create SubWrap first";
if (!`objExists skinCage`) error "\"skinCage\" not found, you must create SubWrap first";
if (!`attributeExists subWrapped skinCage`) error "No SubWraps have been detached";
int $numAttach;
string $msh;
string $tempString[];
$tempString[0]=`getAttr skinCage.subWrapped`;
tokenize $tempString[0] ";" $tempString;
for ($i=0;$i<size($tempString);$i++)
	{
	$msh=$tempString[$i];
	if (!`objExists $msh`)
		continue;
	select $msh;
	asWrapSkin;
	$numAttach++;
	}
print ("//"+$numAttach+" SubWrap(s) attached");
}

global proc asSkinSubDetach ()
{
if (!`asConfirmIfNotInBuildPose`)
	return;
string $subWraps[]=`ls -type wrap "subWrap*"`;
string $wrapAttrs[]={"falloffMode","exclusiveBind","autoWeightThreshold","weightThreshold","maxDistance"};
string $tempString[],$tempString2[];
string $msh,$subWrappedString;
for ($i=0;$i<size($subWraps);$i++)
	{
	//store wrapInfo on the meshes they deform.
	$tempString=`listHistory -f 1 ($subWraps[$i]+".outputGeometry")`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="mesh")
			{
			$tempString2=`listRelatives -p $tempString[$y]`;
			$msh=$tempString2[0];
			}
	$subWrappedString+=$msh+";";
	for ($y=0;$y<size($wrapAttrs);$y++)
		{
		if (!`attributeExists $wrapAttrs[$y] $msh`) addAttr -ln $wrapAttrs[$y] -at double $msh;
		setAttr ($msh+"."+$wrapAttrs[$y]) `getAttr ($subWraps[$i]+"."+$wrapAttrs[$y])`;
		}
	delete $subWraps;
	print ("//"+`size($subWraps)`+" SubWrap(s) detached");
	}
if (!`attributeExists subWrapped skinCage`)
	addAttr -ln "subWrapped" -dt "string" skinCage;
setAttr -type "string" skinCage.subWrapped $subWrappedString;
}

global proc asSmoothSkin ()
{
global string $gSelect;
global string $gMainProgressBar;
string $sel[]=`ls -sl`;
float $charHeight=`asgetCharHeight`;
float $pos[];
string $tempString[];
string $smoothJoints[];
if (`objExists Head_M`)
	{
	$tempString=`listRelatives -p Head_M`;
	string $parent=$tempString[0];
	while(`gmatch $parent "*Part[0-9]*"`)
		{
		$smoothJoints[size($smoothJoints)]=$parent;
		$tempString=`listRelatives -p $parent`;
		$parent=$tempString[0];
		}
	}
string $lookforJoints[]={"Root_M","Hip_R","Hip_L"};
for ($i=0;$i<size($lookforJoints);$i++)
if (`objExists $lookforJoints[$i]`)
	$smoothJoints[size($smoothJoints)]=$lookforJoints[$i];
string $skinCluster;
setToolTo $gSelect;
if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;
for ($i=0;$i<size($sel);$i++)
	{
	$tempString=`listHistory -pdo 1 $sel[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`nodeType $tempString[$y]` == "skinCluster")
			$skinCluster=$tempString[$y];
	if ($skinCluster=="")
		error "Found no skinCluster on selected object";
	int $numVtxs[]=`polyEvaluate -v $sel[$i]`;
	progressBar -e -st "Finding Vtx for smoothing" -bp -ii 1 -min 0 -max $numVtxs[0] $gMainProgressBar;
	for ($y=0;$y<$numVtxs[0];$y++)
		for ($z=0;$z<size($smoothJoints);$z++)
			{
			if (`progressBar -q -ic $gMainProgressBar`)
				{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
			if ($z==0)
				progressBar -e -s 1 $gMainProgressBar;
			$tempString=`skinPercent -ignoreBelow 0.001 -q -t $skinCluster ($sel[$i]+".vtx["+$y+"]")`;
			if (`stringArrayCount $smoothJoints[$z] $tempString`)
				{
				select -add ($sel[$i]+".vtx["+$y+"]");
				//middleVtx to root
				if (`gmatch $smoothJoints[$z] "*Root_M*"` || `gmatch $smoothJoints[$z] "*Hip_*"`)
					{
					$pos=`xform -q -ws -t ($sel[$i]+".vtx["+$y+"]")`;
					if ($pos[0]>($charHeight/-5000.0) && $pos[0]<($charHeight/5000.0))
						skinPercent -tv $smoothJoints[$z] 1 $skinCluster ($sel[$i]+".vtx["+$y+"]");
					}
				}
			}
		if (size(`ls -sl`))
			weightHammerVerts;
	}
progressBar -e -ep $gMainProgressBar;
}

global proc asDeleteSkinCurves ()
{
if (!`objExists skinCageShape` || !`objExists skinClusterSkinCage`)
	return;
setAttr skinClusterSkinCage.envelope 0;
duplicate -n asTempMesh skinCageShape;
setAttr skinClusterSkinCage.envelope 1;
string $deleteObjs[]={"SkinCurves1","SkinCurves2","MeshGeometry","MeshCurves","NurbsGeometry"};
for ($obj in $deleteObjs)
	if (`objExists $obj`)
		delete $obj;
string $tempString[]=`listRelatives -s -type mesh skinCage`;
for ($mesh in $tempString)
	if ($mesh!="skinCageShape")
		{
		connectAttr asTempMesh.outMesh ($mesh+".inMesh");
		evalDeferred -lp ("delete asTempMesh");
		break;
		}
}

global proc string asNrToLetter (int $nr)
{
string $letter;
if ($nr==0) $letter="";if ($nr==1) $letter="A";if ($nr==2) $letter="B";
if ($nr==3) $letter="C";if ($nr==4) $letter="D";if ($nr==5) $letter="E";
if ($nr==6) $letter="F";if ($nr==7) $letter="G";if ($nr==8) $letter="H";
if ($nr==9) $letter="I";if ($nr==10) $letter="J";if ($nr==11) $letter="K";
if ($nr==12) $letter="L";if ($nr==13) $letter="M";if ($nr==14) $letter="N";
if ($nr==15) $letter="O";if ($nr==16) $letter="P";if ($nr==17) $letter="Q";
if ($nr==18) $letter="R";if ($nr==19) $letter="S";if ($nr==20) $letter="T";
if ($nr==21) $letter="U";if ($nr==22) $letter="V";if ($nr==23) $letter="W";
if ($nr==24) $letter="X";if ($nr==25) $letter="Y";if ($nr==26) $letter="Z";
return $letter;
}

global proc asAlign (string $object, string $alignToObject, int $translate, int $rotate, int $jointOrient, int $rotateOrder)
{
string $parents[]=`listRelatives -p $object`;
string $orientConstraint[];
float $rotation[];

parent $object $alignToObject;
//Might have generated a Xform
string $generatedXform;
string $tempString[]=`listRelatives -p $object`;
if ($tempString[0]!=$alignToObject)
	$generatedXform=$tempString[0];
if ($translate)
	{
	xform -os -t 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -t 0 0 0 $generatedXform;
	}
if ($rotateOrder)
	setAttr ($object+".rotateOrder") `getAttr ($alignToObject+".rotateOrder")`;
if ($rotate)
	{
	xform -os -ro 0 0 0 $object;
	if ($generatedXform!="")
		xform -os -ro 0 0 0 $generatedXform;
	}
if ($jointOrient && $rotate)
	setAttr -type float3 ($object+".jointOrient") 0 0 0;
	
if (`objExists $parents[0]`)
	parent $object $parents[0];
else
	parent -w $object;

if ($jointOrient && !$rotate)
	{
	if (`getAttr ($alignToObject+".rotateOrder")`!=0)
		warning "Aligning jointOrient for objects without aligning rotation, and non-default rotationOrder, may cause problems.";
	$orientConstraint=`orientConstraint $alignToObject $object`;
	$rotation=`xform -q -os -ro $object`;
	delete $orientConstraint[0];
	setAttr -type float3 ($object+".jointOrient") $rotation[0] $rotation[1] $rotation[2];
	setAttr -type float3 ($object+".rotate") 0 0 0;
	}
}

global proc asImportIconsFile (string $iconsFile)
{
string $beforeObj[]=`ls -l -as`;
string $afterObj[];
int $fromBefore[];
int $readLine;
$fileId=`fopen $iconsFile "r"`;
string $nextLine = `fgetline $fileId`;
string $previousLine;
while ( size( $nextLine ) > 0 )
	{
	if (!$readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
	if (`gmatch $nextLine "createNode nurbsCurve*"`)
		{
		$readLine=1;
		eval ($previousLine);
		$previousLine = $nextLine;
		$nextLine = `fgetline $fileId`;
		continue;
		}
	if ($readLine)
		if (`gmatch $nextLine "\t*"`)
			{
			$previousLine += $nextLine;
			$nextLine = `fgetline $fileId`;
			continue;
			}
		else
			{
			$readLine=0;
			eval ($previousLine);
			}
	$previousLine=$nextLine;
	$nextLine = `fgetline $fileId`;
	}
fclose $fileId;
$afterObj=`ls -l -as`;
for ($i=0;$i<size($afterObj);$i++)
	for ($y=0;$y<size($beforeObj);$y++)
		if ($afterObj[$i]==$beforeObj[$y])
			$fromBefore[$i]=1;
for ($i=0;$i<size($afterObj);$i++)
	if (!$fromBefore[$i])
		parent $afterObj[$i] "iconsGroup";
}

global proc asCreateController (string $type, string $name, string $side, string $fitJoint)
{
string $sel[]=`ls -sl`;
select -cl;
int $rotOrder=`getAttr ($fitJoint+".rotateOrder")`;
if ($type=="FK")
	createNode -n ($type+"Offset"+$name+$side) transform;
//	joint -n ($type+"Offset"+$name+$side);//Why joint ?
else
	{
	createNode -n ($type+"Offset"+$name+$side) transform;
	parent ($type+"Offset"+$name+$side) "IKHandle";
	}
createNode -n ($type+"Extra"+$name+$side) transform;
sets -add ControlSet ($type+"Extra"+$name+$side);
parent ($type+"Extra"+$name+$side) ($type+"Offset"+$name+$side);
asLockAttr ($type+"Extra"+$name+$side) 0 0 1 1;
if (`gmatch $name "*Scapula*"`)
	duplicate -n ($type+$name+$side) "Scapula_icon";
else
	duplicate -n ($type+$name+$side) ($type+"_icon");
xform -os -t 0 0 0 -ro 0 0 0 ($type+$name+$side);
if ($type=="FK" || $type=="IKLocal" || $type=="Bend")
	{
	setAttr ($type+"Offset"+$name+$side+".rotateOrder") $rotOrder;
	setAttr ($type+"Extra"+$name+$side+".rotateOrder") $rotOrder;
	setAttr ($type+$name+$side+".rotateOrder") $rotOrder;
	}

if ($side=="_L")
	setAttr -type float3 ($type+$name+$side+".s") -1 -1 -1;

float $height=`getAttr "Main.height"`;
float $defaultCtrlScale=$height/30.0;
float $sca[3]={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
string $tempString[]=`listRelatives -c -type joint $fitJoint`;
if ($tempString[0]!="")
	{
	float $pos1[]=`xform -q -ws -t $fitJoint`;
	float $pos2[]=`xform -q -ws -t $tempString[0]`;
	float $boneLenght=`mag<<$pos2[0]-$pos1[0],$pos2[1]-$pos1[1],$pos2[2]-$pos1[2]>>`;
	if ($boneLenght>1)
		$boneLenght=$boneLenght/2.0;
	else
		$boneLenght=$boneLenght+((1-$boneLenght)/2.0);
	$defaultCtrlScale=$defaultCtrlScale*$boneLenght;
	$sca={$defaultCtrlScale,$defaultCtrlScale,$defaultCtrlScale};
	}

if (`attributeExists fat $fitJoint` && `attributeExists fatY $fitJoint` && `attributeExists fatZ $fitJoint`)
	{
	float $fat=`getAttr ($fitJoint+$side+".fat")`;
	float $fatY=`getAttr ($fitJoint+$side+".fatY")`;
	float $fatZ=`getAttr ($fitJoint+$side+".fatZ")`;
//	$sca={$defaultCtrlScale,$fat*$fatY*$scale,$fat*$fatZ*$scale};
	$sca={$defaultCtrlScale,$fat*$fatY,$fat*$fatZ};
	}

string $shapes[]=`listRelatives -s -f ($type+$name+$side)`;
for ($i=0;$i<size($shapes);$i++)
	{
	xform -s $sca[1] $sca[1] $sca[1] ($shapes[$i]+".cv[0:99]");
	xform -s 1.5 1.5 1.5 ($shapes[$i]+".cv[0:99]");
	}
makeIdentity -a 1 -t 1 -r 1 -s 1 ($type+$name+$side);

parent ($type+$name+$side) ($type+"Extra"+$name+$side);

float $pos[]=`xform -q -ws -t ($fitJoint+$side)`;
float $rot[]=`xform -q -ws -ro ($fitJoint+$side)`;
xform -ws -t $pos[0] $pos[1] $pos[2] ($type+"Offset"+$name+$side);
if ($type=="FK")
	xform -ws -ro $rot[0] $rot[1] $rot[2] ($type+"Offset"+$name+$side);
select $sel;
}

global proc asCreateUnTwister (string $fitJoint, string $side, string $twistParent, string $twistParentSide, string $fitJointIK, int $b, int $IkUnTwister, string $ikFollow)
{
float $scale=`asGetScale`;
if (`objExists ("TwistFollow"+$fitJoint+$side)`)
	return;
string $parentIK;
string $tempString[],$iKInfo[],$twistParentIKInfo[];
$iKInfo=`asFitJointIKInfo $fitJoint`;
string $IK=$iKInfo[0];
string $IKChildJoint=$iKInfo[3];
string $IKNumCtrls=$iKInfo[5];
//fake IK-mid ctrl, to control mid locs
if ($IKNumCtrls==2)
	$IKNumCtrls=3;

//find $parentIK
if (`objExists ($twistParent+$twistParentSide)`)
	{
	$twistParentIKInfo=`asFitJointIKInfo $twistParent`;
	$parentIK=$twistParentIKInfo[0];
	}
$tempString=`listRelatives -p $fitJoint`;
string $fitJointParent=$tempString[0];

createNode -n ("TwistFollow"+$fitJoint+$side) -p TwistSystem transform;
createNode -n ("TwistFollowParent"+$fitJoint+$side) -p TwistSystem transform;
asAlign ("TwistFollow"+$fitJoint+$side) ($fitJoint+$side) 1 1 0 1;
if (`objExists ("IKSp"+$fitJoint+$side)`)
	asAlign ("TwistFollow"+$fitJoint+$side) ("IKSp"+$fitJoint+$side) 1 1 0 1;
setAttr -l 1 ("TwistFollow"+$fitJoint+$side+".v") 0;
setAttr -l 1 ("TwistFollowParent"+$fitJoint+$side+".v") 0;

if ($IkUnTwister)
	{
	parentConstraint ($ikFollow+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		{
		if (`objExists ("IKSp"+$twistParent+$twistParentSide)`)
			parentConstraint ("IKSp"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		else
			parentConstraint ("IKX"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		}
	}
else
	{
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
	if (`objExists ($twistParent+$twistParentSide)`)
		{
		if ($fitJointParent=="Root")
			parentConstraint LegLockConstrained ("TwistFollowParent"+$fitJoint+$side);
		else
			asConstraintToFKIK "parent" $parentIK ("FKX"+$twistParent+$twistParentSide) ("IKX2"+$twistParent+$twistParentSide) ("TwistFollowParent"+$fitJoint+$side);
		}
	}

if (!`objExists ($twistParent+$twistParentSide)`)
	parentConstraint RootX_M ("TwistFollowParent"+$fitJoint+$side);	
//Makes FKIK mixing less flippy, but `might` cause cycle
//		parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);
//setAttr ("TwistFollow"+$fitJoint+$side+"_parentConstraint1.interpType") 2;



select ($fitJoint+$side);
//if (`objExists ("IKSp"+$fitJoint+$side)`)
//	select ("IKSp"+$fitJoint+$side);
joint -n ("UnTwist"+$fitJoint+$side);
joint -n ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwist"+$fitJoint+$side) ("TwistFollowParent"+$fitJoint+$side);

if ($IkUnTwister)
	pointConstraint ($ikFollow+$side) ("UnTwist"+$fitJoint+$side);
else
	asConstraintToFKIK "point" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("UnTwist"+$fitJoint+$side);

//stabalize constraint by adding offsetNode
createNode -n ("TwistFollowOffset"+$fitJoint+$side) -p ("TwistFollow"+$fitJoint+$side) transform;
createNode -n ("TwistFollowParentOffset"+$fitJoint+$side) -p ("TwistFollowParent"+$fitJoint+$side) transform;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowOffset"+$fitJoint+$side+".r") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".t") 0 0 0;
setAttr -type float3 ("TwistFollowParentOffset"+$fitJoint+$side+".r") 0 0 0;
parent ("TwistFollowOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollowParentOffset"+$fitJoint+$side) TwistSystem;
parent ("TwistFollow"+$fitJoint+$side) ("TwistFollowOffset"+$fitJoint+$side);
parent ("TwistFollowParent"+$fitJoint+$side) ("TwistFollowParentOffset"+$fitJoint+$side);

setAttr ("UnTwistEnd"+$fitJoint+$side+".translateX") ($b*$scale);
ikHandle -n ("UnTwistIK"+$fitJoint+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$fitJoint+$side) -ee ("UnTwistEnd"+$fitJoint+$side);
parent ("UnTwistIK"+$fitJoint+$side) ("TwistFollow"+$fitJoint+$side);
poleVectorConstraint ("UnTwist"+$fitJoint+$side) ("UnTwistIK"+$fitJoint+$side);

select ("UnTwist"+$fitJoint+$side);
joint -n ("TwistBalancer"+$fitJoint+$side);
setAttr ("TwistBalancer"+$fitJoint+$side+".rotateOrder") 5;
if ($IkUnTwister)
	parentConstraint ($ikFollow+$side) ("TwistBalancer"+$fitJoint+$side);
else
	asConstraintToFKIK "parent" $fitJointIK ("FKX"+$fitJoint+$side) ("IKX2"+$fitJoint+$side) ("TwistBalancer"+$fitJoint+$side);
//360, part1
parentConstraint ("UnTwist"+$fitJoint+$side) ("TwistBalancer"+$fitJoint+$side);
//setAttr ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1.interpType") 0;
if (!`objExists MainTwistFlipSetRange`)
	{
	createNode -n MainTwistFlipSetRange setRange;
	setAttr MainTwistFlipSetRange.oldMinX 0;
	setAttr MainTwistFlipSetRange.oldMaxX 1;
	setAttr MainTwistFlipSetRange.minX 1;
	setAttr MainTwistFlipSetRange.maxX 0;

	setAttr MainTwistFlipSetRange.oldMinY 0;
	setAttr MainTwistFlipSetRange.oldMaxY 1;
	setAttr MainTwistFlipSetRange.minY 1;
	setAttr MainTwistFlipSetRange.maxY 2;

	setAttr MainTwistFlipSetRange.oldMinZ 0;
	setAttr MainTwistFlipSetRange.oldMaxZ 1;
	setAttr MainTwistFlipSetRange.minZ 0;
	setAttr MainTwistFlipSetRange.maxZ 1;

//	connectAttr Main.twistFlip MainTwistFlipSetRange.valueX;
//	connectAttr Main.twistFlip MainTwistFlipSetRange.valueY;
	}
//connectAttr -f MainTwistFlipSetRange.outValue.outValueX ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1.interpType");
$tempString=`listAttr -ud ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1")`;
//connectAttr -f Main.twistFlip ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1."+$tempString[size($tempString)-1]);
connectAttr -f MainTwistFlipSetRange.outValue.outValueZ ("TwistBalancer"+$fitJoint+$side+"_parentConstraint1."+$tempString[size($tempString)-1]);

//autoTwist & extraTwist attributes
string $autoTwistCtrl="FK"+$fitJoint+$side;
if ($IkUnTwister)
	$autoTwistCtrl="IK"+$IK+$IKNumCtrls+$side;

addAttr -ln "twist" -at double ("TwistBalancer"+$fitJoint+$side);
addAttr -k 0 -ln "autoTwist" -at double -min 0 -max 10 -dv 10 $autoTwistCtrl;
addAttr -k 0 -ln "extraTwist" -at double $autoTwistCtrl;

createNode -n ($autoTwistCtrl+"AutoTwistUnitConversion") unitConversion;
setAttr ($autoTwistCtrl+"AutoTwistUnitConversion.conversionFactor") 0.1;
connectAttr ($autoTwistCtrl+".autoTwist") ($autoTwistCtrl+"AutoTwistUnitConversion.input");

//360, part2 //setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*2);
createNode -n ($autoTwistCtrl+"360TwistDivideMultiplyDivide") multiplyDivide;
connectAttr -f MainTwistFlipSetRange.outValue.outValueY ($autoTwistCtrl+"360TwistDivideMultiplyDivide.input1X");
connectAttr -f ("TwistBalancer"+$fitJoint+$side+".rotateX") ($autoTwistCtrl+"360TwistDivideMultiplyDivide.input2X");

createNode -n ($autoTwistCtrl+"AutoTwistMultiplyDivide") multiplyDivide;
connectAttr -f ($autoTwistCtrl+"AutoTwistUnitConversion.output") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input1X");

connectAttr -f ($autoTwistCtrl+"360TwistDivideMultiplyDivide.outputX") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input2X");
//connectAttr -f ("TwistBalancer"+$fitJoint+$side+".rotateX") ($autoTwistCtrl+"AutoTwistMultiplyDivide.input2X");

createNode -n ($autoTwistCtrl+"ExtraTwistPlusMinusAverage") plusMinusAverage;
connectAttr -f ($autoTwistCtrl+"AutoTwistMultiplyDivide.outputX") ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.input1D[0]");
connectAttr -f ($autoTwistCtrl+".extraTwist") ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.input1D[1]");
connectAttr -f ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.output1D") ("TwistBalancer"+$fitJoint+$side+".twist");
//	connectAttr -f ($autoTwistCtrl+"ExtraTwistPlusMinusAverage.output1D") IKSpineHandle_M.twist;
}

global proc asInvertSelection ()
{
//Maya 2018 does not seem to work with "InvertSelection" on component selection
string $tempString[]=`ls -sl`;
string $tempString2[]=`ls -sl -o`;
if (`gmatch $tempString[0] "*[.]vtx*"`)
	{
	select ($tempString2[0]+".vtx[0:99999]");
	select -d $tempString;
	}
else if (`gmatch $tempString[0] "*[.]f*"`)
	{
	select ($tempString2[0]+".f[0:99999]");
	select -d $tempString;
	}
else if (`gmatch $tempString[0] "*[.]e*"`)
	{
	select ($tempString2[0]+".e[0:99999]");
	select -d $tempString;
	}
else
	InvertSelection;
}


global proc asUnitConvertAndReverse (string $name, string $driver)
{
createNode -n ($name+"UnitConversion")  unitConversion;
setAttr ($name+"UnitConversion.conversionFactor") 0.1;
connectAttr $driver ($name+"UnitConversion.input");
createNode -n ($name+"Reverse")  reverse;
connectAttr ($name+"UnitConversion.output") ($name+"Reverse.inputX");
}

global proc asSkinWeightMerge (string $sourceSc, string $destSc, string $removeJoint)
{
string $cmd;
string $infJoints[];

$cmd+="import maya.OpenMaya as OpenMaya\n";
$cmd+="import maya.OpenMayaAnim as OpenMayaAnim\n";
$cmd+="import maya.cmds as cmds\n";
$cmd+="import maya.mel as mel\n";

$cmd+="# poly mesh and skinCluster name\n";
$cmd+="sourceSCName = '"+$sourceSc+"'\n";
$cmd+="destSCName = '"+$destSc+"'\n";
$cmd+="removeJoint = '"+$removeJoint+"'\n";

$cmd+="# get the MFnSkinCluster for destSCName\n";
$cmd+="selList = OpenMaya.MSelectionList()\n";
$cmd+="selList.add(destSCName)\n";
$cmd+="clusterNode = OpenMaya.MObject()\n";
$cmd+="selList.getDependNode(0, clusterNode)\n";
$cmd+="skinFn = OpenMayaAnim.MFnSkinCluster(clusterNode)\n";

$cmd+="# get the MDagPath for all influence\n";
$cmd+="infDags = OpenMaya.MDagPathArray()\n";
$cmd+="skinFn.influenceObjects(infDags)\n";

//$cmd+="print infDags\n";

$cmd+="# create a dictionary whose key is the MPlug indice id and \n";
$cmd+="# whose value is the influence list id\n";
$cmd+="infIds = {}\n";
$cmd+="infs = []\n";
$cmd+="for x in xrange(infDags.length()):\n";
//$cmd+="	infPath = infDags[x].fullPathName()\n";
$cmd+="	infPath = infDags[x].partialPathName()\n";
//$cmd+="	infId = int(skinFn.indexForInfluenceObject(infDags[x]))\n";
$cmd+="	infId = x\n";
$cmd+="	infIds[infId] = x\n";
$cmd+="	infs.append(infPath)\n";

$cmd+="# get the MPlug for the weightList and weights attributes\n";
$cmd+="wlPlug = skinFn.findPlug('weightList')\n";
$cmd+="wPlug = skinFn.findPlug('weights')\n";
$cmd+="wlAttr = wlPlug.attribute()\n";
$cmd+="wAttr = wPlug.attribute()\n";
$cmd+="wInfIds = OpenMaya.MIntArray()\n";

$cmd+="# the weights are stored in dictionary, the key is the vertId, \n";
$cmd+="# the value is another dictionary whose key is the influence id and \n";
$cmd+="# value is the weight for that influence\n";
$cmd+="weights = {}\n";
$cmd+="for vId in xrange(wlPlug.numElements()):\n";
$cmd+="	vWeights = {}\n";
$cmd+="	# tell the weights attribute which vertex id it represents\n";
$cmd+="	wPlug.selectAncestorLogicalIndex(vId, wlAttr)\n";
	
$cmd+="	# get the indice of all non-zero weights for this vert\n";
$cmd+="	wPlug.getExistingArrayAttributeIndices(wInfIds)\n";

$cmd+="	# create a copy of the current wPlug\n";
$cmd+="	infPlug = OpenMaya.MPlug(wPlug)\n";
$cmd+="	for infId in wInfIds:\n";
$cmd+="		# tell the infPlug it represents the current influence id\n";
$cmd+="		infPlug.selectAncestorLogicalIndex(infId, wAttr)\n";
		
$cmd+="		# add this influence and its weight to this verts weights\n";
$cmd+="		try:\n";
$cmd+="			vWeights[infIds[infId]] = infPlug.asDouble()\n";
$cmd+="		except KeyError:\n";
$cmd+="			# assumes a removed influence\n";
$cmd+="			pass\n";
$cmd+="	weights[vId] = vWeights\n";

$cmd+="cmds.copySkinWeights(ss=sourceSCName , ds=destSCName, noMirror=True)\n";

$cmd+="for vertId, weightData in weights.items():\n";
$cmd+="	wlAttr = '%s.weightList[%s]' % (destSCName, vertId)\n";
$cmd+="	for infId, infValue in weightData.items():\n";
$cmd+="		if infs[infId] == removeJoint:\n";
$cmd+="			continue\n";
$cmd+="		wAttr = '.weights[%s]' % infId\n";
$cmd+="		cmds.setAttr(wlAttr + wAttr, infValue)\n";

python ($cmd);
}

global proc asSkinWeightSet (string $joint, string $geometry, string $skinCluster, int $vtxNrs[], float $weights[])
{
string $cmd;
string $infJoints[];

$cmd+="import re as re\n";
$cmd+="import maya.cmds as mc\n";
$cmd+="import maya.OpenMaya as om\n";
$cmd+="import maya.OpenMayaAnim as oma\n";
$cmd+="# get the MFnSkinCluster for clusterName\n";
$cmd+="selList = om.MSelectionList()\n";
$cmd+="selList.add('"+$skinCluster+"')\n";
$cmd+="clusterNode = om.MObject()\n";
$cmd+="selList.getDependNode(0, clusterNode)\n";
$cmd+="skinFn = oma.MFnSkinCluster(clusterNode)\n";
$cmd+="# get the MDagPath for all influence\n";
$cmd+="infDags = om.MDagPathArray()\n";
$cmd+="skinFn.influenceObjects(infDags)\n";
$cmd+="conns = mc.listConnections ('"+$skinCluster+".matrix',c=1)\n";
$cmd+="for i in range(len(conns)):\n";
$cmd+="    if conns[i] == '"+$joint+"':\n";
$cmd+="        str = conns[i-1]\n";
$cmd+="        nrA = str.split('[')\n";
$cmd+="        nrB = nrA[1].split(']')\n";
$cmd+="        jointNr = int (nrB[0])\n";
$cmd+="vtxNrs = [";
for ($i=0;$i<size($vtxNrs);$i++)
	$cmd+=$vtxNrs[$i]+",";
$cmd+="]\n";
$cmd+="weights = [";
for ($i=0;$i<size($weights);$i++)
	$cmd+=$weights[$i]+",";
$cmd+="]\n";
$cmd+="for i in range(len(vtxNrs)):\n";
$cmd+="    vtxNr = vtxNrs[i]\n";
$cmd+="    wAttr = '"+$skinCluster+".wl[%s].w[%d]' %(vtxNr,jointNr)\n";
$cmd+="    mc.setAttr(wAttr, weights[i])\n";

python ($cmd);

//normalize
$infJoints=`listConnections ($skinCluster+".matrix")`;
for ($i=0;$i<size($infJoints);$i++)
	setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
setAttr ($joint+".lockInfluenceWeights") 1;
skinPercent -normalize true $skinCluster $geometry;
setAttr ($joint+".lockInfluenceWeights") 0;
}

global proc asSkinWeightBySoftMod (string $joint, string $geometry, string $skinCluster, float $falloffRadius, float $maxWeight)
{
global string $gMainProgressBar;
int $numCurvePoints;
float $weight;
float $pos[]=`xform -q -ws -t $joint`;
float $posAs[];
string $vtx,$fitJoint,$falloffCurveString,$cmd;
string $sel[]=`ls -sl`;
string $tempString[],$infJoints[];
int $clusterWeighting;
if (`objectType $skinCluster`=="cluster")
	{
	$clusterWeighting=1;
	$pos=`xform -q -ws -piv $joint`;
	}

if (!`objExists tempSoftModCopy`)//coming from asFaceConvertSoftModBackToControl proc
	{
	//create softSelection
	if (`objExists closestSampler2`) delete closestSampler2;
	createNode -n closestSampler2 closestPointOnMesh;
	connectAttr -f ($geometry+".outMesh") closestSampler2.inMesh;
	setAttr closestSampler2.inPosition $pos[0] $pos[1] $pos[2];
	select ($geometry+".vtx["+`getAttr closestSampler2.result.closestVertexIndex`+"]");
	delete closestSampler2;
	softSelect -softSelectReset;
	softSelect -e -softSelectEnabled 1 -softSelectFalloff 1 -softSelectDistance $falloffRadius;
	if (`gmatch $joint "LipPullJoint_*"`)
		softSelect -e -softSelectCurve "0,1,3, 0.439,0.304,3, 0.945397,0.0806,3, 1,0,3";
	if (`gmatch $joint "MouthNarrowJoint_*"`)
		{
		softSelect -e -softSelectCurve "0,1,1, 1,0,1";
		softSelect -e -softSelectFalloff 0;
		}


	$cmd+="import maya.cmds as mc\n";
	$cmd+="import maya.OpenMaya as om\n";
	$cmd+="import maya.OpenMayaAnim as oma\n";
	$cmd+="def softSelection():\n";
	$cmd+="    selection = om.MSelectionList()\n";
	$cmd+="    softSelection = om.MRichSelection()\n";
	$cmd+="    om.MGlobal.getRichSelection(softSelection)\n";
	$cmd+="    softSelection.getSelection(selection)\n";
	$cmd+="    dagPath = om.MDagPath()\n";
	$cmd+="    component = om.MObject()\n";
	$cmd+="    iter = om.MItSelectionList( selection,om.MFn.kMeshVertComponent )\n";
	$cmd+="    elements = []\n";
	$cmd+="    while not iter.isDone(): \n";
	$cmd+="        iter.getDagPath( dagPath, component )\n";
	$cmd+="        dagPath.pop()\n";
	$cmd+="        node = dagPath.fullPathName()\n";
	$cmd+="        fnComp = om.MFnSingleIndexedComponent(component)\n";
	$cmd+="        for i in range(fnComp.elementCount()):\n";
	$cmd+="            elements.append([node, fnComp.element(i), fnComp.weight(i).influence()] )\n";
	$cmd+="        iter.next()\n";
	$cmd+="    return elements\n";
	$cmd+="def softSelWeights():\n";
	$cmd+="    softElementData = softSelection()\n";
	$cmd+="    selection = [\"%s.vtx[%d]\" % (el[0], el[1])for el in softElementData ]\n";

	$cmd+="    # get the MFnSkinCluster for clusterName\n";
	$cmd+="    selList = om.MSelectionList()\n";
	$cmd+="    selList.add('"+$skinCluster+"')\n";
	$cmd+="    clusterNode = om.MObject()\n";
	$cmd+="    selList.getDependNode(0, clusterNode)\n";
	$cmd+="    skinFn = oma.MFnSkinCluster(clusterNode)\n";

	$cmd+="    # get the MDagPath for all influence\n";
	$cmd+="    infDags = om.MDagPathArray()\n";
	$cmd+="    skinFn.influenceObjects(infDags)\n";

	$cmd+="    for x in range(infDags.length()):\n";
	$cmd+="        infPath = infDags[x].partialPathName()\n";
	$cmd+="        infIndexes = skinFn.indexForInfluenceObject(infDags[x])\n";
	$cmd+="        if infPath == '"+$joint+"':\n";
	$cmd+="            joint = infPath\n";
	$cmd+="            jointNr = infIndexes\n";


	$cmd+="    for i in range(len(softElementData)):\n";
	$cmd+="        vtxNr = softElementData[i][1]\n";
	$cmd+="        wAttr = '"+$skinCluster+".wl[%s].w[%d]' %(vtxNr,jointNr)\n";
	$cmd+="        infValue = softElementData[i][2]\n";
	$cmd+="        mc.setAttr(wAttr, infValue)\n";
//	$cmd+="        print(wAttr, infValue)\n";

	$cmd+="softSelWeights()\n";

	python ($cmd);

	softSelect -e -softSelectEnabled 0;
	softSelect -softSelectReset;

	//normalize
	$infJoints=`listConnections ($skinCluster+".matrix")`;
	for ($i=0;$i<size($infJoints);$i++)
		setAttr ($infJoints[$i]+".lockInfluenceWeights") 0;
	setAttr ($joint+".lockInfluenceWeights") 1;
	skinPercent -normalize true $skinCluster $geometry;
	setAttr ($joint+".lockInfluenceWeights") 0;

	select $sel;
	return;
}

duplicate -n tempMesh $geometry;
select tempMesh;
$tempString=`softMod -falloffMode 1 -falloffAroundSelection 0`;
rename $tempString[0] TempSoftMod;
rename $tempString[1] TempSoftModHandle;

if (`objExists tempSoftModCopy`)//coming from asFaceConvertSoftModBackToControl proc
	{
	setAttr TempSoftMod.falloffRadius `getAttr tempSoftModCopy.falloffRadius`;
	setAttr TempSoftMod.falloffMode  `getAttr tempSoftModCopy.falloffMode `;
	for ($i=0;$i<`getAttr -s tempSoftModCopy.falloffCurve`;$i++)
		connectAttr -f ("tempSoftModCopy.falloffCurve["+$i+"]") ("TempSoftMod.falloffCurve["+$i+"]");
	}

setAttr -type float3 TempSoftModHandleShape.origin $pos[0] $pos[1] $pos[2];
setAttr TempSoftMod.falloffCenter $pos[0] $pos[1] $pos[2];
xform -piv $pos[0] $pos[1] $pos[2] TempSoftModHandle;
setAttr TempSoftMod.falloffMode 1;
setAttr TempSoftMod.falloffRadius $falloffRadius;

if (`gmatch $joint "LipPullJoint_*"` && !`objExists tempSoftModCopy`)
	{
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Position 0;
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_FloatValue 1;
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_Position 1;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_FloatValue 0;
	setAttr TempSoftMod.falloffCurve[1].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_Position 0.3043;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_FloatValue 0.439273;
	setAttr TempSoftMod.falloffCurve[2].falloffCurve_Interp 3;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_Position 0.0806;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_FloatValue 0.945397;
	setAttr TempSoftMod.falloffCurve[3].falloffCurve_Interp 3;
	}
if (`gmatch $joint "MouthNarrowJoint_*"` && !`objExists tempSoftModCopy`)
	{
	setAttr TempSoftMod.falloffCurve[0].falloffCurve_Interp 1;
	}

select tempMesh;
polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
$tempString=`ls -sl -fl`;
if ($clusterWeighting)
	{
	select $geometry;
	polySelectConstraint -m 3 -t 1 -d 1 -db 0 $falloffRadius -dp $pos[0] $pos[1] $pos[2];
	asInvertSelection;
	percent -v 0 $skinCluster `ls -sl`;
	}
polySelectConstraint -m 0;

progressBar -e -st ("SkinWeight by SoftMod ("+$joint+")") -bp -ii 1 -min 0 -max ((size($tempString))+1) $gMainProgressBar;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`objExists eyeLidArea`)
		if (`sets -im eyeLidArea $tempString[$i]`)
			continue;
	if (`objExists lipArea`)
		if (`sets -im lipArea $tempString[$i]`)
			continue;

	$posA=`xform -q -ws -t $tempString[$i]`;
	$posAs[$i]=$posA[1];
	}
setAttr TempSoftModHandle.ty 1;
for ($i=0;$i<size($tempString);$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;error "Interrupted";}
	progressBar -e -s 1 $gMainProgressBar;

	$posB=`xform -q -ws -t $tempString[$i]`;
	$weight=($posB[1]-$posAs[$i])*$maxWeight;
	if ($weight<0) $weight=0;
	if ($weight>1) $weight=1;
	$vtx=`substitute tempMesh $tempString[$i] $geometry`;
	if ($clusterWeighting)
		catchQuiet (`percent -v $weight $skinCluster $vtx`);
	else
	 	catchQuiet (`skinPercent -tv $joint $weight $skinCluster $vtx`);
	}
setAttr TempSoftModHandle.ty 0;

//update FitJoint radius & falloffCurveString
tokenize $joint "_" $tempString;
$fitJoint=`substitute "Joint" $tempString[0] ""`;
if (`attributeExists falloffRadius $fitJoint`)
	setAttr ($fitJoint+".falloffRadius") $falloffRadius;
if (`objExists $fitJoint`)
	{
	if (!`attributeExists falloffCurve $fitJoint`)
		addAttr -ln falloffCurve -dt "string" $fitJoint;
	$numCurvePoints=`getAttr -s TempSoftMod.falloffCurve`;
	for ($i=0;$i<$numCurvePoints;$i++)
		{
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_Position "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_Position")`+";";
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_Interp "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_Interp")`+";";
		$falloffCurveString+="setAttr TempSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue "+`getAttr ("TempSoftMod.falloffCurve["+$i+"].falloffCurve_FloatValue")`+";";
		}
		setAttr -type "string" ($fitJoint+".falloffCurve") $falloffCurveString;
	}

delete tempMesh;
if (`objExists tempSoftModCopy`) delete tempSoftModCopy;

progressBar -e -ep $gMainProgressBar;

select $sel;
}

global proc asFollow (string $driver, string $driven, string $target)
{
if (!`objExists $target`)
	return;
string $setRange=$driver+"SetRangeFollow";
if (!`attributeExists "follow" $driver`)
	{
	addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 0 $driver;
	createNode -n $setRange setRange;
	setAttr ($setRange+".maxX") 1;
	setAttr ($setRange+".minY") 1;
	setAttr ($setRange+".oldMaxX") 10;
	setAttr ($setRange+".oldMaxY") 10;
	connectAttr ($driver+".follow") ($setRange+".value.valueX");
	connectAttr ($driver+".follow") ($setRange+".value.valueY");
	}
createNode -n ($driven+"FollowNoScale") transform;
pointConstraint $target ($driven+"FollowNoScale");
orientConstraint $target ($driven+"FollowNoScale");
parent ($driven+"FollowNoScale") ("IKFollow");

createNode -n ($driven+"Follow") transform;
asAlign ($driven+"Follow") $driven 1 1 0 0;
parent ($driven+"Follow") ("IKFollow");
parentConstraint -mo ($driven+"FollowNoScale") ($driven+"Follow");

createNode -n ($driven+"Static") transform;
asAlign ($driven+"Static") $driven 1 1 0 0;
parent ($driven+"Static") ("IKStatic");
string $tempString[]=`parentConstraint ($driven+"Static") ($driven+"Follow") $driven`;
string $constraint=$tempString[0];
select $constraint;
connectAttr ($setRange+".outValue.outValueY") ($constraint+"."+$driven+"Static"+"W0");
connectAttr($setRange+".outValue.outValueX") ($constraint+"."+$driven+"Follow"+"W1");
}

global proc asConstraintToFKIK (string $type, string $fitJointIK, string $fk, string $ik, string $target)
{
string $contraintCmd="pointConstraint ";
if ($type=="orient")
	$contraintCmd="orientConstraint ";
if ($type=="parent")
	$contraintCmd="parentConstraint ";
if ($type=="scale")
	$contraintCmd="scaleConstraint ";
$contraintCmd+=$fk;
if (`objExists $ik`)
	$contraintCmd+=" "+$ik;
$contraintCmd+=" "+$target;
string $tempString[];
tokenize $target "_" $tempString;
string $side="_"+$tempString[size($tempString)-1];
tokenize $fk "_" $tempString;
string $contraintToSide="_"+$tempString[size($tempString)-1];
$tempString=`eval ($contraintCmd)`;
string $constraint=$tempString[0];
if (`objExists $ik` && `objExists ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide)`)
	{
	connectAttr ("FKIKBlend"+$fitJointIK+"Reverse"+$contraintToSide+".outputX") ($constraint+"."+$fk+"W0");
	connectAttr ("FKIKBlend"+$fitJointIK+"UnitConversion"+$contraintToSide+".output") ($constraint+"."+$ik+"W1");
	}
}

global proc asModelCheckerUI ()
{
if (`window -q -ex asModelChecker`)
	deleteUI asModelChecker;
window -t "Model Checker" asModelChecker;
columnLayout;
	separator -st none -h 10;
	text -l "Check for default Transformation values,";
	text -l "and Model Symmetry.";
	separator -st none -h 5;
	text -l "Select the model, then:";
	separator -st none -h 10;
	button -w 50 -l "Check" -c "asModelCheck Ok";
showWindow;
}

global proc int asModelCheck (string $okMessage)
{
global string $gMainProgressBar;
int $tempInt[];
int $numVtxs,$mirrortVtx,$i;
int $return=1;
float $mag;
float $posA[],$posB[],$tempFloat[];
string $sel[]=`ls -sl`;
string $m;

if (!size($sel))
	error "Nothing Selected";

//check Transform
$tempFloat=`getAttr ($sel[0]+".t")`;
if ($tempFloat[0]!=0) $m+="TranslateX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="TranslateY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="TranslateZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".r")`;
if ($tempFloat[0]!=0) $m+="RotateX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="RotateY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="RotateZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".s")`;
if ($tempFloat[0]!=1) $m+="ScaleX = "+$tempFloat[0]+", should be 1\n";
if ($tempFloat[1]!=1) $m+="ScaleY = "+$tempFloat[1]+", should be 1\n";
if ($tempFloat[2]!=1) $m+="ScaleZ = "+$tempFloat[2]+", should be 1\n";
$tempFloat=`getAttr ($sel[0]+".rp")`;
if ($tempFloat[0]!=0) $m+="RotatePivotX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="RotatePivotY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="RotatePivotZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".sp")`;
if ($tempFloat[0]!=0) $m+="ScalePivotX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="ScalePivotY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="ScalePivotZ = "+$tempFloat[2]+", should be 0\n";

if ($m!="")
	$m=$m+"\nThe above transform values are Non-Default values.\n"
			+"This can cause error when building FaceSetup.\n\n"
			+"It is recommended that you use the \"Model Clean\" tool,\n"
			+"before rigging.";
if ($m!="")
	{
	$dialog=`confirmDialog -t "Confirm" -m $m -b $okMessage -b "Cancel" -db "Cancel" -ds "Cancel"`;
	if ($dialog!=$okMessage)
		$return=0;
	return $return;
	}

//Symmetry check
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($sel[$i]+".outMesh") closestSampler.inMesh;
$tempInt=`polyEvaluate -v $sel[$i]`;
$numVtxs=$tempInt[0];
select -cl;
progressBar -e -st "Checking symmetry" -bp -ii 1 -min 0 -max $numVtxs $gMainProgressBar;
for ($i=0;$i<$numVtxs;$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;break;}
	progressBar -e -s 1 $gMainProgressBar;
	$posA=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	if ($posA[0]>0.001)
		continue;
	setAttr closestSampler.inPosition ($posA[0]*-1) $posA[1] $posA[2];
	$mirrortVtx=`getAttr closestSampler.closestVertexIndex`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$mirrortVtx+"]")`;
	$mag=`mag <<($posA[0]-($posB[0]*-1)),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>0.001)
		select -add ($sel[0]+".vtx["+$i+"]") ($sel[0]+".vtx["+$mirrortVtx+"]");
	}
progressBar -e -ep $gMainProgressBar;
delete closestSampler;
refresh;
if (size(`ls -sl`))
	{
	$dialog=`confirmDialog -t "Confirm" -m "Selected verticies are not symmetrical" -b $okMessage -b "Cancel" -db "Cancel" -ds "Cancel"`;
	if ($dialog!=$okMessage)
		$return=0;
	}
else
	print "// Model is symmetrical.\n";

return $return;
}

global proc asAnimationTesterUI ()
{
if (`window -q -ex asAnimationTester`)
    deleteUI asAnimationTester;
window -t AnimationTester asAnimationTester;
columnLayout -adj 1;
	text -l "Apply test animation:";
	separator -h 10;
	frameLayout -cll 1 -cl `optionVar -q asATBodyFrameLayout` -cc asFL -ec asFL-l "Body:" asATBodyFrameLayout;
		floatFieldGrp -pre 0 -numberOfFields 3 -label "rotate" -value1 90 -value2 90 -value3 90 -cw4 65 30 30 30 asBodyTestRotateFloatFieldGrp;
		intFieldGrp -l "frames" -v1 5 -cw2 65 30 asBodyTestFramesIntFieldGrp;
		rowLayout -nc 2;
			separator -w 67 -st none;
			checkBox -l "both positive and negative directions" asBodyTestPosNegCheckBox;
			setParent..;
		rowLayout -nc 2;
			separator -w 67 -st none;
			checkBox -l "both right and left side" asBodyTestRightLeftCheckBox;
			setParent..;
		rowLayout -nc 2;
			separator -w 67 -st none;
			checkBox -l "only on selected control" asBodyTestSelectedCheckBox;
			setParent..;
		button -w 100 -l "apply" -c asAnimationTest;
		separator -h 5;
		text -l "paint weights:";
		text -l "(double click to choose the moving joint)";
		separator -h 5;
		shelfButton -w 34 -h 34 -ann "Paint weights on smooth bound skins." -l "Paint Skin Weights Tool" -dcc asAnimationTesterPaintWeights
			-image paintSkinWeights.png -image1 paintSkinWeights.png -style "iconOnly" -c "ArtPaintSkinWeightsTool;";
		separator -h 20 -w 300;
		text -l "Or apply Example Motion Capture:";
		text -al "center" -fn "smallBoldLabelFont" -l "* only for Maya versions that include MoCap files";
		rowLayout -nc 2;
			optionMenu asAnimationTesterMoCapsOptionMenu;
			button -l "apply" -c asAnimationTesterMoCapApply;
			setParent..;
		setParent..;

	frameLayout -cll 1 -cl `optionVar -q asATFaceFrameLayout` -cc asFL -ec asFL-l "Face:" asATFaceFrameLayout;
		columnLayout;
			button -l "import Face test-animation" -c asAnimationTestFace;
		setParent..;
	setParent..;


	separator -h 20 -w 300;
	button -l "Remove test animations" -c asAnimationTesterRemove;
	setParent..;


asPopulateAnimationTesterMoCapsOptionMenu;
showWindow;
}

global proc asAnimationTest ()
{
int $posNeg=`checkBox -q -v asBodyTestPosNegCheckBox`;
int $rightLeft=`checkBox -q -v asBodyTestRightLeftCheckBox`;
int $selected=`checkBox -q -v asBodyTestSelectedCheckBox`;
int $frames=`intFieldGrp -q -v1 asBodyTestFramesIntFieldGrp`;
float $currentTime;
float $r[],$currentRot[];
$r[0]=`floatFieldGrp -q -v1 asBodyTestRotateFloatFieldGrp`;
$r[1]=`floatFieldGrp -q -v2 asBodyTestRotateFloatFieldGrp`;
$r[2]=`floatFieldGrp -q -v3 asBodyTestRotateFloatFieldGrp`;
string $selectedXYZ;
string $fkSystems[]={"FKOffsetRoot_M"};
string $tempString[]=`listRelatives -c -type transform FKSystem`;
string $xyz[]={"x","y","z"};
string $tempString2[];
string $sel[]=`ls -sl`;

playbackOptions -min 0 -ast 0 -max 2000 -aet 2000;
currentTime 0;
asSetAllFK "";
if (`attributeExists legLock RootX_M`)
	setAttr RootX_M.legLock 10;

for ($i=0;$i<size($tempString);$i++)
	if ($tempString[$i]!=$fkSystems[0])
		$fkSystems[size($fkSystems)]=$tempString[$i];

for ($i=0;$i<size($fkSystems);$i++)
//for ($i=0;$i<1;$i++)
	{
	$tempString=`listRelatives -ad -type nurbsCurve $fkSystems[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`listRelatives -p $tempString[$y]`;
		$ctrl=$tempString2[0];
		if (!`sets -im ControlSet $ctrl`)
			continue;
		if (!$rightLeft && !$selected && `gmatch $ctrl "*_L"`)
			continue;
		if ($selected && !`stringArrayCount $ctrl $sel`)
			continue;
		if ($selected)
			{
			//preferred axis and $posNeg provided
			$currentRot=`getAttr ($ctrl+".r")`;
			if ($currentRot[0]!=0) $selectedXYZ="x";
			if ($currentRot[1]!=0) $selectedXYZ="y";
			if ($currentRot[2]!=0) $selectedXYZ="z";
			if ($selectedXYZ!="")
				$r=$currentRot;
			}

		for ($z=0;$z<size($xyz);$z++)
			{
			for ($b=1;$b>-2;$b=$b-2)//2ways (positive and negative values)
				{
				if ($b==-1 && !$posNeg)
					continue;
				if ($r[$z]==0)
					continue;
				if ($selectedXYZ!="" && $xyz[$z]!=$selectedXYZ)
					continue;
				setKeyframe -v 0 ($ctrl+".r"+$xyz[$z]);
				$currentTime+=$frames;currentTime $currentTime;
				setKeyframe -v ($r[$z]*$b) ($ctrl+".r"+$xyz[$z]);
				$currentTime+=$frames;currentTime $currentTime;
				setKeyframe -v 0 ($ctrl+".r"+$xyz[$z]);
				}
			}
		$currentTime+=$frames;currentTime $currentTime;
		}
	}
$currentTime=$currentTime-$frames;
playbackOptions -min 0 -ast 0 -max $currentTime -aet $currentTime;
currentTime 0;
}

global proc asAnimationTesterPaintWeights ()
{
float $t[],$r[],$s[];
string $objAttr;
string $joint="Root_M";
string $sel[]=`ls -sl`;
string $controlSetMembers[],$tempString[],$tempString2[];
if (`objExists ControlSet`)
	$controlSetMembers=`sets -q ControlSet`;
string $trs[]={"t","r"};
string $xyz[]={"x","y","z"};

for ($i=0;$i<size($controlSetMembers);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			$objAttr=$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z];
			if (!`getAttr -k $objAttr`)
				continue;
			$value=`getAttr $objAttr`;
			if ($value<-0.001 || $value>0.001)
				{
				print ("detected motion on:"+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+" : "+$value+"\n");
				$tempString[0]=`substitute "FK" $controlSetMembers[$i] ""`;
				if (`objExists $tempString[0]`)
					$joint=$tempString[0];
				$i=$y=$z=999;
				break;
				}
			}

//Select objects bound to $joint (if nothing selected);
if (size($sel)==0)
	{
	$tempString=`listConnections -s 0 -d 1 ($joint+".worldMatrix")`;
	for ($i=0;$i<size($tempString);$i++)
		{
		if (`objectType $tempString[$i]`!="skinCluster")
			continue;
		$tempString2=`listConnections -s 0 -d 1 $tempString[$i]`;
		for ($y=0;$y<size($tempString2);$y++)
			{
			if (`objectType $tempString2[$y]`=="mesh" || `objectType $tempString2[$y]`=="transform")
				select -add `listRelatives -p $tempString2[$y]`;
			}
		}
	}

ArtPaintSkinWeightsTool;
artAttrSkinPaintCtx -e -sao smooth -influence $joint artAttrSkinContext;
artSkinInflListChanging $joint 1;
artSkinInflListChanged artAttrSkinPaintCtx;
toolPropertyWindow;
}

global proc asPopulateAnimationTesterMoCapsOptionMenu ()
{
string $mayaLocation=`getenv MAYA_LOCATION`;
string $mocapFbxLocation=$mayaLocation+"/Examples/Animation/Motion_Capture/FBX";
if (!`file -q -ex $mocapFbxLocation`)
	return;
string $files[]=`getFileList -fs "*.fbx" -fld $mocapFbxLocation`;
setParent -menu asAnimationTesterMoCapsOptionMenu;
for ($i=0;$i<size($files);$i++)
	menuItem -l $files[$i];
}

global proc asAnimationTesterMoCapApply ()
{
int $lastKeyFrameNr;
float $posA[],$posB[],$keyTimes[],$rotA[],$rotB[];
string $mayaLocation=`getenv MAYA_LOCATION`;
string $mocapFbxLocation=$mayaLocation+"/Examples/Animation/Motion_Capture/FBX";
string $fileName=`optionMenu -q -v asAnimationTesterMoCapsOptionMenu`;
string $file=$mocapFbxLocation+"/"+$fileName;
string $basename=`basenameEx $file`;
string $ref="AnimationTester:"+$basename+":Reference";
string $hipsJoint,$side,$rightLeft,$mpd,$nameSpace;
string $constraintObjs[],$constraintToObjs[],$tempString[];
string $fingers[]={"Thumb","Index","Middle","Ring","Pinky"};

if ($fileName=="")
	error "No MotionCapture Example choosen";

asAnimationTesterRemove;

file -r -type "FBX" -ignoreVersion -gl -mergeNamespacesOnClash false -namespace "AnimationTester" -options "v=0;" $file;
$tempString=`ls -r 1 Reference`;
if (!`size($tempString)`)
	error "Top node named Reference, not found in this file";
$nameSpace=`substitute ":Reference" $tempString[0] ""`;

$ref=$nameSpace+":Reference";

currentTime 0;
$tempString=`listRelatives -type joint -c $ref`;
$hipsJoint=$tempString[0];

createNode -n AnimationTesterScale transform;
parent $ref AnimationTesterScale;

$posA=`xform -q -ws -t Root_M`;
$posB=`xform -q -ws -t $hipsJoint`;
setAttr AnimationTesterScale.s -type float3 ($posA[1]/$posB[1]) ($posA[1]/$posB[1]) ($posA[1]/$posB[1]);

$keyTimes=`keyframe -q -tc ($hipsJoint+".tx")`;
$lastKeyFrameNr=$keyTimes[size($keyTimes)-1];

playbackOptions -min 0 -ast 0 -max $lastKeyFrameNr -aet $lastKeyFrameNr;
//asSetAllFK "";

if (`objExists FKIKLeg_R`) setAttr "FKIKLeg_R.FKIKBlend" 10;
if (`objExists FKIKLeg_L`) setAttr "FKIKLeg_L	.FKIKBlend" 10;
if (`objExists FKIKSpine_M`) setAttr "FKIKSpine_M.FKIKBlend" 0;
if (`objExists FKIKArm_R`) setAttr "FKIKArm_R.FKIKBlend" 0;
if (`objExists FKIKArm_L`) setAttr "FKIKArm_L.FKIKBlend" 0;

$tempString=`listRelatives -type joint -ad $ref`;
for ($i=0;$i<size($tempString);$i++)
	setAttr ($tempString[$i]+".r") -type float3 0 0 0;
setAttr ($hipsJoint+".tx") 0;
setAttr ($hipsJoint+".tz") 0;

xform -ws -ro -180 0 180 ($nameSpace+":RightShoulder");
xform -ws -ro 0 0 0 ($nameSpace+":LeftShoulder");
xform -ws -ro 90 0 -180 ($nameSpace+":RightArm");
xform -ws -ro 90 0 0 ($nameSpace+":LeftArm");


for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$rightLeft="Right";$rotA[0]=0;$rotA[1]=0;$rotA[2]=180;$rotB[0]=-90;$rotB[1]=0;$rotB[2]=-180;}
	if ($b==-1) {$side="_L";$rightLeft="Left";$rotA[0]=0;$rotA[1]=0;$rotA[2]=0;$rotB[0]=90;$rotB[1]=0;$rotB[2]=-180;}

	xform -ws -ro $rotA[0] $rotA[1] $rotA[2] ($nameSpace+":"+$rightLeft+"Arm");
	xform -ws -ro $rotA[0] $rotA[1] $rotA[2] ($nameSpace+":"+$rightLeft+"Hand");

	if (`objExists ("FKShoulder"+$side)`)
		xform -ws -ro $rotB[0] $rotB[1] $rotB[2] ("FKShoulder"+$side);
	if (`objExists ("FKWrist"+$side)`)
		xform -ws -ro $rotB[0] $rotB[1] $rotB[2] ("FKWrist"+$side);
	}

$constraintObjs={"RootX_M","FKRoot_M","FKSpine1_M","FKChest_M","FKNeck_M","FKHead_M"};
$constraintToObjs={"Hips","Spine","Spine1","Spine3","Neck","Head"};

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$rightLeft="Right";}
	if ($b==-1) {$side="_L";$rightLeft="Left";}

	$tempString={("IKLeg"+$side),("IKToes"+$side),("FKScapula"+$side),("FKShoulder"+$side),("FKElbow"+$side),("FKWrist"+$side)};
	$constraintObjs=`stringArrayCatenate $tempString $constraintObjs`;
	$tempString={($rightLeft+"Foot"),($rightLeft+"ToeBase"),($rightLeft+"Shoulder"),($rightLeft+"Arm"),($rightLeft+"ForeArm"),($rightLeft+"Hand")};
	$constraintToObjs=`stringArrayCatenate $tempString $constraintToObjs`;
	}

for ($i=0;$i<size($constraintObjs);$i++)
	{
	if (!`objExists ($nameSpace+":"+$constraintToObjs[$i])` || !`objExists $constraintObjs[$i]`)
		continue;
	parent `orientConstraint -mo ($nameSpace+":"+$constraintToObjs[$i]) $constraintObjs[$i]` AnimationTesterScale;
	if (`gmatch $constraintObjs[$i] "FK*"` || `gmatch $constraintObjs[$i] "IKToes_*"`)
		continue;
	parent `pointConstraint -mo ($nameSpace+":"+$constraintToObjs[$i]) $constraintObjs[$i]` AnimationTesterScale;
	}

for ($b=1;$b>-2;$b=$b-2)
	{
	if ($b==1)  {$side="_R";$rightLeft="Right";}
	if ($b==-1) {$side="_L";$rightLeft="Left";}


	for ($y=0;$y<size($fingers);$y++)
		for ($i=1;$i<4;$i++)
			{
			$mpd="AnimationTester"+$fingers[$y]+"FingerMPD"+$i+$side;
			if (`objExists $mpd`)
				delete $mpd;
			if (!`objExists ($nameSpace+":"+$rightLeft+"Hand"+$fingers[$y]+$i)` || !`objExists ("FK"+$fingers[$y]+"Finger"+$i+$side)`)
				continue;
			createNode -n $mpd multiplyDivide;
			connectAttr ($nameSpace+":"+$rightLeft+"Hand"+$fingers[$y]+$i+".ry") ($mpd+".input1Y");
			connectAttr ($nameSpace+":"+$rightLeft+"Hand"+$fingers[$y]+$i+".rz") ($mpd+".input1Z");
			setAttr ($mpd+".input2Y") -1;
			if ($side=="_L")
				setAttr ($mpd+".input2Z") -1;
			connectAttr ($mpd+".outputZ") ("FK"+$fingers[$y]+"Finger"+$i+$side+".ry");
			connectAttr ($mpd+".outputY") ("FK"+$fingers[$y]+"Finger"+$i+$side+".rz");
			}
	}

setAttr AnimationTesterScale.v 0;
select -cl;
//currentTime 1;
currentTime 0;
//dgdirty -a;
}

global proc asAnimationTesterRemove ()
{
string $refFiles[]=`file -q -r`;
string $sel[]=`ls -sl`;
string $tempString[];
select `sets -q ControlSet`;
if (`objExists FaceControlSet`)
	select -add `sets -q FaceControlSet`;

string $animCurves[]=`listConnections -type animCurve -s 1 -d 0`;
if (size($animCurves))
	delete $animCurves;

//remove testMoCap as well
for ($i=0;$i<size($refFiles);$i++)
	if (`file -q -ns $refFiles[$i]`=="AnimationTester")
		file -rr $refFiles[$i];
if (`objExists AnimationTesterScale`)
	delete AnimationTesterScale;

$tempString=`ls "AnimationTester*MPD*"`;
if (size($tempString))
	delete $tempString;

asGoToBuildPose bodySetup;
if (`objExists FaceControlSet`)
	asGoToBuildPose faceSetup;

catchQuiet (`select $sel`);
print ("// Test animations removed.\n");
}

global proc asAnimationTestFace ()
{
string $ctrl,$attr;
string $tempString[],$tempString2[],$animCurves[];
string $asMotionFaceFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asMotionFace.ma";

file -r -ignoreVersion -gl -mergeNamespacesOnClash false -namespace "AnimationTester" -options "v=0;" $asMotionFaceFile;

$animCurves=`ls -type animCurve "AnimationTester:*"`;
for ($i=0;$i<size($animCurves);$i++)
	{
	$tempString=`duplicate $animCurves[$i]`;
	tokenize $tempString[0] "_" $tempString2;
	$ctrl=$tempString2[0]+"_"+$tempString2[1];
	$attr=$tempString2[2];
	if (!`attributeExists $attr $ctrl`)
		{
		print ("//Not found:"+$ctrl+"."+$attr+"\n");
		continue;
		}
	connectAttr ($tempString[0]+".output") ($ctrl+"."+$attr);
	}
file -rr $asMotionFaceFile;
playbackOptions -min 0 -ast 0 -max 330 -aet 330;
currentTime 70;
print "// Test animation applied.\n";
}

global proc string asNearestFeatherParent (string $ctrl, string $fitJointsCurveGuide)
{
float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;
string $nearestJoint,$nearestFeatherParent;
int $arrivedAtTaggedJoint;
float $posA[]=`xform -q -ws -t $ctrl`;
if (`gmatch $ctrl "*_L"`)
	$posA[0]=$posA[0]*-1;
float $posB[];
float $dist;
float $minDist=999;
string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
string $curveGuideFitJoints[],$tempString[];
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists curveGuide $fitJoints[$i]`)
		continue;
	if (`getAttr -as ($fitJoints[$i]+".curveGuide")`!=$fitJointsCurveGuide)
		continue;
	$curveGuideFitJoints[size($curveGuideFitJoints)]=$fitJoints[$i];
	$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
	$curveGuideFitJoints=`stringArrayCatenate $tempString $curveGuideFitJoints`;
	}
for ($i=0;$i<size($curveGuideFitJoints);$i++)
	{
	$posB=`xform -q -ws -t $curveGuideFitJoints[$i]`;
	$dist=`mag<<$posA[0]-$posB[0],$posA[1]-$posB[1],$posA[2]-$posB[2]>>`;
	if ($dist<$minDist)
		{
		$minDist=$dist;
		$nearestJoint=$curveGuideFitJoints[$i];
		}
	}
$tempString=`ls -l $nearestJoint`;
tokenize $tempString[0] "|" $tempString;
for ($i=size($tempString)-1;$i>-1;$i--)
	{
	if ($arrivedAtTaggedJoint)
		{
		$nearestFeatherParent=$tempString[$i];
		break;
		}
	if (`attributeExists curveGuide $tempString[$i]`)
		$arrivedAtTaggedJoint=1;
	}
if (`gmatch $ctrl "*_R"` && `objExists ($nearestFeatherParent+"_R")`) $nearestFeatherParent+="_R";
else if (`gmatch $ctrl "*_L"` && `objExists ($nearestFeatherParent+"_L")`) $nearestFeatherParent+="_L";
else $nearestFeatherParent+="_M";
return $nearestFeatherParent;
}

global proc asRemoveAllUnusedInfluences ()
{
string $sel[]=`ls -sl`;
string $tempString[],$tempString2[];
string $meshes[]=`ls -type mesh`;
for ($i=0;$i<size($meshes);$i++)
	{
	$tempString=`listHistory -pdo 1 $meshes[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		if (`objectType $tempString[$y]`=="skinCluster")
			{
			select `listRelatives -p $meshes[$i]`;
			removeUnusedInfluences;
			}
	}
select $sel;
print "// Unused influences removed.\n";
}

global proc asSaveUIs ()
{
delete `ls sceneConfigurationScriptNode`;
delete `ls uiConfigurationScriptNode`;
delete `ls -type hyperView`;
flushUndo;
print "// Saved UI hyperGraph layouts, etc now removed.\n";
print "// Note: Save and re-open this file, for this to take effect.\n";
}

global proc asDeleteUnusedJoints ()
{
string $jointChildren[],$tempString[];
string $joints[]=`listRelatives -ad -type joint DeformationSystem`;

if (`objExists root`)
	if (`attributeExists skinTransferred root`)
		error ("Unable to Delete UnusedJoints, because currently weights are transferred to Unreal Skeleton, which would cause undesired results.");

for ($i=0;$i<size($joints);$i++)
	{
	$jointChildren=`listRelatives -ad -type joint $joints[$i]`;
	if (size($jointChildren))
		continue;
	$tempString=`listConnections -s 0 -d 1 ($joints[$i]+".worldMatrix")`;
	if (!size($tempString))
		{
		print ("// deleting joint:\""+$joints[$i]+"\"\n");
		delete $joints[$i];
		}
	}
}

global proc freezeSkinCluster (string $skinCluster)
{
if (!`objExists $skinCluster`)
	return;
int $numMatrix;
float $jointMatrix[];
string $tempString[]=`ls -showType $skinCluster`;

$numMatrix=`getAttr -s ($skinCluster+".bindPreMatrix")`;
for ($i=0;$i<$numMatrix;$i++)
	{
	$tempString=`listConnections -s 1 -d 1 ($skinCluster+".matrix["+$i+"]")`;
	if (!`objExists $tempString[0]`)
		continue;
	$jointMatrix=`getAttr ($tempString[0]+".worldInverseMatrix")`;
	setAttr ($skinCluster+".bindPreMatrix["+$i+"]") -type "matrix" $jointMatrix[0] $jointMatrix[1] $jointMatrix[2] $jointMatrix[3] $jointMatrix[4] $jointMatrix[5] $jointMatrix[6] $jointMatrix[7] $jointMatrix[8] $jointMatrix[9] $jointMatrix[10] $jointMatrix[11] $jointMatrix[12] $jointMatrix[13] $jointMatrix[14] $jointMatrix[15];
	}
}

global proc asSetDisplayLayersToR ()
{
string $displayLayers[]=`listConnections layerManager.displayLayerId`;
for ($i=$y=0;$i<size($displayLayers);$i++)
	{
	if ($displayLayers[$i]=="defaultLayer")
		continue;
	setAttr ($displayLayers[$i]+".displayType") 2;
	}
}

global proc float asGetScale ()
{
float $scale=1;
if (!`objExists FitSkeleton`)
	return $scale;
float $maxY;
float $pos[];
$tempString=`asListAllDecents FitSkeleton`;
for ($i=0;$i<size($tempString);$i++)
	{
	$pos=`xform -q -ws -t $tempString[$i]`;
	if ($pos[1]>$maxY)
		$maxY=$pos[1];
	}
if ($maxY>0)
	$scale=$maxY/17.176163;
return $scale;
}

global proc asPublish ()
{
string $sceneName=`file -q -sn`;
if ($sceneName=="")
	error "File not saved, can not publish";
string $tempString[];
string $filePath,$publishFile;
string $basename=`basenameEx $sceneName`;
tokenize $sceneName "/" $tempString;
for ($i=0;$i<size($tempString)-1;$i++)
	$filePath+=$tempString[$i]+"/";
if (`gmatch $sceneName "*[.]mb"`)
	{
	print "// Your working file is already MB format, appending \"_Published\" to the name.\n";
	$publishFile=$filePath+$basename+"_Published.mb";
	}
else
	$publishFile=$filePath+$basename+".mb";
if (`file -q -ex $publishFile`)
	{
	print ("// Publish file already exits, performing incrementalSave for backup.\n");
	file -rename $publishFile;
	incrementalSaveScene;
	file -rename $sceneName;
	}

//string $references[]=`file -q -r`;
//for ($i=0;$i<size($references);$i++)
//	file -importReference $references[$i];
file -f -op "v=0" -typ "mayaBinary" -ea $publishFile;

print ("// Published: \""+$publishFile+"\".\n");
}

global proc asReBuildDagPose ()
{
select `ls -type dagPose "bindPose*"`;
if (size(`ls -sl`)) delete;
select -hi Root_M;
if (`objExists |root`) //Unreal Skeleton
	select -hi |root;
select -d `ls -sl "*Constraint*"`;
string $bindPoseNode=`dagPose -save -selection -bindPose -name bindPose`;
select -cl;
print ("// dagPose node: \""+$bindPoseNode+"\" created.\n");
}

global proc asFbxExport ()
{
string $plugins[]=`pluginInfo -q -ls`;
for ($plug in $plugins)
	if (!`stringArrayCount "fbxmaya" $plugins`)
	error "You Must Load the \"fbxmaya\" plugin !";

select -r DeformationSystem Geometry;
if (`objExists |root`) //Unreal Skeleton
	select |root Geometry;
refresh;

optionVar -sv "defaultFileExportActiveType" "FBX export";
ExportSelection;
}

global proc asDeleteAdvanced ()
{
string $tempString[],$tempString2[];

if (!`objExists FitSkeleton`)
	return;
asJointsVisibility 1;
if (!`objExists |FitSkeleton`)
	parent -w FitSkeleton;
if (`objExists Geometry`)
	{
	$tempString=`listRelatives -type transform -c Geometry`;
	if (size($tempString))
		parent -w $tempString;
	}
if (`objExists Sets`)
	{
	//disable some node-types to avoid warnings
	$tempString=`ls -type expression -type curveInfo`;
	for ($i=0;$i<size($tempString);$i++)
		if (`sets -im AllSet $tempString[$i]`)
			{
			$tempString2=`listConnections -c 1 -p 1 ($tempString[$i]+".inputCurve")`;
			if (size($tempString2))
				disconnectAttr $tempString2[1] $tempString2[0];
			}
	select Sets;
	select -d `listConnections -type animCurve FitSkeleton`;//keep drivingSystems
	delete;
	if (`objExists DeformSet`) delete DeformSet;
	if (`objExists ControlSet`) delete ControlSet;
	if (`objExists AllSet`) delete AllSet;
	if (`objExists Sets`) delete Sets;
	}
print ("// Existing AdvancedSkeleton removed.\n");
asUpdateButtonEnables;
}

global proc asReBuildAdvancedSkeleton ()
{
global int $asBuilding;
global int $asRebuilding;
global string $gMainProgressBar;

int $asConfirmIfNotInBuildPose=`asConfirmIfNotInBuildPose`;
if (!$asConfirmIfNotInBuildPose)
	return;

if (!`objExists "Group"`)
	{
	$asBuilding=1;
	asBuildAdvancedSkeleton;//First build
	if (`checkBox -q -ex asKeepAllCheckBox`)
		checkBox -e -m 1 asKeepAllCheckBox;
	if (`button -q -ex asToggleFitSkeletonButton`)
		button -e -m 1 asToggleFitSkeletonButton;
	if (`button -q -ex asBuildAdvancedSkeletonButton`)
		button -e -l "ReBuild AdvancedSkeleton" asBuildAdvancedSkeletonButton;
	$asBuilding=0;
	return;
	}
if (`objExists "prefix_Group"`)
	error "Object \"prefix_Group\" found, which means a previous build failed. Try to Undo previous build, to restore functional AdvancedSkeleton";

if (`objExists "Group"` && `objExists FitSkeleton`)
	if (!`getAttr FitSkeleton.visibility`)
		asToggleFitAdvancedSkeleton;

int $keepAll=`checkBox -q -v asKeepAllCheckBox`;
int $keepCurveShapes=`checkBox -q -v asKeepCurveShapesCheckBox`;
int $keepBuildPose=`checkBox -q -v asKeepBuildPoseCheckBox`;
int $keepParenting=`checkBox -q -v asKeepParentingCheckBox`;
int $keepParentConstraints=`checkBox -q -v asKeepParentConstraintsCheckBox`;
int $keepLockHide=`checkBox -q -v asKeepLockHideCheckBox`;
int $keepUserAttrs=`checkBox -q -v asKeepUserAttrsCheckBox`;
int $keepLimits=`checkBox -q -v asKeepLimitsCheckBox`;
int $keepSkinning=`checkBox -q -v asKeepSkinningCheckBox`;

string $tempString[],$tempString2[],$sources[],$destinations[],$sourcesNoPlug[],$destinationsNoPlug[];
string $roots[];

if (!`objExists FitSkeleton`)
	error "No skeleton to rebuild\n";
parent -w FitSkeleton;

progressBar -e -st "Analyzing AdvancedSkeleton" -bp -ii 0 -min 0 -max (size(`sets -q AllSet`)*2) $gMainProgressBar;

//Pre Rebuild
float $mx[];
string $trs[]={"t","r","s"};
string $xyz[]={"x","y","z"};
string $userAttrs[],$children[],$connections[],$connectionsObj[],$connectCmdsSource[],$connectCmdsDest[];
string $addAttrCmds[],$cmds[],$connectCmds[],$skinClusters[],$jointClusters[],$checkAttrs[];
string $sn,$ln,$at,$k,$cb,$dv,$minMax,$enumName,$skinCluster,$control;
string $charSet,$objectType,$tr,$target,$restorePoseCmd,$preRebuildScript,$postRebuildScript;
int $childIsMember,$alreadyConnected;
int $locked;
int $e[2];
float $range[2];
float $vals[2];

//Pre Rebuild : preRebuildScript
if (!`attributeExists preRebuildScript FitSkeleton`)
	asEnsureFitSkeletonAttributes;
$preRebuildScript=`getAttr FitSkeleton.preRebuildScript`;
if ($preRebuildScript!="")
	evalEcho ($preRebuildScript);

if (`objExists CustomSystem` && `objExists ControlSet`)
	sets -rm ControlSet `listRelatives -ad CustomSystem`;

//getting $allSetMembers after preRebuildScript, as it may rename controllers
string $allSet="AllSet";
string $allSetMembers[]=`sets -q $allSet`;
string $controlSet="ControlSet";
string $controlSetMembers[]=`sets -q $controlSet`;

if (`objExists FaceAllSet`)
	if (`sets -im "Sets" FaceAllSet`)
		sets -rm "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	if (`sets -im "Sets" FaceControlSet`)
		sets -rm "Sets" FaceControlSet;

//Pre Rebuild : $keepBuildPose
if (!$keepAll && !$keepBuildPose)
	if (`objExists FitSkeleton`)
		if (`attributeExists run FitSkeleton`)
			setAttr -type "string" FitSkeleton.run "";

//Pre Rebuild : Bind Pose is not same as Build Pose
if ($asConfirmIfNotInBuildPose==2)
	$restorePoseCmd=`asGetRestorePoseCmd`;

//Pre Rebuild parentConstraints
string $constraintParent,$constraintChild;
string $parentConstraints[]=`ls -type parentConstraint`;
string $parentConstraintParents[],$parentConstraintChildren[];
for ($i=$y=0;$i<size($parentConstraints);$i++)
	{
	if (!$keepAll && !$keepParentConstraints)
		continue;
	if (`sets -im $allSet $parentConstraints[$i]` || `gmatch $parentConstraints[$i] "*Box_*"`)
		continue;
	if ($parentConstraints[$i]=="AimEyeFollow_M_parentConstraint1")//connected multiTarget constraint
		continue;

	$tempString=`listConnections ($parentConstraints[$i]+".target[0].targetJointOrient")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintParent=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	$tempString=`listConnections ($parentConstraints[$i]+".constraintTranslate.constraintTranslateX")`;
	tokenize $tempString[0] "|" $tempString;
	$constraintChild=`substitute "prefix_" $tempString[size($tempString)-1] ""`;

	if (!`objExists $constraintParent` || !`objExists $constraintChild`)
		continue;
	if (!`sets -im $allSet $constraintParent` && !`sets -im $allSet $constraintChild`)
		continue;

	$parentConstraintParents[$y]=$constraintParent;
	$parentConstraintChildren[$y]=$constraintChild;
	delete $parentConstraints[$i];
	$y++;
	}

//Pre Rebuild userDefinedAttr
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepUserAttrs)
		continue;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	$userAttrs=`listAttr -ud $allSetMembers[$i]`;
	for ($y=0;$y<size($userAttrs);$y++)
		{
		$tempString=`listAttr -sn ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$sn=$tempString[0];
		$ln=$userAttrs[$y];
		$at=`getAttr -typ ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="float")
			$at="double";
		if (`gmatch $at "*Array"` || $at=="message")
			continue;
		$dv=`getAttr ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$k=`getAttr -k ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		$cb=`getAttr -cb ($allSetMembers[$i]+"."+$userAttrs[$y])`;
		if ($at=="string")
			continue;
		if (`gmatch $ln "*W[0-9]"`)
			continue;
		$minMax="";
		if (`attributeQuery -re -n $allSetMembers[$i] $ln`)
			{
			$range=`attributeQuery -r -n $allSetMembers[$i] $ln`;
			$minMax="-hasMinValue 1 -min "+$range[0]+" -hasMaxValue 1 -max "+$range[1];
			}
		$enumName="";
		if ($at=="enum")
			$enumName="-en \""+`addAttr -q -en ($allSetMembers[$i]+"."+$userAttrs[$y])`+"\"";
		$addAttrCmds[size($addAttrCmds)]="if (!`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	addAttr -k "+$k+" -sn "+$sn+" -ln "+$ln+" -at "+$at+" -dv "+$dv+" "+$minMax+" "+$enumName+" "+$allSetMembers[$i]+";";
		//Non-keyable
		if ($k=="0" && $cb)
			$addAttrCmds[size($addAttrCmds)]="if (`attributeExists "+$userAttrs[$y]+" "+$allSetMembers[$i]+"`)"
					+"	setAttr -cb 1 "+$allSetMembers[$i]+"."+$userAttrs[$y]+";";
		}
	}

//Pre Rebuild Geometry-Parenting (anything parented to "Geometry", will always be preserved)
if (`objExists Group|Geometry`)
	{
	$children=`listRelatives -c Geometry`;
	$cmds[size($cmds)]="parent Geometry Group";
	}

//Pre Rebuild Parenting
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepParenting)
		continue;
	if (!`objExists $allSetMembers[$i]`)
		continue;
	if (`objectType $allSetMembers[$i]`=="objectSet")
		continue;

	//non AS onto AS
	$children=`listRelatives -c $allSetMembers[$i]`;
	for ($y=0;$y<size($children);$y++)
		{
		$tempString=`ls $children[$y]`;
		if (size($tempString)>1)
			error ("ObjectName not unique "+$children[$y]+"\n");
		$childIsMember=0;
		for ($z=0;$z<size($allSetMembers);$z++)
			if ($children[$y]==$allSetMembers[$z])
				$childIsMember=1;
		if ($children[$y]=="Geometry")
			continue;
		if (!$childIsMember)
			{
			$tempString=`ls -s $children[$y]`;
			if ($tempString[0]!="")
				$cmds[size($cmds)]="parent -r -s "+$children[$y]+" "+$allSetMembers[$i]+";";
			else if (`getAttr ($children[$y]+".inheritsTransform")` && !`gmatch $children[$y] "*_?_[0-9][0-9]"`)
				$cmds[size($cmds)]="parent "+$children[$y]+" "+$allSetMembers[$i]+";";
			else
				$cmds[size($cmds)]="parent -r "+$children[$y]+" "+$allSetMembers[$i]+";";
			}
		}

	// AS onto non AS
	$tempString=`listRelatives -p $allSetMembers[$i]`;
	if ($tempString[0]!="")
		if (!`sets -im AllSet $tempString[0]`)
			$cmds[size($cmds)]="parent "+$allSetMembers[$i]+" "+$tempString[0]+";";
	}

//Pre Rebuild $keepSkinning
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepSkinning)
		continue;

	//Incoming connections
	$connections=`listConnections -p 1 -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 1 -d 0 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		if ($connections[$y+1]=="Group.message")
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver" || $objectType== "displayLayerManager")
			continue;
		if ($connections[$y+1]=="time1.outTime")
			continue;
		if (`attributeExists drivingSystemOut $connectionsObj[$y+1]`)//drivingSystem SDK`s to be connected elsewhere
			continue;
		$connectCmds[size($connectCmds)]="if (`getAttr -l "+$connections[$y]+"`)  setAttr -l 0 "+$connections[$y]+";connectAttr -f "+$connections[$y+1]+" "+$connections[$y]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y+1];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y];
		}

	//Outgoing connections
	$connections=`listConnections -p 1 -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	$connectionsObj=`listConnections -c 1 -s 0 -d 1 $allSetMembers[$i]`;
	for ($y=0;$y<size($connections);$y=$y+2)
		{
		if (!`objExists $connectionsObj[$y+1]`)
			continue;
		if (`sets -im $allSet $connectionsObj[$y+1]`)
			continue;
		$objectType=`objectType $connectionsObj[$y+1]`;
		if ($objectType=="materialInfo" || $objectType=="partition")
			continue;
		//changed to allow user-defined selection-set to persist
//		if ($objectType=="objectSet" || $objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
		if ($objectType=="objectSet")
			if ($connectionsObj[$y+1]=="AllSet" || $connectionsObj[$y+1]=="ControlSet" || $connectionsObj[$y+1]=="DeformSet")
				continue;
		if ($objectType=="ikSCsolver" || $objectType=="ikRPsolver" || $objectType=="hikSolver" || $objectType=="ikSplineSolver")
			continue;
		if (`gmatch $connections[$y] "*instObjGroups*"` || `gmatch $connections[$y+1] "*instObjGroups*"`)
			if ($objectType!="objectSet")
				continue;
		if ($objectType=="skinCluster")
			$skinClusters[size($skinClusters)]=$connectionsObj[$y+1];
		if ($objectType=="jointCluster")
			$jointClusters[size($jointClusters)]=$connectionsObj[$y+1];
		$connectCmds[size($connectCmds)]="connectAttr -f "+$connections[$y]+" "+$connections[$y+1]+";";
		$connectCmdsSource[size($connectCmds)-1]=$connections[$y];
		$connectCmdsDest[size($connectCmds)-1]=$connections[$y+1];
		}
	}

//Pre Rebuild $transformLimits
for ($i=0;$i<size($allSetMembers);$i++)
	{
	progressBar -e -s 1 $gMainProgressBar;
	if (!$keepAll && !$keepLimits)
		continue;

	if (`objectType $allSetMembers[$i]`=="joint" || `sets -im ControlSet $allSetMembers[$i]`)
		{
		$tr="r";
		for ($y=0;$y<2;$y++)
			{
			if ($y==1)
				continue;
			for ($z=0;$z<size($xyz);$z++)
				{
				$e=`eval ("transformLimits -q -e"+$tr+$xyz[$z]+" "+$allSetMembers[$i])`;
				if ($e[0] || $e[1])
					{
					$vals=`eval ("transformLimits -q -"+$tr+$xyz[$z]+" "+$allSetMembers[$i])`;
					$cmds[size($cmds)]="transformLimits -"+$tr+$xyz[$z]+" "+$vals[0]+" "+$vals[1]+" -e"+$tr+$xyz[$z]+" "+$e[0]+" "+$e[1]+" "+$allSetMembers[$i]+";";
					}
				}
			}
		}
	}

//Pre Rebuild Lock and Hide
for ($i=0;$i<size($controlSetMembers);$i++)
	for ($y=0;$y<size($trs);$y++)
		for ($z=0;$z<size($xyz);$z++)
			{
			if (!$keepAll && !$keepLockHide)
				continue;
			if (`getAttr -l ($controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z])`)
				$cmds[size($cmds)]="setAttr -l 1 "+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+";";
			if (!`getAttr -k ($controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z])`)
				$cmds[size($cmds)]="setAttr -k 0 "+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+";";
			if (`getAttr -cb ($controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z])`)
				$cmds[size($cmds)]="setAttr -cb 1 "+$controlSetMembers[$i]+"."+$trs[$y]+$xyz[$z]+";";
			}

//Pre Rebuild CurveShapes
string $curveShape;
int $spans,$degree,$numCVs;
float $cvPos[3];
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!$keepAll && !$keepCurveShapes)
		continue;
	$tempString=`listRelatives -s $controlSetMembers[$i]`;
	for ($z=0;$z<size($tempString);$z++)
		{
		$curveShape=$tempString[$z];
		if (!`objExists $curveShape`)
			continue;
		if (`objectType $curveShape`!="nurbsCurve")
			continue;
		$spans=`getAttr ($curveShape+".spans")`;
		$degree=`getAttr ($curveShape+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$cvPos=`getAttr ($curveShape+".controlPoints["+$y+"]")`;
			$cmds[size($cmds)]="setAttr "+$curveShape+".controlPoints["+$y+"] "+$cvPos[0]+" "+$cvPos[1]+" "+$cvPos[2]+" "+";";
			}
		//color
		$cmds[size($cmds)]="setAttr "+$curveShape+".overrideColor "+`getAttr ($curveShape+".overrideColor")`+";";
		}
	}

//Pre Rebuild Disable expressions to avoid warnings
$tempString=`ls -type expression`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im $allSet $tempString[$i]`)
		setAttr ($tempString[$i]+".nodeState") 1;

//Pre Rebuild joint.drawStyle (joint visibility)
clear $tempString;
if (`objExists |Group`)
	$tempString=`listRelatives -f -type joint -ad |Group`;
for ($i=0;$i<size($tempString);$i++)
	$cmds[size($cmds)]="setAttr "+$tempString[$i]+".drawStyle "+`getAttr ($tempString[$i]+".drawStyle")`+";";

//Rebuild
$allSetMembers[size($allSetMembers)]="Group";
$allSetMembers[size($allSetMembers)]="Sets";
$allSetMembers[size($allSetMembers)]="AllSet";
$allSetMembers[size($allSetMembers)]="ControlSet";
$allSetMembers[size($allSetMembers)]="DeformSet";

for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		$allSetMembers[$i]=`rename $allSetMembers[$i] ("prefix_"+$allSetMembers[$i])`;
	else
		$allSetMembers[$i]="";

//unprefix CylShapes in order to preserve these
$tempString=`ls -type nurbsSurface "*_CylShape*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`objExists $tempString[$i]`)
		rename $tempString[$i] `substitute "prefix_" $tempString[$i] ""`;

//unprefix Added Shapes in order to preserve these (they might have `inherited the prefixing from parent transform)
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`objExists ("prefix_"+$controlSetMembers[$i])`)
		continue;
	$tempString=`listRelatives -s ("prefix_"+$controlSetMembers[$i])`;
	for ($y=0;$y<size($tempString);$y++)
		if (`gmatch $tempString[$y] "prefix_*"`)
			if (!`sets -im prefix_AllSet $tempString[$y]`)
				rename $tempString[$y] `substitute "prefix_" $tempString[$y] ""`;
	}

progressBar -e -ep $gMainProgressBar;


$asRebuilding=1;
asBuildAdvancedSkeleton;
$asRebuilding=0;


//redo parentConstraints
for ($i=0;$i<size($parentConstraintParents);$i++)
	if (`objExists $parentConstraintParents[$i]` && `objExists $parentConstraintChildren[$i]`)
		parentConstraint -mo $parentConstraintParents[$i] $parentConstraintChildren[$i];


//Post Rebuild
for ($cmd in $addAttrCmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");
for ($i=0;$i<size($connectCmds);$i++)
	{
	$alreadyConnected=0;
	if (`objExists $connectCmdsSource[$i]` && `objExists $connectCmdsDest[$i]`)
		if (`isConnected -iuc $connectCmdsSource[$i] $connectCmdsDest[$i]`)
			$alreadyConnected=1;
	if (!$alreadyConnected)
		if (catchQuiet (`eval ($connectCmds[$i])`)) warning ("Failed: "+$connectCmds[$i]+"\n");
	}
for ($cmd in $cmds)
	if (catchQuiet (`eval ($cmd)`)) warning ("Failed: "+$cmd+"\n");

//Post Rebuild Remove attributes that were restored due to increased number of IK controls
$checkAttrs={"ikCvVis","stretchy","follow","volume"};
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`gmatch $controlSetMembers[$i] "IK*[0-9]*"`)
		continue;
	for ($y=0;$y<size($checkAttrs);$y++)
		if (`attributeExists $checkAttrs[$y] $controlSetMembers[$i]`)
			{
			$tempString=`listConnections -s 0 -d 1 ($controlSetMembers[$i]+"."+$checkAttrs[$y])`;
			if (!size($tempString))
				deleteAttr ($controlSetMembers[$i]+"."+$checkAttrs[$y]);
			}
	}

//Post Rebuild CurveShapes, that have non-matching spans or degree or form
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	if (!`objExists $controlSetMembers[$i]`)
		continue;

	clear $tempString;
	if (`objExists ("prefix_"+$controlSetMembers[$i])`)
		$tempString=`listRelatives -s ("prefix_"+$controlSetMembers[$i])`;
	for ($z=0;$z<size($tempString);$z++)
		{
		$tempString2=`listRelatives -p $tempString[$z]`;
		$control=`substitute "prefix_" $tempString2[0] ""`;
		$curveShape=`substitute "prefix_" $tempString[$z] ""`;
		if (!`objExists $control`)
			continue;

		if (!`objExists $curveShape`)//multi curve shapes
			{
			sets -rm prefix_AllSet $tempString[$z];
			parent -r -s $tempString[$z] $control;
			rename $tempString[$z] $curveShape;
			continue;
			}

		if ((`getAttr ($curveShape+".spans")`==`getAttr ("prefix_"+$curveShape+".spans")`)
			&& (`getAttr ($curveShape+".degree")`==`getAttr ("prefix_"+$curveShape+".degree")`)
			&& (`getAttr ($curveShape+".form")`==`getAttr ("prefix_"+$curveShape+".form")`))
			continue;
		connectAttr -f ("prefix_"+$curveShape+".local") ($curveShape+".create");

		if (!`objExists tempCurveForRefresh`)
			{
			curve -n tempCurveForRefresh -d 1 -p 0 0 0 -k 0;
			}
		connectAttr ($curveShape+".local") tempCurveForRefresh.create;
		refresh;
		if (`objExists tempCurveForRefresh`)
			delete tempCurveForRefresh;
		}
	}

//reset bindPose
string $bindPose;
string $newSetMembers[]=`sets -q $allSet`;
for ($i=0;$i<size($newSetMembers);$i++)
	{
	if (`objectType $newSetMembers[$i]`=="joint")
		{
		select $newSetMembers[$i];
		$tempString=`dagPose -q -bp`;
		$bindPose=$tempString[0];
		if (`objExists $bindPose`)
			{
			$tempString=`listConnections ($newSetMembers[$i]+".bindPose")`;
			if ($tempString[0]==$bindPose)
				{
				select -add $bindPose;
				dagPose -rs;
				}
			}
		}
	}

if ($asConfirmIfNotInBuildPose==2) //Bind Pose is not same as Build Pose
	{
	tokenize $restorePoseCmd ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		catchQuiet (`eval($tempString[$i])`);
	}

for ($i=0;$i<size($allSetMembers);$i++)
	if (`gmatch $allSetMembers[$i] "*CurveInfo*"`)
		if (`objExists $allSetMembers[$i]`)
			delete $allSetMembers[$i];

if (`objExists prefix_Group`) delete prefix_Group;
if (`objExists prefix_volume1OverSpine_M`) delete prefix_volume1OverSpine_M;
refresh;
for ($i=0;$i<size($allSetMembers);$i++)
	if (`objExists $allSetMembers[$i]`)
		catchQuiet (`delete $allSetMembers[$i]`);

$skinClusters=`stringArrayRemoveDuplicates $skinClusters`;
$jointClusters=`stringArrayRemoveDuplicates $jointClusters`;
for ($i=0;$i<size($skinClusters);$i++)
	freezeSkinCluster $skinClusters[$i];
for ($i=0;$i<size($jointClusters);$i++)
	freezeJointCluster $jointClusters[$i];

if (`objExists FaceAllSet`)
	sets -add "Sets" FaceAllSet;
if (`objExists FaceControlSet`)
	sets -add "Sets" FaceControlSet;

//if ($runCmd!="")
//	evalEcho $runCmd;

//Post Rebuild : postRebuildScript
$postRebuildScript=`getAttr FitSkeleton.postRebuildScript`;
if ($postRebuildScript!="")
	evalEcho ($postRebuildScript);

eval ("dgdirty -a");
select -cl;
print "// ReBuild Complete\n";
}

global proc asBuildAdvancedSkeleton ()
{
global int $asRebuilding;
global string $gSelect;
string $iconsFile=`asGetScriptLocation`+"/AdvancedSkeleton5Files/div/asIcons.ma";

//FitSkeleton from basic joints
string $selJoints[]=`ls -sl -type joint`;
if (!`objExists FitSkeleton` && size($selJoints))
	{
	asCreateFitSkeleton;
	parent $selJoints[0] FitSkeleton;
	}

float $scale=`asGetScale`;
float $sideTreshold=0.0001*$scale;

//preBuild check
if (!`objExists FitSkeleton`)
	error "FitSkeleton not found. You must import a FitSkeleton, or select a joint-chain.\n";
if (!`file -q -ex $iconsFile`)
	error ("File not found:"+$iconsFile);
if (!$asRebuilding)
	if (`objExists "Group"`)
		error "AdvancedSkeleton already exists, use ReBuild instead";
string $tempString[]=`listRelatives -c -type joint FitSkeleton`;
if ($tempString[0]=="")
	{
	asFitModeManualUpdate;//some fitJoints could have `generated xforms`, then this will remove them.
	$tempString=`listRelatives -c -type joint FitSkeleton`;
	if ($tempString[0]=="")
		error "FitSkeleton has no joints parented to it";
	}
float $firstJointPos[3]=`xform -q -ws -t $tempString[0]`;
if ($tempString[0]=="Root" && ($firstJointPos[0]>$sideTreshold || $firstJointPos[0]<(-1*$sideTreshold)))
	{//Existing Root but not centered, gets renamed, so new centered root gets generated
	rename Root RootSide;
	$tempString=`listRelatives -c -type joint FitSkeleton`;
	}
if ($tempString[0]!="Root")
	{
	if (`objExists "Root"`)
		error "The top-level joint must be named \"Root\", but another object in this scene is already called Root";
	if ($firstJointPos[0]<$sideTreshold && $firstJointPos[0]>(-1*$sideTreshold))
		rename $tempString[0] Root;
	else
		{
		select FitSkeleton;
		joint -n Root;
		xform -ws -t 0 $firstJointPos[1] $firstJointPos[2] Root;
		parent $tempString[0];
		}
	}

if (`exists softSelect`)
	softSelect -e -softSelectEnabled 0;
if (`symmetricModelling -q -s`)
	symmetricModelling -e -s 0;

asFitModeManualUpdate; //Ensure joint rotations & jointOrientations & uniqueNames
asOffFitMode;

string $fitJoints[]=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	asEnsureFitJointAttrs $fitJoints[$i];

string $rootIKInfo[]=`asFitJointIKInfo Root`;
string $nonCenteredSpineJoints="";
if ($rootIKInfo[0]=="Spine")
	{
	string $rootIKJoints[]=`asGetIKJoints $rootIKInfo[1] $rootIKInfo[3]`;
	for ($i=0;$i<size($rootIKJoints);$i++)
		{
		float $rootIKJointPos[]=`xform -q -ws -t $rootIKJoints[$i]`;
		if ($rootIKJointPos[0]>$sideTreshold || $rootIKJointPos[0]<($sideTreshold*-1))
			$nonCenteredSpineJoints+="\""+$rootIKJoints[$i]+"\" ";
		}
	if ($nonCenteredSpineJoints!="")
		error ("These Spine joints are not in the center: "+$nonCenteredSpineJoints);
	}


setToolTo $gSelect;
asSetFixedWrapOptions;
int $numLetters,$centerBtwFeet,$inbetweenJoints,$reachedQtoes,$hasChildWithToesLabel,$stiffCtrl1Nr,$stiffCtrl2Nr,$stiffLocNr,$closestIkCtrlNr1,$closestIkCtrlNr2,$ikControlNr,$numChar,$x,$y,$z,$xUp,$yUp,$zUp;
int $fitJointTwistJoints[],$fitJointUpTwistJoints[],$fitJointBendyJoints[],$fitJointUpBendyJoints[],$fitJointBend[],$fitJointInbetweenJoints[],$fitJointUnTwister[],$fitJointRotOrder[];
int $fitJointIsEndJoint[],$ikLocal[],$ikLocalType[],$isScapula[],$fitJointGlobal[],$fitJointsWheel[],$fitJointFirstAfterIK[],$fitJointNonDef[];
int $fitJointsAim[],$fitJointNoMirror[],$fitJointNoFlip[],$fitJointNoControl[],$fitJointNoSkin[],$fitJointGlobalTranslate[];
int $isIKStart[],$isIKEnd[],$isIKBelowIKEnd[],$fitJointIKNumCtrls[],$fitJointIKNumCtrlsFakeMid[];
int $fitJointLockTx[],$fitJointLockTy[],$fitJointLockTz[],$fitJointLockRx[],$fitJointLockRy[],$fitJointLockRz[],$fitJointLockSx[],$fitJointLockSy[],$fitJointLockSz[],$fitJointsAimAxis[],$fitJointsAimUpAxis[];
float $pos[3],$pos2[3],$rot[3],$sca[3],$parentPos[3],$parentRot[3],$temp[3],$temp2[3],$temp3[3],$aimV[3];
float $footRotX[],$ikLenght[],$fitJointGlobalValue[];
float $dist,$minDist,$minDist1,$minDist2,$defaultDistance,$posFactor,$invPosFactor,$weight,$fat,$fatY,$fatZ,$lockCenterTolerance,$height,$lenght,$width,$maxFitJoint,$minFitJoint,$iconScaleFactor,$twistDistance,$w;
float $defaultAngleDirection,$defaultAngle,$defaultUnstretchedLenght,$defaultOffsetAngle,$yy,$zz,$scalerWeight,$parameter,$hf,$diameter,$scaleFactor;
$scale=`asGetScale`;
string $side,$childSide,$parent,$joint,$multipleDivide,$childLabel,$ankle,$heel,$toes,$toesEnd,$bigToe,$pinkyToe,$scapula,$label,$offsetParent,$curveGuide,$ctrl,$ikParentConstraintTo,$worldUpObject,$inbetweenJoint;
string $startJoint,$endJoint,$IKEndJoint,$blendWeighted,$newSDK,$ds,$dsObjName,$dsSide,$aimAtSide;
string $fitJointLabel[],$fitJointSide[],$fitJointParent[],$fitJointParentSide[],$fitJointChild[],$fitJointChildSide[],$fitJointQtoes[];
string $fitJointsAttachTo[],$fitJointsAttachMode[],$fitJointsAimAt[],$fitJointsCurveGuide[],$tempString2[],$tempString3[],$FKXJoints[],$sdks[],$sdkPlugs[];
string $asFitJointIKInfo[],$fitJointIK[],$fitJointIKStartJoint[],$fitJointIKMiddleJoint[],$fitJointIKEndJoint[],$fitJointIKSolver[],$IKJoints[],$userAttrs[],$footRollJoints[];
string $allBefore[]=`ls`;

if (`objExists FitSkeletonVisualizers`)
	{
	delete FitSkeletonVisualizers;
	asUpdateButtonEnables;
	}

int $numMainExtras=0;
if (`attributeExists numMainExtras FitSkeleton`)
	$numMainExtras=`getAttr FitSkeleton.numMainExtras`;

createNode -n "iconsGroup" transform;
setAttr "iconsGroup.visibility" 0;
asImportIconsFile $iconsFile;

//--Sets--//
select -cl;
sets -name ControlSet;
sets -name DeformSet;
sets -name AllSet;
sets -name "Sets";
sets -add "Sets" AllSet ControlSet DeformSet;
sets -add ControlSet `listRelatives -c iconsGroup`;

createNode -n "Group" transform;
asLockAttr "Group" 1 1 1 0;
duplicate -n Main Main_icon;
parent Main "Group";
xform -s (0.285*$scale) (0.285*$scale) (0.285*$scale) Main.cv[0:7];
connectAttr -f FitSkeletonShape.worldSpace[0] MainShape.create;
refresh;
disconnectAttr FitSkeletonShape.worldSpace[0] MainShape.create;

for ($i=1;$i<$numMainExtras+1;$i++)
	{
	if ($i==1)
		duplicate -n ("MainExtra"+$i) Main;
	else
		duplicate -n ("MainExtra"+$i) ("MainExtra"+($i-1));
	xform -s 1.1 1.1 1.1 ("MainExtra"+$i+".cv[0:7]");
	setAttr ("MainExtra"+$i+"Shape.overrideColor") (19+$i);
	}
for ($i=1;$i<$numMainExtras;$i++)
	parent ("MainExtra"+$i) ("MainExtra"+($i+1));
if ($numMainExtras>0)
	parent Main MainExtra1;

//--3rd level transforms--//
parent FitSkeleton Main;
createNode -n MotionSystem transform;
createNode -n DeformationSystem transform;
if (!$asRebuilding || !`objExists Geometry`)
	{
	createNode -n Geometry transform;
	setAttr -l 1 Geometry.inheritsTransform 0;
	parent Geometry "Group";
	}
parent MotionSystem DeformationSystem Main;
setAttr -l 0 FitSkeleton.v;
setAttr -l 1 FitSkeleton.v 0;
connectAttr -f MotionSystem.visibility MainShape.visibility;
for ($i=1;$i<$numMainExtras+1;$i++)
	connectAttr -f MotionSystem.visibility ("MainExtra"+$i+"Shape.visibility");

//--4th level transforms--//
createNode -n FKSystem -p MotionSystem transform;
createNode -n IKSystem -p MotionSystem transform;
createNode -n FKIKSystem -p MotionSystem transform;
createNode -n BendSystem -p MotionSystem transform;
createNode -n AimSystem -p MotionSystem transform;
createNode -n RootSystem -p MotionSystem transform;
createNode -n TwistSystem -p MotionSystem transform;
createNode -n GlobalSystem -p MotionSystem transform;
createNode -n ConstraintSystem -p MotionSystem transform;
createNode -n DynamicSystem -p MotionSystem transform;	
setAttr BendSystem.inheritsTransform 0;

//--5th level transforms--//
createNode -n IKJoints -p IKSystem transform;
createNode -n IKHandle -p IKSystem transform;
createNode -n IKFollow -p IKSystem transform;
createNode -n IKStatic -p IKSystem transform;
createNode -n IKCurve -p IKSystem transform;
setAttr IKCurve.inheritsTransform 0;
createNode -n IKMessure -p IKSystem transform;

//--6th level transforms--//
createNode -n IKRootConstraint -p IKHandle transform;

addAttr -k 1 -ln fkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkVis;
connectAttr -f Main.fkVis FKSystem.v;
addAttr -k 1 -ln ikVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.ikVis;
connectAttr -f Main.ikVis "IKSystem.v";
addAttr -k 1 -ln fkIkVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fkIkVis;
connectAttr -f Main.fkIkVis FKIKSystem.v;
addAttr -k 1 -ln aimVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimVis;
connectAttr -f Main.aimVis AimSystem.v;
addAttr -k 1 -ln aimFKVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimFKVis;
addAttr -k 1 -ln aimLRVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.aimLRVis;
addAttr -k 1 -ln fingerVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.fingerVis;
addAttr -k 1 -ln bendVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.bendVis;
addAttr -k 1 -ln arrowVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.arrowVis;
addAttr -k 1 -ln drvSysVis -at bool -dv 1 Main;
setAttr -k 0 -cb 1 Main.drvSysVis;
//addAttr -k 1 -ln customVis -at bool -dv 1 Main;
//setAttr -k 0 -cb 1 Main.customVis;
//addAttr -k 1 -ln ikCvVis -at bool -dv 0 Main;
//setAttr -k 0 -cb 1 Main.ikCvVis;
//addAttr -k 1 -ln twistFlip  -at "enum" -en "180:360:" Main;
//setAttr -k 0 -cb 1 Main.twistFlip;
//addAttr -k 1 -ln jointsVis -at bool -dv 1 Main;
//setAttr -k 0 -cb 1 Main.jointsVis;
//connectAttr -f Main.jointsVis DeformationSystem.v;

connectAttr -f Main.bendVis BendSystem.v;

if (`objExists jointLayer`)
	delete jointLayer;
createNode -n jointLayer displayLayer;
//setAttr jointLayer.displayType 2;


//Zero out endJoints
for ($i=0;$i<size($fitJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		{
		$tempString2=`listRelatives -c -type joint $tempString[$y]`;
		if (size($tempString2)==0)
			{
			if (!`getAttr -l ($tempString[$y]+".rx")` && `getAttr -l ($tempString[$y]+".ry")` && `getAttr -l ($tempString[$y]+".rz")`)
				setAttr -type float3 ($tempString[$y]+".rotate") 0 0 0;
			setAttr -type float3 ($tempString[$y]+".jointOrient") 0 0 0;
			}
		}
	}

//Adding inbetweenJoints to FitSkeleton
for ($i=0;$i<size($fitJoints);$i++)
	{
	if (!`attributeExists inbetweenJoints $fitJoints[$i]`)
		continue;
	$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	if ($inbetweenJoints<1)
		continue;
	$rlaChild=`asRlaChild $fitJoints[$i]`;
	if ($rlaChild=="")
		continue;
	select $fitJoints[$i];
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		$inbetweenJoint=$fitJoints[$i]+"Part"+$y;
		joint -n $inbetweenJoint;
		setAttr ($inbetweenJoint+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
		$weight=(1.0/($inbetweenJoints+1))*$y;
		$tempString=`pointConstraint -w $weight $rlaChild $inbetweenJoint`;
		pointConstraint -w (1-$weight) $fitJoints[$i] $inbetweenJoint;
		delete $tempString[0];
		addAttr -k 1 -ln tempInbetweener -at bool -dv 1 $inbetweenJoint;
		addAttr -k 1 -ln noControl -at bool -dv 1 $inbetweenJoint;
		$fat=(`getAttr ($fitJoints[$i]+".fat")`*(1-$weight)) + (`getAttr ($rlaChild+".fat")`*$weight);
		$fatY=(`getAttr ($fitJoints[$i]+".fatY")`*(1-$weight)) + (`getAttr ($rlaChild+".fatY")`*$weight);
		$fatZ=(`getAttr ($fitJoints[$i]+".fatZ")`*(1-$weight)) + (`getAttr ($rlaChild+".fatZ")`*$weight);
		addAttr -k 0 -ln fat -at double -dv $fat $inbetweenJoint;
		addAttr -k 0 -ln fatY -at double -dv $fatY $inbetweenJoint;
		addAttr -k 0 -ln fatZ -at double -dv $fatZ $inbetweenJoint;
		}
	parent $rlaChild $inbetweenJoint;
	}

//Analyze
$fitJoints=`listRelatives -ad -type joint FitSkeleton`;
for ($i=0;$i<size($fitJoints);$i++)
	{
	//Analyze $fitJointLabel
	$fitJointLabel[$i]=`asLabel $fitJoints[$i]`;

	//Analyze $fitJointSide
	$fitJointSide[$i]="_R";
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
		$fitJointSide[$i]="_M";

	//Analyze $fitJointNoMirror & $fitJointNoFlip
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`attributeExists noMirror $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noMirror")`)
				$fitJointNoMirror[$i]=1;
		if (`attributeExists noFlip $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noFlip")`)
				$fitJointNoFlip[$i]=1;
		}


	//Analyze $fitJointNoControl
	if (`attributeExists noControl $fitJoints[$i]`)
		$fitJointNoControl[$i]=`getAttr ($fitJoints[$i]+".noControl")`;

	//Analyze $fitJointNoSkin
	$tempString=`ls -l $fitJoints[$i]`;
	tokenize $tempString[0] "|" $tempString;
	for ($y=0;$y<size($tempString);$y++)
		{
		if (`attributeExists noSkin $tempString[$y]`)
			if (`getAttr ($tempString[$y]+".noSkin")`)
				$fitJointNoSkin[$i]=1;
		}

	//Analyze $fitJointIsEndJoint
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	if ($tempString[0]=="")
		$fitJointIsEndJoint[$i]=1;
	else
		$fitJointIsEndJoint[$i]=0;

	//Analyze rotateOrder
	$fitJointRotOrder[$i]=`getAttr ($fitJoints[$i]+".rotateOrder")`;

	//Analyze Parent
	$tempString=`listRelatives -p -type joint $fitJoints[$i]`;
	$fitJointParent[$i]=$tempString[0];

	//Analyze ParentSide
	if ($fitJointParent[$i]!="")
		{
		$fitJointParentSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointParent[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointParentSide[$i]="_M";
		}

	//Analyze Child
	$tempString=`listRelatives -c -type joint $fitJoints[$i]`;
	$fitJointChild[$i]=$tempString[0];
	//Prefer X-down child
	if (size($tempString)>1)
		for ($y=0;$y<size($tempString);$y++)
			{
			$temp=`getAttr ($tempString[$y]+".t")`;
			if ($temp[1]>-0.01 && $temp[1]<0.01 && $temp[2]>-0.01 && $temp[2]<0.01)
				{
				$fitJointChild[$i]=$tempString[$y];
				break;
				}
			}

	//Analyze ChildSide
	if ($fitJointChild[$i]!="")
		{
		$fitJointChildSide[$i]="_R";
		$temp=`xform -q -ws -t $fitJointChild[$i]`;
		if ($temp[0]<$sideTreshold && $temp[0]>(-1*$sideTreshold))
			$fitJointChildSide[$i]="_M";
		}

	//TwistJoints, BendyJoints & inbetweenJoints Require a RlaChild
	if (`asRlaChild $fitJoints[$i]`!="")
		{

		//Analyze TwistJoints
		if (`attributeExists twistJoints $fitJoints[$i]`)
			$fitJointTwistJoints[$i]=`getAttr ($fitJoints[$i]+".twistJoints")`;

		//Analyze BendyJoints
		if (`attributeExists bendyJoints $fitJoints[$i]`)
			$fitJointBendyJoints[$i]=`getAttr ($fitJoints[$i]+".bendyJoints")`;

		//Analyze inbetweenJoints
		if (`attributeExists inbetweenJoints $fitJoints[$i]`)
			$fitJointInbetweenJoints[$i]=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
		if (`attributeExists unTwister $fitJoints[$i]`)
			if ($fitJointInbetweenJoints[$i]>0)
				$fitJointUnTwister[$i]=`getAttr ($fitJoints[$i]+".unTwister")`;
		}

	//Analyze UpTwistJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists twistJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpTwistJoints[$i]=`getAttr ($fitJointParent[$i]+".twistJoints")`;

	//Analyze UpBendyJoints
	if ($fitJointParent[$i]!="")
		if (`attributeExists bendyJoints $fitJointParent[$i]`)
			if ($fitJoints[$i]==`asRlaChild $fitJointParent[$i]`)
				$fitJointUpBendyJoints[$i]=`getAttr ($fitJointParent[$i]+".bendyJoints")`;

	//Analyze global
	if (`attributeExists "global" $fitJoints[$i]`)
		{
		$fitJointGlobal[$i]=1;
		$fitJointGlobalValue[$i]=`getAttr ($fitJoints[$i]+".global")`;
		if (`attributeExists "globalTranslate" $fitJoints[$i]`)
			$fitJointGlobalTranslate[$i]=`getAttr ($fitJoints[$i]+".globalTranslate")`;
		}


	//Analyze Aim
	if (`attributeExists aim $fitJoints[$i]`)
		$fitJointsAim[$i]=1;

	//Analyze geoAttach
	if (`attributeExists geoAttach $fitJoints[$i]`)
		{
		$fitJointsAttachTo[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttach")`;
		if (`gmatch $fitJointsAttachTo[$i] "*__*"` && !`objExists $fitJointsAttachTo[$i]`)
			{
			$tempString[0]=`substitute "__" $fitJointsAttachTo[$i] ":"`;
			if (`objExists $tempString[0]`)
				$fitJointsAttachTo[$i]=$tempString[0];
			}
		if (`attributeExists geoAttachMode $fitJoints[$i]`)
			$fitJointsAttachMode[$i]=`getAttr -asString ($fitJoints[$i]+".geoAttachMode")`;
		}

	//Analyze aimAt
	if (`attributeExists aimAt $fitJoints[$i]`)
		{
		$fitJointsAimAt[$i]=`getAttr -asString ($fitJoints[$i]+".aimAt")`;
		$fitJointsAimAxis[$i]=`getAttr ($fitJoints[$i]+".aimAxis")`;
		$fitJointsAimUpAxis[$i]=`getAttr ($fitJoints[$i]+".aimUpAxis")`;
		}

	//Analyze curveGuide
	if (`attributeExists curveGuide $fitJoints[$i]`)
		{
		$fitJointsCurveGuide[$i]=`getAttr -asString ($fitJoints[$i]+".curveGuide")`;
		if (`gmatch $fitJointsCurveGuide[$i] "*__*"` && !`objExists $fitJointsCurveGuide[$i]`)
			{
			$tempString[0]=`substitute "__" $fitJointsCurveGuide[$i] ":"`;
			if (`objExists $tempString[0]`)
				$fitJointsCurveGuide[$i]=$tempString[0];
			}
		}

	//Analyze Wheel
	if (`attributeExists wheel $fitJoints[$i]`)
		$fitJointsWheel[$i]=1;

	//Analyze IK
	$asFitJointIKInfo=`asFitJointIKInfo $fitJoints[$i]`;
	$fitJointIK[$i]=$asFitJointIKInfo[0];
	$fitJointIKStartJoint[$i]=$asFitJointIKInfo[1];
	$fitJointIKMiddleJoint[$i]=$asFitJointIKInfo[2];
	$fitJointIKEndJoint[$i]=$asFitJointIKInfo[3];
	$fitJointIKSolver[$i]=$asFitJointIKInfo[4];
	if ($asFitJointIKInfo[5]!="")
		{
		$fitJointIKNumCtrls[$i]=$asFitJointIKInfo[5];
		//fake IK-mid ctrl, to control mid locs
		if ($fitJointIKNumCtrls[$i]==2)
			{
			$fitJointIKNumCtrls[$i]=3;
			$fitJointIKNumCtrlsFakeMid[$i]=1;
			}
		}
	if ($fitJointIKStartJoint[$i]==$fitJoints[$i])
		$isIKStart[$i]=1;
	if ($fitJointIKEndJoint[$i]==$fitJoints[$i])
		if (!`gmatch $fitJointLabel[$i] "*Toes*"`)
			$isIKEnd[$i]=1;

	//Not to use UnTwister, if in IK, as the untwisting conflicts
	if ($fitJointIK[$i]!="" && $fitJointUnTwister[$i])
		{
		warning ("Setting "+$fitJoints[$i]+".unTwister to \"0\", since FK-unTwister will not work for joint that is in IK-chain");
		setAttr ($fitJoints[$i]+".unTwister") 0;
		$fitJointUnTwister[$i]=0;
		}

	//Analyze $isIKBelowIKEnd ($toes/qtoes)
	if ($fitJointIK[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointIKStartJoint[$i]`;
		$IKEndJoint=$asFitJointIKInfo[3];
		$tempString=`listRelatives -type joint -ad $fitJoints[$i]`;
		if ($fitJoints[$i]!=$IKEndJoint)
		if (!`stringArrayCount $IKEndJoint $tempString`)
			$isIKBelowIKEnd[$i]=1;
		}

	//Analyze $fitJointQtoes (for IKEndJoint)
	$fitJointQtoes[$i]="";
	if ($isIKEnd[$i])
		{
		$tempString=`listRelatives -type joint -ad $fitJoints[$i]`;
		for ($y=0;$y<size($tempString);$y++)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*QToes*"`)
				$fitJointQtoes[$i]=$tempString[$y];
			}
		}

	//Analyze Non-deform joints
	if (`gmatch $fitJointLabel[$i] "*Heel*"` || `gmatch $fitJointLabel[$i] "*BigToe*"` || `gmatch $fitJointLabel[$i] "*PinkyToe*"`)
		$fitJointNonDef[$i]=1;	

	//Analyze $footRotX
	if (`gmatch $fitJointLabel[$i] "*Foot*"`)
		{
		createNode -n rotationSampler1 transform;
		createNode -n rotationSampler2 -p rotationSampler1 transform;
		setAttr -type float3 rotationSampler1.r 90 0 -90;
		setAttr rotationSampler2.rotateOrder `getAttr ($fitJoints[$i]+".rotateOrder")`;
		orientConstraint $fitJoints[$i] rotationSampler2;
		$footRotX[$i]=`getAttr rotationSampler2.rx`*-1;
		delete rotationSampler1;
		}

	//Analyze $ikLocal
	if (`attributeExists ikLocal $fitJoints[$i]`)
		{
		$ikLocal[$i]=1;
		//backwards compatible (used to be bool attribute)
		if (`getAttr -type ($fitJoints[$i]+".ikLocal")`=="bool" && $ikLocal[$i]==0)
			$ikLocal[$i]=-1;
		$ikLocalType[$i]=`getAttr ($fitJoints[$i]+".ikLocal")`;
		}

	//Analyze FirstAfterIK
	if ($fitJointParent[$i]!="")
		{
		$asFitJointIKInfo=`asFitJointIKInfo $fitJointParent[$i]`;
		if ($fitJointIK[$i]!=$asFitJointIKInfo[0])
			$fitJointFirstAfterIK[$i]=1;
		}

	//Analyze Lock (if out ouf $lockCenterTolerance)
	$pos=`xform -q -ws -t $fitJoints[$i]`;
	$lockCenterTolerance=0.01*$scale;
	if ($pos[0]<-$lockCenterTolerance || $pos[0]>$lockCenterTolerance)
		{
		if (`getAttr -l ($fitJoints[$i]+".tx")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".ty")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".tz")`) $fitJointLockTx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".rx")`) $fitJointLockRx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".ry")`) $fitJointLockRy[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".rz")`) $fitJointLockRz[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sx")`) $fitJointLockSx[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sy")`) $fitJointLockSy[$i]=1;
		if (`getAttr -l ($fitJoints[$i]+".sz")`) $fitJointLockSz[$i]=1;
		}
	}

//Analyze $centerBtwFeet
if (`attributeExists centerBtwFeet Root`)
	$centerBtwFeet=`getAttr Root.centerBtwFeet`;

//Analyze $ikLenght
for ($i=0;$i<size($fitJoints);$i++)
	{
	$ikLenght[$i]=0;
	if ($fitJointIK[$i]=="")
		continue;
	$tempString[0]=$fitJointIKEndJoint[$i];
	for ($a=0;$a<99;$a++)
		{
		if ($tempString[0]==$fitJointIKStartJoint[$i])
			break;
		$ikLenght[$i]+=`getAttr ($tempString[0]+".tx")`;
		$tempString=`listRelatives -p $tempString[0]`;
		}
	$ikLenght[$i]=abs($ikLenght[$i]);
	}

//height
for ($a=0;$a<3;$a++)
	{
	$maxFitJoint=0;
	$minFitJoint=99;
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$pos=`xform -q -ws -t $fitJoints[$i]`;
		if ($pos[$a]>$maxFitJoint)
			$maxFitJoint=$pos[$a];
		if ($pos[$a]<$minFitJoint)
			$minFitJoint=$pos[$a];
		}
	if ($a==0) $width=$maxFitJoint-$minFitJoint;
	if ($a==1) $height=$maxFitJoint-$minFitJoint;
	if ($a==2) $lenght=$maxFitJoint-$minFitJoint;
	}
addAttr -ln height -at double Main;
setAttr -l 1 Main.height $height;
//$iconScaleFactor
$iconScaleFactor=$height;
if ($lenght>$height && $lenght>$width) $iconScaleFactor=$lenght;
if ($width>$height && $width>$lenght) $iconScaleFactor=$width;
$iconScaleFactor=$iconScaleFactor/80.0;

//--Creation--//
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		$pos=`xform -q -ws -t $fitJoints[$i]`;
		$rot=`xform -q -ws -ro $fitJoints[$i]`;
		$joint=$fitJoints[$i]+$side;

		//Creation Deform
		select -cl;
		joint -n $joint;
		if (!$fitJointNoSkin[$i])
			sets -add DeformSet $joint;
		setAttr ($joint+".rotateOrder") $fitJointRotOrder[$i];
		xform -ws -t ($pos[0]*$b) $pos[1] $pos[2] $joint;
		xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fat")` -ln fat -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatY")` -ln fatY -at double $joint;
		addAttr -k 0 -dv `getAttr ($fitJoints[$i]+".fatZ")` -ln fatZ -at double $joint;

		if ($side=="_L")
			{
			$tempString=`mirrorJoint -mirrorYZ -mirrorBehavior $joint`;
			if (`asMayaVersionAsFloat`<2012)
				$tempString[0]=$joint+"1";
			if ($fitJointNoFlip[$i])
				rotate -r -os 0 0 180 $tempString[0];
			$rot=`xform -q -ws -ro $tempString[0]`;
			xform -ws -ro $rot[0] $rot[1] $rot[2] $joint;
			delete $tempString[0];
			}

		//Creation TwistJoints
		select $joint;
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			joint -n ($fitJoints[$i]+"Part"+$y+$side);
			if (!$fitJointNoSkin[$i])
				sets -add DeformSet ($fitJoints[$i]+"Part"+$y+$side);
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".rotateOrder") `getAttr ($fitJoints[$i]+".rotateOrder")`;
			}			

		if($fitJoints[$i]=="Root")
			connectAttr -f jointLayer.drawInfo Root_M.drawOverride;
		}

//Parent Deform
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		$parentJoint=$fitJointParent[$i]+$parentSide;
		if ($fitJointParent[$i]=="")
			parent $joint DeformationSystem;
		else
			parent $joint $parentJoint;
		}

//Parent TwistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointTwistJoints[$i]<1)
			continue;refresh;

		$twistDistance=`getAttr ($fitJointChild[$i]+$childSide+".tx")`/($fitJointTwistJoints[$i]+1.0);
		for ($y=1;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			setAttr ($fitJoints[$i]+"Part"+$y+$side+".tx") $twistDistance;
			//connect scale
			connectAttr ($fitJoints[$i]+$side+".sx") ($fitJoints[$i]+"Part"+$y+$side+".sx");
			connectAttr ($fitJoints[$i]+$side+".sy") ($fitJoints[$i]+"Part"+$y+$side+".sy");
			connectAttr ($fitJoints[$i]+$side+".sz") ($fitJoints[$i]+"Part"+$y+$side+".sz");
/*
			//Exception for last twistJoint, this needs uniform scaling to avoid it`s child to `shear`
			if ($y==$fitJointTwistJoints[$i])
				connectAttr -f ($fitJoints[$i]+$side+".sy") ($fitJoints[$i]+"Part"+$y+$side+".sx");
*/
			}
		

		//reParent child to last twist
		if ($fitJointTwistJoints[$i]>0)
			{
			parent -w ($fitJointChild[$i]+$childSide);//parent to world first, as this ensures auto-inverseScale connect
			parent ($fitJointChild[$i]+$childSide) ($fitJoints[$i]+"Part"+($fitJointTwistJoints[$i])+$side);
//			setAttr ($fitJointChild[$i]+$childSide+".segmentScaleCompensate") 0;
			}
		}

//Freeze rotation(move to jointOrient)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;refresh;

		$joint=$fitJoints[$i]+$side;
		makeIdentity -a 1 -r 1 $joint;
		}

//Advanced Root
asCreateController "Root" "X" "_M" "Root";
xform -s 0.23 0.23 0.23 RootX_M;
setAttr RootX_M.rotateOrder 3;
makeIdentity -a 1 -s 1 RootX_M;
parent RootOffsetX_M RootSystem;
createNode -n RootZeroXform transform;
parent RootZeroXform RootX_M;
parentConstraint RootZeroXform FKSystem;
parentConstraint RootZeroXform IKRootConstraint;

//LegLock
createNode -n LegLockConstrained -p RootSystem transform;
pointConstraint Root_M LegLockConstrained;
createNode -n RootSpineAligned -p RootX_M transform;
orientConstraint -mo Root_M RootSpineAligned;
orientConstraint RootX_M RootSpineAligned LegLockConstrained;
addAttr -k 1 -ln legLock -at double -min 0 -max 10 -dv 0 RootX_M;
createNode -n LegLockUnitConversion unitConversion;
setAttr LegLockUnitConversion.conversionFactor 0.1;
connectAttr RootX_M.legLock LegLockUnitConversion.input;
connectAttr LegLockUnitConversion.output LegLockConstrained_orientConstraint1.RootX_MW0;
createNode -n LegLockReverse reverse;
connectAttr LegLockUnitConversion.output LegLockReverse.inputX;
connectAttr LegLockReverse.outputX LegLockConstrained_orientConstraint1.RootSpineAlignedW1;


//Creation FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;


		asCreateController "FK" $fitJoints[$i] $side $fitJoints[$i];
//		setAttr ("FKExtra"+$fitJoints[$i]+$side+".overrideEnabled") 1;

		select ("FK"+$fitJoints[$i]+$side);
		joint -n ("FKX"+$fitJoints[$i]+$side);
		connectAttr -f jointLayer.drawInfo ("FKX"+$fitJoints[$i]+$side+".drawOverride");
		setAttr ("FKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
//		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$fitJoints[$i]+$side);

		if ($fitJointInbetweenJoints[$i])
			{
			parent ("FKX"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side);
			for ($y=0;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				$joint="FKX"+$fitJoints[$i]+"Part"+$y+$side;
				if ($y==0)
					{
					$joint="FKX"+$fitJoints[$i]+$side;
					connectAttr ("FK"+$fitJoints[$i]+$side+".t") ($joint+".t");
					}
				orientConstraint ("FK"+$fitJoints[$i]+$side) ("FKExtra"+$fitJoints[$i]+$side) $joint;
				setAttr ($joint+"_orientConstraint1.interpType") 2;//gives more accurate division by 3rds
				$w=(1.0/($fitJointInbetweenJoints[$i]+1))*($y+1);
				setAttr ($joint+"_orientConstraint1.FK"+$fitJoints[$i]+$side+"W0") $w;
				setAttr ($joint+"_orientConstraint1.FKExtra"+$fitJoints[$i]+$side+"W1") (1-$w);
				}
			}

		if($fitJointGlobal[$i])
			{
			createNode -n ("FKGlobalStatic"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("FKGlobalStatic"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			duplicate -n ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			duplicate -n ("GlobalOffset"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);

			parent ("FKGlobal"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side);
			parent ("FKExtra"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			parent ("Global"+$fitJoints[$i]+$side) ("GlobalOffset"+$fitJoints[$i]+$side);
			parent ("GlobalOffset"+$fitJoints[$i]+$side) GlobalSystem;

			orientConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
			addAttr -k 1 -ln "Global"-at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
			createNode -n ("globalReverse"+$fitJoints[$i]+$side) reverse;
			createNode -n ("globalUnitConversion"+$fitJoints[$i]+$side) unitConversion;
			setAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
			connectAttr ("FK"+$fitJoints[$i]+$side+".Global") ("globalUnitConversion"+$fitJoints[$i]+$side+".input");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("globalReverse"+$fitJoints[$i]+$side+".inputX");
			connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.Global"+$fitJoints[$i]+$side+"W0");
			connectAttr ("globalReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_orientConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");

			if ($fitJointGlobalTranslate[$i])
				{
				pointConstraint ("Global"+$fitJoints[$i]+$side) ("FKGlobalStatic"+$fitJoints[$i]+$side) ("FKGlobal"+$fitJoints[$i]+$side);
//				connectAttr ("globalUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.Global"+$fitJoints[$i]+$side+"W0");
//				connectAttr ("globalReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");


				addAttr -k 1 -ln "GlobalTranslate" -at double -min 0 -max 10 -dv $fitJointGlobalValue[$i] ("FK"+$fitJoints[$i]+$side);
				createNode -n ("globalTranslateReverse"+$fitJoints[$i]+$side) reverse;
				createNode -n ("globalTranslateUnitConversion"+$fitJoints[$i]+$side) unitConversion;
				setAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".conversionFactor") 0.1;
				connectAttr ("FK"+$fitJoints[$i]+$side+".GlobalTranslate") ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".input");
				connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("globalTranslateReverse"+$fitJoints[$i]+$side+".inputX");
				connectAttr ("globalTranslateUnitConversion"+$fitJoints[$i]+$side+".output") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.Global"+$fitJoints[$i]+$side+"W0");
				connectAttr ("globalTranslateReverse"+$fitJoints[$i]+$side+".outputX") ("FKGlobal"+$fitJoints[$i]+$side+"_pointConstraint1.FKGlobalStatic"+$fitJoints[$i]+$side+"W1");
				}
			}

		if ($fitJointNoControl[$i])
			{
			setAttr -l 1 ("FK"+$fitJoints[$i]+$side+"Shape.v") 0;
			sets -rm ControlSet {("FK"+$fitJoints[$i]+$side),("FKExtra"+$fitJoints[$i]+$side)};
			}
		}

//Connect inbetweenJoints scale
for ($i=0;$i<size($fitJoints);$i++)
	{
	$side=$fitJointSide[$i];

	if (!`attributeExists inbetweenJoints $fitJoints[$i]`)
		continue;
	$inbetweenJoints=`getAttr ($fitJoints[$i]+".inbetweenJoints")`;
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		$inbetweenJoint=$fitJoints[$i]+"Part"+$y+$side;
		connectAttr ("FK"+$fitJoints[$i]+$side+".sx") ("FK"+$fitJoints[$i]+"Part"+$y+$side+".sx");
		connectAttr ("FK"+$fitJoints[$i]+$side+".sy") ("FK"+$fitJoints[$i]+"Part"+$y+$side+".sy");
		connectAttr ("FK"+$fitJoints[$i]+$side+".sz") ("FK"+$fitJoints[$i]+"Part"+$y+$side+".sz");
		}
	}


//Creation AlignIKTo
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($isIKStart[$i] || $isIKEnd[$i])
			{
			createNode -n ("AlignIKTo"+$fitJoints[$i]+$side) transform;
			setAttr ("AlignIKTo"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			asAlign ("AlignIKTo"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 0 0 0;
			if ($fitJointIsEndJoint[$i])
				parent ("AlignIKTo"+$fitJoints[$i]+$side) ("FKX"+$fitJointParent[$i]+$side);
			else
				parent ("AlignIKTo"+$fitJoints[$i]+$side) ("FKX"+$fitJoints[$i]+$side);
			}
		}

//Creation of FKX endJoint in IK systems
//removed, as deform endJoint then is constraint to FK only (e.g. dinosaur head)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if ($fitJointIKSolver[$i]!="ikSplineSolver")
			continue;
		if (!$fitJointIsEndJoint[$i])
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		select ("FKX"+$fitJointParent[$i]+$parentSide);
		joint -n ("FKX"+$fitJoints[$i]+$side);
		connectAttr -f jointLayer.drawInfo ("FKX"+$fitJoints[$i]+$side+".drawOverride");
		setAttr ("FKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
		xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("FKX"+$fitJoints[$i]+$side);
		}

//Parenting FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		if ($fitJointParent[$i]=="")
			parent ("FKOffset"+$fitJoints[$i]+$side) FKSystem;

		else if ($fitJointFirstAfterIK[$i])
			{
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (!`objExists $parentContraintToXform`)
				{
				createNode -n $parentContraintToXform -p FKSystem transform;
				//-mo as this prevents Ankle from flipping. nut this make scaleConstraint wrong
				asAlign $parentContraintToXform ($fitJointParent[$i]+$parentSide) 1 0 0 0;
//				parentConstraint -mo ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
				if ($fitJointParent[$i]=="Root")
					parentConstraint LegLockConstrained $parentContraintToXform;
				else
					{
					//point & orient instead of parent, as we dont want inverseScale
					pointConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
					orientConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
					//parentConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
					}

				if ($fitJointParent[$i]=="Wrist")
					connectAttr Main.fingerVis ($parentContraintToXform+".v");
				}
			parent ("FKOffset"+$fitJoints[$i]+$side) $parentContraintToXform;
			connectAttr -f jointLayer.drawInfo ("FKOffset"+$fitJoints[$i]+$side+".drawOverride");
			}
		else
			parent ("FKOffset"+$fitJoints[$i]+$side) ("FKX"+$fitJointParent[$i]+$parentSide);
		}

//FK segmentScaleCompensate
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		//fingers/toes to scale up with hand/foot, and anything below head
		if (`gmatch $fitJoints[$i] "*Finger*"` || `gmatch $fitJoints[$i] "*Cup*"` || `gmatch $fitJoints[$i] "*Toes*"` || $fitJointParent[$i]=="Head")
			{
			setAttr ($fitJoints[$i]+$side+".segmentScaleCompensate") 0;
			$parentContraintToXform="FKParentConstraintTo"+$fitJointParent[$i]+$parentSide;
			if (`objExists $parentContraintToXform`)
				if (!`isConnected ($fitJointParent[$i]+$parentSide+".s") ($parentContraintToXform+".s")`)
					connectAttr ($fitJointParent[$i]+$parentSide+".s") ($parentContraintToXform+".s");
//				scaleConstraint ($fitJointParent[$i]+$parentSide) $parentContraintToXform;
//changed scaleConstraint to scaleConnect, to resolve stretchyLeg bending the foot.
			}
		}

//Creation IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;

		select -cl;
		joint -n ("IKX"+$fitJoints[$i]+$side);
		setAttr ("IKX"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
		//Extra child under IKX (IKX2), for the FKIK to constrain to, as this avoids constrain flip.
		createNode -n ("IKX2"+$fitJoints[$i]+$side) -p ("IKX"+$fitJoints[$i]+$side) transform;
		if ($isIKStart[$i])
			{
			createNode -n ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			setAttr ("IKParentConstraint"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			createNode -n ("IKXOffset"+$fitJoints[$i]+$side) transform;
			setAttr ("IKXOffset"+$fitJoints[$i]+$side+".rotateOrder") $fitJointRotOrder[$i];
			parent ("IKX"+$fitJoints[$i]+$side) ("IKXOffset"+$fitJoints[$i]+$side);
			if (`objExists ($fitJointParent[$i]+$parentSide)`)
				{
				$parentPos=`xform -q -ws -t ($fitJointParent[$i]+$parentSide)`;
				$parentRot=`xform -q -ws -ro ($fitJointParent[$i]+$parentSide)`;
				xform -ws -t $parentPos[0] $parentPos[1] $parentPos[2] -ro $parentRot[0] $parentRot[1] $parentRot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
				if ($fitJointIKSolver[$i]!="ikSplineSolver")
					{
					if ($fitJointParent[$i]=="Root")
						parentConstraint LegLockConstrained ("IKParentConstraint"+$fitJoints[$i]+$side);
					else
						parentConstraint ($fitJointParent[$i]+$parentSide) ("IKParentConstraint"+$fitJoints[$i]+$side);
					}
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKXOffset"+$fitJoints[$i]+$side);
				makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
				}
			else
				xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKParentConstraint"+$fitJoints[$i]+$side);
			asAlign ("IKXOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 1 0 0;
			parent ("IKXOffset"+$fitJoints[$i]+$side) ("IKParentConstraint"+$fitJoints[$i]+$side);
			}
		else
			xform -ws -t $pos[0] $pos[1] $pos[2] -ro $rot[0] $rot[1] $rot[2] ("IKX"+$fitJoints[$i]+$side);
		if ($isIKStart[$i] && $fitJointIKSolver[$i]=="ikRPsolver")
			{
			createNode -n ("IKMessureFrom"+$fitJoints[$i]+$side) -p ("IKParentConstraint"+$fitJoints[$i]+$side) transform;
			asAlign ("IKMessureFrom"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) 1 1 0 1;
			}
		if ($isIKStart[$i])
			connectAttr -f jointLayer.drawInfo ("IKX"+$fitJoints[$i]+$side+".drawOverride");
		}

//Parenting IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;

		if ($isIKStart[$i])
			parent ("IKParentConstraint"+$fitJoints[$i]+$side) IKJoints;
		else
			{
			parent ("IKX"+$fitJoints[$i]+$side) ("IKX"+$fitJointParent[$i]+$parentSide);
			makeIdentity -a 1 -r 1 ("IKX"+$fitJoints[$i]+$side);
			}
		}

//Constraint to FK (&IK)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ("FKX"+$fitJoints[$i]+$side)`)
			continue;

		parentConstraint ("FKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
		if ($fitJointIK[$i]!="")
			parentConstraint -w 0 ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
		parent ($fitJoints[$i]+$side+"_parentConstraint1") ConstraintSystem;
		}
// 1-joint-FitSkeleton:
if (`objExists Root_M` && !`objExists Root_M_parentConstraint1`)
	parentConstraint -mo RootX_M Root_M;

//UnTwister (inbetweener option)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointUnTwister[$i])
			{
			$tempString=`listRelatives -c -type joint ($fitJoints[$i]+"Part"+$fitJointInbetweenJoints[$i])`;
			string $unTwisterChild=$tempString[0];
			asCreateUnTwister $unTwisterChild $side $fitJoints[$i] $side "" 1 0 "";
			for ($y=1;$y<$fitJointInbetweenJoints[$i]+1;$y++)
				{
				createNode -n ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side) multiplyDivide;
//				connectAttr ("TwistBalancer"+$unTwisterChild+$side+".rx") ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input1X");
				connectAttr ("TwistBalancer"+$unTwisterChild+$side+".twist") ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input1X");
				setAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".input2X") ((1.0/($fitJointInbetweenJoints[$i]+1))*$y);
				connectAttr ("InbetweenUnTwistDivider"+$fitJoints[$i]+$y+$side+".outputX") ($fitJoints[$i]+"Part"+$y+$side+"_parentConstraint1.target[0].targetOffsetRotateX");
				//to avoid that rotating the Base, to cause double twisting, contraint to FK instead of FKX:
				delete ("TwistFollowParent"+$unTwisterChild+$side+"_parentConstraint1");
				parentConstraint ("FK"+$fitJoints[$i]+$side) ("TwistFollowParent"+$unTwisterChild+$side);
				}
			}
		}

//Advanced Aim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsAim[$i])
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;

		if (!`objExists ("Aim"+$fitJoints[$i])`)
			{
			createNode -n ("Aim"+$fitJoints[$i]) -p AimSystem transform;
			createNode -n ("AimOffset"+$fitJoints[$i]) -p ("Aim"+$fitJoints[$i]) transform;
			createNode -n ("AimFollow"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOn"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			createNode -n ("AimFollowOff"+$fitJoints[$i]) -p ("AimOffset"+$fitJoints[$i]) transform;
			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] ("Aim"+$fitJoints[$i]+"_M");
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideEnabled") 1;
			setAttr ("Aim"+$fitJoints[$i]+"_MShape.overrideColor") 17;
			sets -add ControlSet ("Aim"+$fitJoints[$i]+"_M");
			scale -r -p 0 0 0 ($scale/3.0) ($scale/3.0) ($scale/3.0) ("Aim"+$fitJoints[$i]+"_M.cv[0:4]");
			parent ("Aim"+$fitJoints[$i]+"_M") ("AimFollow"+$fitJoints[$i]);
			$pos=`xform -q -ws -t $fitJoints[$i]`;
			xform -ws -t 0 $pos[1] ($pos[2]+$scale*2) ("AimOffset"+$fitJoints[$i]);

			//.follow setup
			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 ("Aim"+$fitJoints[$i]+"_M");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M") unitConversion;
			setAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.conversionFactor") 0.1;
			connectAttr ("Aim"+$fitJoints[$i]+"_M.follow") ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.input");
			createNode -n ("Aim"+$fitJoints[$i]+"FollowReverse_M") reverse;
			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("Aim"+$fitJoints[$i]+"FollowReverse_M.inputX");

			parentConstraint ("AimFollowOn"+$fitJoints[$i]) ("AimFollowOff"+$fitJoints[$i]) ("AimFollow"+$fitJoints[$i]);
			parentConstraint -mo ($fitJointParent[$i]+$fitJointParentSide[$i]) ("AimFollowOn"+$fitJoints[$i]);

			connectAttr ("Aim"+$fitJoints[$i]+"FollowUnitConversion_M.output") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOn"+$fitJoints[$i]+"W0");
			connectAttr ("Aim"+$fitJoints[$i]+"FollowReverse_M.outputX") ("AimFollow"+$fitJoints[$i]+"_parentConstraint1.AimFollowOff"+$fitJoints[$i]+"W1");
			}
		
		if ($side!="_M")
			{
			createNode -n ("AimOffset"+$fitJoints[$i]+$side) -p ("Aim"+$fitJoints[$i]+"_M") transform;
			duplicate -n ("Aim"+$fitJoints[$i]+$side) ("Aim"+$fitJoints[$i]+"_M");
			$tempString=`listRelatives -c -f -type transform ("Aim"+$fitJoints[$i]+$side)`;
			if (`size ($tempString)`) delete $tempString;
			parent ("Aim"+$fitJoints[$i]+$side) ("AimOffset"+$fitJoints[$i]+$side);
			asLockAttr ("Aim"+$fitJoints[$i]+$side) 0 1 1 1;
			deleteAttr ("Aim"+$fitJoints[$i]+$side+".follow");
			setAttr -type float3 ("AimOffset"+$fitJoints[$i]+$side+".s") 0.2 0.2 0.2;
			asAlign ("AimOffset"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side) 1 0 0 0;
			setAttr ("AimOffset"+$fitJoints[$i]+$side+".tz") 0;
			connectAttr Main.aimLRVis ("Aim"+$fitJoints[$i]+$side+"Shape.v");
			}
		createNode -n ("FKAim"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAim"+$fitJoints[$i]+$side) ("FKOffset"+$fitJoints[$i]+$side) 1 1 0 1;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		parent ("FKAim"+$fitJoints[$i]+$side) $tempString[0];
		aimConstraint -aim 1 0 0 -upVector 0 0 -1 -worldUpVector 0 0 -1 -worldUpType "objectrotation" 
			-worldUpObject ($fitJointParent[$i]+$fitJointParentSide[$i]) ("Aim"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAim"+$fitJoints[$i]+$side);
		connectAttr Main.aimFKVis ("FK"+$fitJoints[$i]+$side+"Shape.v");
		}


//Advanced IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;

		//IKSp jointChain
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			createNode -n ("IKSp"+$fitJointIK[$i]+"Offset"+$side) -p IKJoints transform;
			setAttr -l 1 ("IKSp"+$fitJointIK[$i]+"Offset"+$side+".v") 0;
			asAlign ("IKSp"+$fitJointIK[$i]+"Offset"+$side) ("FKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 1;
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("FKX"+$fitJointIKStartJoint[$i]+$side) ($fitJointIKEndJoint[$i]+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side)`;
			select ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
			for ($y=0;$y<size($IKJoints);$y++)
				{
				joint -n ("IKSp"+$IKJoints[$y]+$side);
				}
			//changing to no longer distribute IKSp joints evenly
			for ($y=0;$y<size($IKJoints);$y++)
				asAlign ("IKSp"+$IKJoints[$y]+$side) ("IKX"+$IKJoints[$y]+$side) 1 1 0 0;
			}
		//IKfake, first & last 2 joints in splineIK chain are `fake`, so that`real` can blend btw fake and ..AlignTo (for fixed end.rot in stretchy mode)
		//Also IKfake3 ensures correct twist distribution, as splikeIK twist assumes `end bone`
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			select ("IKSp"+$fitJointIKStartJoint[$i]+$side);
			joint -n ("IKfake0"+$fitJointIK[$i]+$side);
			setAttr -l 1 ("IKfake0"+$fitJointIK[$i]+$side+".v") 0;
			parent ("IKfake0"+$fitJointIK[$i]+$side) ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side);
			$tempString=`listRelatives -c ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
			parent $tempString[0] ("IKfake0"+$fitJointIK[$i]+$side);

			select ("IKSp"+$fitJointIKEndJoint[$i]+$side);
			joint -n ("IKfake1"+$fitJointIK[$i]+$side);
			if ($fitJointChild[$i]=="")// If there is no child, then the joint Before the end-joint, should have the full rotation, since the end-joint is not bound to skin.
				{
				$tempString=`listRelatives -p ("IKSp"+$fitJointIKEndJoint[$i]+$side)`;
				parent ("IKfake1"+$fitJointIK[$i]+$side) $tempString[0];
				}
			setAttr -l 1 ("IKfake1"+$fitJointIK[$i]+$side+".visibility") 0;
			}

		$startJoint="IKX"+$fitJointIKStartJoint[$i]+$side;
		$endJoint="IKX"+$fitJointIKEndJoint[$i]+$side;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			$startJoint="IKfake0"+$fitJointIK[$i]+$side;
			$endJoint="IKfake1"+$fitJointIK[$i]+$side;
//			if (`objExists ("IKfake2"+$fitJointIK[$i]+$side)`)
//				$endJoint="IKfake3"+$fitJointIK[$i]+$side;
			}
		joint -e -setPreferredAngles -children $startJoint;
		if (`objExists ("IKfake1"+$fitJointIK[$i]+$side)` && size($IKJoints)==2)
			{
			$tempString=`listRelatives -p ("IKfake1"+$fitJointIK[$i]+$side)`;
			if ($tempString[0]!="IKfake0"+$fitJointIK[$i]+$side)
				parent ("IKfake1"+$fitJointIK[$i]+$side) ("IKfake0"+$fitJointIK[$i]+$side);
			}

		$tempString=`ikHandle -n ("IK"+$fitJointIK[$i]+"Handle"+$side) -ccv 0 -ns 2 -sol $fitJointIKSolver[$i] -sj $startJoint -ee $endJoint`;
		rename $tempString[1] ("IK"+$fitJointIK[$i]+"Effector"+$side);
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Handle"+$side+".v") 0;
		setAttr -l 1 ("IK"+$fitJointIK[$i]+"Effector"+$side+".v") 0;
		setAttr ("IK"+$fitJointIK[$i]+"Effector"+$side+".rotateOrder") $fitJointRotOrder[$i];
		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//controller
			asCreateController "IK" $fitJointIK[$i] $side $fitJoints[$i];		
			if ($fitJointQtoes[$i]!="") 
				asAlign ("IKOffset"+$fitJointIK[$i]+$side) ($fitJointQtoes[$i]+$side) 1 0 0 0;
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+$side);
			//pole
			asCreateController "Pole" $fitJointIK[$i] $side $fitJoints[$i];	
			asLockAttr ("Pole"+$fitJointIK[$i]+$side) 0 1 1 1;
			//place poleVector
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
//			$startJointChildJoint=$tempString[0];
			createNode -n tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer2 -p tempPoleVecPlacer1 transform;
			createNode -n tempPoleVecPlacer3 -p tempPoleVecPlacer2 transform;
			$tempString=`pointConstraint $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i] tempPoleVecPlacer1`;
			if (`getAttr ($fitJointIKEndJoint[$i]+".tx")`>0)
				setAttr ($tempString[0]+"."+$fitJointIKStartJoint[$i]+"W0") `getAttr ($fitJointIKEndJoint[$i]+".tx")`;
			if (`getAttr ($fitJointIKMiddleJoint[$i]+".tx")`>0)
				setAttr ($tempString[0]+"."+$fitJointIKEndJoint[$i]+"W1") `getAttr ($fitJointIKMiddleJoint[$i]+".tx")`;
			if ($fitJointIKMiddleJoint[$i]!=$fitJointIKStartJoint[$i])
				{
				aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject $fitJointIKStartJoint[$i] $fitJointIKMiddleJoint[$i] tempPoleVecPlacer2;
				setAttr tempPoleVecPlacer3.tx $ikLenght[$i];
				}
			else //no knee joint
				setAttr tempPoleVecPlacer3.tz $ikLenght[$i];
			$temp=`xform -q -ws -t tempPoleVecPlacer3`;
			delete tempPoleVecPlacer1;
			xform -ws -t ($temp[0]*$b) $temp[1] $temp[2] ("PoleOffset"+$fitJointIK[$i]+$side);
			poleVectorConstraint ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side);
			$tempString[0]=`createNode annotationShape`;
			$tempString=`listRelatives -p $tempString[0]`;
			string $direction=`rename $tempString[0] ("PoleAnnotation"+$fitJointIK[$i]+$side)`;
			setAttr ($direction+"Shape.overrideEnabled") 1;
			setAttr ($direction+"Shape.overrideDisplayType") 2;
			connectAttr Main.arrowVis ($direction+".v");
//			$tempString=`listRelatives -c -type joint $fitJointIKStartJoint[$i]`;
			parent $direction ("IKX"+$fitJointIKMiddleJoint[$i]+$side);
			xform -os -t 0 0 0 -ro 0 0 0 -s 1 1 1 $direction;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+"Shape.worldMatrix[0]") ($direction+"Shape.dagObjectMatrix[0]");
			//orientCnstraint last segment to controller
			createNode -n ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			createNode -n ("IKFKAligned"+$fitJointIK[$i]+$side) -p ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) transform;
			asAlign ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
			orientConstraint ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKEndJoint[$i]+$side);
			//$ikLocal
			if ($ikLocal[$i] && $ikLocalType[$i]==0)//$ikLocal=addCtrl
				{
				asCreateController "IKLocal" $fitJointIK[$i] $side $fitJoints[$i];
				asAlign ("IKLocalOffset"+$fitJointIK[$i]+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				asLockAttr ("IKLocal"+$fitJointIK[$i]+$side) 1 0 1 1;
				parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IKLocal"+$fitJointIK[$i]+$side);
				}
			if ($ikLocal[$i] && $ikLocalType[$i]==1)//$ikLocal=nonZero
				{
				parent -w ("IKFKAlignedOffset"+$fitJointIK[$i]+$side);
//				asAlign ("IK"+$fitJointIK[$i]+$side) $fitJoints[$i] 0 1 0 0;
//				setAttr -type float3 ("IKFKAlignedOffset"+$fitJointIK[$i]+$side+".r") (90*$b) 0 180;
				createNode -n tempXform transform;
				asAlign tempXform ($fitJointIKMiddleJoint[$i]+$side) 1 1 0 0;
				delete `aimConstraint -aimVector (1*$b) 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject tempXform tempXform ("IK"+$fitJointIK[$i]+$side)`;
				if (`gmatch $fitJointLabel[$i] "*Foot*"`)
					delete `aimConstraint -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject tempXform tempXform ("IK"+$fitJointIK[$i]+$side)`;
				delete tempXform;
				parent ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				asAlign ("AlignIKTo"+$fitJointIKEndJoint[$i]+$side) ("IK"+$fitJointIK[$i]+$side) 0 1 0 0;
				}
			if ($ikLocal[$i] && $ikLocalType[$i]==2)//$ikLocal=localOrient
				{
				parent -w ("IKFKAlignedOffset"+$fitJointIK[$i]+$side);
//				asAlign ("IKOffset"+$fitJointIK[$i]+$side) ($fitJoints[$i]+$side) 0 1 0 0;//causes Warning Cycle
				createNode -n tempXform transform;
				asAlign tempXform ($fitJoints[$i]+$side) 0 1 0 0;

				parent -w ("IK"+$fitJointIK[$i]+"Handle"+$side);
				asAlign ("IKOffset"+$fitJointIK[$i]+$side) tempXform 0 1 0 0;
				parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+$side);

				delete tempXform;
				parent ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
				setAttr -type float3 ("AlignIKTo"+$fitJointIKEndJoint[$i]+$side+".r") 0 0 0;
				}
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) IKHandle;
//			$numCVs=$fitJointIKNumCtrls[$i]*2;
			$numCVs=size($IKJoints);
			if ($fitJointIKNumCtrls[$i]==2) $numCVs=$numCVs+2;//2 extra middle CV when only 2 IKctrls
			string $crvCmd="curve -n IK"+$fitJointIK[$i]+"Curve"+$side+" -d 3";
			if ($numCVs<4)//for less then 4cv`s change to degree==1
				$crvCmd="curve -n IK"+$fitJointIK[$i]+"Curve"+$side+" -d 1";
			for ($z=0;$z<$numCVs;$z++)
				 $crvCmd+=" -p 0 0 0";
			eval ($crvCmd);
			$tempString=`listRelatives -s ("IK"+$fitJointIK[$i]+"Curve"+$side)`;
			rename $tempString[0] ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
			parent ("IK"+$fitJointIK[$i]+"Curve"+$side) IKCurve;

			$tempString=`listRelatives -type joint -p ($fitJointIKStartJoint[$i]+$side)`;
			if ($tempString[0]=="") //Root
				$ikParentConstraintTo="IKSystem";
			else
				{
				$ikParentConstraintTo="IKParentConstraintTo"+$tempString[0];
				if (!`objExists $ikParentConstraintTo`)
					{
					createNode -n $ikParentConstraintTo -p IKSystem transform;
					if ($tempString[0]=="Root_M")//tails should be affected to LegLock as well
						parentConstraint LegLockConstrained $ikParentConstraintTo;
					else
						parentConstraint $tempString[0] $ikParentConstraintTo;
					}
				}

			//create IKcv ctrls
			for ($z=0;$z<$numCVs;$z++)
				{
				spaceLocator -n ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				setAttr -l 1 ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+".v") 0;
				connectAttr ("IK"+$fitJointIK[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

				$posFactor=0;
				$posFactor=(1.0/($numCVs-1.0))*$z;
//				$posFactor=`smoothstep 0 1 $posFactor`;
				$invPosFactor=1-$posFactor;
				$tempString=`pointConstraint -w $invPosFactor ("IKSp"+$fitJointIKStartJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side)`;
				pointConstraint -w $posFactor ("IKSp"+$fitJointIKEndJoint[$i]+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side);
				delete $tempString[0];

				if ($z!=0 && $z!=$numCVs-1)
					{
					asCreateController "Pole" ("cv"+$fitJointIK[$i]+$z) $side $fitJointIKStartJoint[$i];
					rename ("Polecv"+$fitJointIK[$i]+$z+$side) ("IKcv"+$fitJointIK[$i]+$z+$side);
					rename ("PoleExtracv"+$fitJointIK[$i]+$z+$side) ("IKExtracv"+$fitJointIK[$i]+$z+$side);
					rename ("PoleOffsetcv"+$fitJointIK[$i]+$z+$side) ("IKOffsetcv"+$fitJointIK[$i]+$z+$side);
					asLockAttr ("IKcv"+$fitJointIK[$i]+$z+$side) 0 1 1 0;
					setAttr ("IKcv"+$fitJointIK[$i]+$z+$side+"Shape.overrideColor") 17;
//					connectAttr Main.ikCvVis ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+".v");
					asAlign ("IKOffsetcv"+$fitJointIK[$i]+$z+$side) ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) 1 1 0 0;
					$rot=`xform -q -ws -ro ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
					xform -s 0.01 1 1 ("IKcv"+$fitJointIK[$i]+$z+$side+".cv[0:99]");
//					xform -s 0 0 0 ("IKcv"+$fitJointIK[$i]+$z+$side+".cv[1:4]") ("IKcv"+$fitJointIK[$i]+$z+$side+".cv[11:14]");
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IKcv"+$fitJointIK[$i]+$z+$side+".cv[0:99]");
					parent ("IK"+$fitJointIK[$i]+"Locator"+$z+$side) ("IKcv"+$fitJointIK[$i]+$z+$side);
					}
				}

			//create IK ctrls
			for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
				{
				$ikControlNr=$q;
				asCreateController "IK" ($fitJointIK[$i]+$ikControlNr) $side $fitJointIKStartJoint[$i];
				//circleIcon for `inbetween-spline-ik-ctrls
				if (!($q==1 || $q==$fitJointIKNumCtrls[$i]))
					{
					circle -n tempCircle -c 0 0 0 -nr 1 0 0 -sw 360 -r (`getAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.controlPoints[0].xValue")`) -d 3 -ut 0 -tol 0.000393701 -s 8 -ch 0;
					parent -add -s tempCircleShape ("IK"+$fitJointIK[$i]+$ikControlNr+$side);
					delete tempCircle;
					delete ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape");
					rename tempCircleShape ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape");
					setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.overrideEnabled") 1;
					setAttr ("IK"+$fitJointIK[$i]+$ikControlNr+$side+"Shape.overrideColor") 13;
					}

				if ($q==1)
					delete `pointConstraint ($fitJointIKStartJoint[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side)`;
				else if ($q==$fitJointIKNumCtrls[$i])
					delete `pointConstraint ($fitJointIKEndJoint[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side)`;
				else
					{//inbetween IK ctrls
					$tempString=`pointConstraint ($fitJointIKStartJoint[$i]+$side)  ($fitJointIKEndJoint[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side)`;
					setAttr ($tempString[0]+"."+$fitJointIKStartJoint[$i]+$side+"W0") (1-(($q-1.0)/($fitJointIKNumCtrls[$i]-1.0)));
					setAttr ($tempString[0]+"."+$fitJointIKEndJoint[$i]+$side+"W1") (($q-1.0)/($fitJointIKNumCtrls[$i]-1.0));
					delete $tempString[0];
					}

				if ($q==1)
					parent ("IK"+$fitJointIK[$i]+"Locator"+"0"+$side) ("IK"+$fitJointIK[$i]+"1"+$side);
				if ($q==$fitJointIKNumCtrls[$i])
					parent ("IK"+$fitJointIK[$i]+"Locator"+($numCVs-1)+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);

				//LocalOrient1 & 2, for scaling
				createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) -p ("IK"+$fitJointIK[$i]+$ikControlNr+$side) transform;
				if ($ikControlNr==$fitJointIKNumCtrls[$i])
					asAlign ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) ($fitJointIKEndJoint[$i]+$side) 0 1 0 0;
				else
					asAlign ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) ($fitJointIKStartJoint[$i]+$side) 0 1 0 0;
				createNode -n ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient2"+$side) -p ("IK"+$fitJointIK[$i]+$ikControlNr+"LocalOrient1"+$side) transform;

				if ($ikLocal[$i])
					asAlign ("IKOffset"+$fitJointIK[$i]+$ikControlNr+$side) ($fitJoints[$i]+$side) 0 1 0 0;
				$rot=`xform -q -ws -ro ("IKSp"+$fitJointIKStartJoint[$i]+$side)`;
				xform -s 0.1 1 1 ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
				if (!$ikLocal[$i])
					xform -ws -ro $rot[0] $rot[1] $rot[2] ("IK"+$fitJointIK[$i]+$ikControlNr+$side+".cv[0:99]");
				}


			//IkcvVis (both from ikCvVis attribute and from FKIK.IKVis
			addAttr -k 1 -ln ikCvVis -at bool -dv 0 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			setAttr -k 0 -cb 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikCvVis");
			for ($z=0;$z<$numCVs;$z++)
				if ($z!=0 && $z!=$numCVs-1)
					connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".ikCvVis") ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+".v");

			//Ikcv constrained, to the 2 nearest IKctrls, and contrain-weighted according to distance to IKctrls
			for ($z=1;$z<$numCVs-1;$z++)
				{
				$pos=`xform -q -ws -t ("IKcv"+$fitJointIK[$i]+$z+$side)`;
				//$minDist1
				$minDist1=9999;
				for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
					{
					$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$q+$side)`;
					$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
					if ($dist<$minDist1)
						{
						$closestIkCtrlNr1=$q;
						$minDist1=$dist;
						}
					}
				//$minDist2
				$minDist2=9999;
				for ($q=1;$q<$fitJointIKNumCtrls[$i]+1;$q++)
					{
					if ($q==$closestIkCtrlNr1)
						continue;
					$pos2=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$q+$side)`;
					$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
					if ($dist<$minDist2)
						{
						$closestIkCtrlNr2=$q;
						$minDist2=$dist;
						}
					}

				//ensure $closestIkCtrlNr1 & $closestIkCtrlNr2 are sorted, for stiffness to work
				if ($z==1 && $closestIkCtrlNr2=="1")
					{
					$tempString[0]=$closestIkCtrlNr1;
					$tempString[1]=$minDist1;
					$closestIkCtrlNr1=$closestIkCtrlNr2;
					$minDist1=$minDist2;
					$closestIkCtrlNr2=$tempString[0];
					$minDist2=$tempString[1];
					}

				parentConstraint -mo ("IK"+$fitJointIK[$i]+$closestIkCtrlNr1+$side) ("IK"+$fitJointIK[$i]+$closestIkCtrlNr2+$side) ("IKOffsetcv"+$fitJointIK[$i]+$z+$side);
				setAttr ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr1+$side+"W0") ($minDist2/($minDist1+$minDist2));
				setAttr ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr2+$side+"W1") ($minDist1/($minDist1+$minDist2));

				//stiffness
				if ($z==1 || $z==$numCVs-2)
					{
					if ($z==1) $stiffCtrl1Nr=1;
					if ($z==$numCVs-2) $stiffCtrl1Nr=$fitJointIKNumCtrls[$i];

					addAttr -k 1 -ln stiff -at double -min 0 -max 10 -dv 5 ("IK"+$fitJointIK[$i]+$stiffCtrl1Nr+$side);
					createNode -n ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side) setRange;
					connectAttr ("IK"+$fitJointIK[$i]+$stiffCtrl1Nr+$side+".stiff") ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".valueX");
					connectAttr ("IK"+$fitJointIK[$i]+$stiffCtrl1Nr+$side+".stiff") ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".valueY");
					setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".minX") `getAttr ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr1+$side+"W0")`;
					setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".minY") `getAttr ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr2+$side+"W1")`;
					setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".maxX") 1;
					setAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".oldMax") -type float3 10 10 0;
					connectAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".outValueX") ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr1+$side+"W0");
					connectAttr ("IKStiff"+$fitJointIK[$i]+$stiffCtrl1Nr+"SetRange"+$side+".outValueY") ("IKOffsetcv"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$closestIkCtrlNr2+$side+"W1");
					}
				}

			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IK"+$fitJointIK[$i]+"Handle"+$side+".inCurve");

			createNode -n ("IKCurveInfo"+$fitJointIK[$i]+$side) curveInfo;
			connectAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+"Shape.worldSpace[0]") ("IKCurveInfo"+$fitJointIK[$i]+$side+".inputCurve");

			//IK spline stretchy
			addAttr -k 1 -ln stretchy -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".operation") 2;
			createNode -n ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side) multiplyDivide;
			setAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".operation") 2;
			connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".outputX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input1X");
			connectAttr ("Main.scaleX") ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".input2X");
			connectAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength") ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input1X");
			setAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".input2X") `getAttr ("IKCurveInfo"+$fitJointIK[$i]+$side+".arcLength")`;
			createNode -n ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
			setAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".stretchy") ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
			createNode -n ("stretchy"+$fitJointIK[$i]+"Reverse"+$side) reverse;
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".inputX");
			select `listRelatives -ad -type joint $startJoint`;
			select -d ("IKSp"+$fitJointIKEndJoint[$i]+$side);
			$tempString=`ls -sl`;
			for ($x=0;$x<size($tempString);$x++) 
				{
				createNode -n ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side) multiplyDivide;
				setAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input1X") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".input2X");

				createNode -n ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side) blendTwoAttr;
				connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".attributesBlender");
				setAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[0]") `getAttr ($tempString[$x]+".translateX")`;
				connectAttr ("stretchy"+$fitJointIK[$i]+"MultiplyDivide"+$x+$side+".outputX") ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".input[1]");
				connectAttr ("stretchy"+$fitJointIK[$i]+"BlendTwo"+$x+$side+".output") ($tempString[$x]+".translateX");
				}

			//twist
			asCreateUnTwister $fitJoints[$i] $side $fitJointIKStartJoint[$i] $side $fitJointIK[$i] $b 1 ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2");

			//Advanced Twist Control
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistControlEnable") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpType") 4;
			if (`attributeExists dForwardAxis ("IK"+$fitJointIK[$i]+"Handle"+$side)`)
				setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dForwardAxis") 0;
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpAxis") 3;
			setAttr -type float3 ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVector") 0 0 1;
			setAttr -type float3 ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorEnd") 0 0 1;

			connectAttr ("IK"+$fitJointIK[$i]+"1"+"LocalOrient2"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpMatrix");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpMatrixEnd");
//			connectAttr ("IKStiffOrient"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+""+$side+".worldMatrix") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpMatrixEnd");
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistValueType") 2;
			createNode -n ("IK"+$fitJointIK[$i]+"Ramp"+$side) ramp;
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".interpolation") 1;
			connectAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".outColor") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistRamp");
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList[0].color") -type double3 0 0 0;
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList[0].position") 0;
			setAttr ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistRampMult") 3.333;
			for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
				{
				setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].color") -type double3 0 0 0;
//				setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].position") ((1.0/($fitJointIKNumCtrls[$i]-1))*($z-1));
				//instead calculate percentage from a tempCurve, to better twist in correct place for non-even distributed joints
				$crvCmd="curve -n tempCurve -d 1";
				for ($a=0;$a<size($IKJoints);$a++)
					{
					$pos=`xform -q -ws -t ($IKJoints[$a]+$side)`;
					$crvCmd+=" -p "+$pos[0]+" "+$pos[1]+" "+$pos[2];
					}
				eval ($crvCmd);
				if (`objExists tempNearestPointOnCurve`) delete tempNearestPointOnCurve;
				createNode -n tempNearestPointOnCurve nearestPointOnCurve;
				connectAttr -f tempCurve.worldSpace[0] tempNearestPointOnCurve.inputCurve;
				$pos=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$z+$side)`;
				setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
				$posFactor=`getAttr tempNearestPointOnCurve.result.parameter`/(size($IKJoints)+0.0);
				delete tempCurve tempNearestPointOnCurve;
				setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].position") $posFactor;
				//Derive actual twist, based on `asCreateUnTwister`
				createNode -n ("TwistFollow"+$fitJointIK[$i]+$z+$side) -p TwistSystem transform;
				setAttr -l 1 ("TwistFollow"+$fitJointIK[$i]+$z+$side+".v") 0;
				parentConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) ("TwistFollow"+$fitJointIK[$i]+$z+$side);
				createNode -n ("TwistFollowOffset"+$fitJointIK[$i]+$z+$side) -p ("TwistFollow"+$fitJointIK[$i]+$z+$side) transform;
				parent ("TwistFollowOffset"+$fitJointIK[$i]+$z+$side) TwistSystem;
				parent ("TwistFollow"+$fitJointIK[$i]+$z+$side) ("TwistFollowOffset"+$fitJointIK[$i]+$z+$side);

				createNode -n ("TwistFollowParent"+$fitJointIK[$i]+$z+$side) -p TwistSystem transform;
				setAttr -l 1 ("TwistFollowParent"+$fitJointIK[$i]+$z+$side+".v") 0;
//				parentConstraint ("IK"+$fitJointIK[$i]+"1"+"LocalOrient2"+$side) ("TwistFollowParent"+$fitJointIK[$i]+$z+$side);
	
				createNode -n ("IK"+$fitJointIK[$i]+$z+"LocalOrient3"+$side) -p ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) transform;
				parent ("IK"+$fitJointIK[$i]+$z+"LocalOrient3"+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
				parentConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient3"+$side) ("TwistFollowParent"+$fitJointIK[$i]+$z+$side);
	
				createNode -n ("TwistFollowParentOffset"+$fitJointIK[$i]+$z+$side) -p ("TwistFollowParent"+$fitJointIK[$i]+$z+$side) transform;
				parent ("TwistFollowParentOffset"+$fitJointIK[$i]+$z+$side) TwistSystem;
				parent ("TwistFollowParent"+$fitJointIK[$i]+$z+$side) ("TwistFollowParentOffset"+$fitJointIK[$i]+$z+$side);

				select ("TwistFollowParent"+$fitJointIK[$i]+$z+$side);
				joint -n ("UnTwist"+$fitJointIK[$i]+$z+$side);
				joint -n ("UnTwistEnd"+$fitJointIK[$i]+$z+$side);
				setAttr ("UnTwistEnd"+$fitJointIK[$i]+$z+$side+".tx") ($height/12.0);
				select ("UnTwist"+$fitJointIK[$i]+$z+$side);
				joint -n ("TwistBalancer"+$fitJointIK[$i]+$z+$side);

				pointConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) ("UnTwist"+$fitJointIK[$i]+$z+$side);
				ikHandle -n ("UnTwistIK"+$fitJointIK[$i]+$z+$side) -ns 2 -sol "ikRPsolver" -sj ("UnTwist"+$fitJointIK[$i]+$z+$side) -ee ("UnTwistEnd"+$fitJointIK[$i]+$z+$side);
				parent ("UnTwistIK"+$fitJointIK[$i]+$z+$side) ("TwistFollow"+$fitJointIK[$i]+$z+$side);
				poleVectorConstraint ("UnTwist"+$fitJointIK[$i]+$z+$side) ("UnTwistIK"+$fitJointIK[$i]+$z+$side);
				parentConstraint ("IK"+$fitJointIK[$i]+$z+"LocalOrient2"+$side) ("TwistBalancer"+$fitJointIK[$i]+$z+$side);
				connectAttr ("TwistBalancer"+$fitJointIK[$i]+$z+$side+".rotateX") ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($z-1)+"].colorR");
				}
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($fitJointIKNumCtrls[$i])+"].color") -type double3 0 0 0;
			setAttr ("IK"+$fitJointIK[$i]+"Ramp"+$side+".colorEntryList["+($fitJointIKNumCtrls[$i])+"].position") 1;

			//flipAxis
			addAttr -k 0 -ln "flipAxis" -at "enum" -en "bend:side:" ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side) setRange;
//			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".min") -type float3 3 0 1;
			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".min") -type float3 0 1 0;
//			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".max") -type float3 0 1 0;
			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".max") -type float3 3 0 1;
			setAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".oldMax") -type float3 1 1 1;
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".value.valueX");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".value.valueY");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".value.valueZ");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValueY") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorY");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValueZ") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorZ");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValue.outValueY") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorEndY");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValue.outValueZ") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpVectorEndZ");
			connectAttr ("IK"+$fitJointIK[$i]+"FlipAxisSetRange"+$side+".outValue.outValueX") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dWorldUpAxis");
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".flipAxis") 1;

			//autoTwist & extraTwist
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".autoTwist") ("IK"+$fitJointIK[$i]+"Handle"+$side+".dTwistControlEnable");
			connectAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".extraTwist") ("IK"+$fitJointIK[$i]+"Handle"+$side+".twist");

			//IK spline Follow
			$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
			string $ikParent=$tempString[0];
			if ($ikParent=="DeformationSystem") $ikParent="RootX_M";
			if ($ikParent=="Root_M") $ikParent="LegLockConstrained";
			asFollow ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) $ikParent;
			setAttr ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+".follow") 10;

			//Extra Offset needed, since ParentConstraint does not work well with non-uniform scaled parent (e.g. squashed spine)
			createNode -n ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side) -p IKHandle transform;
			pointConstraint $ikParent ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side);
			orientConstraint $ikParent ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side);
//			parentConstraint -mo $ikParent ("IKOffset"+$fitJointIK[$i]+"1"+$side);
			parent ("IKOffset"+$fitJointIK[$i]+"1"+$side) ("IKOffsetConstrained"+$fitJointIK[$i]+"1"+$side);

			for ($z=2;$z<$fitJointIKNumCtrls[$i];$z++)
				{
				addAttr -k 1 -ln "followEnd" -at double -min 0 -max 10 -dv ((($z-1)/($fitJointIKNumCtrls[$i]-1.0))*10) ("IK"+$fitJointIK[$i]+$z+$side);
				asUnitConvertAndReverse ("IKFollowEnd"+$fitJointIK[$i]+$z+$side) ("IK"+$fitJointIK[$i]+$z+$side+".followEnd");
				parentConstraint -mo ("IK"+$fitJointIK[$i]+"1"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$z+$side);
				connectAttr ("IKFollowEnd"+$fitJointIK[$i]+$z+$side+"Reverse.outputX") ("IKOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+"1"+$side+"W0");
				connectAttr ("IKFollowEnd"+$fitJointIK[$i]+$z+$side+"UnitConversion.output") ("IKOffset"+$fitJointIK[$i]+$z+$side+"_parentConstraint1.IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side+"W1");
				}

			//IKAc
			createNode -n ("IKAc"+$fitJointIK[$i]+"Offset"+$side) -p IKJoints transform;
			asAlign ("IKAc"+$fitJointIK[$i]+"Offset"+$side) ($IKJoints[0]+$side)  1 1 0 0;
			createNode -n ("IKAc"+$fitJointIK[$i]+"Offset2"+$side) -p IKJoints transform;
			createNode -n ("IKAc"+$fitJointIK[$i]+"Offset3"+$side) -p IKJoints transform;
			setAttr ("IKAc"+$fitJointIK[$i]+"Offset3"+$side+".inheritsTransform") 0;//since we move by POCI
			asAlign ("IKAc"+$fitJointIK[$i]+"Offset2"+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side)  1 1 0 0;
			for ($y=0;$y<size($IKJoints);$y++)
				{
				select ("IKAc"+$fitJointIK[$i]+"Offset"+$side);
				joint -n ("IKAc"+$IKJoints[$y]+$side);
				}
			setAttr -l 1 ("IKAc"+$fitJointIK[$i]+"Offset"+$side+".v") 0;
			if (`objExists tempNearestPointOnCurve`) delete tempNearestPointOnCurve;
			createNode -n tempNearestPointOnCurve nearestPointOnCurve;
			connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") tempNearestPointOnCurve.inputCurve;
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKAcPoci"+$IKJoints[$y]+$side) pointOnCurveInfo;
				connectAttr -f ("IK"+$fitJointIK[$i]+"Curve"+$side+".worldSpace[0]") ("IKAcPoci"+$IKJoints[$y]+$side+".inputCurve");
				setAttr ("IKAcPoci"+$IKJoints[$y]+$side+".turnOnPercentage") 0;

				$pos=`xform -q -ws -t ("IKSp"+$IKJoints[$y]+$side)`;
				setAttr -type float3 tempNearestPointOnCurve.inPosition $pos[0] $pos[1] $pos[2];
				setAttr ("IKAcPoci"+$IKJoints[$y]+$side+".parameter") `getAttr tempNearestPointOnCurve.result.parameter`;
//				connectAttr -f ("IKAcPoci"+$IKJoints[$y]+$side+".position") ("IKAc"+$IKJoints[$y]+$side+".t");
				createNode -n ("IKAcPociXform"+$IKJoints[$y]+$side) -p ("IKAc"+$fitJointIK[$i]+"Offset3"+$side) transform;
				connectAttr -f ("IKAcPoci"+$IKJoints[$y]+$side+".position") ("IKAcPociXform"+$IKJoints[$y]+$side+".t");
				pointConstraint ("IKAcPociXform"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[$y]+$side);
//				tangentConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("IKSp"+$IKJoints[$y]+$side) ("IK"+$fitJointIK[$i]+"Curve"+$side) ("IKAc"+$IKJoints[$y]+$side);
				if ($y==0)
					$worldUpObject="IKfake0"+$fitJointIK[$i]+$side;
				else
					$worldUpObject="IKAc"+$IKJoints[$y-1]+$side;
				if ($y<(size($IKJoints)-1))
					{
					aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject $worldUpObject ("IKAc"+$IKJoints[$y+1]+$side) ("IKAc"+$IKJoints[$y]+$side);
					connectAttr ("IKSp"+$IKJoints[$y]+$side+".rx") ("IKAc"+$IKJoints[$y]+$side+"_aimConstraint1.offset.offsetX");
					}
				}
			delete tempNearestPointOnCurve;
			//Constraint to IKAc jointChain
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) -p ("IKAc"+$IKJoints[$y]+$side) transform;
				asAlign ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) ($IKJoints[$y]+$side) 1 1 0 0;

				//change from parent to point+orient constr. with offset, for better offset behaviour (for curvey splines)
				parent ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) ("IKAc"+$fitJointIK[$i]+"Offset2"+$side);
				if ($y>0)
					{
					pointConstraint -mo ("IKAc"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side);
					orientConstraint -mo ("IKAc"+$IKJoints[$y]+$side) ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side);
					}

				parentConstraint ("IKAc"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
				//connect scale so the Offset scales along
				connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".output.outputX") ("IKAc"+$IKJoints[$y]+$side+".sx");
				connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".output.outputX") ("IKAc"+$IKJoints[$y]+$side+".sy");
				connectAttr ("IKCurveInfoNormalize"+$fitJointIK[$i]+$side+".output.outputX") ("IKAc"+$IKJoints[$y]+$side+".sz");
				}
			//changing 1st IK joint due to FixedOrient
//			parent ("IKAc"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) IKJoints;

			//Constraint to IKSp jointChain
			for ($y=0;$y<size($IKJoints);$y++)
				{
				createNode -n ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) -p ("IKSp"+$IKJoints[$y]+$side) transform;
				asAlign ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ($IKJoints[$y]+$side) 1 1 0 0;

				//change from parent to point+orient constr. with offset, for better offset behaviour (for curvey splines)

				parent ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKSp"+$fitJointIK[$i]+"Offset"+$side);
				if ($y>0)
					{
					pointConstraint -mo ("IKSp"+$IKJoints[$y]+$side) ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side);
					orientConstraint -mo ("IKSp"+$IKJoints[$y]+$side) ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side);
					}

				parentConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);
				connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("IKX"+$IKJoints[$y]+$side+"_parentConstraint1.IKAc"+$IKJoints[$y]+"FollowOffset"+$side+"W0");
				connectAttr ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ("IKX"+$IKJoints[$y]+$side+"_parentConstraint1.IKSp"+$IKJoints[$y]+"FollowOffset"+$side+"W1");

				if ($IKJoints[$y]==$fitJointIKEndJoint[$i]) //fixedEnd replacement (always fixedEnd)
					{
					delete ("IKX"+$IKJoints[$y]+$side+"_parentConstraint1");
					$tempString=`pointConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKX"+$IKJoints[$y]+$side)`;
					$constraint=$tempString[0];
					$attrs=`listAttr -k -ud $constraint`;
					connectAttr ("stretchy"+$fitJointIK[$i]+"Reverse"+$side+".outputX") ($tempString[0]+"."+$attrs[0]);
					connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($tempString[0]+"."+$attrs[1]);
//not sure why this was change, but now qpeds gets non-def pose warning, so chaning back
//chaning this again, to remove -mo, as dragon got non-def pose warning
					orientConstraint ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKX"+$IKJoints[$y]+$side);
//					orientConstraint -mo ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+"LocalOrient2"+$side) ("IKX"+$IKJoints[$y]+$side);
//					orientConstraint -mo ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side) ("IKX"+$IKJoints[$y]+$side);
					}
				else
					parentConstraint ("IKSp"+$IKJoints[$y]+"FollowOffset"+$side) ("IKX"+$IKJoints[$y]+$side);

				}
			//changing 1st IK joint due to FixedOrient
//			parent ("IKSp"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) IKJoints;

			//adding FixedOrient Attribute added to first IK controller
			createNode -n ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side) -p ("IKfake0"+$fitJointIK[$i]+$side) transform;
			createNode -n ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) -p ("IK"+$fitJointIK[$i]+"1"+"LocalOrient2"+$side) transform;
			asAlign ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) ("IKfake0"+$fitJointIK[$i]+$side) 1 1 0 0;
			orientConstraint ("IKfake0"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side) ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side);
			addAttr -k 1 -ln "FixedOrient" -at double -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+"1"+$side);
			asUnitConvertAndReverse ("IKFixedOrient"+$fitJointIK[$i]+"1"+$side) ("IK"+$fitJointIK[$i]+"1"+$side+".FixedOrient");
			connectAttr ("IKFixedOrient"+$fitJointIK[$i]+"1"+$side+"Reverse.outputX") ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side+"_orientConstraint1.IKfake0"+$fitJointIK[$i]+$side+"W0");
			connectAttr ("IKFixedOrient"+$fitJointIK[$i]+"1"+$side+"UnitConversion.output") ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side+"_orientConstraint1.IK"+$fitJointIK[$i]+"1"+"LocalOrient3"+$side+"W1");
			parent ("IKAc"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) ("IKSp"+$fitJointIKStartJoint[$i]+"FollowOffset"+$side) ("IKFixedOrient"+$fitJointIKStartJoint[$i]+$side);
			}

		$tempString=`listRelatives -p ($fitJointIKStartJoint[$i]+$side)`;
		string $ikParent=$tempString[0];

		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			//PoleAim (PoleLeg avoid flipping in the forward plane)
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				createNode -n ("PoleAim"+$fitJointIK[$i]+$side) transform;
				asAlign ("PoleAim"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 1 0 0 0;
//				if ($msLegAim[$i]!="")
//					asAlign ("PoleAim"+$fitJointIK[$i]+$side) ($msLegAim[$i]+$side) 1 0 0 0;
				$tempString=`aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("IKFKAlignedOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side)`;
				$constraint=$tempString[0];
				parent ("PoleAim"+$fitJointIK[$i]+$side) ("IKHandle");
//				pointConstraint Root_M ("PoleAim"+$fitJointIK[$i]+$side);
				pointConstraint $ikParent ("PoleAim"+$fitJointIK[$i]+$side);
				}

			//Follow
			if (!`gmatch $fitJointIK[$i] "*Leg*"`)
				{
				asFollow ("IK"+$fitJointIK[$i]+$side) ("IKOffset"+$fitJointIK[$i]+$side) $ikParent;
				}
			if (`gmatch $fitJointIK[$i] "*Leg*"`)
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("PoleAim"+$fitJointIK[$i]+$side);
			else
				asFollow ("Pole"+$fitJointIK[$i]+$side) ("PoleOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);
			}
		}

//Advanced FKIK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;

		duplicate -n ("FKIK"+$fitJointIK[$i]+$side) "FKIK_icon";
		xform -ws -t 0 0 0 -ro 0 0 0 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".scale") $iconScaleFactor $iconScaleFactor $iconScaleFactor;
		setAttr ("FKIK"+$fitJointIK[$i]+$side+".rotateY") 90;
		makeIdentity -a 1 -t 1 -r 1 -s 1 ("FKIK"+$fitJointIK[$i]+$side);

		createNode -n ("FKIKParentConstraint"+$fitJointIK[$i]+$side) transform;
		$tempString=`listRelatives -p -type joint ($fitJointIKStartJoint[$i]+$side)`;
		string $parent=$tempString[0];
		if ($parent=="Root_M")
			parentConstraint LegLockConstrained ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		else if(`objExists $parent`)
			parentConstraint $parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		else
			parentConstraint ($fitJointIKStartJoint[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		parent ("FKIKParentConstraint"+$fitJointIK[$i]+$side) ("FKIKSystem");

		$sca=`xform -q -r -s $fitJointIKStartJoint[$i]`;
		$sca[0]*=$scale;$sca[1]*=$scale;$sca[2]*=$scale;
		parent ("FKIK"+$fitJointIK[$i]+$side) ($fitJointIKStartJoint[$i]+$side);
		setAttr -type float3 ("FKIK"+$fitJointIK[$i]+$side+".t") ($iconScaleFactor*$b*5) 0 ($iconScaleFactor*$b*5);
		//`fat` based side-distance
		if (`attributeExists fatZ $fitJoints[$i]`)
			{
			$pos=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[0]")`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side+".cv[5]")`;
			$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`*$b;
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") ((`getAttr ($fitJoints[$i]+".fat")`*`getAttr ($fitJoints[$i]+".fatZ")`*$b)+($dist/2.0));
			}

		//ensure its moved to `outside` direction
		if ($side!="_M")
			{
			$pos=`xform -q -ws -t ($fitJointIKStartJoint[$i]+$side)`;
			$pos2=`xform -q -ws -t ("FKIK"+$fitJointIK[$i]+$side)`;
			if ($side=="_R" && $pos2[0]>$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			if ($side=="_L" && $pos2[0]<$pos[0])
				setAttr ("FKIK"+$fitJointIK[$i]+$side+".tz") (`getAttr ("FKIK"+$fitJointIK[$i]+$side+".tz")`*-1);
			}

		parent ("FKIK"+$fitJointIK[$i]+$side) ("FKIKParentConstraint"+$fitJointIK[$i]+$side);
		asLockAttr ("FKIK"+$fitJointIK[$i]+$side) 1 1 1 1;

		addAttr -k 1 -ln FKIKBlend -at double -min 0 -max 10 -dv 0 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln autoVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -k 0 -cb 1 ("FKIK"+$fitJointIK[$i]+$side+".autoVis");
		addAttr -k 1 -ln FKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln IKVis -at bool -dv 1 ("FKIK"+$fitJointIK[$i]+$side);
		addAttr -ln startJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".startJoint") $fitJointIKStartJoint[$i];
		addAttr -ln middleJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".middleJoint") $fitJointIKMiddleJoint[$i];
		addAttr -ln endJoint -dt "string"  ("FKIK"+$fitJointIK[$i]+$side);
		setAttr -l 1 -type "string" ("FKIK"+$fitJointIK[$i]+$side+".endJoint") $fitJointIKEndJoint[$i];

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side) reverse;
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".inputX");

		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side) condition;
		createNode -n ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side) setRange;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".minX") 10;
		setAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".oldMaxX") 10;

		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".autoVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".firstTerm");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".IKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueR");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKVis") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfTrueG");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".valueX");
		connectAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseR");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"setRange"+$side+".outValueX") ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".colorIfFalseG");


		if ($fitJointIKSolver[$i]=="ikRPsolver")
			{
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("PoleOffset"+$fitJointIK[$i]+$side+".visibility");
			}
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			{
			for ($z=1;$z<$fitJointIKNumCtrls[$i]+1;$z++)
				connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKOffset"+$fitJointIK[$i]+$z+$side+".visibility");
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IK"+$fitJointIK[$i]+"Curve"+$side+".visibility");
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideEnabled") 1;
			setAttr ("IK"+$fitJointIK[$i]+"Curve"+$side+".overrideDisplayType") 1;
			}
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR")  ("IKParentConstraint"+$fitJointIKStartJoint[$i]+$side+".visibility");
		connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorG")  ("FKOffset"+$fitJointIKStartJoint[$i]+$side+".visibility");

		for ($y=1;$y<99;$y++)
			{
			if (!`objExists ("IKExtracv"+$fitJointIK[$i]+$y+$side)`)
				break;
			setAttr -l 0 ("IKExtracv"+$fitJointIK[$i]+$y+$side+".v");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKExtracv"+$fitJointIK[$i]+$y+$side+".v");
			}
		}


//FKIK connect to constraints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side+"_parentConstraint1")`)
			continue;

		if ($fitJointIK[$i]!="")
			{
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"Reverse"+$side+".outputX")       ($fitJoints[$i]+$side+"_parentConstraint1.FKX"+$fitJoints[$i]+$side+"W0");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ($fitJoints[$i]+$side+"_parentConstraint1.IKX"+$fitJoints[$i]+$side+"W1");
			}
	}

//Advanced IK, ikLocal used to get controller at start of IK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($isIKEnd[$i])
			continue;

		if ($ikLocal[$i])
			{
			asCreateController "IKLocal" ($fitJointIK[$i]+$fitJoints[$i]) $side $fitJoints[$i];
			if ($ikLocalType[$i]==2)//$ikLocal=localOrient 
				asAlign ("IKLocalOffset"+$fitJointIK[$i]+$fitJoints[$i]+$side) $fitJointIKStartJoint[$i] 0 1 0 0;
			parent ("IKLocalOffset"+$fitJointIK[$i]+$fitJoints[$i]+$side) ("FKParentConstraintTo"+$fitJointParent[$i]+$parentSide);
			parentConstraint -mo ("IKLocal"+$fitJointIK[$i]+$fitJoints[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side);
			connectAttr -f ("FKIKBlend"+$fitJointIK[$i]+"Condition"+$side+".outColorR") ("IKLocalOffset"+$fitJointIK[$i]+$fitJoints[$i]+$side+".visibility");
			}
		}


//Advanced FootRoll
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!`gmatch $fitJointLabel[$i] "*Foot*"`)
			continue;

		//find $ankle,$heel,$toes,$toesEnd & $footRollJoints
		$ankle=$fitJoints[$i];
		$heel="";$toes="";$toesEnd="";$bigToe="";$pinkyToe="";
		clear $footRollJoints;
		$tempString=`listRelatives -ad -type joint $ankle`;
//		for ($y=0;$y<size($tempString);$y++)
		for ($y=size($tempString)-1;$y>-1;$y--)
			{
			$childLabel=`asLabel $tempString[$y]`;
			if (`gmatch $childLabel "*Heel*"`)
				$heel=$tempString[$y];
			if (`gmatch $childLabel "*Toes*"` && !`gmatch $childLabel "*ToesEnd*"`)
				{
				$toes=$tempString[$y];
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
				}
			if (`gmatch $childLabel "*BigToe*"`)
				$bigToe=$tempString[$y];
			if (`gmatch $childLabel "*PinkyToe*"`)
				$pinkyToe=$tempString[$y];
			if (`gmatch $childLabel "*ToesEnd*"`)
				{
				$toesEnd=$tempString[$y];
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
				}
			//skip joints below Toes (that is not ToesEnd)
			$tempString2=`ls -l $tempString[$y]`;
			if (`gmatch $tempString2[0] ("*|"+$toes+"|*")` && $tempString[$y]!=$toesEnd)
				continue;
			//skip joints that end-up at Toes label $hasChildWithToesLabel (e.g claw attached to Ankle)
			$hasChildWithToesLabel=0;
			$tempString2=`listRelatives -ad -type joint $tempString[$y]`;
			for ($z=0;$z<size($tempString2);$z++)
				{
				$label=`asLabel $tempString2[$z]`;
				if (`gmatch $label "*Toes*"`)
					$hasChildWithToesLabel=1;
				}
			if (!$hasChildWithToesLabel)
				continue;
			if ($childLabel=="")
				$footRollJoints[size($footRollJoints)]=$tempString[$y];
			}
		if ($heel!="")
			$footRollJoints[size($footRollJoints)]=$heel;

		if ($toes=="" || $toesEnd=="")
			continue;

		addAttr -k 1 -ln swivel -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
//		addAttr -k 1 -ln toe -at double ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln roll -at double -min -5 -max 10 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln rollAngle -at double -dv 25 ("IK"+$fitJointIK[$i]+$side);

		connectAttr ("IK"+$fitJointIK[$i]+$side+".swivel") ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX");
		$tempString=`listConnections ("PoleAim"+$fitJointIK[$i]+$side+"_aimConstraint1.offset.offsetX")`;
		setAttr ($tempString[0]+".conversionFactor") 0.1;

		createNode -n ("IK"+$fitJointIK[$i]+"FootRoll"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
		$temp=`xform -q -ws -t ($fitJointIKEndJoint[$i]+$side)`;
		xform -ws -t $temp[0] $temp[1] $temp[2] ("IK"+$fitJointIK[$i]+"FootRoll"+$side);
		setAttr ("IK"+$fitJointIK[$i]+"FootRoll"+$side+".ry") ($footRotX[$i]*$b);

		//$footRollJoints  IK->Heel->ToeEnd->Toes->Hocks
		for ($y=0;$y<size($footRollJoints);$y++)
			{
			asCreateController "Roll" $footRollJoints[$y] $side $footRollJoints[$y];
			setAttr ("RollOffset"+$footRollJoints[$y]+$side+".ry") ($footRotX[$i]*$b);
			if ($y>0)
				parent ("RollOffset"+$footRollJoints[$y-1]+$side) ("Roll"+$footRollJoints[$y]+$side);
			}
		parent ("RollOffset"+$footRollJoints[size($footRollJoints)-1]+$side)  ("IK"+$fitJointIK[$i]+$side);

		//Pinky/index toe side2side rocking
		if (`objExists $toes` && `objExists $bigToe` && `objExists $pinkyToe`)
			{
			addAttr -k 1 -ln rock -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
//			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rotateOrder") 5;
			asAlign ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side) 1 1 0 0;
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $bigToe`)
				$pos=`xform -q -ws -t $bigToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("Roll"+$toes+$side);
			duplicate -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			$pos=`xform -q -ws -t $toes`;
			if (`objExists $pinkyToe`)
				$pos=`xform -q -ws -t $pinkyToe`;
			xform -ws -t ($pos[0]*$b) 0 $pos[2] ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+$side);

			createNode -n ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side) clamp;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".minR") -200;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rock") ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockInnerPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz");
			if ($side=="_L")
				{
				$tempString=`listConnections ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side+".rz")`;
				setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*-1);
				}
			createNode -n ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side) clamp;
			setAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".maxR") 200;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".rock") ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".inputR");
			connectAttr ("IK"+$fitJointIK[$i]+"FootRockOuterPivotClamp"+$side+".outputR") ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz");
			if ($side=="_L")
				{
				$tempString=`listConnections ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side+".rz")`;
				setAttr ($tempString[0]+".conversionFactor") (`getAttr ($tempString[0]+".conversionFactor")`*-1);
				}
			parent ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side) ("IK"+$fitJointIK[$i]+"FootRockInnerPivot"+$side);
			parent ("IKFKAligned"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			parent ("RollOffset"+$footRollJoints[size($footRollJoints)-1]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
				
			if (`objExists ("IKLocalOffset"+$fitJointIK[$i]+$side)`)
				parent ("IKLocalOffset"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"FootRockOuterPivot"+$side);
			}

		if ($ikLocal[$i] && $ikLocalType[$i]==0 && $heel!="")//$ikLocal=addCtrl
			{
			createNode -n ("RollOffsetOffset"+$heel+$side) -p ("IK"+$fitJointIK[$i]+$side) transform;
			asAlign ("RollOffsetOffset"+$heel+$side) ("RollOffset"+$heel+$side) 1 1 0 0;
			parent ("RollOffset"+$heel+$side) ("RollOffsetOffset"+$heel+$side);
			parent ("RollOffsetOffset"+$heel+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			parent ("IK"+$fitJointIK[$i]+"FootRoll"+$side) ("IKLocal"+$fitJointIK[$i]+$side);
			}

		for ($y=-1;$y<size($footRollJoints)-1;$y++)
			{
			if ($y==-1)
				$startJoint=$ankle;
			else
				$startJoint=$footRollJoints[$y];
			$endJoint=$footRollJoints[$y+1];
			if ($startJoint==$heel || $endJoint==$heel)
				continue;
			$tempString=`ikHandle -n ("IK"+$startJoint+"Handle"+$side) -s "sticky" -sol ikSCsolver -sj ("IKX"+$startJoint+$side) -ee ("IKX"+$footRollJoints[$y+1]+$side)`;
			rename $tempString[1] ("IK"+$startJoint+"Effector"+$side);
			parent ("IK"+$startJoint+"Handle"+$side) ("Roll"+$footRollJoints[$y+1]+$side);
			setAttr -l 1 ("IK"+$startJoint+"Handle"+$side+".v") 0;
			}

		//parent LegIKHandle to end of RollHierarchy
		if (`objExists ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side)`)
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("IK"+$fitJointIK[$i]+"FootRockReverse"+$side);
		else
			parent ("IK"+$fitJointIK[$i]+"Handle"+$side) ("Roll"+$footRollJoints[0]+$side);

		createNode -n ($fitJointIK[$i]+$side+"AngleReverse") multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ($fitJointIK[$i]+$side+"AngleReverse.input1X");
		setAttr ($fitJointIK[$i]+$side+"AngleReverse.input2X") -1;

		createNode -n ("IKRollAngle"+$fitJointIK[$i]+$side) setRange;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".roll") ("IKRollAngle"+$fitJointIK[$i]+$side+".valueZ");
		connectAttr ($fitJointIK[$i]+$side+"AngleReverse.output.outputX") ("IKRollAngle"+$fitJointIK[$i]+$side+".minX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxY");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".rollAngle") ("IKRollAngle"+$fitJointIK[$i]+$side+".maxZ");
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinX") -5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxY") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMinZ") 5;
		setAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".oldMaxZ") 10;

		for ($y=0;$y<size($footRollJoints);$y++)
			{
			if ($footRollJoints[$y]!=$heel && $footRollJoints[$y]!=$toes && $footRollJoints[$y]!=$toesEnd)
				continue;
			createNode -n ("RollRoller"+$footRollJoints[$y]+$side) -p ("RollOffset"+$footRollJoints[$y]+$side) transform;
			parent ("RollExtra"+$footRollJoints[$y]+$side) ("RollRoller"+$footRollJoints[$y]+$side);
			}

		if ($heel!="")
			connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueX") ("RollRoller"+$heel+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueY") ("RollRoller"+$toes+$side+".rotateX");
		connectAttr ("IKRollAngle"+$fitJointIK[$i]+$side+".outValueZ") ("RollRoller"+$toesEnd+$side+".rotateX");

		//IKToes (behaves as FKToes but for the IK)
		asCreateController "IK" $toes $side $toes;
		parent ("IKOffset"+$toes+$side) ("Roll"+$toesEnd+$side);
		setAttr ("IKOffset"+$toes+$side+".r") -type float3 0 0 0;
		createNode -n ("AlignIKTo"+$toes+$side) -p ("FKX"+$toes+$side)  transform;
		asAlign ("AlignIKTo"+$toes+$side) ("IK"+$toes+$side) 0 1 0 0;
		//circleIcon for IKToes
		duplicate -n tempToes ("FK"+$toes+$side);
		parent -add -s tempToesShape ("IK"+$toes+$side);
		delete tempToes;
		delete ("IK"+$toes+$side+"Shape");
		rename tempToesShape ("IK"+$toes+$side+"Shape");
		$pos=`xform -q -ws -t ("IK"+$toes+$side)`;
		rotate -r -p $pos[0] $pos[1] $pos[2] -os 0 -90 0 ("IK"+$toes+$side+"Shape.cv[0:99]");

		setAttr ("IK"+$toes+$side+"Shape.overrideEnabled") 1;
		setAttr ("IK"+$toes+$side+"Shape.overrideColor") 13;
		parent ("IK"+$toes+"Handle"+$side) ("IK"+$toes+$side);

		//$qtoes aim
		if ($fitJointQtoes[$i]!="")
			{
			createNode -n ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) -p ("IKX"+$fitJointIKStartJoint[$i]+$side) transform;
			parent ("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side);

			addAttr -k 1 -ln toesAim -dv 10 -min 0 -max 10 -at double ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side) unitConversion;
			setAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".conversionFactor") 0.1;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".toesAim") ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".input");
			createNode -n ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side) reverse;
			connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side+".inputX");

			createNode -n ("RollToesAim"+$toes+$side) -p ("RollOffset"+$toes+$side) transform;
			$tempString=`listRelatives -p ("RollOffset"+$toes+$side)`;
			parent ("RollToesAim"+$toes+$side) $tempString[0];
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
				-worldUpObject ("Pole"+$fitJointIK[$i]+$side)
				("RollToesAimTargetStatic"+$fitJointIK[$i]+$side) ("IKX"+$fitJointIKStartJoint[$i]+$side) 
				("RollToesAim"+$toes+$side);
			parent ("RollOffset"+$toes+$side) ("RollToesAim"+$toes+$side);
			connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimReverse"+$side+".outputX") ("RollToesAim"+$toes+$side+"_aimConstraint1.RollToesAimTargetStatic"+$fitJointIK[$i]+$side+"W0");
			connectAttr ("IK"+$fitJointIK[$i]+"RollToesAimMultiplyUnitConversion"+$side+".output") ("RollToesAim"+$toes+$side+"_aimConstraint1.IKX"+$fitJointIKStartJoint[$i]+$side+"W1");
			}
		}

//Advanced LegAim
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKStart[$i])
			continue;
		$tempString=`listRelatives -p $fitJoints[$i]`;
		$scapula=$tempString[0];
		if ($scapula!="")
			{
			$tempString[0]=`asLabel $scapula`;
			if (!`gmatch $tempString[0] "*LegAim*"`)
				continue;
			}

		addAttr -k 1 -ln legAim -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
//		addAttr -k 1 -ln legAimSDK -at double -min 0 -max 10 -dv 10 ("IK"+$fitJointIK[$i]+$side);
		$tempString=`listRelatives -p ("FKOffset"+$scapula+$side)`;
		$parent=$tempString[0];
		createNode -n ("LegAim"+$scapula+$side) -p $parent transform;
		asAlign ("LegAim"+$scapula+$side) ("FKOffset"+$scapula+$side) 1 1 0 0;
		duplicate -n ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		duplicate -n ("LegAimOff"+$scapula+$side) ("LegAim"+$scapula+$side);

//		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		aimConstraint -aimVector 1 0 0 -upVector 0 0 1 -worldUpVector 0 0 1 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("LegAimOff"+$scapula+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
//		aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpVector 0 1 0 -worldUpType "object" -worldUpObject ("Pole"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+$side) ("LegAimOn"+$scapula+$side);
		asAlign ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) 1 1 0 0;
		orientConstraint ("LegAimOff"+$scapula+$side) ("LegAimOn"+$scapula+$side) ("LegAim"+$scapula+$side);
		parent ("FKOffset"+$scapula+$side) ("LegAim"+$scapula+$side);

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side) unitConversion;
		setAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".legAim") ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".input");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side) multiplyDivide;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimUnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input1X");
		connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".input2X");

		createNode -n ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side) reverse;
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".inputX");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimMultiplyDivide"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOn"+$scapula+$side+"W1");
		connectAttr ("IK"+$fitJointIK[$i]+"LegAimReverse"+$side+".outputX") ("LegAim"+$scapula+$side+"_orientConstraint1.LegAimOff"+$scapula+$side+"W0");

		createNode -n ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistanceForLegAim"+$fitJointIK[$i]+$side);
		parent ("IKdistanceForLegAim"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".visibility") 0;

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".v") 0;
		parent ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side) IKMessure;
		duplicate -n ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);
		connectAttr ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".startPoint");
		connectAttr ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side+".translate") ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+".endPoint");
		pointConstraint ("LegAim"+$scapula+$side) ("IKmessureLocForLegAim2"+$fitJointIK[$i]+$side);
		pointConstraint ("IK"+$fitJointIK[$i]+$side) ("IKmessureLocForLegAim1"+$fitJointIK[$i]+$side);

		$defaultDistance=`getAttr ("IKdistanceForLegAim"+$fitJointIK[$i]+$side+"Shape.distance")`;
		$defaultAngleDirection=`getAttr ($fitJoints[$i]+$side+".jointOrientZ")`;
		$defaultAngle=90;
		if ($defaultAngleDirection>0)
			$defaultAngle=-90;
		$defaultUnstretchedLenght=0;
		$parent=$fitJointIKEndJoint[$i];
		while ($parent!=$fitJointIKStartJoint[$i])
			{
			$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;
			$tempString=`listRelatives -p $parent`;
			$parent=$tempString[0];
			}
		$defaultUnstretchedLenght+=`getAttr ($parent+".tx")`;

		createNode -n tempSampler -p ("FK"+$scapula+$side) transform;
		parent tempSampler ("LegAim"+$scapula+$side);
		$defaultOffsetAngle=`getAttr tempSampler.rz`;
		delete tempSampler;
		}

//Advanced Scaling
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

//		if ($fitJointIsEndJoint[$i])
//			continue;

		if ($fitJointIK[$i]!="")
			{
			createNode -n ("ScaleBlend"+$fitJoints[$i]+$side) blendColors;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color1") 1 1 1;
			setAttr -type float3 ("ScaleBlend"+$fitJoints[$i]+$side+".color2") 1 1 1;
			if (`objExists ("FK"+$fitJoints[$i]+$side)`)
				{
				connectAttr ("FK"+$fitJoints[$i]+$side+".sx") ("ScaleBlend"+$fitJoints[$i]+$side+".color2R");
				connectAttr ("FK"+$fitJoints[$i]+$side+".sy") ("ScaleBlend"+$fitJoints[$i]+$side+".color2G");
				connectAttr ("FK"+$fitJoints[$i]+$side+".sz") ("ScaleBlend"+$fitJoints[$i]+$side+".color2B");
				}
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".outputR") ($fitJoints[$i]+$side+".scaleX");
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".outputG") ($fitJoints[$i]+$side+".scaleY");
			connectAttr ("ScaleBlend"+$fitJoints[$i]+$side+".outputB") ($fitJoints[$i]+$side+".scaleZ");
			connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("ScaleBlend"+$fitJoints[$i]+$side+".blender");
			}
		else if (`objExists ("FK"+$fitJoints[$i]+$side)`)
			connectAttr ("FK"+$fitJoints[$i]+$side+".scale") ($fitJoints[$i]+$side+".scale");
		}

for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJoints[$i]==$fitJointIKEndJoint[$i] && $isIKEnd[$i])
			{
			if ($fitJointIKSolver[$i]=="ikRPsolver")
				{
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sx") ("ScaleBlend"+$fitJoints[$i]+$side+".color1R");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sy") ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".sz") ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
				connectAttr ("IK"+$fitJointIK[$i]+$side+".scale") ("IKX"+$fitJoints[$i]+$side+".scale");
				}
			if ($fitJointIKSolver[$i]=="ikSplineSolver")
				{
				$IKJoints=`asGetIKJoints $fitJointIKStartJoint[$i] $fitJointIKEndJoint[$i]`;
				for ($y=0;$y<size($IKJoints);$y++)
					{
					createNode -n ("IKScaler"+$IKJoints[$y]+$side) -p IKHandle transform;
					createNode -n ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side) multiplyDivide;
					connectAttr ("IKScaler"+$IKJoints[$y]+$side+".scale") ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".input1");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".outputX") ("ScaleBlend"+$IKJoints[$y]+$side+".color1R");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".outputY") ("ScaleBlend"+$IKJoints[$y]+$side+".color1G");
					connectAttr ("IKScale"+$IKJoints[$y]+"MultiplyDivide"+$side+".outputZ") ("ScaleBlend"+$IKJoints[$y]+$side+".color1B");
					for ($z=0;$z<$fitJointIKNumCtrls[$i];$z++)
						{
		        $yy=(1.0/(size($IKJoints)-1))*$y;
		        $zz=(1.0/($fitJointIKNumCtrls[$i]-1))*$z;
		        $weight=1-(abs($yy-$zz));
		        $weight=` smoothstep 0.5 1 $weight`;
						scaleConstraint -w $weight ("IK"+$fitJointIK[$i]+($z+1)+"LocalOrient2"+$side) ("IKScaler"+$IKJoints[$y]+$side);
						}
					$scalerWeight=((1.0 / (`size($IKJoints)`+1))*($y+1))*2;
					if ($scalerWeight>1)
						$scalerWeight=1-($scalerWeight-1);
					addAttr -k 1 -ln scalerWeight -at double -dv $scalerWeight ("IKScaler"+$IKJoints[$y]+$side);
					}
				}
			}
		}

//Advanced Stretchy (arms/legs)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if ($isIKBelowIKEnd[$i])
			continue;
		if ($fitJointIKSolver[$i]!="ikRPsolver")
			continue;
		if (`asIsMayaLT`)
			continue;

		addAttr -k 1 -ln stretchy -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);
		addAttr -k 1 -ln antiPop -at double  -min 0 -max 10 -dv 0 ("IK"+$fitJointIK[$i]+$side);

		createNode -n ("IKSetRangeStretch"+$fitJointIK[$i]+$side) setRange;
		createNode -n ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side) setRange;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".maxX") 1;
		setAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		setAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".oldMaxX") 10;
		connectAttr ("IK"+$fitJointIK[$i]+$side+".stretchy") ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".valueX");
		connectAttr ("IK"+$fitJointIK[$i]+$side+".antiPop") ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".valueX");

		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc1"+$fitJointIK[$i]+$side+".visibility") 0;
		pointConstraint ("IKX"+$fitJointIKStartJoint[$i]+$side)  ("IKmessureLoc1"+$fitJointIK[$i]+$side);
		parent ("IKmessureLoc1"+$fitJointIK[$i]+$side) ("IKMessure");
		$tempString=`spaceLocator`;
		rename $tempString[0] ("IKmessureLoc2"+$fitJointIK[$i]+$side);
		setAttr -l 1 ("IKmessureLoc2"+$fitJointIK[$i]+$side+".visibility") 0;
		asAlign ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 0 0 0;
		parent ("IKmessureLoc2"+$fitJointIK[$i]+$side) ("IKmessureLoc1"+$fitJointIK[$i]+$side);

		createNode -n ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) transform;
		asAlign ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) ("IK"+$fitJointIK[$i]+"Handle"+$side) 1 1 0 0;
		$tempString=`listRelatives -p ("IK"+$fitJointIK[$i]+"Handle"+$side)`;
		parent ("IKmessureConstrainTo"+$fitJointIK[$i]+$side) $tempString[0];
		pointConstraint ("IKmessureConstrainTo"+$fitJointIK[$i]+$side)  ("IKmessureLoc2"+$fitJointIK[$i]+$side);

		createNode -n ("IKdistance"+$fitJointIK[$i]+$side+"_Shape") distanceDimShape;
		$tempString=`listRelatives -p ("IKdistance"+$fitJointIK[$i]+$side+"_Shape")`;
		rename $tempString[0] ("IKdistance"+$fitJointIK[$i]+$side);
		parent ("IKdistance"+$fitJointIK[$i]+$side) ("IKMessure");
		setAttr -l 1 ("IKdistance"+$fitJointIK[$i]+$side+".visibility") 0;
		connectAttr ("IKmessureLoc2"+$fitJointIK[$i]+$side+".translate") ("IKdistance"+$fitJointIK[$i]+$side+".endPoint");
		createNode -n ("IKmessureDiv"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".operation") 2;
		setAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".input2X") $ikLenght[$i];

		$distance=`getAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance")`;
		createNode -n ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeAntiPop"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".attributesBlender");
		addAttr -ln antiPop -at double ("IKdistance"+$fitJointIK[$i]+$side+"Shape");
		setDrivenKeyframe -itt "spline" -ott "linear" -v $ikLenght[$i] -dv $ikLenght[$i] -cd ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape.antiPop");
		setKeyframe -itt "spline" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.1) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*1.2) -f ($ikLenght[$i]*1.2) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setKeyframe -itt "linear" -ott "spline" -v $ikLenght[$i] -f ($ikLenght[$i]*0.70) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		setKeyframe -itt "spline" -ott "spline" -v ($ikLenght[$i]*0.9) -f ($ikLenght[$i]*0.85) ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");

		selectKey ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		setInfinity -poi linear;
		duplicate -n ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
		cutKey -in 0 -in 1 -in 2 ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+".distance") ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.input");

		if ($fitJointIKMiddleJoint[$i]==$fitJointIKStartJoint[$i])//no knee joint, stretchy should also allow for `shortening`
			{
			setAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.preInfinity") 1;
			cutKey -in 0 -in 1 -in 2 ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop");
			setAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop.preInfinity") 1;
			}

		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_normal.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKdistance"+$fitJointIK[$i]+$side+"Shape_antiPop.output") ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".input[1]");

		createNode -n ("IKdistanceClamp"+$fitJointIK[$i]+$side) clamp;
		setAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".maxR") $ikLenght[$i];
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKdistanceClamp"+$fitJointIK[$i]+$side+".inputR");
		createNode -n ("IKmessureBlendStretch"+$fitJointIK[$i]+$side) blendTwoAttr;
		connectAttr ("IKSetRangeStretch"+$fitJointIK[$i]+$side+".outValueX") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".attributesBlender");
		connectAttr ("IKdistanceClamp"+$fitJointIK[$i]+$side+".outputR") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[0]");
		connectAttr ("IKmessureBlendAntiPop"+$fitJointIK[$i]+$side+".output") ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".input[1]");
		connectAttr ("IKmessureBlendStretch"+$fitJointIK[$i]+$side+".output") ("IKmessureDiv"+$fitJointIK[$i]+$side+".input1X");

		addAttr -k 1 -ln lock -at double -min 0 -max 10 ("Pole"+$fitJointIK[$i]+$side);
		createNode -n ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ("Pole"+$fitJointIK[$i]+$side+".lock") ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".input");

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			$temp[0]=`getAttr ($tempString[0]+".translateX")`;
			createNode -n ($tempString[0]+"_IKmessureDiv"+$side) multiplyDivide;
			setAttr ($tempString[0]+"_IKmessureDiv"+$side+".input2X") $temp[0];
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input1X");
//			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ($tempString[0]+".translateX");
			//IkLengtControl
			addAttr -k 1 -ln ("Lenght"+($a+1)) -at double -dv 1 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ($tempString[0]+"_IKLenght"+$side) multiplyDivide;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".Lenght"+($a+1)) ($tempString[0]+"_IKLenght"+$side+".input1X");
			setAttr ($tempString[0]+"_IKLenght"+$side+".input2X") $temp[0];
			connectAttr ($tempString[0]+"_IKLenght"+$side+".output.outputX") ($tempString[0]+"_IKmessureDiv"+$side+".input2X");
			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			//IkFatnessControl
			addAttr -k 1 -ln ("Fatness"+($a+1)) -at double -dv 0 ("IK"+$fitJointIK[$i]+$side);
			createNode -n ("fatness"+$tempString[0]) plusMinusAverage;
			connectAttr ("IK"+$fitJointIK[$i]+$side+".Fatness"+($a+1)) ("fatness"+$tempString[0]+".input1D[0]");

			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			//pole.lock
			createNode -n ("PoleLockBlender"+$tempString[0]) blendTwoAttr;
			connectAttr ($tempString[0]+"_IKmessureDiv"+$side+".output.outputX") ("PoleLockBlender"+$tempString[0]+".input[0]");
			connectAttr ("PoleLockBlender"+$tempString[0]+".output") ($tempString[0]+".translateX");
			connectAttr ("Pole"+$fitJointIK[$i]+"UnitConversion"+$side+".output")  ("PoleLockBlender"+$tempString[0]+".attributesBlender");
			createNode -n ($tempString[0]+"Distance") distanceBetween;
			connectAttr ("Pole"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix1");
			if ($a==0)
				connectAttr ("IKMessureFrom"+$fitJointIKStartJoint[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			else
				connectAttr ("IKmessureLoc2"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");//modified for Qtoes
//				connectAttr ("IK"+$fitJointIK[$i]+$side+".worldMatrix[0]") ($tempString[0]+"Distance.inMatrix2");
			createNode -n ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side) unitConversion;
			setAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".conversionFactor") $b;
//			connectAttr ($tempString[0]+"Distance.distance") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");
			//divide by Main.sy scale
			createNode -n ("PoleLockMainScaler"+$tempString[0]) multiplyDivide;
			setAttr ("PoleLockMainScaler"+$tempString[0]+".operation") 2;
			connectAttr ($tempString[0]+"Distance.distance") ("PoleLockMainScaler"+$tempString[0]+".input1X");
			connectAttr Main.sy ("PoleLockMainScaler"+$tempString[0]+".input2X");
			connectAttr ("PoleLockMainScaler"+$tempString[0]+".outputX") ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".input");

			connectAttr ("PoleDistanceSideReverse"+$tempString[0]+"UnitConversion"+$side+".output") ("PoleLockBlender"+$tempString[0]+".input[1]");

			//stretching applies to scaleX as well, unless twistJoints
/*
			$tempString2=`listRelatives -p -type joint $tempString[0]`;
			$tempString2[0]=`substring $tempString2[0] 4 99`;
			$tempString3=`listRelatives -c -type joint $tempString2[0]`;
			if (!`gmatch $tempString3[0] "*Part[0-9]*"`)
				{
				createNode -n ("PoleLockBlenderNormalize"+$tempString[0]) multiplyDivide;
				setAttr ("PoleLockBlenderNormalize"+$tempString[0]+".operation") 2;
				setAttr ("PoleLockBlenderNormalize"+$tempString[0]+".input2X") `getAttr ("PoleLockBlender"+$tempString[0]+".output")`;
				connectAttr ("PoleLockBlender"+$tempString[0]+".output") ("PoleLockBlenderNormalize"+$tempString[0]+".input1X");
				connectAttr ("PoleLockBlenderNormalize"+$tempString[0]+".outputX") ("ScaleBlend"+$tempString2[0]+".color1R");
				}
*/

			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}
		}

//HipSwinger
int $buildHipSwinger=`objExists Spine1_M`;
for ($i=0;$i<size($fitJoints);$i++)
	if (`asLabel $fitJoints[$i]`=="Root")
		if (`attributeExists hipSwinger $fitJoints[$i]`)
			if (`getAttr ($fitJoints[$i]+".hipSwinger")`==0)
				$buildHipSwinger=0;
if ($buildHipSwinger)
	{
	asCreateController "HipSwinger" "" "_M" "Spine1";
	if (`objExists FKIKBlendSpineCondition_M`)
		connectAttr FKIKBlendSpineCondition_M.outColorG HipSwingerOffset_M.v;
	asAlign HipSwingerOffset_M Root_M 0 1 0 0;
	parent HipSwinger_M HipSwingerOffset_M;
	delete HipSwingerExtra_M;
	parent HipSwingerOffset_M FKSystem;
	$pos=`xform -q -ws -t Root`;
	delete `pointConstraint Root Spine1 HipSwingerOffset_M`;
	setAttr HipSwingerOffset_M.tx (`getAttr Root.fat`*`getAttr Root.fatZ`*-1.4);
	parent HipSwingerOffset_M FKRoot_M;
	asLockAttr HipSwinger_M 1 0 1 0;

	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints Root`)
		$inbetweenJoints=`getAttr Root.inbetweenJoints`;

	createNode -n HipSwingerStabilizerTarget transform;
	if ($inbetweenJoints)
		asAlign HipSwingerStabilizerTarget HipSwinger_M 1 1 0 0;
	else
		{
		asAlign HipSwingerStabilizerTarget FKOffsetSpine1_M 1 1 0 0;
		asAlign HipSwingerStabilizerTarget Spine1 0 1 0 0;
		}

	parent HipSwingerStabilizerTarget FKRoot_M;
	createNode -n HipSwingReverse -p FKRoot_M transform;
	asAlign HipSwingReverse Spine1_M 1 0 0 0;

	$parent="HipSwingReverse";
	$inbetweenJoints=0;
	if (`attributeExists inbetweenJoints Root`)
		$inbetweenJoints=`getAttr Root.inbetweenJoints`;
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		createNode -n ("HipSwingReversePart"+$y) -p $parent transform;
		setAttr ("HipSwingReversePart"+$y+".tx") (`getAttr ("RootPart"+$y+"_M.tx")`*-1);
		duplicate -n ("HipSwingReverseXPart"+$y) ("HipSwingReversePart"+$y);
		if ($y>1)
			parent ("HipSwingReverseXPart"+$y) HipSwingReverse;
		orientConstraint ("HipSwingReversePart"+$y) ("HipSwingReverseXPart"+$y);
		$parent="HipSwingReversePart"+$y;
		}
	createNode -n HipSwingReverseRoot transform;
	asAlign HipSwingReverseRoot Root_M 1 1 0 0;

	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		orientConstraint HipSwingerStabilizerTarget HipSwinger_M ("HipSwingReversePart"+$y);
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwingerStabilizerTargetW0") (1-((1.0/($inbetweenJoints+1))*$y));
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.HipSwinger_MW1") ((1.0/($inbetweenJoints+1))*$y);
		setAttr ("HipSwingReversePart"+$y+"_orientConstraint1.interpType") 2;
		}

	//inbetween done by constraint-blend, hipSwing done with constraint-offset
	for ($y=1;$y<$inbetweenJoints+1;$y++)
		{
		if ($y==$inbetweenJoints)
			connectAttr ("HipSwingReverseXPart"+$y+".r") FKXRoot_M_orientConstraint1.offset;
		else
			connectAttr ("HipSwingReverseXPart"+($inbetweenJoints-$y)+".r") ("FKXRootPart"+$y+"_M_orientConstraint1.offset");
		}

	createNode -n HipSwingerStabilizer transform;
	if ($inbetweenJoints==0)
		{
		parent HipSwingReverseRoot HipSwingReverse;
		orientConstraint HipSwinger_M HipSwingReverse;
		parentConstraint HipSwingReverseRoot FKXRoot_M;

		parent HipSwingerStabilizer FKOffsetSpine1_M;
		xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
		parent FKExtraSpine1_M HipSwingerStabilizer;
		}
	else
		{
		parent HipSwingReverseRoot ("HipSwingReversePart"+$inbetweenJoints);
		orientConstraint HipSwinger_M HipSwingReverseRoot;
		pointConstraint HipSwingReverseRoot FKXRoot_M;

		parent HipSwingerStabilizer ("FKXRootPart"+$inbetweenJoints+"_M");
		xform -os -t 0 0 0 -ro 0 0 0 HipSwingerStabilizer;
		if (`objExists FKOffsetSpine1_M`)
			parent FKOffsetSpine1_M HipSwingerStabilizer;
		}

	orientConstraint HipSwingerStabilizerTarget HipSwingerStabilizer;	
	}

//CenterBetweenFeet
string $ikLegs[];
$tempString=`ls "IKLeg*_*"`;
for ($i=0;$i<size($tempString);$i++)
	if (`sets -im ControlSet $tempString[$i]`)
		$ikLegs[size($ikLegs)]=$tempString[$i];
if (size($ikLegs) && $centerBtwFeet)
	{
	createNode -n RootCenterBtwLegsBlended_M transform;
	asAlign RootCenterBtwLegsBlended_M Root_M 1 0 0 1;
	parent RootCenterBtwLegsBlended_M RootSystem;
	parent RootOffsetX_M RootCenterBtwLegsBlended_M;
	createNode -n RootCenterBtwLegsOffset_M -p RootSystem transform;
	asAlign RootCenterBtwLegsOffset_M Root_M 1 0 0 1;
	duplicate -n RootCenter_M RootCenterBtwLegsOffset_M;
	duplicate -n RootCenterBtwLegs_M RootCenterBtwLegsOffset_M;
	for ($i=0;$i<size($ikLegs);$i++)
		{
		pointConstraint -skip y $ikLegs[$i] RootCenterBtwLegs_M;
		orientConstraint -skip x -skip z $ikLegs[$i] RootCenterBtwLegs_M;
		}
	parent RootCenterBtwLegsOffset_M RootCenterBtwLegs_M;
	parentConstraint RootCenter_M RootCenterBtwLegsOffset_M RootCenterBtwLegsBlended_M;
	createNode -n CenterBtwLegsUnitConversion unitConversion;
	setAttr CenterBtwLegsUnitConversion.conversionFactor 0.1;
	addAttr -k 1 -ln CenterBtwFeet -at double -min 0 -max 10 RootX_M;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsUnitConversion.input;
	createNode -n CenterBtwLegsUnitReverse reverse;
	connectAttr CenterBtwLegsUnitConversion.output CenterBtwLegsUnitReverse.inputX;
	connectAttr CenterBtwLegsUnitConversion.output RootCenterBtwLegsBlended_M_parentConstraint1.RootCenterBtwLegsOffset_MW1;
	connectAttr CenterBtwLegsUnitReverse.outputX RootCenterBtwLegsBlended_M_parentConstraint1.RootCenter_MW0;
	createNode -n CenterBtwLegsNodeStateSetRange setRange;
	setAttr CenterBtwLegsNodeStateSetRange.minX 1;
	setAttr CenterBtwLegsNodeStateSetRange.oldMaxX 0.1;
	connectAttr RootX_M.CenterBtwFeet CenterBtwLegsNodeStateSetRange.valueX;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_pointConstraint1.nodeState;
	connectAttr CenterBtwLegsNodeStateSetRange.outValueX RootCenterBtwLegs_M_orientConstraint1.nodeState;
	}

//Locking
asLockAttr RootX_M 0 0 1 0;

//Advanced Twist
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointTwistJoints[$i])
			catchQuiet (`delete ($fitJoints[$i]+$side+"_parentConstraint1")`);
		else if (!$fitJointUpTwistJoints[$i])
			continue;refresh;

		asCreateUnTwister $fitJoints[$i] $side $fitJointParent[$i] $parentSide $fitJointIK[$i] $b 0 "";

		if ($fitJointTwistJoints[$i])
			{
			asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ($fitJoints[$i]+$side);
			parent ($fitJoints[$i]+$side+"_pointConstraint1") ConstraintSystem;	
			}

		int $numTwisters=$fitJointTwistJoints[$i]+1;
		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			$numTwisters=$fitJointUpTwistJoints[$i]+1;
		for ($y=0;$y<$numTwisters;$y++)
			{
			createNode -n ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side) multiplyDivide;
			createNode -n ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side) plusMinusAverage;
			createNode -n ("Twister"+$fitJoints[$i]+$y+$side) -p ("UnTwist"+$fitJoints[$i]+$side) transform;

			if ($fitJointTwistJoints[$i])
				{
				if ($y==0)
					$joint=$fitJoints[$i]+$side;
				else
					$joint=$fitJoints[$i]+"Part"+$y+$side;
				addAttr -k 1 -ln twistAmount -at double -min 0 -max 1 $joint;
				addAttr -k 1 -ln twistAddition -at double $joint;
				setAttr ($joint+".twistAmount") ($y/($fitJointTwistJoints[$i]+1.0));
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				connectAttr ($joint+".twistAddition") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[1]");
				orientConstraint ("Twister"+$fitJoints[$i]+$y+$side) $joint;
				parent ($joint+"_orientConstraint1") ConstraintSystem;
				}

//			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input1X");
			connectAttr ("TwistBalancer"+$fitJoints[$i]+$side+".twist") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input1X");
			connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[0]");
//			if ($fitJoints[$i]=="Root" && $y==0)
//				;//special case, Root untwister cycle avoidance, for when Bendy ctrl is added to Root-joint
//			else
				connectAttr ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".output1D") ("Twister"+$fitJoints[$i]+$y+$side+".rotateX");
			}
		}

//Advanced Twist ($fitJointUpTwistJoints)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpTwistJoints[$i] && !$fitJointTwistJoints[$i])
			for ($y=0;$y<$fitJointUpTwistJoints[$i]+1;$y++)
				{
				if ($y==0)
					$joint=$fitJointParent[$i]+$parentSide;
				else
					$joint=$fitJointParent[$i]+"Part"+$y+$parentSide;
				connectAttr ($joint+".twistAmount") ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".input2X");
				if ($fitJointParent[$i]=="Root")
print ("Skipping for Root: connectAttr twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX twistAddition"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1D[2];\n");
				else
					connectAttr ("twistAmountDivide"+$fitJoints[$i]+"Part"+$y+$side+".outputX") ("twistAddition"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1D[2]");
//				connectAttr -f ("TwistBalancer"+$fitJoints[$i]+$side+".rotateX") ("twistAmountDivide"+$fitJointParent[$i]+"Part"+$y+$parentSide+".input1X");
				}
		}

//Advanced BendyJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if (!$fitJointBendyJoints[$i])
			continue;

		string $crvCmd="curve -n Bend"+$fitJoints[$i]+"Curve"+$side+" -d 3";
		for ($z=0;$z<5;$z++)
			 $crvCmd+=" -p 0 0 0";
		eval ($crvCmd);
		$tempString=`listRelatives -s ("Bend"+$fitJoints[$i]+"Curve"+$side)`;
		rename $tempString[0] ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape");
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideEnabled") 1;
		setAttr ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.overrideDisplayType") 1;
		parent ("Bend"+$fitJoints[$i]+"Curve"+$side) BendSystem;

		createNode -n ("BendParentConstraint"+$fitJoints[$i]+$side) -p BendSystem transform;
		asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
//removed in v 5.621, as this cause issues when scaling FK. e.g. scale FKShoulder_R cause non-uniform spread of Part-joints
//restored in v 5.622, removing this caused main.scale side-effects
		asConstraintToFKIK "scale" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);

		createNode -n ("BendParentConstraintOffset"+$fitJoints[$i]+$side) -p BendSystem transform;
		asAlign ("BendParentConstraintOffset"+$fitJoints[$i]+$side) ("BendParentConstraint"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("BendParentConstraint"+$fitJoints[$i]+$side) ("BendParentConstraintOffset"+$fitJoints[$i]+$side);

		$bendControlNr=1;
		for ($z=0;$z<5;$z++)
			{
			if ($fitJointTwistJoints[$i]==0 && $z>0)
				{
				delete ("Bend"+$fitJoints[$i]+"Curve"+$side);
				break;
				}

			spaceLocator -n ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			setAttr -l 1 ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+".v") 0;
			connectAttr ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"Shape.worldPosition[0]") ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.controlPoints["+$z+"]");

			$posFactor=(1.0/4.0)*$z;

			$invPosFactor=1-$posFactor;
			$tempString=`pointConstraint -w $invPosFactor ($fitJoints[$i]+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side)`;
			pointConstraint -w $posFactor ($fitJointChild[$i]+$childSide) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);
			delete $tempString[0];

			if ($z==0)//Start
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==2 || $z==0)//Controllers
				{
				asCreateController "Bend" ($fitJoints[$i]+$bendControlNr) $side $fitJoints[$i];
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) BendSystem;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 0 0 0;
				asAlign ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("FK"+$fitJoints[$i]+$side) 0 1 0 0;
				parent ("BendOffset"+$fitJoints[$i]+$bendControlNr+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("Bend"+$fitJoints[$i]+$bendControlNr+$side);
				$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
				xform -s 0.1 1 1 ("Bend"+$fitJoints[$i]+$bendControlNr+$side+".cv[0:99]");
				$bendControlNr++;
				}
			if ($z==0)//Create BendStiff node
				{
				createNode -n ("BendStiff"+$fitJoints[$i]+$side) setRange;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".minX") 0;setAttr ("BendStiff"+$fitJoints[$i]+$side+".minY") 1;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxX") 1;setAttr ("BendStiff"+$fitJoints[$i]+$side+".maxY") 0;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinX") -10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMinY") -10;
				setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxX") 10;setAttr ("BendStiff"+$fitJoints[$i]+$side+".oldMaxY") 10;
				}
			if ($z==2)//`Bezier handles`(stiffness)
				{
				addAttr -k 1 -ln stiff -at double -min -10 -max 10 -dv 10 ("Bend"+$fitJoints[$i]+"2"+$side);
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".stiff") ("BendStiff"+$fitJoints[$i]+$side+".valueX");
				connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".stiff") ("BendStiff"+$fitJoints[$i]+$side+".valueY");
				}

			if ($z==1 || $z==3)//`Bezier handles`(stiffness)
				{
				createNode -n ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) -p ("BendParentConstraint"+$fitJoints[$i]+$side) transform;
				if ($z==1)
					parent ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"1"+$side);
				if ($z==3 && `objExists ("Bend"+$fitJointChild[$i]+"1"+$side)`)
					parent ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJointChild[$i]+"1"+$side);

				asAlign ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) 1 1 0 0;
				duplicate -n ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side);
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
				pointConstraint ("Bend"+$fitJoints[$i]+"BezOn"+$z+$side) ("Bend"+$fitJoints[$i]+"BezOff"+$z+$side) ("Bend"+$fitJoints[$i]+"Locator"+$z+$side);

				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueX") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOn"+$z+$side+"W0");
				connectAttr ("BendStiff"+$fitJoints[$i]+$side+".outValueY") ("Bend"+$fitJoints[$i]+"Locator"+$z+$side+"_pointConstraint1.Bend"+$fitJoints[$i]+"BezOff"+$z+$side+"W1");

				}
			if ($z==4)
				parent ("Bend"+$fitJoints[$i]+"Locator"+$z+$side) ("BendParentConstraint"+$fitJoints[$i]+$side);
			if ($z==3)
				{
				createNode -n ("Bend"+$fitJoints[$i]+"BezScale"+$side) -p ("Bend"+$fitJoints[$i]+"2"+$side) transform;
				parent ("Bend"+$fitJoints[$i]+"BezOn"+"1"+$side) ("Bend"+$fitJoints[$i]+"BezOn"+"3"+$side) ("Bend"+$fitJoints[$i]+"BezScale"+$side);
				if (`objExists ("IKmessureDiv"+$fitJointIK[$i]+$side)`)
					{
					if (!`objExists ("BendBezScale"+$fitJointIK[$i]+"BlendTwo"+$side)`)
						{
						createNode -n ("BendBezScale"+$fitJointIK[$i]+"BlendTwo"+$side) blendTwoAttr;
						connectAttr ("FKIKBlend"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("BendBezScale"+$fitJointIK[$i]+"BlendTwo"+$side+".attributesBlender");
						setAttr ("BendBezScale"+$fitJointIK[$i]+"BlendTwo"+$side+".input[0]") 1;
						connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".outputX") ("BendBezScale"+$fitJointIK[$i]+"BlendTwo"+$side+".input[1]");
						}
					connectAttr ("BendBezScale"+$fitJointIK[$i]+"BlendTwo"+$side+".output") ("Bend"+$fitJoints[$i]+"BezScale"+$side+".sx");
					}

//				parent ("Bend"+$fitJoints[$i]+"BezOn"+"1"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
//				parent ("Bend"+$fitJoints[$i]+"BezOn"+"3"+$side) ("Bend"+$fitJoints[$i]+"2"+$side);
				}
			}

		//Bend1 adds to ConstraintOffset
//		if ($fitJoints[$i]=="Root")
//			;//special case, Root untwister cycle avoidance, for when Bendy ctrl is added to Root-joint
//		else
		if (`objExists ($fitJoints[$i]+$side+"_orientConstraint1")`)
			{
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rotateY") ($fitJoints[$i]+$side+"_orientConstraint1.offsetY");
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rotateZ") ($fitJoints[$i]+$side+"_orientConstraint1.offsetZ");
			}


		//connect to twistJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{

			if ($y==0)
				$joint=$fitJoints[$i]+$side;
			else
				{
				$joint=$fitJoints[$i]+"Part"+$y+$side;
				delete ($joint+"_orientConstraint1");
				}
			if ($y==0)
				{
				delete (`listConnections -s 1 -d 0 ($fitJoints[$i]+$side+".tx")`);//could be point or parent constraint
				if ($fitJointTwistJoints[$i]==0 && `objExists ("Bend"+$fitJoints[$i]+"1"+$side)`) // Bendy Root
					orientConstraint ("Bend"+$fitJoints[$i]+"1"+$side) ($fitJoints[$i]+$side);
				}

			//bend hookup
			if ($y==0)
				{
				pointConstraint ("Bend"+$fitJoints[$i]+"1"+$side) $joint;				
				parent ($joint+"_pointConstraint1") ConstraintSystem;			

				//First BendyJoint spesial case
				if (`objExists ("Twister"+$fitJoints[$i]+"0"+$side)`)
					{
					delete ($joint+"_orientConstraint1");
					createNode -p ("Bend"+$fitJoints[$i]+"1"+$side) -n ($fitJoints[$i]+"BendTangent"+$side) transform;
					createNode -p ("Bend"+$fitJoints[$i]+"1"+$side) -n ($fitJoints[$i]+"BendStatic"+$side) transform;
					tangentConstraint -weight 1 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("Twister"+$fitJoints[$i]+"0"+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side) ($fitJoints[$i]+"BendTangent"+$side);

					orientConstraint ($fitJoints[$i]+"BendTangent"+$side) ($fitJoints[$i]+"BendStatic"+$side) $joint;
					addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 5 ("Bend"+$fitJoints[$i]+"1"+$side);
					asUnitConvertAndReverse ("BendFollow"+$fitJoints[$i]+"1"+$side) ("Bend"+$fitJoints[$i]+"1"+$side+".follow");
					connectAttr ("BendFollow"+$fitJoints[$i]+"1"+$side+"UnitConversion.output") ($fitJoints[$i]+$side+"_orientConstraint1."+$fitJoints[$i]+"BendTangent"+$side+"W0");
					connectAttr ("BendFollow"+$fitJoints[$i]+"1"+$side+"Reverse.outputX") ($fitJoints[$i]+$side+"_orientConstraint1."+$fitJoints[$i]+"BendStatic"+$side+"W1");

					parent ($joint+"_orientConstraint1") ConstraintSystem;
					connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".ry") ($fitJoints[$i]+$side+"_orientConstraint1.offsetY");
					connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rz") ($fitJoints[$i]+$side+"_orientConstraint1.offsetZ");
					}
				}
			else
				{
				createNode -n ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side) pointOnCurveInfo;
				connectAttr -f ("Bend"+$fitJoints[$i]+"Curve"+$side+"Shape.worldSpace[0]") ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".inputCurve");
				createNode -p BendSystem -n ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) transform;
				connectAttr -f ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".position") ($fitJoints[$i]+"PointOnCurveXform"+$y+$side+".t");
//				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".turnOnPercentage") 1;
				//make tempSurface, so a closestPointOnSurface node can find $parameter
				extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 ("Bend"+$fitJoints[$i]+"Curve"+$side);
				createNode -n tempClosestPointOnSurface closestPointOnSurface;
				spaceLocator -n tempClosestPointOnSurfaceLoc;
				connectAttr tempSurface.worldSpace[0] tempClosestPointOnSurface.inputSurface;
				connectAttr tempClosestPointOnSurfaceLoc.worldPosition[0] tempClosestPointOnSurface.inPosition;
				pointConstraint ($fitJoints[$i]+$side) ($fitJointChild[$i]+$childSide) tempClosestPointOnSurfaceLoc;
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJoints[$i]+$side+"W0") (1-((1.0/($fitJointTwistJoints[$i]+1.0))*$y));
				setAttr ("tempClosestPointOnSurfaceLoc_pointConstraint1."+$fitJointChild[$i]+$childSide+"W1")((1.0/($fitJointTwistJoints[$i]+1.0))*$y);
				$parameter=`getAttr tempClosestPointOnSurface.parameterU`;
				delete tempClosestPointOnSurface tempSurface tempClosestPointOnSurfaceLoc;
				setAttr ($fitJoints[$i]+"PointOnCurveInfo"+$y+$side+".parameter") $parameter;

				pointConstraint ($fitJoints[$i]+"PointOnCurveXform"+$y+$side) $joint;
				parent ($joint+"_pointConstraint1") ConstraintSystem;	
				tangentConstraint -weight 1 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("Twister"+$fitJoints[$i]+$y+$side) ("Bend"+$fitJoints[$i]+"Curve"+$side) $joint;
				parent ($joint+"_tangentConstraint1") ConstraintSystem;
				}
			}
		}

//Advanced BendyJoints (attached to parent)
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointUpBendyJoints[$i] && `objExists ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide)`)
			{
			if (!$fitJointBendyJoints[$i])//e.g. wrist
				asConstraintToFKIK "parent" $fitJointIK[$i] ("FKX"+$fitJoints[$i]+$side) ("IKX"+$fitJoints[$i]+$side) ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide);
			if ($fitJointBendyJoints[$i])//e.g. elbow
				parent ("Bend"+$fitJointParent[$i]+"Locator"+"4"+$parentSide) ("Bend"+$fitJoints[$i]+"1"+$side);
			}

		//twisty BendyJoints
		for ($y=0;$y<($fitJointTwistJoints[$i]+1);$y++)
			{
			if (!$fitJointBendyJoints[$i] || !$fitJointTwistJoints[$i])
				continue;
			//startTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"1"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1X");
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2X") (1-(1/($fitJointTwistJoints[$i]+0.00))*$y);
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputX") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[3]");
			//midTwister
			createNode -n ("BendTwistMult"+$fitJoints[$i]+"2"+"_"+$y+$side) multiplyDivide;
			connectAttr ("Bend"+$fitJoints[$i]+"2"+$side+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Y");
			$hf=(1.0/$fitJointTwistJoints[$i])*$y*2;
			if ($y>$fitJointTwistJoints[$i]/2) $hf=2-$hf;
			setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Y") $hf;
			connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputY") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[4]");
			//endTwister
			if (`objExists ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx")`)
				{
				connectAttr ("Bend"+$fitJointChild[$i]+"1"+$childSide+".rx") ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input1Z");
				setAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".input2Z") ((1/($fitJointTwistJoints[$i]+0.00))*$y);
				connectAttr ("BendTwistMult"+$fitJoints[$i]+"1"+"_"+$y+$side+".outputZ") ("twistAddition"+$fitJoints[$i]+"Part"+$y+$side+".input1D[5]");
				}
			}
		}

//Advanced distribution of twistJoints
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$childSide=$fitJointChildSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1 && $fitJointChildSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1) $childSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointTwistJoints[$i])
			continue;

		//Seem to work.Nope, makes foot unasable with stretchy leg
//		setAttr ($fitJoints[$i]+"Part"+"1"+$side+".segmentScaleCompensate") 0;

		//if there`s no ("FKX"+$fitJointChild[$i]+$childSide), the skip Advanced distribution
		if (!`objExists ("FKX"+$fitJointChild[$i]+$childSide)`)
			continue;

		string $contraintTo="FKX"+$fitJointChild[$i]+$childSide;
		if ($fitJointIK[$i]!="")
			{
			$contraintTo=("FKIKMix"+$fitJointChild[$i]+$childSide);
			createNode -n $contraintTo -p TwistSystem transform;
			if (`objExists $contraintTo`)
				asConstraintToFKIK "point" $fitJointIK[$i] ("FKX"+$fitJointChild[$i]+$childSide) ("IKX"+$fitJointChild[$i]+$childSide) $contraintTo;
			}

		//Above Knee(elbow) to follow Knee(elbow)
		if ($fitJointBendyJoints[$i] && !$fitJointUpBendyJoints[$i] && `objExists ("Bend"+$fitJointChild[$i]+"1"+$side)`)
			$contraintTo="Bend"+$fitJointChild[$i]+"1"+$side;

		if (!$fitJointBendyJoints[$i] && `objExists $contraintTo`)
			{
			for ($y=1;$y<$fitJointTwistJoints[$i]+1;$y++)
				{
				$tempString=`pointConstraint $contraintTo ($fitJoints[$i]+$side) ($fitJoints[$i]+"Part"+$y+$side)`;
				$constraint=$tempString[0];
				parent $constraint ConstraintSystem;
				setAttr ($constraint+"."+$contraintTo+"W0") ($y/($fitJointTwistJoints[$i]+1.0));
				setAttr ($constraint+"."+$fitJoints[$i]+$side+"W1") (1-($y/($fitJointTwistJoints[$i]+1.0)));
				}
			}
		//make bendy compatible with `stretchy`
		if ($fitJointBendyJoints[$i] && `objExists $contraintTo`)
			{
//			aimConstraint -offset 0 0 0 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($fitJoints[$i]+$side) $contraintTo ("BendOffset"+$fitJoints[$i]+"2"+$side);
			aimConstraint -offset 0 0 0 -aimVector $b 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ("Bend"+$fitJoints[$i]+"1"+$side) $contraintTo ("BendOffset"+$fitJoints[$i]+"2"+$side);
			pointConstraint ($fitJoints[$i]+$side) $contraintTo ("BendOffset"+$fitJoints[$i]+"2"+$side);
			//and SX
/*
			createNode -n ($fitJoints[$i]+"Distance"+$side) distanceBetween;
			connectAttr ($fitJoints[$i]+$side+".worldMatrix[0]") ($fitJoints[$i]+"Distance"+$side+".inMatrix1");
			connectAttr ($contraintTo+".worldMatrix[0]") ($fitJoints[$i]+"Distance"+$side+".inMatrix2");
			createNode -n ($fitJoints[$i]+"DistanceNormalizer"+$side) multiplyDivide;
			setAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".operation") 2;
			connectAttr ($fitJoints[$i]+"Distance"+$side+".distance") ($fitJoints[$i]+"DistanceNormalizer"+$side+".input1X");
			setAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".input2X") `getAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".input1X")`;

			createNode -n ($fitJoints[$i]+"DistanceNormalizerScaler"+$side) multiplyDivide;
			setAttr ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".operation") 2;
			connectAttr ($fitJoints[$i]+"DistanceNormalizer"+$side+".outputX") ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".input1X");
			connectAttr Main.scaleY ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".input2X");
			connectAttr ($fitJoints[$i]+"DistanceNormalizerScaler"+$side+".outputX") ("BendOffset"+$fitJoints[$i]+"2"+$side+".sx");
*/
			}
		}

//volume (Squash Scaling) - `IK setup` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if (`asIsMayaLT`)
			continue;

		$ikHandle = ("IK"+$fitJointIK[$i]+$side);
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			$ikHandle = ("IK"+$fitJointIK[$i]+$fitJointIKNumCtrls[$i]+$side);
		addAttr -k 1 -ln volume -at double -smn 0 -hsn 1 -smx 10 -hsx 1 -dv 10 $ikHandle;
		createNode -n ("volume"+$fitJointIK[$i]+"UnitConversion"+$side) unitConversion;
		setAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".conversionFactor") 0.1;
		connectAttr ($ikHandle+".volume") ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".input");
		createNode -n ("multWithStretchy"+$fitJointIK[$i]+$side) multiplyDivide;
		connectAttr ("volume"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input1X");
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("stretchy"+$fitJointIK[$i]+"UnitConversion"+$side+".output") ("multWithStretchy"+$fitJointIK[$i]+$side+".input2X");
		createNode -n ("volume1Over"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".operation") 2;
		if ($fitJointIKSolver[$i]=="ikSplineSolver")
			connectAttr ("IKCurveInfoAllMultiply"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");
		else
			connectAttr ("IKmessureDiv"+$fitJointIK[$i]+$side+".outputX") ("volume1Over"+$fitJointIK[$i]+$side+".input2X");			
		setAttr ("volume1Over"+$fitJointIK[$i]+$side+".input1X") 1;
		createNode -n ("volumepow"+$fitJointIK[$i]+$side) multiplyDivide;
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".operation") 3;
		connectAttr ("volume1Over"+$fitJointIK[$i]+$side+".outputX") ("volumepow"+$fitJointIK[$i]+$side+".input1X");
		setAttr ("volumepow"+$fitJointIK[$i]+$side+".input2X") 0.5;
		createNode -n ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side) blendTwoAttr;
		connectAttr ("multWithStretchy"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".attributesBlender");
		setAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[0]") 1;
		connectAttr ("volumepow"+$fitJointIK[$i]+$side+".outputX") ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".input[1]");
		}

//volume (Squash Scaling) - `Connect to scale` part
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJoints[$i]=="Root")
			continue;
		if ($isIKEnd[$i] || $isIKBelowIKEnd[$i])
			continue;

		if (`asIsMayaLT`)
			continue;

		string $volumeOutPlug="volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output";
		if (`objExists ("IKScaler"+$fitJoints[$i]+$side)`)
			{
			createNode -n ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side) plusMinusAverage;
			createNode -n ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side) plusMinusAverage;
			connectAttr ("volumeBlend"+$fitJointIK[$i]+"BlendTwo"+$side+".output") ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[0]");
			setAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".input1D[1]") -1;
			setAttr ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[1]") 1;

			createNode -n ("IKSquashDistributer"+$fitJoints[$i]+$side) multiplyDivide;
			connectAttr ("IKSquashDistributNormalizerA"+$fitJoints[$i]+$side+".output1D") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input1X");
			connectAttr ("IKScaler"+$fitJoints[$i]+$side+".scalerWeight") ("IKSquashDistributer"+$fitJoints[$i]+$side+".input2X");

			connectAttr ("IKSquashDistributer"+$fitJoints[$i]+$side+".outputX") ("IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".input1D[0]");
			$volumeOutPlug="IKSquashDistributNormalizerB"+$fitJoints[$i]+$side+".output1D";
			}

		if (`objExists ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side)`)//splineIkScaling
			{
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2X");
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Y");
			connectAttr $volumeOutPlug ("IKScale"+$fitJoints[$i]+"MultiplyDivide"+$side+".input2Z");
			}
		else
			{
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1R");
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1G");
			connectAttr $volumeOutPlug ("ScaleBlend"+$fitJoints[$i]+$side+".color1B");
			}
		}

//Advanced Ik Fatness
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIK[$i]=="")
			continue;
		if (!$isIKEnd[$i])
			continue;
		if ($isIKBelowIKEnd[$i])
			continue;
		if ($fitJointIKSolver[$i]!="ikRPsolver")
			continue;

		$tempString[0]=("IKX"+$fitJointIKStartJoint[$i]+$side);
		for ($a=0;$a<99;$a++)
			{
			//IkFatnessControl
			$tempString2[0]=`substitute "IKX" $tempString[0] ""`;
			$tempString3=`listConnections -p 1 ("ScaleBlend"+$tempString2[0]+".color1G")`;
			connectAttr $tempString3[0] ("fatness"+$tempString[0]+".input1D[1]");
			connectAttr -f ("fatness"+$tempString[0]+".output1D") ("ScaleBlend"+$tempString2[0]+".color1G");
			connectAttr -f ("fatness"+$tempString[0]+".output1D") ("ScaleBlend"+$tempString2[0]+".color1B");

			$tempString=`listRelatives -c -type joint ($tempString[0])`;
			if ($tempString[0]==("IKX"+$fitJointIKEndJoint[$i]+$side))
				break;
			}
		}

//Advanced Attach
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointsAttachTo[$i]=="")
			continue;

		if (`gmatch $fitJointsAttachTo[$i] "*_R"`)
			if ($side=="_L")
				{
				$tempString[0]=`substitute "_R" $fitJointsAttachTo[$i] "_L"`;
				if (`objExists $tempString[0]`)
					$fitJointsAttachTo[$i]=$tempString[0];
				}

		if (`objExists closestSampler`)
			delete closestSampler;
		createNode -n closestSampler closestPointOnMesh;
		connectAttr -f ($fitJointsAttachTo[$i]+".outMesh") closestSampler.inMesh;
		$temp=`xform -q -ws -t $fitJoints[$i]`;
		setAttr closestSampler.inPosition ($temp[0]*$b) $temp[1] $temp[2];
		int $closestFaceIndex=`getAttr closestSampler.closestFaceIndex`;
		delete closestSampler;
		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		$offsetParent=$tempString[0];
		createNode -n ("FKAttach"+$fitJoints[$i]+$side) transform;
		createNode -n ("Attach"+$fitJoints[$i]+$side) transform;
		createNode -n ("Detach"+$fitJoints[$i]+$side) transform;
		createNode -n ("FKAttachOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("FKAttachOffset"+$fitJoints[$i]+$side) $offsetParent 1 1 0 0;
		select -r ($fitJointsAttachTo[$i]+".f["+$closestFaceIndex+"]");
		select -add ("Attach"+$fitJoints[$i]+$side);
		doCreatePointOnPolyConstraintArgList 1 { "0","0","0","1","","1" };
		$tempString=`listConnections ("Attach"+$fitJoints[$i]+$side+".tx")`;
		if ($fitJointsAttachMode[$i]=="point")
			{
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateX") ("Attach"+$fitJoints[$i]+$side+".rx");
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateY") ("Attach"+$fitJoints[$i]+$side+".ry");
			disconnectAttr ($tempString[0]+".constraintRotate.constraintRotateZ") ("Attach"+$fitJoints[$i]+$side+".rz");
			}
		if ($fitJointsAttachMode[$i]=="orient")
			{
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateX") ("Attach"+$fitJoints[$i]+$side+".tx");
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateY") ("Attach"+$fitJoints[$i]+$side+".ty");
			disconnectAttr ($tempString[0]+".constraintTranslate.constraintTranslateZ") ("Attach"+$fitJoints[$i]+$side+".tz");
			}

		asAlign ("FKAttach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side) 1 1 0 0;
		asAlign ("Detach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side) 1 1 0 0;
		parent ("FKAttach"+$fitJoints[$i]+$side) ("Attach"+$fitJoints[$i]+$side)  ("Detach"+$fitJoints[$i]+$side) $offsetParent;

		parent ("FKAttachOffset"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKAttachOffset"+$fitJoints[$i]+$side);

		parentConstraint ("Attach"+$fitJoints[$i]+$side) ("Detach"+$fitJoints[$i]+$side) ("FKAttach"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln attach -at double -min 0 -max 10 -dv 10 ("FK"+$fitJoints[$i]+$side);
		createNode -n ("FK"+$fitJoints[$i]+$side+"AttachSetRange") setRange;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.minX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.minY") 1;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.maxX") 1;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.maxY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMinX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMinY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMaxX") 10;setAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.oldMaxY") 10;
		connectAttr ("FK"+$fitJoints[$i]+$side+".attach") ("FK"+$fitJoints[$i]+$side+"AttachSetRange.value.valueX");
		connectAttr ("FK"+$fitJoints[$i]+$side+".attach") ("FK"+$fitJoints[$i]+$side+"AttachSetRange.value.valueY");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.outValue.outValueX") ("FKAttach"+$fitJoints[$i]+$side+"_parentConstraint1."+"Attach"+$fitJoints[$i]+$side+"W0");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AttachSetRange.outValue.outValueY") ("FKAttach"+$fitJoints[$i]+$side+"_parentConstraint1."+"Detach"+$fitJoints[$i]+$side+"W1");
		}

//Advanced AimAt
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;

		if ($fitJointsAimAt[$i]=="" || !`objExists $fitJointsAimAt[$i]`)
			continue;

		if ($fitJointsAimAxis[$i]==0) {$x=1;$y=0;$z=0;}
		if ($fitJointsAimAxis[$i]==1) {$x=0;$y=1;$z=0;}
		if ($fitJointsAimAxis[$i]==2) {$x=0;$y=0;$z=1;}
		if ($fitJointsAimUpAxis[$i]==0) {$xUp=1;$yUp=0;$zUp=0;}
		if ($fitJointsAimUpAxis[$i]==1) {$xUp=0;$yUp=1;$zUp=0;}
		if ($fitJointsAimUpAxis[$i]==2) {$xUp=0;$yUp=0;$zUp=1;}

		$aimAtSide=$side;
		$pos=`xform -q -ws -t $fitJointsAimAt[$i]`;
		if ($pos[0]<$sideTreshold && $pos[0]>(-1*$sideTreshold))
			$aimAtSide="_M";
		
		if (!`objExists ("FK"+$fitJointsAimAt[$i]+$aimAtSide)`)
			{
			warning ("Unable to add aimAt, target not found:\"FK"+$fitJointsAimAt[$i]+$aimAtSide+"\"");
			continue;
			}

		createNode -n ("FKAimAt"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("AimAt"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("Static"+$fitJoints[$i]+$side) -p ("FKOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("AimAt"+$fitJoints[$i]+$side) ("FK"+$fitJointsAimAt[$i]+$aimAtSide) 1 1 0 0;
		asAlign ("Static"+$fitJoints[$i]+$side) ("FK"+$fitJointsAimAt[$i]+$aimAtSide) 1 1 0 0;
		parent ("FKExtra"+$fitJoints[$i]+$side) ("FKAimAt"+$fitJoints[$i]+$side);
		parent ("AimAt"+$fitJoints[$i]+$side) ("FK"+$fitJointsAimAt[$i]+$aimAtSide);

		aimConstraint -offset 0 0 0 -aimVector ($x*$b) ($y*$b) ($z*$b) -upVector ($xUp*$b) ($yUp*$b) ($zUp*$b) -worldUpType "objectrotation" -worldUpVector 0 $b 0 -worldUpObject ("AimAt"+$fitJoints[$i]+$side) ("AimAt"+$fitJoints[$i]+$side) ("Static"+$fitJoints[$i]+$side) ("FKAimAt"+$fitJoints[$i]+$side);

		addAttr -k 1 -ln aimAt -at double -min 0 -max 10 -dv 10 ("FK"+$fitJoints[$i]+$side);
		createNode -n ("FK"+$fitJoints[$i]+$side+"AimAtSetRange") setRange;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.minX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.minY") 1;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.maxX") 1;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.maxY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMinX") 0;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMinY") 0;
		setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMaxX") 10;setAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.oldMaxY") 10;
		connectAttr ("FK"+$fitJoints[$i]+$side+".aimAt") ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.value.valueX");
		connectAttr ("FK"+$fitJoints[$i]+$side+".aimAt") ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.value.valueY");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.outValue.outValueX") ("FKAimAt"+$fitJoints[$i]+$side+"_aimConstraint1."+"AimAt"+$fitJoints[$i]+$side+"W0");
		connectAttr ("FK"+$fitJoints[$i]+$side+"AimAtSetRange.outValue.outValueY") ("FKAimAt"+$fitJoints[$i]+$side+"_aimConstraint1."+"Static"+$fitJoints[$i]+$side+"W1");
		}

//Advanced CurveGuide
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointsCurveGuide[$i]=="")
			continue;

		if (!`objExists CurveGuideSystem`)
			{
			createNode -n CurveGuideSystem -p MotionSystem transform;
			setAttr -l 1 CurveGuideSystem.inheritsTransform 0;
			}
		
		$curveGuide=$fitJointsCurveGuide[$i]+$side;
		$tempString=`listRelatives -p $fitJointsCurveGuide[$i]`;
		if ($tempString[0]=="")
			parent $fitJointsCurveGuide[$i] FitSkeleton;
		if (`attributeExists curveGuide $fitJointsCurveGuide[$i]`) deleteAttr ($fitJointsCurveGuide[$i]+".curveGuide");
		if (!`objExists $curveGuide`)
			{
			duplicate -n $curveGuide $fitJointsCurveGuide[$i];
			makeIdentity -a 1 -t 1 -r 1 -s 1 $curveGuide;
			asLockAttr $curveGuide 1 1 1 1;
			sets -add ControlSet $curveGuide;
			setAttr ($curveGuide+"Shape.overrideEnabled") 1;
			setAttr ($curveGuide+"Shape.overrideColor") 17;
//			setAttr ($curveGuide+".v") 1;
			parent $curveGuide CurveGuideSystem;
			if ($side=="_L")
				scale -r -p 0 0 0 -1 1 1 ($curveGuide+".cv[0:999]");
			}

		$tempString=`listRelatives -p ("FKOffset"+$fitJoints[$i]+$side)`;
		$offsetParent=$tempString[0];
		createNode -n ("FKCurveGuide"+$fitJoints[$i]+$side) -p $offsetParent transform;
		asAlign ("FKCurveGuide"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 1 0 0;
//		rotate -r -os 0 0 -90 ("FKCurveGuide"+$fitJoints[$i]+$side);
//		duplicate -n ("FKCurveGuideUpVec"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

		createNode -n ("CurveGuideOnCurve"+$fitJoints[$i]+$side) -p ("FK"+$fitJoints[$i]+$side) transform;

		geometryConstraint $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);
		$pos=`xform -q -ws -t ("FK"+$fitJoints[$i]+$side)`;
		$pos2=`xform -q -ws -t ("CurveGuideOnCurve"+$fitJoints[$i]+$side)`;
		$dist=`mag<<$pos[0]-$pos2[0],$pos[1]-$pos2[1],$pos[2]-$pos2[2]>>`;
		delete ("CurveGuideOnCurve"+$fitJoints[$i]+$side+"_geometryConstraint1");
		setAttr -type float3 ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".t") ($dist*$b) 0 0;
		geometryConstraint $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);

		for ($y=0;$y<99;$y++)
			{
			setAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".ty") 0;
			setAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".tz") 0;
			}
		delete ("CurveGuideOnCurve"+$fitJoints[$i]+$side+"_geometryConstraint1");
		parent ("CurveGuideOnCurve"+$fitJoints[$i]+$side) CurveGuideSystem;

		extrude -n tempSurface -ch true -rn false -po 0 -et 0 -upn 1 -length 1 -rotation 0 -scale 1 -dl 3 $curveGuide;
		createNode -n tempSampler closestPointOnSurface;
		connectAttr tempSurface.worldSpace[0] tempSampler.inputSurface;
		connectAttr ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".translate") tempSampler.inPosition;

		createNode -n ("CurveGuideInfo"+$fitJoints[$i]+$side) pointOnCurveInfo;
		connectAttr -f ($curveGuide+".worldSpace") ("CurveGuideInfo"+$fitJoints[$i]+$side+".inputCurve");
		setAttr ("CurveGuideInfo"+$fitJoints[$i]+$side+".parameter") `getAttr tempSampler.result.parameterU`;

		connectAttr ("CurveGuideInfo"+$fitJoints[$i]+$side+".position") ("CurveGuideOnCurve"+$fitJoints[$i]+$side+".t");
		tangentConstraint -weight 1 -aimVector (-1*$b) 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $curveGuide ("CurveGuideOnCurve"+$fitJoints[$i]+$side);

		createNode -n ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) transform;
		$tempString=`listRelatives -p ("FKCurveGuide"+$fitJoints[$i]+$side)`;
		parent ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) $tempString[0];
		createNode -n ("CurveGuideStatic"+$fitJoints[$i]+$side) -p ("CurveGuideStaticOffset"+$fitJoints[$i]+$side) transform;
		asAlign ("CurveGuideStatic"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) 1 1 0 0;

		delete tempSurface tempSampler;

		asCreateController "IK" $fitJoints[$i] $side $fitJoints[$i];
		if (!`attributeExists guideTargetsVis Main`)
			{
			addAttr -k 1 -ln guideTargetsVis -at bool -dv 0 Main;
			setAttr -k 0 -cb 1 Main.guideTargetsVis;
			}
		connectAttr Main.guideTargetsVis ("IKOffset"+$fitJoints[$i]+$side+".v");
		xform -os -t 0 0 0 ("IKOffset"+$fitJoints[$i]+$side);
		scale -r -p 0 0 0 0.3 0.3 0.3 ("IK"+$fitJoints[$i]+$side+".cv[0:99]");
//		asAlign ("IKOffset"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) 1 1 0 0;
		parentConstraint ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideStatic"+$fitJoints[$i]+$side) ("IKOffset"+$fitJoints[$i]+$side);

		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 -1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("IK"+$fitJoints[$i]+$side) ("IK"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 -1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("CurveGuideStatic"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 90 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("FK"+$fitJointParent[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);
//		aimConstraint -offset 0 0 0 -aimVector (1*$b) 0 0 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("FKCurveGuideUpVec"+$fitJoints[$i]+$side) ("CurveGuideOnCurve"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

		if (!`attributeExists blend $curveGuide`)
			addAttr -k 1 -ln blend -at double -min 0 -max 10 -dv 10 $curveGuide;
		if (!`objExists ($curveGuide+"BlendUnitConversion")`)
			{
			createNode -n ($curveGuide+"BlendUnitConversion") unitConversion;
			setAttr ($curveGuide+"BlendUnitConversion.conversionFactor") 0.1;
			connectAttr ($curveGuide+".blend") ($curveGuide+"BlendUnitConversion.input");
			createNode -n ($curveGuide+"BlendReverse") reverse;
			connectAttr ($curveGuide+"BlendUnitConversion.output") ($curveGuide+"BlendReverse.inputX");
			}
//		connectAttr ($curveGuide+"BlendUnitConversion.output") ("FKCurveGuide"+$fitJoints[$i]+$side+"_aimConstraint1.CurveGuideOnCurve"+$fitJoints[$i]+$side+"W0");
//		connectAttr ($curveGuide+"BlendReverse.outputX") ("FKCurveGuide"+$fitJoints[$i]+$side+"_aimConstraint1.CurveGuideStatic"+$fitJoints[$i]+$side+"W1");
		connectAttr ($curveGuide+"BlendUnitConversion.output") ("IKOffset"+$fitJoints[$i]+$side+"_parentConstraint1.CurveGuideOnCurve"+$fitJoints[$i]+$side+"W0");
		connectAttr ($curveGuide+"BlendReverse.outputX") ("IKOffset"+$fitJoints[$i]+$side+"_parentConstraint1.CurveGuideStatic"+$fitJoints[$i]+$side+"W1");

		parent ("FKOffset"+$fitJoints[$i]+$side) ("FKCurveGuide"+$fitJoints[$i]+$side);

		//CurveGuide controllers
		$spans=`getAttr ($curveGuide+".spans")`;
		$degree=`getAttr ($curveGuide+".degree")`;
		$numCVs=$spans+$degree;
		for ($y=0;$y<$numCVs;$y++)
			{
			$side="_R";
			$pos=`xform -q -ws -t ($curveGuide+".cv["+$y+"]")`;
			if ($pos[0]==0) $side="_M";
			if ($pos[0]>0) $side="_L";
			$ctrl="IK"+$fitJointsCurveGuide[$i]+"Ctrl"+$y+$side;
			if (`objExists $ctrl`)
				continue;

			$tempString[0]=`curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4`;
			rename $tempString[0] $ctrl;
			$tempString=`listRelatives -s $ctrl`;
			rename $tempString[0] ($ctrl+"Shape");
			setAttr ($ctrl+"Shape.overrideEnabled") 1;
			setAttr ($ctrl+"Shape.overrideColor") 17;
			sets -add ControlSet $ctrl;
			scale -r -p 0 0 0 ($scale/1.0) ($scale/1.0) ($scale/1.0) ($ctrl+".cv[0:4]");
			createNode -n ($ctrl+"Offset") -p CurveGuideSystem transform;
			parent $ctrl ($ctrl+"Offset");
			$tempString=`spaceLocator`;
			rename $tempString[0] ($ctrl+"Loc");
			parent ($ctrl+"Loc") $ctrl;
			setAttr -l 1 ($ctrl+"Loc.v") 0;

			$pos=`xform -q -ws -t ($curveGuide+".cv["+$y+"]")`;
			xform -ws -t $pos[0] $pos[1] $pos[2] ($ctrl+"Offset");

			connectAttr -f ($ctrl+"Loc.worldPosition[0]") ($curveGuide+".controlPoints["+$y+"]");

			addAttr -k 1 -ln follow -at double -min 0 -max 10 -dv 10 $ctrl;
			createNode -n ($ctrl+"FollowSetRange") setRange;
			setAttr ($ctrl+"FollowSetRange.minX") 0;setAttr ($ctrl+"FollowSetRange.minY") 1;
			setAttr ($ctrl+"FollowSetRange.maxX") 1;setAttr ($ctrl+"FollowSetRange.maxY") 0;
			setAttr ($ctrl+"FollowSetRange.oldMinX") 0;setAttr ($ctrl+"FollowSetRange.oldMinY") 0;
			setAttr ($ctrl+"FollowSetRange.oldMaxX") 10;setAttr ($ctrl+"FollowSetRange.oldMaxY") 10;
			connectAttr ($ctrl+".follow") ($ctrl+"FollowSetRange.value.valueX");
			connectAttr ($ctrl+".follow") ($ctrl+"FollowSetRange.value.valueY");

			createNode -n ($ctrl+"FollowOn") -p $ctrl transform;
			createNode -n ($ctrl+"FollowOff") -p $ctrl transform;
			parent ($ctrl+"FollowOn") CurveGuideSystem;
			parent ($ctrl+"FollowOff") GlobalSystem;
			parentConstraint -mo `asNearestFeatherParent $ctrl $fitJointsCurveGuide[$i]` ($ctrl+"FollowOn");
			parentConstraint ($ctrl+"FollowOn") ($ctrl+"FollowOff") ($ctrl+"Offset");
			connectAttr ($ctrl+"FollowSetRange.outValue.outValueX") ($ctrl+"Offset_parentConstraint1."+$ctrl+"FollowOnW0");
			connectAttr ($ctrl+"FollowSetRange.outValue.outValueY") ($ctrl+"Offset_parentConstraint1."+$ctrl+"FollowOffW1");
			scaleConstraint MotionSystem ($ctrl+"Offset");
			}
		}

//Advanced Wheel
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$fitJointsWheel[$i])
			continue;

		if (!`objExists WheelSystem`)
			{
			createNode -n WheelSystem -p MotionSystem transform;
			setAttr -l 1 WheelSystem.inheritsTransform 0;
			}

		xform -os -t 0 -0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[0]");
		xform -os -t 0 0 -1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[1]");
		xform -os -t 0 0.783612 -0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[2]");
		xform -os -t 0 1.108194 0  ("FK"+$fitJoints[$i]+$side+"Shape.cv[3]");
		xform -os -t 0 0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[4]");
		xform -os -t 0 0 1.108194 ("FK"+$fitJoints[$i]+$side+"Shape.cv[5]");
		xform -os -t 0 -0.783612 0.783612 ("FK"+$fitJoints[$i]+$side+"Shape.cv[6]");
		xform -os -t 0 -1.108194 0 ("FK"+$fitJoints[$i]+$side+"Shape.cv[7]");

		$temp=`xform -q -ws -t $fitJoints[$i]`;
		$diameter=$temp[1]*2;
//		float $scaleFactor= $diameter * 1.1054;// 1.1054->nurbs
		$scaleFactor=$diameter/2.0;
		xform -ws -s $scaleFactor $scaleFactor $scaleFactor ("FK"+$fitJoints[$i]+$side+"Shape.cv[0:999]");
		addAttr -k 1 -ln "diameter" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 1 -ln "autoRoll" -at double -smn 0 -hsn 1 -smx 1 -hsx 1 -dv 1 ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosX" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosY" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);
		addAttr -k 0 -ln "prevPosZ" -at double -dv $diameter ("FK"+$fitJoints[$i]+$side);

		createNode -n ("prevPosOffset"+$fitJoints[$i]+$side) -p WheelSystem transform;
		createNode -n ("prevPos"+$fitJoints[$i]+$side) -p ("prevPosOffset"+$fitJoints[$i]+$side) transform;
		createNode -n ("prevPosAngler"+$fitJoints[$i]+$side) -p ("prevPos"+$fitJoints[$i]+$side) transform;
		createNode -n ("nowPos"+$fitJoints[$i]+$side) -p WheelSystem transform;
		pointConstraint ("FK"+$fitJoints[$i]+$side) ("nowPos"+$fitJoints[$i]+$side);
		asAlign ("prevPosOffset"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side) 1 0 0 0;
		$temp=`xform -q -ws -ro ("FK"+$fitJoints[$i]+$side)`;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rz") 90;
		setAttr ("prevPosOffset"+$fitJoints[$i]+$side+".rx") $temp[1];
		duplicate -n ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		parent ("prevPosSteer"+$fitJoints[$i]+$side) ("FK"+$fitJoints[$i]+$side);
		orientConstraint ("prevPosSteer"+$fitJoints[$i]+$side) ("prevPosAngler"+$fitJoints[$i]+$side);
		aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "vector" -worldUpVector 0 1 0 ("FK"+$fitJoints[$i]+$side) ("prevPos"+$fitJoints[$i]+$side);


		string $exp="";
		$exp+="float $diameter = FK"+$fitJoints[$i]+$side+".diameter;\n";
		$exp+="float $autoRoll = FK"+$fitJoints[$i]+$side+".autoRoll;\n";
		$exp+="float $sideAngle=prevPosAngler"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $prevPosX=FK"+$fitJoints[$i]+$side+".prevPosX;\n";
		$exp+="float $prevPosY=FK"+$fitJoints[$i]+$side+".prevPosY;\n";
		$exp+="float $prevPosZ=FK"+$fitJoints[$i]+$side+".prevPosZ;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateX=$prevPosX;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateY=$prevPosY;\n";
		$exp+="prevPosOffset"+$fitJoints[$i]+$side+".translateZ=$prevPosZ;\n";
		$exp+="float $nowPosX=nowPos"+$fitJoints[$i]+$side+".translateX;\n";
		$exp+="float $nowPosY=nowPos"+$fitJoints[$i]+$side+".translateY;\n";
		$exp+="float $nowPosZ=nowPos"+$fitJoints[$i]+$side+".translateZ;\n";
		$exp+="float $distance=`mag<<$nowPosX-$prevPosX,$nowPosY-$prevPosY,$nowPosZ-$prevPosZ>>`;\n";
		$exp+="float $curRotX=FKX"+$fitJoints[$i]+$side+".rotateX;\n";
		$exp+="float $piD = 3.14 * $diameter;\n";
		$exp+="FKX"+$fitJoints[$i]+$side+".rotateX=$curRotX+($distance/$piD)*360 * $autoRoll * "+($b*-1)+" * sin(deg_to_rad($sideAngle));\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosX=$nowPosX;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosY=$nowPosY;\n";
		$exp+="FK"+$fitJoints[$i]+$side+".prevPosZ=$nowPosZ;\n";

		expression -n ($fitJoints[$i]+"WheelExpression"+$side) -s $exp -o ("FKX"+$fitJoints[$i]+$side) -ae 1 -uc all ;

		}

if (`objExists FKOffsetRoot_M`)
	connectAttr -f jointLayer.drawInfo FKOffsetRoot_M.drawOverride;

//Lock FK
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		$parentSide=$fitJointParentSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointParentSide[$i]=="_R") $parentSide="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointIsEndJoint[$i])
			continue;
		if ($fitJointChild[$i]=="")
			continue;refresh;

		if ($fitJointLockTx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".tx");
		if ($fitJointLockTy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".ty");
		if ($fitJointLockTz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".tz");
		if ($fitJointLockRx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".rx");
		if ($fitJointLockRy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".ry");
		if ($fitJointLockRz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".rz");
		if ($fitJointLockSx[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sx");
		if ($fitJointLockSy[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sy");
		if ($fitJointLockSz[$i]) setAttr -k 0 -l 1 ("FK"+$fitJoints[$i]+$side+".sz");
		}

//Custom controller shapes
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!`objExists ($fitJoints[$i]+$side)`)
			continue;

		$pos=`xform -q -ws -t ($fitJoints[$i]+$side)`;
		$rot=`xform -q -ws -ro ($fitJoints[$i]+$side)`;
		$sca=`xform -q -r -s $fitJoints[$i]`;

		//Head 
		if (`gmatch $fitJoints[$i] "*Head*"` && $fitJointChild[$i]!="")
			{
			$pos2=`xform -q -ws -t $fitJointChild[$i]`;
			xform -r -s 2 2 2 ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			xform -r -ws -t ($pos2[0]-$pos[0]) ($pos2[1]-$pos[1]) ($pos2[2]-$pos[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
//			xform -s (1/$sca[0]) (1/$sca[1]) (1/$sca[2]) ("FK"+$fitJoints[$i]+$side+".cv[0:99]");//restore uniform scale first
//			float $frontAxisScale=`getAttr ($fitJoints[$i]+".s"+$U)`;
//			xform -s $frontAxisScale $frontAxisScale $frontAxisScale ("FK"+$fitJoints[$i]+$side+".cv[0:99]");
			}
		//IKLegs
		if (`gmatch $fitJointLabel[$i] "*Foot*"` && `objExists ("IK"+$fitJointIK[$i]+$side)`)
			{
			//First find $toesEnd
			$toesEnd="";
			$tempString=`listRelatives -ad -type joint $fitJoints[$i]`;
			for ($y=0;$y<size($tempString);$y++)
				{
				$childLabel=`asLabel $tempString[$y]`;
				if (`gmatch $childLabel "*ToesEnd*"`)
					$toesEnd=$tempString[$y];
				}
			int $numCVs=`getAttr ("IK"+$fitJointIK[$i]+$side+".spans")`+`getAttr ("IK"+$fitJointIK[$i]+$side+".degree")`;
			if ($toesEnd!="")
				for ($y=0;$y<$numCVs;$y++)
					{
					$temp=`xform -q -ws -t ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]")`;
					$temp2=`xform -q -ws -t ("IKX"+$fitJoints[$i]+$side)`;
					if ($fitJointQtoes[$i]!="")
						$temp2=`xform -q -ws -t ("IKX"+$fitJointQtoes[$i]+$side)`;
					$temp3=`xform -q -ws -t ($toesEnd+$side)`;
					if ($temp[1]<$temp2[1])
						{
						xform -ws -t $temp[0] 0 $temp[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						if ($temp[2]>$temp2[2])
							xform -ws -t $temp[0] 0 $temp3[2] ("IK"+$fitJointIK[$i]+$side+".cv["+$y+"]");
						}
					}
			$temp=`xform -q -ws -t ($fitJoints[$i]+$side)`;
			rotate -r -p $temp[0] $temp[1] $temp[2] -ws 0 ($footRotX[$i]*$b) 0 ("IK"+$fitJointIK[$i]+$side+".cv[0:99]");
			}
		}

//Default System values
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if (!$isIKEnd[$i])
			continue;

		if (`gmatch $fitJointLabel[$i] "*Foot*"`)
			{
			//Legs in IK
			setAttr ("FKIK"+$fitJointIK[$i]+$side+".FKIKBlend") 10;
			//Legs have pole follow
			setAttr ("Pole"+$fitJointIK[$i]+$side+".follow") 10;
			}
		}

delete "iconsGroup";

//Remove endJoints from DeformSet
string $deformJoints[]=`listRelatives -type joint -ad "DeformationSystem"`;
for ($i=0;$i<size($deformJoints);$i++)
	{
	$tempString=`listRelatives -c -type joint $deformJoints[$i]`;
	if ($tempString[0]=="")
		sets -rm DeformSet $deformJoints[$i];
	}

//delete $fitJointNonDef
for ($b=1;$b>-2;$b=$b-2)
	for ($i=0;$i<size($fitJoints);$i++)
		{
		$side=$fitJointSide[$i];
		if ($b==-1 && $fitJointSide[$i]=="_M") continue;
		if ($b==-1) $side="_L";
		if ($b==-1 && $fitJointNoMirror[$i]) continue;

		if ($fitJointNonDef[$i])
			delete ($fitJoints[$i]+$side);
		}

//Remove tempInbetweeners
for ($i=0;$i<size($fitJoints);$i++)
	if (`attributeExists tempInbetweener $fitJoints[$i]`)
		{
		$tempString=`listRelatives -c $fitJoints[$i]`;
		$tempString2=`listRelatives -p $fitJoints[$i]`;
		parent $tempString[0] $tempString2[0];
		reorder -front $tempString[0];//ensure it`s first child
		delete $fitJoints[$i];
		}

//buildPose
createNode -n "buildPose" dagPose;
select `sets -q ("ControlSet")`;
string $controlSetMembers[]=`ls -sl`;
string $setAttrCmd;
for ($i=0;$i<size($controlSetMembers);$i++)
	{
	int $kT=0;
	int $kR=0;
	int $kS=0;
	if (`getAttr -k ($controlSetMembers[$i]+".tx")`) $kT=1;
	if (`getAttr -k ($controlSetMembers[$i]+".rx")`) $kR=1;
	if (`getAttr -k ($controlSetMembers[$i]+".sx")`) $kS=1;
	if ($kT || $kR || $kS)
		$setAttrCmd+="xform -os ";
	if ($kT)
		{
		$temp=`xform -q -os -t $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-t "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kR)
		{
		$temp=`xform -q -os -ro $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-ro "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kS)
		{
		$temp=`xform -q -r -os -s $controlSetMembers[$i]`;
		$temp[0]=`asRoundOff $temp[0] 3`;$temp[1]=`asRoundOff $temp[1] 3`;$temp[2]=`asRoundOff $temp[2] 3`;
		$setAttrCmd+="-s "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
		}
	if ($kT || $kR || $kS)
		$setAttrCmd+=$controlSetMembers[$i]+";";
	$tempString=`listAttr -k -shortNames -ud $controlSetMembers[$i]`;
	for ($y=0;$y<size($tempString);$y++)
		$setAttrCmd+="setAttr "+$controlSetMembers[$i]+"."+$tempString[$y]+" "+`getAttr ($controlSetMembers[$i]+"."+$tempString[$y])`+";";
	}
if (!`attributeExists udAttr buildPose`)
	addAttr -ln udAttr -dt "string"  buildPose;
setAttr -type "string" buildPose.udAttr $setAttrCmd;

//Ensure mirrored controls
//asMirrorControlCurves 0 ControlSet;

//drivingSystems
$userAttrs=`listAttr -ud -s FitSkeleton`;
for ($i=0;$i<size($userAttrs);$i++)
	{
	if (!`gmatch $userAttrs[$i] "drivingSystem_*"`)
		continue;
	string $ds=`substitute "drivingSystem_" $userAttrs[$i] ""`;
	$numChar=size($ds);
	string $dsObjName=`substring $ds 1 ($numChar-2)`;
	string $dsSide=`substring $ds ($numChar-1) 99`;
	string $sdks[]=`listConnections ("FitSkeleton."+$userAttrs[$i])`;
	string $sdkPlugs[]=`listConnections -p 1 ("FitSkeleton."+$userAttrs[$i])`;

	//backwards compatibility, for DrivingSystems from versions prior to 5.593 (remove SDK[0-9] number)
	for ($y=0;$y<size($sdks);$y++)
		{
		if (`gmatch $sdks[$y] "SDK[0-9]*"`)
			rename $sdks[$y] ("SDK"+`substring $sdks[$y] 5 99`);
		}
	$sdks=`listConnections ("FitSkeleton."+$userAttrs[$i])`;

	for ($y=0;$y<size($sdks);$y++)
		{
		$newSDK=`substitute "prefix_" $sdks[$y] ""`;
		duplicate -n $newSDK $sdks[$y];
//		sets -add AllSet $newSDK;
		tokenize $sdkPlugs[$y] "." $tempString;
		string $dsAttrName=$tempString[1];

		tokenize $newSDK "_" $tempString;
		string $drivenObj=`substring $tempString[0] 4 99`;

		for ($z=1;$z<size($tempString)-1;$z++)
			$drivenObj+="_"+$tempString[$z];

		if (!`objExists $drivenObj`)
			continue;
		string $drivenAttr=$tempString[size($tempString)-1];
		while (`gmatch $drivenAttr "*[0-9]"`)
			{
			$numChar=size($drivenAttr);
			$drivenAttr=`substring $drivenAttr 1 ($numChar-1)`;
			}

		string $controllerName=$dsObjName+$dsSide;
		if (!`objExists $controllerName`)
			asDsCreateController $controllerName {$drivenObj};

		string $sdkXform="SDK"+$drivenObj;
		if (!`objExists $sdkXform`)
			asDsCreateSDKXform $drivenObj;

		if (`attributeExists $drivenAttr $sdkXform`)
			{
			$blendWeighted=`asEnsureBlendWeighted ($sdkXform+"."+$drivenAttr)`;
			connectAttr ($newSDK+".output") ($blendWeighted+".input["+`getAttr -s ($blendWeighted+".input")`+"]");
			refresh;//for the next connection to count `getAttr -s` correctly
			}
		else
			warning ("failed: connectAttr -f "+$newSDK+".output "+$sdkXform+"."+$drivenAttr+";");

		if (!`attributeExists $dsAttrName $ds`)
			{
			string $addAttrCmd="addAttr -k 1 -ln "+$dsAttrName+" -at \"float\"  ";
			if (`addAttr -q -hasMinValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMinValue 1 -minValue "+`addAttr -q -min ($newSDK+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasMaxValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasMaxValue 1 -maxValue "+`addAttr -q -max ($newSDK+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMinValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMinValue 1 -softMinValue "+`addAttr -q -softMinValue ($newSDK+"."+$dsAttrName)`+" ";
			if (`addAttr -q -hasSoftMaxValue ($newSDK+"."+$dsAttrName)`)
				$addAttrCmd+="-hasSoftMaxValue 1 -softMaxValue "+`addAttr -q -softMaxValue ($newSDK+"."+$dsAttrName)`+" ";
			$addAttrCmd+=$ds;
			eval ($addAttrCmd);
			setAttr -type "string" buildPose.udAttr (`getAttr buildPose.udAttr`+";setAttr "+$ds+"."+$dsAttrName+" 0;");
			}
		if (`attributeExists $dsAttrName $ds`)
			connectAttr -f ($ds+"."+$dsAttrName) ($newSDK+".input");
		}
	}

//delete any remaining un-used SDK`s
if (`attributeExists drivingSystem FitSkeleton`)
	$sdks=`listConnections -s 1 -d 0 FitSkeleton.drivingSystem`;
for ($y=0;$y<size($sdks);$y++)
	{
	$tempString=`listConnections -s 0 -d 1 ($sdks[$y]+".output")`;
	if (!size($tempString))
		delete $sdks[$y];
	}

asDsOptimizeControllers;

//selectionChildHighlighting
for ($i=0;$i<size($controlSetMembers);$i++)
	if (`attributeExists "selectionChildHighlighting" $controlSetMembers[$i]`)
		setAttr ($controlSetMembers[$i]+".selectionChildHighlighting") 0;

//Run
if (`attributeExists "run" FitSkeleton`)
	{
	string $run=`getAttr FitSkeleton.run`;
//	catch (`eval ($run)`);
	tokenize $run ";" $tempString;
	for ($i=0;$i<size($tempString);$i++)
		{
		if ($tempString[$i]=="")
			continue;
		if (catchQuiet (`eval ($tempString[$i])`)) warning ("Failed: "+$tempString[$i]+"\n");
		}
	}

//version
addAttr -ln version -at double Main;
setAttr -l 1 Main.version `asGetScriptVersion`;

//Allset
string $allAfter[]=`ls`;
string $myIntersector = `stringArrayIntersector`;
stringArrayIntersector -edit -intersect $allBefore $myIntersector;
stringArrayIntersector -edit -intersect $allAfter $myIntersector;
string $allSame[]=`stringArrayIntersector -query $myIntersector`;
deleteUI $myIntersector;
select $allAfter;
select -d $allSame;
select -ne -d "Sets" "Geometry";
select -d `ls -type ikSolver -type ikSystem`;
sets -add AllSet `ls -sl`;
select -cl;
sets -rm AllSet `listRelatives -ad FitSkeleton`;

//isHistoricallyInteresting
asSetIsHistoricallyInteresting ControlSet;

asUpdateButtonEnables;
print "// Build Complete\n";
}
